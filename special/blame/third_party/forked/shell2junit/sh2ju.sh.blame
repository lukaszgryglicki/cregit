0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	### Copyright 2010 Manuel Carrasco Mo√±ino. (manolo at apache.org)
0000000000000000000000000000000000000000;;	###
0000000000000000000000000000000000000000;;	### Licensed under the Apache License, Version 2.0.
0000000000000000000000000000000000000000;;	### You may obtain a copy of it at
0000000000000000000000000000000000000000;;	### http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	###
0000000000000000000000000000000000000000;;	### A library for shell scripts which creates reports in jUnit format.
0000000000000000000000000000000000000000;;	### These reports can be used in Jenkins, or any other CI.
0000000000000000000000000000000000000000;;	###
0000000000000000000000000000000000000000;;	### Usage:
0000000000000000000000000000000000000000;;	###     - Include this file in your shell script
0000000000000000000000000000000000000000;;	###     - Use juLog to call your command any time you want to produce a new report
0000000000000000000000000000000000000000;;	###        Usage:   juLog <options> command arguments
0000000000000000000000000000000000000000;;	###           options:
0000000000000000000000000000000000000000;;	###             -class="MyClass" : a class name which will be shown in the junit report
0000000000000000000000000000000000000000;;	###             -name="TestName" : the test name which will be shown in the junit report
0000000000000000000000000000000000000000;;	###             -error="RegExp"  : a regexp which sets the test as failure when the output matches it
0000000000000000000000000000000000000000;;	###             -ierror="RegExp" : same as -error but case insensitive
0000000000000000000000000000000000000000;;	###             -output="Path"   : path to output directory, defaults to "./results"
0000000000000000000000000000000000000000;;	###     - Junit reports are left in the folder 'result' under the directory where the script is executed.
0000000000000000000000000000000000000000;;	###     - Configure Jenkins to parse junit files from the generated folder
0000000000000000000000000000000000000000;;	###
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	asserts=00; errors=0; total=0; content=""
0000000000000000000000000000000000000000;;	date=`which gdate 2>/dev/null || which date`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# default output folder
0000000000000000000000000000000000000000;;	juDIR=`pwd`/results
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# The name of the suite is calculated based in your script name
0000000000000000000000000000000000000000;;	suite=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# A wrapper for the eval method witch allows catching seg-faults and use tee
0000000000000000000000000000000000000000;;	errfile=/tmp/evErr.$$.log
0000000000000000000000000000000000000000;;	function eVal() {
0000000000000000000000000000000000000000;;	  (eval "$1")
0000000000000000000000000000000000000000;;	  # stdout and stderr may currently be inverted (see below) so echo may write to stderr
0000000000000000000000000000000000000000;;	  echo $? 2>&1 | tr -d "\n" > $errfile
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Method to clean old tests
0000000000000000000000000000000000000000;;	function juLogClean() {
0000000000000000000000000000000000000000;;	  echo "+++ Removing old junit reports from: $juDIR "
0000000000000000000000000000000000000000;;	  rm -f "$juDIR"/junit-*
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Execute a command and record its results
0000000000000000000000000000000000000000;;	function juLog() {
0000000000000000000000000000000000000000;;	  suite="";
0000000000000000000000000000000000000000;;	  errfile=/tmp/evErr.$$.log
0000000000000000000000000000000000000000;;	  date=`which gdate || which date`
0000000000000000000000000000000000000000;;	  asserts=00; errors=0; total=0; content=""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # parse arguments
0000000000000000000000000000000000000000;;	  ya=""; icase=""
0000000000000000000000000000000000000000;;	  while [ -z "$ya" ]; do
0000000000000000000000000000000000000000;;	    case "$1" in
0000000000000000000000000000000000000000;;	  	  -name=*)   name=`echo "$1" | sed -e 's/-name=//'`;   shift;;
0000000000000000000000000000000000000000;;	  	  -class=*)  class=`echo "$1" | sed -e 's/-class=//'`;   shift;;
0000000000000000000000000000000000000000;;	      -ierror=*) ereg=`echo "$1" | sed -e 's/-ierror=//'`; icase="-i"; shift;;
0000000000000000000000000000000000000000;;	      -error=*)  ereg=`echo "$1" | sed -e 's/-error=//'`;  shift;;
0000000000000000000000000000000000000000;;	      -output=*) juDIR=`echo "$1" | sed -e 's/-output=//'`;  shift;;
0000000000000000000000000000000000000000;;	      *)         ya=1;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # create output directory
0000000000000000000000000000000000000000;;	  mkdir -p "$juDIR" || exit
0000000000000000000000000000000000000000;;	  # use first arg as name if it was not given
0000000000000000000000000000000000000000;;	  if [ -z "$name" ]; then
0000000000000000000000000000000000000000;;	    name="$asserts-$1"
0000000000000000000000000000000000000000;;	    shift
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ "$class" = "" ]]; then
0000000000000000000000000000000000000000;;	    class="default"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  suite=$class
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # calculate command to eval
0000000000000000000000000000000000000000;;	  [ -z "$1" ] && return
0000000000000000000000000000000000000000;;	  cmd="$1"; shift
0000000000000000000000000000000000000000;;	  while [ -n "$1" ]
0000000000000000000000000000000000000000;;	  do
0000000000000000000000000000000000000000;;	     cmd="$cmd \"$1\""
0000000000000000000000000000000000000000;;	     shift
0000000000000000000000000000000000000000;;	  done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # eval the command sending output to a file
0000000000000000000000000000000000000000;;	  outf=/var/tmp/ju$$.txt
0000000000000000000000000000000000000000;;	  errf=/var/tmp/ju$$-err.txt
0000000000000000000000000000000000000000;;	  >$outf
0000000000000000000000000000000000000000;;	  echo ""                         | tee -a $outf
0000000000000000000000000000000000000000;;	  echo "+++ Running case: $class.$name " | tee -a $outf
0000000000000000000000000000000000000000;;	  echo "+++ working dir: "`pwd`           | tee -a $outf
0000000000000000000000000000000000000000;;	  echo "+++ command: $cmd"            | tee -a $outf
0000000000000000000000000000000000000000;;	  ini=`$date +%s.%N`
0000000000000000000000000000000000000000;;	  # execute the command, temporarily swapping stderr and stdout so they can be tee'd to separate files,
0000000000000000000000000000000000000000;;	  # then swapping them back again so that the streams are written correctly for the invoking process
0000000000000000000000000000000000000000;;	  ( (eVal "$cmd" | tee -a $outf) 3>&1 1>&2 2>&3 | tee $errf) 3>&1 1>&2 2>&3
0000000000000000000000000000000000000000;;	  evErr=`cat $errfile`
0000000000000000000000000000000000000000;;	  rm -f $errfile
0000000000000000000000000000000000000000;;	  end=`$date +%s.%N`
0000000000000000000000000000000000000000;;	  echo "+++ exit code: $evErr"        | tee -a $outf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # set the appropriate error, based in the exit code and the regex
0000000000000000000000000000000000000000;;	  [ $evErr != 0 ] && err=1 || err=0
0000000000000000000000000000000000000000;;	  out=`cat $outf | sed -e 's/^\([^+]\)/| \1/g'`
0000000000000000000000000000000000000000;;	  if [ $err = 0 -a -n "$ereg" ]; then
0000000000000000000000000000000000000000;;	      H=`echo "$out" | egrep $icase "$ereg"`
0000000000000000000000000000000000000000;;	      [ -n "$H" ] && err=1
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  [ $err != 0 ] && echo "+++ error: $err"         | tee -a $outf
0000000000000000000000000000000000000000;;	  rm -f $outf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  errMsg=`cat $errf`
0000000000000000000000000000000000000000;;	  rm -f $errf
0000000000000000000000000000000000000000;;	  # calculate vars
0000000000000000000000000000000000000000;;	  asserts=$(($asserts+1))
0000000000000000000000000000000000000000;;	  errors=$(($errors+$err))
0000000000000000000000000000000000000000;;	  time=`echo "$end - $ini" | bc -l`
0000000000000000000000000000000000000000;;	  total=`echo "$total + $time" | bc -l`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  # write the junit xml report
0000000000000000000000000000000000000000;;	  ## failure tag
0000000000000000000000000000000000000000;;	  [ $err = 0 ] && failure="" || failure="
0000000000000000000000000000000000000000;;	      <failure type=\"ScriptError\" message=\"Script Error\">
0000000000000000000000000000000000000000;;	      <![CDATA[
0000000000000000000000000000000000000000;;	      $errMsg
0000000000000000000000000000000000000000;;	      ]]>
0000000000000000000000000000000000000000;;	      </failure>
0000000000000000000000000000000000000000;;	  "
0000000000000000000000000000000000000000;;	  ## testcase tag
0000000000000000000000000000000000000000;;	  content="$content
0000000000000000000000000000000000000000;;	    <testcase assertions=\"1\" name=\"$name\" time=\"$time\" classname=\"$class\">
0000000000000000000000000000000000000000;;	    $failure
0000000000000000000000000000000000000000;;	    <system-err>
0000000000000000000000000000000000000000;;	<![CDATA[
0000000000000000000000000000000000000000;;	$errMsg
0000000000000000000000000000000000000000;;	]]>
0000000000000000000000000000000000000000;;	    </system-err>
0000000000000000000000000000000000000000;;	    </testcase>
0000000000000000000000000000000000000000;;	  "
0000000000000000000000000000000000000000;;	  ## testsuite block
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  if [[ -e "$juDIR/junit-$suite.xml" ]]; then
0000000000000000000000000000000000000000;;	    # file exists. first update the failures count
0000000000000000000000000000000000000000;;	    failCount=`sed -n "s/.*testsuite.*failures=\"\([0-9]*\)\".*/\1/p" "$juDIR/junit-$suite.xml"`
0000000000000000000000000000000000000000;;	    errors=$(($failCount+$errors))
0000000000000000000000000000000000000000;;	    sed -i "0,/failures=\"$failCount\"/ s/failures=\"$failCount\"/failures=\"$errors\"/" "$juDIR/junit-$suite.xml"
0000000000000000000000000000000000000000;;	    sed -i "0,/errors=\"$failCount\"/ s/errors=\"$failCount\"/errors=\"$errors\"/" "$juDIR/junit-$suite.xml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    # file exists. Need to append to it. If we remove the testsuite end tag, we can just add it in after.
0000000000000000000000000000000000000000;;	    sed -i "s^</testsuite>^^g" $juDIR/junit-$suite.xml ## remove testSuite so we can add it later
0000000000000000000000000000000000000000;;	    sed -i "s^</testsuites>^^g" $juDIR/junit-$suite.xml
0000000000000000000000000000000000000000;;	    cat <<EOF >> "$juDIR/junit-$suite.xml"
0000000000000000000000000000000000000000;;	     $content
0000000000000000000000000000000000000000;;	    </testsuite>
0000000000000000000000000000000000000000;;	</testsuites>
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  else
0000000000000000000000000000000000000000;;	    # no file exists. Adding a new file
0000000000000000000000000000000000000000;;	    cat <<EOF > "$juDIR/junit-$suite.xml"
0000000000000000000000000000000000000000;;	<?xml version="1.0" encoding="UTF-8"?>
0000000000000000000000000000000000000000;;	<testsuites>
0000000000000000000000000000000000000000;;	    <testsuite failures="$errors" assertions="$assertions" name="$suite" tests="1" errors="$errors" time="$total">
0000000000000000000000000000000000000000;;	    $content
0000000000000000000000000000000000000000;;	    </testsuite>
0000000000000000000000000000000000000000;;	</testsuites>
0000000000000000000000000000000000000000;;	EOF
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  return $err
0000000000000000000000000000000000000000;;	}
