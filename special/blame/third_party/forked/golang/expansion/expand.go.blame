0000000000000000000000000000000000000000;;	package expansion
649aa350e6e0ed556053bda5b1d4e4d2cdf49dc8;third_party/golang/expansion/expand.go[third_party/golang/expansion/expand.go][third_party/forked/golang/expansion/expand.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		operator        = '$'
0000000000000000000000000000000000000000;;		referenceOpener = '('
0000000000000000000000000000000000000000;;		referenceCloser = ')'
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syntaxWrap returns the input string wrapped by the expansion syntax.
0000000000000000000000000000000000000000;;	func syntaxWrap(input string) string {
0000000000000000000000000000000000000000;;		return string(operator) + string(referenceOpener) + input + string(referenceCloser)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MappingFuncFor returns a mapping function for use with Expand that
0000000000000000000000000000000000000000;;	// implements the expansion semantics defined in the expansion spec; it
0000000000000000000000000000000000000000;;	// returns the input string wrapped in the expansion syntax if no mapping
0000000000000000000000000000000000000000;;	// for the input is found.
0000000000000000000000000000000000000000;;	func MappingFuncFor(context ...map[string]string) func(string) string {
0000000000000000000000000000000000000000;;		return func(input string) string {
0000000000000000000000000000000000000000;;			for _, vars := range context {
0000000000000000000000000000000000000000;;				val, ok := vars[input]
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					return val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return syntaxWrap(input)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Expand replaces variable references in the input string according to
0000000000000000000000000000000000000000;;	// the expansion spec using the given mapping function to resolve the
0000000000000000000000000000000000000000;;	// values of variables.
0000000000000000000000000000000000000000;;	func Expand(input string, mapping func(string) string) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		checkpoint := 0
0000000000000000000000000000000000000000;;		for cursor := 0; cursor < len(input); cursor++ {
0000000000000000000000000000000000000000;;			if input[cursor] == operator && cursor+1 < len(input) {
0000000000000000000000000000000000000000;;				// Copy the portion of the input string since the last
0000000000000000000000000000000000000000;;				// checkpoint into the buffer
0000000000000000000000000000000000000000;;				buf.WriteString(input[checkpoint:cursor])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Attempt to read the variable name as defined by the
0000000000000000000000000000000000000000;;				// syntax from the input string
0000000000000000000000000000000000000000;;				read, isVar, advance := tryReadVariableName(input[cursor+1:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if isVar {
0000000000000000000000000000000000000000;;					// We were able to read a variable name correctly;
0000000000000000000000000000000000000000;;					// apply the mapping to the variable name and copy the
0000000000000000000000000000000000000000;;					// bytes into the buffer
0000000000000000000000000000000000000000;;					buf.WriteString(mapping(read))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Not a variable name; copy the read bytes into the buffer
0000000000000000000000000000000000000000;;					buf.WriteString(read)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Advance the cursor in the input string to account for
0000000000000000000000000000000000000000;;				// bytes consumed to read the variable name expression
0000000000000000000000000000000000000000;;				cursor += advance
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Advance the checkpoint in the input string
0000000000000000000000000000000000000000;;				checkpoint = cursor + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return the buffer and any remaining unwritten bytes in the
0000000000000000000000000000000000000000;;		// input string.
0000000000000000000000000000000000000000;;		return buf.String() + input[checkpoint:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryReadVariableName attempts to read a variable name from the input
0000000000000000000000000000000000000000;;	// string and returns the content read from the input, whether that content
0000000000000000000000000000000000000000;;	// represents a variable name to perform mapping on, and the number of bytes
0000000000000000000000000000000000000000;;	// consumed in the input string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The input string is assumed not to contain the initial operator.
0000000000000000000000000000000000000000;;	func tryReadVariableName(input string) (string, bool, int) {
0000000000000000000000000000000000000000;;		switch input[0] {
0000000000000000000000000000000000000000;;		case operator:
0000000000000000000000000000000000000000;;			// Escaped operator; return it.
0000000000000000000000000000000000000000;;			return input[0:1], false, 1
0000000000000000000000000000000000000000;;		case referenceOpener:
0000000000000000000000000000000000000000;;			// Scan to expression closer
0000000000000000000000000000000000000000;;			for i := 1; i < len(input); i++ {
0000000000000000000000000000000000000000;;				if input[i] == referenceCloser {
0000000000000000000000000000000000000000;;					return input[1:i], true, i + 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Incomplete reference; return it.
0000000000000000000000000000000000000000;;			return string(operator) + string(referenceOpener), false, 1
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Not the beginning of an expression, ie, an operator
0000000000000000000000000000000000000000;;			// that doesn't begin an expression.  Return the operator
0000000000000000000000000000000000000000;;			// and the first rune in the string.
0000000000000000000000000000000000000000;;			return (string(operator) + string(input[0])), false, 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
