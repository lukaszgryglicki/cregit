0000000000000000000000000000000000000000;;	//This package is copied from Go library text/template.
0000000000000000000000000000000000000000;;	//The original private functions indirect and printableValue
0000000000000000000000000000000000000000;;	//are exported as public functions.
0000000000000000000000000000000000000000;;	package template
884fe0568af7432b15e24074ce4f07f5ee39181e;third_party/golang/template/exec.go[third_party/golang/template/exec.go][third_party/forked/golang/template/exec.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var Indirect = indirect
0000000000000000000000000000000000000000;;	var PrintableValue = printableValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errorType       = reflect.TypeOf((*error)(nil)).Elem()
0000000000000000000000000000000000000000;;		fmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// indirect returns the item at the end of indirection, and a bool to indicate if it's nil.
0000000000000000000000000000000000000000;;	// We indirect through pointers and empty interfaces (only) because
0000000000000000000000000000000000000000;;	// non-empty interfaces have methods we might need.
0000000000000000000000000000000000000000;;	func indirect(v reflect.Value) (rv reflect.Value, isNil bool) {
0000000000000000000000000000000000000000;;		for ; v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface; v = v.Elem() {
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				return v, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Interface && v.NumMethod() > 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printableValue returns the, possibly indirected, interface value inside v that
0000000000000000000000000000000000000000;;	// is best for a call to formatted printer.
0000000000000000000000000000000000000000;;	func printableValue(v reflect.Value) (interface{}, bool) {
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			v, _ = indirect(v) // fmt.Fprint handles nil.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !v.IsValid() {
0000000000000000000000000000000000000000;;			return "<no value>", true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !v.Type().Implements(errorType) && !v.Type().Implements(fmtStringerType) {
0000000000000000000000000000000000000000;;			if v.CanAddr() && (reflect.PtrTo(v.Type()).Implements(errorType) || reflect.PtrTo(v.Type()).Implements(fmtStringerType)) {
0000000000000000000000000000000000000000;;				v = v.Addr()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch v.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Chan, reflect.Func:
0000000000000000000000000000000000000000;;					return nil, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.Interface(), true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.
0000000000000000000000000000000000000000;;	func canBeNil(typ reflect.Type) bool {
0000000000000000000000000000000000000000;;		switch typ.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTrue reports whether the value is 'true', in the sense of not the zero of its type,
0000000000000000000000000000000000000000;;	// and whether the value has a meaningful truth value.
0000000000000000000000000000000000000000;;	func isTrue(val reflect.Value) (truth, ok bool) {
0000000000000000000000000000000000000000;;		if !val.IsValid() {
0000000000000000000000000000000000000000;;			// Something like var x interface{}, never set. It's a form of nil.
0000000000000000000000000000000000000000;;			return false, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch val.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;			truth = val.Len() > 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			truth = val.Bool()
0000000000000000000000000000000000000000;;		case reflect.Complex64, reflect.Complex128:
0000000000000000000000000000000000000000;;			truth = val.Complex() != 0
0000000000000000000000000000000000000000;;		case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Interface:
0000000000000000000000000000000000000000;;			truth = !val.IsNil()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			truth = val.Int() != 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			truth = val.Float() != 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			truth = val.Uint() != 0
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			truth = true // Struct values are always true.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return truth, true
0000000000000000000000000000000000000000;;	}
