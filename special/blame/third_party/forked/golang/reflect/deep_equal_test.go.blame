0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
6568fe3bd0f292eec9866ac40d95c5aaafbb0545;pkg/conversion/deep_equal_test.go[pkg/conversion/deep_equal_test.go][third_party/forked/golang/reflect/deep_equal_test.go];	
0000000000000000000000000000000000000000;;	package reflect
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEqualities(t *testing.T) {
0000000000000000000000000000000000000000;;		e := Equalities{}
0000000000000000000000000000000000000000;;		type Bar struct {
0000000000000000000000000000000000000000;;			X int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type Baz struct {
0000000000000000000000000000000000000000;;			Y Bar
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := e.AddFuncs(
0000000000000000000000000000000000000000;;			func(a, b int) bool {
0000000000000000000000000000000000000000;;				return a+1 == b
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(a, b Bar) bool {
0000000000000000000000000000000000000000;;				return a.X*10 == b.X
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Foo struct {
0000000000000000000000000000000000000000;;			X int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			a, b  interface{}
0000000000000000000000000000000000000000;;			equal bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{1, 2, true},
0000000000000000000000000000000000000000;;			{2, 1, false},
0000000000000000000000000000000000000000;;			{"foo", "fo", false},
0000000000000000000000000000000000000000;;			{"foo", "foo", true},
0000000000000000000000000000000000000000;;			{"foo", "foobar", false},
0000000000000000000000000000000000000000;;			{Foo{1}, Foo{2}, true},
0000000000000000000000000000000000000000;;			{Foo{2}, Foo{1}, false},
0000000000000000000000000000000000000000;;			{Bar{1}, Bar{10}, true},
0000000000000000000000000000000000000000;;			{&Bar{1}, &Bar{10}, true},
0000000000000000000000000000000000000000;;			{Baz{Bar{1}}, Baz{Bar{10}}, true},
0000000000000000000000000000000000000000;;			{[...]string{}, [...]string{"1", "2", "3"}, false},
0000000000000000000000000000000000000000;;			{[...]string{"1"}, [...]string{"1", "2", "3"}, false},
0000000000000000000000000000000000000000;;			{[...]string{"1", "2", "3"}, [...]string{}, false},
0000000000000000000000000000000000000000;;			{[...]string{"1", "2", "3"}, [...]string{"1", "2", "3"}, true},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1}, map[string]int{}, false},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1}, map[string]int{"foo": 2}, true},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 2}, map[string]int{"foo": 1}, false},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1}, map[string]int{"foo": 2, "bar": 6}, false},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1, "bar": 6}, map[string]int{"foo": 2}, false},
0000000000000000000000000000000000000000;;			{map[string]int{}, map[string]int(nil), true},
0000000000000000000000000000000000000000;;			{[]string(nil), []string(nil), true},
0000000000000000000000000000000000000000;;			{[]string{}, []string(nil), true},
0000000000000000000000000000000000000000;;			{[]string(nil), []string{}, true},
0000000000000000000000000000000000000000;;			{[]string{"1"}, []string(nil), false},
0000000000000000000000000000000000000000;;			{[]string{}, []string{"1", "2", "3"}, false},
0000000000000000000000000000000000000000;;			{[]string{"1"}, []string{"1", "2", "3"}, false},
0000000000000000000000000000000000000000;;			{[]string{"1", "2", "3"}, []string{}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			if e, a := item.equal, e.DeepEqual(item.a, item.b); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected (%+v == %+v) == %v, but got %v", item.a, item.b, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDerivates(t *testing.T) {
0000000000000000000000000000000000000000;;		e := Equalities{}
0000000000000000000000000000000000000000;;		type Bar struct {
0000000000000000000000000000000000000000;;			X int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type Baz struct {
0000000000000000000000000000000000000000;;			Y Bar
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := e.AddFuncs(
0000000000000000000000000000000000000000;;			func(a, b int) bool {
0000000000000000000000000000000000000000;;				return a+1 == b
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(a, b Bar) bool {
0000000000000000000000000000000000000000;;				return a.X*10 == b.X
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Foo struct {
0000000000000000000000000000000000000000;;			X int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			a, b  interface{}
0000000000000000000000000000000000000000;;			equal bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{1, 2, true},
0000000000000000000000000000000000000000;;			{2, 1, false},
0000000000000000000000000000000000000000;;			{"foo", "fo", false},
0000000000000000000000000000000000000000;;			{"foo", "foo", true},
0000000000000000000000000000000000000000;;			{"foo", "foobar", false},
0000000000000000000000000000000000000000;;			{Foo{1}, Foo{2}, true},
0000000000000000000000000000000000000000;;			{Foo{2}, Foo{1}, false},
0000000000000000000000000000000000000000;;			{Bar{1}, Bar{10}, true},
0000000000000000000000000000000000000000;;			{&Bar{1}, &Bar{10}, true},
0000000000000000000000000000000000000000;;			{Baz{Bar{1}}, Baz{Bar{10}}, true},
0000000000000000000000000000000000000000;;			{[...]string{}, [...]string{"1", "2", "3"}, false},
0000000000000000000000000000000000000000;;			{[...]string{"1"}, [...]string{"1", "2", "3"}, false},
0000000000000000000000000000000000000000;;			{[...]string{"1", "2", "3"}, [...]string{}, false},
0000000000000000000000000000000000000000;;			{[...]string{"1", "2", "3"}, [...]string{"1", "2", "3"}, true},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1}, map[string]int{}, false},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1}, map[string]int{"foo": 2}, true},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 2}, map[string]int{"foo": 1}, false},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1}, map[string]int{"foo": 2, "bar": 6}, true},
0000000000000000000000000000000000000000;;			{map[string]int{"foo": 1, "bar": 6}, map[string]int{"foo": 2}, false},
0000000000000000000000000000000000000000;;			{map[string]int{}, map[string]int(nil), true},
0000000000000000000000000000000000000000;;			{[]string(nil), []string(nil), true},
0000000000000000000000000000000000000000;;			{[]string{}, []string(nil), true},
0000000000000000000000000000000000000000;;			{[]string(nil), []string{}, true},
0000000000000000000000000000000000000000;;			{[]string{"1"}, []string(nil), false},
0000000000000000000000000000000000000000;;			{[]string{}, []string{"1", "2", "3"}, true},
0000000000000000000000000000000000000000;;			{[]string{"1"}, []string{"1", "2", "3"}, true},
0000000000000000000000000000000000000000;;			{[]string{"1", "2", "3"}, []string{}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			if e, a := item.equal, e.DeepDerivative(item.a, item.b); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected (%+v ~ %+v) == %v, but got %v", item.a, item.b, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
