0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
58b3994076efb0a8e1e020de7f84b2367273e167;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package wal provides an implementation of a write ahead log that is used by
0000000000000000000000000000000000000000;;	etcd.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A WAL is created at a particular directory and is made up of a number of
0000000000000000000000000000000000000000;;	segmented WAL files. Inside of each file the raft state and entries are appended
0000000000000000000000000000000000000000;;	to it with the Save method:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metadata := []byte{}
0000000000000000000000000000000000000000;;		w, err := wal.Create("/var/lib/etcd", metadata)
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;		err := w.Save(s, ents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After saving an raft snapshot to disk, SaveSnapshot method should be called to
0000000000000000000000000000000000000000;;	record it. So WAL can match with the saved snapshot when restarting.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := w.SaveSnapshot(walpb.Snapshot{Index: 10, Term: 2})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When a user has finished using a WAL it must be closed:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	WAL files are placed inside of the directory in the following format:
0000000000000000000000000000000000000000;;	$seq-$index.wal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The first WAL file to be created will be 0000000000000000-0000000000000000.wal
0000000000000000000000000000000000000000;;	indicating an initial sequence of 0 and an initial raft index of 0. The first
0000000000000000000000000000000000000000;;	entry written to WAL MUST have raft index 0.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	WAL will cuts its current wal files if its size exceeds 8MB. This will increment an internal
0000000000000000000000000000000000000000;;	sequence number and cause a new file to be created. If the last raft index saved
0000000000000000000000000000000000000000;;	was 0x20 and this is the first time cut has been called on this WAL then the sequence will
0000000000000000000000000000000000000000;;	increment from 0x0 to 0x1. The new file will be: 0000000000000001-0000000000000021.wal.
0000000000000000000000000000000000000000;;	If a second cut issues 0x10 entries with incremental index later then the file will be called:
0000000000000000000000000000000000000000;;	0000000000000002-0000000000000031.wal.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	At a later time a WAL can be opened at a particular snapshot. If there is no
0000000000000000000000000000000000000000;;	snapshot, an empty snapshot should be passed in.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, err := wal.Open("/var/lib/etcd", walpb.Snapshot{Index: 10, Term: 2})
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The snapshot must have been written to the WAL.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Additional items cannot be Saved to this WAL until all of the items from the given
0000000000000000000000000000000000000000;;	snapshot to the end of the WAL are read first:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metadata, state, ents, err := w.ReadAll()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This will give you the metadata, the last raft.State and the slice of
0000000000000000000000000000000000000000;;	raft.Entry items in the log.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package wal
