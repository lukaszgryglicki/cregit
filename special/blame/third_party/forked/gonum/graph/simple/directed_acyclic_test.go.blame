0000000000000000000000000000000000000000;;	// Copyright Â©2014 The gonum Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fcb27c13af752dbe70d4cf7f31219e6c3a925ffc;;	
0000000000000000000000000000000000000000;;	package simple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ graph.Graph = &DirectedAcyclicGraph{}
0000000000000000000000000000000000000000;;	var _ graph.Directed = &DirectedAcyclicGraph{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests Issue #27
0000000000000000000000000000000000000000;;	func TestAcyclicEdgeOvercounting(t *testing.T) {
0000000000000000000000000000000000000000;;		g := generateDummyAcyclicGraph()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if neigh := g.From(Node(Node(2))); len(neigh) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Node 2 has incorrect number of neighbors got neighbors %v (count %d), expected 2 neighbors {0,1}", neigh, len(neigh))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateDummyAcyclicGraph() *DirectedAcyclicGraph {
0000000000000000000000000000000000000000;;		nodes := [4]struct{ srcID, targetID int }{
0000000000000000000000000000000000000000;;			{2, 1},
0000000000000000000000000000000000000000;;			{1, 0},
0000000000000000000000000000000000000000;;			{0, 2},
0000000000000000000000000000000000000000;;			{2, 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g := NewDirectedAcyclicGraph(0, math.Inf(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range nodes {
0000000000000000000000000000000000000000;;			g.SetEdge(Edge{F: Node(n.srcID), T: Node(n.targetID), W: 1})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return g
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test for issue #123 https://github.com/gonum/graph/issues/123
0000000000000000000000000000000000000000;;	func TestAcyclicIssue123DirectedGraph(t *testing.T) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if r := recover(); r != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected panic: %v", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		g := NewDirectedAcyclicGraph(0, math.Inf(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n0 := Node(g.NewNodeID())
0000000000000000000000000000000000000000;;		g.AddNode(n0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n1 := Node(g.NewNodeID())
0000000000000000000000000000000000000000;;		g.AddNode(n1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.RemoveNode(n0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n2 := Node(g.NewNodeID())
0000000000000000000000000000000000000000;;		g.AddNode(n2)
0000000000000000000000000000000000000000;;	}
