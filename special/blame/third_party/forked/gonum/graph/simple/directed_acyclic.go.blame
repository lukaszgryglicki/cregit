0000000000000000000000000000000000000000;;	package simple
fcb27c13af752dbe70d4cf7f31219e6c3a925ffc;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectedAcyclicGraph implements graph.Directed using UndirectedGraph,
0000000000000000000000000000000000000000;;	// which only stores one edge for any node pair.
0000000000000000000000000000000000000000;;	type DirectedAcyclicGraph struct {
0000000000000000000000000000000000000000;;		*UndirectedGraph
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDirectedAcyclicGraph(self, absent float64) *DirectedAcyclicGraph {
0000000000000000000000000000000000000000;;		return &DirectedAcyclicGraph{
0000000000000000000000000000000000000000;;			UndirectedGraph: NewUndirectedGraph(self, absent),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *DirectedAcyclicGraph) HasEdgeFromTo(u, v graph.Node) bool {
0000000000000000000000000000000000000000;;		edge := g.UndirectedGraph.EdgeBetween(u, v)
0000000000000000000000000000000000000000;;		if edge == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (edge.From().ID() == u.ID())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *DirectedAcyclicGraph) From(n graph.Node) []graph.Node {
0000000000000000000000000000000000000000;;		if !g.Has(n) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fid := n.ID()
0000000000000000000000000000000000000000;;		nodes := make([]graph.Node, 0, g.UndirectedGraph.edges[n.ID()].Len())
0000000000000000000000000000000000000000;;		g.UndirectedGraph.edges[n.ID()].Visit(func(neighbor int, edge graph.Edge) {
0000000000000000000000000000000000000000;;			if edge.From().ID() == fid {
0000000000000000000000000000000000000000;;				nodes = append(nodes, g.UndirectedGraph.nodes[edge.To().ID()])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *DirectedAcyclicGraph) VisitFrom(n graph.Node, visitor func(neighbor graph.Node) (shouldContinue bool)) {
0000000000000000000000000000000000000000;;		if !g.Has(n) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fid := n.ID()
0000000000000000000000000000000000000000;;		g.UndirectedGraph.edges[n.ID()].Visit(func(neighbor int, edge graph.Edge) {
0000000000000000000000000000000000000000;;			if edge.From().ID() == fid {
0000000000000000000000000000000000000000;;				if !visitor(g.UndirectedGraph.nodes[edge.To().ID()]) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *DirectedAcyclicGraph) To(n graph.Node) []graph.Node {
0000000000000000000000000000000000000000;;		if !g.Has(n) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tid := n.ID()
0000000000000000000000000000000000000000;;		nodes := make([]graph.Node, 0, g.UndirectedGraph.edges[n.ID()].Len())
0000000000000000000000000000000000000000;;		g.UndirectedGraph.edges[n.ID()].Visit(func(neighbor int, edge graph.Edge) {
0000000000000000000000000000000000000000;;			if edge.To().ID() == tid {
0000000000000000000000000000000000000000;;				nodes = append(nodes, g.UndirectedGraph.nodes[edge.From().ID()])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *DirectedAcyclicGraph) VisitTo(n graph.Node, visitor func(neighbor graph.Node) (shouldContinue bool)) {
0000000000000000000000000000000000000000;;		if !g.Has(n) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tid := n.ID()
0000000000000000000000000000000000000000;;		g.UndirectedGraph.edges[n.ID()].Visit(func(neighbor int, edge graph.Edge) {
0000000000000000000000000000000000000000;;			if edge.To().ID() == tid {
0000000000000000000000000000000000000000;;				if !visitor(g.UndirectedGraph.nodes[edge.From().ID()]) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
