0000000000000000000000000000000000000000;;	// Copyright Â©2014 The gonum Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
774b4e9e7e7f8e00aca2c93e3cce9ed35d8c55fb;;	
0000000000000000000000000000000000000000;;	package simple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ graph.Graph = (*UndirectedGraph)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAssertMutableNotDirected(t *testing.T) {
0000000000000000000000000000000000000000;;		var g graph.UndirectedBuilder = NewUndirectedGraph(0, math.Inf(1))
0000000000000000000000000000000000000000;;		if _, ok := g.(graph.Directed); ok {
0000000000000000000000000000000000000000;;			t.Fatal("Graph is directed, but a MutableGraph cannot safely be directed!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMaxID(t *testing.T) {
0000000000000000000000000000000000000000;;		g := NewUndirectedGraph(0, math.Inf(1))
0000000000000000000000000000000000000000;;		nodes := make(map[graph.Node]struct{})
0000000000000000000000000000000000000000;;		for i := Node(0); i < 3; i++ {
0000000000000000000000000000000000000000;;			g.AddNode(i)
0000000000000000000000000000000000000000;;			nodes[i] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.RemoveNode(Node(0))
0000000000000000000000000000000000000000;;		delete(nodes, Node(0))
0000000000000000000000000000000000000000;;		g.RemoveNode(Node(2))
0000000000000000000000000000000000000000;;		delete(nodes, Node(2))
0000000000000000000000000000000000000000;;		n := Node(g.NewNodeID())
0000000000000000000000000000000000000000;;		g.AddNode(n)
0000000000000000000000000000000000000000;;		if !g.Has(n) {
0000000000000000000000000000000000000000;;			t.Error("added node does not exist in graph")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, exists := nodes[n]; exists {
0000000000000000000000000000000000000000;;			t.Errorf("Created already existing node id: %v", n.ID())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test for issue #123 https://github.com/gonum/graph/issues/123
0000000000000000000000000000000000000000;;	func TestIssue123UndirectedGraph(t *testing.T) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if r := recover(); r != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected panic: %v", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		g := NewUndirectedGraph(0, math.Inf(1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n0 := Node(g.NewNodeID())
0000000000000000000000000000000000000000;;		g.AddNode(n0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n1 := Node(g.NewNodeID())
0000000000000000000000000000000000000000;;		g.AddNode(n1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.RemoveNode(n0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n2 := Node(g.NewNodeID())
0000000000000000000000000000000000000000;;		g.AddNode(n2)
0000000000000000000000000000000000000000;;	}
