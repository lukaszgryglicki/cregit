0000000000000000000000000000000000000000;;	// Copyright Â©2014 The gonum Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
774b4e9e7e7f8e00aca2c93e3cce9ed35d8c55fb;;	
0000000000000000000000000000000000000000;;	package simple
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/tools/container/intsets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UndirectedGraph implements a generalized undirected graph.
0000000000000000000000000000000000000000;;	type UndirectedGraph struct {
0000000000000000000000000000000000000000;;		nodes map[int]graph.Node
0000000000000000000000000000000000000000;;		edges map[int]edgeHolder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		self, absent float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		freeIDs intsets.Sparse
0000000000000000000000000000000000000000;;		usedIDs intsets.Sparse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUndirectedGraph returns an UndirectedGraph with the specified self and absent
0000000000000000000000000000000000000000;;	// edge weight values.
0000000000000000000000000000000000000000;;	func NewUndirectedGraph(self, absent float64) *UndirectedGraph {
0000000000000000000000000000000000000000;;		return &UndirectedGraph{
0000000000000000000000000000000000000000;;			nodes: make(map[int]graph.Node),
0000000000000000000000000000000000000000;;			edges: make(map[int]edgeHolder),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			self:   self,
0000000000000000000000000000000000000000;;			absent: absent,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNodeID returns a new unique ID for a node to be added to g. The returned ID does
0000000000000000000000000000000000000000;;	// not become a valid ID in g until it is added to g.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) NewNodeID() int {
0000000000000000000000000000000000000000;;		if len(g.nodes) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(g.nodes) == maxInt {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("simple: cannot allocate node: no slot"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var id int
0000000000000000000000000000000000000000;;		if g.freeIDs.Len() != 0 && g.freeIDs.TakeMin(&id) {
0000000000000000000000000000000000000000;;			return id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if id = g.usedIDs.Max(); id < maxInt {
0000000000000000000000000000000000000000;;			return id + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for id = 0; id < maxInt; id++ {
0000000000000000000000000000000000000000;;			if !g.usedIDs.Has(id) {
0000000000000000000000000000000000000000;;				return id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddNode adds n to the graph. It panics if the added node ID matches an existing node ID.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) AddNode(n graph.Node) {
0000000000000000000000000000000000000000;;		if _, exists := g.nodes[n.ID()]; exists {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("simple: node ID collision: %d", n.ID()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.nodes[n.ID()] = n
0000000000000000000000000000000000000000;;		g.edges[n.ID()] = &sliceEdgeHolder{self: n.ID()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.freeIDs.Remove(n.ID())
0000000000000000000000000000000000000000;;		g.usedIDs.Insert(n.ID())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveNode removes n from the graph, as well as any edges attached to it. If the node
0000000000000000000000000000000000000000;;	// is not in the graph it is a no-op.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) RemoveNode(n graph.Node) {
0000000000000000000000000000000000000000;;		if _, ok := g.nodes[n.ID()]; !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(g.nodes, n.ID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.edges[n.ID()].Visit(func(neighbor int, edge graph.Edge) {
0000000000000000000000000000000000000000;;			g.edges[neighbor] = g.edges[neighbor].Delete(n.ID())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		delete(g.edges, n.ID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.freeIDs.Insert(n.ID())
0000000000000000000000000000000000000000;;		g.usedIDs.Remove(n.ID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEdge adds e, an edge from one node to another. If the nodes do not exist, they are added.
0000000000000000000000000000000000000000;;	// It will panic if the IDs of the e.From and e.To are equal.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) SetEdge(e graph.Edge) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			from = e.From()
0000000000000000000000000000000000000000;;			fid  = from.ID()
0000000000000000000000000000000000000000;;			to   = e.To()
0000000000000000000000000000000000000000;;			tid  = to.ID()
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fid == tid {
0000000000000000000000000000000000000000;;			panic("simple: adding self edge")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !g.Has(from) {
0000000000000000000000000000000000000000;;			g.AddNode(from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !g.Has(to) {
0000000000000000000000000000000000000000;;			g.AddNode(to)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.edges[fid] = g.edges[fid].Set(tid, e)
0000000000000000000000000000000000000000;;		g.edges[tid] = g.edges[tid].Set(fid, e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveEdge removes e from the graph, leaving the terminal nodes. If the edge does not exist
0000000000000000000000000000000000000000;;	// it is a no-op.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) RemoveEdge(e graph.Edge) {
0000000000000000000000000000000000000000;;		from, to := e.From(), e.To()
0000000000000000000000000000000000000000;;		if _, ok := g.nodes[from.ID()]; !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := g.nodes[to.ID()]; !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.edges[from.ID()] = g.edges[from.ID()].Delete(to.ID())
0000000000000000000000000000000000000000;;		g.edges[to.ID()] = g.edges[to.ID()].Delete(from.ID())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node returns the node in the graph with the given ID.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) Node(id int) graph.Node {
0000000000000000000000000000000000000000;;		return g.nodes[id]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns whether the node exists within the graph.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) Has(n graph.Node) bool {
0000000000000000000000000000000000000000;;		_, ok := g.nodes[n.ID()]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nodes returns all the nodes in the graph.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) Nodes() []graph.Node {
0000000000000000000000000000000000000000;;		nodes := make([]graph.Node, len(g.nodes))
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for _, n := range g.nodes {
0000000000000000000000000000000000000000;;			nodes[i] = n
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Edges returns all the edges in the graph.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) Edges() []graph.Edge {
0000000000000000000000000000000000000000;;		var edges []graph.Edge
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		seen := make(map[[2]int]struct{})
0000000000000000000000000000000000000000;;		for _, u := range g.edges {
0000000000000000000000000000000000000000;;			u.Visit(func(neighbor int, e graph.Edge) {
0000000000000000000000000000000000000000;;				uid := e.From().ID()
0000000000000000000000000000000000000000;;				vid := e.To().ID()
0000000000000000000000000000000000000000;;				if _, ok := seen[[2]int{uid, vid}]; ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				seen[[2]int{uid, vid}] = struct{}{}
0000000000000000000000000000000000000000;;				seen[[2]int{vid, uid}] = struct{}{}
0000000000000000000000000000000000000000;;				edges = append(edges, e)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return edges
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From returns all nodes in g that can be reached directly from n.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) From(n graph.Node) []graph.Node {
0000000000000000000000000000000000000000;;		if !g.Has(n) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes := make([]graph.Node, g.edges[n.ID()].Len())
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		g.edges[n.ID()].Visit(func(neighbor int, edge graph.Edge) {
0000000000000000000000000000000000000000;;			nodes[i] = g.nodes[neighbor]
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasEdgeBetween returns whether an edge exists between nodes x and y.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) HasEdgeBetween(x, y graph.Node) bool {
0000000000000000000000000000000000000000;;		_, ok := g.edges[x.ID()].Get(y.ID())
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Edge returns the edge from u to v if such an edge exists and nil otherwise.
0000000000000000000000000000000000000000;;	// The node v must be directly reachable from u as defined by the From method.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) Edge(u, v graph.Node) graph.Edge {
0000000000000000000000000000000000000000;;		return g.EdgeBetween(u, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EdgeBetween returns the edge between nodes x and y.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) EdgeBetween(x, y graph.Node) graph.Edge {
0000000000000000000000000000000000000000;;		// We don't need to check if neigh exists because
0000000000000000000000000000000000000000;;		// it's implicit in the edges access.
0000000000000000000000000000000000000000;;		if !g.Has(x) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		edge, _ := g.edges[x.ID()].Get(y.ID())
0000000000000000000000000000000000000000;;		return edge
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Weight returns the weight for the edge between x and y if Edge(x, y) returns a non-nil Edge.
0000000000000000000000000000000000000000;;	// If x and y are the same node or there is no joining edge between the two nodes the weight
0000000000000000000000000000000000000000;;	// value returned is either the graph's absent or self value. Weight returns true if an edge
0000000000000000000000000000000000000000;;	// exists between x and y or if x and y have the same ID, false otherwise.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) Weight(x, y graph.Node) (w float64, ok bool) {
0000000000000000000000000000000000000000;;		xid := x.ID()
0000000000000000000000000000000000000000;;		yid := y.ID()
0000000000000000000000000000000000000000;;		if xid == yid {
0000000000000000000000000000000000000000;;			return g.self, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n, ok := g.edges[xid]; ok {
0000000000000000000000000000000000000000;;			if e, ok := n.Get(yid); ok {
0000000000000000000000000000000000000000;;				return e.Weight(), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return g.absent, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Degree returns the degree of n in g.
0000000000000000000000000000000000000000;;	func (g *UndirectedGraph) Degree(n graph.Node) int {
0000000000000000000000000000000000000000;;		if _, ok := g.nodes[n.ID()]; !ok {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return g.edges[n.ID()].Len()
0000000000000000000000000000000000000000;;	}
