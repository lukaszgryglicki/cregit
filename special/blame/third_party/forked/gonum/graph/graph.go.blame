0000000000000000000000000000000000000000;;	// Copyright Â©2014 The gonum Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
774b4e9e7e7f8e00aca2c93e3cce9ed35d8c55fb;;	
0000000000000000000000000000000000000000;;	package graph
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node is a graph node. It returns a graph-unique integer ID.
0000000000000000000000000000000000000000;;	type Node interface {
0000000000000000000000000000000000000000;;		ID() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Edge is a graph edge. In directed graphs, the direction of the
0000000000000000000000000000000000000000;;	// edge is given from -> to, otherwise the edge is semantically
0000000000000000000000000000000000000000;;	// unordered.
0000000000000000000000000000000000000000;;	type Edge interface {
0000000000000000000000000000000000000000;;		From() Node
0000000000000000000000000000000000000000;;		To() Node
0000000000000000000000000000000000000000;;		Weight() float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Graph is a generalized graph.
0000000000000000000000000000000000000000;;	type Graph interface {
0000000000000000000000000000000000000000;;		// Has returns whether the node exists within the graph.
0000000000000000000000000000000000000000;;		Has(Node) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nodes returns all the nodes in the graph.
0000000000000000000000000000000000000000;;		Nodes() []Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// From returns all nodes that can be reached directly
0000000000000000000000000000000000000000;;		// from the given node.
0000000000000000000000000000000000000000;;		From(Node) []Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HasEdgeBeteen returns whether an edge exists between
0000000000000000000000000000000000000000;;		// nodes x and y without considering direction.
0000000000000000000000000000000000000000;;		HasEdgeBetween(x, y Node) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Edge returns the edge from u to v if such an edge
0000000000000000000000000000000000000000;;		// exists and nil otherwise. The node v must be directly
0000000000000000000000000000000000000000;;		// reachable from u as defined by the From method.
0000000000000000000000000000000000000000;;		Edge(u, v Node) Edge
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Undirected is an undirected graph.
0000000000000000000000000000000000000000;;	type Undirected interface {
0000000000000000000000000000000000000000;;		Graph
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EdgeBetween returns the edge between nodes x and y.
0000000000000000000000000000000000000000;;		EdgeBetween(x, y Node) Edge
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Directed is a directed graph.
0000000000000000000000000000000000000000;;	type Directed interface {
0000000000000000000000000000000000000000;;		Graph
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HasEdgeFromTo returns whether an edge exists
0000000000000000000000000000000000000000;;		// in the graph from u to v.
0000000000000000000000000000000000000000;;		HasEdgeFromTo(u, v Node) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To returns all nodes that can reach directly
0000000000000000000000000000000000000000;;		// to the given node.
0000000000000000000000000000000000000000;;		To(Node) []Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Weighter defines graphs that can report edge weights.
0000000000000000000000000000000000000000;;	type Weighter interface {
0000000000000000000000000000000000000000;;		// Weight returns the weight for the edge between
0000000000000000000000000000000000000000;;		// x and y if Edge(x, y) returns a non-nil Edge.
0000000000000000000000000000000000000000;;		// If x and y are the same node or there is no
0000000000000000000000000000000000000000;;		// joining edge between the two nodes the weight
0000000000000000000000000000000000000000;;		// value returned is implementation dependent.
0000000000000000000000000000000000000000;;		// Weight returns true if an edge exists between
0000000000000000000000000000000000000000;;		// x and y or if x and y have the same ID, false
0000000000000000000000000000000000000000;;		// otherwise.
0000000000000000000000000000000000000000;;		Weight(x, y Node) (w float64, ok bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAdder is an interface for adding arbitrary nodes to a graph.
0000000000000000000000000000000000000000;;	type NodeAdder interface {
0000000000000000000000000000000000000000;;		// NewNodeID returns a new unique arbitrary ID.
0000000000000000000000000000000000000000;;		NewNodeID() int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adds a node to the graph. AddNode panics if
0000000000000000000000000000000000000000;;		// the added node ID matches an existing node ID.
0000000000000000000000000000000000000000;;		AddNode(Node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeRemover is an interface for removing nodes from a graph.
0000000000000000000000000000000000000000;;	type NodeRemover interface {
0000000000000000000000000000000000000000;;		// RemoveNode removes a node from the graph, as
0000000000000000000000000000000000000000;;		// well as any edges attached to it. If the node
0000000000000000000000000000000000000000;;		// is not in the graph it is a no-op.
0000000000000000000000000000000000000000;;		RemoveNode(Node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EdgeSetter is an interface for adding edges to a graph.
0000000000000000000000000000000000000000;;	type EdgeSetter interface {
0000000000000000000000000000000000000000;;		// SetEdge adds an edge from one node to another.
0000000000000000000000000000000000000000;;		// If the graph supports node addition the nodes
0000000000000000000000000000000000000000;;		// will be added if they do not exist, otherwise
0000000000000000000000000000000000000000;;		// SetEdge will panic.
0000000000000000000000000000000000000000;;		// If the IDs returned by e.From and e.To are
0000000000000000000000000000000000000000;;		// equal, SetEdge will panic.
0000000000000000000000000000000000000000;;		SetEdge(e Edge)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EdgeRemover is an interface for removing nodes from a graph.
0000000000000000000000000000000000000000;;	type EdgeRemover interface {
0000000000000000000000000000000000000000;;		// RemoveEdge removes the given edge, leaving the
0000000000000000000000000000000000000000;;		// terminal nodes. If the edge does not exist it
0000000000000000000000000000000000000000;;		// is a no-op.
0000000000000000000000000000000000000000;;		RemoveEdge(Edge)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Builder is a graph that can have nodes and edges added.
0000000000000000000000000000000000000000;;	type Builder interface {
0000000000000000000000000000000000000000;;		NodeAdder
0000000000000000000000000000000000000000;;		EdgeSetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UndirectedBuilder is an undirected graph builder.
0000000000000000000000000000000000000000;;	type UndirectedBuilder interface {
0000000000000000000000000000000000000000;;		Undirected
0000000000000000000000000000000000000000;;		Builder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectedBuilder is a directed graph builder.
0000000000000000000000000000000000000000;;	type DirectedBuilder interface {
0000000000000000000000000000000000000000;;		Directed
0000000000000000000000000000000000000000;;		Builder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy copies nodes and edges as undirected edges from the source to the destination
0000000000000000000000000000000000000000;;	// without first clearing the destination. Copy will panic if a node ID in the source
0000000000000000000000000000000000000000;;	// graph matches a node ID in the destination.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the source is undirected and the destination is directed both directions will
0000000000000000000000000000000000000000;;	// be present in the destination after the copy is complete.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the source is a directed graph, the destination is undirected, and a fundamental
0000000000000000000000000000000000000000;;	// cycle exists with two nodes where the edge weights differ, the resulting destination
0000000000000000000000000000000000000000;;	// graph's edge weight between those nodes is undefined. If there is a defined function
0000000000000000000000000000000000000000;;	// to resolve such conflicts, an Undirect may be used to do this.
0000000000000000000000000000000000000000;;	func Copy(dst Builder, src Graph) {
0000000000000000000000000000000000000000;;		nodes := src.Nodes()
0000000000000000000000000000000000000000;;		for _, n := range nodes {
0000000000000000000000000000000000000000;;			dst.AddNode(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, u := range nodes {
0000000000000000000000000000000000000000;;			for _, v := range src.From(u) {
0000000000000000000000000000000000000000;;				dst.SetEdge(src.Edge(u, v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
