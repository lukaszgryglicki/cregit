0000000000000000000000000000000000000000;;	// Copyright Â©2015 The gonum Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
774b4e9e7e7f8e00aca2c93e3cce9ed35d8c55fb;;	
0000000000000000000000000000000000000000;;	// Package linear provides common linear data structures.
0000000000000000000000000000000000000000;;	package linear
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeStack implements a LIFO stack of graph.Node.
0000000000000000000000000000000000000000;;	type NodeStack []graph.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of graph.Nodes on the stack.
0000000000000000000000000000000000000000;;	func (s *NodeStack) Len() int { return len(*s) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pop returns the last graph.Node on the stack and removes it
0000000000000000000000000000000000000000;;	// from the stack.
0000000000000000000000000000000000000000;;	func (s *NodeStack) Pop() graph.Node {
0000000000000000000000000000000000000000;;		v := *s
0000000000000000000000000000000000000000;;		v, n := v[:len(v)-1], v[len(v)-1]
0000000000000000000000000000000000000000;;		*s = v
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Push adds the node n to the stack at the last position.
0000000000000000000000000000000000000000;;	func (s *NodeStack) Push(n graph.Node) { *s = append(*s, n) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeQueue implements a FIFO queue.
0000000000000000000000000000000000000000;;	type NodeQueue struct {
0000000000000000000000000000000000000000;;		head int
0000000000000000000000000000000000000000;;		data []graph.Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of graph.Nodes in the queue.
0000000000000000000000000000000000000000;;	func (q *NodeQueue) Len() int { return len(q.data) - q.head }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enqueue adds the node n to the back of the queue.
0000000000000000000000000000000000000000;;	func (q *NodeQueue) Enqueue(n graph.Node) {
0000000000000000000000000000000000000000;;		if len(q.data) == cap(q.data) && q.head > 0 {
0000000000000000000000000000000000000000;;			l := q.Len()
0000000000000000000000000000000000000000;;			copy(q.data, q.data[q.head:])
0000000000000000000000000000000000000000;;			q.head = 0
0000000000000000000000000000000000000000;;			q.data = append(q.data[:l], n)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			q.data = append(q.data, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dequeue returns the graph.Node at the front of the queue and
0000000000000000000000000000000000000000;;	// removes it from the queue.
0000000000000000000000000000000000000000;;	func (q *NodeQueue) Dequeue() graph.Node {
0000000000000000000000000000000000000000;;		if q.Len() == 0 {
0000000000000000000000000000000000000000;;			panic("queue: empty queue")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var n graph.Node
0000000000000000000000000000000000000000;;		n, q.data[q.head] = q.data[q.head], nil
0000000000000000000000000000000000000000;;		q.head++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if q.Len() == 0 {
0000000000000000000000000000000000000000;;			q.head = 0
0000000000000000000000000000000000000000;;			q.data = q.data[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset clears the queue for reuse.
0000000000000000000000000000000000000000;;	func (q *NodeQueue) Reset() {
0000000000000000000000000000000000000000;;		q.head = 0
0000000000000000000000000000000000000000;;		q.data = q.data[:0]
0000000000000000000000000000000000000000;;	}
