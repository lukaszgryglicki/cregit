0000000000000000000000000000000000000000;;	// Copyright Â©2015 The gonum Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
774b4e9e7e7f8e00aca2c93e3cce9ed35d8c55fb;;	
0000000000000000000000000000000000000000;;	// Package traverse provides basic graph traversal primitives.
0000000000000000000000000000000000000000;;	package traverse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"golang.org/x/tools/container/intsets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph"
0000000000000000000000000000000000000000;;		"k8s.io/kubernetes/third_party/forked/gonum/graph/internal/linear"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BreadthFirst implements stateful breadth-first graph traversal.
0000000000000000000000000000000000000000;;	type BreadthFirst struct {
0000000000000000000000000000000000000000;;		EdgeFilter func(graph.Edge) bool
0000000000000000000000000000000000000000;;		Visit      func(u, v graph.Node)
0000000000000000000000000000000000000000;;		queue      linear.NodeQueue
0000000000000000000000000000000000000000;;		visited    *intsets.Sparse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Walk performs a breadth-first traversal of the graph g starting from the given node,
0000000000000000000000000000000000000000;;	// depending on the the EdgeFilter field and the until parameter if they are non-nil. The
0000000000000000000000000000000000000000;;	// traversal follows edges for which EdgeFilter(edge) is true and returns the first node
0000000000000000000000000000000000000000;;	// for which until(node, depth) is true. During the traversal, if the Visit field is
0000000000000000000000000000000000000000;;	// non-nil, it is called with the nodes joined by each followed edge.
0000000000000000000000000000000000000000;;	func (b *BreadthFirst) Walk(g graph.Graph, from graph.Node, until func(n graph.Node, d int) bool) graph.Node {
0000000000000000000000000000000000000000;;		if b.visited == nil {
0000000000000000000000000000000000000000;;			b.visited = &intsets.Sparse{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.queue.Enqueue(from)
0000000000000000000000000000000000000000;;		b.visited.Insert(from.ID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			depth     int
0000000000000000000000000000000000000000;;			children  int
0000000000000000000000000000000000000000;;			untilNext = 1
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for b.queue.Len() > 0 {
0000000000000000000000000000000000000000;;			t := b.queue.Dequeue()
0000000000000000000000000000000000000000;;			if until != nil && until(t, depth) {
0000000000000000000000000000000000000000;;				return t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, n := range g.From(t) {
0000000000000000000000000000000000000000;;				if b.EdgeFilter != nil && !b.EdgeFilter(g.Edge(t, n)) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b.visited.Has(n.ID()) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b.Visit != nil {
0000000000000000000000000000000000000000;;					b.Visit(t, n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b.visited.Insert(n.ID())
0000000000000000000000000000000000000000;;				children++
0000000000000000000000000000000000000000;;				b.queue.Enqueue(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if untilNext--; untilNext == 0 {
0000000000000000000000000000000000000000;;				depth++
0000000000000000000000000000000000000000;;				untilNext = children
0000000000000000000000000000000000000000;;				children = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WalkAll calls Walk for each unvisited node of the graph g using edges independent
0000000000000000000000000000000000000000;;	// of their direction. The functions before and after are called prior to commencing
0000000000000000000000000000000000000000;;	// and after completing each walk if they are non-nil respectively. The function
0000000000000000000000000000000000000000;;	// during is called on each node as it is traversed.
0000000000000000000000000000000000000000;;	func (b *BreadthFirst) WalkAll(g graph.Undirected, before, after func(), during func(graph.Node)) {
0000000000000000000000000000000000000000;;		b.Reset()
0000000000000000000000000000000000000000;;		for _, from := range g.Nodes() {
0000000000000000000000000000000000000000;;			if b.Visited(from) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if before != nil {
0000000000000000000000000000000000000000;;				before()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.Walk(g, from, func(n graph.Node, _ int) bool {
0000000000000000000000000000000000000000;;				if during != nil {
0000000000000000000000000000000000000000;;					during(n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if after != nil {
0000000000000000000000000000000000000000;;				after()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visited returned whether the node n was visited during a traverse.
0000000000000000000000000000000000000000;;	func (b *BreadthFirst) Visited(n graph.Node) bool {
0000000000000000000000000000000000000000;;		return b.visited != nil && b.visited.Has(n.ID())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the state of the traverser for reuse.
0000000000000000000000000000000000000000;;	func (b *BreadthFirst) Reset() {
0000000000000000000000000000000000000000;;		b.queue.Reset()
0000000000000000000000000000000000000000;;		if b.visited != nil {
0000000000000000000000000000000000000000;;			b.visited.Clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DepthFirst implements stateful depth-first graph traversal.
0000000000000000000000000000000000000000;;	type DepthFirst struct {
0000000000000000000000000000000000000000;;		EdgeFilter func(graph.Edge) bool
0000000000000000000000000000000000000000;;		Visit      func(u, v graph.Node)
0000000000000000000000000000000000000000;;		stack      linear.NodeStack
0000000000000000000000000000000000000000;;		visited    *intsets.Sparse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Walk performs a depth-first traversal of the graph g starting from the given node,
0000000000000000000000000000000000000000;;	// depending on the the EdgeFilter field and the until parameter if they are non-nil. The
0000000000000000000000000000000000000000;;	// traversal follows edges for which EdgeFilter(edge) is true and returns the first node
0000000000000000000000000000000000000000;;	// for which until(node) is true. During the traversal, if the Visit field is non-nil, it
0000000000000000000000000000000000000000;;	// is called with the nodes joined by each followed edge.
0000000000000000000000000000000000000000;;	func (d *DepthFirst) Walk(g graph.Graph, from graph.Node, until func(graph.Node) bool) graph.Node {
0000000000000000000000000000000000000000;;		if d.visited == nil {
0000000000000000000000000000000000000000;;			d.visited = &intsets.Sparse{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.stack.Push(from)
0000000000000000000000000000000000000000;;		d.visited.Insert(from.ID())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for d.stack.Len() > 0 {
0000000000000000000000000000000000000000;;			t := d.stack.Pop()
0000000000000000000000000000000000000000;;			if until != nil && until(t) {
0000000000000000000000000000000000000000;;				return t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, n := range g.From(t) {
0000000000000000000000000000000000000000;;				if d.EdgeFilter != nil && !d.EdgeFilter(g.Edge(t, n)) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if d.visited.Has(n.ID()) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if d.Visit != nil {
0000000000000000000000000000000000000000;;					d.Visit(t, n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.visited.Insert(n.ID())
0000000000000000000000000000000000000000;;				d.stack.Push(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WalkAll calls Walk for each unvisited node of the graph g using edges independent
0000000000000000000000000000000000000000;;	// of their direction. The functions before and after are called prior to commencing
0000000000000000000000000000000000000000;;	// and after completing each walk if they are non-nil respectively. The function
0000000000000000000000000000000000000000;;	// during is called on each node as it is traversed.
0000000000000000000000000000000000000000;;	func (d *DepthFirst) WalkAll(g graph.Undirected, before, after func(), during func(graph.Node)) {
0000000000000000000000000000000000000000;;		d.Reset()
0000000000000000000000000000000000000000;;		for _, from := range g.Nodes() {
0000000000000000000000000000000000000000;;			if d.Visited(from) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if before != nil {
0000000000000000000000000000000000000000;;				before()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.Walk(g, from, func(n graph.Node) bool {
0000000000000000000000000000000000000000;;				if during != nil {
0000000000000000000000000000000000000000;;					during(n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if after != nil {
0000000000000000000000000000000000000000;;				after()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visited returned whether the node n was visited during a traverse.
0000000000000000000000000000000000000000;;	func (d *DepthFirst) Visited(n graph.Node) bool {
0000000000000000000000000000000000000000;;		return d.visited != nil && d.visited.Has(n.ID())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the state of the traverser for reuse.
0000000000000000000000000000000000000000;;	func (d *DepthFirst) Reset() {
0000000000000000000000000000000000000000;;		d.stack = d.stack[:0]
0000000000000000000000000000000000000000;;		if d.visited != nil {
0000000000000000000000000000000000000000;;			d.visited.Clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
