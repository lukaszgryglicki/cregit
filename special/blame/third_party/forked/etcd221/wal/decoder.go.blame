0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
6e04cf52dcc9d574f52de37ef85abbfe8064938a;;	
0000000000000000000000000000000000000000;;	package wal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/crc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decoder struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		br *bufio.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c   io.Closer
0000000000000000000000000000000000000000;;		crc hash.Hash32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDecoder(rc io.ReadCloser) *decoder {
0000000000000000000000000000000000000000;;		return &decoder{
0000000000000000000000000000000000000000;;			br:  bufio.NewReader(rc),
0000000000000000000000000000000000000000;;			c:   rc,
0000000000000000000000000000000000000000;;			crc: crc.New(0, crcTable),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decode(rec *walpb.Record) error {
0000000000000000000000000000000000000000;;		d.mu.Lock()
0000000000000000000000000000000000000000;;		defer d.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rec.Reset()
0000000000000000000000000000000000000000;;		l, err := readInt64(d.br)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := make([]byte, l)
0000000000000000000000000000000000000000;;		if _, err = io.ReadFull(d.br, data); err != nil {
0000000000000000000000000000000000000000;;			// ReadFull returns io.EOF only if no bytes were read
0000000000000000000000000000000000000000;;			// the decoder should treat this as an ErrUnexpectedEOF instead.
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := rec.Unmarshal(data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// skip crc checking if the record type is crcType
0000000000000000000000000000000000000000;;		if rec.Type == crcType {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.crc.Write(rec.Data)
0000000000000000000000000000000000000000;;		return rec.Validate(d.crc.Sum32())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) updateCRC(prevCrc uint32) {
0000000000000000000000000000000000000000;;		d.crc = crc.New(prevCrc, crcTable)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) lastCRC() uint32 {
0000000000000000000000000000000000000000;;		return d.crc.Sum32()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) close() error {
0000000000000000000000000000000000000000;;		return d.c.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustUnmarshalEntry(d []byte) raftpb.Entry {
0000000000000000000000000000000000000000;;		var e raftpb.Entry
0000000000000000000000000000000000000000;;		pbutil.MustUnmarshal(&e, d)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustUnmarshalState(d []byte) raftpb.HardState {
0000000000000000000000000000000000000000;;		var s raftpb.HardState
0000000000000000000000000000000000000000;;		pbutil.MustUnmarshal(&s, d)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readInt64(r io.Reader) (int64, error) {
0000000000000000000000000000000000000000;;		var n int64
0000000000000000000000000000000000000000;;		err := binary.Read(r, binary.LittleEndian, &n)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
