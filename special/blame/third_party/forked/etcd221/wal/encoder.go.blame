0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
6e04cf52dcc9d574f52de37ef85abbfe8064938a;;	
0000000000000000000000000000000000000000;;	package wal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/crc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encoder struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		bw *bufio.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crc       hash.Hash32
0000000000000000000000000000000000000000;;		buf       []byte
0000000000000000000000000000000000000000;;		uint64buf []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEncoder(w io.Writer, prevCrc uint32) *encoder {
0000000000000000000000000000000000000000;;		return &encoder{
0000000000000000000000000000000000000000;;			bw:  bufio.NewWriter(w),
0000000000000000000000000000000000000000;;			crc: crc.New(prevCrc, crcTable),
0000000000000000000000000000000000000000;;			// 1MB buffer
0000000000000000000000000000000000000000;;			buf:       make([]byte, 1024*1024),
0000000000000000000000000000000000000000;;			uint64buf: make([]byte, 8),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) encode(rec *walpb.Record) error {
0000000000000000000000000000000000000000;;		e.mu.Lock()
0000000000000000000000000000000000000000;;		defer e.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.crc.Write(rec.Data)
0000000000000000000000000000000000000000;;		rec.Crc = e.crc.Sum32()
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			data []byte
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;			n    int
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rec.Size() > len(e.buf) {
0000000000000000000000000000000000000000;;			data, err = rec.Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n, err = rec.MarshalTo(e.buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data = e.buf[:n]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := writeInt64(e.bw, int64(len(data)), e.uint64buf); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = e.bw.Write(data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) flush() error {
0000000000000000000000000000000000000000;;		e.mu.Lock()
0000000000000000000000000000000000000000;;		defer e.mu.Unlock()
0000000000000000000000000000000000000000;;		return e.bw.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeInt64(w io.Writer, n int64, buf []byte) error {
0000000000000000000000000000000000000000;;		// http://golang.org/src/encoding/binary/binary.go
0000000000000000000000000000000000000000;;		binary.LittleEndian.PutUint64(buf, uint64(n))
0000000000000000000000000000000000000000;;		_, err := w.Write(buf)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
