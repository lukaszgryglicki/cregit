0000000000000000000000000000000000000000;;	// Copyright 2011 Google Inc. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0bb851a996de6832be77e7fbed24df546e763dcf;third_party/src/code.google.com/p/google-api-go-client/googleapi/googleapi.go[third_party/src/code.google.com/p/google-api-go-client/googleapi/googleapi.go][vendor/google.golang.org/api/googleapi/googleapi.go];	
0000000000000000000000000000000000000000;;	// Package googleapi contains the common code shared by all Google API
0000000000000000000000000000000000000000;;	// libraries.
0000000000000000000000000000000000000000;;	package googleapi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi/internal/uritemplates"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContentTyper is an interface for Readers which know (or would like
0000000000000000000000000000000000000000;;	// to override) their Content-Type. If a media body doesn't implement
0000000000000000000000000000000000000000;;	// ContentTyper, the type is sniffed from the content using
0000000000000000000000000000000000000000;;	// http.DetectContentType.
0000000000000000000000000000000000000000;;	type ContentTyper interface {
0000000000000000000000000000000000000000;;		ContentType() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SizeReaderAt is a ReaderAt with a Size method.
0000000000000000000000000000000000000000;;	// An io.SectionReader implements SizeReaderAt.
0000000000000000000000000000000000000000;;	type SizeReaderAt interface {
0000000000000000000000000000000000000000;;		io.ReaderAt
0000000000000000000000000000000000000000;;		Size() int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerResponse is embedded in each Do response and
0000000000000000000000000000000000000000;;	// provides the HTTP status code and header sent by the server.
0000000000000000000000000000000000000000;;	type ServerResponse struct {
0000000000000000000000000000000000000000;;		// HTTPStatusCode is the server's response status code.
0000000000000000000000000000000000000000;;		// When using a resource method's Do call, this will always be in the 2xx range.
0000000000000000000000000000000000000000;;		HTTPStatusCode int
0000000000000000000000000000000000000000;;		// Header contains the response header fields from the server.
0000000000000000000000000000000000000000;;		Header http.Header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Version = "0.5"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserAgent is the header string used to identify this package.
0000000000000000000000000000000000000000;;		UserAgent = "google-api-go-client/" + Version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The default chunk size to use for resumable uploads if not specified by the user.
0000000000000000000000000000000000000000;;		DefaultUploadChunkSize = 8 * 1024 * 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The minimum chunk size that can be used for resumable uploads.  All
0000000000000000000000000000000000000000;;		// user-specified chunk sizes must be multiple of this value.
0000000000000000000000000000000000000000;;		MinUploadChunkSize = 256 * 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error contains an error response from the server.
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		// Code is the HTTP response status code and will always be populated.
0000000000000000000000000000000000000000;;		Code int `json:"code"`
0000000000000000000000000000000000000000;;		// Message is the server response message and is only populated when
0000000000000000000000000000000000000000;;		// explicitly referenced by the JSON server response.
0000000000000000000000000000000000000000;;		Message string `json:"message"`
0000000000000000000000000000000000000000;;		// Body is the raw response returned by the server.
0000000000000000000000000000000000000000;;		// It is often but not always JSON, depending on how the request fails.
0000000000000000000000000000000000000000;;		Body string
0000000000000000000000000000000000000000;;		// Header contains the response header fields from the server.
0000000000000000000000000000000000000000;;		Header http.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Errors []ErrorItem
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorItem is a detailed error code & message from the Google API frontend.
0000000000000000000000000000000000000000;;	type ErrorItem struct {
0000000000000000000000000000000000000000;;		// Reason is the typed error code. For example: "some_example".
0000000000000000000000000000000000000000;;		Reason string `json:"reason"`
0000000000000000000000000000000000000000;;		// Message is the human-readable description of the error.
0000000000000000000000000000000000000000;;		Message string `json:"message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Error) Error() string {
0000000000000000000000000000000000000000;;		if len(e.Errors) == 0 && e.Message == "" {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("googleapi: got HTTP response code %d with body: %v", e.Code, e.Body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "googleapi: Error %d: ", e.Code)
0000000000000000000000000000000000000000;;		if e.Message != "" {
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "%s", e.Message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(e.Errors) == 0 {
0000000000000000000000000000000000000000;;			return strings.TrimSpace(buf.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(e.Errors) == 1 && e.Errors[0].Message == e.Message {
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, ", %s", e.Errors[0].Reason)
0000000000000000000000000000000000000000;;			return buf.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(&buf, "\nMore details:")
0000000000000000000000000000000000000000;;		for _, v := range e.Errors {
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "Reason: %s, Message: %s\n", v.Reason, v.Message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorReply struct {
0000000000000000000000000000000000000000;;		Error *Error `json:"error"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckResponse returns an error (of type *Error) if the response
0000000000000000000000000000000000000000;;	// status code is not 2xx.
0000000000000000000000000000000000000000;;	func CheckResponse(res *http.Response) error {
0000000000000000000000000000000000000000;;		if res.StatusCode >= 200 && res.StatusCode <= 299 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slurp, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			jerr := new(errorReply)
0000000000000000000000000000000000000000;;			err = json.Unmarshal(slurp, jerr)
0000000000000000000000000000000000000000;;			if err == nil && jerr.Error != nil {
0000000000000000000000000000000000000000;;				if jerr.Error.Code == 0 {
0000000000000000000000000000000000000000;;					jerr.Error.Code = res.StatusCode
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				jerr.Error.Body = string(slurp)
0000000000000000000000000000000000000000;;				return jerr.Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Error{
0000000000000000000000000000000000000000;;			Code:   res.StatusCode,
0000000000000000000000000000000000000000;;			Body:   string(slurp),
0000000000000000000000000000000000000000;;			Header: res.Header,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNotModified reports whether err is the result of the
0000000000000000000000000000000000000000;;	// server replying with http.StatusNotModified.
0000000000000000000000000000000000000000;;	// Such error values are sometimes returned by "Do" methods
0000000000000000000000000000000000000000;;	// on calls when If-None-Match is used.
0000000000000000000000000000000000000000;;	func IsNotModified(err error) bool {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ae, ok := err.(*Error)
0000000000000000000000000000000000000000;;		return ok && ae.Code == http.StatusNotModified
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckMediaResponse returns an error (of type *Error) if the response
0000000000000000000000000000000000000000;;	// status code is not 2xx. Unlike CheckResponse it does not assume the
0000000000000000000000000000000000000000;;	// body is a JSON error document.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to close res.Body.
0000000000000000000000000000000000000000;;	func CheckMediaResponse(res *http.Response) error {
0000000000000000000000000000000000000000;;		if res.StatusCode >= 200 && res.StatusCode <= 299 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slurp, _ := ioutil.ReadAll(io.LimitReader(res.Body, 1<<20))
0000000000000000000000000000000000000000;;		return &Error{
0000000000000000000000000000000000000000;;			Code: res.StatusCode,
0000000000000000000000000000000000000000;;			Body: string(slurp),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MarshalStyle bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var WithDataWrapper = MarshalStyle(true)
0000000000000000000000000000000000000000;;	var WithoutDataWrapper = MarshalStyle(false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wrap MarshalStyle) JSONReader(v interface{}) (io.Reader, error) {
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		if wrap {
0000000000000000000000000000000000000000;;			buf.Write([]byte(`{"data": `))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := json.NewEncoder(buf).Encode(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wrap {
0000000000000000000000000000000000000000;;			buf.Write([]byte(`}`))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// endingWithErrorReader from r until it returns an error.  If the
0000000000000000000000000000000000000000;;	// final error from r is io.EOF and e is non-nil, e is used instead.
0000000000000000000000000000000000000000;;	type endingWithErrorReader struct {
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;		e error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (er endingWithErrorReader) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, err = er.r.Read(p)
0000000000000000000000000000000000000000;;		if err == io.EOF && er.e != nil {
0000000000000000000000000000000000000000;;			err = er.e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// countingWriter counts the number of bytes it receives to write, but
0000000000000000000000000000000000000000;;	// discards them.
0000000000000000000000000000000000000000;;	type countingWriter struct {
0000000000000000000000000000000000000000;;		n *int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w countingWriter) Write(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		*w.n += int64(len(p))
0000000000000000000000000000000000000000;;		return len(p), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProgressUpdater is a function that is called upon every progress update of a resumable upload.
0000000000000000000000000000000000000000;;	// This is the only part of a resumable upload (from googleapi) that is usable by the developer.
0000000000000000000000000000000000000000;;	// The remaining usable pieces of resumable uploads is exposed in each auto-generated API.
0000000000000000000000000000000000000000;;	type ProgressUpdater func(current, total int64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MediaOption interface {
0000000000000000000000000000000000000000;;		setOptions(o *MediaOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type contentTypeOption string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ct contentTypeOption) setOptions(o *MediaOptions) {
0000000000000000000000000000000000000000;;		o.ContentType = string(ct)
0000000000000000000000000000000000000000;;		if o.ContentType == "" {
0000000000000000000000000000000000000000;;			o.ForceEmptyContentType = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContentType returns a MediaOption which sets the Content-Type header for media uploads.
0000000000000000000000000000000000000000;;	// If ctype is empty, the Content-Type header will be omitted.
0000000000000000000000000000000000000000;;	func ContentType(ctype string) MediaOption {
0000000000000000000000000000000000000000;;		return contentTypeOption(ctype)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type chunkSizeOption int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs chunkSizeOption) setOptions(o *MediaOptions) {
0000000000000000000000000000000000000000;;		size := int(cs)
0000000000000000000000000000000000000000;;		if size%MinUploadChunkSize != 0 {
0000000000000000000000000000000000000000;;			size += MinUploadChunkSize - (size % MinUploadChunkSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.ChunkSize = size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChunkSize returns a MediaOption which sets the chunk size for media uploads.
0000000000000000000000000000000000000000;;	// size will be rounded up to the nearest multiple of 256K.
0000000000000000000000000000000000000000;;	// Media which contains fewer than size bytes will be uploaded in a single request.
0000000000000000000000000000000000000000;;	// Media which contains size bytes or more will be uploaded in separate chunks.
0000000000000000000000000000000000000000;;	// If size is zero, media will be uploaded in a single request.
0000000000000000000000000000000000000000;;	func ChunkSize(size int) MediaOption {
0000000000000000000000000000000000000000;;		return chunkSizeOption(size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MediaOptions stores options for customizing media upload.  It is not used by developers directly.
0000000000000000000000000000000000000000;;	type MediaOptions struct {
0000000000000000000000000000000000000000;;		ContentType           string
0000000000000000000000000000000000000000;;		ForceEmptyContentType bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ChunkSize int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProcessMediaOptions stores options from opts in a MediaOptions.
0000000000000000000000000000000000000000;;	// It is not used by developers directly.
0000000000000000000000000000000000000000;;	func ProcessMediaOptions(opts []MediaOption) *MediaOptions {
0000000000000000000000000000000000000000;;		mo := &MediaOptions{ChunkSize: DefaultUploadChunkSize}
0000000000000000000000000000000000000000;;		for _, o := range opts {
0000000000000000000000000000000000000000;;			o.setOptions(mo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ResolveRelative(basestr, relstr string) string {
0000000000000000000000000000000000000000;;		u, _ := url.Parse(basestr)
0000000000000000000000000000000000000000;;		rel, _ := url.Parse(relstr)
0000000000000000000000000000000000000000;;		u = u.ResolveReference(rel)
0000000000000000000000000000000000000000;;		us := u.String()
0000000000000000000000000000000000000000;;		us = strings.Replace(us, "%7B", "{", -1)
0000000000000000000000000000000000000000;;		us = strings.Replace(us, "%7D", "}", -1)
0000000000000000000000000000000000000000;;		return us
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Expand subsitutes any {encoded} strings in the URL passed in using
0000000000000000000000000000000000000000;;	// the map supplied.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This calls SetOpaque to avoid encoding of the parameters in the URL path.
0000000000000000000000000000000000000000;;	func Expand(u *url.URL, expansions map[string]string) {
0000000000000000000000000000000000000000;;		escaped, unescaped, err := uritemplates.Expand(u.Path, expansions)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			u.Path = unescaped
0000000000000000000000000000000000000000;;			u.RawPath = escaped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseBody is used to close res.Body.
0000000000000000000000000000000000000000;;	// Prior to calling Close, it also tries to Read a small amount to see an EOF.
0000000000000000000000000000000000000000;;	// Not seeing an EOF can prevent HTTP Transports from reusing connections.
0000000000000000000000000000000000000000;;	func CloseBody(res *http.Response) {
0000000000000000000000000000000000000000;;		if res == nil || res.Body == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Justification for 3 byte reads: two for up to "\r\n" after
0000000000000000000000000000000000000000;;		// a JSON/XML document, and then 1 to see EOF if we haven't yet.
0000000000000000000000000000000000000000;;		// TODO(bradfitz): detect Go 1.3+ and skip these reads.
0000000000000000000000000000000000000000;;		// See https://codereview.appspot.com/58240043
0000000000000000000000000000000000000000;;		// and https://codereview.appspot.com/49570044
0000000000000000000000000000000000000000;;		buf := make([]byte, 1)
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			_, err := res.Body.Read(buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VariantType returns the type name of the given variant.
0000000000000000000000000000000000000000;;	// If the map doesn't contain the named key or the value is not a []interface{}, "" is returned.
0000000000000000000000000000000000000000;;	// This is used to support "variant" APIs that can return one of a number of different types.
0000000000000000000000000000000000000000;;	func VariantType(t map[string]interface{}) string {
0000000000000000000000000000000000000000;;		s, _ := t["type"].(string)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertVariant uses the JSON encoder/decoder to fill in the struct 'dst' with the fields found in variant 'v'.
0000000000000000000000000000000000000000;;	// This is used to support "variant" APIs that can return one of a number of different types.
0000000000000000000000000000000000000000;;	// It reports whether the conversion was successful.
0000000000000000000000000000000000000000;;	func ConvertVariant(v map[string]interface{}, dst interface{}) bool {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		err := json.NewEncoder(&buf).Encode(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Unmarshal(buf.Bytes(), dst) == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Field names a field to be retrieved with a partial response.
0000000000000000000000000000000000000000;;	// See https://developers.google.com/gdata/docs/2.0/basics#PartialResponse
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Partial responses can dramatically reduce the amount of data that must be sent to your application.
0000000000000000000000000000000000000000;;	// In order to request partial responses, you can specify the full list of fields
0000000000000000000000000000000000000000;;	// that your application needs by adding the Fields option to your request.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Field strings use camelCase with leading lower-case characters to identify fields within the response.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, if your response has a "NextPageToken" and a slice of "Items" with "Id" fields,
0000000000000000000000000000000000000000;;	// you could request just those fields like this:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     svc.Events.List().Fields("nextPageToken", "items/id").Do()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// or if you were also interested in each Item's "Updated" field, you can combine them like this:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     svc.Events.List().Fields("nextPageToken", "items(id,updated)").Do()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// More information about field formatting can be found here:
0000000000000000000000000000000000000000;;	// https://developers.google.com/+/api/#fields-syntax
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Another way to find field names is through the Google API explorer:
0000000000000000000000000000000000000000;;	// https://developers.google.com/apis-explorer/#p/
0000000000000000000000000000000000000000;;	type Field string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CombineFields combines fields into a single string.
0000000000000000000000000000000000000000;;	func CombineFields(s []Field) string {
0000000000000000000000000000000000000000;;		r := make([]string, len(s))
0000000000000000000000000000000000000000;;		for i, v := range s {
0000000000000000000000000000000000000000;;			r[i] = string(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(r, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A CallOption is an optional argument to an API call.
0000000000000000000000000000000000000000;;	// It should be treated as an opaque value by users of Google APIs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A CallOption is something that configures an API call in a way that is
0000000000000000000000000000000000000000;;	// not specific to that API; for instance, controlling the quota user for
0000000000000000000000000000000000000000;;	// an API call is common across many APIs, and is thus a CallOption.
0000000000000000000000000000000000000000;;	type CallOption interface {
0000000000000000000000000000000000000000;;		Get() (key, value string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QuotaUser returns a CallOption that will set the quota user for a call.
0000000000000000000000000000000000000000;;	// The quota user can be used by server-side applications to control accounting.
0000000000000000000000000000000000000000;;	// It can be an arbitrary string up to 40 characters, and will override UserIP
0000000000000000000000000000000000000000;;	// if both are provided.
0000000000000000000000000000000000000000;;	func QuotaUser(u string) CallOption { return quotaUser(u) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quotaUser string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q quotaUser) Get() (string, string) { return "quotaUser", string(q) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UserIP returns a CallOption that will set the "userIp" parameter of a call.
0000000000000000000000000000000000000000;;	// This should be the IP address of the originating request.
0000000000000000000000000000000000000000;;	func UserIP(ip string) CallOption { return userIP(ip) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userIP string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i userIP) Get() (string, string) { return "userIp", string(i) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Trace returns a CallOption that enables diagnostic tracing for a call.
0000000000000000000000000000000000000000;;	// traceToken is an ID supplied by Google support.
0000000000000000000000000000000000000000;;	func Trace(traceToken string) CallOption { return traceTok(traceToken) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type traceTok string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t traceTok) Get() (string, string) { return "trace", "token:" + string(t) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Fields too
