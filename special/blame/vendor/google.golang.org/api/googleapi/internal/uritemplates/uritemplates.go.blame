0000000000000000000000000000000000000000;;	// Copyright 2013 Joshua Tacoma. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
3c5b01cf3b40a66d614a82b4e47a8137b9009330;Godeps/_workspace/src/code.google.com/p/google-api-go-client/googleapi/internal/uritemplates/uritemplates.go[Godeps/_workspace/src/code.google.com/p/google-api-go-client/googleapi/internal/uritemplates/uritemplates.go][vendor/google.golang.org/api/googleapi/internal/uritemplates/uritemplates.go];	
0000000000000000000000000000000000000000;;	// Package uritemplates is a level 3 implementation of RFC 6570 (URI
0000000000000000000000000000000000000000;;	// Template, http://tools.ietf.org/html/rfc6570).
0000000000000000000000000000000000000000;;	// uritemplates does not support composite values (in Go: slices or maps)
0000000000000000000000000000000000000000;;	// and so does not qualify as a level 4 implementation.
0000000000000000000000000000000000000000;;	package uritemplates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		unreserved = regexp.MustCompile("[^A-Za-z0-9\\-._~]")
0000000000000000000000000000000000000000;;		reserved   = regexp.MustCompile("[^A-Za-z0-9\\-._~:/?#[\\]@!$&'()*+,;=]")
0000000000000000000000000000000000000000;;		validname  = regexp.MustCompile("^([A-Za-z0-9_\\.]|%[0-9A-Fa-f][0-9A-Fa-f])+$")
0000000000000000000000000000000000000000;;		hex        = []byte("0123456789ABCDEF")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pctEncode(src []byte) []byte {
0000000000000000000000000000000000000000;;		dst := make([]byte, len(src)*3)
0000000000000000000000000000000000000000;;		for i, b := range src {
0000000000000000000000000000000000000000;;			buf := dst[i*3 : i*3+3]
0000000000000000000000000000000000000000;;			buf[0] = 0x25
0000000000000000000000000000000000000000;;			buf[1] = hex[b/16]
0000000000000000000000000000000000000000;;			buf[2] = hex[b%16]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pairWriter is a convenience struct which allows escaped and unescaped
0000000000000000000000000000000000000000;;	// versions of the template to be written in parallel.
0000000000000000000000000000000000000000;;	type pairWriter struct {
0000000000000000000000000000000000000000;;		escaped, unescaped bytes.Buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes the provided string directly without any escaping.
0000000000000000000000000000000000000000;;	func (w *pairWriter) Write(s string) {
0000000000000000000000000000000000000000;;		w.escaped.WriteString(s)
0000000000000000000000000000000000000000;;		w.unescaped.WriteString(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Escape writes the provided string, escaping the string for the
0000000000000000000000000000000000000000;;	// escaped output.
0000000000000000000000000000000000000000;;	func (w *pairWriter) Escape(s string, allowReserved bool) {
0000000000000000000000000000000000000000;;		w.unescaped.WriteString(s)
0000000000000000000000000000000000000000;;		if allowReserved {
0000000000000000000000000000000000000000;;			w.escaped.Write(reserved.ReplaceAllFunc([]byte(s), pctEncode))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.escaped.Write(unreserved.ReplaceAllFunc([]byte(s), pctEncode))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Escaped returns the escaped string.
0000000000000000000000000000000000000000;;	func (w *pairWriter) Escaped() string {
0000000000000000000000000000000000000000;;		return w.escaped.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unescaped returns the unescaped string.
0000000000000000000000000000000000000000;;	func (w *pairWriter) Unescaped() string {
0000000000000000000000000000000000000000;;		return w.unescaped.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A uriTemplate is a parsed representation of a URI template.
0000000000000000000000000000000000000000;;	type uriTemplate struct {
0000000000000000000000000000000000000000;;		raw   string
0000000000000000000000000000000000000000;;		parts []templatePart
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse parses a URI template string into a uriTemplate object.
0000000000000000000000000000000000000000;;	func parse(rawTemplate string) (*uriTemplate, error) {
0000000000000000000000000000000000000000;;		split := strings.Split(rawTemplate, "{")
0000000000000000000000000000000000000000;;		parts := make([]templatePart, len(split)*2-1)
0000000000000000000000000000000000000000;;		for i, s := range split {
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				if strings.Contains(s, "}") {
0000000000000000000000000000000000000000;;					return nil, errors.New("unexpected }")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				parts[i].raw = s
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			subsplit := strings.Split(s, "}")
0000000000000000000000000000000000000000;;			if len(subsplit) != 2 {
0000000000000000000000000000000000000000;;				return nil, errors.New("malformed template")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expression := subsplit[0]
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			parts[i*2-1], err = parseExpression(expression)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts[i*2].raw = subsplit[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &uriTemplate{
0000000000000000000000000000000000000000;;			raw:   rawTemplate,
0000000000000000000000000000000000000000;;			parts: parts,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type templatePart struct {
0000000000000000000000000000000000000000;;		raw           string
0000000000000000000000000000000000000000;;		terms         []templateTerm
0000000000000000000000000000000000000000;;		first         string
0000000000000000000000000000000000000000;;		sep           string
0000000000000000000000000000000000000000;;		named         bool
0000000000000000000000000000000000000000;;		ifemp         string
0000000000000000000000000000000000000000;;		allowReserved bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type templateTerm struct {
0000000000000000000000000000000000000000;;		name     string
0000000000000000000000000000000000000000;;		explode  bool
0000000000000000000000000000000000000000;;		truncate int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseExpression(expression string) (result templatePart, err error) {
0000000000000000000000000000000000000000;;		switch expression[0] {
0000000000000000000000000000000000000000;;		case '+':
0000000000000000000000000000000000000000;;			result.sep = ","
0000000000000000000000000000000000000000;;			result.allowReserved = true
0000000000000000000000000000000000000000;;			expression = expression[1:]
0000000000000000000000000000000000000000;;		case '.':
0000000000000000000000000000000000000000;;			result.first = "."
0000000000000000000000000000000000000000;;			result.sep = "."
0000000000000000000000000000000000000000;;			expression = expression[1:]
0000000000000000000000000000000000000000;;		case '/':
0000000000000000000000000000000000000000;;			result.first = "/"
0000000000000000000000000000000000000000;;			result.sep = "/"
0000000000000000000000000000000000000000;;			expression = expression[1:]
0000000000000000000000000000000000000000;;		case ';':
0000000000000000000000000000000000000000;;			result.first = ";"
0000000000000000000000000000000000000000;;			result.sep = ";"
0000000000000000000000000000000000000000;;			result.named = true
0000000000000000000000000000000000000000;;			expression = expression[1:]
0000000000000000000000000000000000000000;;		case '?':
0000000000000000000000000000000000000000;;			result.first = "?"
0000000000000000000000000000000000000000;;			result.sep = "&"
0000000000000000000000000000000000000000;;			result.named = true
0000000000000000000000000000000000000000;;			result.ifemp = "="
0000000000000000000000000000000000000000;;			expression = expression[1:]
0000000000000000000000000000000000000000;;		case '&':
0000000000000000000000000000000000000000;;			result.first = "&"
0000000000000000000000000000000000000000;;			result.sep = "&"
0000000000000000000000000000000000000000;;			result.named = true
0000000000000000000000000000000000000000;;			result.ifemp = "="
0000000000000000000000000000000000000000;;			expression = expression[1:]
0000000000000000000000000000000000000000;;		case '#':
0000000000000000000000000000000000000000;;			result.first = "#"
0000000000000000000000000000000000000000;;			result.sep = ","
0000000000000000000000000000000000000000;;			result.allowReserved = true
0000000000000000000000000000000000000000;;			expression = expression[1:]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			result.sep = ","
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rawterms := strings.Split(expression, ",")
0000000000000000000000000000000000000000;;		result.terms = make([]templateTerm, len(rawterms))
0000000000000000000000000000000000000000;;		for i, raw := range rawterms {
0000000000000000000000000000000000000000;;			result.terms[i], err = parseTerm(raw)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseTerm(term string) (result templateTerm, err error) {
0000000000000000000000000000000000000000;;		// TODO(djd): Remove "*" suffix parsing once we check that no APIs have
0000000000000000000000000000000000000000;;		// mistakenly used that attribute.
0000000000000000000000000000000000000000;;		if strings.HasSuffix(term, "*") {
0000000000000000000000000000000000000000;;			result.explode = true
0000000000000000000000000000000000000000;;			term = term[:len(term)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		split := strings.Split(term, ":")
0000000000000000000000000000000000000000;;		if len(split) == 1 {
0000000000000000000000000000000000000000;;			result.name = term
0000000000000000000000000000000000000000;;		} else if len(split) == 2 {
0000000000000000000000000000000000000000;;			result.name = split[0]
0000000000000000000000000000000000000000;;			var parsed int64
0000000000000000000000000000000000000000;;			parsed, err = strconv.ParseInt(split[1], 10, 0)
0000000000000000000000000000000000000000;;			result.truncate = int(parsed)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = errors.New("multiple colons in same term")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !validname.MatchString(result.name) {
0000000000000000000000000000000000000000;;			err = errors.New("not a valid name: " + result.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.explode && result.truncate > 0 {
0000000000000000000000000000000000000000;;			err = errors.New("both explode and prefix modifers on same term")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Expand expands a URI template with a set of values to produce the
0000000000000000000000000000000000000000;;	// resultant URI. Two forms of the result are returned: one with all the
0000000000000000000000000000000000000000;;	// elements escaped, and one with the elements unescaped.
0000000000000000000000000000000000000000;;	func (t *uriTemplate) Expand(values map[string]string) (escaped, unescaped string) {
0000000000000000000000000000000000000000;;		var w pairWriter
0000000000000000000000000000000000000000;;		for _, p := range t.parts {
0000000000000000000000000000000000000000;;			p.expand(&w, values)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Escaped(), w.Unescaped()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tp *templatePart) expand(w *pairWriter, values map[string]string) {
0000000000000000000000000000000000000000;;		if len(tp.raw) > 0 {
0000000000000000000000000000000000000000;;			w.Write(tp.raw)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var first = true
0000000000000000000000000000000000000000;;		for _, term := range tp.terms {
0000000000000000000000000000000000000000;;			value, exists := values[term.name]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				w.Write(tp.first)
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write(tp.sep)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tp.expandString(w, term, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tp *templatePart) expandName(w *pairWriter, name string, empty bool) {
0000000000000000000000000000000000000000;;		if tp.named {
0000000000000000000000000000000000000000;;			w.Write(name)
0000000000000000000000000000000000000000;;			if empty {
0000000000000000000000000000000000000000;;				w.Write(tp.ifemp)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.Write("=")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tp *templatePart) expandString(w *pairWriter, t templateTerm, s string) {
0000000000000000000000000000000000000000;;		if len(s) > t.truncate && t.truncate > 0 {
0000000000000000000000000000000000000000;;			s = s[:t.truncate]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tp.expandName(w, t.name, len(s) == 0)
0000000000000000000000000000000000000000;;		w.Escape(s, tp.allowReserved)
0000000000000000000000000000000000000000;;	}
