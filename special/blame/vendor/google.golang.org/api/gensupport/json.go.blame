0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0c9cd978a5434280274c834bdab152689fd59b88;Godeps/_workspace/src/google.golang.org/api/gensupport/json.go[Godeps/_workspace/src/google.golang.org/api/gensupport/json.go][vendor/google.golang.org/api/gensupport/json.go];	
0000000000000000000000000000000000000000;;	package gensupport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON returns a JSON encoding of schema containing only selected fields.
0000000000000000000000000000000000000000;;	// A field is selected if any of the following is true:
0000000000000000000000000000000000000000;;	//   * it has a non-empty value
0000000000000000000000000000000000000000;;	//   * its field name is present in forceSendFields and it is not a nil pointer or nil interface
0000000000000000000000000000000000000000;;	//   * its field name is present in nullFields.
0000000000000000000000000000000000000000;;	// The JSON key for each selected field is taken from the field's json: struct tag.
0000000000000000000000000000000000000000;;	func MarshalJSON(schema interface{}, forceSendFields, nullFields []string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(forceSendFields) == 0 && len(nullFields) == 0 {
0000000000000000000000000000000000000000;;			return json.Marshal(schema)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mustInclude := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, f := range forceSendFields {
0000000000000000000000000000000000000000;;			mustInclude[f] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		useNull := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, f := range nullFields {
0000000000000000000000000000000000000000;;			useNull[f] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataMap, err := schemaToMap(schema, mustInclude, useNull)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(dataMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func schemaToMap(schema interface{}, mustInclude, useNull map[string]struct{}) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		m := make(map[string]interface{})
0000000000000000000000000000000000000000;;		s := reflect.ValueOf(schema)
0000000000000000000000000000000000000000;;		st := s.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < s.NumField(); i++ {
0000000000000000000000000000000000000000;;			jsonTag := st.Field(i).Tag.Get("json")
0000000000000000000000000000000000000000;;			if jsonTag == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tag, err := parseJSONTag(jsonTag)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tag.ignore {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v := s.Field(i)
0000000000000000000000000000000000000000;;			f := st.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, ok := useNull[f.Name]; ok {
0000000000000000000000000000000000000000;;				if !isEmptyValue(v) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("field %q in NullFields has non-empty value", f.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m[tag.apiName] = nil
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !includeField(v, f, mustInclude) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// nil maps are treated as empty maps.
0000000000000000000000000000000000000000;;			if f.Type.Kind() == reflect.Map && v.IsNil() {
0000000000000000000000000000000000000000;;				m[tag.apiName] = map[string]string{}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// nil slices are treated as empty slices.
0000000000000000000000000000000000000000;;			if f.Type.Kind() == reflect.Slice && v.IsNil() {
0000000000000000000000000000000000000000;;				m[tag.apiName] = []bool{}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tag.stringFormat {
0000000000000000000000000000000000000000;;				m[tag.apiName] = formatAsString(v, f.Type.Kind())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				m[tag.apiName] = v.Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatAsString returns a string representation of v, dereferencing it first if possible.
0000000000000000000000000000000000000000;;	func formatAsString(v reflect.Value, kind reflect.Kind) string {
0000000000000000000000000000000000000000;;		if kind == reflect.Ptr && !v.IsNil() {
0000000000000000000000000000000000000000;;			v = v.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v", v.Interface())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// jsonTag represents a restricted version of the struct tag format used by encoding/json.
0000000000000000000000000000000000000000;;	// It is used to describe the JSON encoding of fields in a Schema struct.
0000000000000000000000000000000000000000;;	type jsonTag struct {
0000000000000000000000000000000000000000;;		apiName      string
0000000000000000000000000000000000000000;;		stringFormat bool
0000000000000000000000000000000000000000;;		ignore       bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseJSONTag parses a restricted version of the struct tag format used by encoding/json.
0000000000000000000000000000000000000000;;	// The format of the tag must match that generated by the Schema.writeSchemaStruct method
0000000000000000000000000000000000000000;;	// in the api generator.
0000000000000000000000000000000000000000;;	func parseJSONTag(val string) (jsonTag, error) {
0000000000000000000000000000000000000000;;		if val == "-" {
0000000000000000000000000000000000000000;;			return jsonTag{ignore: true}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tag jsonTag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := strings.Index(val, ",")
0000000000000000000000000000000000000000;;		if i == -1 || val[:i] == "" {
0000000000000000000000000000000000000000;;			return tag, fmt.Errorf("malformed json tag: %s", val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tag = jsonTag{
0000000000000000000000000000000000000000;;			apiName: val[:i],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch val[i+1:] {
0000000000000000000000000000000000000000;;		case "omitempty":
0000000000000000000000000000000000000000;;		case "omitempty,string":
0000000000000000000000000000000000000000;;			tag.stringFormat = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return tag, fmt.Errorf("malformed json tag: %s", val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tag, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reports whether the struct field "f" with value "v" should be included in JSON output.
0000000000000000000000000000000000000000;;	func includeField(v reflect.Value, f reflect.StructField, mustInclude map[string]struct{}) bool {
0000000000000000000000000000000000000000;;		// The regular JSON encoding of a nil pointer is "null", which means "delete this field".
0000000000000000000000000000000000000000;;		// Therefore, we could enable field deletion by honoring pointer fields' presence in the mustInclude set.
0000000000000000000000000000000000000000;;		// However, many fields are not pointers, so there would be no way to delete these fields.
0000000000000000000000000000000000000000;;		// Rather than partially supporting field deletion, we ignore mustInclude for nil pointer fields.
0000000000000000000000000000000000000000;;		// Deletion will be handled by a separate mechanism.
0000000000000000000000000000000000000000;;		if f.Type.Kind() == reflect.Ptr && v.IsNil() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The "any" type is represented as an interface{}.  If this interface
0000000000000000000000000000000000000000;;		// is nil, there is no reasonable representation to send.  We ignore
0000000000000000000000000000000000000000;;		// these fields, for the same reasons as given above for pointers.
0000000000000000000000000000000000000000;;		if f.Type.Kind() == reflect.Interface && v.IsNil() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, ok := mustInclude[f.Name]
0000000000000000000000000000000000000000;;		return ok || !isEmptyValue(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isEmptyValue reports whether v is the empty value for its type.  This
0000000000000000000000000000000000000000;;	// implementation is based on that of the encoding/json package, but its
0000000000000000000000000000000000000000;;	// correctness does not depend on it being identical. What's important is that
0000000000000000000000000000000000000000;;	// this function return false in situations where v should not be sent as part
0000000000000000000000000000000000000000;;	// of a PATCH operation.
0000000000000000000000000000000000000000;;	func isEmptyValue(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
