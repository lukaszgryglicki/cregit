0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
db73eca7336e67cf99cea454745afc888e9596fd;;	
0000000000000000000000000000000000000000;;	package gensupport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// statusTooManyRequests is returned by the storage API if the
0000000000000000000000000000000000000000;;		// per-project limits have been temporarily exceeded. The request
0000000000000000000000000000000000000000;;		// should be retried.
0000000000000000000000000000000000000000;;		// https://cloud.google.com/storage/docs/json_api/v1/status-codes#standardcodes
0000000000000000000000000000000000000000;;		statusTooManyRequests = 429
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResumableUpload is used by the generated APIs to provide resumable uploads.
0000000000000000000000000000000000000000;;	// It is not used by developers directly.
0000000000000000000000000000000000000000;;	type ResumableUpload struct {
0000000000000000000000000000000000000000;;		Client *http.Client
0000000000000000000000000000000000000000;;		// URI is the resumable resource destination provided by the server after specifying "&uploadType=resumable".
0000000000000000000000000000000000000000;;		URI       string
0000000000000000000000000000000000000000;;		UserAgent string // User-Agent for header of the request
0000000000000000000000000000000000000000;;		// Media is the object being uploaded.
0000000000000000000000000000000000000000;;		Media *MediaBuffer
0000000000000000000000000000000000000000;;		// MediaType defines the media type, e.g. "image/jpeg".
0000000000000000000000000000000000000000;;		MediaType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu       sync.Mutex // guards progress
0000000000000000000000000000000000000000;;		progress int64      // number of bytes uploaded so far
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Callback is an optional function that will be periodically called with the cumulative number of bytes uploaded.
0000000000000000000000000000000000000000;;		Callback func(int64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If not specified, a default exponential backoff strategy will be used.
0000000000000000000000000000000000000000;;		Backoff BackoffStrategy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Progress returns the number of bytes uploaded at this point.
0000000000000000000000000000000000000000;;	func (rx *ResumableUpload) Progress() int64 {
0000000000000000000000000000000000000000;;		rx.mu.Lock()
0000000000000000000000000000000000000000;;		defer rx.mu.Unlock()
0000000000000000000000000000000000000000;;		return rx.progress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doUploadRequest performs a single HTTP request to upload data.
0000000000000000000000000000000000000000;;	// off specifies the offset in rx.Media from which data is drawn.
0000000000000000000000000000000000000000;;	// size is the number of bytes in data.
0000000000000000000000000000000000000000;;	// final specifies whether data is the final chunk to be uploaded.
0000000000000000000000000000000000000000;;	func (rx *ResumableUpload) doUploadRequest(ctx context.Context, data io.Reader, off, size int64, final bool) (*http.Response, error) {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", rx.URI, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.ContentLength = size
0000000000000000000000000000000000000000;;		var contentRange string
0000000000000000000000000000000000000000;;		if final {
0000000000000000000000000000000000000000;;			if size == 0 {
0000000000000000000000000000000000000000;;				contentRange = fmt.Sprintf("bytes */%v", off)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				contentRange = fmt.Sprintf("bytes %v-%v/%v", off, off+size-1, off+size)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			contentRange = fmt.Sprintf("bytes %v-%v/*", off, off+size-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Range", contentRange)
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", rx.MediaType)
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", rx.UserAgent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Google's upload endpoint uses status code 308 for a
0000000000000000000000000000000000000000;;		// different purpose than the "308 Permanent Redirect"
0000000000000000000000000000000000000000;;		// since-standardized in RFC 7238. Because of the conflict in
0000000000000000000000000000000000000000;;		// semantics, Google added this new request header which
0000000000000000000000000000000000000000;;		// causes it to not use "308" and instead reply with 200 OK
0000000000000000000000000000000000000000;;		// and sets the upload-specific "X-HTTP-Status-Code-Override:
0000000000000000000000000000000000000000;;		// 308" response header.
0000000000000000000000000000000000000000;;		req.Header.Set("X-GUploader-No-308", "yes")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return SendRequest(ctx, rx.Client, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func statusResumeIncomplete(resp *http.Response) bool {
0000000000000000000000000000000000000000;;		// This is how the server signals "status resume incomplete"
0000000000000000000000000000000000000000;;		// when X-GUploader-No-308 is set to "yes":
0000000000000000000000000000000000000000;;		return resp != nil && resp.Header.Get("X-Http-Status-Code-Override") == "308"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reportProgress calls a user-supplied callback to report upload progress.
0000000000000000000000000000000000000000;;	// If old==updated, the callback is not called.
0000000000000000000000000000000000000000;;	func (rx *ResumableUpload) reportProgress(old, updated int64) {
0000000000000000000000000000000000000000;;		if updated-old == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rx.mu.Lock()
0000000000000000000000000000000000000000;;		rx.progress = updated
0000000000000000000000000000000000000000;;		rx.mu.Unlock()
0000000000000000000000000000000000000000;;		if rx.Callback != nil {
0000000000000000000000000000000000000000;;			rx.Callback(updated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transferChunk performs a single HTTP request to upload a single chunk from rx.Media.
0000000000000000000000000000000000000000;;	func (rx *ResumableUpload) transferChunk(ctx context.Context) (*http.Response, error) {
0000000000000000000000000000000000000000;;		chunk, off, size, err := rx.Media.Chunk()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := err == io.EOF
0000000000000000000000000000000000000000;;		if !done && err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := rx.doUploadRequest(ctx, chunk, off, int64(size), done)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We sent "X-GUploader-No-308: yes" (see comment elsewhere in
0000000000000000000000000000000000000000;;		// this file), so we don't expect to get a 308.
0000000000000000000000000000000000000000;;		if res.StatusCode == 308 {
0000000000000000000000000000000000000000;;			return nil, errors.New("unexpected 308 response status code")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if res.StatusCode == http.StatusOK {
0000000000000000000000000000000000000000;;			rx.reportProgress(off, off+int64(size))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if statusResumeIncomplete(res) {
0000000000000000000000000000000000000000;;			rx.Media.Next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contextDone(ctx context.Context) bool {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Upload starts the process of a resumable upload with a cancellable context.
0000000000000000000000000000000000000000;;	// It retries using the provided back off strategy until cancelled or the
0000000000000000000000000000000000000000;;	// strategy indicates to stop retrying.
0000000000000000000000000000000000000000;;	// It is called from the auto-generated API code and is not visible to the user.
0000000000000000000000000000000000000000;;	// Before sending an HTTP request, Upload calls any registered hook functions,
0000000000000000000000000000000000000000;;	// and calls the returned functions after the request returns (see send.go).
0000000000000000000000000000000000000000;;	// rx is private to the auto-generated API code.
0000000000000000000000000000000000000000;;	// Exactly one of resp or err will be nil.  If resp is non-nil, the caller must call resp.Body.Close.
0000000000000000000000000000000000000000;;	func (rx *ResumableUpload) Upload(ctx context.Context) (resp *http.Response, err error) {
0000000000000000000000000000000000000000;;		var pause time.Duration
0000000000000000000000000000000000000000;;		backoff := rx.Backoff
0000000000000000000000000000000000000000;;		if backoff == nil {
0000000000000000000000000000000000000000;;			backoff = DefaultBackoffStrategy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Ensure that we return in the case of cancelled context, even if pause is 0.
0000000000000000000000000000000000000000;;			if contextDone(ctx) {
0000000000000000000000000000000000000000;;				return nil, ctx.Err()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return nil, ctx.Err()
0000000000000000000000000000000000000000;;			case <-time.After(pause):
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err = rx.transferChunk(ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var status int
0000000000000000000000000000000000000000;;			if resp != nil {
0000000000000000000000000000000000000000;;				status = resp.StatusCode
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if we should retry the request.
0000000000000000000000000000000000000000;;			if shouldRetry(status, err) {
0000000000000000000000000000000000000000;;				var retry bool
0000000000000000000000000000000000000000;;				pause, retry = backoff.Pause()
0000000000000000000000000000000000000000;;				if retry {
0000000000000000000000000000000000000000;;					if resp != nil && resp.Body != nil {
0000000000000000000000000000000000000000;;						resp.Body.Close()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the chunk was uploaded successfully, but there's still
0000000000000000000000000000000000000000;;			// more to go, upload the next chunk without any delay.
0000000000000000000000000000000000000000;;			if statusResumeIncomplete(resp) {
0000000000000000000000000000000000000000;;				pause = 0
0000000000000000000000000000000000000000;;				backoff.Reset()
0000000000000000000000000000000000000000;;				resp.Body.Close()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// It's possible for err and resp to both be non-nil here, but we expose a simpler
0000000000000000000000000000000000000000;;			// contract to our callers: exactly one of resp and err will be non-nil.  This means
0000000000000000000000000000000000000000;;			// that any response body must be closed here before returning a non-nil error.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if resp != nil && resp.Body != nil {
0000000000000000000000000000000000000000;;					resp.Body.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return resp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
