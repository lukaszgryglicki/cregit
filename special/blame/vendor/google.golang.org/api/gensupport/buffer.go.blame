0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
db73eca7336e67cf99cea454745afc888e9596fd;;	
0000000000000000000000000000000000000000;;	package gensupport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MediaBuffer buffers data from an io.Reader to support uploading media in retryable chunks.
0000000000000000000000000000000000000000;;	type MediaBuffer struct {
0000000000000000000000000000000000000000;;		media io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chunk []byte // The current chunk which is pending upload.  The capacity is the chunk size.
0000000000000000000000000000000000000000;;		err   error  // Any error generated when populating chunk by reading media.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The absolute position of chunk in the underlying media.
0000000000000000000000000000000000000000;;		off int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMediaBuffer(media io.Reader, chunkSize int) *MediaBuffer {
0000000000000000000000000000000000000000;;		return &MediaBuffer{media: media, chunk: make([]byte, 0, chunkSize)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chunk returns the current buffered chunk, the offset in the underlying media
0000000000000000000000000000000000000000;;	// from which the chunk is drawn, and the size of the chunk.
0000000000000000000000000000000000000000;;	// Successive calls to Chunk return the same chunk between calls to Next.
0000000000000000000000000000000000000000;;	func (mb *MediaBuffer) Chunk() (chunk io.Reader, off int64, size int, err error) {
0000000000000000000000000000000000000000;;		// There may already be data in chunk if Next has not been called since the previous call to Chunk.
0000000000000000000000000000000000000000;;		if mb.err == nil && len(mb.chunk) == 0 {
0000000000000000000000000000000000000000;;			mb.err = mb.loadChunk()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes.NewReader(mb.chunk), mb.off, len(mb.chunk), mb.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadChunk will read from media into chunk, up to the capacity of chunk.
0000000000000000000000000000000000000000;;	func (mb *MediaBuffer) loadChunk() error {
0000000000000000000000000000000000000000;;		bufSize := cap(mb.chunk)
0000000000000000000000000000000000000000;;		mb.chunk = mb.chunk[:bufSize]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		read := 0
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for err == nil && read < bufSize {
0000000000000000000000000000000000000000;;			var n int
0000000000000000000000000000000000000000;;			n, err = mb.media.Read(mb.chunk[read:])
0000000000000000000000000000000000000000;;			read += n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mb.chunk = mb.chunk[:read]
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next advances to the next chunk, which will be returned by the next call to Chunk.
0000000000000000000000000000000000000000;;	// Calls to Next without a corresponding prior call to Chunk will have no effect.
0000000000000000000000000000000000000000;;	func (mb *MediaBuffer) Next() {
0000000000000000000000000000000000000000;;		mb.off += int64(len(mb.chunk))
0000000000000000000000000000000000000000;;		mb.chunk = mb.chunk[0:0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type readerTyper struct {
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;		googleapi.ContentTyper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReaderAtToReader adapts a ReaderAt to be used as a Reader.
0000000000000000000000000000000000000000;;	// If ra implements googleapi.ContentTyper, then the returned reader
0000000000000000000000000000000000000000;;	// will also implement googleapi.ContentTyper, delegating to ra.
0000000000000000000000000000000000000000;;	func ReaderAtToReader(ra io.ReaderAt, size int64) io.Reader {
0000000000000000000000000000000000000000;;		r := io.NewSectionReader(ra, 0, size)
0000000000000000000000000000000000000000;;		if typer, ok := ra.(googleapi.ContentTyper); ok {
0000000000000000000000000000000000000000;;			return readerTyper{r, typer}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
