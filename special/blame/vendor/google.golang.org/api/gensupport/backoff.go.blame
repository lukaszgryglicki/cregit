0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
db73eca7336e67cf99cea454745afc888e9596fd;;	
0000000000000000000000000000000000000000;;	package gensupport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BackoffStrategy interface {
0000000000000000000000000000000000000000;;		// Pause returns the duration of the next pause and true if the operation should be
0000000000000000000000000000000000000000;;		// retried, or false if no further retries should be attempted.
0000000000000000000000000000000000000000;;		Pause() (time.Duration, bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset restores the strategy to its initial state.
0000000000000000000000000000000000000000;;		Reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExponentialBackoff performs exponential backoff as per https://en.wikipedia.org/wiki/Exponential_backoff.
0000000000000000000000000000000000000000;;	// The initial pause time is given by Base.
0000000000000000000000000000000000000000;;	// Once the total pause time exceeds Max, Pause will indicate no further retries.
0000000000000000000000000000000000000000;;	type ExponentialBackoff struct {
0000000000000000000000000000000000000000;;		Base  time.Duration
0000000000000000000000000000000000000000;;		Max   time.Duration
0000000000000000000000000000000000000000;;		total time.Duration
0000000000000000000000000000000000000000;;		n     uint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eb *ExponentialBackoff) Pause() (time.Duration, bool) {
0000000000000000000000000000000000000000;;		if eb.total > eb.Max {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The next pause is selected from randomly from [0, 2^n * Base).
0000000000000000000000000000000000000000;;		d := time.Duration(rand.Int63n((1 << eb.n) * int64(eb.Base)))
0000000000000000000000000000000000000000;;		eb.total += d
0000000000000000000000000000000000000000;;		eb.n++
0000000000000000000000000000000000000000;;		return d, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eb *ExponentialBackoff) Reset() {
0000000000000000000000000000000000000000;;		eb.n = 0
0000000000000000000000000000000000000000;;		eb.total = 0
0000000000000000000000000000000000000000;;	}
