0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0c9cd978a5434280274c834bdab152689fd59b88;Godeps/_workspace/src/google.golang.org/api/gensupport/media.go[Godeps/_workspace/src/google.golang.org/api/gensupport/media.go][vendor/google.golang.org/api/gensupport/media.go];	
0000000000000000000000000000000000000000;;	package gensupport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"mime/multipart"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/textproto"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"google.golang.org/api/googleapi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const sniffBuffSize = 512
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newContentSniffer(r io.Reader) *contentSniffer {
0000000000000000000000000000000000000000;;		return &contentSniffer{r: r}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contentSniffer wraps a Reader, and reports the content type determined by sniffing up to 512 bytes from the Reader.
0000000000000000000000000000000000000000;;	type contentSniffer struct {
0000000000000000000000000000000000000000;;		r     io.Reader
0000000000000000000000000000000000000000;;		start []byte // buffer for the sniffed bytes.
0000000000000000000000000000000000000000;;		err   error  // set to any error encountered while reading bytes to be sniffed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctype   string // set on first sniff.
0000000000000000000000000000000000000000;;		sniffed bool   // set to true on first sniff.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *contentSniffer) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		// Ensure that the content type is sniffed before any data is consumed from Reader.
0000000000000000000000000000000000000000;;		_, _ = cs.ContentType()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cs.start) > 0 {
0000000000000000000000000000000000000000;;			n := copy(p, cs.start)
0000000000000000000000000000000000000000;;			cs.start = cs.start[n:]
0000000000000000000000000000000000000000;;			return n, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We may have read some bytes into start while sniffing, even if the read ended in an error.
0000000000000000000000000000000000000000;;		// We should first return those bytes, then the error.
0000000000000000000000000000000000000000;;		if cs.err != nil {
0000000000000000000000000000000000000000;;			return 0, cs.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we have handled all bytes that were buffered while sniffing.  Now just delegate to the underlying reader.
0000000000000000000000000000000000000000;;		return cs.r.Read(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContentType returns the sniffed content type, and whether the content type was succesfully sniffed.
0000000000000000000000000000000000000000;;	func (cs *contentSniffer) ContentType() (string, bool) {
0000000000000000000000000000000000000000;;		if cs.sniffed {
0000000000000000000000000000000000000000;;			return cs.ctype, cs.ctype != ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs.sniffed = true
0000000000000000000000000000000000000000;;		// If ReadAll hits EOF, it returns err==nil.
0000000000000000000000000000000000000000;;		cs.start, cs.err = ioutil.ReadAll(io.LimitReader(cs.r, sniffBuffSize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't try to detect the content type based on possibly incomplete data.
0000000000000000000000000000000000000000;;		if cs.err != nil {
0000000000000000000000000000000000000000;;			return "", false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cs.ctype = http.DetectContentType(cs.start)
0000000000000000000000000000000000000000;;		return cs.ctype, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DetermineContentType determines the content type of the supplied reader.
0000000000000000000000000000000000000000;;	// If the content type is already known, it can be specified via ctype.
0000000000000000000000000000000000000000;;	// Otherwise, the content of media will be sniffed to determine the content type.
0000000000000000000000000000000000000000;;	// If media implements googleapi.ContentTyper (deprecated), this will be used
0000000000000000000000000000000000000000;;	// instead of sniffing the content.
0000000000000000000000000000000000000000;;	// After calling DetectContentType the caller must not perform further reads on
0000000000000000000000000000000000000000;;	// media, but rather read from the Reader that is returned.
0000000000000000000000000000000000000000;;	func DetermineContentType(media io.Reader, ctype string) (io.Reader, string) {
0000000000000000000000000000000000000000;;		// Note: callers could avoid calling DetectContentType if ctype != "",
0000000000000000000000000000000000000000;;		// but doing the check inside this function reduces the amount of
0000000000000000000000000000000000000000;;		// generated code.
0000000000000000000000000000000000000000;;		if ctype != "" {
0000000000000000000000000000000000000000;;			return media, ctype
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For backwards compatability, allow clients to set content
0000000000000000000000000000000000000000;;		// type by providing a ContentTyper for media.
0000000000000000000000000000000000000000;;		if typer, ok := media.(googleapi.ContentTyper); ok {
0000000000000000000000000000000000000000;;			return media, typer.ContentType()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sniffer := newContentSniffer(media)
0000000000000000000000000000000000000000;;		if ctype, ok := sniffer.ContentType(); ok {
0000000000000000000000000000000000000000;;			return sniffer, ctype
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If content type could not be sniffed, reads from sniffer will eventually fail with an error.
0000000000000000000000000000000000000000;;		return sniffer, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type typeReader struct {
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;		typ string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// multipartReader combines the contents of multiple readers to creat a multipart/related HTTP body.
0000000000000000000000000000000000000000;;	// Close must be called if reads from the multipartReader are abandoned before reaching EOF.
0000000000000000000000000000000000000000;;	type multipartReader struct {
0000000000000000000000000000000000000000;;		pr       *io.PipeReader
0000000000000000000000000000000000000000;;		pipeOpen bool
0000000000000000000000000000000000000000;;		ctype    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMultipartReader(parts []typeReader) *multipartReader {
0000000000000000000000000000000000000000;;		mp := &multipartReader{pipeOpen: true}
0000000000000000000000000000000000000000;;		var pw *io.PipeWriter
0000000000000000000000000000000000000000;;		mp.pr, pw = io.Pipe()
0000000000000000000000000000000000000000;;		mpw := multipart.NewWriter(pw)
0000000000000000000000000000000000000000;;		mp.ctype = "multipart/related; boundary=" + mpw.Boundary()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for _, part := range parts {
0000000000000000000000000000000000000000;;				w, err := mpw.CreatePart(typeHeader(part.typ))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					mpw.Close()
0000000000000000000000000000000000000000;;					pw.CloseWithError(fmt.Errorf("googleapi: CreatePart failed: %v", err))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = io.Copy(w, part.Reader)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					mpw.Close()
0000000000000000000000000000000000000000;;					pw.CloseWithError(fmt.Errorf("googleapi: Copy failed: %v", err))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mpw.Close()
0000000000000000000000000000000000000000;;			pw.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return mp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mp *multipartReader) Read(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return mp.pr.Read(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mp *multipartReader) Close() error {
0000000000000000000000000000000000000000;;		if !mp.pipeOpen {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mp.pipeOpen = false
0000000000000000000000000000000000000000;;		return mp.pr.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CombineBodyMedia combines a json body with media content to create a multipart/related HTTP body.
0000000000000000000000000000000000000000;;	// It returns a ReadCloser containing the combined body, and the overall "multipart/related" content type, with random boundary.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The caller must call Close on the returned ReadCloser if reads are abandoned before reaching EOF.
0000000000000000000000000000000000000000;;	func CombineBodyMedia(body io.Reader, bodyContentType string, media io.Reader, mediaContentType string) (io.ReadCloser, string) {
0000000000000000000000000000000000000000;;		mp := newMultipartReader([]typeReader{
0000000000000000000000000000000000000000;;			{body, bodyContentType},
0000000000000000000000000000000000000000;;			{media, mediaContentType},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return mp, mp.ctype
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func typeHeader(contentType string) textproto.MIMEHeader {
0000000000000000000000000000000000000000;;		h := make(textproto.MIMEHeader)
0000000000000000000000000000000000000000;;		if contentType != "" {
0000000000000000000000000000000000000000;;			h.Set("Content-Type", contentType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrepareUpload determines whether the data in the supplied reader should be
0000000000000000000000000000000000000000;;	// uploaded in a single request, or in sequential chunks.
0000000000000000000000000000000000000000;;	// chunkSize is the size of the chunk that media should be split into.
0000000000000000000000000000000000000000;;	// If chunkSize is non-zero and the contents of media do not fit in a single
0000000000000000000000000000000000000000;;	// chunk (or there is an error reading media), then media will be returned as a
0000000000000000000000000000000000000000;;	// MediaBuffer.  Otherwise, media will be returned as a Reader.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// After PrepareUpload has been called, media should no longer be used: the
0000000000000000000000000000000000000000;;	// media content should be accessed via one of the return values.
0000000000000000000000000000000000000000;;	func PrepareUpload(media io.Reader, chunkSize int) (io.Reader, *MediaBuffer) {
0000000000000000000000000000000000000000;;		if chunkSize == 0 { // do not chunk
0000000000000000000000000000000000000000;;			return media, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mb := NewMediaBuffer(media, chunkSize)
0000000000000000000000000000000000000000;;		rdr, _, _, err := mb.Chunk()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == io.EOF { // we can upload this in a single request
0000000000000000000000000000000000000000;;			return rdr, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// err might be a non-EOF error. If it is, the next call to mb.Chunk will
0000000000000000000000000000000000000000;;		// return the same error. Returning a MediaBuffer ensures that this error
0000000000000000000000000000000000000000;;		// will be handled at some point.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, mb
0000000000000000000000000000000000000000;;	}
