0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
edbcd7131459086bebd8b977925afcb7a234f8d4;;	
0000000000000000000000000000000000000000;;	package gensupport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context/ctxhttp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hook is the type of a function that is called once before each HTTP request
0000000000000000000000000000000000000000;;	// that is sent by a generated API.  It returns a function that is called after
0000000000000000000000000000000000000000;;	// the request returns.
0000000000000000000000000000000000000000;;	// Hooks are not called if the context is nil.
0000000000000000000000000000000000000000;;	type Hook func(ctx context.Context, req *http.Request) func(resp *http.Response)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var hooks []Hook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterHook registers a Hook to be called before each HTTP request by a
0000000000000000000000000000000000000000;;	// generated API.  Hooks are called in the order they are registered.  Each
0000000000000000000000000000000000000000;;	// hook can return a function; if it is non-nil, it is called after the HTTP
0000000000000000000000000000000000000000;;	// request returns.  These functions are called in the reverse order.
0000000000000000000000000000000000000000;;	// RegisterHook should not be called concurrently with itself or SendRequest.
0000000000000000000000000000000000000000;;	func RegisterHook(h Hook) {
0000000000000000000000000000000000000000;;		hooks = append(hooks, h)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendRequest sends a single HTTP request using the given client.
0000000000000000000000000000000000000000;;	// If ctx is non-nil, it calls all hooks, then sends the request with
0000000000000000000000000000000000000000;;	// ctxhttp.Do, then calls any functions returned by the hooks in reverse order.
0000000000000000000000000000000000000000;;	func SendRequest(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			return client.Do(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Call hooks in order of registration, store returned funcs.
0000000000000000000000000000000000000000;;		post := make([]func(resp *http.Response), len(hooks))
0000000000000000000000000000000000000000;;		for i, h := range hooks {
0000000000000000000000000000000000000000;;			fn := h(ctx, req)
0000000000000000000000000000000000000000;;			post[i] = fn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send request.
0000000000000000000000000000000000000000;;		resp, err := ctxhttp.Do(ctx, client, req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call returned funcs in reverse order.
0000000000000000000000000000000000000000;;		for i := len(post) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if fn := post[i]; fn != nil {
0000000000000000000000000000000000000000;;				fn(resp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
