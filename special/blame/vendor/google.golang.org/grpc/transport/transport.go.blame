0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/transport/transport.go[Godeps/_workspace/src/google.golang.org/grpc/transport/transport.go][vendor/google.golang.org/grpc/transport/transport.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package transport defines and implements message oriented communication channel
0000000000000000000000000000000000000000;;	to complete various transactions (e.g., an RPC).
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/trace"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recvMsg represents the received msg from the transport. All transport
0000000000000000000000000000000000000000;;	// protocol specific info has been removed.
0000000000000000000000000000000000000000;;	type recvMsg struct {
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;		// nil: received some data
0000000000000000000000000000000000000000;;		// io.EOF: stream is completed. data is nil.
0000000000000000000000000000000000000000;;		// other non-nil error: transport failure. data is nil.
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*recvMsg) item() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All items in an out of a recvBuffer should be the same type.
0000000000000000000000000000000000000000;;	type item interface {
0000000000000000000000000000000000000000;;		item()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recvBuffer is an unbounded channel of item.
0000000000000000000000000000000000000000;;	type recvBuffer struct {
0000000000000000000000000000000000000000;;		c       chan item
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		backlog []item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRecvBuffer() *recvBuffer {
0000000000000000000000000000000000000000;;		b := &recvBuffer{
0000000000000000000000000000000000000000;;			c: make(chan item, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *recvBuffer) put(r item) {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		if len(b.backlog) == 0 {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case b.c <- r:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.backlog = append(b.backlog, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *recvBuffer) load() {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		if len(b.backlog) > 0 {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case b.c <- b.backlog[0]:
0000000000000000000000000000000000000000;;				b.backlog = b.backlog[1:]
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get returns the channel that receives an item in the buffer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Upon receipt of an item, the caller should call load to send another
0000000000000000000000000000000000000000;;	// item onto the channel if there is any.
0000000000000000000000000000000000000000;;	func (b *recvBuffer) get() <-chan item {
0000000000000000000000000000000000000000;;		return b.c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recvBufferReader implements io.Reader interface to read the data from
0000000000000000000000000000000000000000;;	// recvBuffer.
0000000000000000000000000000000000000000;;	type recvBufferReader struct {
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		goAway chan struct{}
0000000000000000000000000000000000000000;;		recv   *recvBuffer
0000000000000000000000000000000000000000;;		last   *bytes.Reader // Stores the remaining data in the previous calls.
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads the next len(p) bytes from last. If last is drained, it tries to
0000000000000000000000000000000000000000;;	// read additional data from recv. It blocks if there no additional data available
0000000000000000000000000000000000000000;;	// in recv. If Read returns any non-nil error, it will continue to return that error.
0000000000000000000000000000000000000000;;	func (r *recvBufferReader) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return 0, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() { r.err = err }()
0000000000000000000000000000000000000000;;		if r.last != nil && r.last.Len() > 0 {
0000000000000000000000000000000000000000;;			// Read remaining data left in last call.
0000000000000000000000000000000000000000;;			return r.last.Read(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-r.ctx.Done():
0000000000000000000000000000000000000000;;			return 0, ContextErr(r.ctx.Err())
0000000000000000000000000000000000000000;;		case <-r.goAway:
0000000000000000000000000000000000000000;;			return 0, ErrStreamDrain
0000000000000000000000000000000000000000;;		case i := <-r.recv.get():
0000000000000000000000000000000000000000;;			r.recv.load()
0000000000000000000000000000000000000000;;			m := i.(*recvMsg)
0000000000000000000000000000000000000000;;			if m.err != nil {
0000000000000000000000000000000000000000;;				return 0, m.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.last = bytes.NewReader(m.data)
0000000000000000000000000000000000000000;;			return r.last.Read(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type streamState uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		streamActive    streamState = iota
0000000000000000000000000000000000000000;;		streamWriteDone             // EndStream sent
0000000000000000000000000000000000000000;;		streamReadDone              // EndStream received
0000000000000000000000000000000000000000;;		streamDone                  // the entire stream is finished.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stream represents an RPC in the transport layer.
0000000000000000000000000000000000000000;;	type Stream struct {
0000000000000000000000000000000000000000;;		id uint32
0000000000000000000000000000000000000000;;		// nil for client side Stream.
0000000000000000000000000000000000000000;;		st ServerTransport
0000000000000000000000000000000000000000;;		// ctx is the associated context of the stream.
0000000000000000000000000000000000000000;;		ctx context.Context
0000000000000000000000000000000000000000;;		// cancel is always nil for client side Stream.
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;		// done is closed when the final status arrives.
0000000000000000000000000000000000000000;;		done chan struct{}
0000000000000000000000000000000000000000;;		// goAway is closed when the server sent GoAways signal before this stream was initiated.
0000000000000000000000000000000000000000;;		goAway chan struct{}
0000000000000000000000000000000000000000;;		// method records the associated RPC method of the stream.
0000000000000000000000000000000000000000;;		method       string
0000000000000000000000000000000000000000;;		recvCompress string
0000000000000000000000000000000000000000;;		sendCompress string
0000000000000000000000000000000000000000;;		buf          *recvBuffer
0000000000000000000000000000000000000000;;		dec          io.Reader
0000000000000000000000000000000000000000;;		fc           *inFlow
0000000000000000000000000000000000000000;;		recvQuota    uint32
0000000000000000000000000000000000000000;;		// The accumulated inbound quota pending for window update.
0000000000000000000000000000000000000000;;		updateQuota uint32
0000000000000000000000000000000000000000;;		// The handler to control the window update procedure for both this
0000000000000000000000000000000000000000;;		// particular stream and the associated transport.
0000000000000000000000000000000000000000;;		windowHandler func(int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sendQuotaPool *quotaPool
0000000000000000000000000000000000000000;;		// Close headerChan to indicate the end of reception of header metadata.
0000000000000000000000000000000000000000;;		headerChan chan struct{}
0000000000000000000000000000000000000000;;		// header caches the received header metadata.
0000000000000000000000000000000000000000;;		header metadata.MD
0000000000000000000000000000000000000000;;		// The key-value map of trailer metadata.
0000000000000000000000000000000000000000;;		trailer metadata.MD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.RWMutex // guard the following
0000000000000000000000000000000000000000;;		// headerOK becomes true from the first header is about to send.
0000000000000000000000000000000000000000;;		headerOk bool
0000000000000000000000000000000000000000;;		state    streamState
0000000000000000000000000000000000000000;;		// true iff headerChan is closed. Used to avoid closing headerChan
0000000000000000000000000000000000000000;;		// multiple times.
0000000000000000000000000000000000000000;;		headerDone bool
0000000000000000000000000000000000000000;;		// the status received from the server.
0000000000000000000000000000000000000000;;		statusCode codes.Code
0000000000000000000000000000000000000000;;		statusDesc string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecvCompress returns the compression algorithm applied to the inbound
0000000000000000000000000000000000000000;;	// message. It is empty string if there is no compression applied.
0000000000000000000000000000000000000000;;	func (s *Stream) RecvCompress() string {
0000000000000000000000000000000000000000;;		return s.recvCompress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetSendCompress sets the compression algorithm to the stream.
0000000000000000000000000000000000000000;;	func (s *Stream) SetSendCompress(str string) {
0000000000000000000000000000000000000000;;		s.sendCompress = str
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Done returns a chanel which is closed when it receives the final status
0000000000000000000000000000000000000000;;	// from the server.
0000000000000000000000000000000000000000;;	func (s *Stream) Done() <-chan struct{} {
0000000000000000000000000000000000000000;;		return s.done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoAway returns a channel which is closed when the server sent GoAways signal
0000000000000000000000000000000000000000;;	// before this stream was initiated.
0000000000000000000000000000000000000000;;	func (s *Stream) GoAway() <-chan struct{} {
0000000000000000000000000000000000000000;;		return s.goAway
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header acquires the key-value pairs of header metadata once it
0000000000000000000000000000000000000000;;	// is available. It blocks until i) the metadata is ready or ii) there is no
0000000000000000000000000000000000000000;;	// header metadata or iii) the stream is cancelled/expired.
0000000000000000000000000000000000000000;;	func (s *Stream) Header() (metadata.MD, error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.ctx.Done():
0000000000000000000000000000000000000000;;			return nil, ContextErr(s.ctx.Err())
0000000000000000000000000000000000000000;;		case <-s.goAway:
0000000000000000000000000000000000000000;;			return nil, ErrStreamDrain
0000000000000000000000000000000000000000;;		case <-s.headerChan:
0000000000000000000000000000000000000000;;			return s.header.Copy(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Trailer returns the cached trailer metedata. Note that if it is not called
0000000000000000000000000000000000000000;;	// after the entire stream is done, it could return an empty MD. Client
0000000000000000000000000000000000000000;;	// side only.
0000000000000000000000000000000000000000;;	func (s *Stream) Trailer() metadata.MD {
0000000000000000000000000000000000000000;;		s.mu.RLock()
0000000000000000000000000000000000000000;;		defer s.mu.RUnlock()
0000000000000000000000000000000000000000;;		return s.trailer.Copy()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerTransport returns the underlying ServerTransport for the stream.
0000000000000000000000000000000000000000;;	// The client side stream always returns nil.
0000000000000000000000000000000000000000;;	func (s *Stream) ServerTransport() ServerTransport {
0000000000000000000000000000000000000000;;		return s.st
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Context returns the context of the stream.
0000000000000000000000000000000000000000;;	func (s *Stream) Context() context.Context {
0000000000000000000000000000000000000000;;		return s.ctx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TraceContext recreates the context of s with a trace.Trace.
0000000000000000000000000000000000000000;;	func (s *Stream) TraceContext(tr trace.Trace) {
0000000000000000000000000000000000000000;;		s.ctx = trace.NewContext(s.ctx, tr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Method returns the method for the stream.
0000000000000000000000000000000000000000;;	func (s *Stream) Method() string {
0000000000000000000000000000000000000000;;		return s.method
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusCode returns statusCode received from the server.
0000000000000000000000000000000000000000;;	func (s *Stream) StatusCode() codes.Code {
0000000000000000000000000000000000000000;;		return s.statusCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusDesc returns statusDesc received from the server.
0000000000000000000000000000000000000000;;	func (s *Stream) StatusDesc() string {
0000000000000000000000000000000000000000;;		return s.statusDesc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetHeader sets the header metadata. This can be called multiple times.
0000000000000000000000000000000000000000;;	// Server side only.
0000000000000000000000000000000000000000;;	func (s *Stream) SetHeader(md metadata.MD) error {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if s.headerOk || s.state == streamDone {
0000000000000000000000000000000000000000;;			return ErrIllegalHeaderWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if md.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.header = metadata.Join(s.header, md)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTrailer sets the trailer metadata which will be sent with the RPC status
0000000000000000000000000000000000000000;;	// by the server. This can be called multiple times. Server side only.
0000000000000000000000000000000000000000;;	func (s *Stream) SetTrailer(md metadata.MD) error {
0000000000000000000000000000000000000000;;		if md.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		s.trailer = metadata.Join(s.trailer, md)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) write(m recvMsg) {
0000000000000000000000000000000000000000;;		s.buf.put(&m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads all the data available for this Stream from the transport and
0000000000000000000000000000000000000000;;	// passes them into the decoder, which converts them into a gRPC message stream.
0000000000000000000000000000000000000000;;	// The error is io.EOF when the stream is done or another non-nil error if
0000000000000000000000000000000000000000;;	// the stream broke.
0000000000000000000000000000000000000000;;	func (s *Stream) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, err = s.dec.Read(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.windowHandler(n)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The key to save transport.Stream in the context.
0000000000000000000000000000000000000000;;	type streamKey struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newContextWithStream creates a new context from ctx and attaches stream
0000000000000000000000000000000000000000;;	// to it.
0000000000000000000000000000000000000000;;	func newContextWithStream(ctx context.Context, stream *Stream) context.Context {
0000000000000000000000000000000000000000;;		return context.WithValue(ctx, streamKey{}, stream)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamFromContext returns the stream saved in ctx.
0000000000000000000000000000000000000000;;	func StreamFromContext(ctx context.Context) (s *Stream, ok bool) {
0000000000000000000000000000000000000000;;		s, ok = ctx.Value(streamKey{}).(*Stream)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// state of transport
0000000000000000000000000000000000000000;;	type transportState int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		reachable transportState = iota
0000000000000000000000000000000000000000;;		unreachable
0000000000000000000000000000000000000000;;		closing
0000000000000000000000000000000000000000;;		draining
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerTransport creates a ServerTransport with conn or non-nil error
0000000000000000000000000000000000000000;;	// if it fails.
0000000000000000000000000000000000000000;;	func NewServerTransport(protocol string, conn net.Conn, maxStreams uint32, authInfo credentials.AuthInfo) (ServerTransport, error) {
0000000000000000000000000000000000000000;;		return newHTTP2Server(conn, maxStreams, authInfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectOptions covers all relevant options for communicating with the server.
0000000000000000000000000000000000000000;;	type ConnectOptions struct {
0000000000000000000000000000000000000000;;		// UserAgent is the application user agent.
0000000000000000000000000000000000000000;;		UserAgent string
0000000000000000000000000000000000000000;;		// Dialer specifies how to dial a network address.
0000000000000000000000000000000000000000;;		Dialer func(context.Context, string) (net.Conn, error)
0000000000000000000000000000000000000000;;		// PerRPCCredentials stores the PerRPCCredentials required to issue RPCs.
0000000000000000000000000000000000000000;;		PerRPCCredentials []credentials.PerRPCCredentials
0000000000000000000000000000000000000000;;		// TransportCredentials stores the Authenticator required to setup a client connection.
0000000000000000000000000000000000000000;;		TransportCredentials credentials.TransportCredentials
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TargetInfo contains the information of the target such as network address and metadata.
0000000000000000000000000000000000000000;;	type TargetInfo struct {
0000000000000000000000000000000000000000;;		Addr     string
0000000000000000000000000000000000000000;;		Metadata interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientTransport establishes the transport with the required ConnectOptions
0000000000000000000000000000000000000000;;	// and returns it to the caller.
0000000000000000000000000000000000000000;;	func NewClientTransport(ctx context.Context, target TargetInfo, opts ConnectOptions) (ClientTransport, error) {
0000000000000000000000000000000000000000;;		return newHTTP2Client(ctx, target, opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options provides additional hints and information for message
0000000000000000000000000000000000000000;;	// transmission.
0000000000000000000000000000000000000000;;	type Options struct {
0000000000000000000000000000000000000000;;		// Last indicates whether this write is the last piece for
0000000000000000000000000000000000000000;;		// this stream.
0000000000000000000000000000000000000000;;		Last bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delay is a hint to the transport implementation for whether
0000000000000000000000000000000000000000;;		// the data could be buffered for a batching write. The
0000000000000000000000000000000000000000;;		// Transport implementation may ignore the hint.
0000000000000000000000000000000000000000;;		Delay bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CallHdr carries the information of a particular RPC.
0000000000000000000000000000000000000000;;	type CallHdr struct {
0000000000000000000000000000000000000000;;		// Host specifies the peer's host.
0000000000000000000000000000000000000000;;		Host string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Method specifies the operation to perform.
0000000000000000000000000000000000000000;;		Method string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RecvCompress specifies the compression algorithm applied on
0000000000000000000000000000000000000000;;		// inbound messages.
0000000000000000000000000000000000000000;;		RecvCompress string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SendCompress specifies the compression algorithm applied on
0000000000000000000000000000000000000000;;		// outbound message.
0000000000000000000000000000000000000000;;		SendCompress string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flush indicates whether a new stream command should be sent
0000000000000000000000000000000000000000;;		// to the peer without waiting for the first data. This is
0000000000000000000000000000000000000000;;		// only a hint. The transport may modify the flush decision
0000000000000000000000000000000000000000;;		// for performance purposes.
0000000000000000000000000000000000000000;;		Flush bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientTransport is the common interface for all gRPC client-side transport
0000000000000000000000000000000000000000;;	// implementations.
0000000000000000000000000000000000000000;;	type ClientTransport interface {
0000000000000000000000000000000000000000;;		// Close tears down this transport. Once it returns, the transport
0000000000000000000000000000000000000000;;		// should not be accessed any more. The caller must make sure this
0000000000000000000000000000000000000000;;		// is called only once.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GracefulClose starts to tear down the transport. It stops accepting
0000000000000000000000000000000000000000;;		// new RPCs and wait the completion of the pending RPCs.
0000000000000000000000000000000000000000;;		GracefulClose() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write sends the data for the given stream. A nil stream indicates
0000000000000000000000000000000000000000;;		// the write is to be performed on the transport as a whole.
0000000000000000000000000000000000000000;;		Write(s *Stream, data []byte, opts *Options) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewStream creates a Stream for an RPC.
0000000000000000000000000000000000000000;;		NewStream(ctx context.Context, callHdr *CallHdr) (*Stream, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CloseStream clears the footprint of a stream when the stream is
0000000000000000000000000000000000000000;;		// not needed any more. The err indicates the error incurred when
0000000000000000000000000000000000000000;;		// CloseStream is called. Must be called when a stream is finished
0000000000000000000000000000000000000000;;		// unless the associated transport is closing.
0000000000000000000000000000000000000000;;		CloseStream(stream *Stream, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error returns a channel that is closed when some I/O error
0000000000000000000000000000000000000000;;		// happens. Typically the caller should have a goroutine to monitor
0000000000000000000000000000000000000000;;		// this in order to take action (e.g., close the current transport
0000000000000000000000000000000000000000;;		// and create a new one) in error case. It should not return nil
0000000000000000000000000000000000000000;;		// once the transport is initiated.
0000000000000000000000000000000000000000;;		Error() <-chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GoAway returns a channel that is closed when ClientTranspor
0000000000000000000000000000000000000000;;		// receives the draining signal from the server (e.g., GOAWAY frame in
0000000000000000000000000000000000000000;;		// HTTP/2).
0000000000000000000000000000000000000000;;		GoAway() <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerTransport is the common interface for all gRPC server-side transport
0000000000000000000000000000000000000000;;	// implementations.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Methods may be called concurrently from multiple goroutines, but
0000000000000000000000000000000000000000;;	// Write methods for a given Stream will be called serially.
0000000000000000000000000000000000000000;;	type ServerTransport interface {
0000000000000000000000000000000000000000;;		// HandleStreams receives incoming streams using the given handler.
0000000000000000000000000000000000000000;;		HandleStreams(func(*Stream))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WriteHeader sends the header metadata for the given stream.
0000000000000000000000000000000000000000;;		// WriteHeader may not be called on all streams.
0000000000000000000000000000000000000000;;		WriteHeader(s *Stream, md metadata.MD) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write sends the data for the given stream.
0000000000000000000000000000000000000000;;		// Write may not be called on all streams.
0000000000000000000000000000000000000000;;		Write(s *Stream, data []byte, opts *Options) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WriteStatus sends the status of a stream to the client.
0000000000000000000000000000000000000000;;		// WriteStatus is the final call made on a stream and always
0000000000000000000000000000000000000000;;		// occurs.
0000000000000000000000000000000000000000;;		WriteStatus(s *Stream, statusCode codes.Code, statusDesc string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close tears down the transport. Once it is called, the transport
0000000000000000000000000000000000000000;;		// should not be accessed any more. All the pending streams and their
0000000000000000000000000000000000000000;;		// handlers will be terminated asynchronously.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RemoteAddr returns the remote network address.
0000000000000000000000000000000000000000;;		RemoteAddr() net.Addr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Drain notifies the client this ServerTransport stops accepting new RPCs.
0000000000000000000000000000000000000000;;		Drain()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamErrorf creates an StreamError with the specified error code and description.
0000000000000000000000000000000000000000;;	func streamErrorf(c codes.Code, format string, a ...interface{}) StreamError {
0000000000000000000000000000000000000000;;		return StreamError{
0000000000000000000000000000000000000000;;			Code: c,
0000000000000000000000000000000000000000;;			Desc: fmt.Sprintf(format, a...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// connectionErrorf creates an ConnectionError with the specified error description.
0000000000000000000000000000000000000000;;	func connectionErrorf(temp bool, e error, format string, a ...interface{}) ConnectionError {
0000000000000000000000000000000000000000;;		return ConnectionError{
0000000000000000000000000000000000000000;;			Desc: fmt.Sprintf(format, a...),
0000000000000000000000000000000000000000;;			temp: temp,
0000000000000000000000000000000000000000;;			err:  e,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectionError is an error that results in the termination of the
0000000000000000000000000000000000000000;;	// entire connection and the retry of all the active streams.
0000000000000000000000000000000000000000;;	type ConnectionError struct {
0000000000000000000000000000000000000000;;		Desc string
0000000000000000000000000000000000000000;;		temp bool
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e ConnectionError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("connection error: desc = %q", e.Desc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Temporary indicates if this connection error is temporary or fatal.
0000000000000000000000000000000000000000;;	func (e ConnectionError) Temporary() bool {
0000000000000000000000000000000000000000;;		return e.temp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Origin returns the original error of this connection error.
0000000000000000000000000000000000000000;;	func (e ConnectionError) Origin() error {
0000000000000000000000000000000000000000;;		// Never return nil error here.
0000000000000000000000000000000000000000;;		// If the original error is nil, return itself.
0000000000000000000000000000000000000000;;		if e.err == nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrConnClosing indicates that the transport is closing.
0000000000000000000000000000000000000000;;		ErrConnClosing = connectionErrorf(true, nil, "transport is closing")
0000000000000000000000000000000000000000;;		// ErrStreamDrain indicates that the stream is rejected by the server because
0000000000000000000000000000000000000000;;		// the server stops accepting new RPCs.
0000000000000000000000000000000000000000;;		ErrStreamDrain = streamErrorf(codes.Unavailable, "the server stops accepting new RPCs")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamError is an error that only affects one stream within a connection.
0000000000000000000000000000000000000000;;	type StreamError struct {
0000000000000000000000000000000000000000;;		Code codes.Code
0000000000000000000000000000000000000000;;		Desc string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e StreamError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("stream error: code = %d desc = %q", e.Code, e.Desc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContextErr converts the error from context package into a StreamError.
0000000000000000000000000000000000000000;;	func ContextErr(err error) StreamError {
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case context.DeadlineExceeded:
0000000000000000000000000000000000000000;;			return streamErrorf(codes.DeadlineExceeded, "%v", err)
0000000000000000000000000000000000000000;;		case context.Canceled:
0000000000000000000000000000000000000000;;			return streamErrorf(codes.Canceled, "%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("Unexpected error from context packet: %v", err))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait blocks until it can receive from ctx.Done, closing, or proceed.
0000000000000000000000000000000000000000;;	// If it receives from ctx.Done, it returns 0, the StreamError for ctx.Err.
0000000000000000000000000000000000000000;;	// If it receives from done, it returns 0, io.EOF if ctx is not done; otherwise
0000000000000000000000000000000000000000;;	// it return the StreamError for ctx.Err.
0000000000000000000000000000000000000000;;	// If it receives from goAway, it returns 0, ErrStreamDrain.
0000000000000000000000000000000000000000;;	// If it receives from closing, it returns 0, ErrConnClosing.
0000000000000000000000000000000000000000;;	// If it receives from proceed, it returns the received integer, nil.
0000000000000000000000000000000000000000;;	func wait(ctx context.Context, done, goAway, closing <-chan struct{}, proceed <-chan int) (int, error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return 0, ContextErr(ctx.Err())
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;			// User cancellation has precedence.
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return 0, ContextErr(ctx.Err())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		case <-goAway:
0000000000000000000000000000000000000000;;			return 0, ErrStreamDrain
0000000000000000000000000000000000000000;;		case <-closing:
0000000000000000000000000000000000000000;;			return 0, ErrConnClosing
0000000000000000000000000000000000000000;;		case i := <-proceed:
0000000000000000000000000000000000000000;;			return i, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
