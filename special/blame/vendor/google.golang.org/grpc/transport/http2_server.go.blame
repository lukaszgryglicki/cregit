0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/transport/http2_server.go[Godeps/_workspace/src/google.golang.org/grpc/transport/http2_server.go][vendor/google.golang.org/grpc/transport/http2_server.go];	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2/hpack"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/peer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrIllegalHeaderWrite indicates that setting header is illegal because of
0000000000000000000000000000000000000000;;	// the stream's state.
0000000000000000000000000000000000000000;;	var ErrIllegalHeaderWrite = errors.New("transport: the stream is done or WriteHeader was already called")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// http2Server implements the ServerTransport interface with HTTP2.
0000000000000000000000000000000000000000;;	type http2Server struct {
0000000000000000000000000000000000000000;;		conn        net.Conn
0000000000000000000000000000000000000000;;		maxStreamID uint32               // max stream ID ever seen
0000000000000000000000000000000000000000;;		authInfo    credentials.AuthInfo // auth info about the connection
0000000000000000000000000000000000000000;;		// writableChan synchronizes write access to the transport.
0000000000000000000000000000000000000000;;		// A writer acquires the write lock by receiving a value on writableChan
0000000000000000000000000000000000000000;;		// and releases it by sending on writableChan.
0000000000000000000000000000000000000000;;		writableChan chan int
0000000000000000000000000000000000000000;;		// shutdownChan is closed when Close is called.
0000000000000000000000000000000000000000;;		// Blocking operations should select on shutdownChan to avoid
0000000000000000000000000000000000000000;;		// blocking forever after Close.
0000000000000000000000000000000000000000;;		shutdownChan chan struct{}
0000000000000000000000000000000000000000;;		framer       *framer
0000000000000000000000000000000000000000;;		hBuf         *bytes.Buffer  // the buffer for HPACK encoding
0000000000000000000000000000000000000000;;		hEnc         *hpack.Encoder // HPACK encoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The max number of concurrent streams.
0000000000000000000000000000000000000000;;		maxStreams uint32
0000000000000000000000000000000000000000;;		// controlBuf delivers all the control related tasks (e.g., window
0000000000000000000000000000000000000000;;		// updates, reset streams, and various settings) to the controller.
0000000000000000000000000000000000000000;;		controlBuf *recvBuffer
0000000000000000000000000000000000000000;;		fc         *inFlow
0000000000000000000000000000000000000000;;		// sendQuotaPool provides flow control to outbound message.
0000000000000000000000000000000000000000;;		sendQuotaPool *quotaPool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu            sync.Mutex // guard the following
0000000000000000000000000000000000000000;;		state         transportState
0000000000000000000000000000000000000000;;		activeStreams map[uint32]*Stream
0000000000000000000000000000000000000000;;		// the per-stream outbound flow control window size set by the peer.
0000000000000000000000000000000000000000;;		streamSendQuota uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newHTTP2Server constructs a ServerTransport based on HTTP2. ConnectionError is
0000000000000000000000000000000000000000;;	// returned if something goes wrong.
0000000000000000000000000000000000000000;;	func newHTTP2Server(conn net.Conn, maxStreams uint32, authInfo credentials.AuthInfo) (_ ServerTransport, err error) {
0000000000000000000000000000000000000000;;		framer := newFramer(conn)
0000000000000000000000000000000000000000;;		// Send initial settings as connection preface to client.
0000000000000000000000000000000000000000;;		var settings []http2.Setting
0000000000000000000000000000000000000000;;		// TODO(zhaoq): Have a better way to signal "no limit" because 0 is
0000000000000000000000000000000000000000;;		// permitted in the HTTP2 spec.
0000000000000000000000000000000000000000;;		if maxStreams == 0 {
0000000000000000000000000000000000000000;;			maxStreams = math.MaxUint32
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			settings = append(settings, http2.Setting{
0000000000000000000000000000000000000000;;				ID:  http2.SettingMaxConcurrentStreams,
0000000000000000000000000000000000000000;;				Val: maxStreams,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if initialWindowSize != defaultWindowSize {
0000000000000000000000000000000000000000;;			settings = append(settings, http2.Setting{
0000000000000000000000000000000000000000;;				ID:  http2.SettingInitialWindowSize,
0000000000000000000000000000000000000000;;				Val: uint32(initialWindowSize)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := framer.writeSettings(true, settings...); err != nil {
0000000000000000000000000000000000000000;;			return nil, connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Adjust the connection flow control window if needed.
0000000000000000000000000000000000000000;;		if delta := uint32(initialConnWindowSize - defaultWindowSize); delta > 0 {
0000000000000000000000000000000000000000;;			if err := framer.writeWindowUpdate(true, 0, delta); err != nil {
0000000000000000000000000000000000000000;;				return nil, connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		t := &http2Server{
0000000000000000000000000000000000000000;;			conn:            conn,
0000000000000000000000000000000000000000;;			authInfo:        authInfo,
0000000000000000000000000000000000000000;;			framer:          framer,
0000000000000000000000000000000000000000;;			hBuf:            &buf,
0000000000000000000000000000000000000000;;			hEnc:            hpack.NewEncoder(&buf),
0000000000000000000000000000000000000000;;			maxStreams:      maxStreams,
0000000000000000000000000000000000000000;;			controlBuf:      newRecvBuffer(),
0000000000000000000000000000000000000000;;			fc:              &inFlow{limit: initialConnWindowSize},
0000000000000000000000000000000000000000;;			sendQuotaPool:   newQuotaPool(defaultWindowSize),
0000000000000000000000000000000000000000;;			state:           reachable,
0000000000000000000000000000000000000000;;			writableChan:    make(chan int, 1),
0000000000000000000000000000000000000000;;			shutdownChan:    make(chan struct{}),
0000000000000000000000000000000000000000;;			activeStreams:   make(map[uint32]*Stream),
0000000000000000000000000000000000000000;;			streamSendQuota: defaultWindowSize,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go t.controller()
0000000000000000000000000000000000000000;;		t.writableChan <- 0
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operateHeader takes action on the decoded headers.
0000000000000000000000000000000000000000;;	func (t *http2Server) operateHeaders(frame *http2.MetaHeadersFrame, handle func(*Stream)) (close bool) {
0000000000000000000000000000000000000000;;		buf := newRecvBuffer()
0000000000000000000000000000000000000000;;		s := &Stream{
0000000000000000000000000000000000000000;;			id:  frame.Header().StreamID,
0000000000000000000000000000000000000000;;			st:  t,
0000000000000000000000000000000000000000;;			buf: buf,
0000000000000000000000000000000000000000;;			fc:  &inFlow{limit: initialWindowSize},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var state decodeState
0000000000000000000000000000000000000000;;		for _, hf := range frame.Fields {
0000000000000000000000000000000000000000;;			state.processHeaderField(hf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := state.err; err != nil {
0000000000000000000000000000000000000000;;			if se, ok := err.(StreamError); ok {
0000000000000000000000000000000000000000;;				t.controlBuf.put(&resetStream{s.id, statusCodeConvTab[se.Code]})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if frame.StreamEnded() {
0000000000000000000000000000000000000000;;			// s is just created by the caller. No lock needed.
0000000000000000000000000000000000000000;;			s.state = streamReadDone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.recvCompress = state.encoding
0000000000000000000000000000000000000000;;		if state.timeoutSet {
0000000000000000000000000000000000000000;;			s.ctx, s.cancel = context.WithTimeout(context.TODO(), state.timeout)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.ctx, s.cancel = context.WithCancel(context.TODO())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pr := &peer.Peer{
0000000000000000000000000000000000000000;;			Addr: t.conn.RemoteAddr(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Attach Auth info if there is any.
0000000000000000000000000000000000000000;;		if t.authInfo != nil {
0000000000000000000000000000000000000000;;			pr.AuthInfo = t.authInfo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.ctx = peer.NewContext(s.ctx, pr)
0000000000000000000000000000000000000000;;		// Cache the current stream to the context so that the server application
0000000000000000000000000000000000000000;;		// can find out. Required when the server wants to send some metadata
0000000000000000000000000000000000000000;;		// back to the client (unary call only).
0000000000000000000000000000000000000000;;		s.ctx = newContextWithStream(s.ctx, s)
0000000000000000000000000000000000000000;;		// Attach the received metadata to the context.
0000000000000000000000000000000000000000;;		if len(state.mdata) > 0 {
0000000000000000000000000000000000000000;;			s.ctx = metadata.NewContext(s.ctx, state.mdata)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.dec = &recvBufferReader{
0000000000000000000000000000000000000000;;			ctx:  s.ctx,
0000000000000000000000000000000000000000;;			recv: s.buf,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.recvCompress = state.encoding
0000000000000000000000000000000000000000;;		s.method = state.method
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		if t.state != reachable {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if uint32(len(t.activeStreams)) >= t.maxStreams {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			t.controlBuf.put(&resetStream{s.id, http2.ErrCodeRefusedStream})
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.id%2 != 1 || s.id <= t.maxStreamID {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			// illegal gRPC stream id.
0000000000000000000000000000000000000000;;			grpclog.Println("transport: http2Server.HandleStreams received an illegal stream id: ", s.id)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.maxStreamID = s.id
0000000000000000000000000000000000000000;;		s.sendQuotaPool = newQuotaPool(int(t.streamSendQuota))
0000000000000000000000000000000000000000;;		t.activeStreams[s.id] = s
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		s.windowHandler = func(n int) {
0000000000000000000000000000000000000000;;			t.updateWindow(s, uint32(n))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handle(s)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleStreams receives incoming streams using the given handler. This is
0000000000000000000000000000000000000000;;	// typically run in a separate goroutine.
0000000000000000000000000000000000000000;;	func (t *http2Server) HandleStreams(handle func(*Stream)) {
0000000000000000000000000000000000000000;;		// Check the validity of client preface.
0000000000000000000000000000000000000000;;		preface := make([]byte, len(clientPreface))
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(t.conn, preface); err != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("transport: http2Server.HandleStreams failed to receive the preface from client: %v", err)
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !bytes.Equal(preface, clientPreface) {
0000000000000000000000000000000000000000;;			grpclog.Printf("transport: http2Server.HandleStreams received bogus greeting from client: %q", preface)
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frame, err := t.framer.readFrame()
0000000000000000000000000000000000000000;;		if err == io.EOF || err == io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("transport: http2Server.HandleStreams failed to read frame: %v", err)
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sf, ok := frame.(*http2.SettingsFrame)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			grpclog.Printf("transport: http2Server.HandleStreams saw invalid preface type %T from client", frame)
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.handleSettings(sf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			frame, err := t.framer.readFrame()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if se, ok := err.(http2.StreamError); ok {
0000000000000000000000000000000000000000;;					t.mu.Lock()
0000000000000000000000000000000000000000;;					s := t.activeStreams[se.StreamID]
0000000000000000000000000000000000000000;;					t.mu.Unlock()
0000000000000000000000000000000000000000;;					if s != nil {
0000000000000000000000000000000000000000;;						t.closeStream(s)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t.controlBuf.put(&resetStream{se.StreamID, se.Code})
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == io.EOF || err == io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;					t.Close()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				grpclog.Printf("transport: http2Server.HandleStreams failed to read frame: %v", err)
0000000000000000000000000000000000000000;;				t.Close()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch frame := frame.(type) {
0000000000000000000000000000000000000000;;			case *http2.MetaHeadersFrame:
0000000000000000000000000000000000000000;;				if t.operateHeaders(frame, handle) {
0000000000000000000000000000000000000000;;					t.Close()
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *http2.DataFrame:
0000000000000000000000000000000000000000;;				t.handleData(frame)
0000000000000000000000000000000000000000;;			case *http2.RSTStreamFrame:
0000000000000000000000000000000000000000;;				t.handleRSTStream(frame)
0000000000000000000000000000000000000000;;			case *http2.SettingsFrame:
0000000000000000000000000000000000000000;;				t.handleSettings(frame)
0000000000000000000000000000000000000000;;			case *http2.PingFrame:
0000000000000000000000000000000000000000;;				t.handlePing(frame)
0000000000000000000000000000000000000000;;			case *http2.WindowUpdateFrame:
0000000000000000000000000000000000000000;;				t.handleWindowUpdate(frame)
0000000000000000000000000000000000000000;;			case *http2.GoAwayFrame:
0000000000000000000000000000000000000000;;				// TODO: Handle GoAway from the client appropriately.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				grpclog.Printf("transport: http2Server.HandleStreams found unhandled frame type %v.", frame)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) getStream(f http2.Frame) (*Stream, bool) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		if t.activeStreams == nil {
0000000000000000000000000000000000000000;;			// The transport is closing.
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s, ok := t.activeStreams[f.Header().StreamID]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// The stream is already done.
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateWindow adjusts the inbound quota for the stream and the transport.
0000000000000000000000000000000000000000;;	// Window updates will deliver to the controller for sending when
0000000000000000000000000000000000000000;;	// the cumulative quota exceeds the corresponding threshold.
0000000000000000000000000000000000000000;;	func (t *http2Server) updateWindow(s *Stream, n uint32) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if s.state == streamDone {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w := t.fc.onRead(n); w > 0 {
0000000000000000000000000000000000000000;;			t.controlBuf.put(&windowUpdate{0, w})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w := s.fc.onRead(n); w > 0 {
0000000000000000000000000000000000000000;;			t.controlBuf.put(&windowUpdate{s.id, w})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) handleData(f *http2.DataFrame) {
0000000000000000000000000000000000000000;;		size := len(f.Data())
0000000000000000000000000000000000000000;;		if err := t.fc.onData(uint32(size)); err != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("transport: http2Server %v", err)
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Select the right stream to dispatch.
0000000000000000000000000000000000000000;;		s, ok := t.getStream(f)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if w := t.fc.onRead(uint32(size)); w > 0 {
0000000000000000000000000000000000000000;;				t.controlBuf.put(&windowUpdate{0, w})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if size > 0 {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			if s.state == streamDone {
0000000000000000000000000000000000000000;;				s.mu.Unlock()
0000000000000000000000000000000000000000;;				// The stream has been closed. Release the corresponding quota.
0000000000000000000000000000000000000000;;				if w := t.fc.onRead(uint32(size)); w > 0 {
0000000000000000000000000000000000000000;;					t.controlBuf.put(&windowUpdate{0, w})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := s.fc.onData(uint32(size)); err != nil {
0000000000000000000000000000000000000000;;				s.mu.Unlock()
0000000000000000000000000000000000000000;;				t.closeStream(s)
0000000000000000000000000000000000000000;;				t.controlBuf.put(&resetStream{s.id, http2.ErrCodeFlowControl})
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			// TODO(bradfitz, zhaoq): A copy is required here because there is no
0000000000000000000000000000000000000000;;			// guarantee f.Data() is consumed before the arrival of next frame.
0000000000000000000000000000000000000000;;			// Can this copy be eliminated?
0000000000000000000000000000000000000000;;			data := make([]byte, size)
0000000000000000000000000000000000000000;;			copy(data, f.Data())
0000000000000000000000000000000000000000;;			s.write(recvMsg{data: data})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.Header().Flags.Has(http2.FlagDataEndStream) {
0000000000000000000000000000000000000000;;			// Received the end of stream from the client.
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			if s.state != streamDone {
0000000000000000000000000000000000000000;;				s.state = streamReadDone
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			s.write(recvMsg{err: io.EOF})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) handleRSTStream(f *http2.RSTStreamFrame) {
0000000000000000000000000000000000000000;;		s, ok := t.getStream(f)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.closeStream(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) handleSettings(f *http2.SettingsFrame) {
0000000000000000000000000000000000000000;;		if f.IsAck() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ss []http2.Setting
0000000000000000000000000000000000000000;;		f.ForeachSetting(func(s http2.Setting) error {
0000000000000000000000000000000000000000;;			ss = append(ss, s)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// The settings will be applied once the ack is sent.
0000000000000000000000000000000000000000;;		t.controlBuf.put(&settings{ack: true, ss: ss})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) handlePing(f *http2.PingFrame) {
0000000000000000000000000000000000000000;;		if f.IsAck() { // Do nothing.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pingAck := &ping{ack: true}
0000000000000000000000000000000000000000;;		copy(pingAck.data[:], f.Data[:])
0000000000000000000000000000000000000000;;		t.controlBuf.put(pingAck)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) handleWindowUpdate(f *http2.WindowUpdateFrame) {
0000000000000000000000000000000000000000;;		id := f.Header().StreamID
0000000000000000000000000000000000000000;;		incr := f.Increment
0000000000000000000000000000000000000000;;		if id == 0 {
0000000000000000000000000000000000000000;;			t.sendQuotaPool.add(int(incr))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s, ok := t.getStream(f); ok {
0000000000000000000000000000000000000000;;			s.sendQuotaPool.add(int(incr))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) writeHeaders(s *Stream, b *bytes.Buffer, endStream bool) error {
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		endHeaders := false
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// Sends the headers in a single batch.
0000000000000000000000000000000000000000;;		for !endHeaders {
0000000000000000000000000000000000000000;;			size := t.hBuf.Len()
0000000000000000000000000000000000000000;;			if size > http2MaxFrameLen {
0000000000000000000000000000000000000000;;				size = http2MaxFrameLen
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				endHeaders = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				p := http2.HeadersFrameParam{
0000000000000000000000000000000000000000;;					StreamID:      s.id,
0000000000000000000000000000000000000000;;					BlockFragment: b.Next(size),
0000000000000000000000000000000000000000;;					EndStream:     endStream,
0000000000000000000000000000000000000000;;					EndHeaders:    endHeaders,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = t.framer.writeHeaders(endHeaders, p)
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = t.framer.writeContinuation(endHeaders, s.id, endHeaders, b.Next(size))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Close()
0000000000000000000000000000000000000000;;				return connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeader sends the header metedata md back to the client.
0000000000000000000000000000000000000000;;	func (t *http2Server) WriteHeader(s *Stream, md metadata.MD) error {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if s.headerOk || s.state == streamDone {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return ErrIllegalHeaderWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.headerOk = true
0000000000000000000000000000000000000000;;		if md.Len() > 0 {
0000000000000000000000000000000000000000;;			if s.header.Len() > 0 {
0000000000000000000000000000000000000000;;				s.header = metadata.Join(s.header, md)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s.header = md
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		md = s.header
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		if _, err := wait(s.ctx, nil, nil, t.shutdownChan, t.writableChan); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.hBuf.Reset()
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: "content-type", Value: "application/grpc"})
0000000000000000000000000000000000000000;;		if s.sendCompress != "" {
0000000000000000000000000000000000000000;;			t.hEnc.WriteField(hpack.HeaderField{Name: "grpc-encoding", Value: s.sendCompress})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range md {
0000000000000000000000000000000000000000;;			if isReservedHeader(k) {
0000000000000000000000000000000000000000;;				// Clients don't tolerate reading restricted headers after some non restricted ones were sent.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, entry := range v {
0000000000000000000000000000000000000000;;				t.hEnc.WriteField(hpack.HeaderField{Name: k, Value: entry})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := t.writeHeaders(s, t.hBuf, false); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.writableChan <- 0
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteStatus sends stream status to the client and terminates the stream.
0000000000000000000000000000000000000000;;	// There is no further I/O operations being able to perform on this stream.
0000000000000000000000000000000000000000;;	// TODO(zhaoq): Now it indicates the end of entire stream. Revisit if early
0000000000000000000000000000000000000000;;	// OK is adopted.
0000000000000000000000000000000000000000;;	func (t *http2Server) WriteStatus(s *Stream, statusCode codes.Code, statusDesc string) error {
0000000000000000000000000000000000000000;;		var headersSent, hasHeader bool
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if s.state == streamDone {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.headerOk {
0000000000000000000000000000000000000000;;			headersSent = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.header.Len() > 0 {
0000000000000000000000000000000000000000;;			hasHeader = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !headersSent && hasHeader {
0000000000000000000000000000000000000000;;			t.WriteHeader(s, nil)
0000000000000000000000000000000000000000;;			headersSent = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := wait(s.ctx, nil, nil, t.shutdownChan, t.writableChan); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.hBuf.Reset()
0000000000000000000000000000000000000000;;		if !headersSent {
0000000000000000000000000000000000000000;;			t.hEnc.WriteField(hpack.HeaderField{Name: ":status", Value: "200"})
0000000000000000000000000000000000000000;;			t.hEnc.WriteField(hpack.HeaderField{Name: "content-type", Value: "application/grpc"})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(
0000000000000000000000000000000000000000;;			hpack.HeaderField{
0000000000000000000000000000000000000000;;				Name:  "grpc-status",
0000000000000000000000000000000000000000;;				Value: strconv.Itoa(int(statusCode)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: "grpc-message", Value: encodeGrpcMessage(statusDesc)})
0000000000000000000000000000000000000000;;		// Attach the trailer metadata.
0000000000000000000000000000000000000000;;		for k, v := range s.trailer {
0000000000000000000000000000000000000000;;			// Clients don't tolerate reading restricted headers after some non restricted ones were sent.
0000000000000000000000000000000000000000;;			if isReservedHeader(k) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, entry := range v {
0000000000000000000000000000000000000000;;				t.hEnc.WriteField(hpack.HeaderField{Name: k, Value: entry})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := t.writeHeaders(s, t.hBuf, true); err != nil {
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.closeStream(s)
0000000000000000000000000000000000000000;;		t.writableChan <- 0
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write converts the data into HTTP2 data frame and sends it out. Non-nil error
0000000000000000000000000000000000000000;;	// is returns if it fails (e.g., framing error, transport error).
0000000000000000000000000000000000000000;;	func (t *http2Server) Write(s *Stream, data []byte, opts *Options) error {
0000000000000000000000000000000000000000;;		// TODO(zhaoq): Support multi-writers for a single stream.
0000000000000000000000000000000000000000;;		var writeHeaderFrame bool
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if s.state == streamDone {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return streamErrorf(codes.Unknown, "the stream has been done")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.headerOk {
0000000000000000000000000000000000000000;;			writeHeaderFrame = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		if writeHeaderFrame {
0000000000000000000000000000000000000000;;			t.WriteHeader(s, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := bytes.NewBuffer(data)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if r.Len() == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			size := http2MaxFrameLen
0000000000000000000000000000000000000000;;			s.sendQuotaPool.add(0)
0000000000000000000000000000000000000000;;			// Wait until the stream has some quota to send the data.
0000000000000000000000000000000000000000;;			sq, err := wait(s.ctx, nil, nil, t.shutdownChan, s.sendQuotaPool.acquire())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.sendQuotaPool.add(0)
0000000000000000000000000000000000000000;;			// Wait until the transport has some quota to send the data.
0000000000000000000000000000000000000000;;			tq, err := wait(s.ctx, nil, nil, t.shutdownChan, t.sendQuotaPool.acquire())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if _, ok := err.(StreamError); ok {
0000000000000000000000000000000000000000;;					t.sendQuotaPool.cancel()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sq < size {
0000000000000000000000000000000000000000;;				size = sq
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tq < size {
0000000000000000000000000000000000000000;;				size = tq
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p := r.Next(size)
0000000000000000000000000000000000000000;;			ps := len(p)
0000000000000000000000000000000000000000;;			if ps < sq {
0000000000000000000000000000000000000000;;				// Overbooked stream quota. Return it back.
0000000000000000000000000000000000000000;;				s.sendQuotaPool.add(sq - ps)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ps < tq {
0000000000000000000000000000000000000000;;				// Overbooked transport quota. Return it back.
0000000000000000000000000000000000000000;;				t.sendQuotaPool.add(tq - ps)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.framer.adjustNumWriters(1)
0000000000000000000000000000000000000000;;			// Got some quota. Try to acquire writing privilege on the
0000000000000000000000000000000000000000;;			// transport.
0000000000000000000000000000000000000000;;			if _, err := wait(s.ctx, nil, nil, t.shutdownChan, t.writableChan); err != nil {
0000000000000000000000000000000000000000;;				if _, ok := err.(StreamError); ok {
0000000000000000000000000000000000000000;;					// Return the connection quota back.
0000000000000000000000000000000000000000;;					t.sendQuotaPool.add(ps)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if t.framer.adjustNumWriters(-1) == 0 {
0000000000000000000000000000000000000000;;					// This writer is the last one in this batch and has the
0000000000000000000000000000000000000000;;					// responsibility to flush the buffered frames. It queues
0000000000000000000000000000000000000000;;					// a flush request to controlBuf instead of flushing directly
0000000000000000000000000000000000000000;;					// in order to avoid the race with other writing or flushing.
0000000000000000000000000000000000000000;;					t.controlBuf.put(&flushIO{})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-s.ctx.Done():
0000000000000000000000000000000000000000;;				t.sendQuotaPool.add(ps)
0000000000000000000000000000000000000000;;				if t.framer.adjustNumWriters(-1) == 0 {
0000000000000000000000000000000000000000;;					t.controlBuf.put(&flushIO{})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.writableChan <- 0
0000000000000000000000000000000000000000;;				return ContextErr(s.ctx.Err())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var forceFlush bool
0000000000000000000000000000000000000000;;			if r.Len() == 0 && t.framer.adjustNumWriters(0) == 1 && !opts.Last {
0000000000000000000000000000000000000000;;				forceFlush = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := t.framer.writeData(forceFlush, s.id, false, p); err != nil {
0000000000000000000000000000000000000000;;				t.Close()
0000000000000000000000000000000000000000;;				return connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.framer.adjustNumWriters(-1) == 0 {
0000000000000000000000000000000000000000;;				t.framer.flushWrite()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.writableChan <- 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) applySettings(ss []http2.Setting) {
0000000000000000000000000000000000000000;;		for _, s := range ss {
0000000000000000000000000000000000000000;;			if s.ID == http2.SettingInitialWindowSize {
0000000000000000000000000000000000000000;;				t.mu.Lock()
0000000000000000000000000000000000000000;;				defer t.mu.Unlock()
0000000000000000000000000000000000000000;;				for _, stream := range t.activeStreams {
0000000000000000000000000000000000000000;;					stream.sendQuotaPool.reset(int(s.Val - t.streamSendQuota))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.streamSendQuota = s.Val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controller running in a separate goroutine takes charge of sending control
0000000000000000000000000000000000000000;;	// frames (e.g., window update, reset stream, setting, etc.) to the server.
0000000000000000000000000000000000000000;;	func (t *http2Server) controller() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case i := <-t.controlBuf.get():
0000000000000000000000000000000000000000;;				t.controlBuf.load()
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-t.writableChan:
0000000000000000000000000000000000000000;;					switch i := i.(type) {
0000000000000000000000000000000000000000;;					case *windowUpdate:
0000000000000000000000000000000000000000;;						t.framer.writeWindowUpdate(true, i.streamID, i.increment)
0000000000000000000000000000000000000000;;					case *settings:
0000000000000000000000000000000000000000;;						if i.ack {
0000000000000000000000000000000000000000;;							t.framer.writeSettingsAck(true)
0000000000000000000000000000000000000000;;							t.applySettings(i.ss)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							t.framer.writeSettings(true, i.ss...)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case *resetStream:
0000000000000000000000000000000000000000;;						t.framer.writeRSTStream(true, i.streamID, i.code)
0000000000000000000000000000000000000000;;					case *goAway:
0000000000000000000000000000000000000000;;						t.mu.Lock()
0000000000000000000000000000000000000000;;						if t.state == closing {
0000000000000000000000000000000000000000;;							t.mu.Unlock()
0000000000000000000000000000000000000000;;							// The transport is closing.
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						sid := t.maxStreamID
0000000000000000000000000000000000000000;;						t.state = draining
0000000000000000000000000000000000000000;;						t.mu.Unlock()
0000000000000000000000000000000000000000;;						t.framer.writeGoAway(true, sid, http2.ErrCodeNo, nil)
0000000000000000000000000000000000000000;;					case *flushIO:
0000000000000000000000000000000000000000;;						t.framer.flushWrite()
0000000000000000000000000000000000000000;;					case *ping:
0000000000000000000000000000000000000000;;						t.framer.writePing(true, i.ack, i.data)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						grpclog.Printf("transport: http2Server.controller got unexpected item type %v\n", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t.writableChan <- 0
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case <-t.shutdownChan:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-t.shutdownChan:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close starts shutting down the http2Server transport.
0000000000000000000000000000000000000000;;	// TODO(zhaoq): Now the destruction is not blocked on any pending streams. This
0000000000000000000000000000000000000000;;	// could cause some resource issue. Revisit this later.
0000000000000000000000000000000000000000;;	func (t *http2Server) Close() (err error) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		if t.state == closing {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return errors.New("transport: Close() was already called")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.state = closing
0000000000000000000000000000000000000000;;		streams := t.activeStreams
0000000000000000000000000000000000000000;;		t.activeStreams = nil
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		close(t.shutdownChan)
0000000000000000000000000000000000000000;;		err = t.conn.Close()
0000000000000000000000000000000000000000;;		// Cancel all active streams.
0000000000000000000000000000000000000000;;		for _, s := range streams {
0000000000000000000000000000000000000000;;			s.cancel()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// closeStream clears the footprint of a stream when the stream is not needed
0000000000000000000000000000000000000000;;	// any more.
0000000000000000000000000000000000000000;;	func (t *http2Server) closeStream(s *Stream) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		delete(t.activeStreams, s.id)
0000000000000000000000000000000000000000;;		if t.state == draining && len(t.activeStreams) == 0 {
0000000000000000000000000000000000000000;;			defer t.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		// In case stream sending and receiving are invoked in separate
0000000000000000000000000000000000000000;;		// goroutines (e.g., bi-directional streaming), cancel needs to be
0000000000000000000000000000000000000000;;		// called to interrupt the potential blocking on other goroutines.
0000000000000000000000000000000000000000;;		s.cancel()
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if q := s.fc.resetPendingData(); q > 0 {
0000000000000000000000000000000000000000;;			if w := t.fc.onRead(q); w > 0 {
0000000000000000000000000000000000000000;;				t.controlBuf.put(&windowUpdate{0, w})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.state == streamDone {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.state = streamDone
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) RemoteAddr() net.Addr {
0000000000000000000000000000000000000000;;		return t.conn.RemoteAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Server) Drain() {
0000000000000000000000000000000000000000;;		t.controlBuf.put(&goAway{})
0000000000000000000000000000000000000000;;	}
