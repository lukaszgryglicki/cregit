0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/transport/http_util.go[Godeps/_workspace/src/google.golang.org/grpc/transport/http_util.go][vendor/google.golang.org/grpc/transport/http_util.go];	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2/hpack"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The primary user agent
0000000000000000000000000000000000000000;;		primaryUA = "grpc-go/1.0"
0000000000000000000000000000000000000000;;		// http2MaxFrameLen specifies the max length of a HTTP2 frame.
0000000000000000000000000000000000000000;;		http2MaxFrameLen = 16384 // 16KB frame
0000000000000000000000000000000000000000;;		// http://http2.github.io/http2-spec/#SettingValues
0000000000000000000000000000000000000000;;		http2InitHeaderTableSize = 4096
0000000000000000000000000000000000000000;;		// http2IOBufSize specifies the buffer size for sending frames.
0000000000000000000000000000000000000000;;		http2IOBufSize = 32 * 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		clientPreface   = []byte(http2.ClientPreface)
0000000000000000000000000000000000000000;;		http2ErrConvTab = map[http2.ErrCode]codes.Code{
0000000000000000000000000000000000000000;;			http2.ErrCodeNo:                 codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeProtocol:           codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeInternal:           codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeFlowControl:        codes.ResourceExhausted,
0000000000000000000000000000000000000000;;			http2.ErrCodeSettingsTimeout:    codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeStreamClosed:       codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeFrameSize:          codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeRefusedStream:      codes.Unavailable,
0000000000000000000000000000000000000000;;			http2.ErrCodeCancel:             codes.Canceled,
0000000000000000000000000000000000000000;;			http2.ErrCodeCompression:        codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeConnect:            codes.Internal,
0000000000000000000000000000000000000000;;			http2.ErrCodeEnhanceYourCalm:    codes.ResourceExhausted,
0000000000000000000000000000000000000000;;			http2.ErrCodeInadequateSecurity: codes.PermissionDenied,
0000000000000000000000000000000000000000;;			http2.ErrCodeHTTP11Required:     codes.FailedPrecondition,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statusCodeConvTab = map[codes.Code]http2.ErrCode{
0000000000000000000000000000000000000000;;			codes.Internal:          http2.ErrCodeInternal,
0000000000000000000000000000000000000000;;			codes.Canceled:          http2.ErrCodeCancel,
0000000000000000000000000000000000000000;;			codes.Unavailable:       http2.ErrCodeRefusedStream,
0000000000000000000000000000000000000000;;			codes.ResourceExhausted: http2.ErrCodeEnhanceYourCalm,
0000000000000000000000000000000000000000;;			codes.PermissionDenied:  http2.ErrCodeInadequateSecurity,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Records the states during HPACK decoding. Must be reset once the
0000000000000000000000000000000000000000;;	// decoding of the entire headers are finished.
0000000000000000000000000000000000000000;;	type decodeState struct {
0000000000000000000000000000000000000000;;		err error // first error encountered decoding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoding string
0000000000000000000000000000000000000000;;		// statusCode caches the stream status received from the trailer
0000000000000000000000000000000000000000;;		// the server sent. Client side only.
0000000000000000000000000000000000000000;;		statusCode codes.Code
0000000000000000000000000000000000000000;;		statusDesc string
0000000000000000000000000000000000000000;;		// Server side only fields.
0000000000000000000000000000000000000000;;		timeoutSet bool
0000000000000000000000000000000000000000;;		timeout    time.Duration
0000000000000000000000000000000000000000;;		method     string
0000000000000000000000000000000000000000;;		// key-value metadata map from the peer.
0000000000000000000000000000000000000000;;		mdata map[string][]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isReservedHeader checks whether hdr belongs to HTTP2 headers
0000000000000000000000000000000000000000;;	// reserved by gRPC protocol. Any other headers are classified as the
0000000000000000000000000000000000000000;;	// user-specified metadata.
0000000000000000000000000000000000000000;;	func isReservedHeader(hdr string) bool {
0000000000000000000000000000000000000000;;		if hdr != "" && hdr[0] == ':' {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch hdr {
0000000000000000000000000000000000000000;;		case "content-type",
0000000000000000000000000000000000000000;;			"grpc-message-type",
0000000000000000000000000000000000000000;;			"grpc-encoding",
0000000000000000000000000000000000000000;;			"grpc-message",
0000000000000000000000000000000000000000;;			"grpc-status",
0000000000000000000000000000000000000000;;			"grpc-timeout",
0000000000000000000000000000000000000000;;			"te":
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isWhitelistedPseudoHeader checks whether hdr belongs to HTTP2 pseudoheaders
0000000000000000000000000000000000000000;;	// that should be propagated into metadata visible to users.
0000000000000000000000000000000000000000;;	func isWhitelistedPseudoHeader(hdr string) bool {
0000000000000000000000000000000000000000;;		switch hdr {
0000000000000000000000000000000000000000;;		case ":authority":
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decodeState) setErr(err error) {
0000000000000000000000000000000000000000;;		if d.err == nil {
0000000000000000000000000000000000000000;;			d.err = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validContentType(t string) bool {
0000000000000000000000000000000000000000;;		e := "application/grpc"
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(t, e) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Support variations on the content-type
0000000000000000000000000000000000000000;;		// (e.g. "application/grpc+blah", "application/grpc;blah").
0000000000000000000000000000000000000000;;		if len(t) > len(e) && t[len(e)] != '+' && t[len(e)] != ';' {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decodeState) processHeaderField(f hpack.HeaderField) {
0000000000000000000000000000000000000000;;		switch f.Name {
0000000000000000000000000000000000000000;;		case "content-type":
0000000000000000000000000000000000000000;;			if !validContentType(f.Value) {
0000000000000000000000000000000000000000;;				d.setErr(streamErrorf(codes.FailedPrecondition, "transport: received the unexpected content-type %q", f.Value))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "grpc-encoding":
0000000000000000000000000000000000000000;;			d.encoding = f.Value
0000000000000000000000000000000000000000;;		case "grpc-status":
0000000000000000000000000000000000000000;;			code, err := strconv.Atoi(f.Value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.setErr(streamErrorf(codes.Internal, "transport: malformed grpc-status: %v", err))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.statusCode = codes.Code(code)
0000000000000000000000000000000000000000;;		case "grpc-message":
0000000000000000000000000000000000000000;;			d.statusDesc = decodeGrpcMessage(f.Value)
0000000000000000000000000000000000000000;;		case "grpc-timeout":
0000000000000000000000000000000000000000;;			d.timeoutSet = true
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			d.timeout, err = decodeTimeout(f.Value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.setErr(streamErrorf(codes.Internal, "transport: malformed time-out: %v", err))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ":path":
0000000000000000000000000000000000000000;;			d.method = f.Value
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if !isReservedHeader(f.Name) || isWhitelistedPseudoHeader(f.Name) {
0000000000000000000000000000000000000000;;				if f.Name == "user-agent" {
0000000000000000000000000000000000000000;;					i := strings.LastIndex(f.Value, " ")
0000000000000000000000000000000000000000;;					if i == -1 {
0000000000000000000000000000000000000000;;						// There is no application user agent string being set.
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Extract the application user agent string.
0000000000000000000000000000000000000000;;					f.Value = f.Value[:i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if d.mdata == nil {
0000000000000000000000000000000000000000;;					d.mdata = make(map[string][]string)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				k, v, err := metadata.DecodeKeyValue(f.Name, f.Value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					grpclog.Printf("Failed to decode (%q, %q): %v", f.Name, f.Value, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.mdata[k] = append(d.mdata[k], v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timeoutUnit uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		hour        timeoutUnit = 'H'
0000000000000000000000000000000000000000;;		minute      timeoutUnit = 'M'
0000000000000000000000000000000000000000;;		second      timeoutUnit = 'S'
0000000000000000000000000000000000000000;;		millisecond timeoutUnit = 'm'
0000000000000000000000000000000000000000;;		microsecond timeoutUnit = 'u'
0000000000000000000000000000000000000000;;		nanosecond  timeoutUnit = 'n'
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func timeoutUnitToDuration(u timeoutUnit) (d time.Duration, ok bool) {
0000000000000000000000000000000000000000;;		switch u {
0000000000000000000000000000000000000000;;		case hour:
0000000000000000000000000000000000000000;;			return time.Hour, true
0000000000000000000000000000000000000000;;		case minute:
0000000000000000000000000000000000000000;;			return time.Minute, true
0000000000000000000000000000000000000000;;		case second:
0000000000000000000000000000000000000000;;			return time.Second, true
0000000000000000000000000000000000000000;;		case millisecond:
0000000000000000000000000000000000000000;;			return time.Millisecond, true
0000000000000000000000000000000000000000;;		case microsecond:
0000000000000000000000000000000000000000;;			return time.Microsecond, true
0000000000000000000000000000000000000000;;		case nanosecond:
0000000000000000000000000000000000000000;;			return time.Nanosecond, true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxTimeoutValue int64 = 100000000 - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// div does integer division and round-up the result. Note that this is
0000000000000000000000000000000000000000;;	// equivalent to (d+r-1)/r but has less chance to overflow.
0000000000000000000000000000000000000000;;	func div(d, r time.Duration) int64 {
0000000000000000000000000000000000000000;;		if m := d % r; m > 0 {
0000000000000000000000000000000000000000;;			return int64(d/r + 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(d / r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(zhaoq): It is the simplistic and not bandwidth efficient. Improve it.
0000000000000000000000000000000000000000;;	func encodeTimeout(t time.Duration) string {
0000000000000000000000000000000000000000;;		if t <= 0 {
0000000000000000000000000000000000000000;;			return "0n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d := div(t, time.Nanosecond); d <= maxTimeoutValue {
0000000000000000000000000000000000000000;;			return strconv.FormatInt(d, 10) + "n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d := div(t, time.Microsecond); d <= maxTimeoutValue {
0000000000000000000000000000000000000000;;			return strconv.FormatInt(d, 10) + "u"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d := div(t, time.Millisecond); d <= maxTimeoutValue {
0000000000000000000000000000000000000000;;			return strconv.FormatInt(d, 10) + "m"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d := div(t, time.Second); d <= maxTimeoutValue {
0000000000000000000000000000000000000000;;			return strconv.FormatInt(d, 10) + "S"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d := div(t, time.Minute); d <= maxTimeoutValue {
0000000000000000000000000000000000000000;;			return strconv.FormatInt(d, 10) + "M"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Note that maxTimeoutValue * time.Hour > MaxInt64.
0000000000000000000000000000000000000000;;		return strconv.FormatInt(div(t, time.Hour), 10) + "H"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeTimeout(s string) (time.Duration, error) {
0000000000000000000000000000000000000000;;		size := len(s)
0000000000000000000000000000000000000000;;		if size < 2 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("transport: timeout string is too short: %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unit := timeoutUnit(s[size-1])
0000000000000000000000000000000000000000;;		d, ok := timeoutUnitToDuration(unit)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("transport: timeout unit is not recognized: %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := strconv.ParseInt(s[:size-1], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d * time.Duration(t), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		spaceByte   = ' '
0000000000000000000000000000000000000000;;		tildaByte   = '~'
0000000000000000000000000000000000000000;;		percentByte = '%'
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeGrpcMessage is used to encode status code in header field
0000000000000000000000000000000000000000;;	// "grpc-message".
0000000000000000000000000000000000000000;;	// It checks to see if each individual byte in msg is an
0000000000000000000000000000000000000000;;	// allowable byte, and then either percent encoding or passing it through.
0000000000000000000000000000000000000000;;	// When percent encoding, the byte is converted into hexadecimal notation
0000000000000000000000000000000000000000;;	// with a '%' prepended.
0000000000000000000000000000000000000000;;	func encodeGrpcMessage(msg string) string {
0000000000000000000000000000000000000000;;		if msg == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lenMsg := len(msg)
0000000000000000000000000000000000000000;;		for i := 0; i < lenMsg; i++ {
0000000000000000000000000000000000000000;;			c := msg[i]
0000000000000000000000000000000000000000;;			if !(c >= spaceByte && c < tildaByte && c != percentByte) {
0000000000000000000000000000000000000000;;				return encodeGrpcMessageUnchecked(msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeGrpcMessageUnchecked(msg string) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		lenMsg := len(msg)
0000000000000000000000000000000000000000;;		for i := 0; i < lenMsg; i++ {
0000000000000000000000000000000000000000;;			c := msg[i]
0000000000000000000000000000000000000000;;			if c >= spaceByte && c < tildaByte && c != percentByte {
0000000000000000000000000000000000000000;;				buf.WriteByte(c)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteString(fmt.Sprintf("%%%02X", c))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeGrpcMessage decodes the msg encoded by encodeGrpcMessage.
0000000000000000000000000000000000000000;;	func decodeGrpcMessage(msg string) string {
0000000000000000000000000000000000000000;;		if msg == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lenMsg := len(msg)
0000000000000000000000000000000000000000;;		for i := 0; i < lenMsg; i++ {
0000000000000000000000000000000000000000;;			if msg[i] == percentByte && i+2 < lenMsg {
0000000000000000000000000000000000000000;;				return decodeGrpcMessageUnchecked(msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeGrpcMessageUnchecked(msg string) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		lenMsg := len(msg)
0000000000000000000000000000000000000000;;		for i := 0; i < lenMsg; i++ {
0000000000000000000000000000000000000000;;			c := msg[i]
0000000000000000000000000000000000000000;;			if c == percentByte && i+2 < lenMsg {
0000000000000000000000000000000000000000;;				parsed, err := strconv.ParseUint(msg[i+1:i+3], 16, 8)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					buf.WriteByte(c)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					buf.WriteByte(byte(parsed))
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteByte(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type framer struct {
0000000000000000000000000000000000000000;;		numWriters int32
0000000000000000000000000000000000000000;;		reader     io.Reader
0000000000000000000000000000000000000000;;		writer     *bufio.Writer
0000000000000000000000000000000000000000;;		fr         *http2.Framer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFramer(conn net.Conn) *framer {
0000000000000000000000000000000000000000;;		f := &framer{
0000000000000000000000000000000000000000;;			reader: bufio.NewReaderSize(conn, http2IOBufSize),
0000000000000000000000000000000000000000;;			writer: bufio.NewWriterSize(conn, http2IOBufSize),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.fr = http2.NewFramer(f.writer, f.reader)
0000000000000000000000000000000000000000;;		f.fr.ReadMetaHeaders = hpack.NewDecoder(http2InitHeaderTableSize, nil)
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) adjustNumWriters(i int32) int32 {
0000000000000000000000000000000000000000;;		return atomic.AddInt32(&f.numWriters, i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following writeXXX functions can only be called when the caller gets
0000000000000000000000000000000000000000;;	// unblocked from writableChan channel (i.e., owns the privilege to write).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeContinuation(forceFlush bool, streamID uint32, endHeaders bool, headerBlockFragment []byte) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteContinuation(streamID, endHeaders, headerBlockFragment); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeData(forceFlush bool, streamID uint32, endStream bool, data []byte) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteData(streamID, endStream, data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeGoAway(forceFlush bool, maxStreamID uint32, code http2.ErrCode, debugData []byte) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteGoAway(maxStreamID, code, debugData); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeHeaders(forceFlush bool, p http2.HeadersFrameParam) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteHeaders(p); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writePing(forceFlush, ack bool, data [8]byte) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WritePing(ack, data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writePriority(forceFlush bool, streamID uint32, p http2.PriorityParam) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WritePriority(streamID, p); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writePushPromise(forceFlush bool, p http2.PushPromiseParam) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WritePushPromise(p); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeRSTStream(forceFlush bool, streamID uint32, code http2.ErrCode) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteRSTStream(streamID, code); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeSettings(forceFlush bool, settings ...http2.Setting) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteSettings(settings...); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeSettingsAck(forceFlush bool) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteSettingsAck(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) writeWindowUpdate(forceFlush bool, streamID, incr uint32) error {
0000000000000000000000000000000000000000;;		if err := f.fr.WriteWindowUpdate(streamID, incr); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceFlush {
0000000000000000000000000000000000000000;;			return f.writer.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) flushWrite() error {
0000000000000000000000000000000000000000;;		return f.writer.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) readFrame() (http2.Frame, error) {
0000000000000000000000000000000000000000;;		return f.fr.ReadFrame()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *framer) errorDetail() error {
0000000000000000000000000000000000000000;;		return f.fr.ErrorDetail()
0000000000000000000000000000000000000000;;	}
