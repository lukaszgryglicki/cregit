0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Copyright 2016, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	// This file is the implementation of a gRPC server using HTTP/2 which
0000000000000000000000000000000000000000;;	// uses the standard Go http2 Server implementation (via the
0000000000000000000000000000000000000000;;	// http.Handler interface), rather than speaking low-level HTTP/2
0000000000000000000000000000000000000000;;	// frames itself. It is the implementation of *grpc.Server.ServeHTTP.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/peer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerHandlerTransport returns a ServerTransport handling gRPC
0000000000000000000000000000000000000000;;	// from inside an http.Handler. It requires that the http Server
0000000000000000000000000000000000000000;;	// supports HTTP/2.
0000000000000000000000000000000000000000;;	func NewServerHandlerTransport(w http.ResponseWriter, r *http.Request) (ServerTransport, error) {
0000000000000000000000000000000000000000;;		if r.ProtoMajor != 2 {
0000000000000000000000000000000000000000;;			return nil, errors.New("gRPC requires HTTP/2")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Method != "POST" {
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid gRPC request method")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !validContentType(r.Header.Get("Content-Type")) {
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid gRPC request content-type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := w.(http.Flusher); !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("gRPC requires a ResponseWriter supporting http.Flusher")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := w.(http.CloseNotifier); !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("gRPC requires a ResponseWriter supporting http.CloseNotifier")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		st := &serverHandlerTransport{
0000000000000000000000000000000000000000;;			rw:       w,
0000000000000000000000000000000000000000;;			req:      r,
0000000000000000000000000000000000000000;;			closedCh: make(chan struct{}),
0000000000000000000000000000000000000000;;			writes:   make(chan func()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v := r.Header.Get("grpc-timeout"); v != "" {
0000000000000000000000000000000000000000;;			to, err := decodeTimeout(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, streamErrorf(codes.Internal, "malformed time-out: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			st.timeoutSet = true
0000000000000000000000000000000000000000;;			st.timeout = to
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var metakv []string
0000000000000000000000000000000000000000;;		if r.Host != "" {
0000000000000000000000000000000000000000;;			metakv = append(metakv, ":authority", r.Host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, vv := range r.Header {
0000000000000000000000000000000000000000;;			k = strings.ToLower(k)
0000000000000000000000000000000000000000;;			if isReservedHeader(k) && !isWhitelistedPseudoHeader(k) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range vv {
0000000000000000000000000000000000000000;;				if k == "user-agent" {
0000000000000000000000000000000000000000;;					// user-agent is special. Copying logic of http_util.go.
0000000000000000000000000000000000000000;;					if i := strings.LastIndex(v, " "); i == -1 {
0000000000000000000000000000000000000000;;						// There is no application user agent string being set
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						v = v[:i]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				metakv = append(metakv, k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.headerMD = metadata.Pairs(metakv...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return st, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serverHandlerTransport is an implementation of ServerTransport
0000000000000000000000000000000000000000;;	// which replies to exactly one gRPC request (exactly one HTTP request),
0000000000000000000000000000000000000000;;	// using the net/http.Handler interface. This http.Handler is guaranteed
0000000000000000000000000000000000000000;;	// at this point to be speaking over HTTP/2, so it's able to speak valid
0000000000000000000000000000000000000000;;	// gRPC.
0000000000000000000000000000000000000000;;	type serverHandlerTransport struct {
0000000000000000000000000000000000000000;;		rw               http.ResponseWriter
0000000000000000000000000000000000000000;;		req              *http.Request
0000000000000000000000000000000000000000;;		timeoutSet       bool
0000000000000000000000000000000000000000;;		timeout          time.Duration
0000000000000000000000000000000000000000;;		didCommonHeaders bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerMD metadata.MD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closeOnce sync.Once
0000000000000000000000000000000000000000;;		closedCh  chan struct{} // closed on Close
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// writes is a channel of code to run serialized in the
0000000000000000000000000000000000000000;;		// ServeHTTP (HandleStreams) goroutine. The channel is closed
0000000000000000000000000000000000000000;;		// when WriteStatus is called.
0000000000000000000000000000000000000000;;		writes chan func()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) Close() error {
0000000000000000000000000000000000000000;;		ht.closeOnce.Do(ht.closeCloseChanOnce)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) closeCloseChanOnce() { close(ht.closedCh) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) RemoteAddr() net.Addr { return strAddr(ht.req.RemoteAddr) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// strAddr is a net.Addr backed by either a TCP "ip:port" string, or
0000000000000000000000000000000000000000;;	// the empty string if unknown.
0000000000000000000000000000000000000000;;	type strAddr string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a strAddr) Network() string {
0000000000000000000000000000000000000000;;		if a != "" {
0000000000000000000000000000000000000000;;			// Per the documentation on net/http.Request.RemoteAddr, if this is
0000000000000000000000000000000000000000;;			// set, it's set to the IP:port of the peer (hence, TCP):
0000000000000000000000000000000000000000;;			// https://golang.org/pkg/net/http/#Request
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// If we want to support Unix sockets later, we can
0000000000000000000000000000000000000000;;			// add our own grpc-specific convention within the
0000000000000000000000000000000000000000;;			// grpc codebase to set RemoteAddr to a different
0000000000000000000000000000000000000000;;			// format, or probably better: we can attach it to the
0000000000000000000000000000000000000000;;			// context and use that from serverHandlerTransport.RemoteAddr.
0000000000000000000000000000000000000000;;			return "tcp"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a strAddr) String() string { return string(a) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// do runs fn in the ServeHTTP goroutine.
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) do(fn func()) error {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case ht.writes <- fn:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-ht.closedCh:
0000000000000000000000000000000000000000;;			return ErrConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) WriteStatus(s *Stream, statusCode codes.Code, statusDesc string) error {
0000000000000000000000000000000000000000;;		err := ht.do(func() {
0000000000000000000000000000000000000000;;			ht.writeCommonHeaders(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// And flush, in case no header or body has been sent yet.
0000000000000000000000000000000000000000;;			// This forces a separation of headers and trailers if this is the
0000000000000000000000000000000000000000;;			// first call (for example, in end2end tests's TestNoService).
0000000000000000000000000000000000000000;;			ht.rw.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			h := ht.rw.Header()
0000000000000000000000000000000000000000;;			h.Set("Grpc-Status", fmt.Sprintf("%d", statusCode))
0000000000000000000000000000000000000000;;			if statusDesc != "" {
0000000000000000000000000000000000000000;;				h.Set("Grpc-Message", encodeGrpcMessage(statusDesc))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if md := s.Trailer(); len(md) > 0 {
0000000000000000000000000000000000000000;;				for k, vv := range md {
0000000000000000000000000000000000000000;;					// Clients don't tolerate reading restricted headers after some non restricted ones were sent.
0000000000000000000000000000000000000000;;					if isReservedHeader(k) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, v := range vv {
0000000000000000000000000000000000000000;;						// http2 ResponseWriter mechanism to
0000000000000000000000000000000000000000;;						// send undeclared Trailers after the
0000000000000000000000000000000000000000;;						// headers have possibly been written.
0000000000000000000000000000000000000000;;						h.Add(http2.TrailerPrefix+k, v)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		close(ht.writes)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeCommonHeaders sets common headers on the first write
0000000000000000000000000000000000000000;;	// call (Write, WriteHeader, or WriteStatus).
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) writeCommonHeaders(s *Stream) {
0000000000000000000000000000000000000000;;		if ht.didCommonHeaders {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ht.didCommonHeaders = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := ht.rw.Header()
0000000000000000000000000000000000000000;;		h["Date"] = nil // suppress Date to make tests happy; TODO: restore
0000000000000000000000000000000000000000;;		h.Set("Content-Type", "application/grpc")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Predeclare trailers we'll set later in WriteStatus (after the body).
0000000000000000000000000000000000000000;;		// This is a SHOULD in the HTTP RFC, and the way you add (known)
0000000000000000000000000000000000000000;;		// Trailers per the net/http.ResponseWriter contract.
0000000000000000000000000000000000000000;;		// See https://golang.org/pkg/net/http/#ResponseWriter
0000000000000000000000000000000000000000;;		// and https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
0000000000000000000000000000000000000000;;		h.Add("Trailer", "Grpc-Status")
0000000000000000000000000000000000000000;;		h.Add("Trailer", "Grpc-Message")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.sendCompress != "" {
0000000000000000000000000000000000000000;;			h.Set("Grpc-Encoding", s.sendCompress)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) Write(s *Stream, data []byte, opts *Options) error {
0000000000000000000000000000000000000000;;		return ht.do(func() {
0000000000000000000000000000000000000000;;			ht.writeCommonHeaders(s)
0000000000000000000000000000000000000000;;			ht.rw.Write(data)
0000000000000000000000000000000000000000;;			if !opts.Delay {
0000000000000000000000000000000000000000;;				ht.rw.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) WriteHeader(s *Stream, md metadata.MD) error {
0000000000000000000000000000000000000000;;		return ht.do(func() {
0000000000000000000000000000000000000000;;			ht.writeCommonHeaders(s)
0000000000000000000000000000000000000000;;			h := ht.rw.Header()
0000000000000000000000000000000000000000;;			for k, vv := range md {
0000000000000000000000000000000000000000;;				// Clients don't tolerate reading restricted headers after some non restricted ones were sent.
0000000000000000000000000000000000000000;;				if isReservedHeader(k) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, v := range vv {
0000000000000000000000000000000000000000;;					h.Add(k, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ht.rw.WriteHeader(200)
0000000000000000000000000000000000000000;;			ht.rw.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) HandleStreams(startStream func(*Stream)) {
0000000000000000000000000000000000000000;;		// With this transport type there will be exactly 1 stream: this HTTP request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ctx context.Context
0000000000000000000000000000000000000000;;		var cancel context.CancelFunc
0000000000000000000000000000000000000000;;		if ht.timeoutSet {
0000000000000000000000000000000000000000;;			ctx, cancel = context.WithTimeout(context.Background(), ht.timeout)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ctx, cancel = context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// requestOver is closed when either the request's context is done
0000000000000000000000000000000000000000;;		// or the status has been written via WriteStatus.
0000000000000000000000000000000000000000;;		requestOver := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clientGone receives a single value if peer is gone, either
0000000000000000000000000000000000000000;;		// because the underlying connection is dead or because the
0000000000000000000000000000000000000000;;		// peer sends an http2 RST_STREAM.
0000000000000000000000000000000000000000;;		clientGone := ht.rw.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-requestOver:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-ht.closedCh:
0000000000000000000000000000000000000000;;			case <-clientGone:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := ht.req
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &Stream{
0000000000000000000000000000000000000000;;			id:            0,            // irrelevant
0000000000000000000000000000000000000000;;			windowHandler: func(int) {}, // nothing
0000000000000000000000000000000000000000;;			cancel:        cancel,
0000000000000000000000000000000000000000;;			buf:           newRecvBuffer(),
0000000000000000000000000000000000000000;;			st:            ht,
0000000000000000000000000000000000000000;;			method:        req.URL.Path,
0000000000000000000000000000000000000000;;			recvCompress:  req.Header.Get("grpc-encoding"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pr := &peer.Peer{
0000000000000000000000000000000000000000;;			Addr: ht.RemoteAddr(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.TLS != nil {
0000000000000000000000000000000000000000;;			pr.AuthInfo = credentials.TLSInfo{State: *req.TLS}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx = metadata.NewContext(ctx, ht.headerMD)
0000000000000000000000000000000000000000;;		ctx = peer.NewContext(ctx, pr)
0000000000000000000000000000000000000000;;		s.ctx = newContextWithStream(ctx, s)
0000000000000000000000000000000000000000;;		s.dec = &recvBufferReader{ctx: s.ctx, recv: s.buf}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readerDone is closed when the Body.Read-ing goroutine exits.
0000000000000000000000000000000000000000;;		readerDone := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(readerDone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: minimize garbage, optimize recvBuffer code/ownership
0000000000000000000000000000000000000000;;			const readSize = 8196
0000000000000000000000000000000000000000;;			for buf := make([]byte, readSize); ; {
0000000000000000000000000000000000000000;;				n, err := req.Body.Read(buf)
0000000000000000000000000000000000000000;;				if n > 0 {
0000000000000000000000000000000000000000;;					s.buf.put(&recvMsg{data: buf[:n:n]})
0000000000000000000000000000000000000000;;					buf = buf[n:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					s.buf.put(&recvMsg{err: mapRecvMsgError(err)})
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(buf) == 0 {
0000000000000000000000000000000000000000;;					buf = make([]byte, readSize)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// startStream is provided by the *grpc.Server's serveStreams.
0000000000000000000000000000000000000000;;		// It starts a goroutine serving s and exits immediately.
0000000000000000000000000000000000000000;;		// The goroutine that is started is the one that then calls
0000000000000000000000000000000000000000;;		// into ht, calling WriteHeader, Write, WriteStatus, Close, etc.
0000000000000000000000000000000000000000;;		startStream(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ht.runStream()
0000000000000000000000000000000000000000;;		close(requestOver)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for reading goroutine to finish.
0000000000000000000000000000000000000000;;		req.Body.Close()
0000000000000000000000000000000000000000;;		<-readerDone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) runStream() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case fn, ok := <-ht.writes:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fn()
0000000000000000000000000000000000000000;;			case <-ht.closedCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ht *serverHandlerTransport) Drain() {
0000000000000000000000000000000000000000;;		panic("Drain() is not implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapRecvMsgError returns the non-nil err into the appropriate
0000000000000000000000000000000000000000;;	// error value as expected by callers of *grpc.parser.recvMsg.
0000000000000000000000000000000000000000;;	// In particular, in can only be:
0000000000000000000000000000000000000000;;	//   * io.EOF
0000000000000000000000000000000000000000;;	//   * io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;	//   * of type transport.ConnectionError
0000000000000000000000000000000000000000;;	//   * of type transport.StreamError
0000000000000000000000000000000000000000;;	func mapRecvMsgError(err error) error {
0000000000000000000000000000000000000000;;		if err == io.EOF || err == io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if se, ok := err.(http2.StreamError); ok {
0000000000000000000000000000000000000000;;			if code, ok := http2ErrConvTab[se.Code]; ok {
0000000000000000000000000000000000000000;;				return StreamError{
0000000000000000000000000000000000000000;;					Code: code,
0000000000000000000000000000000000000000;;					Desc: se.Error(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return connectionErrorf(true, err, err.Error())
0000000000000000000000000000000000000000;;	}
