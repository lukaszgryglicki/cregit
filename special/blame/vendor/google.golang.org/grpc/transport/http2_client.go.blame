0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/transport/http2_client.go[Godeps/_workspace/src/google.golang.org/grpc/transport/http2_client.go][vendor/google.golang.org/grpc/transport/http2_client.go];	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2/hpack"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/peer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// http2Client implements the ClientTransport interface with HTTP2.
0000000000000000000000000000000000000000;;	type http2Client struct {
0000000000000000000000000000000000000000;;		target    string // server name/addr
0000000000000000000000000000000000000000;;		userAgent string
0000000000000000000000000000000000000000;;		md        interface{}
0000000000000000000000000000000000000000;;		conn      net.Conn             // underlying communication channel
0000000000000000000000000000000000000000;;		authInfo  credentials.AuthInfo // auth info about the connection
0000000000000000000000000000000000000000;;		nextID    uint32               // the next stream ID to be used
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// writableChan synchronizes write access to the transport.
0000000000000000000000000000000000000000;;		// A writer acquires the write lock by sending a value on writableChan
0000000000000000000000000000000000000000;;		// and releases it by receiving from writableChan.
0000000000000000000000000000000000000000;;		writableChan chan int
0000000000000000000000000000000000000000;;		// shutdownChan is closed when Close is called.
0000000000000000000000000000000000000000;;		// Blocking operations should select on shutdownChan to avoid
0000000000000000000000000000000000000000;;		// blocking forever after Close.
0000000000000000000000000000000000000000;;		// TODO(zhaoq): Maybe have a channel context?
0000000000000000000000000000000000000000;;		shutdownChan chan struct{}
0000000000000000000000000000000000000000;;		// errorChan is closed to notify the I/O error to the caller.
0000000000000000000000000000000000000000;;		errorChan chan struct{}
0000000000000000000000000000000000000000;;		// goAway is closed to notify the upper layer (i.e., addrConn.transportMonitor)
0000000000000000000000000000000000000000;;		// that the server sent GoAway on this transport.
0000000000000000000000000000000000000000;;		goAway chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		framer *framer
0000000000000000000000000000000000000000;;		hBuf   *bytes.Buffer  // the buffer for HPACK encoding
0000000000000000000000000000000000000000;;		hEnc   *hpack.Encoder // HPACK encoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// controlBuf delivers all the control related tasks (e.g., window
0000000000000000000000000000000000000000;;		// updates, reset streams, and various settings) to the controller.
0000000000000000000000000000000000000000;;		controlBuf *recvBuffer
0000000000000000000000000000000000000000;;		fc         *inFlow
0000000000000000000000000000000000000000;;		// sendQuotaPool provides flow control to outbound message.
0000000000000000000000000000000000000000;;		sendQuotaPool *quotaPool
0000000000000000000000000000000000000000;;		// streamsQuota limits the max number of concurrent streams.
0000000000000000000000000000000000000000;;		streamsQuota *quotaPool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The scheme used: https if TLS is on, http otherwise.
0000000000000000000000000000000000000000;;		scheme string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds []credentials.PerRPCCredentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu            sync.Mutex     // guard the following variables
0000000000000000000000000000000000000000;;		state         transportState // the state of underlying connection
0000000000000000000000000000000000000000;;		activeStreams map[uint32]*Stream
0000000000000000000000000000000000000000;;		// The max number of concurrent streams
0000000000000000000000000000000000000000;;		maxStreams int
0000000000000000000000000000000000000000;;		// the per-stream outbound flow control window size set by the peer.
0000000000000000000000000000000000000000;;		streamSendQuota uint32
0000000000000000000000000000000000000000;;		// goAwayID records the Last-Stream-ID in the GoAway frame from the server.
0000000000000000000000000000000000000000;;		goAwayID uint32
0000000000000000000000000000000000000000;;		// prevGoAway ID records the Last-Stream-ID in the previous GOAway frame.
0000000000000000000000000000000000000000;;		prevGoAwayID uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dial(ctx context.Context, fn func(context.Context, string) (net.Conn, error), addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		if fn != nil {
0000000000000000000000000000000000000000;;			return fn(ctx, addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dialContext(ctx, "tcp", addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isTemporary(err error) bool {
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case io.EOF:
0000000000000000000000000000000000000000;;			// Connection closures may be resolved upon retry, and are thus
0000000000000000000000000000000000000000;;			// treated as temporary.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case context.DeadlineExceeded:
0000000000000000000000000000000000000000;;			// In Go 1.7, context.DeadlineExceeded implements Timeout(), and this
0000000000000000000000000000000000000000;;			// special case is not needed. Until then, we need to keep this
0000000000000000000000000000000000000000;;			// clause.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch err := err.(type) {
0000000000000000000000000000000000000000;;		case interface {
0000000000000000000000000000000000000000;;			Temporary() bool
0000000000000000000000000000000000000000;;		}:
0000000000000000000000000000000000000000;;			return err.Temporary()
0000000000000000000000000000000000000000;;		case interface {
0000000000000000000000000000000000000000;;			Timeout() bool
0000000000000000000000000000000000000000;;		}:
0000000000000000000000000000000000000000;;			// Timeouts may be resolved upon retry, and are thus treated as
0000000000000000000000000000000000000000;;			// temporary.
0000000000000000000000000000000000000000;;			return err.Timeout()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newHTTP2Client constructs a connected ClientTransport to addr based on HTTP2
0000000000000000000000000000000000000000;;	// and starts to receive messages on it. Non-nil error returns if construction
0000000000000000000000000000000000000000;;	// fails.
0000000000000000000000000000000000000000;;	func newHTTP2Client(ctx context.Context, addr TargetInfo, opts ConnectOptions) (_ ClientTransport, err error) {
0000000000000000000000000000000000000000;;		scheme := "http"
0000000000000000000000000000000000000000;;		conn, err := dial(ctx, opts.Dialer, addr.Addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Any further errors will close the underlying connection
0000000000000000000000000000000000000000;;		defer func(conn net.Conn) {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				conn.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}(conn)
0000000000000000000000000000000000000000;;		var authInfo credentials.AuthInfo
0000000000000000000000000000000000000000;;		if creds := opts.TransportCredentials; creds != nil {
0000000000000000000000000000000000000000;;			scheme = "https"
0000000000000000000000000000000000000000;;			conn, authInfo, err = creds.ClientHandshake(ctx, addr.Addr, conn)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Credentials handshake errors are typically considered permanent
0000000000000000000000000000000000000000;;				// to avoid retrying on e.g. bad certificates.
0000000000000000000000000000000000000000;;				temp := isTemporary(err)
0000000000000000000000000000000000000000;;				return nil, connectionErrorf(temp, err, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ua := primaryUA
0000000000000000000000000000000000000000;;		if opts.UserAgent != "" {
0000000000000000000000000000000000000000;;			ua = opts.UserAgent + " " + ua
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		t := &http2Client{
0000000000000000000000000000000000000000;;			target:    addr.Addr,
0000000000000000000000000000000000000000;;			userAgent: ua,
0000000000000000000000000000000000000000;;			md:        addr.Metadata,
0000000000000000000000000000000000000000;;			conn:      conn,
0000000000000000000000000000000000000000;;			authInfo:  authInfo,
0000000000000000000000000000000000000000;;			// The client initiated stream id is odd starting from 1.
0000000000000000000000000000000000000000;;			nextID:          1,
0000000000000000000000000000000000000000;;			writableChan:    make(chan int, 1),
0000000000000000000000000000000000000000;;			shutdownChan:    make(chan struct{}),
0000000000000000000000000000000000000000;;			errorChan:       make(chan struct{}),
0000000000000000000000000000000000000000;;			goAway:          make(chan struct{}),
0000000000000000000000000000000000000000;;			framer:          newFramer(conn),
0000000000000000000000000000000000000000;;			hBuf:            &buf,
0000000000000000000000000000000000000000;;			hEnc:            hpack.NewEncoder(&buf),
0000000000000000000000000000000000000000;;			controlBuf:      newRecvBuffer(),
0000000000000000000000000000000000000000;;			fc:              &inFlow{limit: initialConnWindowSize},
0000000000000000000000000000000000000000;;			sendQuotaPool:   newQuotaPool(defaultWindowSize),
0000000000000000000000000000000000000000;;			scheme:          scheme,
0000000000000000000000000000000000000000;;			state:           reachable,
0000000000000000000000000000000000000000;;			activeStreams:   make(map[uint32]*Stream),
0000000000000000000000000000000000000000;;			creds:           opts.PerRPCCredentials,
0000000000000000000000000000000000000000;;			maxStreams:      math.MaxInt32,
0000000000000000000000000000000000000000;;			streamSendQuota: defaultWindowSize,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Start the reader goroutine for incoming message. Each transport has
0000000000000000000000000000000000000000;;		// a dedicated goroutine which reads HTTP2 frame from network. Then it
0000000000000000000000000000000000000000;;		// dispatches the frame to the corresponding stream entity.
0000000000000000000000000000000000000000;;		go t.reader()
0000000000000000000000000000000000000000;;		// Send connection preface to server.
0000000000000000000000000000000000000000;;		n, err := t.conn.Write(clientPreface)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return nil, connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != len(clientPreface) {
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return nil, connectionErrorf(true, err, "transport: preface mismatch, wrote %d bytes; want %d", n, len(clientPreface))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if initialWindowSize != defaultWindowSize {
0000000000000000000000000000000000000000;;			err = t.framer.writeSettings(true, http2.Setting{
0000000000000000000000000000000000000000;;				ID:  http2.SettingInitialWindowSize,
0000000000000000000000000000000000000000;;				Val: uint32(initialWindowSize),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = t.framer.writeSettings(true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return nil, connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Adjust the connection flow control window if needed.
0000000000000000000000000000000000000000;;		if delta := uint32(initialConnWindowSize - defaultWindowSize); delta > 0 {
0000000000000000000000000000000000000000;;			if err := t.framer.writeWindowUpdate(true, 0, delta); err != nil {
0000000000000000000000000000000000000000;;				t.Close()
0000000000000000000000000000000000000000;;				return nil, connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go t.controller()
0000000000000000000000000000000000000000;;		t.writableChan <- 0
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) newStream(ctx context.Context, callHdr *CallHdr) *Stream {
0000000000000000000000000000000000000000;;		// TODO(zhaoq): Handle uint32 overflow of Stream.id.
0000000000000000000000000000000000000000;;		s := &Stream{
0000000000000000000000000000000000000000;;			id:            t.nextID,
0000000000000000000000000000000000000000;;			done:          make(chan struct{}),
0000000000000000000000000000000000000000;;			goAway:        make(chan struct{}),
0000000000000000000000000000000000000000;;			method:        callHdr.Method,
0000000000000000000000000000000000000000;;			sendCompress:  callHdr.SendCompress,
0000000000000000000000000000000000000000;;			buf:           newRecvBuffer(),
0000000000000000000000000000000000000000;;			fc:            &inFlow{limit: initialWindowSize},
0000000000000000000000000000000000000000;;			sendQuotaPool: newQuotaPool(int(t.streamSendQuota)),
0000000000000000000000000000000000000000;;			headerChan:    make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.nextID += 2
0000000000000000000000000000000000000000;;		s.windowHandler = func(n int) {
0000000000000000000000000000000000000000;;			t.updateWindow(s, uint32(n))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The client side stream context should have exactly the same life cycle with the user provided context.
0000000000000000000000000000000000000000;;		// That means, s.ctx should be read-only. And s.ctx is done iff ctx is done.
0000000000000000000000000000000000000000;;		// So we use the original context here instead of creating a copy.
0000000000000000000000000000000000000000;;		s.ctx = ctx
0000000000000000000000000000000000000000;;		s.dec = &recvBufferReader{
0000000000000000000000000000000000000000;;			ctx:    s.ctx,
0000000000000000000000000000000000000000;;			goAway: s.goAway,
0000000000000000000000000000000000000000;;			recv:   s.buf,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStream creates a stream and register it into the transport as "active"
0000000000000000000000000000000000000000;;	// streams.
0000000000000000000000000000000000000000;;	func (t *http2Client) NewStream(ctx context.Context, callHdr *CallHdr) (_ *Stream, err error) {
0000000000000000000000000000000000000000;;		pr := &peer.Peer{
0000000000000000000000000000000000000000;;			Addr: t.conn.RemoteAddr(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Attach Auth info if there is any.
0000000000000000000000000000000000000000;;		if t.authInfo != nil {
0000000000000000000000000000000000000000;;			pr.AuthInfo = t.authInfo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx = peer.NewContext(ctx, pr)
0000000000000000000000000000000000000000;;		authData := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, c := range t.creds {
0000000000000000000000000000000000000000;;			// Construct URI required to get auth request metadata.
0000000000000000000000000000000000000000;;			var port string
0000000000000000000000000000000000000000;;			if pos := strings.LastIndex(t.target, ":"); pos != -1 {
0000000000000000000000000000000000000000;;				// Omit port if it is the default one.
0000000000000000000000000000000000000000;;				if t.target[pos+1:] != "443" {
0000000000000000000000000000000000000000;;					port = ":" + t.target[pos+1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos := strings.LastIndex(callHdr.Method, "/")
0000000000000000000000000000000000000000;;			if pos == -1 {
0000000000000000000000000000000000000000;;				return nil, streamErrorf(codes.InvalidArgument, "transport: malformed method name: %q", callHdr.Method)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			audience := "https://" + callHdr.Host + port + callHdr.Method[:pos]
0000000000000000000000000000000000000000;;			data, err := c.GetRequestMetadata(ctx, audience)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, streamErrorf(codes.InvalidArgument, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range data {
0000000000000000000000000000000000000000;;				authData[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		if t.activeStreams == nil {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, ErrConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.state == draining {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, ErrStreamDrain
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.state != reachable {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, ErrConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		checkStreamsQuota := t.streamsQuota != nil
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		if checkStreamsQuota {
0000000000000000000000000000000000000000;;			sq, err := wait(ctx, nil, nil, t.shutdownChan, t.streamsQuota.acquire())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Returns the quota balance back.
0000000000000000000000000000000000000000;;			if sq > 1 {
0000000000000000000000000000000000000000;;				t.streamsQuota.add(sq - 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := wait(ctx, nil, nil, t.shutdownChan, t.writableChan); err != nil {
0000000000000000000000000000000000000000;;			// Return the quota back now because there is no stream returned to the caller.
0000000000000000000000000000000000000000;;			if _, ok := err.(StreamError); ok && checkStreamsQuota {
0000000000000000000000000000000000000000;;				t.streamsQuota.add(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		if t.state == draining {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			if checkStreamsQuota {
0000000000000000000000000000000000000000;;				t.streamsQuota.add(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Need to make t writable again so that the rpc in flight can still proceed.
0000000000000000000000000000000000000000;;			t.writableChan <- 0
0000000000000000000000000000000000000000;;			return nil, ErrStreamDrain
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.state != reachable {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, ErrConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := t.newStream(ctx, callHdr)
0000000000000000000000000000000000000000;;		t.activeStreams[s.id] = s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This stream is not counted when applySetings(...) initialize t.streamsQuota.
0000000000000000000000000000000000000000;;		// Reset t.streamsQuota to the right value.
0000000000000000000000000000000000000000;;		var reset bool
0000000000000000000000000000000000000000;;		if !checkStreamsQuota && t.streamsQuota != nil {
0000000000000000000000000000000000000000;;			reset = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		if reset {
0000000000000000000000000000000000000000;;			t.streamsQuota.reset(-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HPACK encodes various headers. Note that once WriteField(...) is
0000000000000000000000000000000000000000;;		// called, the corresponding headers/continuation frame has to be sent
0000000000000000000000000000000000000000;;		// because hpack.Encoder is stateful.
0000000000000000000000000000000000000000;;		t.hBuf.Reset()
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: ":method", Value: "POST"})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: ":scheme", Value: t.scheme})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: ":path", Value: callHdr.Method})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: ":authority", Value: callHdr.Host})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: "content-type", Value: "application/grpc"})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: "user-agent", Value: t.userAgent})
0000000000000000000000000000000000000000;;		t.hEnc.WriteField(hpack.HeaderField{Name: "te", Value: "trailers"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if callHdr.SendCompress != "" {
0000000000000000000000000000000000000000;;			t.hEnc.WriteField(hpack.HeaderField{Name: "grpc-encoding", Value: callHdr.SendCompress})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dl, ok := ctx.Deadline(); ok {
0000000000000000000000000000000000000000;;			// Send out timeout regardless its value. The server can detect timeout context by itself.
0000000000000000000000000000000000000000;;			timeout := dl.Sub(time.Now())
0000000000000000000000000000000000000000;;			t.hEnc.WriteField(hpack.HeaderField{Name: "grpc-timeout", Value: encodeTimeout(timeout)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range authData {
0000000000000000000000000000000000000000;;			// Capital header names are illegal in HTTP/2.
0000000000000000000000000000000000000000;;			k = strings.ToLower(k)
0000000000000000000000000000000000000000;;			t.hEnc.WriteField(hpack.HeaderField{Name: k, Value: v})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			hasMD      bool
0000000000000000000000000000000000000000;;			endHeaders bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if md, ok := metadata.FromContext(ctx); ok {
0000000000000000000000000000000000000000;;			hasMD = true
0000000000000000000000000000000000000000;;			for k, v := range md {
0000000000000000000000000000000000000000;;				// HTTP doesn't allow you to set pseudoheaders after non pseudoheaders were set.
0000000000000000000000000000000000000000;;				if isReservedHeader(k) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, entry := range v {
0000000000000000000000000000000000000000;;					t.hEnc.WriteField(hpack.HeaderField{Name: k, Value: entry})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if md, ok := t.md.(*metadata.MD); ok {
0000000000000000000000000000000000000000;;			for k, v := range *md {
0000000000000000000000000000000000000000;;				if isReservedHeader(k) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, entry := range v {
0000000000000000000000000000000000000000;;					t.hEnc.WriteField(hpack.HeaderField{Name: k, Value: entry})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		// Sends the headers in a single batch even when they span multiple frames.
0000000000000000000000000000000000000000;;		for !endHeaders {
0000000000000000000000000000000000000000;;			size := t.hBuf.Len()
0000000000000000000000000000000000000000;;			if size > http2MaxFrameLen {
0000000000000000000000000000000000000000;;				size = http2MaxFrameLen
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				endHeaders = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var flush bool
0000000000000000000000000000000000000000;;			if endHeaders && (hasMD || callHdr.Flush) {
0000000000000000000000000000000000000000;;				flush = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				// Sends a HeadersFrame to server to start a new stream.
0000000000000000000000000000000000000000;;				p := http2.HeadersFrameParam{
0000000000000000000000000000000000000000;;					StreamID:      s.id,
0000000000000000000000000000000000000000;;					BlockFragment: t.hBuf.Next(size),
0000000000000000000000000000000000000000;;					EndStream:     false,
0000000000000000000000000000000000000000;;					EndHeaders:    endHeaders,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Do a force flush for the buffered frames iff it is the last headers frame
0000000000000000000000000000000000000000;;				// and there is header metadata to be sent. Otherwise, there is flushing until
0000000000000000000000000000000000000000;;				// the corresponding data frame is written.
0000000000000000000000000000000000000000;;				err = t.framer.writeHeaders(flush, p)
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Sends Continuation frames for the leftover headers.
0000000000000000000000000000000000000000;;				err = t.framer.writeContinuation(flush, s.id, endHeaders, t.hBuf.Next(size))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.notifyError(err)
0000000000000000000000000000000000000000;;				return nil, connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.writableChan <- 0
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseStream clears the footprint of a stream when the stream is not needed any more.
0000000000000000000000000000000000000000;;	// This must not be executed in reader's goroutine.
0000000000000000000000000000000000000000;;	func (t *http2Client) CloseStream(s *Stream, err error) {
0000000000000000000000000000000000000000;;		var updateStreams bool
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		if t.activeStreams == nil {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.streamsQuota != nil {
0000000000000000000000000000000000000000;;			updateStreams = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(t.activeStreams, s.id)
0000000000000000000000000000000000000000;;		if t.state == draining && len(t.activeStreams) == 0 {
0000000000000000000000000000000000000000;;			// The transport is draining and s is the last live stream on t.
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		if updateStreams {
0000000000000000000000000000000000000000;;			t.streamsQuota.add(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if q := s.fc.resetPendingData(); q > 0 {
0000000000000000000000000000000000000000;;			if n := t.fc.onRead(q); n > 0 {
0000000000000000000000000000000000000000;;				t.controlBuf.put(&windowUpdate{0, n})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.state == streamDone {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.headerDone {
0000000000000000000000000000000000000000;;			close(s.headerChan)
0000000000000000000000000000000000000000;;			s.headerDone = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.state = streamDone
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		if se, ok := err.(StreamError); ok && se.Code != codes.DeadlineExceeded {
0000000000000000000000000000000000000000;;			t.controlBuf.put(&resetStream{s.id, http2.ErrCodeCancel})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close kicks off the shutdown process of the transport. This should be called
0000000000000000000000000000000000000000;;	// only once on a transport. Once it is called, the transport should not be
0000000000000000000000000000000000000000;;	// accessed any more.
0000000000000000000000000000000000000000;;	func (t *http2Client) Close() (err error) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		if t.state == closing {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.state == reachable || t.state == draining {
0000000000000000000000000000000000000000;;			close(t.errorChan)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.state = closing
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		close(t.shutdownChan)
0000000000000000000000000000000000000000;;		err = t.conn.Close()
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		streams := t.activeStreams
0000000000000000000000000000000000000000;;		t.activeStreams = nil
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		// Notify all active streams.
0000000000000000000000000000000000000000;;		for _, s := range streams {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			if !s.headerDone {
0000000000000000000000000000000000000000;;				close(s.headerChan)
0000000000000000000000000000000000000000;;				s.headerDone = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			s.write(recvMsg{err: ErrConnClosing})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) GracefulClose() error {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		switch t.state {
0000000000000000000000000000000000000000;;		case unreachable:
0000000000000000000000000000000000000000;;			// The server may close the connection concurrently. t is not available for
0000000000000000000000000000000000000000;;			// any streams. Close it now.
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case closing:
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Notify the streams which were initiated after the server sent GOAWAY.
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-t.goAway:
0000000000000000000000000000000000000000;;			n := t.prevGoAwayID
0000000000000000000000000000000000000000;;			if n == 0 && t.nextID > 1 {
0000000000000000000000000000000000000000;;				n = t.nextID - 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m := t.goAwayID + 2
0000000000000000000000000000000000000000;;			if m == 2 {
0000000000000000000000000000000000000000;;				m = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := m; i <= n; i += 2 {
0000000000000000000000000000000000000000;;				if s, ok := t.activeStreams[i]; ok {
0000000000000000000000000000000000000000;;					close(s.goAway)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.state == draining {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.state = draining
0000000000000000000000000000000000000000;;		active := len(t.activeStreams)
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		if active == 0 {
0000000000000000000000000000000000000000;;			return t.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write formats the data into HTTP2 data frame(s) and sends it out. The caller
0000000000000000000000000000000000000000;;	// should proceed only if Write returns nil.
0000000000000000000000000000000000000000;;	// TODO(zhaoq): opts.Delay is ignored in this implementation. Support it later
0000000000000000000000000000000000000000;;	// if it improves the performance.
0000000000000000000000000000000000000000;;	func (t *http2Client) Write(s *Stream, data []byte, opts *Options) error {
0000000000000000000000000000000000000000;;		r := bytes.NewBuffer(data)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var p []byte
0000000000000000000000000000000000000000;;			if r.Len() > 0 {
0000000000000000000000000000000000000000;;				size := http2MaxFrameLen
0000000000000000000000000000000000000000;;				s.sendQuotaPool.add(0)
0000000000000000000000000000000000000000;;				// Wait until the stream has some quota to send the data.
0000000000000000000000000000000000000000;;				sq, err := wait(s.ctx, s.done, s.goAway, t.shutdownChan, s.sendQuotaPool.acquire())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.sendQuotaPool.add(0)
0000000000000000000000000000000000000000;;				// Wait until the transport has some quota to send the data.
0000000000000000000000000000000000000000;;				tq, err := wait(s.ctx, s.done, s.goAway, t.shutdownChan, t.sendQuotaPool.acquire())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if _, ok := err.(StreamError); ok || err == io.EOF {
0000000000000000000000000000000000000000;;						t.sendQuotaPool.cancel()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sq < size {
0000000000000000000000000000000000000000;;					size = sq
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tq < size {
0000000000000000000000000000000000000000;;					size = tq
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p = r.Next(size)
0000000000000000000000000000000000000000;;				ps := len(p)
0000000000000000000000000000000000000000;;				if ps < sq {
0000000000000000000000000000000000000000;;					// Overbooked stream quota. Return it back.
0000000000000000000000000000000000000000;;					s.sendQuotaPool.add(sq - ps)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ps < tq {
0000000000000000000000000000000000000000;;					// Overbooked transport quota. Return it back.
0000000000000000000000000000000000000000;;					t.sendQuotaPool.add(tq - ps)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				endStream  bool
0000000000000000000000000000000000000000;;				forceFlush bool
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if opts.Last && r.Len() == 0 {
0000000000000000000000000000000000000000;;				endStream = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Indicate there is a writer who is about to write a data frame.
0000000000000000000000000000000000000000;;			t.framer.adjustNumWriters(1)
0000000000000000000000000000000000000000;;			// Got some quota. Try to acquire writing privilege on the transport.
0000000000000000000000000000000000000000;;			if _, err := wait(s.ctx, s.done, s.goAway, t.shutdownChan, t.writableChan); err != nil {
0000000000000000000000000000000000000000;;				if _, ok := err.(StreamError); ok || err == io.EOF {
0000000000000000000000000000000000000000;;					// Return the connection quota back.
0000000000000000000000000000000000000000;;					t.sendQuotaPool.add(len(p))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if t.framer.adjustNumWriters(-1) == 0 {
0000000000000000000000000000000000000000;;					// This writer is the last one in this batch and has the
0000000000000000000000000000000000000000;;					// responsibility to flush the buffered frames. It queues
0000000000000000000000000000000000000000;;					// a flush request to controlBuf instead of flushing directly
0000000000000000000000000000000000000000;;					// in order to avoid the race with other writing or flushing.
0000000000000000000000000000000000000000;;					t.controlBuf.put(&flushIO{})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-s.ctx.Done():
0000000000000000000000000000000000000000;;				t.sendQuotaPool.add(len(p))
0000000000000000000000000000000000000000;;				if t.framer.adjustNumWriters(-1) == 0 {
0000000000000000000000000000000000000000;;					t.controlBuf.put(&flushIO{})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.writableChan <- 0
0000000000000000000000000000000000000000;;				return ContextErr(s.ctx.Err())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.Len() == 0 && t.framer.adjustNumWriters(0) == 1 {
0000000000000000000000000000000000000000;;				// Do a force flush iff this is last frame for the entire gRPC message
0000000000000000000000000000000000000000;;				// and the caller is the only writer at this moment.
0000000000000000000000000000000000000000;;				forceFlush = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If WriteData fails, all the pending streams will be handled
0000000000000000000000000000000000000000;;			// by http2Client.Close(). No explicit CloseStream() needs to be
0000000000000000000000000000000000000000;;			// invoked.
0000000000000000000000000000000000000000;;			if err := t.framer.writeData(forceFlush, s.id, endStream, p); err != nil {
0000000000000000000000000000000000000000;;				t.notifyError(err)
0000000000000000000000000000000000000000;;				return connectionErrorf(true, err, "transport: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.framer.adjustNumWriters(-1) == 0 {
0000000000000000000000000000000000000000;;				t.framer.flushWrite()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.writableChan <- 0
0000000000000000000000000000000000000000;;			if r.Len() == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !opts.Last {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if s.state != streamDone {
0000000000000000000000000000000000000000;;			s.state = streamWriteDone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) getStream(f http2.Frame) (*Stream, bool) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		s, ok := t.activeStreams[f.Header().StreamID]
0000000000000000000000000000000000000000;;		return s, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateWindow adjusts the inbound quota for the stream and the transport.
0000000000000000000000000000000000000000;;	// Window updates will deliver to the controller for sending when
0000000000000000000000000000000000000000;;	// the cumulative quota exceeds the corresponding threshold.
0000000000000000000000000000000000000000;;	func (t *http2Client) updateWindow(s *Stream, n uint32) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if s.state == streamDone {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w := t.fc.onRead(n); w > 0 {
0000000000000000000000000000000000000000;;			t.controlBuf.put(&windowUpdate{0, w})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w := s.fc.onRead(n); w > 0 {
0000000000000000000000000000000000000000;;			t.controlBuf.put(&windowUpdate{s.id, w})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) handleData(f *http2.DataFrame) {
0000000000000000000000000000000000000000;;		size := len(f.Data())
0000000000000000000000000000000000000000;;		if err := t.fc.onData(uint32(size)); err != nil {
0000000000000000000000000000000000000000;;			t.notifyError(connectionErrorf(true, err, "%v", err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Select the right stream to dispatch.
0000000000000000000000000000000000000000;;		s, ok := t.getStream(f)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if w := t.fc.onRead(uint32(size)); w > 0 {
0000000000000000000000000000000000000000;;				t.controlBuf.put(&windowUpdate{0, w})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if size > 0 {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			if s.state == streamDone {
0000000000000000000000000000000000000000;;				s.mu.Unlock()
0000000000000000000000000000000000000000;;				// The stream has been closed. Release the corresponding quota.
0000000000000000000000000000000000000000;;				if w := t.fc.onRead(uint32(size)); w > 0 {
0000000000000000000000000000000000000000;;					t.controlBuf.put(&windowUpdate{0, w})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := s.fc.onData(uint32(size)); err != nil {
0000000000000000000000000000000000000000;;				s.state = streamDone
0000000000000000000000000000000000000000;;				s.statusCode = codes.Internal
0000000000000000000000000000000000000000;;				s.statusDesc = err.Error()
0000000000000000000000000000000000000000;;				close(s.done)
0000000000000000000000000000000000000000;;				s.mu.Unlock()
0000000000000000000000000000000000000000;;				s.write(recvMsg{err: io.EOF})
0000000000000000000000000000000000000000;;				t.controlBuf.put(&resetStream{s.id, http2.ErrCodeFlowControl})
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			// TODO(bradfitz, zhaoq): A copy is required here because there is no
0000000000000000000000000000000000000000;;			// guarantee f.Data() is consumed before the arrival of next frame.
0000000000000000000000000000000000000000;;			// Can this copy be eliminated?
0000000000000000000000000000000000000000;;			data := make([]byte, size)
0000000000000000000000000000000000000000;;			copy(data, f.Data())
0000000000000000000000000000000000000000;;			s.write(recvMsg{data: data})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The server has closed the stream without sending trailers.  Record that
0000000000000000000000000000000000000000;;		// the read direction is closed, and set the status appropriately.
0000000000000000000000000000000000000000;;		if f.FrameHeader.Flags.Has(http2.FlagDataEndStream) {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			if s.state == streamDone {
0000000000000000000000000000000000000000;;				s.mu.Unlock()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.state = streamDone
0000000000000000000000000000000000000000;;			s.statusCode = codes.Internal
0000000000000000000000000000000000000000;;			s.statusDesc = "server closed the stream without sending trailers"
0000000000000000000000000000000000000000;;			close(s.done)
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			s.write(recvMsg{err: io.EOF})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) handleRSTStream(f *http2.RSTStreamFrame) {
0000000000000000000000000000000000000000;;		s, ok := t.getStream(f)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if s.state == streamDone {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.state = streamDone
0000000000000000000000000000000000000000;;		if !s.headerDone {
0000000000000000000000000000000000000000;;			close(s.headerChan)
0000000000000000000000000000000000000000;;			s.headerDone = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.statusCode, ok = http2ErrConvTab[http2.ErrCode(f.ErrCode)]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			grpclog.Println("transport: http2Client.handleRSTStream found no mapped gRPC status for the received http2 error ", f.ErrCode)
0000000000000000000000000000000000000000;;			s.statusCode = codes.Unknown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.statusDesc = fmt.Sprintf("stream terminated by RST_STREAM with error code: %d", f.ErrCode)
0000000000000000000000000000000000000000;;		close(s.done)
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		s.write(recvMsg{err: io.EOF})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) handleSettings(f *http2.SettingsFrame) {
0000000000000000000000000000000000000000;;		if f.IsAck() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ss []http2.Setting
0000000000000000000000000000000000000000;;		f.ForeachSetting(func(s http2.Setting) error {
0000000000000000000000000000000000000000;;			ss = append(ss, s)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// The settings will be applied once the ack is sent.
0000000000000000000000000000000000000000;;		t.controlBuf.put(&settings{ack: true, ss: ss})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) handlePing(f *http2.PingFrame) {
0000000000000000000000000000000000000000;;		if f.IsAck() { // Do nothing.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pingAck := &ping{ack: true}
0000000000000000000000000000000000000000;;		copy(pingAck.data[:], f.Data[:])
0000000000000000000000000000000000000000;;		t.controlBuf.put(pingAck)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) handleGoAway(f *http2.GoAwayFrame) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		if t.state == reachable || t.state == draining {
0000000000000000000000000000000000000000;;			if f.LastStreamID > 0 && f.LastStreamID%2 != 1 {
0000000000000000000000000000000000000000;;				t.mu.Unlock()
0000000000000000000000000000000000000000;;				t.notifyError(connectionErrorf(true, nil, "received illegal http2 GOAWAY frame: stream ID %d is even", f.LastStreamID))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-t.goAway:
0000000000000000000000000000000000000000;;				id := t.goAwayID
0000000000000000000000000000000000000000;;				// t.goAway has been closed (i.e.,multiple GoAways).
0000000000000000000000000000000000000000;;				if id < f.LastStreamID {
0000000000000000000000000000000000000000;;					t.mu.Unlock()
0000000000000000000000000000000000000000;;					t.notifyError(connectionErrorf(true, nil, "received illegal http2 GOAWAY frame: previously recv GOAWAY frame with LastStramID %d, currently recv %d", id, f.LastStreamID))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.prevGoAwayID = id
0000000000000000000000000000000000000000;;				t.goAwayID = f.LastStreamID
0000000000000000000000000000000000000000;;				t.mu.Unlock()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.goAwayID = f.LastStreamID
0000000000000000000000000000000000000000;;			close(t.goAway)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) handleWindowUpdate(f *http2.WindowUpdateFrame) {
0000000000000000000000000000000000000000;;		id := f.Header().StreamID
0000000000000000000000000000000000000000;;		incr := f.Increment
0000000000000000000000000000000000000000;;		if id == 0 {
0000000000000000000000000000000000000000;;			t.sendQuotaPool.add(int(incr))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s, ok := t.getStream(f); ok {
0000000000000000000000000000000000000000;;			s.sendQuotaPool.add(int(incr))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// operateHeaders takes action on the decoded headers.
0000000000000000000000000000000000000000;;	func (t *http2Client) operateHeaders(frame *http2.MetaHeadersFrame) {
0000000000000000000000000000000000000000;;		s, ok := t.getStream(frame)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var state decodeState
0000000000000000000000000000000000000000;;		for _, hf := range frame.Fields {
0000000000000000000000000000000000000000;;			state.processHeaderField(hf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if state.err != nil {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			if !s.headerDone {
0000000000000000000000000000000000000000;;				close(s.headerChan)
0000000000000000000000000000000000000000;;				s.headerDone = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			s.write(recvMsg{err: state.err})
0000000000000000000000000000000000000000;;			// Something wrong. Stops reading even when there is remaining.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endStream := frame.StreamEnded()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if !endStream {
0000000000000000000000000000000000000000;;			s.recvCompress = state.encoding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.headerDone {
0000000000000000000000000000000000000000;;			if !endStream && len(state.mdata) > 0 {
0000000000000000000000000000000000000000;;				s.header = state.mdata
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(s.headerChan)
0000000000000000000000000000000000000000;;			s.headerDone = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !endStream || s.state == streamDone {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(state.mdata) > 0 {
0000000000000000000000000000000000000000;;			s.trailer = state.mdata
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.statusCode = state.statusCode
0000000000000000000000000000000000000000;;		s.statusDesc = state.statusDesc
0000000000000000000000000000000000000000;;		close(s.done)
0000000000000000000000000000000000000000;;		s.state = streamDone
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		s.write(recvMsg{err: io.EOF})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleMalformedHTTP2(s *Stream, err error) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if !s.headerDone {
0000000000000000000000000000000000000000;;			close(s.headerChan)
0000000000000000000000000000000000000000;;			s.headerDone = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		s.write(recvMsg{err: err})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reader runs as a separate goroutine in charge of reading data from network
0000000000000000000000000000000000000000;;	// connection.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(zhaoq): currently one reader per transport. Investigate whether this is
0000000000000000000000000000000000000000;;	// optimal.
0000000000000000000000000000000000000000;;	// TODO(zhaoq): Check the validity of the incoming frame sequence.
0000000000000000000000000000000000000000;;	func (t *http2Client) reader() {
0000000000000000000000000000000000000000;;		// Check the validity of server preface.
0000000000000000000000000000000000000000;;		frame, err := t.framer.readFrame()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.notifyError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sf, ok := frame.(*http2.SettingsFrame)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.notifyError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.handleSettings(sf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// loop to keep reading incoming messages on this transport.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			frame, err := t.framer.readFrame()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Abort an active stream if the http2.Framer returns a
0000000000000000000000000000000000000000;;				// http2.StreamError. This can happen only if the server's response
0000000000000000000000000000000000000000;;				// is malformed http2.
0000000000000000000000000000000000000000;;				if se, ok := err.(http2.StreamError); ok {
0000000000000000000000000000000000000000;;					t.mu.Lock()
0000000000000000000000000000000000000000;;					s := t.activeStreams[se.StreamID]
0000000000000000000000000000000000000000;;					t.mu.Unlock()
0000000000000000000000000000000000000000;;					if s != nil {
0000000000000000000000000000000000000000;;						// use error detail to provide better err message
0000000000000000000000000000000000000000;;						handleMalformedHTTP2(s, streamErrorf(http2ErrConvTab[se.Code], "%v", t.framer.errorDetail()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Transport error.
0000000000000000000000000000000000000000;;					t.notifyError(err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch frame := frame.(type) {
0000000000000000000000000000000000000000;;			case *http2.MetaHeadersFrame:
0000000000000000000000000000000000000000;;				t.operateHeaders(frame)
0000000000000000000000000000000000000000;;			case *http2.DataFrame:
0000000000000000000000000000000000000000;;				t.handleData(frame)
0000000000000000000000000000000000000000;;			case *http2.RSTStreamFrame:
0000000000000000000000000000000000000000;;				t.handleRSTStream(frame)
0000000000000000000000000000000000000000;;			case *http2.SettingsFrame:
0000000000000000000000000000000000000000;;				t.handleSettings(frame)
0000000000000000000000000000000000000000;;			case *http2.PingFrame:
0000000000000000000000000000000000000000;;				t.handlePing(frame)
0000000000000000000000000000000000000000;;			case *http2.GoAwayFrame:
0000000000000000000000000000000000000000;;				t.handleGoAway(frame)
0000000000000000000000000000000000000000;;			case *http2.WindowUpdateFrame:
0000000000000000000000000000000000000000;;				t.handleWindowUpdate(frame)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				grpclog.Printf("transport: http2Client.reader got unhandled frame type %v.", frame)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) applySettings(ss []http2.Setting) {
0000000000000000000000000000000000000000;;		for _, s := range ss {
0000000000000000000000000000000000000000;;			switch s.ID {
0000000000000000000000000000000000000000;;			case http2.SettingMaxConcurrentStreams:
0000000000000000000000000000000000000000;;				// TODO(zhaoq): This is a hack to avoid significant refactoring of the
0000000000000000000000000000000000000000;;				// code to deal with the unrealistic int32 overflow. Probably will try
0000000000000000000000000000000000000000;;				// to find a better way to handle this later.
0000000000000000000000000000000000000000;;				if s.Val > math.MaxInt32 {
0000000000000000000000000000000000000000;;					s.Val = math.MaxInt32
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.mu.Lock()
0000000000000000000000000000000000000000;;				reset := t.streamsQuota != nil
0000000000000000000000000000000000000000;;				if !reset {
0000000000000000000000000000000000000000;;					t.streamsQuota = newQuotaPool(int(s.Val) - len(t.activeStreams))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ms := t.maxStreams
0000000000000000000000000000000000000000;;				t.maxStreams = int(s.Val)
0000000000000000000000000000000000000000;;				t.mu.Unlock()
0000000000000000000000000000000000000000;;				if reset {
0000000000000000000000000000000000000000;;					t.streamsQuota.reset(int(s.Val) - ms)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case http2.SettingInitialWindowSize:
0000000000000000000000000000000000000000;;				t.mu.Lock()
0000000000000000000000000000000000000000;;				for _, stream := range t.activeStreams {
0000000000000000000000000000000000000000;;					// Adjust the sending quota for each stream.
0000000000000000000000000000000000000000;;					stream.sendQuotaPool.reset(int(s.Val - t.streamSendQuota))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.streamSendQuota = s.Val
0000000000000000000000000000000000000000;;				t.mu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// controller running in a separate goroutine takes charge of sending control
0000000000000000000000000000000000000000;;	// frames (e.g., window update, reset stream, setting, etc.) to the server.
0000000000000000000000000000000000000000;;	func (t *http2Client) controller() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case i := <-t.controlBuf.get():
0000000000000000000000000000000000000000;;				t.controlBuf.load()
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-t.writableChan:
0000000000000000000000000000000000000000;;					switch i := i.(type) {
0000000000000000000000000000000000000000;;					case *windowUpdate:
0000000000000000000000000000000000000000;;						t.framer.writeWindowUpdate(true, i.streamID, i.increment)
0000000000000000000000000000000000000000;;					case *settings:
0000000000000000000000000000000000000000;;						if i.ack {
0000000000000000000000000000000000000000;;							t.framer.writeSettingsAck(true)
0000000000000000000000000000000000000000;;							t.applySettings(i.ss)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							t.framer.writeSettings(true, i.ss...)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case *resetStream:
0000000000000000000000000000000000000000;;						t.framer.writeRSTStream(true, i.streamID, i.code)
0000000000000000000000000000000000000000;;					case *flushIO:
0000000000000000000000000000000000000000;;						t.framer.flushWrite()
0000000000000000000000000000000000000000;;					case *ping:
0000000000000000000000000000000000000000;;						t.framer.writePing(true, i.ack, i.data)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						grpclog.Printf("transport: http2Client.controller got unexpected item type %v\n", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t.writableChan <- 0
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case <-t.shutdownChan:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-t.shutdownChan:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) Error() <-chan struct{} {
0000000000000000000000000000000000000000;;		return t.errorChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) GoAway() <-chan struct{} {
0000000000000000000000000000000000000000;;		return t.goAway
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *http2Client) notifyError(err error) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		// make sure t.errorChan is closed only once.
0000000000000000000000000000000000000000;;		if t.state == draining {
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			t.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.state == reachable {
0000000000000000000000000000000000000000;;			t.state = unreachable
0000000000000000000000000000000000000000;;			close(t.errorChan)
0000000000000000000000000000000000000000;;			grpclog.Printf("transport: http2Client.notifyError got notified that the client transport was broken %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;	}
