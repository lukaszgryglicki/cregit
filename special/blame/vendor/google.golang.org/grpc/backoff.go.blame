0000000000000000000000000000000000000000;;	package grpc
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultBackoffConfig uses values specified for backoff in
0000000000000000000000000000000000000000;;	// https://github.com/grpc/grpc/blob/master/doc/connection-backoff.md.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		DefaultBackoffConfig = BackoffConfig{
0000000000000000000000000000000000000000;;			MaxDelay:  120 * time.Second,
0000000000000000000000000000000000000000;;			baseDelay: 1.0 * time.Second,
0000000000000000000000000000000000000000;;			factor:    1.6,
0000000000000000000000000000000000000000;;			jitter:    0.2,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// backoffStrategy defines the methodology for backing off after a grpc
0000000000000000000000000000000000000000;;	// connection failure.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is unexported until the gRPC project decides whether or not to allow
0000000000000000000000000000000000000000;;	// alternative backoff strategies. Once a decision is made, this type and its
0000000000000000000000000000000000000000;;	// method may be exported.
0000000000000000000000000000000000000000;;	type backoffStrategy interface {
0000000000000000000000000000000000000000;;		// backoff returns the amount of time to wait before the next retry given
0000000000000000000000000000000000000000;;		// the number of consecutive failures.
0000000000000000000000000000000000000000;;		backoff(retries int) time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BackoffConfig defines the parameters for the default gRPC backoff strategy.
0000000000000000000000000000000000000000;;	type BackoffConfig struct {
0000000000000000000000000000000000000000;;		// MaxDelay is the upper bound of backoff delay.
0000000000000000000000000000000000000000;;		MaxDelay time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(stevvooe): The following fields are not exported, as allowing
0000000000000000000000000000000000000000;;		// changes would violate the current gRPC specification for backoff. If
0000000000000000000000000000000000000000;;		// gRPC decides to allow more interesting backoff strategies, these fields
0000000000000000000000000000000000000000;;		// may be opened up in the future.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// baseDelay is the amount of time to wait before retrying after the first
0000000000000000000000000000000000000000;;		// failure.
0000000000000000000000000000000000000000;;		baseDelay time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// factor is applied to the backoff after each retry.
0000000000000000000000000000000000000000;;		factor float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// jitter provides a range to randomize backoff delays.
0000000000000000000000000000000000000000;;		jitter float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDefaults(bc *BackoffConfig) {
0000000000000000000000000000000000000000;;		md := bc.MaxDelay
0000000000000000000000000000000000000000;;		*bc = DefaultBackoffConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if md > 0 {
0000000000000000000000000000000000000000;;			bc.MaxDelay = md
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bc BackoffConfig) backoff(retries int) time.Duration {
0000000000000000000000000000000000000000;;		if retries == 0 {
0000000000000000000000000000000000000000;;			return bc.baseDelay
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		backoff, max := float64(bc.baseDelay), float64(bc.MaxDelay)
0000000000000000000000000000000000000000;;		for backoff < max && retries > 0 {
0000000000000000000000000000000000000000;;			backoff *= bc.factor
0000000000000000000000000000000000000000;;			retries--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if backoff > max {
0000000000000000000000000000000000000000;;			backoff = max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Randomize backoff delays so that if a cluster of requests start at
0000000000000000000000000000000000000000;;		// the same time, they won't operate in lockstep.
0000000000000000000000000000000000000000;;		backoff *= 1 + bc.jitter*(rand.Float64()*2-1)
0000000000000000000000000000000000000000;;		if backoff < 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Duration(backoff)
0000000000000000000000000000000000000000;;	}
