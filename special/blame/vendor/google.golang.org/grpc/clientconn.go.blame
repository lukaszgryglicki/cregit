0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/clientconn.go[Godeps/_workspace/src/google.golang.org/grpc/clientconn.go][vendor/google.golang.org/grpc/clientconn.go];	
0000000000000000000000000000000000000000;;	package grpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/trace"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/transport"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrClientConnClosing indicates that the operation is illegal because
0000000000000000000000000000000000000000;;		// the ClientConn is closing.
0000000000000000000000000000000000000000;;		ErrClientConnClosing = errors.New("grpc: the client connection is closing")
0000000000000000000000000000000000000000;;		// ErrClientConnTimeout indicates that the ClientConn cannot establish the
0000000000000000000000000000000000000000;;		// underlying connections within the specified timeout.
0000000000000000000000000000000000000000;;		ErrClientConnTimeout = errors.New("grpc: timed out when dialing")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// errNoTransportSecurity indicates that there is no transport security
0000000000000000000000000000000000000000;;		// being set for ClientConn. Users should either set one or explicitly
0000000000000000000000000000000000000000;;		// call WithInsecure DialOption to disable security.
0000000000000000000000000000000000000000;;		errNoTransportSecurity = errors.New("grpc: no transport security set (use grpc.WithInsecure() explicitly or set credentials)")
0000000000000000000000000000000000000000;;		// errTransportCredentialsMissing indicates that users want to transmit security
0000000000000000000000000000000000000000;;		// information (e.g., oauth2 token) which requires secure connection on an insecure
0000000000000000000000000000000000000000;;		// connection.
0000000000000000000000000000000000000000;;		errTransportCredentialsMissing = errors.New("grpc: the credentials require transport level security (use grpc.WithTransportCredentials() to set)")
0000000000000000000000000000000000000000;;		// errCredentialsConflict indicates that grpc.WithTransportCredentials()
0000000000000000000000000000000000000000;;		// and grpc.WithInsecure() are both called for a connection.
0000000000000000000000000000000000000000;;		errCredentialsConflict = errors.New("grpc: transport credentials are set for an insecure connection (grpc.WithTransportCredentials() and grpc.WithInsecure() are both called)")
0000000000000000000000000000000000000000;;		// errNetworkIO indicates that the connection is down due to some network I/O error.
0000000000000000000000000000000000000000;;		errNetworkIO = errors.New("grpc: failed with network I/O error")
0000000000000000000000000000000000000000;;		// errConnDrain indicates that the connection starts to be drained and does not accept any new RPCs.
0000000000000000000000000000000000000000;;		errConnDrain = errors.New("grpc: the connection is drained")
0000000000000000000000000000000000000000;;		// errConnClosing indicates that the connection is closing.
0000000000000000000000000000000000000000;;		errConnClosing = errors.New("grpc: the connection is closing")
0000000000000000000000000000000000000000;;		// errConnUnavailable indicates that the connection is unavailable.
0000000000000000000000000000000000000000;;		errConnUnavailable = errors.New("grpc: the connection is unavailable")
0000000000000000000000000000000000000000;;		errNoAddr          = errors.New("grpc: there is no address available to dial")
0000000000000000000000000000000000000000;;		// minimum time to give a connection to complete
0000000000000000000000000000000000000000;;		minConnectTimeout = 20 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dialOptions configure a Dial call. dialOptions are set by the DialOption
0000000000000000000000000000000000000000;;	// values passed to Dial.
0000000000000000000000000000000000000000;;	type dialOptions struct {
0000000000000000000000000000000000000000;;		unaryInt  UnaryClientInterceptor
0000000000000000000000000000000000000000;;		streamInt StreamClientInterceptor
0000000000000000000000000000000000000000;;		codec     Codec
0000000000000000000000000000000000000000;;		cp        Compressor
0000000000000000000000000000000000000000;;		dc        Decompressor
0000000000000000000000000000000000000000;;		bs        backoffStrategy
0000000000000000000000000000000000000000;;		balancer  Balancer
0000000000000000000000000000000000000000;;		block     bool
0000000000000000000000000000000000000000;;		insecure  bool
0000000000000000000000000000000000000000;;		timeout   time.Duration
0000000000000000000000000000000000000000;;		copts     transport.ConnectOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialOption configures how we set up the connection.
0000000000000000000000000000000000000000;;	type DialOption func(*dialOptions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithCodec returns a DialOption which sets a codec for message marshaling and unmarshaling.
0000000000000000000000000000000000000000;;	func WithCodec(c Codec) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.codec = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithCompressor returns a DialOption which sets a CompressorGenerator for generating message
0000000000000000000000000000000000000000;;	// compressor.
0000000000000000000000000000000000000000;;	func WithCompressor(cp Compressor) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.cp = cp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDecompressor returns a DialOption which sets a DecompressorGenerator for generating
0000000000000000000000000000000000000000;;	// message decompressor.
0000000000000000000000000000000000000000;;	func WithDecompressor(dc Decompressor) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.dc = dc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithBalancer returns a DialOption which sets a load balancer.
0000000000000000000000000000000000000000;;	func WithBalancer(b Balancer) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.balancer = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithBackoffMaxDelay configures the dialer to use the provided maximum delay
0000000000000000000000000000000000000000;;	// when backing off after failed connection attempts.
0000000000000000000000000000000000000000;;	func WithBackoffMaxDelay(md time.Duration) DialOption {
0000000000000000000000000000000000000000;;		return WithBackoffConfig(BackoffConfig{MaxDelay: md})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithBackoffConfig configures the dialer to use the provided backoff
0000000000000000000000000000000000000000;;	// parameters after connection failures.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use WithBackoffMaxDelay until more parameters on BackoffConfig are opened up
0000000000000000000000000000000000000000;;	// for use.
0000000000000000000000000000000000000000;;	func WithBackoffConfig(b BackoffConfig) DialOption {
0000000000000000000000000000000000000000;;		// Set defaults to ensure that provided BackoffConfig is valid and
0000000000000000000000000000000000000000;;		// unexported fields get default values.
0000000000000000000000000000000000000000;;		setDefaults(&b)
0000000000000000000000000000000000000000;;		return withBackoff(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// withBackoff sets the backoff strategy used for retries after a
0000000000000000000000000000000000000000;;	// failed connection attempt.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This can be exported if arbitrary backoff strategies are allowed by gRPC.
0000000000000000000000000000000000000000;;	func withBackoff(bs backoffStrategy) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.bs = bs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithBlock returns a DialOption which makes caller of Dial blocks until the underlying
0000000000000000000000000000000000000000;;	// connection is up. Without this, Dial returns immediately and connecting the server
0000000000000000000000000000000000000000;;	// happens in background.
0000000000000000000000000000000000000000;;	func WithBlock() DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.block = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithInsecure returns a DialOption which disables transport security for this ClientConn.
0000000000000000000000000000000000000000;;	// Note that transport security is required unless WithInsecure is set.
0000000000000000000000000000000000000000;;	func WithInsecure() DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.insecure = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithTransportCredentials returns a DialOption which configures a
0000000000000000000000000000000000000000;;	// connection level security credentials (e.g., TLS/SSL).
0000000000000000000000000000000000000000;;	func WithTransportCredentials(creds credentials.TransportCredentials) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.copts.TransportCredentials = creds
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithPerRPCCredentials returns a DialOption which sets
0000000000000000000000000000000000000000;;	// credentials which will place auth state on each outbound RPC.
0000000000000000000000000000000000000000;;	func WithPerRPCCredentials(creds credentials.PerRPCCredentials) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.copts.PerRPCCredentials = append(o.copts.PerRPCCredentials, creds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithTimeout returns a DialOption that configures a timeout for dialing a ClientConn
0000000000000000000000000000000000000000;;	// initially. This is valid if and only if WithBlock() is present.
0000000000000000000000000000000000000000;;	func WithTimeout(d time.Duration) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.timeout = d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDialer returns a DialOption that specifies a function to use for dialing network addresses.
0000000000000000000000000000000000000000;;	func WithDialer(f func(string, time.Duration) (net.Conn, error)) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.copts.Dialer = func(ctx context.Context, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;				if deadline, ok := ctx.Deadline(); ok {
0000000000000000000000000000000000000000;;					return f(addr, deadline.Sub(time.Now()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return f(addr, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithUserAgent returns a DialOption that specifies a user agent string for all the RPCs.
0000000000000000000000000000000000000000;;	func WithUserAgent(s string) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.copts.UserAgent = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithUnaryInterceptor returns a DialOption that specifies the interceptor for unary RPCs.
0000000000000000000000000000000000000000;;	func WithUnaryInterceptor(f UnaryClientInterceptor) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.unaryInt = f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithStreamInterceptor returns a DialOption that specifies the interceptor for streaming RPCs.
0000000000000000000000000000000000000000;;	func WithStreamInterceptor(f StreamClientInterceptor) DialOption {
0000000000000000000000000000000000000000;;		return func(o *dialOptions) {
0000000000000000000000000000000000000000;;			o.streamInt = f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial creates a client connection to the given target.
0000000000000000000000000000000000000000;;	func Dial(target string, opts ...DialOption) (*ClientConn, error) {
0000000000000000000000000000000000000000;;		return DialContext(context.Background(), target, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialContext creates a client connection to the given target. ctx can be used to
0000000000000000000000000000000000000000;;	// cancel or expire the pending connecting. Once this function returns, the
0000000000000000000000000000000000000000;;	// cancellation and expiration of ctx will be noop. Users should call ClientConn.Close
0000000000000000000000000000000000000000;;	// to terminate all the pending operations after this function returns.
0000000000000000000000000000000000000000;;	// This is the EXPERIMENTAL API.
0000000000000000000000000000000000000000;;	func DialContext(ctx context.Context, target string, opts ...DialOption) (conn *ClientConn, err error) {
0000000000000000000000000000000000000000;;		cc := &ClientConn{
0000000000000000000000000000000000000000;;			target: target,
0000000000000000000000000000000000000000;;			conns:  make(map[Address]*addrConn),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.ctx, cc.cancel = context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				conn, err = nil, ctx.Err()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cc.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, opt := range opts {
0000000000000000000000000000000000000000;;			opt(&cc.dopts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set defaults.
0000000000000000000000000000000000000000;;		if cc.dopts.codec == nil {
0000000000000000000000000000000000000000;;			cc.dopts.codec = protoCodec{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cc.dopts.bs == nil {
0000000000000000000000000000000000000000;;			cc.dopts.bs = DefaultBackoffConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		creds := cc.dopts.copts.TransportCredentials
0000000000000000000000000000000000000000;;		if creds != nil && creds.Info().ServerName != "" {
0000000000000000000000000000000000000000;;			cc.authority = creds.Info().ServerName
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			colonPos := strings.LastIndex(target, ":")
0000000000000000000000000000000000000000;;			if colonPos == -1 {
0000000000000000000000000000000000000000;;				colonPos = len(target)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.authority = target[:colonPos]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		waitC := make(chan error, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			var addrs []Address
0000000000000000000000000000000000000000;;			if cc.dopts.balancer == nil {
0000000000000000000000000000000000000000;;				// Connect to target directly if balancer is nil.
0000000000000000000000000000000000000000;;				addrs = append(addrs, Address{Addr: target})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var credsClone credentials.TransportCredentials
0000000000000000000000000000000000000000;;				if creds != nil {
0000000000000000000000000000000000000000;;					credsClone = creds.Clone()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				config := BalancerConfig{
0000000000000000000000000000000000000000;;					DialCreds: credsClone,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := cc.dopts.balancer.Start(target, config); err != nil {
0000000000000000000000000000000000000000;;					waitC <- err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ch := cc.dopts.balancer.Notify()
0000000000000000000000000000000000000000;;				if ch == nil {
0000000000000000000000000000000000000000;;					// There is no name resolver installed.
0000000000000000000000000000000000000000;;					addrs = append(addrs, Address{Addr: target})
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					addrs, ok = <-ch
0000000000000000000000000000000000000000;;					if !ok || len(addrs) == 0 {
0000000000000000000000000000000000000000;;						waitC <- errNoAddr
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, a := range addrs {
0000000000000000000000000000000000000000;;				if err := cc.resetAddrConn(a, false, nil); err != nil {
0000000000000000000000000000000000000000;;					waitC <- err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(waitC)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var timeoutCh <-chan time.Time
0000000000000000000000000000000000000000;;		if cc.dopts.timeout > 0 {
0000000000000000000000000000000000000000;;			timeoutCh = time.After(cc.dopts.timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return nil, ctx.Err()
0000000000000000000000000000000000000000;;		case err := <-waitC:
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-timeoutCh:
0000000000000000000000000000000000000000;;			return nil, ErrClientConnTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If balancer is nil or balancer.Notify() is nil, ok will be false here.
0000000000000000000000000000000000000000;;		// The lbWatcher goroutine will not be created.
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			go cc.lbWatcher()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectivityState indicates the state of a client connection.
0000000000000000000000000000000000000000;;	type ConnectivityState int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Idle indicates the ClientConn is idle.
0000000000000000000000000000000000000000;;		Idle ConnectivityState = iota
0000000000000000000000000000000000000000;;		// Connecting indicates the ClienConn is connecting.
0000000000000000000000000000000000000000;;		Connecting
0000000000000000000000000000000000000000;;		// Ready indicates the ClientConn is ready for work.
0000000000000000000000000000000000000000;;		Ready
0000000000000000000000000000000000000000;;		// TransientFailure indicates the ClientConn has seen a failure but expects to recover.
0000000000000000000000000000000000000000;;		TransientFailure
0000000000000000000000000000000000000000;;		// Shutdown indicates the ClientConn has started shutting down.
0000000000000000000000000000000000000000;;		Shutdown
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s ConnectivityState) String() string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case Idle:
0000000000000000000000000000000000000000;;			return "IDLE"
0000000000000000000000000000000000000000;;		case Connecting:
0000000000000000000000000000000000000000;;			return "CONNECTING"
0000000000000000000000000000000000000000;;		case Ready:
0000000000000000000000000000000000000000;;			return "READY"
0000000000000000000000000000000000000000;;		case TransientFailure:
0000000000000000000000000000000000000000;;			return "TRANSIENT_FAILURE"
0000000000000000000000000000000000000000;;		case Shutdown:
0000000000000000000000000000000000000000;;			return "SHUTDOWN"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unknown connectivity state: %d", s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConn represents a client connection to an RPC server.
0000000000000000000000000000000000000000;;	type ClientConn struct {
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		target    string
0000000000000000000000000000000000000000;;		authority string
0000000000000000000000000000000000000000;;		dopts     dialOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu    sync.RWMutex
0000000000000000000000000000000000000000;;		conns map[Address]*addrConn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) lbWatcher() {
0000000000000000000000000000000000000000;;		for addrs := range cc.dopts.balancer.Notify() {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				add []Address   // Addresses need to setup connections.
0000000000000000000000000000000000000000;;				del []*addrConn // Connections need to tear down.
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			cc.mu.Lock()
0000000000000000000000000000000000000000;;			for _, a := range addrs {
0000000000000000000000000000000000000000;;				if _, ok := cc.conns[a]; !ok {
0000000000000000000000000000000000000000;;					add = append(add, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, c := range cc.conns {
0000000000000000000000000000000000000000;;				var keep bool
0000000000000000000000000000000000000000;;				for _, a := range addrs {
0000000000000000000000000000000000000000;;					if k == a {
0000000000000000000000000000000000000000;;						keep = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !keep {
0000000000000000000000000000000000000000;;					del = append(del, c)
0000000000000000000000000000000000000000;;					delete(cc.conns, c.addr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;			for _, a := range add {
0000000000000000000000000000000000000000;;				cc.resetAddrConn(a, true, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range del {
0000000000000000000000000000000000000000;;				c.tearDown(errConnDrain)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resetAddrConn creates an addrConn for addr and adds it to cc.conns.
0000000000000000000000000000000000000000;;	// If there is an old addrConn for addr, it will be torn down, using tearDownErr as the reason.
0000000000000000000000000000000000000000;;	// If tearDownErr is nil, errConnDrain will be used instead.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) resetAddrConn(addr Address, skipWait bool, tearDownErr error) error {
0000000000000000000000000000000000000000;;		ac := &addrConn{
0000000000000000000000000000000000000000;;			cc:    cc,
0000000000000000000000000000000000000000;;			addr:  addr,
0000000000000000000000000000000000000000;;			dopts: cc.dopts,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ac.ctx, ac.cancel = context.WithCancel(cc.ctx)
0000000000000000000000000000000000000000;;		ac.stateCV = sync.NewCond(&ac.mu)
0000000000000000000000000000000000000000;;		if EnableTracing {
0000000000000000000000000000000000000000;;			ac.events = trace.NewEventLog("grpc.ClientConn", ac.addr.Addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ac.dopts.insecure {
0000000000000000000000000000000000000000;;			if ac.dopts.copts.TransportCredentials == nil {
0000000000000000000000000000000000000000;;				return errNoTransportSecurity
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if ac.dopts.copts.TransportCredentials != nil {
0000000000000000000000000000000000000000;;				return errCredentialsConflict
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, cd := range ac.dopts.copts.PerRPCCredentials {
0000000000000000000000000000000000000000;;				if cd.RequireTransportSecurity() {
0000000000000000000000000000000000000000;;					return errTransportCredentialsMissing
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Track ac in cc. This needs to be done before any getTransport(...) is called.
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		if cc.conns == nil {
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;			return ErrClientConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stale := cc.conns[ac.addr]
0000000000000000000000000000000000000000;;		cc.conns[ac.addr] = ac
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;		if stale != nil {
0000000000000000000000000000000000000000;;			// There is an addrConn alive on ac.addr already. This could be due to
0000000000000000000000000000000000000000;;			// 1) a buggy Balancer notifies duplicated Addresses;
0000000000000000000000000000000000000000;;			// 2) goaway was received, a new ac will replace the old ac.
0000000000000000000000000000000000000000;;			//    The old ac should be deleted from cc.conns, but the
0000000000000000000000000000000000000000;;			//    underlying transport should drain rather than close.
0000000000000000000000000000000000000000;;			if tearDownErr == nil {
0000000000000000000000000000000000000000;;				// tearDownErr is nil if resetAddrConn is called by
0000000000000000000000000000000000000000;;				// 1) Dial
0000000000000000000000000000000000000000;;				// 2) lbWatcher
0000000000000000000000000000000000000000;;				// In both cases, the stale ac should drain, not close.
0000000000000000000000000000000000000000;;				stale.tearDown(errConnDrain)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				stale.tearDown(tearDownErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// skipWait may overwrite the decision in ac.dopts.block.
0000000000000000000000000000000000000000;;		if ac.dopts.block && !skipWait {
0000000000000000000000000000000000000000;;			if err := ac.resetTransport(false); err != nil {
0000000000000000000000000000000000000000;;				if err != errConnClosing {
0000000000000000000000000000000000000000;;					// Tear down ac and delete it from cc.conns.
0000000000000000000000000000000000000000;;					cc.mu.Lock()
0000000000000000000000000000000000000000;;					delete(cc.conns, ac.addr)
0000000000000000000000000000000000000000;;					cc.mu.Unlock()
0000000000000000000000000000000000000000;;					ac.tearDown(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, ok := err.(transport.ConnectionError); ok && !e.Temporary() {
0000000000000000000000000000000000000000;;					return e.Origin()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Start to monitor the error status of transport.
0000000000000000000000000000000000000000;;			go ac.transportMonitor()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Start a goroutine connecting to the server asynchronously.
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				if err := ac.resetTransport(false); err != nil {
0000000000000000000000000000000000000000;;					grpclog.Printf("Failed to dial %s: %v; please retry.", ac.addr.Addr, err)
0000000000000000000000000000000000000000;;					if err != errConnClosing {
0000000000000000000000000000000000000000;;						// Keep this ac in cc.conns, to get the reason it's torn down.
0000000000000000000000000000000000000000;;						ac.tearDown(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ac.transportMonitor()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) getTransport(ctx context.Context, opts BalancerGetOptions) (transport.ClientTransport, func(), error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			ac  *addrConn
0000000000000000000000000000000000000000;;			ok  bool
0000000000000000000000000000000000000000;;			put func()
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if cc.dopts.balancer == nil {
0000000000000000000000000000000000000000;;			// If balancer is nil, there should be only one addrConn available.
0000000000000000000000000000000000000000;;			cc.mu.RLock()
0000000000000000000000000000000000000000;;			if cc.conns == nil {
0000000000000000000000000000000000000000;;				cc.mu.RUnlock()
0000000000000000000000000000000000000000;;				return nil, nil, toRPCErr(ErrClientConnClosing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ac = range cc.conns {
0000000000000000000000000000000000000000;;				// Break after the first iteration to get the first addrConn.
0000000000000000000000000000000000000000;;				ok = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.mu.RUnlock()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				addr Address
0000000000000000000000000000000000000000;;				err  error
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			addr, put, err = cc.dopts.balancer.Get(ctx, opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, toRPCErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.mu.RLock()
0000000000000000000000000000000000000000;;			if cc.conns == nil {
0000000000000000000000000000000000000000;;				cc.mu.RUnlock()
0000000000000000000000000000000000000000;;				return nil, nil, toRPCErr(ErrClientConnClosing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ac, ok = cc.conns[addr]
0000000000000000000000000000000000000000;;			cc.mu.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if put != nil {
0000000000000000000000000000000000000000;;				put()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, nil, errConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := ac.wait(ctx, cc.dopts.balancer != nil, !opts.BlockingWait)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if put != nil {
0000000000000000000000000000000000000000;;				put()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, put, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close tears down the ClientConn and all underlying connections.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) Close() error {
0000000000000000000000000000000000000000;;		cc.cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		if cc.conns == nil {
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;			return ErrClientConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conns := cc.conns
0000000000000000000000000000000000000000;;		cc.conns = nil
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;		if cc.dopts.balancer != nil {
0000000000000000000000000000000000000000;;			cc.dopts.balancer.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ac := range conns {
0000000000000000000000000000000000000000;;			ac.tearDown(ErrClientConnClosing)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addrConn is a network connection to a given address.
0000000000000000000000000000000000000000;;	type addrConn struct {
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc     *ClientConn
0000000000000000000000000000000000000000;;		addr   Address
0000000000000000000000000000000000000000;;		dopts  dialOptions
0000000000000000000000000000000000000000;;		events trace.EventLog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		state   ConnectivityState
0000000000000000000000000000000000000000;;		stateCV *sync.Cond
0000000000000000000000000000000000000000;;		down    func(error) // the handler called when a connection is down.
0000000000000000000000000000000000000000;;		// ready is closed and becomes nil when a new transport is up or failed
0000000000000000000000000000000000000000;;		// due to timeout.
0000000000000000000000000000000000000000;;		ready     chan struct{}
0000000000000000000000000000000000000000;;		transport transport.ClientTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The reason this addrConn is torn down.
0000000000000000000000000000000000000000;;		tearDownErr error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printf records an event in ac's event log, unless ac has been closed.
0000000000000000000000000000000000000000;;	// REQUIRES ac.mu is held.
0000000000000000000000000000000000000000;;	func (ac *addrConn) printf(format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		if ac.events != nil {
0000000000000000000000000000000000000000;;			ac.events.Printf(format, a...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errorf records an error in ac's event log, unless ac has been closed.
0000000000000000000000000000000000000000;;	// REQUIRES ac.mu is held.
0000000000000000000000000000000000000000;;	func (ac *addrConn) errorf(format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		if ac.events != nil {
0000000000000000000000000000000000000000;;			ac.events.Errorf(format, a...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getState returns the connectivity state of the Conn
0000000000000000000000000000000000000000;;	func (ac *addrConn) getState() ConnectivityState {
0000000000000000000000000000000000000000;;		ac.mu.Lock()
0000000000000000000000000000000000000000;;		defer ac.mu.Unlock()
0000000000000000000000000000000000000000;;		return ac.state
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForStateChange blocks until the state changes to something other than the sourceState.
0000000000000000000000000000000000000000;;	func (ac *addrConn) waitForStateChange(ctx context.Context, sourceState ConnectivityState) (ConnectivityState, error) {
0000000000000000000000000000000000000000;;		ac.mu.Lock()
0000000000000000000000000000000000000000;;		defer ac.mu.Unlock()
0000000000000000000000000000000000000000;;		if sourceState != ac.state {
0000000000000000000000000000000000000000;;			return ac.state, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				ac.mu.Lock()
0000000000000000000000000000000000000000;;				err = ctx.Err()
0000000000000000000000000000000000000000;;				ac.stateCV.Broadcast()
0000000000000000000000000000000000000000;;				ac.mu.Unlock()
0000000000000000000000000000000000000000;;			case <-done:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;		for sourceState == ac.state {
0000000000000000000000000000000000000000;;			ac.stateCV.Wait()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ac.state, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ac.state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ac *addrConn) resetTransport(closeTransport bool) error {
0000000000000000000000000000000000000000;;		for retries := 0; ; retries++ {
0000000000000000000000000000000000000000;;			ac.mu.Lock()
0000000000000000000000000000000000000000;;			ac.printf("connecting")
0000000000000000000000000000000000000000;;			if ac.state == Shutdown {
0000000000000000000000000000000000000000;;				// ac.tearDown(...) has been invoked.
0000000000000000000000000000000000000000;;				ac.mu.Unlock()
0000000000000000000000000000000000000000;;				return errConnClosing
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ac.down != nil {
0000000000000000000000000000000000000000;;				ac.down(downErrorf(false, true, "%v", errNetworkIO))
0000000000000000000000000000000000000000;;				ac.down = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ac.state = Connecting
0000000000000000000000000000000000000000;;			ac.stateCV.Broadcast()
0000000000000000000000000000000000000000;;			t := ac.transport
0000000000000000000000000000000000000000;;			ac.mu.Unlock()
0000000000000000000000000000000000000000;;			if closeTransport && t != nil {
0000000000000000000000000000000000000000;;				t.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sleepTime := ac.dopts.bs.backoff(retries)
0000000000000000000000000000000000000000;;			timeout := minConnectTimeout
0000000000000000000000000000000000000000;;			if timeout < sleepTime {
0000000000000000000000000000000000000000;;				timeout = sleepTime
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(ac.ctx, timeout)
0000000000000000000000000000000000000000;;			connectTime := time.Now()
0000000000000000000000000000000000000000;;			sinfo := transport.TargetInfo{
0000000000000000000000000000000000000000;;				Addr:     ac.addr.Addr,
0000000000000000000000000000000000000000;;				Metadata: ac.addr.Metadata,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newTransport, err := transport.NewClientTransport(ctx, sinfo, ac.dopts.copts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, ok := err.(transport.ConnectionError); ok && !e.Temporary() {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				grpclog.Printf("grpc: addrConn.resetTransport failed to create client transport: %v; Reconnecting to %v", err, ac.addr)
0000000000000000000000000000000000000000;;				ac.mu.Lock()
0000000000000000000000000000000000000000;;				if ac.state == Shutdown {
0000000000000000000000000000000000000000;;					// ac.tearDown(...) has been invoked.
0000000000000000000000000000000000000000;;					ac.mu.Unlock()
0000000000000000000000000000000000000000;;					return errConnClosing
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ac.errorf("transient failure: %v", err)
0000000000000000000000000000000000000000;;				ac.state = TransientFailure
0000000000000000000000000000000000000000;;				ac.stateCV.Broadcast()
0000000000000000000000000000000000000000;;				if ac.ready != nil {
0000000000000000000000000000000000000000;;					close(ac.ready)
0000000000000000000000000000000000000000;;					ac.ready = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ac.mu.Unlock()
0000000000000000000000000000000000000000;;				closeTransport = false
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-time.After(sleepTime - time.Since(connectTime)):
0000000000000000000000000000000000000000;;				case <-ac.ctx.Done():
0000000000000000000000000000000000000000;;					return ac.ctx.Err()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ac.mu.Lock()
0000000000000000000000000000000000000000;;			ac.printf("ready")
0000000000000000000000000000000000000000;;			if ac.state == Shutdown {
0000000000000000000000000000000000000000;;				// ac.tearDown(...) has been invoked.
0000000000000000000000000000000000000000;;				ac.mu.Unlock()
0000000000000000000000000000000000000000;;				newTransport.Close()
0000000000000000000000000000000000000000;;				return errConnClosing
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ac.state = Ready
0000000000000000000000000000000000000000;;			ac.stateCV.Broadcast()
0000000000000000000000000000000000000000;;			ac.transport = newTransport
0000000000000000000000000000000000000000;;			if ac.ready != nil {
0000000000000000000000000000000000000000;;				close(ac.ready)
0000000000000000000000000000000000000000;;				ac.ready = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ac.cc.dopts.balancer != nil {
0000000000000000000000000000000000000000;;				ac.down = ac.cc.dopts.balancer.Up(ac.addr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ac.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run in a goroutine to track the error in transport and create the
0000000000000000000000000000000000000000;;	// new transport if an error happens. It returns when the channel is closing.
0000000000000000000000000000000000000000;;	func (ac *addrConn) transportMonitor() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ac.mu.Lock()
0000000000000000000000000000000000000000;;			t := ac.transport
0000000000000000000000000000000000000000;;			ac.mu.Unlock()
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			// This is needed to detect the teardown when
0000000000000000000000000000000000000000;;			// the addrConn is idle (i.e., no RPC in flight).
0000000000000000000000000000000000000000;;			case <-ac.ctx.Done():
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-t.Error():
0000000000000000000000000000000000000000;;					t.Close()
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-t.GoAway():
0000000000000000000000000000000000000000;;				// If GoAway happens without any network I/O error, ac is closed without shutting down the
0000000000000000000000000000000000000000;;				// underlying transport (the transport will be closed when all the pending RPCs finished or
0000000000000000000000000000000000000000;;				// failed.).
0000000000000000000000000000000000000000;;				// If GoAway and some network I/O error happen concurrently, ac and its underlying transport
0000000000000000000000000000000000000000;;				// are closed.
0000000000000000000000000000000000000000;;				// In both cases, a new ac is created.
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-t.Error():
0000000000000000000000000000000000000000;;					ac.cc.resetAddrConn(ac.addr, true, errNetworkIO)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					ac.cc.resetAddrConn(ac.addr, true, errConnDrain)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-t.Error():
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-ac.ctx.Done():
0000000000000000000000000000000000000000;;					t.Close()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case <-t.GoAway():
0000000000000000000000000000000000000000;;					ac.cc.resetAddrConn(ac.addr, true, errNetworkIO)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ac.mu.Lock()
0000000000000000000000000000000000000000;;				if ac.state == Shutdown {
0000000000000000000000000000000000000000;;					// ac has been shutdown.
0000000000000000000000000000000000000000;;					ac.mu.Unlock()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ac.state = TransientFailure
0000000000000000000000000000000000000000;;				ac.stateCV.Broadcast()
0000000000000000000000000000000000000000;;				ac.mu.Unlock()
0000000000000000000000000000000000000000;;				if err := ac.resetTransport(true); err != nil {
0000000000000000000000000000000000000000;;					ac.mu.Lock()
0000000000000000000000000000000000000000;;					ac.printf("transport exiting: %v", err)
0000000000000000000000000000000000000000;;					ac.mu.Unlock()
0000000000000000000000000000000000000000;;					grpclog.Printf("grpc: addrConn.transportMonitor exits due to: %v", err)
0000000000000000000000000000000000000000;;					if err != errConnClosing {
0000000000000000000000000000000000000000;;						// Keep this ac in cc.conns, to get the reason it's torn down.
0000000000000000000000000000000000000000;;						ac.tearDown(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait blocks until i) the new transport is up or ii) ctx is done or iii) ac is closed or
0000000000000000000000000000000000000000;;	// iv) transport is in TransientFailure and there is a balancer/failfast is true.
0000000000000000000000000000000000000000;;	func (ac *addrConn) wait(ctx context.Context, hasBalancer, failfast bool) (transport.ClientTransport, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ac.mu.Lock()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ac.state == Shutdown:
0000000000000000000000000000000000000000;;				if failfast || !hasBalancer {
0000000000000000000000000000000000000000;;					// RPC is failfast or balancer is nil. This RPC should fail with ac.tearDownErr.
0000000000000000000000000000000000000000;;					err := ac.tearDownErr
0000000000000000000000000000000000000000;;					ac.mu.Unlock()
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ac.mu.Unlock()
0000000000000000000000000000000000000000;;				return nil, errConnClosing
0000000000000000000000000000000000000000;;			case ac.state == Ready:
0000000000000000000000000000000000000000;;				ct := ac.transport
0000000000000000000000000000000000000000;;				ac.mu.Unlock()
0000000000000000000000000000000000000000;;				return ct, nil
0000000000000000000000000000000000000000;;			case ac.state == TransientFailure:
0000000000000000000000000000000000000000;;				if failfast || hasBalancer {
0000000000000000000000000000000000000000;;					ac.mu.Unlock()
0000000000000000000000000000000000000000;;					return nil, errConnUnavailable
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ready := ac.ready
0000000000000000000000000000000000000000;;			if ready == nil {
0000000000000000000000000000000000000000;;				ready = make(chan struct{})
0000000000000000000000000000000000000000;;				ac.ready = ready
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ac.mu.Unlock()
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return nil, toRPCErr(ctx.Err())
0000000000000000000000000000000000000000;;			// Wait until the new transport is ready or failed.
0000000000000000000000000000000000000000;;			case <-ready:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tearDown starts to tear down the addrConn.
0000000000000000000000000000000000000000;;	// TODO(zhaoq): Make this synchronous to avoid unbounded memory consumption in
0000000000000000000000000000000000000000;;	// some edge cases (e.g., the caller opens and closes many addrConn's in a
0000000000000000000000000000000000000000;;	// tight loop.
0000000000000000000000000000000000000000;;	// tearDown doesn't remove ac from ac.cc.conns.
0000000000000000000000000000000000000000;;	func (ac *addrConn) tearDown(err error) {
0000000000000000000000000000000000000000;;		ac.cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ac.mu.Lock()
0000000000000000000000000000000000000000;;		defer ac.mu.Unlock()
0000000000000000000000000000000000000000;;		if ac.down != nil {
0000000000000000000000000000000000000000;;			ac.down(downErrorf(false, false, "%v", err))
0000000000000000000000000000000000000000;;			ac.down = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == errConnDrain && ac.transport != nil {
0000000000000000000000000000000000000000;;			// GracefulClose(...) may be executed multiple times when
0000000000000000000000000000000000000000;;			// i) receiving multiple GoAway frames from the server; or
0000000000000000000000000000000000000000;;			// ii) there are concurrent name resolver/Balancer triggered
0000000000000000000000000000000000000000;;			// address removal and GoAway.
0000000000000000000000000000000000000000;;			ac.transport.GracefulClose()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ac.state == Shutdown {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ac.state = Shutdown
0000000000000000000000000000000000000000;;		ac.tearDownErr = err
0000000000000000000000000000000000000000;;		ac.stateCV.Broadcast()
0000000000000000000000000000000000000000;;		if ac.events != nil {
0000000000000000000000000000000000000000;;			ac.events.Finish()
0000000000000000000000000000000000000000;;			ac.events = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ac.ready != nil {
0000000000000000000000000000000000000000;;			close(ac.ready)
0000000000000000000000000000000000000000;;			ac.ready = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ac.transport != nil && err != errConnDrain {
0000000000000000000000000000000000000000;;			ac.transport.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
