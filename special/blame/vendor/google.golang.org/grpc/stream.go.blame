0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/stream.go[Godeps/_workspace/src/google.golang.org/grpc/stream.go][vendor/google.golang.org/grpc/stream.go];	
0000000000000000000000000000000000000000;;	package grpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/trace"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/transport"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamHandler defines the handler called by gRPC server to complete the
0000000000000000000000000000000000000000;;	// execution of a streaming RPC.
0000000000000000000000000000000000000000;;	type StreamHandler func(srv interface{}, stream ServerStream) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamDesc represents a streaming RPC service's method specification.
0000000000000000000000000000000000000000;;	type StreamDesc struct {
0000000000000000000000000000000000000000;;		StreamName string
0000000000000000000000000000000000000000;;		Handler    StreamHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// At least one of these is true.
0000000000000000000000000000000000000000;;		ServerStreams bool
0000000000000000000000000000000000000000;;		ClientStreams bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stream defines the common interface a client or server stream has to satisfy.
0000000000000000000000000000000000000000;;	type Stream interface {
0000000000000000000000000000000000000000;;		// Context returns the context for this stream.
0000000000000000000000000000000000000000;;		Context() context.Context
0000000000000000000000000000000000000000;;		// SendMsg blocks until it sends m, the stream is done or the stream
0000000000000000000000000000000000000000;;		// breaks.
0000000000000000000000000000000000000000;;		// On error, it aborts the stream and returns an RPC status on client
0000000000000000000000000000000000000000;;		// side. On server side, it simply returns the error to the caller.
0000000000000000000000000000000000000000;;		// SendMsg is called by generated code. Also Users can call SendMsg
0000000000000000000000000000000000000000;;		// directly when it is really needed in their use cases.
0000000000000000000000000000000000000000;;		SendMsg(m interface{}) error
0000000000000000000000000000000000000000;;		// RecvMsg blocks until it receives a message or the stream is
0000000000000000000000000000000000000000;;		// done. On client side, it returns io.EOF when the stream is done. On
0000000000000000000000000000000000000000;;		// any other error, it aborts the stream and returns an RPC status. On
0000000000000000000000000000000000000000;;		// server side, it simply returns the error to the caller.
0000000000000000000000000000000000000000;;		RecvMsg(m interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientStream defines the interface a client stream has to satisfy.
0000000000000000000000000000000000000000;;	type ClientStream interface {
0000000000000000000000000000000000000000;;		// Header returns the header metadata received from the server if there
0000000000000000000000000000000000000000;;		// is any. It blocks if the metadata is not ready to read.
0000000000000000000000000000000000000000;;		Header() (metadata.MD, error)
0000000000000000000000000000000000000000;;		// Trailer returns the trailer metadata from the server, if there is any.
0000000000000000000000000000000000000000;;		// It must only be called after stream.CloseAndRecv has returned, or
0000000000000000000000000000000000000000;;		// stream.Recv has returned a non-nil error (including io.EOF).
0000000000000000000000000000000000000000;;		Trailer() metadata.MD
0000000000000000000000000000000000000000;;		// CloseSend closes the send direction of the stream. It closes the stream
0000000000000000000000000000000000000000;;		// when non-nil error is met.
0000000000000000000000000000000000000000;;		CloseSend() error
0000000000000000000000000000000000000000;;		Stream
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientStream creates a new Stream for the client side. This is called
0000000000000000000000000000000000000000;;	// by generated code.
0000000000000000000000000000000000000000;;	func NewClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (ClientStream, error) {
0000000000000000000000000000000000000000;;		if cc.dopts.streamInt != nil {
0000000000000000000000000000000000000000;;			return cc.dopts.streamInt(ctx, desc, cc, method, newClientStream, opts...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newClientStream(ctx, desc, cc, method, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (_ ClientStream, err error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			t   transport.ClientTransport
0000000000000000000000000000000000000000;;			s   *transport.Stream
0000000000000000000000000000000000000000;;			put func()
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		c := defaultCallInfo
0000000000000000000000000000000000000000;;		for _, o := range opts {
0000000000000000000000000000000000000000;;			if err := o.before(&c); err != nil {
0000000000000000000000000000000000000000;;				return nil, toRPCErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		callHdr := &transport.CallHdr{
0000000000000000000000000000000000000000;;			Host:   cc.authority,
0000000000000000000000000000000000000000;;			Method: method,
0000000000000000000000000000000000000000;;			Flush:  desc.ServerStreams && desc.ClientStreams,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cc.dopts.cp != nil {
0000000000000000000000000000000000000000;;			callHdr.SendCompress = cc.dopts.cp.Type()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var trInfo traceInfo
0000000000000000000000000000000000000000;;		if EnableTracing {
0000000000000000000000000000000000000000;;			trInfo.tr = trace.New("grpc.Sent."+methodFamily(method), method)
0000000000000000000000000000000000000000;;			trInfo.firstLine.client = true
0000000000000000000000000000000000000000;;			if deadline, ok := ctx.Deadline(); ok {
0000000000000000000000000000000000000000;;				trInfo.firstLine.deadline = deadline.Sub(time.Now())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trInfo.tr.LazyLog(&trInfo.firstLine, false)
0000000000000000000000000000000000000000;;			ctx = trace.NewContext(ctx, trInfo.tr)
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Need to call tr.finish() if error is returned.
0000000000000000000000000000000000000000;;					// Because tr will not be returned to caller.
0000000000000000000000000000000000000000;;					trInfo.tr.LazyPrintf("RPC: [%v]", err)
0000000000000000000000000000000000000000;;					trInfo.tr.SetError()
0000000000000000000000000000000000000000;;					trInfo.tr.Finish()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gopts := BalancerGetOptions{
0000000000000000000000000000000000000000;;			BlockingWait: !c.failFast,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			t, put, err = cc.getTransport(ctx, gopts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO(zhaoq): Probably revisit the error handling.
0000000000000000000000000000000000000000;;				if _, ok := err.(*rpcError); ok {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == errConnClosing || err == errConnUnavailable {
0000000000000000000000000000000000000000;;					if c.failFast {
0000000000000000000000000000000000000000;;						return nil, Errorf(codes.Unavailable, "%v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// All the other errors are treated as Internal errors.
0000000000000000000000000000000000000000;;				return nil, Errorf(codes.Internal, "%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s, err = t.NewStream(ctx, callHdr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if put != nil {
0000000000000000000000000000000000000000;;					put()
0000000000000000000000000000000000000000;;					put = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := err.(transport.ConnectionError); ok || err == transport.ErrStreamDrain {
0000000000000000000000000000000000000000;;					if c.failFast {
0000000000000000000000000000000000000000;;						return nil, toRPCErr(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, toRPCErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs := &clientStream{
0000000000000000000000000000000000000000;;			opts:  opts,
0000000000000000000000000000000000000000;;			c:     c,
0000000000000000000000000000000000000000;;			desc:  desc,
0000000000000000000000000000000000000000;;			codec: cc.dopts.codec,
0000000000000000000000000000000000000000;;			cp:    cc.dopts.cp,
0000000000000000000000000000000000000000;;			dc:    cc.dopts.dc,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			put: put,
0000000000000000000000000000000000000000;;			t:   t,
0000000000000000000000000000000000000000;;			s:   s,
0000000000000000000000000000000000000000;;			p:   &parser{r: s},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tracing: EnableTracing,
0000000000000000000000000000000000000000;;			trInfo:  trInfo,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cc.dopts.cp != nil {
0000000000000000000000000000000000000000;;			cs.cbuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Listen on ctx.Done() to detect cancellation and s.Done() to detect normal termination
0000000000000000000000000000000000000000;;		// when there is no pending I/O operations on this stream.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-t.Error():
0000000000000000000000000000000000000000;;				// Incur transport error, simply exit.
0000000000000000000000000000000000000000;;			case <-s.Done():
0000000000000000000000000000000000000000;;				// TODO: The trace of the RPC is terminated here when there is no pending
0000000000000000000000000000000000000000;;				// I/O, which is probably not the optimal solution.
0000000000000000000000000000000000000000;;				if s.StatusCode() == codes.OK {
0000000000000000000000000000000000000000;;					cs.finish(nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					cs.finish(Errorf(s.StatusCode(), "%s", s.StatusDesc()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cs.closeTransportStream(nil)
0000000000000000000000000000000000000000;;			case <-s.GoAway():
0000000000000000000000000000000000000000;;				cs.finish(errConnDrain)
0000000000000000000000000000000000000000;;				cs.closeTransportStream(errConnDrain)
0000000000000000000000000000000000000000;;			case <-s.Context().Done():
0000000000000000000000000000000000000000;;				err := s.Context().Err()
0000000000000000000000000000000000000000;;				cs.finish(err)
0000000000000000000000000000000000000000;;				cs.closeTransportStream(transport.ContextErr(err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return cs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientStream implements a client side Stream.
0000000000000000000000000000000000000000;;	type clientStream struct {
0000000000000000000000000000000000000000;;		opts  []CallOption
0000000000000000000000000000000000000000;;		c     callInfo
0000000000000000000000000000000000000000;;		t     transport.ClientTransport
0000000000000000000000000000000000000000;;		s     *transport.Stream
0000000000000000000000000000000000000000;;		p     *parser
0000000000000000000000000000000000000000;;		desc  *StreamDesc
0000000000000000000000000000000000000000;;		codec Codec
0000000000000000000000000000000000000000;;		cp    Compressor
0000000000000000000000000000000000000000;;		cbuf  *bytes.Buffer
0000000000000000000000000000000000000000;;		dc    Decompressor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tracing bool // set to EnableTracing when the clientStream is created.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu     sync.Mutex
0000000000000000000000000000000000000000;;		put    func()
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;		// trInfo.tr is set when the clientStream is created (if EnableTracing is true),
0000000000000000000000000000000000000000;;		// and is set to nil when the clientStream's finish method is called.
0000000000000000000000000000000000000000;;		trInfo traceInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) Context() context.Context {
0000000000000000000000000000000000000000;;		return cs.s.Context()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) Header() (metadata.MD, error) {
0000000000000000000000000000000000000000;;		m, err := cs.s.Header()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(transport.ConnectionError); !ok {
0000000000000000000000000000000000000000;;				cs.closeTransportStream(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) Trailer() metadata.MD {
0000000000000000000000000000000000000000;;		return cs.s.Trailer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) SendMsg(m interface{}) (err error) {
0000000000000000000000000000000000000000;;		if cs.tracing {
0000000000000000000000000000000000000000;;			cs.mu.Lock()
0000000000000000000000000000000000000000;;			if cs.trInfo.tr != nil {
0000000000000000000000000000000000000000;;				cs.trInfo.tr.LazyLog(&payload{sent: true, msg: m}, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cs.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cs.finish(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				// Specialize the process for server streaming. SendMesg is only called
0000000000000000000000000000000000000000;;				// once when creating the stream object. io.EOF needs to be skipped when
0000000000000000000000000000000000000000;;				// the rpc is early finished (before the stream object is created.).
0000000000000000000000000000000000000000;;				// TODO: It is probably better to move this into the generated code.
0000000000000000000000000000000000000000;;				if !cs.desc.ClientStreams && cs.desc.ServerStreams {
0000000000000000000000000000000000000000;;					err = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := err.(transport.ConnectionError); !ok {
0000000000000000000000000000000000000000;;				cs.closeTransportStream(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = toRPCErr(err)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		out, err := encode(cs.codec, m, cs.cp, cs.cbuf)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if cs.cbuf != nil {
0000000000000000000000000000000000000000;;				cs.cbuf.Reset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Errorf(codes.Internal, "grpc: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cs.t.Write(cs.s, out, &transport.Options{Last: false})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) RecvMsg(m interface{}) (err error) {
0000000000000000000000000000000000000000;;		err = recv(cs.p, cs.codec, cs.s, cs.dc, m, math.MaxInt32)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// err != nil indicates the termination of the stream.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cs.finish(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if cs.tracing {
0000000000000000000000000000000000000000;;				cs.mu.Lock()
0000000000000000000000000000000000000000;;				if cs.trInfo.tr != nil {
0000000000000000000000000000000000000000;;					cs.trInfo.tr.LazyLog(&payload{sent: false, msg: m}, true)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cs.mu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !cs.desc.ClientStreams || cs.desc.ServerStreams {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Special handling for client streaming rpc.
0000000000000000000000000000000000000000;;			err = recv(cs.p, cs.codec, cs.s, cs.dc, m, math.MaxInt32)
0000000000000000000000000000000000000000;;			cs.closeTransportStream(err)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return toRPCErr(errors.New("grpc: client streaming protocol violation: get <nil>, want <EOF>"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				if cs.s.StatusCode() == codes.OK {
0000000000000000000000000000000000000000;;					cs.finish(err)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return Errorf(cs.s.StatusCode(), "%s", cs.s.StatusDesc())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return toRPCErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := err.(transport.ConnectionError); !ok {
0000000000000000000000000000000000000000;;			cs.closeTransportStream(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			if cs.s.StatusCode() == codes.OK {
0000000000000000000000000000000000000000;;				// Returns io.EOF to indicate the end of the stream.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Errorf(cs.s.StatusCode(), "%s", cs.s.StatusDesc())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return toRPCErr(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) CloseSend() (err error) {
0000000000000000000000000000000000000000;;		err = cs.t.Write(cs.s, nil, &transport.Options{Last: true})
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cs.finish(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err == nil || err == io.EOF {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := err.(transport.ConnectionError); !ok {
0000000000000000000000000000000000000000;;			cs.closeTransportStream(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = toRPCErr(err)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) closeTransportStream(err error) {
0000000000000000000000000000000000000000;;		cs.mu.Lock()
0000000000000000000000000000000000000000;;		if cs.closed {
0000000000000000000000000000000000000000;;			cs.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs.closed = true
0000000000000000000000000000000000000000;;		cs.mu.Unlock()
0000000000000000000000000000000000000000;;		cs.t.CloseStream(cs.s, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) finish(err error) {
0000000000000000000000000000000000000000;;		cs.mu.Lock()
0000000000000000000000000000000000000000;;		defer cs.mu.Unlock()
0000000000000000000000000000000000000000;;		for _, o := range cs.opts {
0000000000000000000000000000000000000000;;			o.after(&cs.c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cs.put != nil {
0000000000000000000000000000000000000000;;			cs.put()
0000000000000000000000000000000000000000;;			cs.put = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cs.tracing {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cs.trInfo.tr != nil {
0000000000000000000000000000000000000000;;			if err == nil || err == io.EOF {
0000000000000000000000000000000000000000;;				cs.trInfo.tr.LazyPrintf("RPC: [OK]")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cs.trInfo.tr.LazyPrintf("RPC: [%v]", err)
0000000000000000000000000000000000000000;;				cs.trInfo.tr.SetError()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cs.trInfo.tr.Finish()
0000000000000000000000000000000000000000;;			cs.trInfo.tr = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerStream defines the interface a server stream has to satisfy.
0000000000000000000000000000000000000000;;	type ServerStream interface {
0000000000000000000000000000000000000000;;		// SetHeader sets the header metadata. It may be called multiple times.
0000000000000000000000000000000000000000;;		// When call multiple times, all the provided metadata will be merged.
0000000000000000000000000000000000000000;;		// All the metadata will be sent out when one of the following happens:
0000000000000000000000000000000000000000;;		//  - ServerStream.SendHeader() is called;
0000000000000000000000000000000000000000;;		//  - The first response is sent out;
0000000000000000000000000000000000000000;;		//  - An RPC status is sent out (error or success).
0000000000000000000000000000000000000000;;		SetHeader(metadata.MD) error
0000000000000000000000000000000000000000;;		// SendHeader sends the header metadata.
0000000000000000000000000000000000000000;;		// The provided md and headers set by SetHeader() will be sent.
0000000000000000000000000000000000000000;;		// It fails if called multiple times.
0000000000000000000000000000000000000000;;		SendHeader(metadata.MD) error
0000000000000000000000000000000000000000;;		// SetTrailer sets the trailer metadata which will be sent with the RPC status.
0000000000000000000000000000000000000000;;		// When called more than once, all the provided metadata will be merged.
0000000000000000000000000000000000000000;;		SetTrailer(metadata.MD)
0000000000000000000000000000000000000000;;		Stream
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serverStream implements a server side Stream.
0000000000000000000000000000000000000000;;	type serverStream struct {
0000000000000000000000000000000000000000;;		t          transport.ServerTransport
0000000000000000000000000000000000000000;;		s          *transport.Stream
0000000000000000000000000000000000000000;;		p          *parser
0000000000000000000000000000000000000000;;		codec      Codec
0000000000000000000000000000000000000000;;		cp         Compressor
0000000000000000000000000000000000000000;;		dc         Decompressor
0000000000000000000000000000000000000000;;		cbuf       *bytes.Buffer
0000000000000000000000000000000000000000;;		maxMsgSize int
0000000000000000000000000000000000000000;;		statusCode codes.Code
0000000000000000000000000000000000000000;;		statusDesc string
0000000000000000000000000000000000000000;;		trInfo     *traceInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.Mutex // protects trInfo.tr after the service handler runs.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *serverStream) Context() context.Context {
0000000000000000000000000000000000000000;;		return ss.s.Context()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *serverStream) SetHeader(md metadata.MD) error {
0000000000000000000000000000000000000000;;		if md.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ss.s.SetHeader(md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *serverStream) SendHeader(md metadata.MD) error {
0000000000000000000000000000000000000000;;		return ss.t.WriteHeader(ss.s, md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *serverStream) SetTrailer(md metadata.MD) {
0000000000000000000000000000000000000000;;		if md.Len() == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.s.SetTrailer(md)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *serverStream) SendMsg(m interface{}) (err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if ss.trInfo != nil {
0000000000000000000000000000000000000000;;				ss.mu.Lock()
0000000000000000000000000000000000000000;;				if ss.trInfo.tr != nil {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						ss.trInfo.tr.LazyLog(&payload{sent: true, msg: m}, true)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						ss.trInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;						ss.trInfo.tr.SetError()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ss.mu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		out, err := encode(ss.codec, m, ss.cp, ss.cbuf)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if ss.cbuf != nil {
0000000000000000000000000000000000000000;;				ss.cbuf.Reset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = Errorf(codes.Internal, "grpc: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ss.t.Write(ss.s, out, &transport.Options{Last: false}); err != nil {
0000000000000000000000000000000000000000;;			return toRPCErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *serverStream) RecvMsg(m interface{}) (err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if ss.trInfo != nil {
0000000000000000000000000000000000000000;;				ss.mu.Lock()
0000000000000000000000000000000000000000;;				if ss.trInfo.tr != nil {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						ss.trInfo.tr.LazyLog(&payload{sent: false, msg: m}, true)
0000000000000000000000000000000000000000;;					} else if err != io.EOF {
0000000000000000000000000000000000000000;;						ss.trInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;						ss.trInfo.tr.SetError()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ss.mu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err := recv(ss.p, ss.codec, ss.s, ss.dc, m, ss.maxMsgSize); err != nil {
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;				err = Errorf(codes.Internal, io.ErrUnexpectedEOF.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return toRPCErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
