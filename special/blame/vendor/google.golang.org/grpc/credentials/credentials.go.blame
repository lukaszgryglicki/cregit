0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/credentials/credentials.go[Godeps/_workspace/src/google.golang.org/grpc/credentials/credentials.go][vendor/google.golang.org/grpc/credentials/credentials.go];	
0000000000000000000000000000000000000000;;	// Package credentials implements various credentials supported by gRPC library,
0000000000000000000000000000000000000000;;	// which encapsulate all the state needed by a client to authenticate with a
0000000000000000000000000000000000000000;;	// server and make various assertions, e.g., about the client's identity, role,
0000000000000000000000000000000000000000;;	// or whether it is authorized to make a particular call.
0000000000000000000000000000000000000000;;	package credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// alpnProtoStr are the specified application level protocols for gRPC.
0000000000000000000000000000000000000000;;		alpnProtoStr = []string{"h2"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PerRPCCredentials defines the common interface for the credentials which need to
0000000000000000000000000000000000000000;;	// attach security information to every RPC (e.g., oauth2).
0000000000000000000000000000000000000000;;	type PerRPCCredentials interface {
0000000000000000000000000000000000000000;;		// GetRequestMetadata gets the current request metadata, refreshing
0000000000000000000000000000000000000000;;		// tokens if required. This should be called by the transport layer on
0000000000000000000000000000000000000000;;		// each request, and the data should be populated in headers or other
0000000000000000000000000000000000000000;;		// context. uri is the URI of the entry point for the request. When
0000000000000000000000000000000000000000;;		// supported by the underlying implementation, ctx can be used for
0000000000000000000000000000000000000000;;		// timeout and cancellation.
0000000000000000000000000000000000000000;;		// TODO(zhaoq): Define the set of the qualified keys instead of leaving
0000000000000000000000000000000000000000;;		// it as an arbitrary string.
0000000000000000000000000000000000000000;;		GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
0000000000000000000000000000000000000000;;		// RequireTransportSecurity indicates whether the credentials requires
0000000000000000000000000000000000000000;;		// transport security.
0000000000000000000000000000000000000000;;		RequireTransportSecurity() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProtocolInfo provides information regarding the gRPC wire protocol version,
0000000000000000000000000000000000000000;;	// security protocol, security protocol version in use, server name, etc.
0000000000000000000000000000000000000000;;	type ProtocolInfo struct {
0000000000000000000000000000000000000000;;		// ProtocolVersion is the gRPC wire protocol version.
0000000000000000000000000000000000000000;;		ProtocolVersion string
0000000000000000000000000000000000000000;;		// SecurityProtocol is the security protocol in use.
0000000000000000000000000000000000000000;;		SecurityProtocol string
0000000000000000000000000000000000000000;;		// SecurityVersion is the security protocol version.
0000000000000000000000000000000000000000;;		SecurityVersion string
0000000000000000000000000000000000000000;;		// ServerName is the user-configured server name.
0000000000000000000000000000000000000000;;		ServerName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthInfo defines the common interface for the auth information the users are interested in.
0000000000000000000000000000000000000000;;	type AuthInfo interface {
0000000000000000000000000000000000000000;;		AuthType() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrConnDispatched indicates that rawConn has been dispatched out of gRPC
0000000000000000000000000000000000000000;;		// and the caller should not close rawConn.
0000000000000000000000000000000000000000;;		ErrConnDispatched = errors.New("credentials: rawConn is dispatched out of gRPC")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransportCredentials defines the common interface for all the live gRPC wire
0000000000000000000000000000000000000000;;	// protocols and supported transport security protocols (e.g., TLS, SSL).
0000000000000000000000000000000000000000;;	type TransportCredentials interface {
0000000000000000000000000000000000000000;;		// ClientHandshake does the authentication handshake specified by the corresponding
0000000000000000000000000000000000000000;;		// authentication protocol on rawConn for clients. It returns the authenticated
0000000000000000000000000000000000000000;;		// connection and the corresponding auth information about the connection.
0000000000000000000000000000000000000000;;		// Implementations must use the provided context to implement timely cancellation.
0000000000000000000000000000000000000000;;		ClientHandshake(context.Context, string, net.Conn) (net.Conn, AuthInfo, error)
0000000000000000000000000000000000000000;;		// ServerHandshake does the authentication handshake for servers. It returns
0000000000000000000000000000000000000000;;		// the authenticated connection and the corresponding auth information about
0000000000000000000000000000000000000000;;		// the connection.
0000000000000000000000000000000000000000;;		ServerHandshake(net.Conn) (net.Conn, AuthInfo, error)
0000000000000000000000000000000000000000;;		// Info provides the ProtocolInfo of this TransportCredentials.
0000000000000000000000000000000000000000;;		Info() ProtocolInfo
0000000000000000000000000000000000000000;;		// Clone makes a copy of this TransportCredentials.
0000000000000000000000000000000000000000;;		Clone() TransportCredentials
0000000000000000000000000000000000000000;;		// OverrideServerName overrides the server name used to verify the hostname on the returned certificates from the server.
0000000000000000000000000000000000000000;;		// gRPC internals also use it to override the virtual hosting name if it is set.
0000000000000000000000000000000000000000;;		// It must be called before dialing. Currently, this is only used by grpclb.
0000000000000000000000000000000000000000;;		OverrideServerName(string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLSInfo contains the auth information for a TLS authenticated connection.
0000000000000000000000000000000000000000;;	// It implements the AuthInfo interface.
0000000000000000000000000000000000000000;;	type TLSInfo struct {
0000000000000000000000000000000000000000;;		State tls.ConnectionState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthType returns the type of TLSInfo as a string.
0000000000000000000000000000000000000000;;	func (t TLSInfo) AuthType() string {
0000000000000000000000000000000000000000;;		return "tls"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tlsCreds is the credentials required for authenticating a connection using TLS.
0000000000000000000000000000000000000000;;	type tlsCreds struct {
0000000000000000000000000000000000000000;;		// TLS configuration
0000000000000000000000000000000000000000;;		config *tls.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c tlsCreds) Info() ProtocolInfo {
0000000000000000000000000000000000000000;;		return ProtocolInfo{
0000000000000000000000000000000000000000;;			SecurityProtocol: "tls",
0000000000000000000000000000000000000000;;			SecurityVersion:  "1.2",
0000000000000000000000000000000000000000;;			ServerName:       c.config.ServerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *tlsCreds) ClientHandshake(ctx context.Context, addr string, rawConn net.Conn) (_ net.Conn, _ AuthInfo, err error) {
0000000000000000000000000000000000000000;;		// use local cfg to avoid clobbering ServerName if using multiple endpoints
0000000000000000000000000000000000000000;;		cfg := cloneTLSConfig(c.config)
0000000000000000000000000000000000000000;;		if cfg.ServerName == "" {
0000000000000000000000000000000000000000;;			colonPos := strings.LastIndex(addr, ":")
0000000000000000000000000000000000000000;;			if colonPos == -1 {
0000000000000000000000000000000000000000;;				colonPos = len(addr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cfg.ServerName = addr[:colonPos]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn := tls.Client(rawConn, cfg)
0000000000000000000000000000000000000000;;		errChannel := make(chan error, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			errChannel <- conn.Handshake()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errChannel:
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return nil, nil, ctx.Err()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(zhaoq): Omit the auth info for client now. It is more for
0000000000000000000000000000000000000000;;		// information than anything else.
0000000000000000000000000000000000000000;;		return conn, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *tlsCreds) ServerHandshake(rawConn net.Conn) (net.Conn, AuthInfo, error) {
0000000000000000000000000000000000000000;;		conn := tls.Server(rawConn, c.config)
0000000000000000000000000000000000000000;;		if err := conn.Handshake(); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, TLSInfo{conn.ConnectionState()}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *tlsCreds) Clone() TransportCredentials {
0000000000000000000000000000000000000000;;		return NewTLS(c.config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *tlsCreds) OverrideServerName(serverNameOverride string) error {
0000000000000000000000000000000000000000;;		c.config.ServerName = serverNameOverride
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTLS uses c to construct a TransportCredentials based on TLS.
0000000000000000000000000000000000000000;;	func NewTLS(c *tls.Config) TransportCredentials {
0000000000000000000000000000000000000000;;		tc := &tlsCreds{cloneTLSConfig(c)}
0000000000000000000000000000000000000000;;		tc.config.NextProtos = alpnProtoStr
0000000000000000000000000000000000000000;;		return tc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientTLSFromCert constructs a TLS from the input certificate for client.
0000000000000000000000000000000000000000;;	// serverNameOverride is for testing only. If set to a non empty string,
0000000000000000000000000000000000000000;;	// it will override the virtual host name of authority (e.g. :authority header field) in requests.
0000000000000000000000000000000000000000;;	func NewClientTLSFromCert(cp *x509.CertPool, serverNameOverride string) TransportCredentials {
0000000000000000000000000000000000000000;;		return NewTLS(&tls.Config{ServerName: serverNameOverride, RootCAs: cp})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientTLSFromFile constructs a TLS from the input certificate file for client.
0000000000000000000000000000000000000000;;	// serverNameOverride is for testing only. If set to a non empty string,
0000000000000000000000000000000000000000;;	// it will override the virtual host name of authority (e.g. :authority header field) in requests.
0000000000000000000000000000000000000000;;	func NewClientTLSFromFile(certFile, serverNameOverride string) (TransportCredentials, error) {
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadFile(certFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cp := x509.NewCertPool()
0000000000000000000000000000000000000000;;		if !cp.AppendCertsFromPEM(b) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("credentials: failed to append certificates")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewTLS(&tls.Config{ServerName: serverNameOverride, RootCAs: cp}), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerTLSFromCert constructs a TLS from the input certificate for server.
0000000000000000000000000000000000000000;;	func NewServerTLSFromCert(cert *tls.Certificate) TransportCredentials {
0000000000000000000000000000000000000000;;		return NewTLS(&tls.Config{Certificates: []tls.Certificate{*cert}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerTLSFromFile constructs a TLS from the input certificate file and key
0000000000000000000000000000000000000000;;	// file for server.
0000000000000000000000000000000000000000;;	func NewServerTLSFromFile(certFile, keyFile string) (TransportCredentials, error) {
0000000000000000000000000000000000000000;;		cert, err := tls.LoadX509KeyPair(certFile, keyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewTLS(&tls.Config{Certificates: []tls.Certificate{cert}}), nil
0000000000000000000000000000000000000000;;	}
