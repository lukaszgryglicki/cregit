0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/call.go[Godeps/_workspace/src/google.golang.org/grpc/call.go][vendor/google.golang.org/grpc/call.go];	
0000000000000000000000000000000000000000;;	package grpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/trace"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/transport"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recvResponse receives and parses an RPC response.
0000000000000000000000000000000000000000;;	// On error, it returns the error and indicates whether the call should be retried.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(zhaoq): Check whether the received message sequence is valid.
0000000000000000000000000000000000000000;;	func recvResponse(dopts dialOptions, t transport.ClientTransport, c *callInfo, stream *transport.Stream, reply interface{}) (err error) {
0000000000000000000000000000000000000000;;		// Try to acquire header metadata from the server if there is any.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if _, ok := err.(transport.ConnectionError); !ok {
0000000000000000000000000000000000000000;;					t.CloseStream(stream, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		c.headerMD, err = stream.Header()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := &parser{r: stream}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err = recv(p, dopts.codec, stream, dopts.dc, reply, math.MaxInt32); err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.trailerMD = stream.Trailer()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendRequest writes out various information of an RPC such as Context and Message.
0000000000000000000000000000000000000000;;	func sendRequest(ctx context.Context, codec Codec, compressor Compressor, callHdr *transport.CallHdr, t transport.ClientTransport, args interface{}, opts *transport.Options) (_ *transport.Stream, err error) {
0000000000000000000000000000000000000000;;		stream, err := t.NewStream(ctx, callHdr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// If err is connection error, t will be closed, no need to close stream here.
0000000000000000000000000000000000000000;;				if _, ok := err.(transport.ConnectionError); !ok {
0000000000000000000000000000000000000000;;					t.CloseStream(stream, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var cbuf *bytes.Buffer
0000000000000000000000000000000000000000;;		if compressor != nil {
0000000000000000000000000000000000000000;;			cbuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outBuf, err := encode(codec, args, compressor, cbuf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, Errorf(codes.Internal, "grpc: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = t.Write(stream, outBuf, opts)
0000000000000000000000000000000000000000;;		// t.NewStream(...) could lead to an early rejection of the RPC (e.g., the service/method
0000000000000000000000000000000000000000;;		// does not exist.) so that t.Write could get io.EOF from wait(...). Leave the following
0000000000000000000000000000000000000000;;		// recvResponse to get the final status.
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Sent successfully.
0000000000000000000000000000000000000000;;		return stream, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Invoke sends the RPC request on the wire and returns after response is received.
0000000000000000000000000000000000000000;;	// Invoke is called by generated code. Also users can call Invoke directly when it
0000000000000000000000000000000000000000;;	// is really needed in their use cases.
0000000000000000000000000000000000000000;;	func Invoke(ctx context.Context, method string, args, reply interface{}, cc *ClientConn, opts ...CallOption) error {
0000000000000000000000000000000000000000;;		if cc.dopts.unaryInt != nil {
0000000000000000000000000000000000000000;;			return cc.dopts.unaryInt(ctx, method, args, reply, cc, invoke, opts...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return invoke(ctx, method, args, reply, cc, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func invoke(ctx context.Context, method string, args, reply interface{}, cc *ClientConn, opts ...CallOption) (err error) {
0000000000000000000000000000000000000000;;		c := defaultCallInfo
0000000000000000000000000000000000000000;;		for _, o := range opts {
0000000000000000000000000000000000000000;;			if err := o.before(&c); err != nil {
0000000000000000000000000000000000000000;;				return toRPCErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			for _, o := range opts {
0000000000000000000000000000000000000000;;				o.after(&c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if EnableTracing {
0000000000000000000000000000000000000000;;			c.traceInfo.tr = trace.New("grpc.Sent."+methodFamily(method), method)
0000000000000000000000000000000000000000;;			defer c.traceInfo.tr.Finish()
0000000000000000000000000000000000000000;;			c.traceInfo.firstLine.client = true
0000000000000000000000000000000000000000;;			if deadline, ok := ctx.Deadline(); ok {
0000000000000000000000000000000000000000;;				c.traceInfo.firstLine.deadline = deadline.Sub(time.Now())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.traceInfo.tr.LazyLog(&c.traceInfo.firstLine, false)
0000000000000000000000000000000000000000;;			// TODO(dsymonds): Arrange for c.traceInfo.firstLine.remoteAddr to be set.
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					c.traceInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;					c.traceInfo.tr.SetError()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		topts := &transport.Options{
0000000000000000000000000000000000000000;;			Last:  true,
0000000000000000000000000000000000000000;;			Delay: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				err    error
0000000000000000000000000000000000000000;;				t      transport.ClientTransport
0000000000000000000000000000000000000000;;				stream *transport.Stream
0000000000000000000000000000000000000000;;				// Record the put handler from Balancer.Get(...). It is called once the
0000000000000000000000000000000000000000;;				// RPC has completed or failed.
0000000000000000000000000000000000000000;;				put func()
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			// TODO(zhaoq): Need a formal spec of fail-fast.
0000000000000000000000000000000000000000;;			callHdr := &transport.CallHdr{
0000000000000000000000000000000000000000;;				Host:   cc.authority,
0000000000000000000000000000000000000000;;				Method: method,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cc.dopts.cp != nil {
0000000000000000000000000000000000000000;;				callHdr.SendCompress = cc.dopts.cp.Type()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gopts := BalancerGetOptions{
0000000000000000000000000000000000000000;;				BlockingWait: !c.failFast,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t, put, err = cc.getTransport(ctx, gopts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO(zhaoq): Probably revisit the error handling.
0000000000000000000000000000000000000000;;				if _, ok := err.(*rpcError); ok {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == errConnClosing || err == errConnUnavailable {
0000000000000000000000000000000000000000;;					if c.failFast {
0000000000000000000000000000000000000000;;						return Errorf(codes.Unavailable, "%v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// All the other errors are treated as Internal errors.
0000000000000000000000000000000000000000;;				return Errorf(codes.Internal, "%v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.traceInfo.tr != nil {
0000000000000000000000000000000000000000;;				c.traceInfo.tr.LazyLog(&payload{sent: true, msg: args}, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stream, err = sendRequest(ctx, cc.dopts.codec, cc.dopts.cp, callHdr, t, args, topts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if put != nil {
0000000000000000000000000000000000000000;;					put()
0000000000000000000000000000000000000000;;					put = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Retry a non-failfast RPC when
0000000000000000000000000000000000000000;;				// i) there is a connection error; or
0000000000000000000000000000000000000000;;				// ii) the server started to drain before this RPC was initiated.
0000000000000000000000000000000000000000;;				if _, ok := err.(transport.ConnectionError); ok || err == transport.ErrStreamDrain {
0000000000000000000000000000000000000000;;					if c.failFast {
0000000000000000000000000000000000000000;;						return toRPCErr(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return toRPCErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = recvResponse(cc.dopts, t, &c, stream, reply)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if put != nil {
0000000000000000000000000000000000000000;;					put()
0000000000000000000000000000000000000000;;					put = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := err.(transport.ConnectionError); ok || err == transport.ErrStreamDrain {
0000000000000000000000000000000000000000;;					if c.failFast {
0000000000000000000000000000000000000000;;						return toRPCErr(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return toRPCErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.traceInfo.tr != nil {
0000000000000000000000000000000000000000;;				c.traceInfo.tr.LazyLog(&payload{sent: false, msg: reply}, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.CloseStream(stream, nil)
0000000000000000000000000000000000000000;;			if put != nil {
0000000000000000000000000000000000000000;;				put()
0000000000000000000000000000000000000000;;				put = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Errorf(stream.StatusCode(), "%s", stream.StatusDesc())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
