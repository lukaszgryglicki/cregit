0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2016, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	package grpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/naming"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Address represents a server the client connects to.
0000000000000000000000000000000000000000;;	// This is the EXPERIMENTAL API and may be changed or extended in the future.
0000000000000000000000000000000000000000;;	type Address struct {
0000000000000000000000000000000000000000;;		// Addr is the server address on which a connection will be established.
0000000000000000000000000000000000000000;;		Addr string
0000000000000000000000000000000000000000;;		// Metadata is the information associated with Addr, which may be used
0000000000000000000000000000000000000000;;		// to make load balancing decision.
0000000000000000000000000000000000000000;;		Metadata interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BalancerConfig specifies the configurations for Balancer.
0000000000000000000000000000000000000000;;	type BalancerConfig struct {
0000000000000000000000000000000000000000;;		// DialCreds is the transport credential the Balancer implementation can
0000000000000000000000000000000000000000;;		// use to dial to a remote load balancer server. The Balancer implementations
0000000000000000000000000000000000000000;;		// can ignore this if it does not need to talk to another party securely.
0000000000000000000000000000000000000000;;		DialCreds credentials.TransportCredentials
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BalancerGetOptions configures a Get call.
0000000000000000000000000000000000000000;;	// This is the EXPERIMENTAL API and may be changed or extended in the future.
0000000000000000000000000000000000000000;;	type BalancerGetOptions struct {
0000000000000000000000000000000000000000;;		// BlockingWait specifies whether Get should block when there is no
0000000000000000000000000000000000000000;;		// connected address.
0000000000000000000000000000000000000000;;		BlockingWait bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Balancer chooses network addresses for RPCs.
0000000000000000000000000000000000000000;;	// This is the EXPERIMENTAL API and may be changed or extended in the future.
0000000000000000000000000000000000000000;;	type Balancer interface {
0000000000000000000000000000000000000000;;		// Start does the initialization work to bootstrap a Balancer. For example,
0000000000000000000000000000000000000000;;		// this function may start the name resolution and watch the updates. It will
0000000000000000000000000000000000000000;;		// be called when dialing.
0000000000000000000000000000000000000000;;		Start(target string, config BalancerConfig) error
0000000000000000000000000000000000000000;;		// Up informs the Balancer that gRPC has a connection to the server at
0000000000000000000000000000000000000000;;		// addr. It returns down which is called once the connection to addr gets
0000000000000000000000000000000000000000;;		// lost or closed.
0000000000000000000000000000000000000000;;		// TODO: It is not clear how to construct and take advantage of the meaningful error
0000000000000000000000000000000000000000;;		// parameter for down. Need realistic demands to guide.
0000000000000000000000000000000000000000;;		Up(addr Address) (down func(error))
0000000000000000000000000000000000000000;;		// Get gets the address of a server for the RPC corresponding to ctx.
0000000000000000000000000000000000000000;;		// i) If it returns a connected address, gRPC internals issues the RPC on the
0000000000000000000000000000000000000000;;		// connection to this address;
0000000000000000000000000000000000000000;;		// ii) If it returns an address on which the connection is under construction
0000000000000000000000000000000000000000;;		// (initiated by Notify(...)) but not connected, gRPC internals
0000000000000000000000000000000000000000;;		//  * fails RPC if the RPC is fail-fast and connection is in the TransientFailure or
0000000000000000000000000000000000000000;;		//  Shutdown state;
0000000000000000000000000000000000000000;;		//  or
0000000000000000000000000000000000000000;;		//  * issues RPC on the connection otherwise.
0000000000000000000000000000000000000000;;		// iii) If it returns an address on which the connection does not exist, gRPC
0000000000000000000000000000000000000000;;		// internals treats it as an error and will fail the corresponding RPC.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Therefore, the following is the recommended rule when writing a custom Balancer.
0000000000000000000000000000000000000000;;		// If opts.BlockingWait is true, it should return a connected address or
0000000000000000000000000000000000000000;;		// block if there is no connected address. It should respect the timeout or
0000000000000000000000000000000000000000;;		// cancellation of ctx when blocking. If opts.BlockingWait is false (for fail-fast
0000000000000000000000000000000000000000;;		// RPCs), it should return an address it has notified via Notify(...) immediately
0000000000000000000000000000000000000000;;		// instead of blocking.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The function returns put which is called once the rpc has completed or failed.
0000000000000000000000000000000000000000;;		// put can collect and report RPC stats to a remote load balancer.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This function should only return the errors Balancer cannot recover by itself.
0000000000000000000000000000000000000000;;		// gRPC internals will fail the RPC if an error is returned.
0000000000000000000000000000000000000000;;		Get(ctx context.Context, opts BalancerGetOptions) (addr Address, put func(), err error)
0000000000000000000000000000000000000000;;		// Notify returns a channel that is used by gRPC internals to watch the addresses
0000000000000000000000000000000000000000;;		// gRPC needs to connect. The addresses might be from a name resolver or remote
0000000000000000000000000000000000000000;;		// load balancer. gRPC internals will compare it with the existing connected
0000000000000000000000000000000000000000;;		// addresses. If the address Balancer notified is not in the existing connected
0000000000000000000000000000000000000000;;		// addresses, gRPC starts to connect the address. If an address in the existing
0000000000000000000000000000000000000000;;		// connected addresses is not in the notification list, the corresponding connection
0000000000000000000000000000000000000000;;		// is shutdown gracefully. Otherwise, there are no operations to take. Note that
0000000000000000000000000000000000000000;;		// the Address slice must be the full list of the Addresses which should be connected.
0000000000000000000000000000000000000000;;		// It is NOT delta.
0000000000000000000000000000000000000000;;		Notify() <-chan []Address
0000000000000000000000000000000000000000;;		// Close shuts down the balancer.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// downErr implements net.Error. It is constructed by gRPC internals and passed to the down
0000000000000000000000000000000000000000;;	// call of Balancer.
0000000000000000000000000000000000000000;;	type downErr struct {
0000000000000000000000000000000000000000;;		timeout   bool
0000000000000000000000000000000000000000;;		temporary bool
0000000000000000000000000000000000000000;;		desc      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e downErr) Error() string   { return e.desc }
0000000000000000000000000000000000000000;;	func (e downErr) Timeout() bool   { return e.timeout }
0000000000000000000000000000000000000000;;	func (e downErr) Temporary() bool { return e.temporary }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func downErrorf(timeout, temporary bool, format string, a ...interface{}) downErr {
0000000000000000000000000000000000000000;;		return downErr{
0000000000000000000000000000000000000000;;			timeout:   timeout,
0000000000000000000000000000000000000000;;			temporary: temporary,
0000000000000000000000000000000000000000;;			desc:      fmt.Sprintf(format, a...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundRobin returns a Balancer that selects addresses round-robin. It uses r to watch
0000000000000000000000000000000000000000;;	// the name resolution updates and updates the addresses available correspondingly.
0000000000000000000000000000000000000000;;	func RoundRobin(r naming.Resolver) Balancer {
0000000000000000000000000000000000000000;;		return &roundRobin{r: r}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addrInfo struct {
0000000000000000000000000000000000000000;;		addr      Address
0000000000000000000000000000000000000000;;		connected bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type roundRobin struct {
0000000000000000000000000000000000000000;;		r      naming.Resolver
0000000000000000000000000000000000000000;;		w      naming.Watcher
0000000000000000000000000000000000000000;;		addrs  []*addrInfo // all the addresses the client should potentially connect
0000000000000000000000000000000000000000;;		mu     sync.Mutex
0000000000000000000000000000000000000000;;		addrCh chan []Address // the channel to notify gRPC internals the list of addresses the client should connect to.
0000000000000000000000000000000000000000;;		next   int            // index of the next address to return for Get()
0000000000000000000000000000000000000000;;		waitCh chan struct{}  // the channel to block when there is no connected address available
0000000000000000000000000000000000000000;;		done   bool           // The Balancer is closed.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *roundRobin) watchAddrUpdates() error {
0000000000000000000000000000000000000000;;		updates, err := rr.w.Next()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("grpc: the naming watcher stops working due to %v.\n", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.mu.Lock()
0000000000000000000000000000000000000000;;		defer rr.mu.Unlock()
0000000000000000000000000000000000000000;;		for _, update := range updates {
0000000000000000000000000000000000000000;;			addr := Address{
0000000000000000000000000000000000000000;;				Addr:     update.Addr,
0000000000000000000000000000000000000000;;				Metadata: update.Metadata,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch update.Op {
0000000000000000000000000000000000000000;;			case naming.Add:
0000000000000000000000000000000000000000;;				var exist bool
0000000000000000000000000000000000000000;;				for _, v := range rr.addrs {
0000000000000000000000000000000000000000;;					if addr == v.addr {
0000000000000000000000000000000000000000;;						exist = true
0000000000000000000000000000000000000000;;						grpclog.Println("grpc: The name resolver wanted to add an existing address: ", addr)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if exist {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rr.addrs = append(rr.addrs, &addrInfo{addr: addr})
0000000000000000000000000000000000000000;;			case naming.Delete:
0000000000000000000000000000000000000000;;				for i, v := range rr.addrs {
0000000000000000000000000000000000000000;;					if addr == v.addr {
0000000000000000000000000000000000000000;;						copy(rr.addrs[i:], rr.addrs[i+1:])
0000000000000000000000000000000000000000;;						rr.addrs = rr.addrs[:len(rr.addrs)-1]
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				grpclog.Println("Unknown update.Op ", update.Op)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make a copy of rr.addrs and write it onto rr.addrCh so that gRPC internals gets notified.
0000000000000000000000000000000000000000;;		open := make([]Address, len(rr.addrs))
0000000000000000000000000000000000000000;;		for i, v := range rr.addrs {
0000000000000000000000000000000000000000;;			open[i] = v.addr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.done {
0000000000000000000000000000000000000000;;			return ErrClientConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.addrCh <- open
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *roundRobin) Start(target string, config BalancerConfig) error {
0000000000000000000000000000000000000000;;		rr.mu.Lock()
0000000000000000000000000000000000000000;;		defer rr.mu.Unlock()
0000000000000000000000000000000000000000;;		if rr.done {
0000000000000000000000000000000000000000;;			return ErrClientConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.r == nil {
0000000000000000000000000000000000000000;;			// If there is no name resolver installed, it is not needed to
0000000000000000000000000000000000000000;;			// do name resolution. In this case, target is added into rr.addrs
0000000000000000000000000000000000000000;;			// as the only address available and rr.addrCh stays nil.
0000000000000000000000000000000000000000;;			rr.addrs = append(rr.addrs, &addrInfo{addr: Address{Addr: target}})
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w, err := rr.r.Resolve(target)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.w = w
0000000000000000000000000000000000000000;;		rr.addrCh = make(chan []Address)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if err := rr.watchAddrUpdates(); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Up sets the connected state of addr and sends notification if there are pending
0000000000000000000000000000000000000000;;	// Get() calls.
0000000000000000000000000000000000000000;;	func (rr *roundRobin) Up(addr Address) func(error) {
0000000000000000000000000000000000000000;;		rr.mu.Lock()
0000000000000000000000000000000000000000;;		defer rr.mu.Unlock()
0000000000000000000000000000000000000000;;		var cnt int
0000000000000000000000000000000000000000;;		for _, a := range rr.addrs {
0000000000000000000000000000000000000000;;			if a.addr == addr {
0000000000000000000000000000000000000000;;				if a.connected {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				a.connected = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a.connected {
0000000000000000000000000000000000000000;;				cnt++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// addr is only one which is connected. Notify the Get() callers who are blocking.
0000000000000000000000000000000000000000;;		if cnt == 1 && rr.waitCh != nil {
0000000000000000000000000000000000000000;;			close(rr.waitCh)
0000000000000000000000000000000000000000;;			rr.waitCh = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(err error) {
0000000000000000000000000000000000000000;;			rr.down(addr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// down unsets the connected state of addr.
0000000000000000000000000000000000000000;;	func (rr *roundRobin) down(addr Address, err error) {
0000000000000000000000000000000000000000;;		rr.mu.Lock()
0000000000000000000000000000000000000000;;		defer rr.mu.Unlock()
0000000000000000000000000000000000000000;;		for _, a := range rr.addrs {
0000000000000000000000000000000000000000;;			if addr == a.addr {
0000000000000000000000000000000000000000;;				a.connected = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the next addr in the rotation.
0000000000000000000000000000000000000000;;	func (rr *roundRobin) Get(ctx context.Context, opts BalancerGetOptions) (addr Address, put func(), err error) {
0000000000000000000000000000000000000000;;		var ch chan struct{}
0000000000000000000000000000000000000000;;		rr.mu.Lock()
0000000000000000000000000000000000000000;;		if rr.done {
0000000000000000000000000000000000000000;;			rr.mu.Unlock()
0000000000000000000000000000000000000000;;			err = ErrClientConnClosing
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rr.addrs) > 0 {
0000000000000000000000000000000000000000;;			if rr.next >= len(rr.addrs) {
0000000000000000000000000000000000000000;;				rr.next = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			next := rr.next
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				a := rr.addrs[next]
0000000000000000000000000000000000000000;;				next = (next + 1) % len(rr.addrs)
0000000000000000000000000000000000000000;;				if a.connected {
0000000000000000000000000000000000000000;;					addr = a.addr
0000000000000000000000000000000000000000;;					rr.next = next
0000000000000000000000000000000000000000;;					rr.mu.Unlock()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if next == rr.next {
0000000000000000000000000000000000000000;;					// Has iterated all the possible address but none is connected.
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !opts.BlockingWait {
0000000000000000000000000000000000000000;;			if len(rr.addrs) == 0 {
0000000000000000000000000000000000000000;;				rr.mu.Unlock()
0000000000000000000000000000000000000000;;				err = Errorf(codes.Unavailable, "there is no address available")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Returns the next addr on rr.addrs for failfast RPCs.
0000000000000000000000000000000000000000;;			addr = rr.addrs[rr.next].addr
0000000000000000000000000000000000000000;;			rr.next++
0000000000000000000000000000000000000000;;			rr.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait on rr.waitCh for non-failfast RPCs.
0000000000000000000000000000000000000000;;		if rr.waitCh == nil {
0000000000000000000000000000000000000000;;			ch = make(chan struct{})
0000000000000000000000000000000000000000;;			rr.waitCh = ch
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ch = rr.waitCh
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.mu.Unlock()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				err = ctx.Err()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-ch:
0000000000000000000000000000000000000000;;				rr.mu.Lock()
0000000000000000000000000000000000000000;;				if rr.done {
0000000000000000000000000000000000000000;;					rr.mu.Unlock()
0000000000000000000000000000000000000000;;					err = ErrClientConnClosing
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(rr.addrs) > 0 {
0000000000000000000000000000000000000000;;					if rr.next >= len(rr.addrs) {
0000000000000000000000000000000000000000;;						rr.next = 0
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					next := rr.next
0000000000000000000000000000000000000000;;					for {
0000000000000000000000000000000000000000;;						a := rr.addrs[next]
0000000000000000000000000000000000000000;;						next = (next + 1) % len(rr.addrs)
0000000000000000000000000000000000000000;;						if a.connected {
0000000000000000000000000000000000000000;;							addr = a.addr
0000000000000000000000000000000000000000;;							rr.next = next
0000000000000000000000000000000000000000;;							rr.mu.Unlock()
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if next == rr.next {
0000000000000000000000000000000000000000;;							// Has iterated all the possible address but none is connected.
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// The newly added addr got removed by Down() again.
0000000000000000000000000000000000000000;;				if rr.waitCh == nil {
0000000000000000000000000000000000000000;;					ch = make(chan struct{})
0000000000000000000000000000000000000000;;					rr.waitCh = ch
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ch = rr.waitCh
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rr.mu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *roundRobin) Notify() <-chan []Address {
0000000000000000000000000000000000000000;;		return rr.addrCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *roundRobin) Close() error {
0000000000000000000000000000000000000000;;		rr.mu.Lock()
0000000000000000000000000000000000000000;;		defer rr.mu.Unlock()
0000000000000000000000000000000000000000;;		rr.done = true
0000000000000000000000000000000000000000;;		if rr.w != nil {
0000000000000000000000000000000000000000;;			rr.w.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.waitCh != nil {
0000000000000000000000000000000000000000;;			close(rr.waitCh)
0000000000000000000000000000000000000000;;			rr.waitCh = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.addrCh != nil {
0000000000000000000000000000000000000000;;			close(rr.addrCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
