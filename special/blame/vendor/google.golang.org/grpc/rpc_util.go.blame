0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/rpc_util.go[Godeps/_workspace/src/google.golang.org/grpc/rpc_util.go][vendor/google.golang.org/grpc/rpc_util.go];	
0000000000000000000000000000000000000000;;	package grpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/transport"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Codec defines the interface gRPC uses to encode and decode messages.
0000000000000000000000000000000000000000;;	type Codec interface {
0000000000000000000000000000000000000000;;		// Marshal returns the wire format of v.
0000000000000000000000000000000000000000;;		Marshal(v interface{}) ([]byte, error)
0000000000000000000000000000000000000000;;		// Unmarshal parses the wire format into v.
0000000000000000000000000000000000000000;;		Unmarshal(data []byte, v interface{}) error
0000000000000000000000000000000000000000;;		// String returns the name of the Codec implementation. The returned
0000000000000000000000000000000000000000;;		// string will be used as part of content type in transmission.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// protoCodec is a Codec implementation with protobuf. It is the default codec for gRPC.
0000000000000000000000000000000000000000;;	type protoCodec struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (protoCodec) Marshal(v interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		return proto.Marshal(v.(proto.Message))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (protoCodec) Unmarshal(data []byte, v interface{}) error {
0000000000000000000000000000000000000000;;		return proto.Unmarshal(data, v.(proto.Message))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (protoCodec) String() string {
0000000000000000000000000000000000000000;;		return "proto"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compressor defines the interface gRPC uses to compress a message.
0000000000000000000000000000000000000000;;	type Compressor interface {
0000000000000000000000000000000000000000;;		// Do compresses p into w.
0000000000000000000000000000000000000000;;		Do(w io.Writer, p []byte) error
0000000000000000000000000000000000000000;;		// Type returns the compression algorithm the Compressor uses.
0000000000000000000000000000000000000000;;		Type() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGZIPCompressor creates a Compressor based on GZIP.
0000000000000000000000000000000000000000;;	func NewGZIPCompressor() Compressor {
0000000000000000000000000000000000000000;;		return &gzipCompressor{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type gzipCompressor struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *gzipCompressor) Do(w io.Writer, p []byte) error {
0000000000000000000000000000000000000000;;		z := gzip.NewWriter(w)
0000000000000000000000000000000000000000;;		if _, err := z.Write(p); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return z.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *gzipCompressor) Type() string {
0000000000000000000000000000000000000000;;		return "gzip"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decompressor defines the interface gRPC uses to decompress a message.
0000000000000000000000000000000000000000;;	type Decompressor interface {
0000000000000000000000000000000000000000;;		// Do reads the data from r and uncompress them.
0000000000000000000000000000000000000000;;		Do(r io.Reader) ([]byte, error)
0000000000000000000000000000000000000000;;		// Type returns the compression algorithm the Decompressor uses.
0000000000000000000000000000000000000000;;		Type() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type gzipDecompressor struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGZIPDecompressor creates a Decompressor based on GZIP.
0000000000000000000000000000000000000000;;	func NewGZIPDecompressor() Decompressor {
0000000000000000000000000000000000000000;;		return &gzipDecompressor{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *gzipDecompressor) Do(r io.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		z, err := gzip.NewReader(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer z.Close()
0000000000000000000000000000000000000000;;		return ioutil.ReadAll(z)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *gzipDecompressor) Type() string {
0000000000000000000000000000000000000000;;		return "gzip"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// callInfo contains all related configuration and information about an RPC.
0000000000000000000000000000000000000000;;	type callInfo struct {
0000000000000000000000000000000000000000;;		failFast  bool
0000000000000000000000000000000000000000;;		headerMD  metadata.MD
0000000000000000000000000000000000000000;;		trailerMD metadata.MD
0000000000000000000000000000000000000000;;		traceInfo traceInfo // in trace.go
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultCallInfo = callInfo{failFast: true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CallOption configures a Call before it starts or extracts information from
0000000000000000000000000000000000000000;;	// a Call after it completes.
0000000000000000000000000000000000000000;;	type CallOption interface {
0000000000000000000000000000000000000000;;		// before is called before the call is sent to any server.  If before
0000000000000000000000000000000000000000;;		// returns a non-nil error, the RPC fails with that error.
0000000000000000000000000000000000000000;;		before(*callInfo) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// after is called after the call has completed.  after cannot return an
0000000000000000000000000000000000000000;;		// error, so any failures should be reported via output parameters.
0000000000000000000000000000000000000000;;		after(*callInfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type beforeCall func(c *callInfo) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o beforeCall) before(c *callInfo) error { return o(c) }
0000000000000000000000000000000000000000;;	func (o beforeCall) after(c *callInfo)        {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type afterCall func(c *callInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o afterCall) before(c *callInfo) error { return nil }
0000000000000000000000000000000000000000;;	func (o afterCall) after(c *callInfo)        { o(c) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header returns a CallOptions that retrieves the header metadata
0000000000000000000000000000000000000000;;	// for a unary RPC.
0000000000000000000000000000000000000000;;	func Header(md *metadata.MD) CallOption {
0000000000000000000000000000000000000000;;		return afterCall(func(c *callInfo) {
0000000000000000000000000000000000000000;;			*md = c.headerMD
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Trailer returns a CallOptions that retrieves the trailer metadata
0000000000000000000000000000000000000000;;	// for a unary RPC.
0000000000000000000000000000000000000000;;	func Trailer(md *metadata.MD) CallOption {
0000000000000000000000000000000000000000;;		return afterCall(func(c *callInfo) {
0000000000000000000000000000000000000000;;			*md = c.trailerMD
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FailFast configures the action to take when an RPC is attempted on broken
0000000000000000000000000000000000000000;;	// connections or unreachable servers. If failfast is true, the RPC will fail
0000000000000000000000000000000000000000;;	// immediately. Otherwise, the RPC client will block the call until a
0000000000000000000000000000000000000000;;	// connection is available (or the call is canceled or times out) and will retry
0000000000000000000000000000000000000000;;	// the call if it fails due to a transient error. Please refer to
0000000000000000000000000000000000000000;;	// https://github.com/grpc/grpc/blob/master/doc/fail_fast.md
0000000000000000000000000000000000000000;;	func FailFast(failFast bool) CallOption {
0000000000000000000000000000000000000000;;		return beforeCall(func(c *callInfo) error {
0000000000000000000000000000000000000000;;			c.failFast = failFast
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The format of the payload: compressed or not?
0000000000000000000000000000000000000000;;	type payloadFormat uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		compressionNone payloadFormat = iota // no compression
0000000000000000000000000000000000000000;;		compressionMade
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parser reads complete gRPC messages from the underlying reader.
0000000000000000000000000000000000000000;;	type parser struct {
0000000000000000000000000000000000000000;;		// r is the underlying reader.
0000000000000000000000000000000000000000;;		// See the comment on recvMsg for the permissible
0000000000000000000000000000000000000000;;		// error types.
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The header of a gRPC message. Find more detail
0000000000000000000000000000000000000000;;		// at http://www.grpc.io/docs/guides/wire.html.
0000000000000000000000000000000000000000;;		header [5]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recvMsg reads a complete gRPC message from the stream.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It returns the message and its payload (compression/encoding)
0000000000000000000000000000000000000000;;	// format. The caller owns the returned msg memory.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If there is an error, possible values are:
0000000000000000000000000000000000000000;;	//   * io.EOF, when no messages remain
0000000000000000000000000000000000000000;;	//   * io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;	//   * of type transport.ConnectionError
0000000000000000000000000000000000000000;;	//   * of type transport.StreamError
0000000000000000000000000000000000000000;;	// No other error values or types must be returned, which also means
0000000000000000000000000000000000000000;;	// that the underlying io.Reader must not return an incompatible
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func (p *parser) recvMsg(maxMsgSize int) (pf payloadFormat, msg []byte, err error) {
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(p.r, p.header[:]); err != nil {
0000000000000000000000000000000000000000;;			return 0, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pf = payloadFormat(p.header[0])
0000000000000000000000000000000000000000;;		length := binary.BigEndian.Uint32(p.header[1:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if length == 0 {
0000000000000000000000000000000000000000;;			return pf, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if length > uint32(maxMsgSize) {
0000000000000000000000000000000000000000;;			return 0, nil, Errorf(codes.Internal, "grpc: received message length %d exceeding the max size %d", length, maxMsgSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(bradfitz,zhaoq): garbage. reuse buffer after proto decoding instead
0000000000000000000000000000000000000000;;		// of making it for each message:
0000000000000000000000000000000000000000;;		msg = make([]byte, int(length))
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(p.r, msg); err != nil {
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pf, msg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encode serializes msg and prepends the message header. If msg is nil, it
0000000000000000000000000000000000000000;;	// generates the message header of 0 message length.
0000000000000000000000000000000000000000;;	func encode(c Codec, msg interface{}, cp Compressor, cbuf *bytes.Buffer) ([]byte, error) {
0000000000000000000000000000000000000000;;		var b []byte
0000000000000000000000000000000000000000;;		var length uint
0000000000000000000000000000000000000000;;		if msg != nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			// TODO(zhaoq): optimize to reduce memory alloc and copying.
0000000000000000000000000000000000000000;;			b, err = c.Marshal(msg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cp != nil {
0000000000000000000000000000000000000000;;				if err := cp.Do(cbuf, b); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b = cbuf.Bytes()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			length = uint(len(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if length > math.MaxUint32 {
0000000000000000000000000000000000000000;;			return nil, Errorf(codes.InvalidArgument, "grpc: message too large (%d bytes)", length)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			payloadLen = 1
0000000000000000000000000000000000000000;;			sizeLen    = 4
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf = make([]byte, payloadLen+sizeLen+len(b))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write payload format
0000000000000000000000000000000000000000;;		if cp == nil {
0000000000000000000000000000000000000000;;			buf[0] = byte(compressionNone)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			buf[0] = byte(compressionMade)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Write length of b into buf
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(buf[1:], uint32(length))
0000000000000000000000000000000000000000;;		// Copy encoded msg to buf
0000000000000000000000000000000000000000;;		copy(buf[5:], b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkRecvPayload(pf payloadFormat, recvCompress string, dc Decompressor) error {
0000000000000000000000000000000000000000;;		switch pf {
0000000000000000000000000000000000000000;;		case compressionNone:
0000000000000000000000000000000000000000;;		case compressionMade:
0000000000000000000000000000000000000000;;			if dc == nil || recvCompress != dc.Type() {
0000000000000000000000000000000000000000;;				return Errorf(codes.Unimplemented, "grpc: Decompressor is not installed for grpc-encoding %q", recvCompress)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return Errorf(codes.Internal, "grpc: received unexpected payload format %d", pf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recv(p *parser, c Codec, s *transport.Stream, dc Decompressor, m interface{}, maxMsgSize int) error {
0000000000000000000000000000000000000000;;		pf, d, err := p.recvMsg(maxMsgSize)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkRecvPayload(pf, s.RecvCompress(), dc); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pf == compressionMade {
0000000000000000000000000000000000000000;;			d, err = dc.Do(bytes.NewReader(d))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return Errorf(codes.Internal, "grpc: failed to decompress the received message %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(d) > maxMsgSize {
0000000000000000000000000000000000000000;;			// TODO: Revisit the error code. Currently keep it consistent with java
0000000000000000000000000000000000000000;;			// implementation.
0000000000000000000000000000000000000000;;			return Errorf(codes.Internal, "grpc: received a message of %d bytes exceeding %d limit", len(d), maxMsgSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.Unmarshal(d, m); err != nil {
0000000000000000000000000000000000000000;;			return Errorf(codes.Internal, "grpc: failed to unmarshal the received message %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rpcError defines the status from an RPC.
0000000000000000000000000000000000000000;;	type rpcError struct {
0000000000000000000000000000000000000000;;		code codes.Code
0000000000000000000000000000000000000000;;		desc string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *rpcError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("rpc error: code = %d desc = %s", e.code, e.desc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Code returns the error code for err if it was produced by the rpc system.
0000000000000000000000000000000000000000;;	// Otherwise, it returns codes.Unknown.
0000000000000000000000000000000000000000;;	func Code(err error) codes.Code {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return codes.OK
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, ok := err.(*rpcError); ok {
0000000000000000000000000000000000000000;;			return e.code
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return codes.Unknown
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorDesc returns the error description of err if it was produced by the rpc system.
0000000000000000000000000000000000000000;;	// Otherwise, it returns err.Error() or empty string when err is nil.
0000000000000000000000000000000000000000;;	func ErrorDesc(err error) string {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, ok := err.(*rpcError); ok {
0000000000000000000000000000000000000000;;			return e.desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errorf returns an error containing an error code and a description;
0000000000000000000000000000000000000000;;	// Errorf returns nil if c is OK.
0000000000000000000000000000000000000000;;	func Errorf(c codes.Code, format string, a ...interface{}) error {
0000000000000000000000000000000000000000;;		if c == codes.OK {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &rpcError{
0000000000000000000000000000000000000000;;			code: c,
0000000000000000000000000000000000000000;;			desc: fmt.Sprintf(format, a...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toRPCErr converts an error into a rpcError.
0000000000000000000000000000000000000000;;	func toRPCErr(err error) error {
0000000000000000000000000000000000000000;;		switch e := err.(type) {
0000000000000000000000000000000000000000;;		case *rpcError:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		case transport.StreamError:
0000000000000000000000000000000000000000;;			return &rpcError{
0000000000000000000000000000000000000000;;				code: e.Code,
0000000000000000000000000000000000000000;;				desc: e.Desc,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case transport.ConnectionError:
0000000000000000000000000000000000000000;;			return &rpcError{
0000000000000000000000000000000000000000;;				code: codes.Internal,
0000000000000000000000000000000000000000;;				desc: e.Desc,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch err {
0000000000000000000000000000000000000000;;			case context.DeadlineExceeded:
0000000000000000000000000000000000000000;;				return &rpcError{
0000000000000000000000000000000000000000;;					code: codes.DeadlineExceeded,
0000000000000000000000000000000000000000;;					desc: err.Error(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case context.Canceled:
0000000000000000000000000000000000000000;;				return &rpcError{
0000000000000000000000000000000000000000;;					code: codes.Canceled,
0000000000000000000000000000000000000000;;					desc: err.Error(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ErrClientConnClosing:
0000000000000000000000000000000000000000;;				return &rpcError{
0000000000000000000000000000000000000000;;					code: codes.FailedPrecondition,
0000000000000000000000000000000000000000;;					desc: err.Error(),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Errorf(codes.Unknown, "%v", err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertCode converts a standard Go error into its canonical code. Note that
0000000000000000000000000000000000000000;;	// this is only used to translate the error returned by the server applications.
0000000000000000000000000000000000000000;;	func convertCode(err error) codes.Code {
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			return codes.OK
0000000000000000000000000000000000000000;;		case io.EOF:
0000000000000000000000000000000000000000;;			return codes.OutOfRange
0000000000000000000000000000000000000000;;		case io.ErrClosedPipe, io.ErrNoProgress, io.ErrShortBuffer, io.ErrShortWrite, io.ErrUnexpectedEOF:
0000000000000000000000000000000000000000;;			return codes.FailedPrecondition
0000000000000000000000000000000000000000;;		case os.ErrInvalid:
0000000000000000000000000000000000000000;;			return codes.InvalidArgument
0000000000000000000000000000000000000000;;		case context.Canceled:
0000000000000000000000000000000000000000;;			return codes.Canceled
0000000000000000000000000000000000000000;;		case context.DeadlineExceeded:
0000000000000000000000000000000000000000;;			return codes.DeadlineExceeded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case os.IsExist(err):
0000000000000000000000000000000000000000;;			return codes.AlreadyExists
0000000000000000000000000000000000000000;;		case os.IsNotExist(err):
0000000000000000000000000000000000000000;;			return codes.NotFound
0000000000000000000000000000000000000000;;		case os.IsPermission(err):
0000000000000000000000000000000000000000;;			return codes.PermissionDenied
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return codes.Unknown
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportPackageIsVersion4 is referenced from generated protocol buffer files
0000000000000000000000000000000000000000;;	// to assert that that code is compatible with this version of the grpc package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This constant may be renamed in the future if a change in the generated code
0000000000000000000000000000000000000000;;	// requires a synchronised update of grpc-go and protoc-gen-go. This constant
0000000000000000000000000000000000000000;;	// should not be referenced from any other code.
0000000000000000000000000000000000000000;;	const SupportPackageIsVersion4 = true
