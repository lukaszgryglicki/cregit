0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/server.go[Godeps/_workspace/src/google.golang.org/grpc/server.go][vendor/google.golang.org/grpc/server.go];	
0000000000000000000000000000000000000000;;	package grpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2"
0000000000000000000000000000000000000000;;		"golang.org/x/net/trace"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/internal"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/transport"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type methodHandler func(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor UnaryServerInterceptor) (interface{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MethodDesc represents an RPC service's method specification.
0000000000000000000000000000000000000000;;	type MethodDesc struct {
0000000000000000000000000000000000000000;;		MethodName string
0000000000000000000000000000000000000000;;		Handler    methodHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceDesc represents an RPC service's specification.
0000000000000000000000000000000000000000;;	type ServiceDesc struct {
0000000000000000000000000000000000000000;;		ServiceName string
0000000000000000000000000000000000000000;;		// The pointer to the service interface. Used to check whether the user
0000000000000000000000000000000000000000;;		// provided implementation satisfies the interface requirements.
0000000000000000000000000000000000000000;;		HandlerType interface{}
0000000000000000000000000000000000000000;;		Methods     []MethodDesc
0000000000000000000000000000000000000000;;		Streams     []StreamDesc
0000000000000000000000000000000000000000;;		Metadata    interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// service consists of the information of the server serving this service and
0000000000000000000000000000000000000000;;	// the methods in this service.
0000000000000000000000000000000000000000;;	type service struct {
0000000000000000000000000000000000000000;;		server interface{} // the server for service methods
0000000000000000000000000000000000000000;;		md     map[string]*MethodDesc
0000000000000000000000000000000000000000;;		sd     map[string]*StreamDesc
0000000000000000000000000000000000000000;;		mdata  interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server is a gRPC server to serve RPC requests.
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		opts options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu     sync.Mutex // guards following
0000000000000000000000000000000000000000;;		lis    map[net.Listener]bool
0000000000000000000000000000000000000000;;		conns  map[io.Closer]bool
0000000000000000000000000000000000000000;;		drain  bool
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;		// A CondVar to let GracefulStop() blocks until all the pending RPCs are finished
0000000000000000000000000000000000000000;;		// and all the transport goes away.
0000000000000000000000000000000000000000;;		cv     *sync.Cond
0000000000000000000000000000000000000000;;		m      map[string]*service // service name -> service info
0000000000000000000000000000000000000000;;		events trace.EventLog
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type options struct {
0000000000000000000000000000000000000000;;		creds                credentials.TransportCredentials
0000000000000000000000000000000000000000;;		codec                Codec
0000000000000000000000000000000000000000;;		cp                   Compressor
0000000000000000000000000000000000000000;;		dc                   Decompressor
0000000000000000000000000000000000000000;;		maxMsgSize           int
0000000000000000000000000000000000000000;;		unaryInt             UnaryServerInterceptor
0000000000000000000000000000000000000000;;		streamInt            StreamServerInterceptor
0000000000000000000000000000000000000000;;		maxConcurrentStreams uint32
0000000000000000000000000000000000000000;;		useHandlerImpl       bool // use http.Handler-based server
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultMaxMsgSize = 1024 * 1024 * 4 // use 4MB as the default message size limit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ServerOption sets options.
0000000000000000000000000000000000000000;;	type ServerOption func(*options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CustomCodec returns a ServerOption that sets a codec for message marshaling and unmarshaling.
0000000000000000000000000000000000000000;;	func CustomCodec(codec Codec) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			o.codec = codec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RPCCompressor returns a ServerOption that sets a compressor for outbound messages.
0000000000000000000000000000000000000000;;	func RPCCompressor(cp Compressor) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			o.cp = cp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RPCDecompressor returns a ServerOption that sets a decompressor for inbound messages.
0000000000000000000000000000000000000000;;	func RPCDecompressor(dc Decompressor) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			o.dc = dc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxMsgSize returns a ServerOption to set the max message size in bytes for inbound mesages.
0000000000000000000000000000000000000000;;	// If this is not set, gRPC uses the default 4MB.
0000000000000000000000000000000000000000;;	func MaxMsgSize(m int) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			o.maxMsgSize = m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxConcurrentStreams returns a ServerOption that will apply a limit on the number
0000000000000000000000000000000000000000;;	// of concurrent streams to each ServerTransport.
0000000000000000000000000000000000000000;;	func MaxConcurrentStreams(n uint32) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			o.maxConcurrentStreams = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creds returns a ServerOption that sets credentials for server connections.
0000000000000000000000000000000000000000;;	func Creds(c credentials.TransportCredentials) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			o.creds = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnaryInterceptor returns a ServerOption that sets the UnaryServerInterceptor for the
0000000000000000000000000000000000000000;;	// server. Only one unary interceptor can be installed. The construction of multiple
0000000000000000000000000000000000000000;;	// interceptors (e.g., chaining) can be implemented at the caller.
0000000000000000000000000000000000000000;;	func UnaryInterceptor(i UnaryServerInterceptor) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			if o.unaryInt != nil {
0000000000000000000000000000000000000000;;				panic("The unary server interceptor has been set.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.unaryInt = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamInterceptor returns a ServerOption that sets the StreamServerInterceptor for the
0000000000000000000000000000000000000000;;	// server. Only one stream interceptor can be installed.
0000000000000000000000000000000000000000;;	func StreamInterceptor(i StreamServerInterceptor) ServerOption {
0000000000000000000000000000000000000000;;		return func(o *options) {
0000000000000000000000000000000000000000;;			if o.streamInt != nil {
0000000000000000000000000000000000000000;;				panic("The stream server interceptor has been set.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.streamInt = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServer creates a gRPC server which has no service registered and has not
0000000000000000000000000000000000000000;;	// started to accept requests yet.
0000000000000000000000000000000000000000;;	func NewServer(opt ...ServerOption) *Server {
0000000000000000000000000000000000000000;;		var opts options
0000000000000000000000000000000000000000;;		opts.maxMsgSize = defaultMaxMsgSize
0000000000000000000000000000000000000000;;		for _, o := range opt {
0000000000000000000000000000000000000000;;			o(&opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.codec == nil {
0000000000000000000000000000000000000000;;			// Set the default codec.
0000000000000000000000000000000000000000;;			opts.codec = protoCodec{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := &Server{
0000000000000000000000000000000000000000;;			lis:   make(map[net.Listener]bool),
0000000000000000000000000000000000000000;;			opts:  opts,
0000000000000000000000000000000000000000;;			conns: make(map[io.Closer]bool),
0000000000000000000000000000000000000000;;			m:     make(map[string]*service),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.cv = sync.NewCond(&s.mu)
0000000000000000000000000000000000000000;;		s.ctx, s.cancel = context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		if EnableTracing {
0000000000000000000000000000000000000000;;			_, file, line, _ := runtime.Caller(1)
0000000000000000000000000000000000000000;;			s.events = trace.NewEventLog("grpc.Server", fmt.Sprintf("%s:%d", file, line))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printf records an event in s's event log, unless s has been stopped.
0000000000000000000000000000000000000000;;	// REQUIRES s.mu is held.
0000000000000000000000000000000000000000;;	func (s *Server) printf(format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		if s.events != nil {
0000000000000000000000000000000000000000;;			s.events.Printf(format, a...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errorf records an error in s's event log, unless s has been stopped.
0000000000000000000000000000000000000000;;	// REQUIRES s.mu is held.
0000000000000000000000000000000000000000;;	func (s *Server) errorf(format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		if s.events != nil {
0000000000000000000000000000000000000000;;			s.events.Errorf(format, a...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterService register a service and its implementation to the gRPC
0000000000000000000000000000000000000000;;	// server. Called from the IDL generated code. This must be called before
0000000000000000000000000000000000000000;;	// invoking Serve.
0000000000000000000000000000000000000000;;	func (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {
0000000000000000000000000000000000000000;;		ht := reflect.TypeOf(sd.HandlerType).Elem()
0000000000000000000000000000000000000000;;		st := reflect.TypeOf(ss)
0000000000000000000000000000000000000000;;		if !st.Implements(ht) {
0000000000000000000000000000000000000000;;			grpclog.Fatalf("grpc: Server.RegisterService found the handler of type %v that does not satisfy %v", st, ht)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.register(sd, ss)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) register(sd *ServiceDesc, ss interface{}) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		s.printf("RegisterService(%q)", sd.ServiceName)
0000000000000000000000000000000000000000;;		if _, ok := s.m[sd.ServiceName]; ok {
0000000000000000000000000000000000000000;;			grpclog.Fatalf("grpc: Server.RegisterService found duplicate service registration for %q", sd.ServiceName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv := &service{
0000000000000000000000000000000000000000;;			server: ss,
0000000000000000000000000000000000000000;;			md:     make(map[string]*MethodDesc),
0000000000000000000000000000000000000000;;			sd:     make(map[string]*StreamDesc),
0000000000000000000000000000000000000000;;			mdata:  sd.Metadata,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range sd.Methods {
0000000000000000000000000000000000000000;;			d := &sd.Methods[i]
0000000000000000000000000000000000000000;;			srv.md[d.MethodName] = d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range sd.Streams {
0000000000000000000000000000000000000000;;			d := &sd.Streams[i]
0000000000000000000000000000000000000000;;			srv.sd[d.StreamName] = d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.m[sd.ServiceName] = srv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MethodInfo contains the information of an RPC including its method name and type.
0000000000000000000000000000000000000000;;	type MethodInfo struct {
0000000000000000000000000000000000000000;;		// Name is the method name only, without the service name or package name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// IsClientStream indicates whether the RPC is a client streaming RPC.
0000000000000000000000000000000000000000;;		IsClientStream bool
0000000000000000000000000000000000000000;;		// IsServerStream indicates whether the RPC is a server streaming RPC.
0000000000000000000000000000000000000000;;		IsServerStream bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceInfo contains unary RPC method info, streaming RPC methid info and metadata for a service.
0000000000000000000000000000000000000000;;	type ServiceInfo struct {
0000000000000000000000000000000000000000;;		Methods []MethodInfo
0000000000000000000000000000000000000000;;		// Metadata is the metadata specified in ServiceDesc when registering service.
0000000000000000000000000000000000000000;;		Metadata interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetServiceInfo returns a map from service names to ServiceInfo.
0000000000000000000000000000000000000000;;	// Service names include the package names, in the form of <package>.<service>.
0000000000000000000000000000000000000000;;	func (s *Server) GetServiceInfo() map[string]ServiceInfo {
0000000000000000000000000000000000000000;;		ret := make(map[string]ServiceInfo)
0000000000000000000000000000000000000000;;		for n, srv := range s.m {
0000000000000000000000000000000000000000;;			methods := make([]MethodInfo, 0, len(srv.md)+len(srv.sd))
0000000000000000000000000000000000000000;;			for m := range srv.md {
0000000000000000000000000000000000000000;;				methods = append(methods, MethodInfo{
0000000000000000000000000000000000000000;;					Name:           m,
0000000000000000000000000000000000000000;;					IsClientStream: false,
0000000000000000000000000000000000000000;;					IsServerStream: false,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for m, d := range srv.sd {
0000000000000000000000000000000000000000;;				methods = append(methods, MethodInfo{
0000000000000000000000000000000000000000;;					Name:           m,
0000000000000000000000000000000000000000;;					IsClientStream: d.ClientStreams,
0000000000000000000000000000000000000000;;					IsServerStream: d.ServerStreams,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret[n] = ServiceInfo{
0000000000000000000000000000000000000000;;				Methods:  methods,
0000000000000000000000000000000000000000;;				Metadata: srv.mdata,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrServerStopped indicates that the operation is now illegal because of
0000000000000000000000000000000000000000;;		// the server being stopped.
0000000000000000000000000000000000000000;;		ErrServerStopped = errors.New("grpc: the server has been stopped")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) useTransportAuthenticator(rawConn net.Conn) (net.Conn, credentials.AuthInfo, error) {
0000000000000000000000000000000000000000;;		if s.opts.creds == nil {
0000000000000000000000000000000000000000;;			return rawConn, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.opts.creds.ServerHandshake(rawConn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serve accepts incoming connections on the listener lis, creating a new
0000000000000000000000000000000000000000;;	// ServerTransport and service goroutine for each. The service goroutines
0000000000000000000000000000000000000000;;	// read gRPC requests and then call the registered handlers to reply to them.
0000000000000000000000000000000000000000;;	// Serve returns when lis.Accept fails with fatal errors.  lis will be closed when
0000000000000000000000000000000000000000;;	// this method returns.
0000000000000000000000000000000000000000;;	func (s *Server) Serve(lis net.Listener) error {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		s.printf("serving")
0000000000000000000000000000000000000000;;		if s.lis == nil {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			lis.Close()
0000000000000000000000000000000000000000;;			return ErrServerStopped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.lis[lis] = true
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			if s.lis != nil && s.lis[lis] {
0000000000000000000000000000000000000000;;				lis.Close()
0000000000000000000000000000000000000000;;				delete(s.lis, lis)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tempDelay time.Duration // how long to sleep on accept failure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			rawConn, err := lis.Accept()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if ne, ok := err.(interface {
0000000000000000000000000000000000000000;;					Temporary() bool
0000000000000000000000000000000000000000;;				}); ok && ne.Temporary() {
0000000000000000000000000000000000000000;;					if tempDelay == 0 {
0000000000000000000000000000000000000000;;						tempDelay = 5 * time.Millisecond
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						tempDelay *= 2
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if max := 1 * time.Second; tempDelay > max {
0000000000000000000000000000000000000000;;						tempDelay = max
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					s.mu.Lock()
0000000000000000000000000000000000000000;;					s.printf("Accept error: %v; retrying in %v", err, tempDelay)
0000000000000000000000000000000000000000;;					s.mu.Unlock()
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case <-time.After(tempDelay):
0000000000000000000000000000000000000000;;					case <-s.ctx.Done():
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.mu.Lock()
0000000000000000000000000000000000000000;;				s.printf("done serving; Accept = %v", err)
0000000000000000000000000000000000000000;;				s.mu.Unlock()
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tempDelay = 0
0000000000000000000000000000000000000000;;			// Start a new goroutine to deal with rawConn
0000000000000000000000000000000000000000;;			// so we don't stall this Accept loop goroutine.
0000000000000000000000000000000000000000;;			go s.handleRawConn(rawConn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleRawConn is run in its own goroutine and handles a just-accepted
0000000000000000000000000000000000000000;;	// connection that has not had any I/O performed on it yet.
0000000000000000000000000000000000000000;;	func (s *Server) handleRawConn(rawConn net.Conn) {
0000000000000000000000000000000000000000;;		conn, authInfo, err := s.useTransportAuthenticator(rawConn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			s.errorf("ServerHandshake(%q) failed: %v", rawConn.RemoteAddr(), err)
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			grpclog.Printf("grpc: Server.Serve failed to complete security handshake from %q: %v", rawConn.RemoteAddr(), err)
0000000000000000000000000000000000000000;;			// If serverHandShake returns ErrConnDispatched, keep rawConn open.
0000000000000000000000000000000000000000;;			if err != credentials.ErrConnDispatched {
0000000000000000000000000000000000000000;;				rawConn.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		if s.conns == nil {
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.opts.useHandlerImpl {
0000000000000000000000000000000000000000;;			s.serveUsingHandler(conn)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.serveNewHTTP2Transport(conn, authInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveNewHTTP2Transport sets up a new http/2 transport (using the
0000000000000000000000000000000000000000;;	// gRPC http2 server transport in transport/http2_server.go) and
0000000000000000000000000000000000000000;;	// serves streams on it.
0000000000000000000000000000000000000000;;	// This is run in its own goroutine (it does network I/O in
0000000000000000000000000000000000000000;;	// transport.NewServerTransport).
0000000000000000000000000000000000000000;;	func (s *Server) serveNewHTTP2Transport(c net.Conn, authInfo credentials.AuthInfo) {
0000000000000000000000000000000000000000;;		st, err := transport.NewServerTransport("http2", c, s.opts.maxConcurrentStreams, authInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			s.errorf("NewServerTransport(%q) failed: %v", c.RemoteAddr(), err)
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			c.Close()
0000000000000000000000000000000000000000;;			grpclog.Println("grpc: Server.Serve failed to create ServerTransport: ", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.addConn(st) {
0000000000000000000000000000000000000000;;			st.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.serveStreams(st)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) serveStreams(st transport.ServerTransport) {
0000000000000000000000000000000000000000;;		defer s.removeConn(st)
0000000000000000000000000000000000000000;;		defer st.Close()
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		st.HandleStreams(func(stream *transport.Stream) {
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				s.handleStream(st, stream, s.traceInfo(st, stream))
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ http.Handler = (*Server)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveUsingHandler is called from handleRawConn when s is configured
0000000000000000000000000000000000000000;;	// to handle requests via the http.Handler interface. It sets up a
0000000000000000000000000000000000000000;;	// net/http.Server to handle the just-accepted conn. The http.Server
0000000000000000000000000000000000000000;;	// is configured to route all incoming requests (all HTTP/2 streams)
0000000000000000000000000000000000000000;;	// to ServeHTTP, which creates a new ServerTransport for each stream.
0000000000000000000000000000000000000000;;	// serveUsingHandler blocks until conn closes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This codepath is only used when Server.TestingUseHandlerImpl has
0000000000000000000000000000000000000000;;	// been configured. This lets the end2end tests exercise the ServeHTTP
0000000000000000000000000000000000000000;;	// method as one of the environment types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// conn is the *tls.Conn that's already been authenticated.
0000000000000000000000000000000000000000;;	func (s *Server) serveUsingHandler(conn net.Conn) {
0000000000000000000000000000000000000000;;		if !s.addConn(conn) {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.removeConn(conn)
0000000000000000000000000000000000000000;;		h2s := &http2.Server{
0000000000000000000000000000000000000000;;			MaxConcurrentStreams: s.opts.maxConcurrentStreams,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h2s.ServeConn(conn, &http2.ServeConnOpts{
0000000000000000000000000000000000000000;;			Handler: s,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		st, err := transport.NewServerHandlerTransport(w, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.addConn(st) {
0000000000000000000000000000000000000000;;			st.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.removeConn(st)
0000000000000000000000000000000000000000;;		s.serveStreams(st)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// traceInfo returns a traceInfo and associates it with stream, if tracing is enabled.
0000000000000000000000000000000000000000;;	// If tracing is not enabled, it returns nil.
0000000000000000000000000000000000000000;;	func (s *Server) traceInfo(st transport.ServerTransport, stream *transport.Stream) (trInfo *traceInfo) {
0000000000000000000000000000000000000000;;		if !EnableTracing {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trInfo = &traceInfo{
0000000000000000000000000000000000000000;;			tr: trace.New("grpc.Recv."+methodFamily(stream.Method()), stream.Method()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trInfo.firstLine.client = false
0000000000000000000000000000000000000000;;		trInfo.firstLine.remoteAddr = st.RemoteAddr()
0000000000000000000000000000000000000000;;		stream.TraceContext(trInfo.tr)
0000000000000000000000000000000000000000;;		if dl, ok := stream.Context().Deadline(); ok {
0000000000000000000000000000000000000000;;			trInfo.firstLine.deadline = dl.Sub(time.Now())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return trInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) addConn(c io.Closer) bool {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if s.conns == nil || s.drain {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.conns[c] = true
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) removeConn(c io.Closer) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if s.conns != nil {
0000000000000000000000000000000000000000;;			delete(s.conns, c)
0000000000000000000000000000000000000000;;			s.cv.Broadcast()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) sendResponse(t transport.ServerTransport, stream *transport.Stream, msg interface{}, cp Compressor, opts *transport.Options) error {
0000000000000000000000000000000000000000;;		var cbuf *bytes.Buffer
0000000000000000000000000000000000000000;;		if cp != nil {
0000000000000000000000000000000000000000;;			cbuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err := encode(s.opts.codec, msg, cp, cbuf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This typically indicates a fatal issue (e.g., memory
0000000000000000000000000000000000000000;;			// corruption or hardware faults) the application program
0000000000000000000000000000000000000000;;			// cannot handle.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// TODO(zhaoq): There exist other options also such as only closing the
0000000000000000000000000000000000000000;;			// faulty stream locally and remotely (Other streams can keep going). Find
0000000000000000000000000000000000000000;;			// the optimal option.
0000000000000000000000000000000000000000;;			grpclog.Fatalf("grpc: Server failed to encode response %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.Write(stream, p, opts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) {
0000000000000000000000000000000000000000;;		if trInfo != nil {
0000000000000000000000000000000000000000;;			defer trInfo.tr.Finish()
0000000000000000000000000000000000000000;;			trInfo.firstLine.client = false
0000000000000000000000000000000000000000;;			trInfo.tr.LazyLog(&trInfo.firstLine, false)
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					trInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;					trInfo.tr.SetError()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.opts.cp != nil {
0000000000000000000000000000000000000000;;			// NOTE: this needs to be ahead of all handling, https://github.com/grpc/grpc-go/issues/686.
0000000000000000000000000000000000000000;;			stream.SetSendCompress(s.opts.cp.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := &parser{r: stream}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			pf, req, err := p.recvMsg(s.opts.maxMsgSize)
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				// The entire stream is done (for unary RPC only).
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;				err = Errorf(codes.Internal, io.ErrUnexpectedEOF.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				switch err := err.(type) {
0000000000000000000000000000000000000000;;				case *rpcError:
0000000000000000000000000000000000000000;;					if err := t.WriteStatus(stream, err.code, err.desc); err != nil {
0000000000000000000000000000000000000000;;						grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case transport.ConnectionError:
0000000000000000000000000000000000000000;;					// Nothing to do here.
0000000000000000000000000000000000000000;;				case transport.StreamError:
0000000000000000000000000000000000000000;;					if err := t.WriteStatus(stream, err.Code, err.Desc); err != nil {
0000000000000000000000000000000000000000;;						grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("grpc: Unexpected error (%T) from recvMsg: %v", err, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := checkRecvPayload(pf, stream.RecvCompress(), s.opts.dc); err != nil {
0000000000000000000000000000000000000000;;				switch err := err.(type) {
0000000000000000000000000000000000000000;;				case *rpcError:
0000000000000000000000000000000000000000;;					if err := t.WriteStatus(stream, err.code, err.desc); err != nil {
0000000000000000000000000000000000000000;;						grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					if err := t.WriteStatus(stream, codes.Internal, err.Error()); err != nil {
0000000000000000000000000000000000000000;;						grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			statusCode := codes.OK
0000000000000000000000000000000000000000;;			statusDesc := ""
0000000000000000000000000000000000000000;;			df := func(v interface{}) error {
0000000000000000000000000000000000000000;;				if pf == compressionMade {
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					req, err = s.opts.dc.Do(bytes.NewReader(req))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if err := t.WriteStatus(stream, codes.Internal, err.Error()); err != nil {
0000000000000000000000000000000000000000;;							grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(req) > s.opts.maxMsgSize {
0000000000000000000000000000000000000000;;					// TODO: Revisit the error code. Currently keep it consistent with
0000000000000000000000000000000000000000;;					// java implementation.
0000000000000000000000000000000000000000;;					statusCode = codes.Internal
0000000000000000000000000000000000000000;;					statusDesc = fmt.Sprintf("grpc: server received a message of %d bytes exceeding %d limit", len(req), s.opts.maxMsgSize)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := s.opts.codec.Unmarshal(req, v); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if trInfo != nil {
0000000000000000000000000000000000000000;;					trInfo.tr.LazyLog(&payload{sent: false, msg: v}, true)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reply, appErr := md.Handler(srv.server, stream.Context(), df, s.opts.unaryInt)
0000000000000000000000000000000000000000;;			if appErr != nil {
0000000000000000000000000000000000000000;;				if err, ok := appErr.(*rpcError); ok {
0000000000000000000000000000000000000000;;					statusCode = err.code
0000000000000000000000000000000000000000;;					statusDesc = err.desc
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					statusCode = convertCode(appErr)
0000000000000000000000000000000000000000;;					statusDesc = appErr.Error()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if trInfo != nil && statusCode != codes.OK {
0000000000000000000000000000000000000000;;					trInfo.tr.LazyLog(stringer(statusDesc), true)
0000000000000000000000000000000000000000;;					trInfo.tr.SetError()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := t.WriteStatus(stream, statusCode, statusDesc); err != nil {
0000000000000000000000000000000000000000;;					grpclog.Printf("grpc: Server.processUnaryRPC failed to write status: %v", err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if trInfo != nil {
0000000000000000000000000000000000000000;;				trInfo.tr.LazyLog(stringer("OK"), false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			opts := &transport.Options{
0000000000000000000000000000000000000000;;				Last:  true,
0000000000000000000000000000000000000000;;				Delay: false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := s.sendResponse(t, stream, reply, s.opts.cp, opts); err != nil {
0000000000000000000000000000000000000000;;				switch err := err.(type) {
0000000000000000000000000000000000000000;;				case transport.ConnectionError:
0000000000000000000000000000000000000000;;					// Nothing to do here.
0000000000000000000000000000000000000000;;				case transport.StreamError:
0000000000000000000000000000000000000000;;					statusCode = err.Code
0000000000000000000000000000000000000000;;					statusDesc = err.Desc
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					statusCode = codes.Unknown
0000000000000000000000000000000000000000;;					statusDesc = err.Error()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if trInfo != nil {
0000000000000000000000000000000000000000;;				trInfo.tr.LazyLog(&payload{sent: true, msg: reply}, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t.WriteStatus(stream, statusCode, statusDesc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) processStreamingRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, sd *StreamDesc, trInfo *traceInfo) (err error) {
0000000000000000000000000000000000000000;;		if s.opts.cp != nil {
0000000000000000000000000000000000000000;;			stream.SetSendCompress(s.opts.cp.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := &serverStream{
0000000000000000000000000000000000000000;;			t:          t,
0000000000000000000000000000000000000000;;			s:          stream,
0000000000000000000000000000000000000000;;			p:          &parser{r: stream},
0000000000000000000000000000000000000000;;			codec:      s.opts.codec,
0000000000000000000000000000000000000000;;			cp:         s.opts.cp,
0000000000000000000000000000000000000000;;			dc:         s.opts.dc,
0000000000000000000000000000000000000000;;			maxMsgSize: s.opts.maxMsgSize,
0000000000000000000000000000000000000000;;			trInfo:     trInfo,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ss.cp != nil {
0000000000000000000000000000000000000000;;			ss.cbuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trInfo != nil {
0000000000000000000000000000000000000000;;			trInfo.tr.LazyLog(&trInfo.firstLine, false)
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				ss.mu.Lock()
0000000000000000000000000000000000000000;;				if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					ss.trInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;					ss.trInfo.tr.SetError()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ss.trInfo.tr.Finish()
0000000000000000000000000000000000000000;;				ss.trInfo.tr = nil
0000000000000000000000000000000000000000;;				ss.mu.Unlock()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var appErr error
0000000000000000000000000000000000000000;;		if s.opts.streamInt == nil {
0000000000000000000000000000000000000000;;			appErr = sd.Handler(srv.server, ss)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			info := &StreamServerInfo{
0000000000000000000000000000000000000000;;				FullMethod:     stream.Method(),
0000000000000000000000000000000000000000;;				IsClientStream: sd.ClientStreams,
0000000000000000000000000000000000000000;;				IsServerStream: sd.ServerStreams,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			appErr = s.opts.streamInt(srv.server, ss, info, sd.Handler)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if appErr != nil {
0000000000000000000000000000000000000000;;			if err, ok := appErr.(*rpcError); ok {
0000000000000000000000000000000000000000;;				ss.statusCode = err.code
0000000000000000000000000000000000000000;;				ss.statusDesc = err.desc
0000000000000000000000000000000000000000;;			} else if err, ok := appErr.(transport.StreamError); ok {
0000000000000000000000000000000000000000;;				ss.statusCode = err.Code
0000000000000000000000000000000000000000;;				ss.statusDesc = err.Desc
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ss.statusCode = convertCode(appErr)
0000000000000000000000000000000000000000;;				ss.statusDesc = appErr.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trInfo != nil {
0000000000000000000000000000000000000000;;			ss.mu.Lock()
0000000000000000000000000000000000000000;;			if ss.statusCode != codes.OK {
0000000000000000000000000000000000000000;;				ss.trInfo.tr.LazyLog(stringer(ss.statusDesc), true)
0000000000000000000000000000000000000000;;				ss.trInfo.tr.SetError()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ss.trInfo.tr.LazyLog(stringer("OK"), false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ss.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.WriteStatus(ss.s, ss.statusCode, ss.statusDesc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {
0000000000000000000000000000000000000000;;		sm := stream.Method()
0000000000000000000000000000000000000000;;		if sm != "" && sm[0] == '/' {
0000000000000000000000000000000000000000;;			sm = sm[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pos := strings.LastIndex(sm, "/")
0000000000000000000000000000000000000000;;		if pos == -1 {
0000000000000000000000000000000000000000;;			if trInfo != nil {
0000000000000000000000000000000000000000;;				trInfo.tr.LazyLog(&fmtStringer{"Malformed method name %q", []interface{}{sm}}, true)
0000000000000000000000000000000000000000;;				trInfo.tr.SetError()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := t.WriteStatus(stream, codes.InvalidArgument, fmt.Sprintf("malformed method name: %q", stream.Method())); err != nil {
0000000000000000000000000000000000000000;;				if trInfo != nil {
0000000000000000000000000000000000000000;;					trInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;					trInfo.tr.SetError()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				grpclog.Printf("grpc: Server.handleStream failed to write status: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if trInfo != nil {
0000000000000000000000000000000000000000;;				trInfo.tr.Finish()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		service := sm[:pos]
0000000000000000000000000000000000000000;;		method := sm[pos+1:]
0000000000000000000000000000000000000000;;		srv, ok := s.m[service]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if trInfo != nil {
0000000000000000000000000000000000000000;;				trInfo.tr.LazyLog(&fmtStringer{"Unknown service %v", []interface{}{service}}, true)
0000000000000000000000000000000000000000;;				trInfo.tr.SetError()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := t.WriteStatus(stream, codes.Unimplemented, fmt.Sprintf("unknown service %v", service)); err != nil {
0000000000000000000000000000000000000000;;				if trInfo != nil {
0000000000000000000000000000000000000000;;					trInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;					trInfo.tr.SetError()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				grpclog.Printf("grpc: Server.handleStream failed to write status: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if trInfo != nil {
0000000000000000000000000000000000000000;;				trInfo.tr.Finish()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Unary RPC or Streaming RPC?
0000000000000000000000000000000000000000;;		if md, ok := srv.md[method]; ok {
0000000000000000000000000000000000000000;;			s.processUnaryRPC(t, stream, srv, md, trInfo)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sd, ok := srv.sd[method]; ok {
0000000000000000000000000000000000000000;;			s.processStreamingRPC(t, stream, srv, sd, trInfo)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trInfo != nil {
0000000000000000000000000000000000000000;;			trInfo.tr.LazyLog(&fmtStringer{"Unknown method %v", []interface{}{method}}, true)
0000000000000000000000000000000000000000;;			trInfo.tr.SetError()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := t.WriteStatus(stream, codes.Unimplemented, fmt.Sprintf("unknown method %v", method)); err != nil {
0000000000000000000000000000000000000000;;			if trInfo != nil {
0000000000000000000000000000000000000000;;				trInfo.tr.LazyLog(&fmtStringer{"%v", []interface{}{err}}, true)
0000000000000000000000000000000000000000;;				trInfo.tr.SetError()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			grpclog.Printf("grpc: Server.handleStream failed to write status: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trInfo != nil {
0000000000000000000000000000000000000000;;			trInfo.tr.Finish()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the gRPC server. It immediately closes all open
0000000000000000000000000000000000000000;;	// connections and listeners.
0000000000000000000000000000000000000000;;	// It cancels all active RPCs on the server side and the corresponding
0000000000000000000000000000000000000000;;	// pending RPCs on the client side will get notified by connection
0000000000000000000000000000000000000000;;	// errors.
0000000000000000000000000000000000000000;;	func (s *Server) Stop() {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		listeners := s.lis
0000000000000000000000000000000000000000;;		s.lis = nil
0000000000000000000000000000000000000000;;		st := s.conns
0000000000000000000000000000000000000000;;		s.conns = nil
0000000000000000000000000000000000000000;;		// interrupt GracefulStop if Stop and GracefulStop are called concurrently.
0000000000000000000000000000000000000000;;		s.cv.Broadcast()
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for lis := range listeners {
0000000000000000000000000000000000000000;;			lis.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for c := range st {
0000000000000000000000000000000000000000;;			c.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		s.cancel()
0000000000000000000000000000000000000000;;		if s.events != nil {
0000000000000000000000000000000000000000;;			s.events.Finish()
0000000000000000000000000000000000000000;;			s.events = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GracefulStop stops the gRPC server gracefully. It stops the server to accept new
0000000000000000000000000000000000000000;;	// connections and RPCs and blocks until all the pending RPCs are finished.
0000000000000000000000000000000000000000;;	func (s *Server) GracefulStop() {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if s.conns == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for lis := range s.lis {
0000000000000000000000000000000000000000;;			lis.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.lis = nil
0000000000000000000000000000000000000000;;		s.cancel()
0000000000000000000000000000000000000000;;		if !s.drain {
0000000000000000000000000000000000000000;;			for c := range s.conns {
0000000000000000000000000000000000000000;;				c.(transport.ServerTransport).Drain()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.drain = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for len(s.conns) != 0 {
0000000000000000000000000000000000000000;;			s.cv.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.conns = nil
0000000000000000000000000000000000000000;;		if s.events != nil {
0000000000000000000000000000000000000000;;			s.events.Finish()
0000000000000000000000000000000000000000;;			s.events = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		internal.TestingCloseConns = func(arg interface{}) {
0000000000000000000000000000000000000000;;			arg.(*Server).testingCloseConns()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		internal.TestingUseHandlerImpl = func(arg interface{}) {
0000000000000000000000000000000000000000;;			arg.(*Server).opts.useHandlerImpl = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// testingCloseConns closes all existing transports but keeps s.lis
0000000000000000000000000000000000000000;;	// accepting new connections.
0000000000000000000000000000000000000000;;	func (s *Server) testingCloseConns() {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		for c := range s.conns {
0000000000000000000000000000000000000000;;			c.Close()
0000000000000000000000000000000000000000;;			delete(s.conns, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetHeader sets the header metadata.
0000000000000000000000000000000000000000;;	// When called multiple times, all the provided metadata will be merged.
0000000000000000000000000000000000000000;;	// All the metadata will be sent out when one of the following happens:
0000000000000000000000000000000000000000;;	//  - grpc.SendHeader() is called;
0000000000000000000000000000000000000000;;	//  - The first response is sent out;
0000000000000000000000000000000000000000;;	//  - An RPC status is sent out (error or success).
0000000000000000000000000000000000000000;;	func SetHeader(ctx context.Context, md metadata.MD) error {
0000000000000000000000000000000000000000;;		if md.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stream, ok := transport.StreamFromContext(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return Errorf(codes.Internal, "grpc: failed to fetch the stream from the context %v", ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stream.SetHeader(md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendHeader sends header metadata. It may be called at most once.
0000000000000000000000000000000000000000;;	// The provided md and headers set by SetHeader() will be sent.
0000000000000000000000000000000000000000;;	func SendHeader(ctx context.Context, md metadata.MD) error {
0000000000000000000000000000000000000000;;		stream, ok := transport.StreamFromContext(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return Errorf(codes.Internal, "grpc: failed to fetch the stream from the context %v", ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := stream.ServerTransport()
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			grpclog.Fatalf("grpc: SendHeader: %v has no ServerTransport to send header metadata.", stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := t.WriteHeader(stream, md); err != nil {
0000000000000000000000000000000000000000;;			return toRPCErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTrailer sets the trailer metadata that will be sent when an RPC returns.
0000000000000000000000000000000000000000;;	// When called more than once, all the provided metadata will be merged.
0000000000000000000000000000000000000000;;	func SetTrailer(ctx context.Context, md metadata.MD) error {
0000000000000000000000000000000000000000;;		if md.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stream, ok := transport.StreamFromContext(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return Errorf(codes.Internal, "grpc: failed to fetch the stream from the context %v", ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stream.SetTrailer(md)
0000000000000000000000000000000000000000;;	}
