0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2014, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/google.golang.org/grpc/metadata/metadata.go[Godeps/_workspace/src/google.golang.org/grpc/metadata/metadata.go][vendor/google.golang.org/grpc/metadata/metadata.go];	
0000000000000000000000000000000000000000;;	// Package metadata define the structure of the metadata supported by gRPC library.
0000000000000000000000000000000000000000;;	package metadata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		binHdrSuffix = "-bin"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeKeyValue encodes key and value qualified for transmission via gRPC.
0000000000000000000000000000000000000000;;	// Transmitting binary headers violates HTTP/2 spec.
0000000000000000000000000000000000000000;;	// TODO(zhaoq): Maybe check if k is ASCII also.
0000000000000000000000000000000000000000;;	func encodeKeyValue(k, v string) (string, string) {
0000000000000000000000000000000000000000;;		k = strings.ToLower(k)
0000000000000000000000000000000000000000;;		if strings.HasSuffix(k, binHdrSuffix) {
0000000000000000000000000000000000000000;;			val := base64.StdEncoding.EncodeToString([]byte(v))
0000000000000000000000000000000000000000;;			v = string(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k, v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeKeyValue returns the original key and value corresponding to the
0000000000000000000000000000000000000000;;	// encoded data in k, v.
0000000000000000000000000000000000000000;;	// If k is a binary header and v contains comma, v is split on comma before decoded,
0000000000000000000000000000000000000000;;	// and the decoded v will be joined with comma before returned.
0000000000000000000000000000000000000000;;	func DecodeKeyValue(k, v string) (string, string, error) {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(k, binHdrSuffix) {
0000000000000000000000000000000000000000;;			return k, v, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vvs := strings.Split(v, ",")
0000000000000000000000000000000000000000;;		for i, vv := range vvs {
0000000000000000000000000000000000000000;;			val, err := base64.StdEncoding.DecodeString(vv)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vvs[i] = string(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k, strings.Join(vvs, ","), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MD is a mapping from metadata keys to values. Users should use the following
0000000000000000000000000000000000000000;;	// two convenience functions New and Pairs to generate MD.
0000000000000000000000000000000000000000;;	type MD map[string][]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a MD from given key-value map.
0000000000000000000000000000000000000000;;	func New(m map[string]string) MD {
0000000000000000000000000000000000000000;;		md := MD{}
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			key, val := encodeKeyValue(k, v)
0000000000000000000000000000000000000000;;			md[key] = append(md[key], val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return md
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pairs returns an MD formed by the mapping of key, value ...
0000000000000000000000000000000000000000;;	// Pairs panics if len(kv) is odd.
0000000000000000000000000000000000000000;;	func Pairs(kv ...string) MD {
0000000000000000000000000000000000000000;;		if len(kv)%2 == 1 {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("metadata: Pairs got the odd number of input pairs for metadata: %d", len(kv)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		md := MD{}
0000000000000000000000000000000000000000;;		var k string
0000000000000000000000000000000000000000;;		for i, s := range kv {
0000000000000000000000000000000000000000;;			if i%2 == 0 {
0000000000000000000000000000000000000000;;				k = s
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key, val := encodeKeyValue(k, s)
0000000000000000000000000000000000000000;;			md[key] = append(md[key], val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return md
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of items in md.
0000000000000000000000000000000000000000;;	func (md MD) Len() int {
0000000000000000000000000000000000000000;;		return len(md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy returns a copy of md.
0000000000000000000000000000000000000000;;	func (md MD) Copy() MD {
0000000000000000000000000000000000000000;;		return Join(md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Join joins any number of MDs into a single MD.
0000000000000000000000000000000000000000;;	// The order of values for each key is determined by the order in which
0000000000000000000000000000000000000000;;	// the MDs containing those values are presented to Join.
0000000000000000000000000000000000000000;;	func Join(mds ...MD) MD {
0000000000000000000000000000000000000000;;		out := MD{}
0000000000000000000000000000000000000000;;		for _, md := range mds {
0000000000000000000000000000000000000000;;			for k, v := range md {
0000000000000000000000000000000000000000;;				out[k] = append(out[k], v...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mdKey struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewContext creates a new context with md attached.
0000000000000000000000000000000000000000;;	func NewContext(ctx context.Context, md MD) context.Context {
0000000000000000000000000000000000000000;;		return context.WithValue(ctx, mdKey{}, md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromContext returns the MD in ctx if it exists.
0000000000000000000000000000000000000000;;	func FromContext(ctx context.Context) (md MD, ok bool) {
0000000000000000000000000000000000000000;;		md, ok = ctx.Value(mdKey{}).(MD)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
