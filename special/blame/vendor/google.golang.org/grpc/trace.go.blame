0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Copyright 2015, Google Inc.
0000000000000000000000000000000000000000;;	 * All rights reserved.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	 * modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	 * met:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	 * notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	 *     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	 * copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	 * in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	 * distribution.
0000000000000000000000000000000000000000;;	 *     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	 * contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	 * this software without specific prior written permission.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 */
6cf8b80e5da3322f98ca221bde5f9ff5eb4fa392;Godeps/_workspace/src/google.golang.org/grpc/trace.go[Godeps/_workspace/src/google.golang.org/grpc/trace.go][vendor/google.golang.org/grpc/trace.go];	
0000000000000000000000000000000000000000;;	package grpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/trace"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnableTracing controls whether to trace RPCs using the golang.org/x/net/trace package.
0000000000000000000000000000000000000000;;	// This should only be set before any RPCs are sent or received by this program.
0000000000000000000000000000000000000000;;	var EnableTracing = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// methodFamily returns the trace family for the given method.
0000000000000000000000000000000000000000;;	// It turns "/pkg.Service/GetFoo" into "pkg.Service".
0000000000000000000000000000000000000000;;	func methodFamily(m string) string {
0000000000000000000000000000000000000000;;		m = strings.TrimPrefix(m, "/") // remove leading slash
0000000000000000000000000000000000000000;;		if i := strings.Index(m, "/"); i >= 0 {
0000000000000000000000000000000000000000;;			m = m[:i] // remove everything from second slash
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i := strings.LastIndex(m, "."); i >= 0 {
0000000000000000000000000000000000000000;;			m = m[i+1:] // cut down to last dotted component
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// traceInfo contains tracing information for an RPC.
0000000000000000000000000000000000000000;;	type traceInfo struct {
0000000000000000000000000000000000000000;;		tr        trace.Trace
0000000000000000000000000000000000000000;;		firstLine firstLine
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// firstLine is the first line of an RPC trace.
0000000000000000000000000000000000000000;;	type firstLine struct {
0000000000000000000000000000000000000000;;		client     bool // whether this is a client (outgoing) RPC
0000000000000000000000000000000000000000;;		remoteAddr net.Addr
0000000000000000000000000000000000000000;;		deadline   time.Duration // may be zero
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *firstLine) String() string {
0000000000000000000000000000000000000000;;		var line bytes.Buffer
0000000000000000000000000000000000000000;;		io.WriteString(&line, "RPC: ")
0000000000000000000000000000000000000000;;		if f.client {
0000000000000000000000000000000000000000;;			io.WriteString(&line, "to")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			io.WriteString(&line, "from")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(&line, " %v deadline:", f.remoteAddr)
0000000000000000000000000000000000000000;;		if f.deadline != 0 {
0000000000000000000000000000000000000000;;			fmt.Fprint(&line, f.deadline)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			io.WriteString(&line, "none")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return line.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// payload represents an RPC request or response payload.
0000000000000000000000000000000000000000;;	type payload struct {
0000000000000000000000000000000000000000;;		sent bool        // whether this is an outgoing payload
0000000000000000000000000000000000000000;;		msg  interface{} // e.g. a proto.Message
0000000000000000000000000000000000000000;;		// TODO(dsymonds): add stringifying info to codec, and limit how much we hold here?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p payload) String() string {
0000000000000000000000000000000000000000;;		if p.sent {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("sent: %v", p.msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("recv: %v", p.msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fmtStringer struct {
0000000000000000000000000000000000000000;;		format string
0000000000000000000000000000000000000000;;		a      []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fmtStringer) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(f.format, f.a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stringer string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s stringer) String() string { return string(s) }
