0000000000000000000000000000000000000000;;	// Copyright (c) 2013 Phillip Bond
0000000000000000000000000000000000000000;;	// Licensed under the MIT License
0000000000000000000000000000000000000000;;	// see file LICENSE
c841fb672d6f9bc0f6ff4e0b9a3716fb3886fa66;Godeps/_workspace/src/bitbucket.org/bertimus9/systemstat/systemstat_linux.go[Godeps/_workspace/src/bitbucket.org/bertimus9/systemstat/systemstat_linux.go][vendor/bitbucket.org/bertimus9/systemstat/systemstat_linux.go];	
0000000000000000000000000000000000000000;;	// +build linux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package systemstat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getUptime(procfile string) (uptime UptimeSample) {
0000000000000000000000000000000000000000;;		// read in whole uptime file with cpu usage information ;"/proc/uptime"
0000000000000000000000000000000000000000;;		contents, err := ioutil.ReadFile(procfile)
0000000000000000000000000000000000000000;;		uptime.Time = time.Now()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := bufio.NewReader(bytes.NewBuffer(contents))
0000000000000000000000000000000000000000;;		line, _, err := reader.ReadLine()
0000000000000000000000000000000000000000;;		fields := strings.Fields(string(line))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, numerr := strconv.ParseFloat(fields[0], 64)
0000000000000000000000000000000000000000;;		if numerr != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uptime.Uptime = val
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getLoadAvgSample(procfile string) (samp LoadAvgSample) {
0000000000000000000000000000000000000000;;		// read in whole loadavg file with cpu usage information ;"/proc/loadavg"
0000000000000000000000000000000000000000;;		contents, err := ioutil.ReadFile(procfile)
0000000000000000000000000000000000000000;;		samp.Time = time.Now()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := bufio.NewReader(bytes.NewBuffer(contents))
0000000000000000000000000000000000000000;;		line, _, err := reader.ReadLine()
0000000000000000000000000000000000000000;;		fields := strings.Fields(string(line))
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			val, numerr := strconv.ParseFloat(fields[i], 64)
0000000000000000000000000000000000000000;;			if numerr != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch i {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				samp.One = val
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				samp.Five = val
0000000000000000000000000000000000000000;;			case 2:
0000000000000000000000000000000000000000;;				samp.Fifteen = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMemSample(procfile string) (samp MemSample) {
0000000000000000000000000000000000000000;;		want := map[string]bool{
0000000000000000000000000000000000000000;;			"Buffers:":   true,
0000000000000000000000000000000000000000;;			"Cached:":    true,
0000000000000000000000000000000000000000;;			"MemTotal:":  true,
0000000000000000000000000000000000000000;;			"MemFree:":   true,
0000000000000000000000000000000000000000;;			"MemUsed:":   true,
0000000000000000000000000000000000000000;;			"SwapTotal:": true,
0000000000000000000000000000000000000000;;			"SwapFree:":  true,
0000000000000000000000000000000000000000;;			"SwapUsed:":  true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// read in whole meminfo file with cpu usage information ;"/proc/meminfo"
0000000000000000000000000000000000000000;;		contents, err := ioutil.ReadFile(procfile)
0000000000000000000000000000000000000000;;		samp.Time = time.Now()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := bufio.NewReader(bytes.NewBuffer(contents))
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, _, err := reader.ReadLine()
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fields := strings.Fields(string(line))
0000000000000000000000000000000000000000;;			fieldName := fields[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, ok := want[fieldName]
0000000000000000000000000000000000000000;;			if ok && len(fields) == 3 {
0000000000000000000000000000000000000000;;				val, numerr := strconv.ParseUint(fields[1], 10, 64)
0000000000000000000000000000000000000000;;				if numerr != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch fieldName {
0000000000000000000000000000000000000000;;				case "Buffers:":
0000000000000000000000000000000000000000;;					samp.Buffers = val
0000000000000000000000000000000000000000;;				case "Cached:":
0000000000000000000000000000000000000000;;					samp.Cached = val
0000000000000000000000000000000000000000;;				case "MemTotal:":
0000000000000000000000000000000000000000;;					samp.MemTotal = val
0000000000000000000000000000000000000000;;				case "MemFree:":
0000000000000000000000000000000000000000;;					samp.MemFree = val
0000000000000000000000000000000000000000;;				case "SwapTotal:":
0000000000000000000000000000000000000000;;					samp.SwapTotal = val
0000000000000000000000000000000000000000;;				case "SwapFree:":
0000000000000000000000000000000000000000;;					samp.SwapFree = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		samp.MemUsed = samp.MemTotal - samp.MemFree
0000000000000000000000000000000000000000;;		samp.SwapUsed = samp.SwapTotal - samp.SwapFree
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getProcCPUSample() (s ProcCPUSample) {
0000000000000000000000000000000000000000;;		var processInfo syscall.Rusage
0000000000000000000000000000000000000000;;		syscall.Getrusage(syscall.RUSAGE_SELF, &processInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Time = time.Now()
0000000000000000000000000000000000000000;;		s.ProcMemUsedK = int64(processInfo.Maxrss)
0000000000000000000000000000000000000000;;		s.User = float64(processInfo.Utime.Usec)/1000000 + float64(processInfo.Utime.Sec)
0000000000000000000000000000000000000000;;		s.System = float64(processInfo.Stime.Usec)/1000000 + float64(processInfo.Stime.Sec)
0000000000000000000000000000000000000000;;		s.Total = s.User + s.System
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCPUSample(procfile string) (samp CPUSample) {
0000000000000000000000000000000000000000;;		// read in whole proc file with cpu usage information ; "/proc/stat"
0000000000000000000000000000000000000000;;		contents, err := ioutil.ReadFile(procfile)
0000000000000000000000000000000000000000;;		samp.Time = time.Now()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := bufio.NewReader(bytes.NewBuffer(contents))
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, _, err := reader.ReadLine()
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fields := strings.Fields(string(line))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(fields) > 0 {
0000000000000000000000000000000000000000;;				fieldName := fields[0]
0000000000000000000000000000000000000000;;				if fieldName == "cpu" {
0000000000000000000000000000000000000000;;					parseCPUFields(fields, &samp)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSimpleCPUAverage(first CPUSample, second CPUSample) (avg SimpleCPUAverage) {
0000000000000000000000000000000000000000;;		//walltimediff := second.Time.Sub(first.Time)
0000000000000000000000000000000000000000;;		//dT := float64(first.Total - second.Total)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dI := float64(second.Idle - first.Idle)
0000000000000000000000000000000000000000;;		dTot := float64(second.Total - first.Total)
0000000000000000000000000000000000000000;;		avg.IdlePct = dI / dTot * 100
0000000000000000000000000000000000000000;;		avg.BusyPct = (dTot - dI) * 100 / dTot
0000000000000000000000000000000000000000;;		//log.Printf("cpu idle ticks %f, total ticks %f, idle pct %f, busy pct %f\n", dI, dTot, avg.IdlePct, avg.BusyPct)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func subtractAndConvertTicks(first uint64, second uint64) float64 {
0000000000000000000000000000000000000000;;		return float64(first - second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCPUAverage(first CPUSample, second CPUSample) (avg CPUAverage) {
0000000000000000000000000000000000000000;;		dTot := float64(second.Total - first.Total)
0000000000000000000000000000000000000000;;		invQuotient := 100.00 / dTot
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		avg.UserPct = subtractAndConvertTicks(second.User, first.User) * invQuotient
0000000000000000000000000000000000000000;;		avg.NicePct = subtractAndConvertTicks(second.Nice, first.Nice) * invQuotient
0000000000000000000000000000000000000000;;		avg.SystemPct = subtractAndConvertTicks(second.System, first.System) * invQuotient
0000000000000000000000000000000000000000;;		avg.IdlePct = subtractAndConvertTicks(second.Idle, first.Idle) * invQuotient
0000000000000000000000000000000000000000;;		avg.IowaitPct = subtractAndConvertTicks(second.Iowait, first.Iowait) * invQuotient
0000000000000000000000000000000000000000;;		avg.IrqPct = subtractAndConvertTicks(second.Irq, first.Irq) * invQuotient
0000000000000000000000000000000000000000;;		avg.SoftIrqPct = subtractAndConvertTicks(second.SoftIrq, first.SoftIrq) * invQuotient
0000000000000000000000000000000000000000;;		avg.StealPct = subtractAndConvertTicks(second.Steal, first.Steal) * invQuotient
0000000000000000000000000000000000000000;;		avg.GuestPct = subtractAndConvertTicks(second.Guest, first.Guest) * invQuotient
0000000000000000000000000000000000000000;;		avg.Time = second.Time
0000000000000000000000000000000000000000;;		avg.Seconds = second.Time.Sub(first.Time).Seconds()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getProcCPUAverage(first ProcCPUSample, second ProcCPUSample, procUptime float64) (avg ProcCPUAverage) {
0000000000000000000000000000000000000000;;		dT := second.Time.Sub(first.Time).Seconds()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		avg.UserPct = 100 * (second.User - first.User) / dT
0000000000000000000000000000000000000000;;		avg.SystemPct = 100 * (second.System - first.System) / dT
0000000000000000000000000000000000000000;;		avg.TotalPct = 100 * (second.Total - first.Total) / dT
0000000000000000000000000000000000000000;;		avg.PossiblePct = 100.0 * float64(runtime.NumCPU())
0000000000000000000000000000000000000000;;		avg.CumulativeTotalPct = 100 * second.Total / procUptime
0000000000000000000000000000000000000000;;		avg.Time = second.Time
0000000000000000000000000000000000000000;;		avg.Seconds = dT
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseCPUFields(fields []string, stat *CPUSample) {
0000000000000000000000000000000000000000;;		numFields := len(fields)
0000000000000000000000000000000000000000;;		stat.Name = fields[0]
0000000000000000000000000000000000000000;;		for i := 1; i < numFields; i++ {
0000000000000000000000000000000000000000;;			val, numerr := strconv.ParseUint(fields[i], 10, 64)
0000000000000000000000000000000000000000;;			if numerr != nil {
0000000000000000000000000000000000000000;;				log.Println("systemstat.parseCPUFields(): Error parsing (field, value): ", i, fields[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stat.Total += val
0000000000000000000000000000000000000000;;			switch i {
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				stat.User = val
0000000000000000000000000000000000000000;;			case 2:
0000000000000000000000000000000000000000;;				stat.Nice = val
0000000000000000000000000000000000000000;;			case 3:
0000000000000000000000000000000000000000;;				stat.System = val
0000000000000000000000000000000000000000;;			case 4:
0000000000000000000000000000000000000000;;				stat.Idle = val
0000000000000000000000000000000000000000;;			case 5:
0000000000000000000000000000000000000000;;				stat.Iowait = val
0000000000000000000000000000000000000000;;			case 6:
0000000000000000000000000000000000000000;;				stat.Irq = val
0000000000000000000000000000000000000000;;			case 7:
0000000000000000000000000000000000000000;;				stat.SoftIrq = val
0000000000000000000000000000000000000000;;			case 8:
0000000000000000000000000000000000000000;;				stat.Steal = val
0000000000000000000000000000000000000000;;			case 9:
0000000000000000000000000000000000000000;;				stat.Guest = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
