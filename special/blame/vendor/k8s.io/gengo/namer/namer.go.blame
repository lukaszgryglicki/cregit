0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package namer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns whether a name is a private Go name.
0000000000000000000000000000000000000000;;	func IsPrivateGoName(name string) bool {
0000000000000000000000000000000000000000;;		return len(name) == 0 || strings.ToLower(name[:1]) == name[:1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPublicNamer is a helper function that returns a namer that makes
0000000000000000000000000000000000000000;;	// CamelCase names. See the NameStrategy struct for an explanation of the
0000000000000000000000000000000000000000;;	// arguments to this constructor.
0000000000000000000000000000000000000000;;	func NewPublicNamer(prependPackageNames int, ignoreWords ...string) *NameStrategy {
0000000000000000000000000000000000000000;;		n := &NameStrategy{
0000000000000000000000000000000000000000;;			Join:                Joiner(IC, IC),
0000000000000000000000000000000000000000;;			IgnoreWords:         map[string]bool{},
0000000000000000000000000000000000000000;;			PrependPackageNames: prependPackageNames,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, w := range ignoreWords {
0000000000000000000000000000000000000000;;			n.IgnoreWords[w] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPrivateNamer is a helper function that returns a namer that makes
0000000000000000000000000000000000000000;;	// camelCase names. See the NameStrategy struct for an explanation of the
0000000000000000000000000000000000000000;;	// arguments to this constructor.
0000000000000000000000000000000000000000;;	func NewPrivateNamer(prependPackageNames int, ignoreWords ...string) *NameStrategy {
0000000000000000000000000000000000000000;;		n := &NameStrategy{
0000000000000000000000000000000000000000;;			Join:                Joiner(IL, IC),
0000000000000000000000000000000000000000;;			IgnoreWords:         map[string]bool{},
0000000000000000000000000000000000000000;;			PrependPackageNames: prependPackageNames,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, w := range ignoreWords {
0000000000000000000000000000000000000000;;			n.IgnoreWords[w] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRawNamer will return a Namer that makes a name by which you would
0000000000000000000000000000000000000000;;	// directly refer to a type, optionally keeping track of the import paths
0000000000000000000000000000000000000000;;	// necessary to reference the names it provides. Tracker may be nil.
0000000000000000000000000000000000000000;;	// The 'pkg' is the full package name, in which the Namer is used - all
0000000000000000000000000000000000000000;;	// types from that package will be referenced by just type name without
0000000000000000000000000000000000000000;;	// referencing the package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, if the type is map[string]int, a raw namer will literally
0000000000000000000000000000000000000000;;	// return "map[string]int".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Or if the type, in package foo, is "type Bar struct { ... }", then the raw
0000000000000000000000000000000000000000;;	// namer will return "foo.Bar" as the name of the type, and if 'tracker' was
0000000000000000000000000000000000000000;;	// not nil, will record that package foo needs to be imported.
0000000000000000000000000000000000000000;;	func NewRawNamer(pkg string, tracker ImportTracker) *rawNamer {
0000000000000000000000000000000000000000;;		return &rawNamer{pkg: pkg, tracker: tracker}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Names is a map from Type to name, as defined by some Namer.
0000000000000000000000000000000000000000;;	type Names map[*types.Type]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namer takes a type, and assigns a name.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The purpose of this complexity is so that you can assign coherent
0000000000000000000000000000000000000000;;	// side-by-side systems of names for the types. For example, you might want a
0000000000000000000000000000000000000000;;	// public interface, a private implementation struct, and also to reference
0000000000000000000000000000000000000000;;	// literally the type name.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that it is safe to call your own Name() function recursively to find
0000000000000000000000000000000000000000;;	// the names of keys, elements, etc. This is because anonymous types can't have
0000000000000000000000000000000000000000;;	// cycles in their names, and named types don't require the sort of recursion
0000000000000000000000000000000000000000;;	// that would be problematic.
0000000000000000000000000000000000000000;;	type Namer interface {
0000000000000000000000000000000000000000;;		Name(*types.Type) string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems is a map of a system name to a namer for that system.
0000000000000000000000000000000000000000;;	type NameSystems map[string]Namer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameStrategy is a general Namer. The easiest way to use it is to copy the
0000000000000000000000000000000000000000;;	// Public/PrivateNamer variables, and modify the members you wish to change.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Name method produces a name for the given type, of the forms:
0000000000000000000000000000000000000000;;	// Anonymous types: <Prefix><Type description><Suffix>
0000000000000000000000000000000000000000;;	// Named types: <Prefix><Optional Prepended Package name(s)><Original name><Suffix>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In all cases, every part of the name is run through the capitalization
0000000000000000000000000000000000000000;;	// functions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The IgnoreWords map can be set if you have directory names that are
0000000000000000000000000000000000000000;;	// semantically meaningless for naming purposes, e.g. "proto".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Prefix and Suffix can be used to disambiguate parallel systems of type
0000000000000000000000000000000000000000;;	// names. For example, if you want to generate an interface and an
0000000000000000000000000000000000000000;;	// implementation, you might want to suffix one with "Interface" and the other
0000000000000000000000000000000000000000;;	// with "Implementation". Another common use-- if you want to generate private
0000000000000000000000000000000000000000;;	// types, and one of your source types could be "string", you can't use the
0000000000000000000000000000000000000000;;	// default lowercase private namer. You'll have to add a suffix or prefix.
0000000000000000000000000000000000000000;;	type NameStrategy struct {
0000000000000000000000000000000000000000;;		Prefix, Suffix string
0000000000000000000000000000000000000000;;		Join           func(pre string, parts []string, post string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add non-meaningful package directory names here (e.g. "proto") and
0000000000000000000000000000000000000000;;		// they will be ignored.
0000000000000000000000000000000000000000;;		IgnoreWords map[string]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If > 0, prepend exactly that many package directory names (or as
0000000000000000000000000000000000000000;;		// many as there are).  Package names listed in "IgnoreWords" will be
0000000000000000000000000000000000000000;;		// ignored.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// For example, if Ignore words lists "proto" and type Foo is in
0000000000000000000000000000000000000000;;		// pkg/server/frobbing/proto, then a value of 1 will give a type name
0000000000000000000000000000000000000000;;		// of FrobbingFoo, 2 gives ServerFrobbingFoo, etc.
0000000000000000000000000000000000000000;;		PrependPackageNames int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A cache of names thus far assigned by this namer.
0000000000000000000000000000000000000000;;		Names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IC ensures the first character is uppercase.
0000000000000000000000000000000000000000;;	func IC(in string) string {
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.ToUpper(in[:1]) + in[1:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IL ensures the first character is lowercase.
0000000000000000000000000000000000000000;;	func IL(in string) string {
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.ToLower(in[:1]) + in[1:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Joiner lets you specify functions that preprocess the various components of
0000000000000000000000000000000000000000;;	// a name before joining them. You can construct e.g. camelCase or CamelCase or
0000000000000000000000000000000000000000;;	// any other way of joining words. (See the IC and IL convenience functions.)
0000000000000000000000000000000000000000;;	func Joiner(first, others func(string) string) func(pre string, in []string, post string) string {
0000000000000000000000000000000000000000;;		return func(pre string, in []string, post string) string {
0000000000000000000000000000000000000000;;			tmp := []string{others(pre)}
0000000000000000000000000000000000000000;;			for i := range in {
0000000000000000000000000000000000000000;;				tmp = append(tmp, others(in[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tmp = append(tmp, others(post))
0000000000000000000000000000000000000000;;			return first(strings.Join(tmp, ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ns *NameStrategy) removePrefixAndSuffix(s string) string {
0000000000000000000000000000000000000000;;		// The join function may have changed capitalization.
0000000000000000000000000000000000000000;;		lowerIn := strings.ToLower(s)
0000000000000000000000000000000000000000;;		lowerP := strings.ToLower(ns.Prefix)
0000000000000000000000000000000000000000;;		lowerS := strings.ToLower(ns.Suffix)
0000000000000000000000000000000000000000;;		b, e := 0, len(s)
0000000000000000000000000000000000000000;;		if strings.HasPrefix(lowerIn, lowerP) {
0000000000000000000000000000000000000000;;			b = len(ns.Prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(lowerIn, lowerS) {
0000000000000000000000000000000000000000;;			e -= len(ns.Suffix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s[b:e]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		importPathNameSanitizer = strings.NewReplacer("-", "_", ".", "")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filters out unwanted directory names and sanitizes remaining names.
0000000000000000000000000000000000000000;;	func (ns *NameStrategy) filterDirs(path string) []string {
0000000000000000000000000000000000000000;;		allDirs := strings.Split(path, string(filepath.Separator))
0000000000000000000000000000000000000000;;		dirs := make([]string, 0, len(allDirs))
0000000000000000000000000000000000000000;;		for _, p := range allDirs {
0000000000000000000000000000000000000000;;			if ns.IgnoreWords == nil || !ns.IgnoreWords[p] {
0000000000000000000000000000000000000000;;				dirs = append(dirs, importPathNameSanitizer.Replace(p))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dirs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See the comment on NameStrategy.
0000000000000000000000000000000000000000;;	func (ns *NameStrategy) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		if ns.Names == nil {
0000000000000000000000000000000000000000;;			ns.Names = Names{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s, ok := ns.Names[t]; ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Name.Package != "" {
0000000000000000000000000000000000000000;;			dirs := append(ns.filterDirs(t.Name.Package), t.Name.Name)
0000000000000000000000000000000000000000;;			i := ns.PrependPackageNames + 1
0000000000000000000000000000000000000000;;			dn := len(dirs)
0000000000000000000000000000000000000000;;			if i > dn {
0000000000000000000000000000000000000000;;				i = dn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := ns.Join(ns.Prefix, dirs[dn-i:], ns.Suffix)
0000000000000000000000000000000000000000;;			ns.Names[t] = name
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only anonymous types remain.
0000000000000000000000000000000000000000;;		var name string
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, []string{t.Name.Name}, ns.Suffix)
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, []string{
0000000000000000000000000000000000000000;;				"Map",
0000000000000000000000000000000000000000;;				ns.removePrefixAndSuffix(ns.Name(t.Key)),
0000000000000000000000000000000000000000;;				"To",
0000000000000000000000000000000000000000;;				ns.removePrefixAndSuffix(ns.Name(t.Elem)),
0000000000000000000000000000000000000000;;			}, ns.Suffix)
0000000000000000000000000000000000000000;;		case types.Slice:
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, []string{
0000000000000000000000000000000000000000;;				"Slice",
0000000000000000000000000000000000000000;;				ns.removePrefixAndSuffix(ns.Name(t.Elem)),
0000000000000000000000000000000000000000;;			}, ns.Suffix)
0000000000000000000000000000000000000000;;		case types.Pointer:
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, []string{
0000000000000000000000000000000000000000;;				"Pointer",
0000000000000000000000000000000000000000;;				ns.removePrefixAndSuffix(ns.Name(t.Elem)),
0000000000000000000000000000000000000000;;			}, ns.Suffix)
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			names := []string{"Struct"}
0000000000000000000000000000000000000000;;			for _, m := range t.Members {
0000000000000000000000000000000000000000;;				names = append(names, ns.removePrefixAndSuffix(ns.Name(m.Type)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, names, ns.Suffix)
0000000000000000000000000000000000000000;;		case types.Chan:
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, []string{
0000000000000000000000000000000000000000;;				"Chan",
0000000000000000000000000000000000000000;;				ns.removePrefixAndSuffix(ns.Name(t.Elem)),
0000000000000000000000000000000000000000;;			}, ns.Suffix)
0000000000000000000000000000000000000000;;		case types.Interface:
0000000000000000000000000000000000000000;;			// TODO: add to name test
0000000000000000000000000000000000000000;;			names := []string{"Interface"}
0000000000000000000000000000000000000000;;			for _, m := range t.Methods {
0000000000000000000000000000000000000000;;				// TODO: include function signature
0000000000000000000000000000000000000000;;				names = append(names, m.Name.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, names, ns.Suffix)
0000000000000000000000000000000000000000;;		case types.Func:
0000000000000000000000000000000000000000;;			// TODO: add to name test
0000000000000000000000000000000000000000;;			parts := []string{"Func"}
0000000000000000000000000000000000000000;;			for _, pt := range t.Signature.Parameters {
0000000000000000000000000000000000000000;;				parts = append(parts, ns.removePrefixAndSuffix(ns.Name(pt)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts = append(parts, "Returns")
0000000000000000000000000000000000000000;;			for _, rt := range t.Signature.Results {
0000000000000000000000000000000000000000;;				parts = append(parts, ns.removePrefixAndSuffix(ns.Name(rt)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = ns.Join(ns.Prefix, parts, ns.Suffix)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			name = "unnameable_" + string(t.Kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ns.Names[t] = name
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImportTracker allows a raw namer to keep track of the packages needed for
0000000000000000000000000000000000000000;;	// import. You can implement yourself or use the one in the generation package.
0000000000000000000000000000000000000000;;	type ImportTracker interface {
0000000000000000000000000000000000000000;;		AddType(*types.Type)
0000000000000000000000000000000000000000;;		LocalNameOf(packagePath string) string
0000000000000000000000000000000000000000;;		PathOf(localName string) (string, bool)
0000000000000000000000000000000000000000;;		ImportLines() []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rawNamer struct {
0000000000000000000000000000000000000000;;		pkg     string
0000000000000000000000000000000000000000;;		tracker ImportTracker
0000000000000000000000000000000000000000;;		Names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name makes a name the way you'd write it to literally refer to type t,
0000000000000000000000000000000000000000;;	// making ordinary assumptions about how you've imported t's package (or using
0000000000000000000000000000000000000000;;	// r.tracker to specifically track the package imports).
0000000000000000000000000000000000000000;;	func (r *rawNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		if r.Names == nil {
0000000000000000000000000000000000000000;;			r.Names = Names{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if name, ok := r.Names[t]; ok {
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Name.Package != "" {
0000000000000000000000000000000000000000;;			var name string
0000000000000000000000000000000000000000;;			if r.tracker != nil {
0000000000000000000000000000000000000000;;				r.tracker.AddType(t)
0000000000000000000000000000000000000000;;				if t.Name.Package == r.pkg {
0000000000000000000000000000000000000000;;					name = t.Name.Name
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					name = r.tracker.LocalNameOf(t.Name.Package) + "." + t.Name.Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if t.Name.Package == r.pkg {
0000000000000000000000000000000000000000;;					name = t.Name.Name
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					name = filepath.Base(t.Name.Package) + "." + t.Name.Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Names[t] = name
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var name string
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			name = t.Name.Name
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			name = "map[" + r.Name(t.Key) + "]" + r.Name(t.Elem)
0000000000000000000000000000000000000000;;		case types.Slice:
0000000000000000000000000000000000000000;;			name = "[]" + r.Name(t.Elem)
0000000000000000000000000000000000000000;;		case types.Pointer:
0000000000000000000000000000000000000000;;			name = "*" + r.Name(t.Elem)
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			elems := []string{}
0000000000000000000000000000000000000000;;			for _, m := range t.Members {
0000000000000000000000000000000000000000;;				elems = append(elems, m.Name+" "+r.Name(m.Type))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = "struct{" + strings.Join(elems, "; ") + "}"
0000000000000000000000000000000000000000;;		case types.Chan:
0000000000000000000000000000000000000000;;			// TODO: include directionality
0000000000000000000000000000000000000000;;			name = "chan " + r.Name(t.Elem)
0000000000000000000000000000000000000000;;		case types.Interface:
0000000000000000000000000000000000000000;;			// TODO: add to name test
0000000000000000000000000000000000000000;;			elems := []string{}
0000000000000000000000000000000000000000;;			for _, m := range t.Methods {
0000000000000000000000000000000000000000;;				// TODO: include function signature
0000000000000000000000000000000000000000;;				elems = append(elems, m.Name.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = "interface{" + strings.Join(elems, "; ") + "}"
0000000000000000000000000000000000000000;;		case types.Func:
0000000000000000000000000000000000000000;;			// TODO: add to name test
0000000000000000000000000000000000000000;;			params := []string{}
0000000000000000000000000000000000000000;;			for _, pt := range t.Signature.Parameters {
0000000000000000000000000000000000000000;;				params = append(params, r.Name(pt))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			results := []string{}
0000000000000000000000000000000000000000;;			for _, rt := range t.Signature.Results {
0000000000000000000000000000000000000000;;				results = append(results, r.Name(rt))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = "func(" + strings.Join(params, ",") + ")"
0000000000000000000000000000000000000000;;			if len(results) == 1 {
0000000000000000000000000000000000000000;;				name += " " + results[0]
0000000000000000000000000000000000000000;;			} else if len(results) > 1 {
0000000000000000000000000000000000000000;;				name += " (" + strings.Join(results, ",") + ")"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			name = "unnameable_" + string(t.Kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.Names[t] = name
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
