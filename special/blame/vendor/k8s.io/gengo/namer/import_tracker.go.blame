0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package namer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImportTracker may be passed to a namer.RawNamer, to track the imports needed
0000000000000000000000000000000000000000;;	// for the types it names.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: pay attention to the package name (instead of renaming every package).
0000000000000000000000000000000000000000;;	type DefaultImportTracker struct {
0000000000000000000000000000000000000000;;		pathToName map[string]string
0000000000000000000000000000000000000000;;		// forbidden names are in here. (e.g. "go" is a directory in which
0000000000000000000000000000000000000000;;		// there is code, but "go" is not a legal name for a package, so we put
0000000000000000000000000000000000000000;;		// it here to prevent us from naming any package "go")
0000000000000000000000000000000000000000;;		nameToPath map[string]string
0000000000000000000000000000000000000000;;		local      types.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns true if a given types is an invalid type and should be ignored.
0000000000000000000000000000000000000000;;		IsInvalidType func(*types.Type) bool
0000000000000000000000000000000000000000;;		// Returns the final local name for the given name
0000000000000000000000000000000000000000;;		LocalName func(types.Name) string
0000000000000000000000000000000000000000;;		// Returns the "import" line for a given (path, name).
0000000000000000000000000000000000000000;;		PrintImport func(string, string) string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefaultImportTracker(local types.Name) DefaultImportTracker {
0000000000000000000000000000000000000000;;		return DefaultImportTracker{
0000000000000000000000000000000000000000;;			pathToName: map[string]string{},
0000000000000000000000000000000000000000;;			nameToPath: map[string]string{},
0000000000000000000000000000000000000000;;			local:      local,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tracker *DefaultImportTracker) AddTypes(types ...*types.Type) {
0000000000000000000000000000000000000000;;		for _, t := range types {
0000000000000000000000000000000000000000;;			tracker.AddType(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (tracker *DefaultImportTracker) AddType(t *types.Type) {
0000000000000000000000000000000000000000;;		if tracker.local.Package == t.Name.Package {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tracker.IsInvalidType(t) {
0000000000000000000000000000000000000000;;			if t.Kind == types.Builtin {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := tracker.nameToPath[t.Name.Package]; !ok {
0000000000000000000000000000000000000000;;				tracker.nameToPath[t.Name.Package] = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(t.Name.Package) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path := t.Name.Path
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			path = t.Name.Package
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := tracker.pathToName[path]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := tracker.LocalName(t.Name)
0000000000000000000000000000000000000000;;		tracker.nameToPath[name] = path
0000000000000000000000000000000000000000;;		tracker.pathToName[path] = name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tracker *DefaultImportTracker) ImportLines() []string {
0000000000000000000000000000000000000000;;		importPaths := []string{}
0000000000000000000000000000000000000000;;		for path := range tracker.pathToName {
0000000000000000000000000000000000000000;;			importPaths = append(importPaths, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sort.StringSlice(importPaths))
0000000000000000000000000000000000000000;;		out := []string{}
0000000000000000000000000000000000000000;;		for _, path := range importPaths {
0000000000000000000000000000000000000000;;			out = append(out, tracker.PrintImport(path, tracker.pathToName[path]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalNameOf returns the name you would use to refer to the package at the
0000000000000000000000000000000000000000;;	// specified path within the body of a file.
0000000000000000000000000000000000000000;;	func (tracker *DefaultImportTracker) LocalNameOf(path string) string {
0000000000000000000000000000000000000000;;		return tracker.pathToName[path]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathOf returns the path that a given localName is referring to within the
0000000000000000000000000000000000000000;;	// body of a file.
0000000000000000000000000000000000000000;;	func (tracker *DefaultImportTracker) PathOf(localName string) (string, bool) {
0000000000000000000000000000000000000000;;		name, ok := tracker.nameToPath[localName]
0000000000000000000000000000000000000000;;		return name, ok
0000000000000000000000000000000000000000;;	}
