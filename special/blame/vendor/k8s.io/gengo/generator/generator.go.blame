0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/parser"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package contains the contract for generating a package.
0000000000000000000000000000000000000000;;	type Package interface {
0000000000000000000000000000000000000000;;		// Name returns the package short name.
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		// Path returns the package import path.
0000000000000000000000000000000000000000;;		Path() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Filter should return true if this package cares about this type.
0000000000000000000000000000000000000000;;		// Otherwise, this type will be omitted from the type ordering for
0000000000000000000000000000000000000000;;		// this package.
0000000000000000000000000000000000000000;;		Filter(*Context, *types.Type) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Header should return a header for the file, including comment markers.
0000000000000000000000000000000000000000;;		// Useful for copyright notices and doc strings. Include an
0000000000000000000000000000000000000000;;		// autogeneration notice! Do not include the "package x" line.
0000000000000000000000000000000000000000;;		Header(filename string) []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generators returns the list of generators for this package. It is
0000000000000000000000000000000000000000;;		// allowed for more than one generator to write to the same file.
0000000000000000000000000000000000000000;;		// A Context is passed in case the list of generators depends on the
0000000000000000000000000000000000000000;;		// input types.
0000000000000000000000000000000000000000;;		Generators(*Context) []Generator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		Name        string
0000000000000000000000000000000000000000;;		FileType    string
0000000000000000000000000000000000000000;;		PackageName string
0000000000000000000000000000000000000000;;		Header      []byte
0000000000000000000000000000000000000000;;		Imports     map[string]struct{}
0000000000000000000000000000000000000000;;		Vars        bytes.Buffer
0000000000000000000000000000000000000000;;		Consts      bytes.Buffer
0000000000000000000000000000000000000000;;		Body        bytes.Buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FileType interface {
0000000000000000000000000000000000000000;;		AssembleFile(f *File, path string) error
0000000000000000000000000000000000000000;;		VerifyFile(f *File, path string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Packages is a list of packages to generate.
0000000000000000000000000000000000000000;;	type Packages []Package
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generator is the contract for anything that wants to do auto-generation.
0000000000000000000000000000000000000000;;	// It's expected that the io.Writers passed to the below functions will be
0000000000000000000000000000000000000000;;	// ErrorTrackers; this allows implementations to not check for io errors,
0000000000000000000000000000000000000000;;	// making more readable code.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The call order for the functions that take a Context is:
0000000000000000000000000000000000000000;;	// 1. Filter()        // Subsequent calls see only types that pass this.
0000000000000000000000000000000000000000;;	// 2. Namers()        // Subsequent calls see the namers provided by this.
0000000000000000000000000000000000000000;;	// 3. PackageVars()
0000000000000000000000000000000000000000;;	// 4. PackageConsts()
0000000000000000000000000000000000000000;;	// 5. Init()
0000000000000000000000000000000000000000;;	// 6. GenerateType()  // Called N times, once per type in the context's Order.
0000000000000000000000000000000000000000;;	// 7. Imports()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// You may have multiple generators for the same file.
0000000000000000000000000000000000000000;;	type Generator interface {
0000000000000000000000000000000000000000;;		// The name of this generator. Will be included in generated comments.
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Filter should return true if this generator cares about this type.
0000000000000000000000000000000000000000;;		// (otherwise, GenerateType will not be called.)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Filter is called before any of the generator's other functions;
0000000000000000000000000000000000000000;;		// subsequent calls will get a context with only the types that passed
0000000000000000000000000000000000000000;;		// this filter.
0000000000000000000000000000000000000000;;		Filter(*Context, *types.Type) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If this generator needs special namers, return them here. These will
0000000000000000000000000000000000000000;;		// override the original namers in the context if there is a collision.
0000000000000000000000000000000000000000;;		// You may return nil if you don't need special names. These names will
0000000000000000000000000000000000000000;;		// be available in the context passed to the rest of the generator's
0000000000000000000000000000000000000000;;		// functions.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A use case for this is to return a namer that tracks imports.
0000000000000000000000000000000000000000;;		Namers(*Context) namer.NameSystems
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Init should write an init function, and any other content that's not
0000000000000000000000000000000000000000;;		// generated per-type. (It's not intended for generator specific
0000000000000000000000000000000000000000;;		// initialization! Do that when your Package constructs the
0000000000000000000000000000000000000000;;		// Generators.)
0000000000000000000000000000000000000000;;		Init(*Context, io.Writer) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finalize should write finish up functions, and any other content that's not
0000000000000000000000000000000000000000;;		// generated per-type.
0000000000000000000000000000000000000000;;		Finalize(*Context, io.Writer) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PackageVars should emit an array of variable lines. They will be
0000000000000000000000000000000000000000;;		// placed in a var ( ... ) block. There's no need to include a leading
0000000000000000000000000000000000000000;;		// \t or trailing \n.
0000000000000000000000000000000000000000;;		PackageVars(*Context) []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PackageConsts should emit an array of constant lines. They will be
0000000000000000000000000000000000000000;;		// placed in a const ( ... ) block. There's no need to include a leading
0000000000000000000000000000000000000000;;		// \t or trailing \n.
0000000000000000000000000000000000000000;;		PackageConsts(*Context) []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GenerateType should emit the code for a particular type.
0000000000000000000000000000000000000000;;		GenerateType(*Context, *types.Type, io.Writer) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Imports should return a list of necessary imports. They will be
0000000000000000000000000000000000000000;;		// formatted correctly. You do not need to include quotation marks,
0000000000000000000000000000000000000000;;		// return only the package name; alternatively, you can also return
0000000000000000000000000000000000000000;;		// imports in the format `name "path/to/pkg"`. Imports will be called
0000000000000000000000000000000000000000;;		// after Init, PackageVars, PackageConsts, and GenerateType, to allow
0000000000000000000000000000000000000000;;		// you to keep track of what imports you actually need.
0000000000000000000000000000000000000000;;		Imports(*Context) []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Preferred file name of this generator, not including a path. It is
0000000000000000000000000000000000000000;;		// allowed for multiple generators to use the same filename, but it's
0000000000000000000000000000000000000000;;		// up to you to make sure they don't have colliding import names.
0000000000000000000000000000000000000000;;		// TODO: provide per-file import tracking, removing the requirement
0000000000000000000000000000000000000000;;		// that generators coordinate..
0000000000000000000000000000000000000000;;		Filename() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A registered file type in the context to generate this file with. If
0000000000000000000000000000000000000000;;		// the FileType is not found in the context, execution will stop.
0000000000000000000000000000000000000000;;		FileType() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Context is global context for individual generators to consume.
0000000000000000000000000000000000000000;;	type Context struct {
0000000000000000000000000000000000000000;;		// A map from the naming system to the names for that system. E.g., you
0000000000000000000000000000000000000000;;		// might have public names and several private naming systems.
0000000000000000000000000000000000000000;;		Namers namer.NameSystems
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All the types, in case you want to look up something.
0000000000000000000000000000000000000000;;		Universe types.Universe
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All the user-specified packages.  This is after recursive expansion.
0000000000000000000000000000000000000000;;		Inputs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The canonical ordering of the types (will be filtered by both the
0000000000000000000000000000000000000000;;		// Package's and Generator's Filter methods).
0000000000000000000000000000000000000000;;		Order []*types.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A set of types this context can process. If this is empty or nil,
0000000000000000000000000000000000000000;;		// the default "golang" filetype will be provided.
0000000000000000000000000000000000000000;;		FileTypes map[string]FileType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, Execute* calls will just verify that the existing output is
0000000000000000000000000000000000000000;;		// correct. (You may set this after calling NewContext.)
0000000000000000000000000000000000000000;;		Verify bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allows generators to add packages at runtime.
0000000000000000000000000000000000000000;;		builder *parser.Builder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewContext generates a context from the given builder, naming systems, and
0000000000000000000000000000000000000000;;	// the naming system you wish to construct the canonical ordering from.
0000000000000000000000000000000000000000;;	func NewContext(b *parser.Builder, nameSystems namer.NameSystems, canonicalOrderName string) (*Context, error) {
0000000000000000000000000000000000000000;;		universe, err := b.FindTypes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &Context{
0000000000000000000000000000000000000000;;			Namers:   namer.NameSystems{},
0000000000000000000000000000000000000000;;			Universe: universe,
0000000000000000000000000000000000000000;;			Inputs:   b.FindPackages(),
0000000000000000000000000000000000000000;;			FileTypes: map[string]FileType{
0000000000000000000000000000000000000000;;				GolangFileType: NewGolangFile(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			builder: b,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, systemNamer := range nameSystems {
0000000000000000000000000000000000000000;;			c.Namers[name] = systemNamer
0000000000000000000000000000000000000000;;			if name == canonicalOrderName {
0000000000000000000000000000000000000000;;				orderer := namer.Orderer{Namer: systemNamer}
0000000000000000000000000000000000000000;;				c.Order = orderer.OrderUniverse(universe)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDir adds a Go package to the context. The specified path must be a single
0000000000000000000000000000000000000000;;	// go package import path.  GOPATH, GOROOT, and the location of your go binary
0000000000000000000000000000000000000000;;	// (`which go`) will all be searched, in the normal Go fashion.
0000000000000000000000000000000000000000;;	// Deprecated. Please use AddDirectory.
0000000000000000000000000000000000000000;;	func (ctxt *Context) AddDir(path string) error {
0000000000000000000000000000000000000000;;		return ctxt.builder.AddDirTo(path, &ctxt.Universe)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDirectory adds a Go package to the context. The specified path must be a
0000000000000000000000000000000000000000;;	// single go package import path.  GOPATH, GOROOT, and the location of your go
0000000000000000000000000000000000000000;;	// binary (`which go`) will all be searched, in the normal Go fashion.
0000000000000000000000000000000000000000;;	func (ctxt *Context) AddDirectory(path string) (*types.Package, error) {
0000000000000000000000000000000000000000;;		return ctxt.builder.AddDirectoryTo(path, &ctxt.Universe)
0000000000000000000000000000000000000000;;	}
