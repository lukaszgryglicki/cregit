0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SnippetWriter is an attempt to make the template library usable.
0000000000000000000000000000000000000000;;	// Methods are chainable, and you don't have to check Error() until you're all
0000000000000000000000000000000000000000;;	// done.
0000000000000000000000000000000000000000;;	type SnippetWriter struct {
0000000000000000000000000000000000000000;;		w       io.Writer
0000000000000000000000000000000000000000;;		context *Context
0000000000000000000000000000000000000000;;		// Left & right delimiters. text/template defaults to "{{" and "}}"
0000000000000000000000000000000000000000;;		// which is totally unusable for go code based templates.
0000000000000000000000000000000000000000;;		left, right string
0000000000000000000000000000000000000000;;		funcMap     template.FuncMap
0000000000000000000000000000000000000000;;		err         error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// w is the destination; left and right are the delimiters; @ and $ are both
0000000000000000000000000000000000000000;;	// reasonable choices.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// c is used to make a function for every naming system, to which you can pass
0000000000000000000000000000000000000000;;	// a type and get the corresponding name.
0000000000000000000000000000000000000000;;	func NewSnippetWriter(w io.Writer, c *Context, left, right string) *SnippetWriter {
0000000000000000000000000000000000000000;;		sw := &SnippetWriter{
0000000000000000000000000000000000000000;;			w:       w,
0000000000000000000000000000000000000000;;			context: c,
0000000000000000000000000000000000000000;;			left:    left,
0000000000000000000000000000000000000000;;			right:   right,
0000000000000000000000000000000000000000;;			funcMap: template.FuncMap{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, namer := range c.Namers {
0000000000000000000000000000000000000000;;			sw.funcMap[name] = namer.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do parses format and runs args through it. You can have arbitrary logic in
0000000000000000000000000000000000000000;;	// the format (see the text/template documentation), but consider running many
0000000000000000000000000000000000000000;;	// short templaces, with ordinary go logic in between--this may be more
0000000000000000000000000000000000000000;;	// readable. Do is chainable. Any error causes every other call to do to be
0000000000000000000000000000000000000000;;	// ignored, and the error will be returned by Error(). So you can check it just
0000000000000000000000000000000000000000;;	// once, at the end of your function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'args' can be quite literally anything; read the text/template documentation
0000000000000000000000000000000000000000;;	// for details. Maps and structs work particularly nicely. Conveniently, the
0000000000000000000000000000000000000000;;	// types package is designed to have structs that are easily referencable from
0000000000000000000000000000000000000000;;	// the template language.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// sw := generator.NewSnippetWriter(outBuffer, context, "$", "$")
0000000000000000000000000000000000000000;;	// sw.Do(`The public type name is: $.type|public$`, map[string]interface{}{"type": t})
0000000000000000000000000000000000000000;;	// return sw.Error()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Where:
0000000000000000000000000000000000000000;;	// * "$" starts a template directive
0000000000000000000000000000000000000000;;	// * "." references the entire thing passed as args
0000000000000000000000000000000000000000;;	// * "type" therefore sees a map and looks up the key "type"
0000000000000000000000000000000000000000;;	// * "|" means "pass the thing on the left to the thing on the right"
0000000000000000000000000000000000000000;;	// * "public" is the name of a naming system, so the SnippetWriter has given
0000000000000000000000000000000000000000;;	//   the template a function called "public" that takes a *types.Type and
0000000000000000000000000000000000000000;;	//   returns the naming system's name. E.g., if the type is "string" this might
0000000000000000000000000000000000000000;;	//   return "String".
0000000000000000000000000000000000000000;;	// * the second "$" ends the template directive.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The map is actually not necessary. The below does the same thing:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// sw.Do(`The public type name is: $.|public$`, t)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// You may or may not find it more readable to use the map with a descriptive
0000000000000000000000000000000000000000;;	// key, but if you want to pass more than one arg, the map or a custom struct
0000000000000000000000000000000000000000;;	// becomes a requirement. You can do arbitrary logic inside these templates,
0000000000000000000000000000000000000000;;	// but you should consider doing the logic in go and stitching them together
0000000000000000000000000000000000000000;;	// for the sake of your readers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: Change Do() to optionally take a list of pairs of parameters (key, value)
0000000000000000000000000000000000000000;;	// and have it construct a combined map with that and args.
0000000000000000000000000000000000000000;;	func (s *SnippetWriter) Do(format string, args interface{}) *SnippetWriter {
0000000000000000000000000000000000000000;;		if s.err != nil {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Name the template by source file:line so it can be found when
0000000000000000000000000000000000000000;;		// there's an error.
0000000000000000000000000000000000000000;;		_, file, line, _ := runtime.Caller(1)
0000000000000000000000000000000000000000;;		tmpl, err := template.
0000000000000000000000000000000000000000;;			New(fmt.Sprintf("%s:%d", file, line)).
0000000000000000000000000000000000000000;;			Delims(s.left, s.right).
0000000000000000000000000000000000000000;;			Funcs(s.funcMap).
0000000000000000000000000000000000000000;;			Parse(format)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			s.err = err
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = tmpl.Execute(s.w, args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			s.err = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Args exists to make it convenient to construct arguments for
0000000000000000000000000000000000000000;;	// SnippetWriter.Do.
0000000000000000000000000000000000000000;;	type Args map[interface{}]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// With makes a copy of a and adds the given key, value pair.
0000000000000000000000000000000000000000;;	func (a Args) With(key, value interface{}) Args {
0000000000000000000000000000000000000000;;		a2 := Args{key: value}
0000000000000000000000000000000000000000;;		for k, v := range a {
0000000000000000000000000000000000000000;;			a2[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithArgs makes a copy of a and adds the given arguments.
0000000000000000000000000000000000000000;;	func (a Args) WithArgs(rhs Args) Args {
0000000000000000000000000000000000000000;;		a2 := Args{}
0000000000000000000000000000000000000000;;		for k, v := range rhs {
0000000000000000000000000000000000000000;;			a2[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range a {
0000000000000000000000000000000000000000;;			a2[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SnippetWriter) Out() io.Writer {
0000000000000000000000000000000000000000;;		return s.w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns any encountered error.
0000000000000000000000000000000000000000;;	func (s *SnippetWriter) Error() error {
0000000000000000000000000000000000000000;;		return s.err
0000000000000000000000000000000000000000;;	}
