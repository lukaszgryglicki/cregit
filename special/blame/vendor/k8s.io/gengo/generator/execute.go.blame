0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/format"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func errs2strings(errors []error) []string {
0000000000000000000000000000000000000000;;		strs := make([]string, len(errors))
0000000000000000000000000000000000000000;;		for i := range errors {
0000000000000000000000000000000000000000;;			strs[i] = errors[i].Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecutePackages runs the generators for every package in 'packages'. 'outDir'
0000000000000000000000000000000000000000;;	// is the base directory in which to place all the generated packages; it
0000000000000000000000000000000000000000;;	// should be a physical path on disk, not an import path. e.g.:
0000000000000000000000000000000000000000;;	// /path/to/home/path/to/gopath/src/
0000000000000000000000000000000000000000;;	// Each package has its import path already, this will be appended to 'outDir'.
0000000000000000000000000000000000000000;;	func (c *Context) ExecutePackages(outDir string, packages Packages) error {
0000000000000000000000000000000000000000;;		var errors []error
0000000000000000000000000000000000000000;;		for _, p := range packages {
0000000000000000000000000000000000000000;;			if err := c.ExecutePackage(outDir, p); err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("some packages had errors:\n%v\n", strings.Join(errs2strings(errors), "\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DefaultFileType struct {
0000000000000000000000000000000000000000;;		Format   func([]byte) ([]byte, error)
0000000000000000000000000000000000000000;;		Assemble func(io.Writer, *File)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft DefaultFileType) AssembleFile(f *File, pathname string) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Assembling file %q", pathname)
0000000000000000000000000000000000000000;;		destFile, err := os.Create(pathname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer destFile.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		et := NewErrorTracker(b)
0000000000000000000000000000000000000000;;		ft.Assemble(et, f)
0000000000000000000000000000000000000000;;		if et.Error() != nil {
0000000000000000000000000000000000000000;;			return et.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if formatted, err := ft.Format(b.Bytes()); err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("unable to format file %q (%v).", pathname, err)
0000000000000000000000000000000000000000;;			// Write the file anyway, so they can see what's going wrong and fix the generator.
0000000000000000000000000000000000000000;;			if _, err2 := destFile.Write(b.Bytes()); err2 != nil {
0000000000000000000000000000000000000000;;				return err2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, err = destFile.Write(formatted)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ft DefaultFileType) VerifyFile(f *File, pathname string) error {
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Verifying file %q", pathname)
0000000000000000000000000000000000000000;;		friendlyName := filepath.Join(f.PackageName, f.Name)
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		et := NewErrorTracker(b)
0000000000000000000000000000000000000000;;		ft.Assemble(et, f)
0000000000000000000000000000000000000000;;		if et.Error() != nil {
0000000000000000000000000000000000000000;;			return et.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		formatted, err := ft.Format(b.Bytes())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to format the output for %q: %v", friendlyName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		existing, err := ioutil.ReadFile(pathname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to read file %q for comparison: %v", friendlyName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bytes.Compare(formatted, existing) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Be nice and find the first place where they differ
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < len(formatted) && i < len(existing) && formatted[i] == existing[i] {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eDiff, fDiff := existing[i:], formatted[i:]
0000000000000000000000000000000000000000;;		if len(eDiff) > 100 {
0000000000000000000000000000000000000000;;			eDiff = eDiff[:100]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fDiff) > 100 {
0000000000000000000000000000000000000000;;			fDiff = fDiff[:100]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("output for %q differs; first existing/expected diff: \n  %q\n  %q", friendlyName, string(eDiff), string(fDiff))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func assembleGolangFile(w io.Writer, f *File) {
0000000000000000000000000000000000000000;;		w.Write(f.Header)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "package %v\n\n", f.PackageName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(f.Imports) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprint(w, "import (\n")
0000000000000000000000000000000000000000;;			// TODO: sort imports like goimports does.
0000000000000000000000000000000000000000;;			for i := range f.Imports {
0000000000000000000000000000000000000000;;				if strings.Contains(i, "\"") {
0000000000000000000000000000000000000000;;					// they included quotes, or are using the
0000000000000000000000000000000000000000;;					// `name "path/to/pkg"` format.
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "\t%s\n", i)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "\t%q\n", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprint(w, ")\n\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.Vars.Len() > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprint(w, "var (\n")
0000000000000000000000000000000000000000;;			w.Write(f.Vars.Bytes())
0000000000000000000000000000000000000000;;			fmt.Fprint(w, ")\n\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.Consts.Len() > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprint(w, "const (\n")
0000000000000000000000000000000000000000;;			w.Write(f.Consts.Bytes())
0000000000000000000000000000000000000000;;			fmt.Fprint(w, ")\n\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Write(f.Body.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGolangFile() *DefaultFileType {
0000000000000000000000000000000000000000;;		return &DefaultFileType{
0000000000000000000000000000000000000000;;			Format:   format.Source,
0000000000000000000000000000000000000000;;			Assemble: assembleGolangFile,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// format should be one line only, and not end with \n.
0000000000000000000000000000000000000000;;	func addIndentHeaderComment(b *bytes.Buffer, format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if b.Len() > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(b, "\n// "+format+"\n", args...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Fprintf(b, "// "+format+"\n", args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Context) filteredBy(f func(*Context, *types.Type) bool) *Context {
0000000000000000000000000000000000000000;;		c2 := *c
0000000000000000000000000000000000000000;;		c2.Order = []*types.Type{}
0000000000000000000000000000000000000000;;		for _, t := range c.Order {
0000000000000000000000000000000000000000;;			if f(c, t) {
0000000000000000000000000000000000000000;;				c2.Order = append(c2.Order, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &c2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// make a new context; inheret c.Namers, but add on 'namers'. In case of a name
0000000000000000000000000000000000000000;;	// collision, the namer in 'namers' wins.
0000000000000000000000000000000000000000;;	func (c *Context) addNameSystems(namers namer.NameSystems) *Context {
0000000000000000000000000000000000000000;;		if namers == nil {
0000000000000000000000000000000000000000;;			return c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c2 := *c
0000000000000000000000000000000000000000;;		// Copy the existing name systems so we don't corrupt a parent context
0000000000000000000000000000000000000000;;		c2.Namers = namer.NameSystems{}
0000000000000000000000000000000000000000;;		for k, v := range c.Namers {
0000000000000000000000000000000000000000;;			c2.Namers[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, namer := range namers {
0000000000000000000000000000000000000000;;			c2.Namers[name] = namer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &c2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecutePackage executes a single package. 'outDir' is the base directory in
0000000000000000000000000000000000000000;;	// which to place the package; it should be a physical path on disk, not an
0000000000000000000000000000000000000000;;	// import path. e.g.: '/path/to/home/path/to/gopath/src/' The package knows its
0000000000000000000000000000000000000000;;	// import path already, this will be appended to 'outDir'.
0000000000000000000000000000000000000000;;	func (c *Context) ExecutePackage(outDir string, p Package) error {
0000000000000000000000000000000000000000;;		path := filepath.Join(outDir, p.Path())
0000000000000000000000000000000000000000;;		glog.V(2).Infof("Processing package %q, disk location %q", p.Name(), path)
0000000000000000000000000000000000000000;;		// Filter out any types the *package* doesn't care about.
0000000000000000000000000000000000000000;;		packageContext := c.filteredBy(p.Filter)
0000000000000000000000000000000000000000;;		os.MkdirAll(path, 0755)
0000000000000000000000000000000000000000;;		files := map[string]*File{}
0000000000000000000000000000000000000000;;		for _, g := range p.Generators(packageContext) {
0000000000000000000000000000000000000000;;			// Filter out types the *generator* doesn't care about.
0000000000000000000000000000000000000000;;			genContext := packageContext.filteredBy(g.Filter)
0000000000000000000000000000000000000000;;			// Now add any extra name systems defined by this generator
0000000000000000000000000000000000000000;;			genContext = genContext.addNameSystems(g.Namers(genContext))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fileType := g.FileType()
0000000000000000000000000000000000000000;;			if len(fileType) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("generator %q must specify a file type", g.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f := files[g.Filename()]
0000000000000000000000000000000000000000;;			if f == nil {
0000000000000000000000000000000000000000;;				// This is the first generator to reference this file, so start it.
0000000000000000000000000000000000000000;;				f = &File{
0000000000000000000000000000000000000000;;					Name:        g.Filename(),
0000000000000000000000000000000000000000;;					FileType:    fileType,
0000000000000000000000000000000000000000;;					PackageName: p.Name(),
0000000000000000000000000000000000000000;;					Header:      p.Header(g.Filename()),
0000000000000000000000000000000000000000;;					Imports:     map[string]struct{}{},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				files[f.Name] = f
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if f.FileType != g.FileType() {
0000000000000000000000000000000000000000;;					return fmt.Errorf("file %q already has type %q, but generator %q wants to use type %q", f.Name, f.FileType, g.Name(), g.FileType())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if vars := g.PackageVars(genContext); len(vars) > 0 {
0000000000000000000000000000000000000000;;				addIndentHeaderComment(&f.Vars, "Package-wide variables from generator %q.", g.Name())
0000000000000000000000000000000000000000;;				for _, v := range vars {
0000000000000000000000000000000000000000;;					if _, err := fmt.Fprintf(&f.Vars, "%s\n", v); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if consts := g.PackageConsts(genContext); len(consts) > 0 {
0000000000000000000000000000000000000000;;				addIndentHeaderComment(&f.Consts, "Package-wide consts from generator %q.", g.Name())
0000000000000000000000000000000000000000;;				for _, v := range consts {
0000000000000000000000000000000000000000;;					if _, err := fmt.Fprintf(&f.Consts, "%s\n", v); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := genContext.executeBody(&f.Body, g); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if imports := g.Imports(genContext); len(imports) > 0 {
0000000000000000000000000000000000000000;;				for _, i := range imports {
0000000000000000000000000000000000000000;;					f.Imports[i] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errors []error
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			finalPath := filepath.Join(path, f.Name)
0000000000000000000000000000000000000000;;			assembler, ok := c.FileTypes[f.FileType]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("the file type %q registered for file %q does not exist in the context", f.FileType, f.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if c.Verify {
0000000000000000000000000000000000000000;;				err = assembler.VerifyFile(f, finalPath)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = assembler.AssembleFile(f, finalPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("errors in package %q:\n%v\n", p.Path(), strings.Join(errs2strings(errors), "\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Context) executeBody(w io.Writer, generator Generator) error {
0000000000000000000000000000000000000000;;		et := NewErrorTracker(w)
0000000000000000000000000000000000000000;;		if err := generator.Init(c, et); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, t := range c.Order {
0000000000000000000000000000000000000000;;			if err := generator.GenerateType(c, t, et); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := generator.Finalize(c, et); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return et.Error()
0000000000000000000000000000000000000000;;	}
