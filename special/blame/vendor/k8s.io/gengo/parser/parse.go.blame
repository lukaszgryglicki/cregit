0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package parser
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"go/build"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		tc "go/types"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This clarifies when a pkg path has been canonicalized.
0000000000000000000000000000000000000000;;	type importPathString string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Builder lets you add all the go files in all the packages that you care
0000000000000000000000000000000000000000;;	// about, then constructs the type source data.
0000000000000000000000000000000000000000;;	type Builder struct {
0000000000000000000000000000000000000000;;		context *build.Context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map of package names to more canonical information about the package.
0000000000000000000000000000000000000000;;		// This might hold the same value for multiple names, e.g. if someone
0000000000000000000000000000000000000000;;		// referenced ./pkg/name or in the case of vendoring, which canonicalizes
0000000000000000000000000000000000000000;;		// differently that what humans would type.
0000000000000000000000000000000000000000;;		buildPackages map[string]*build.Package
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fset *token.FileSet
0000000000000000000000000000000000000000;;		// map of package path to list of parsed files
0000000000000000000000000000000000000000;;		parsed map[importPathString][]parsedFile
0000000000000000000000000000000000000000;;		// map of package path to absolute path (to prevent overlap)
0000000000000000000000000000000000000000;;		absPaths map[importPathString]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set by typeCheckPackage(), used by importPackage() and friends.
0000000000000000000000000000000000000000;;		typeCheckedPackages map[importPathString]*tc.Package
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map of package path to whether the user requested it or it was from
0000000000000000000000000000000000000000;;		// an import.
0000000000000000000000000000000000000000;;		userRequested map[importPathString]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All comments from everywhere in every parsed file.
0000000000000000000000000000000000000000;;		endLineToCommentGroup map[fileLine]*ast.CommentGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// map of package to list of packages it imports.
0000000000000000000000000000000000000000;;		importGraph map[importPathString]map[string]struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parsedFile is for tracking files with name
0000000000000000000000000000000000000000;;	type parsedFile struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		file *ast.File
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// key type for finding comments.
0000000000000000000000000000000000000000;;	type fileLine struct {
0000000000000000000000000000000000000000;;		file string
0000000000000000000000000000000000000000;;		line int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New constructs a new builder.
0000000000000000000000000000000000000000;;	func New() *Builder {
0000000000000000000000000000000000000000;;		c := build.Default
0000000000000000000000000000000000000000;;		if c.GOROOT == "" {
0000000000000000000000000000000000000000;;			if p, err := exec.Command("which", "go").CombinedOutput(); err == nil {
0000000000000000000000000000000000000000;;				// The returned string will have some/path/bin/go, so remove the last two elements.
0000000000000000000000000000000000000000;;				c.GOROOT = filepath.Dir(filepath.Dir(strings.Trim(string(p), "\n")))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Warningf("Warning: $GOROOT not set, and unable to run `which go` to find it: %v\n", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Force this to off, since we don't properly parse CGo.  All symbols must
0000000000000000000000000000000000000000;;		// have non-CGo equivalents.
0000000000000000000000000000000000000000;;		c.CgoEnabled = false
0000000000000000000000000000000000000000;;		return &Builder{
0000000000000000000000000000000000000000;;			context:               &c,
0000000000000000000000000000000000000000;;			buildPackages:         map[string]*build.Package{},
0000000000000000000000000000000000000000;;			typeCheckedPackages:   map[importPathString]*tc.Package{},
0000000000000000000000000000000000000000;;			fset:                  token.NewFileSet(),
0000000000000000000000000000000000000000;;			parsed:                map[importPathString][]parsedFile{},
0000000000000000000000000000000000000000;;			absPaths:              map[importPathString]string{},
0000000000000000000000000000000000000000;;			userRequested:         map[importPathString]bool{},
0000000000000000000000000000000000000000;;			endLineToCommentGroup: map[fileLine]*ast.CommentGroup{},
0000000000000000000000000000000000000000;;			importGraph:           map[importPathString]map[string]struct{}{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddBuildTags adds the specified build tags to the parse context.
0000000000000000000000000000000000000000;;	func (b *Builder) AddBuildTags(tags ...string) {
0000000000000000000000000000000000000000;;		b.context.BuildTags = append(b.context.BuildTags, tags...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get package information from the go/build package. Automatically excludes
0000000000000000000000000000000000000000;;	// e.g. test files and files for other platforms-- there is quite a bit of
0000000000000000000000000000000000000000;;	// logic of that nature in the build package.
0000000000000000000000000000000000000000;;	func (b *Builder) importBuildPackage(dir string) (*build.Package, error) {
0000000000000000000000000000000000000000;;		if buildPkg, ok := b.buildPackages[dir]; ok {
0000000000000000000000000000000000000000;;			return buildPkg, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This validates the `package foo // github.com/bar/foo` comments.
0000000000000000000000000000000000000000;;		buildPkg, err := b.importWithMode(dir, build.ImportComment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(*build.NoGoError); !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to import %q: %v", dir, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buildPkg == nil {
0000000000000000000000000000000000000000;;			// Might be an empty directory. Try to just find the dir.
0000000000000000000000000000000000000000;;			buildPkg, err = b.importWithMode(dir, build.FindOnly)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remember it under the user-provided name.
0000000000000000000000000000000000000000;;		glog.V(5).Infof("saving buildPackage %s", dir)
0000000000000000000000000000000000000000;;		b.buildPackages[dir] = buildPkg
0000000000000000000000000000000000000000;;		canonicalPackage := canonicalizeImportPath(buildPkg.ImportPath)
0000000000000000000000000000000000000000;;		if dir != string(canonicalPackage) {
0000000000000000000000000000000000000000;;			// Since `dir` is not the canonical name, see if we knew it under another name.
0000000000000000000000000000000000000000;;			if buildPkg, ok := b.buildPackages[string(canonicalPackage)]; ok {
0000000000000000000000000000000000000000;;				return buildPkg, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Must be new, save it under the canonical name, too.
0000000000000000000000000000000000000000;;			glog.V(5).Infof("saving buildPackage %s", canonicalPackage)
0000000000000000000000000000000000000000;;			b.buildPackages[string(canonicalPackage)] = buildPkg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buildPkg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFileForTest adds a file to the set, without verifying that the provided
0000000000000000000000000000000000000000;;	// pkg actually exists on disk. The pkg must be of the form "canonical/pkg/path"
0000000000000000000000000000000000000000;;	// and the path must be the absolute path to the file.  Because this bypasses
0000000000000000000000000000000000000000;;	// the normal recursive finding of package dependencies (on disk), test should
0000000000000000000000000000000000000000;;	// sort their test files topologically first, so all deps are resolved by the
0000000000000000000000000000000000000000;;	// time we need them.
0000000000000000000000000000000000000000;;	func (b *Builder) AddFileForTest(pkg string, path string, src []byte) error {
0000000000000000000000000000000000000000;;		if err := b.addFile(importPathString(pkg), path, src, true); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := b.typeCheckPackage(importPathString(pkg)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addFile adds a file to the set. The pkgPath must be of the form
0000000000000000000000000000000000000000;;	// "canonical/pkg/path" and the path must be the absolute path to the file. A
0000000000000000000000000000000000000000;;	// flag indicates whether this file was user-requested or just from following
0000000000000000000000000000000000000000;;	// the import graph.
0000000000000000000000000000000000000000;;	func (b *Builder) addFile(pkgPath importPathString, path string, src []byte, userRequested bool) error {
0000000000000000000000000000000000000000;;		for _, p := range b.parsed[pkgPath] {
0000000000000000000000000000000000000000;;			if path == p.name {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("addFile %s %s already parsed, skipping", pkgPath, path)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(6).Infof("addFile %s %s", pkgPath, path)
0000000000000000000000000000000000000000;;		p, err := parser.ParseFile(b.fset, path, src, parser.DeclarationErrors|parser.ParseComments)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is redundant with addDir, but some tests call AddFileForTest, which
0000000000000000000000000000000000000000;;		// call into here without calling addDir.
0000000000000000000000000000000000000000;;		b.userRequested[pkgPath] = userRequested || b.userRequested[pkgPath]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.parsed[pkgPath] = append(b.parsed[pkgPath], parsedFile{path, p})
0000000000000000000000000000000000000000;;		for _, c := range p.Comments {
0000000000000000000000000000000000000000;;			position := b.fset.Position(c.End())
0000000000000000000000000000000000000000;;			b.endLineToCommentGroup[fileLine{position.Filename, position.Line}] = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have to get the packages from this specific file, in case the
0000000000000000000000000000000000000000;;		// user added individual files instead of entire directories.
0000000000000000000000000000000000000000;;		if b.importGraph[pkgPath] == nil {
0000000000000000000000000000000000000000;;			b.importGraph[pkgPath] = map[string]struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, im := range p.Imports {
0000000000000000000000000000000000000000;;			importedPath := strings.Trim(im.Path.Value, `"`)
0000000000000000000000000000000000000000;;			b.importGraph[pkgPath][importedPath] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDir adds an entire directory, scanning it for go files. 'dir' should have
0000000000000000000000000000000000000000;;	// a single go package in it. GOPATH, GOROOT, and the location of your go
0000000000000000000000000000000000000000;;	// binary (`which go`) will all be searched if dir doesn't literally resolve.
0000000000000000000000000000000000000000;;	func (b *Builder) AddDir(dir string) error {
0000000000000000000000000000000000000000;;		_, err := b.importPackage(dir, true)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDirRecursive is just like AddDir, but it also recursively adds
0000000000000000000000000000000000000000;;	// subdirectories; it returns an error only if the path couldn't be resolved;
0000000000000000000000000000000000000000;;	// any directories recursed into without go source are ignored.
0000000000000000000000000000000000000000;;	func (b *Builder) AddDirRecursive(dir string) error {
0000000000000000000000000000000000000000;;		// Add the root.
0000000000000000000000000000000000000000;;		if _, err := b.importPackage(dir, true); err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Ignoring directory %v: %v", dir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// filepath.Walk includes the root dir, but we already did that, so we'll
0000000000000000000000000000000000000000;;		// remove that prefix and rebuild a package import path.
0000000000000000000000000000000000000000;;		prefix := b.buildPackages[dir].Dir
0000000000000000000000000000000000000000;;		fn := func(path string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			if info != nil && info.IsDir() {
0000000000000000000000000000000000000000;;				rel := strings.TrimPrefix(path, prefix)
0000000000000000000000000000000000000000;;				if rel != "" {
0000000000000000000000000000000000000000;;					// Make a pkg path.
0000000000000000000000000000000000000000;;					pkg := filepath.Join(string(canonicalizeImportPath(b.buildPackages[dir].ImportPath)), rel)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Add it.
0000000000000000000000000000000000000000;;					if _, err := b.importPackage(pkg, true); err != nil {
0000000000000000000000000000000000000000;;						glog.Warningf("Ignoring child directory %v: %v", pkg, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := filepath.Walk(b.buildPackages[dir].Dir, fn); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDirTo adds an entire directory to a given Universe. Unlike AddDir, this
0000000000000000000000000000000000000000;;	// processes the package immediately, which makes it safe to use from within a
0000000000000000000000000000000000000000;;	// generator (rather than just at init time. 'dir' must be a single go package.
0000000000000000000000000000000000000000;;	// GOPATH, GOROOT, and the location of your go binary (`which go`) will all be
0000000000000000000000000000000000000000;;	// searched if dir doesn't literally resolve.
0000000000000000000000000000000000000000;;	// Deprecated. Please use AddDirectoryTo.
0000000000000000000000000000000000000000;;	func (b *Builder) AddDirTo(dir string, u *types.Universe) error {
0000000000000000000000000000000000000000;;		// We want all types from this package, as if they were directly added
0000000000000000000000000000000000000000;;		// by the user.  They WERE added by the user, in effect.
0000000000000000000000000000000000000000;;		if _, err := b.importPackage(dir, true); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.findTypesIn(canonicalizeImportPath(b.buildPackages[dir].ImportPath), u)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDirectoryTo adds an entire directory to a given Universe. Unlike AddDir,
0000000000000000000000000000000000000000;;	// this processes the package immediately, which makes it safe to use from
0000000000000000000000000000000000000000;;	// within a generator (rather than just at init time. 'dir' must be a single go
0000000000000000000000000000000000000000;;	// package. GOPATH, GOROOT, and the location of your go binary (`which go`)
0000000000000000000000000000000000000000;;	// will all be searched if dir doesn't literally resolve.
0000000000000000000000000000000000000000;;	func (b *Builder) AddDirectoryTo(dir string, u *types.Universe) (*types.Package, error) {
0000000000000000000000000000000000000000;;		// We want all types from this package, as if they were directly added
0000000000000000000000000000000000000000;;		// by the user.  They WERE added by the user, in effect.
0000000000000000000000000000000000000000;;		if _, err := b.importPackage(dir, true); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path := canonicalizeImportPath(b.buildPackages[dir].ImportPath)
0000000000000000000000000000000000000000;;		if err := b.findTypesIn(path, u); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.Package(string(path)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The implementation of AddDir. A flag indicates whether this directory was
0000000000000000000000000000000000000000;;	// user-requested or just from following the import graph.
0000000000000000000000000000000000000000;;	func (b *Builder) addDir(dir string, userRequested bool) error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("addDir %s", dir)
0000000000000000000000000000000000000000;;		buildPkg, err := b.importBuildPackage(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		canonicalPackage := canonicalizeImportPath(buildPkg.ImportPath)
0000000000000000000000000000000000000000;;		pkgPath := canonicalPackage
0000000000000000000000000000000000000000;;		if dir != string(canonicalPackage) {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("addDir %s, canonical path is %s", dir, pkgPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sanity check the pkg dir has not changed.
0000000000000000000000000000000000000000;;		if prev, found := b.absPaths[pkgPath]; found {
0000000000000000000000000000000000000000;;			if buildPkg.Dir != prev {
0000000000000000000000000000000000000000;;				return fmt.Errorf("package %q (%s) previously resolved to %s", pkgPath, buildPkg.Dir, prev)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			b.absPaths[pkgPath] = buildPkg.Dir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range buildPkg.GoFiles {
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(n, ".go") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			absPath := filepath.Join(buildPkg.Dir, n)
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadFile(absPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("while loading %q: %v", absPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = b.addFile(pkgPath, absPath, data, userRequested)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("while parsing %q: %v", absPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// importPackage is a function that will be called by the type check package when it
0000000000000000000000000000000000000000;;	// needs to import a go package. 'path' is the import path.
0000000000000000000000000000000000000000;;	func (b *Builder) importPackage(dir string, userRequested bool) (*tc.Package, error) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("importPackage %s", dir)
0000000000000000000000000000000000000000;;		var pkgPath = importPathString(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the canonical path if we can.
0000000000000000000000000000000000000000;;		if buildPkg := b.buildPackages[dir]; buildPkg != nil {
0000000000000000000000000000000000000000;;			canonicalPackage := canonicalizeImportPath(buildPkg.ImportPath)
0000000000000000000000000000000000000000;;			glog.V(5).Infof("importPackage %s, canonical path is %s", dir, canonicalPackage)
0000000000000000000000000000000000000000;;			pkgPath = canonicalPackage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have not seen this before, process it now.
0000000000000000000000000000000000000000;;		ignoreError := false
0000000000000000000000000000000000000000;;		if _, found := b.parsed[pkgPath]; !found {
0000000000000000000000000000000000000000;;			// Ignore errors in paths that we're importing solely because
0000000000000000000000000000000000000000;;			// they're referenced by other packages.
0000000000000000000000000000000000000000;;			ignoreError = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add it.
0000000000000000000000000000000000000000;;			if err := b.addDir(dir, userRequested); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the canonical path now that it has been added.
0000000000000000000000000000000000000000;;			if buildPkg := b.buildPackages[dir]; buildPkg != nil {
0000000000000000000000000000000000000000;;				canonicalPackage := canonicalizeImportPath(buildPkg.ImportPath)
0000000000000000000000000000000000000000;;				glog.V(5).Infof("importPackage %s, canonical path is %s", dir, canonicalPackage)
0000000000000000000000000000000000000000;;				pkgPath = canonicalPackage
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If it was previously known, just check that the user-requestedness hasn't
0000000000000000000000000000000000000000;;		// changed.
0000000000000000000000000000000000000000;;		b.userRequested[pkgPath] = userRequested || b.userRequested[pkgPath]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the type checker.  We may end up doing this to pkgs that are already
0000000000000000000000000000000000000000;;		// done, or are in the queue to be done later, but it will short-circuit,
0000000000000000000000000000000000000000;;		// and we can't miss pkgs that are only depended on.
0000000000000000000000000000000000000000;;		pkg, err := b.typeCheckPackage(pkgPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ignoreError && pkg != nil:
0000000000000000000000000000000000000000;;				glog.V(2).Infof("type checking encountered some issues in %q, but ignoring.\n", pkgPath)
0000000000000000000000000000000000000000;;			case !ignoreError && pkg != nil:
0000000000000000000000000000000000000000;;				glog.V(2).Infof("type checking encountered some errors in %q\n", pkgPath)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pkg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type importAdapter struct {
0000000000000000000000000000000000000000;;		b *Builder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a importAdapter) Import(path string) (*tc.Package, error) {
0000000000000000000000000000000000000000;;		return a.b.importPackage(path, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeCheckPackage will attempt to return the package even if there are some
0000000000000000000000000000000000000000;;	// errors, so you may check whether the package is nil or not even if you get
0000000000000000000000000000000000000000;;	// an error.
0000000000000000000000000000000000000000;;	func (b *Builder) typeCheckPackage(pkgPath importPathString) (*tc.Package, error) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("typeCheckPackage %s", pkgPath)
0000000000000000000000000000000000000000;;		if pkg, ok := b.typeCheckedPackages[pkgPath]; ok {
0000000000000000000000000000000000000000;;			if pkg != nil {
0000000000000000000000000000000000000000;;				glog.V(6).Infof("typeCheckPackage %s already done", pkgPath)
0000000000000000000000000000000000000000;;				return pkg, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We store a nil right before starting work on a package. So
0000000000000000000000000000000000000000;;			// if we get here and it's present and nil, that means there's
0000000000000000000000000000000000000000;;			// another invocation of this function on the call stack
0000000000000000000000000000000000000000;;			// already processing this package.
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("circular dependency for %q", pkgPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parsedFiles, ok := b.parsed[pkgPath]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No files for pkg %q: %#v", pkgPath, b.parsed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		files := make([]*ast.File, len(parsedFiles))
0000000000000000000000000000000000000000;;		for i := range parsedFiles {
0000000000000000000000000000000000000000;;			files[i] = parsedFiles[i].file
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.typeCheckedPackages[pkgPath] = nil
0000000000000000000000000000000000000000;;		c := tc.Config{
0000000000000000000000000000000000000000;;			IgnoreFuncBodies: true,
0000000000000000000000000000000000000000;;			// Note that importAdapter can call b.importPackage which calls this
0000000000000000000000000000000000000000;;			// method. So there can't be cycles in the import graph.
0000000000000000000000000000000000000000;;			Importer: importAdapter{b},
0000000000000000000000000000000000000000;;			Error: func(err error) {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("type checker: %v\n", err)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pkg, err := c.Check(string(pkgPath), b.fset, files, nil)
0000000000000000000000000000000000000000;;		b.typeCheckedPackages[pkgPath] = pkg // record the result whether or not there was an error
0000000000000000000000000000000000000000;;		return pkg, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindPackages fetches a list of the user-imported packages.
0000000000000000000000000000000000000000;;	// Note that you need to call b.FindTypes() first.
0000000000000000000000000000000000000000;;	func (b *Builder) FindPackages() []string {
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for pkgPath := range b.typeCheckedPackages {
0000000000000000000000000000000000000000;;			if b.userRequested[pkgPath] {
0000000000000000000000000000000000000000;;				// Since walkType is recursive, all types that are in packages that
0000000000000000000000000000000000000000;;				// were directly mentioned will be included.  We don't need to
0000000000000000000000000000000000000000;;				// include all types in all transitive packages, though.
0000000000000000000000000000000000000000;;				result = append(result, string(pkgPath))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindTypes finalizes the package imports, and searches through all the
0000000000000000000000000000000000000000;;	// packages for types.
0000000000000000000000000000000000000000;;	func (b *Builder) FindTypes() (types.Universe, error) {
0000000000000000000000000000000000000000;;		u := types.Universe{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Take a snapshot of pkgs to iterate, since this will recursively mutate
0000000000000000000000000000000000000000;;		// b.parsed.
0000000000000000000000000000000000000000;;		keys := []importPathString{}
0000000000000000000000000000000000000000;;		for pkgPath := range b.parsed {
0000000000000000000000000000000000000000;;			keys = append(keys, pkgPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pkgPath := range keys {
0000000000000000000000000000000000000000;;			if err := b.findTypesIn(pkgPath, &u); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findTypesIn finalizes the package import and searches through the package
0000000000000000000000000000000000000000;;	// for types.
0000000000000000000000000000000000000000;;	func (b *Builder) findTypesIn(pkgPath importPathString, u *types.Universe) error {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("findTypesIn %s", pkgPath)
0000000000000000000000000000000000000000;;		pkg := b.typeCheckedPackages[pkgPath]
0000000000000000000000000000000000000000;;		if pkg == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("findTypesIn(%s): package is not known", pkgPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !b.userRequested[pkgPath] {
0000000000000000000000000000000000000000;;			// Since walkType is recursive, all types that the
0000000000000000000000000000000000000000;;			// packages they asked for depend on will be included.
0000000000000000000000000000000000000000;;			// But we don't need to include all types in all
0000000000000000000000000000000000000000;;			// *packages* they depend on.
0000000000000000000000000000000000000000;;			glog.V(5).Infof("findTypesIn %s: package is not user requested", pkgPath)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We're keeping this package.  This call will create the record.
0000000000000000000000000000000000000000;;		u.Package(string(pkgPath)).Name = pkg.Name()
0000000000000000000000000000000000000000;;		u.Package(string(pkgPath)).Path = pkg.Path()
0000000000000000000000000000000000000000;;		u.Package(string(pkgPath)).SourcePath = b.absPaths[pkgPath]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range b.parsed[pkgPath] {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(f.name, "/doc.go") {
0000000000000000000000000000000000000000;;				tp := u.Package(string(pkgPath))
0000000000000000000000000000000000000000;;				// findTypesIn might be called multiple times. Clean up tp.Comments
0000000000000000000000000000000000000000;;				// to avoid repeatedly fill same comments to it.
0000000000000000000000000000000000000000;;				tp.Comments = []string{}
0000000000000000000000000000000000000000;;				for i := range f.file.Comments {
0000000000000000000000000000000000000000;;					tp.Comments = append(tp.Comments, splitLines(f.file.Comments[i].Text())...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if f.file.Doc != nil {
0000000000000000000000000000000000000000;;					tp.DocComments = splitLines(f.file.Doc.Text())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := pkg.Scope()
0000000000000000000000000000000000000000;;		for _, n := range s.Names() {
0000000000000000000000000000000000000000;;			obj := s.Lookup(n)
0000000000000000000000000000000000000000;;			tn, ok := obj.(*tc.TypeName)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				t := b.walkType(*u, nil, tn.Type())
0000000000000000000000000000000000000000;;				c1 := b.priorCommentLines(obj.Pos(), 1)
0000000000000000000000000000000000000000;;				// c1.Text() is safe if c1 is nil
0000000000000000000000000000000000000000;;				t.CommentLines = splitLines(c1.Text())
0000000000000000000000000000000000000000;;				if c1 == nil {
0000000000000000000000000000000000000000;;					t.SecondClosestCommentLines = splitLines(b.priorCommentLines(obj.Pos(), 2).Text())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.SecondClosestCommentLines = splitLines(b.priorCommentLines(c1.List[0].Slash, 2).Text())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tf, ok := obj.(*tc.Func)
0000000000000000000000000000000000000000;;			// We only care about functions, not concrete/abstract methods.
0000000000000000000000000000000000000000;;			if ok && tf.Type() != nil && tf.Type().(*tc.Signature).Recv() == nil {
0000000000000000000000000000000000000000;;				t := b.addFunction(*u, nil, tf)
0000000000000000000000000000000000000000;;				c1 := b.priorCommentLines(obj.Pos(), 1)
0000000000000000000000000000000000000000;;				// c1.Text() is safe if c1 is nil
0000000000000000000000000000000000000000;;				t.CommentLines = splitLines(c1.Text())
0000000000000000000000000000000000000000;;				if c1 == nil {
0000000000000000000000000000000000000000;;					t.SecondClosestCommentLines = splitLines(b.priorCommentLines(obj.Pos(), 2).Text())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.SecondClosestCommentLines = splitLines(b.priorCommentLines(c1.List[0].Slash, 2).Text())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tv, ok := obj.(*tc.Var)
0000000000000000000000000000000000000000;;			if ok && !tv.IsField() {
0000000000000000000000000000000000000000;;				b.addVariable(*u, nil, tv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for p := range b.importGraph[pkgPath] {
0000000000000000000000000000000000000000;;			u.AddImports(string(pkgPath), p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) importWithMode(dir string, mode build.ImportMode) (*build.Package, error) {
0000000000000000000000000000000000000000;;		// This is a bit of a hack.  The srcDir argument to Import() should
0000000000000000000000000000000000000000;;		// properly be the dir of the file which depends on the package to be
0000000000000000000000000000000000000000;;		// imported, so that vendoring can work properly and local paths can
0000000000000000000000000000000000000000;;		// resolve.  We assume that there is only one level of vendoring, and that
0000000000000000000000000000000000000000;;		// the CWD is inside the GOPATH, so this should be safe. Nobody should be
0000000000000000000000000000000000000000;;		// using local (relative) paths except on the CLI, so CWD is also
0000000000000000000000000000000000000000;;		// sufficient.
0000000000000000000000000000000000000000;;		cwd, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to get current directory: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buildPkg, err := b.context.Import(dir, cwd, mode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buildPkg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// if there's a comment on the line `lines` before pos, return its text, otherwise "".
0000000000000000000000000000000000000000;;	func (b *Builder) priorCommentLines(pos token.Pos, lines int) *ast.CommentGroup {
0000000000000000000000000000000000000000;;		position := b.fset.Position(pos)
0000000000000000000000000000000000000000;;		key := fileLine{position.Filename, position.Line - lines}
0000000000000000000000000000000000000000;;		return b.endLineToCommentGroup[key]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func splitLines(str string) []string {
0000000000000000000000000000000000000000;;		return strings.Split(strings.TrimRight(str, "\n"), "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tcFuncNameToName(in string) types.Name {
0000000000000000000000000000000000000000;;		name := strings.TrimLeft(in, "func ")
0000000000000000000000000000000000000000;;		nameParts := strings.Split(name, "(")
0000000000000000000000000000000000000000;;		return tcNameToName(nameParts[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tcVarNameToName(in string) types.Name {
0000000000000000000000000000000000000000;;		nameParts := strings.Split(in, " ")
0000000000000000000000000000000000000000;;		// nameParts[0] is "var".
0000000000000000000000000000000000000000;;		// nameParts[2:] is the type of the variable, we ignore it for now.
0000000000000000000000000000000000000000;;		return tcNameToName(nameParts[1])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tcNameToName(in string) types.Name {
0000000000000000000000000000000000000000;;		// Detect anonymous type names. (These may have '.' characters because
0000000000000000000000000000000000000000;;		// embedded types may have packages, so we detect them specially.)
0000000000000000000000000000000000000000;;		if strings.HasPrefix(in, "struct{") ||
0000000000000000000000000000000000000000;;			strings.HasPrefix(in, "<-chan") ||
0000000000000000000000000000000000000000;;			strings.HasPrefix(in, "chan<-") ||
0000000000000000000000000000000000000000;;			strings.HasPrefix(in, "chan ") ||
0000000000000000000000000000000000000000;;			strings.HasPrefix(in, "func(") ||
0000000000000000000000000000000000000000;;			strings.HasPrefix(in, "*") ||
0000000000000000000000000000000000000000;;			strings.HasPrefix(in, "map[") ||
0000000000000000000000000000000000000000;;			strings.HasPrefix(in, "[") {
0000000000000000000000000000000000000000;;			return types.Name{Name: in}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, if there are '.' characters present, the name has a
0000000000000000000000000000000000000000;;		// package path in front.
0000000000000000000000000000000000000000;;		nameParts := strings.Split(in, ".")
0000000000000000000000000000000000000000;;		name := types.Name{Name: in}
0000000000000000000000000000000000000000;;		if n := len(nameParts); n >= 2 {
0000000000000000000000000000000000000000;;			// The final "." is the name of the type--previous ones must
0000000000000000000000000000000000000000;;			// have been in the package path.
0000000000000000000000000000000000000000;;			name.Package, name.Name = strings.Join(nameParts[:n-1], "."), nameParts[n-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) convertSignature(u types.Universe, t *tc.Signature) *types.Signature {
0000000000000000000000000000000000000000;;		signature := &types.Signature{}
0000000000000000000000000000000000000000;;		for i := 0; i < t.Params().Len(); i++ {
0000000000000000000000000000000000000000;;			signature.Parameters = append(signature.Parameters, b.walkType(u, nil, t.Params().At(i).Type()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < t.Results().Len(); i++ {
0000000000000000000000000000000000000000;;			signature.Results = append(signature.Results, b.walkType(u, nil, t.Results().At(i).Type()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r := t.Recv(); r != nil {
0000000000000000000000000000000000000000;;			signature.Receiver = b.walkType(u, nil, r.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signature.Variadic = t.Variadic()
0000000000000000000000000000000000000000;;		return signature
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// walkType adds the type, and any necessary child types.
0000000000000000000000000000000000000000;;	func (b *Builder) walkType(u types.Universe, useName *types.Name, in tc.Type) *types.Type {
0000000000000000000000000000000000000000;;		// Most of the cases are underlying types of the named type.
0000000000000000000000000000000000000000;;		name := tcNameToName(in.String())
0000000000000000000000000000000000000000;;		if useName != nil {
0000000000000000000000000000000000000000;;			name = *useName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := in.(type) {
0000000000000000000000000000000000000000;;		case *tc.Struct:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Struct
0000000000000000000000000000000000000000;;			for i := 0; i < t.NumFields(); i++ {
0000000000000000000000000000000000000000;;				f := t.Field(i)
0000000000000000000000000000000000000000;;				m := types.Member{
0000000000000000000000000000000000000000;;					Name:         f.Name(),
0000000000000000000000000000000000000000;;					Embedded:     f.Anonymous(),
0000000000000000000000000000000000000000;;					Tags:         t.Tag(i),
0000000000000000000000000000000000000000;;					Type:         b.walkType(u, nil, f.Type()),
0000000000000000000000000000000000000000;;					CommentLines: splitLines(b.priorCommentLines(f.Pos(), 1).Text()),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out.Members = append(out.Members, m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Map:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Map
0000000000000000000000000000000000000000;;			out.Elem = b.walkType(u, nil, t.Elem())
0000000000000000000000000000000000000000;;			out.Key = b.walkType(u, nil, t.Key())
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Pointer:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Pointer
0000000000000000000000000000000000000000;;			out.Elem = b.walkType(u, nil, t.Elem())
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Slice:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Slice
0000000000000000000000000000000000000000;;			out.Elem = b.walkType(u, nil, t.Elem())
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Array:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Array
0000000000000000000000000000000000000000;;			out.Elem = b.walkType(u, nil, t.Elem())
0000000000000000000000000000000000000000;;			// TODO: need to store array length, otherwise raw type name
0000000000000000000000000000000000000000;;			// cannot be properly written.
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Chan:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Chan
0000000000000000000000000000000000000000;;			out.Elem = b.walkType(u, nil, t.Elem())
0000000000000000000000000000000000000000;;			// TODO: need to store direction, otherwise raw type name
0000000000000000000000000000000000000000;;			// cannot be properly written.
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Basic:
0000000000000000000000000000000000000000;;			out := u.Type(types.Name{
0000000000000000000000000000000000000000;;				Package: "",
0000000000000000000000000000000000000000;;				Name:    t.Name(),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Unsupported
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Signature:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Func
0000000000000000000000000000000000000000;;			out.Signature = b.convertSignature(u, t)
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Interface:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Interface
0000000000000000000000000000000000000000;;			t.Complete()
0000000000000000000000000000000000000000;;			for i := 0; i < t.NumMethods(); i++ {
0000000000000000000000000000000000000000;;				if out.Methods == nil {
0000000000000000000000000000000000000000;;					out.Methods = map[string]*types.Type{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out.Methods[t.Method(i).Name()] = b.walkType(u, nil, t.Method(i).Type())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		case *tc.Named:
0000000000000000000000000000000000000000;;			var out *types.Type
0000000000000000000000000000000000000000;;			switch t.Underlying().(type) {
0000000000000000000000000000000000000000;;			case *tc.Named, *tc.Basic, *tc.Map, *tc.Slice:
0000000000000000000000000000000000000000;;				name := tcNameToName(t.String())
0000000000000000000000000000000000000000;;				out = u.Type(name)
0000000000000000000000000000000000000000;;				if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;					return out
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out.Kind = types.Alias
0000000000000000000000000000000000000000;;				out.Underlying = b.walkType(u, nil, t.Underlying())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// tc package makes everything "named" with an
0000000000000000000000000000000000000000;;				// underlying anonymous type--we remove that annoying
0000000000000000000000000000000000000000;;				// "feature" for users. This flattens those types
0000000000000000000000000000000000000000;;				// together.
0000000000000000000000000000000000000000;;				name := tcNameToName(t.String())
0000000000000000000000000000000000000000;;				if out := u.Type(name); out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;					return out // short circuit if we've already made this.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out = b.walkType(u, &name, t.Underlying())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the underlying type didn't already add methods, add them.
0000000000000000000000000000000000000000;;			// (Interface types will have already added methods.)
0000000000000000000000000000000000000000;;			if len(out.Methods) == 0 {
0000000000000000000000000000000000000000;;				for i := 0; i < t.NumMethods(); i++ {
0000000000000000000000000000000000000000;;					if out.Methods == nil {
0000000000000000000000000000000000000000;;						out.Methods = map[string]*types.Type{}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					out.Methods[t.Method(i).Name()] = b.walkType(u, nil, t.Method(i).Type())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			out := u.Type(name)
0000000000000000000000000000000000000000;;			if out.Kind != types.Unknown {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Kind = types.Unsupported
0000000000000000000000000000000000000000;;			glog.Warningf("Making unsupported type entry %q for: %#v\n", out, t)
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) addFunction(u types.Universe, useName *types.Name, in *tc.Func) *types.Type {
0000000000000000000000000000000000000000;;		name := tcFuncNameToName(in.String())
0000000000000000000000000000000000000000;;		if useName != nil {
0000000000000000000000000000000000000000;;			name = *useName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := u.Function(name)
0000000000000000000000000000000000000000;;		out.Kind = types.DeclarationOf
0000000000000000000000000000000000000000;;		out.Underlying = b.walkType(u, nil, in.Type())
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Builder) addVariable(u types.Universe, useName *types.Name, in *tc.Var) *types.Type {
0000000000000000000000000000000000000000;;		name := tcVarNameToName(in.String())
0000000000000000000000000000000000000000;;		if useName != nil {
0000000000000000000000000000000000000000;;			name = *useName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := u.Variable(name)
0000000000000000000000000000000000000000;;		out.Kind = types.DeclarationOf
0000000000000000000000000000000000000000;;		out.Underlying = b.walkType(u, nil, in.Type())
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// canonicalizeImportPath takes an import path and returns the actual package.
0000000000000000000000000000000000000000;;	// It doesn't support nested vendoring.
0000000000000000000000000000000000000000;;	func canonicalizeImportPath(importPath string) importPathString {
0000000000000000000000000000000000000000;;		if !strings.Contains(importPath, "/vendor/") {
0000000000000000000000000000000000000000;;			return importPathString(importPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return importPathString(importPath[strings.Index(importPath, "/vendor/")+len("/vendor/"):])
0000000000000000000000000000000000000000;;	}
