0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ref makes a reference to the given type. It can only be used for e.g.
0000000000000000000000000000000000000000;;	// passing to namers.
0000000000000000000000000000000000000000;;	func Ref(packageName, typeName string) *Type {
0000000000000000000000000000000000000000;;		return &Type{Name: Name{
0000000000000000000000000000000000000000;;			Name:    typeName,
0000000000000000000000000000000000000000;;			Package: packageName,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A type name may have a package qualifier.
0000000000000000000000000000000000000000;;	type Name struct {
0000000000000000000000000000000000000000;;		// Empty if embedded or builtin. This is the package path unless Path is specified.
0000000000000000000000000000000000000000;;		Package string
0000000000000000000000000000000000000000;;		// The type name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// An optional location of the type definition for languages that can have disjoint
0000000000000000000000000000000000000000;;		// packages and paths.
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the name formatted as a string.
0000000000000000000000000000000000000000;;	func (n Name) String() string {
0000000000000000000000000000000000000000;;		if n.Package == "" {
0000000000000000000000000000000000000000;;			return n.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.Package + "." + n.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The possible classes of types.
0000000000000000000000000000000000000000;;	type Kind string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Builtin is a primitive, like bool, string, int.
0000000000000000000000000000000000000000;;		Builtin Kind = "Builtin"
0000000000000000000000000000000000000000;;		Struct  Kind = "Struct"
0000000000000000000000000000000000000000;;		Map     Kind = "Map"
0000000000000000000000000000000000000000;;		Slice   Kind = "Slice"
0000000000000000000000000000000000000000;;		Pointer Kind = "Pointer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Alias is an alias of another type, e.g. in:
0000000000000000000000000000000000000000;;		//   type Foo string
0000000000000000000000000000000000000000;;		//   type Bar Foo
0000000000000000000000000000000000000000;;		// Bar is an alias of Foo.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// In the real go type system, Foo is a "Named" string; but to simplify
0000000000000000000000000000000000000000;;		// generation, this type system will just say that Foo *is* a builtin.
0000000000000000000000000000000000000000;;		// We then need "Alias" as a way for us to say that Bar *is* a Foo.
0000000000000000000000000000000000000000;;		Alias Kind = "Alias"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Interface is any type that could have differing types at run time.
0000000000000000000000000000000000000000;;		Interface Kind = "Interface"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The remaining types are included for completeness, but are not well
0000000000000000000000000000000000000000;;		// supported.
0000000000000000000000000000000000000000;;		Array Kind = "Array" // Array is just like slice, but has a fixed length.
0000000000000000000000000000000000000000;;		Chan  Kind = "Chan"
0000000000000000000000000000000000000000;;		Func  Kind = "Func"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeclarationOf is different from other Kinds; it indicates that instead of
0000000000000000000000000000000000000000;;		// representing an actual Type, the type is a declaration of an instance of
0000000000000000000000000000000000000000;;		// a type. E.g., a top-level function, variable, or constant. See the
0000000000000000000000000000000000000000;;		// comment for Type.Name for more detail.
0000000000000000000000000000000000000000;;		DeclarationOf Kind = "DeclarationOf"
0000000000000000000000000000000000000000;;		Unknown       Kind = ""
0000000000000000000000000000000000000000;;		Unsupported   Kind = "Unsupported"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Protobuf is protobuf type.
0000000000000000000000000000000000000000;;		Protobuf Kind = "Protobuf"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package holds package-level information.
0000000000000000000000000000000000000000;;	// Fields are public, as everything in this package, to enable consumption by
0000000000000000000000000000000000000000;;	// templates (for example). But it is strongly encouraged for code to build by
0000000000000000000000000000000000000000;;	// using the provided functions.
0000000000000000000000000000000000000000;;	type Package struct {
0000000000000000000000000000000000000000;;		// Canonical name of this package-- its path.
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The location this package was loaded from
0000000000000000000000000000000000000000;;		SourcePath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Short name of this package; the name that appears in the
0000000000000000000000000000000000000000;;		// 'package x' line.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The comment right above the package declaration in doc.go, if any.
0000000000000000000000000000000000000000;;		DocComments []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All comments from doc.go, if any.
0000000000000000000000000000000000000000;;		// TODO: remove Comments and use DocComments everywhere.
0000000000000000000000000000000000000000;;		Comments []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Types within this package, indexed by their name (*not* including
0000000000000000000000000000000000000000;;		// package name).
0000000000000000000000000000000000000000;;		Types map[string]*Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Functions within this package, indexed by their name (*not* including
0000000000000000000000000000000000000000;;		// package name).
0000000000000000000000000000000000000000;;		Functions map[string]*Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Global variables within this package, indexed by their name (*not* including
0000000000000000000000000000000000000000;;		// package name).
0000000000000000000000000000000000000000;;		Variables map[string]*Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Packages imported by this package, indexed by (canonicalized)
0000000000000000000000000000000000000000;;		// package path.
0000000000000000000000000000000000000000;;		Imports map[string]*Package
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if the given name references a type known to this package.
0000000000000000000000000000000000000000;;	func (p *Package) Has(name string) bool {
0000000000000000000000000000000000000000;;		_, has := p.Types[name]
0000000000000000000000000000000000000000;;		return has
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type gets the given Type in this Package.  If the Type is not already
0000000000000000000000000000000000000000;;	// defined, this will add it and return the new Type value.  The caller is
0000000000000000000000000000000000000000;;	// expected to finish initialization.
0000000000000000000000000000000000000000;;	func (p *Package) Type(typeName string) *Type {
0000000000000000000000000000000000000000;;		if t, ok := p.Types[typeName]; ok {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Path == "" {
0000000000000000000000000000000000000000;;			// Import the standard builtin types!
0000000000000000000000000000000000000000;;			if t, ok := builtins.Types[typeName]; ok {
0000000000000000000000000000000000000000;;				p.Types[typeName] = t
0000000000000000000000000000000000000000;;				return t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := &Type{Name: Name{Package: p.Path, Name: typeName}}
0000000000000000000000000000000000000000;;		p.Types[typeName] = t
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function gets the given function Type in this Package. If the function is
0000000000000000000000000000000000000000;;	// not already defined, this will add it.  If a function is added, it's the
0000000000000000000000000000000000000000;;	// caller's responsibility to finish construction of the function by setting
0000000000000000000000000000000000000000;;	// Underlying to the correct type.
0000000000000000000000000000000000000000;;	func (p *Package) Function(funcName string) *Type {
0000000000000000000000000000000000000000;;		if t, ok := p.Functions[funcName]; ok {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := &Type{Name: Name{Package: p.Path, Name: funcName}}
0000000000000000000000000000000000000000;;		t.Kind = DeclarationOf
0000000000000000000000000000000000000000;;		p.Functions[funcName] = t
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variable gets the given variable Type in this Package. If the variable is
0000000000000000000000000000000000000000;;	// not already defined, this will add it. If a variable is added, it's the caller's
0000000000000000000000000000000000000000;;	// responsibility to finish construction of the variable by setting Underlying
0000000000000000000000000000000000000000;;	// to the correct type.
0000000000000000000000000000000000000000;;	func (p *Package) Variable(varName string) *Type {
0000000000000000000000000000000000000000;;		if t, ok := p.Variables[varName]; ok {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := &Type{Name: Name{Package: p.Path, Name: varName}}
0000000000000000000000000000000000000000;;		t.Kind = DeclarationOf
0000000000000000000000000000000000000000;;		p.Variables[varName] = t
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasImport returns true if p imports packageName. Package names include the
0000000000000000000000000000000000000000;;	// package directory.
0000000000000000000000000000000000000000;;	func (p *Package) HasImport(packageName string) bool {
0000000000000000000000000000000000000000;;		_, has := p.Imports[packageName]
0000000000000000000000000000000000000000;;		return has
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Universe is a map of all packages. The key is the package name, but you
0000000000000000000000000000000000000000;;	// should use Package(), Type(), Function(), or Variable() instead of direct
0000000000000000000000000000000000000000;;	// access.
0000000000000000000000000000000000000000;;	type Universe map[string]*Package
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns the canonical type for the given fully-qualified name. Builtin
0000000000000000000000000000000000000000;;	// types will always be found, even if they haven't been explicitly added to
0000000000000000000000000000000000000000;;	// the map. If a non-existing type is requested, this will create (a marker for)
0000000000000000000000000000000000000000;;	// it.
0000000000000000000000000000000000000000;;	func (u Universe) Type(n Name) *Type {
0000000000000000000000000000000000000000;;		return u.Package(n.Package).Type(n.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function returns the canonical function for the given fully-qualified name.
0000000000000000000000000000000000000000;;	// If a non-existing function is requested, this will create (a marker for) it.
0000000000000000000000000000000000000000;;	// If a marker is created, it's the caller's responsibility to finish
0000000000000000000000000000000000000000;;	// construction of the function by setting Underlying to the correct type.
0000000000000000000000000000000000000000;;	func (u Universe) Function(n Name) *Type {
0000000000000000000000000000000000000000;;		return u.Package(n.Package).Function(n.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variable returns the canonical variable for the given fully-qualified name.
0000000000000000000000000000000000000000;;	// If a non-existing variable is requested, this will create (a marker for) it.
0000000000000000000000000000000000000000;;	// If a marker is created, it's the caller's responsibility to finish
0000000000000000000000000000000000000000;;	// construction of the variable by setting Underlying to the correct type.
0000000000000000000000000000000000000000;;	func (u Universe) Variable(n Name) *Type {
0000000000000000000000000000000000000000;;		return u.Package(n.Package).Variable(n.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddImports registers import lines for packageName. May be called multiple times.
0000000000000000000000000000000000000000;;	// You are responsible for canonicalizing all package paths.
0000000000000000000000000000000000000000;;	func (u Universe) AddImports(packagePath string, importPaths ...string) {
0000000000000000000000000000000000000000;;		p := u.Package(packagePath)
0000000000000000000000000000000000000000;;		for _, i := range importPaths {
0000000000000000000000000000000000000000;;			p.Imports[i] = u.Package(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package returns the Package for the given path.
0000000000000000000000000000000000000000;;	// If a non-existing package is requested, this will create (a marker for) it.
0000000000000000000000000000000000000000;;	// If a marker is created, it's the caller's responsibility to finish
0000000000000000000000000000000000000000;;	// construction of the package.
0000000000000000000000000000000000000000;;	func (u Universe) Package(packagePath string) *Package {
0000000000000000000000000000000000000000;;		if p, ok := u[packagePath]; ok {
0000000000000000000000000000000000000000;;			return p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := &Package{
0000000000000000000000000000000000000000;;			Path:      packagePath,
0000000000000000000000000000000000000000;;			Types:     map[string]*Type{},
0000000000000000000000000000000000000000;;			Functions: map[string]*Type{},
0000000000000000000000000000000000000000;;			Variables: map[string]*Type{},
0000000000000000000000000000000000000000;;			Imports:   map[string]*Package{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u[packagePath] = p
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type represents a subset of possible go types.
0000000000000000000000000000000000000000;;	type Type struct {
0000000000000000000000000000000000000000;;		// There are two general categories of types, those explicitly named
0000000000000000000000000000000000000000;;		// and those anonymous. Named ones will have a non-empty package in the
0000000000000000000000000000000000000000;;		// name field.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// An exception: If Kind == DeclarationOf, then this name is the name of a
0000000000000000000000000000000000000000;;		// top-level function, variable, or const, and the type can be found in Underlying.
0000000000000000000000000000000000000000;;		// We do this to allow the naming system to work against these objects, even
0000000000000000000000000000000000000000;;		// though they aren't strictly speaking types.
0000000000000000000000000000000000000000;;		Name Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The general kind of this type.
0000000000000000000000000000000000000000;;		Kind Kind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there are comment lines immediately before the type definition,
0000000000000000000000000000000000000000;;		// they will be recorded here.
0000000000000000000000000000000000000000;;		CommentLines []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there are comment lines preceding the `CommentLines`, they will be
0000000000000000000000000000000000000000;;		// recorded here. There are two cases:
0000000000000000000000000000000000000000;;		// ---
0000000000000000000000000000000000000000;;		// SecondClosestCommentLines
0000000000000000000000000000000000000000;;		// a blank line
0000000000000000000000000000000000000000;;		// CommentLines
0000000000000000000000000000000000000000;;		// type definition
0000000000000000000000000000000000000000;;		// ---
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// or
0000000000000000000000000000000000000000;;		// ---
0000000000000000000000000000000000000000;;		// SecondClosestCommentLines
0000000000000000000000000000000000000000;;		// a blank line
0000000000000000000000000000000000000000;;		// type definition
0000000000000000000000000000000000000000;;		// ---
0000000000000000000000000000000000000000;;		SecondClosestCommentLines []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Kind == Struct
0000000000000000000000000000000000000000;;		Members []Member
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Kind == Map, Slice, Pointer, or Chan
0000000000000000000000000000000000000000;;		Elem *Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Kind == Map, this is the map's key type.
0000000000000000000000000000000000000000;;		Key *Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Kind == Alias, this is the underlying type.
0000000000000000000000000000000000000000;;		// If Kind == DeclarationOf, this is the type of the declaration.
0000000000000000000000000000000000000000;;		Underlying *Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Kind == Interface, this is the set of all required functions.
0000000000000000000000000000000000000000;;		// Otherwise, if this is a named type, this is the list of methods that
0000000000000000000000000000000000000000;;		// type has. (All elements will have Kind=="Func")
0000000000000000000000000000000000000000;;		Methods map[string]*Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Kind == func, this is the signature of the function.
0000000000000000000000000000000000000000;;		Signature *Signature
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Add:
0000000000000000000000000000000000000000;;		// * channel direction
0000000000000000000000000000000000000000;;		// * array length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the name of the type.
0000000000000000000000000000000000000000;;	func (t *Type) String() string {
0000000000000000000000000000000000000000;;		return t.Name.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrimitive returns whether the type is a built-in type or is an alias to a
0000000000000000000000000000000000000000;;	// built-in type.  For example: strings and aliases of strings are primitives,
0000000000000000000000000000000000000000;;	// structs are not.
0000000000000000000000000000000000000000;;	func (t *Type) IsPrimitive() bool {
0000000000000000000000000000000000000000;;		if t.Kind == Builtin || (t.Kind == Alias && t.Underlying.Kind == Builtin) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAssignable returns whether the type is deep-assignable.  For example,
0000000000000000000000000000000000000000;;	// slices and maps and pointers are shallow copies, but ints and strings are
0000000000000000000000000000000000000000;;	// complete.
0000000000000000000000000000000000000000;;	func (t *Type) IsAssignable() bool {
0000000000000000000000000000000000000000;;		if t.IsPrimitive() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Kind == Struct {
0000000000000000000000000000000000000000;;			for _, m := range t.Members {
0000000000000000000000000000000000000000;;				if !m.Type.IsAssignable() {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAnonymousStruct returns true if the type is an anonymous struct or an alias
0000000000000000000000000000000000000000;;	// to an anonymous struct.
0000000000000000000000000000000000000000;;	func (t *Type) IsAnonymousStruct() bool {
0000000000000000000000000000000000000000;;		return (t.Kind == Struct && t.Name.Name == "struct{}") || (t.Kind == Alias && t.Underlying.IsAnonymousStruct())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A single struct member
0000000000000000000000000000000000000000;;	type Member struct {
0000000000000000000000000000000000000000;;		// The name of the member.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the member is embedded (anonymous) this will be true, and the
0000000000000000000000000000000000000000;;		// Name will be the type name.
0000000000000000000000000000000000000000;;		Embedded bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there are comment lines immediately before the member in the type
0000000000000000000000000000000000000000;;		// definition, they will be recorded here.
0000000000000000000000000000000000000000;;		CommentLines []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there are tags along with this member, they will be saved here.
0000000000000000000000000000000000000000;;		Tags string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The type of this member.
0000000000000000000000000000000000000000;;		Type *Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the name and type of the member.
0000000000000000000000000000000000000000;;	func (m Member) String() string {
0000000000000000000000000000000000000000;;		return m.Name + " " + m.Type.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signature is a function's signature.
0000000000000000000000000000000000000000;;	type Signature struct {
0000000000000000000000000000000000000000;;		// TODO: store the parameter names, not just types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If a method of some type, this is the type it's a member of.
0000000000000000000000000000000000000000;;		Receiver   *Type
0000000000000000000000000000000000000000;;		Parameters []*Type
0000000000000000000000000000000000000000;;		Results    []*Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// True if the last in parameter is of the form ...T.
0000000000000000000000000000000000000000;;		Variadic bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there are comment lines immediately before this
0000000000000000000000000000000000000000;;		// signature/method/function declaration, they will be recorded here.
0000000000000000000000000000000000000000;;		CommentLines []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Built in types.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		String = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "string"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Int64 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "int64"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Int32 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "int32"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Int16 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "int16"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Int = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "int"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Uint64 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "uint64"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Uint32 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "uint32"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Uint16 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "uint16"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Uint = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "uint"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Uintptr = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "uintptr"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Float64 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "float64"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Float32 = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "float32"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Float = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "float"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Bool = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "bool"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Byte = &Type{
0000000000000000000000000000000000000000;;			Name: Name{Name: "byte"},
0000000000000000000000000000000000000000;;			Kind: Builtin,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		builtins = &Package{
0000000000000000000000000000000000000000;;			Types: map[string]*Type{
0000000000000000000000000000000000000000;;				"bool":    Bool,
0000000000000000000000000000000000000000;;				"string":  String,
0000000000000000000000000000000000000000;;				"int":     Int,
0000000000000000000000000000000000000000;;				"int64":   Int64,
0000000000000000000000000000000000000000;;				"int32":   Int32,
0000000000000000000000000000000000000000;;				"int16":   Int16,
0000000000000000000000000000000000000000;;				"int8":    Byte,
0000000000000000000000000000000000000000;;				"uint":    Uint,
0000000000000000000000000000000000000000;;				"uint64":  Uint64,
0000000000000000000000000000000000000000;;				"uint32":  Uint32,
0000000000000000000000000000000000000000;;				"uint16":  Uint16,
0000000000000000000000000000000000000000;;				"uint8":   Byte,
0000000000000000000000000000000000000000;;				"uintptr": Uintptr,
0000000000000000000000000000000000000000;;				"byte":    Byte,
0000000000000000000000000000000000000000;;				"float":   Float,
0000000000000000000000000000000000000000;;				"float64": Float64,
0000000000000000000000000000000000000000;;				"float32": Float32,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Imports: map[string]*Package{},
0000000000000000000000000000000000000000;;			Path:    "",
0000000000000000000000000000000000000000;;			Name:    "",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsInteger(t *Type) bool {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case Int, Int64, Int32, Int16, Uint, Uint64, Uint32, Uint16, Byte:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
