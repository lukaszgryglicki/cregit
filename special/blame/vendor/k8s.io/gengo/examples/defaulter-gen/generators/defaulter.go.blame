0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8e194e7ee84bfdd889315410fbe51017a0b29426;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CustomArgs is used tby the go2idl framework to pass args specific to this
0000000000000000000000000000000000000000;;	// generator.
0000000000000000000000000000000000000000;;	type CustomArgs struct {
0000000000000000000000000000000000000000;;		ExtraPeerDirs []string // Always consider these as last-ditch possibilities for conversions.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the comment tags that carry parameters for defaulter generation.
0000000000000000000000000000000000000000;;	const tagName = "k8s:defaulter-gen"
0000000000000000000000000000000000000000;;	const intputTagName = "k8s:defaulter-gen-input"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractTag(comments []string) []string {
0000000000000000000000000000000000000000;;		return types.ExtractCommentTags("+", comments)[tagName]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractInputTag(comments []string) []string {
0000000000000000000000000000000000000000;;		return types.ExtractCommentTags("+", comments)[intputTagName]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkTag(comments []string, require ...string) bool {
0000000000000000000000000000000000000000;;		values := types.ExtractCommentTags("+", comments)[tagName]
0000000000000000000000000000000000000000;;		if len(require) == 0 {
0000000000000000000000000000000000000000;;			return len(values) == 1 && values[0] == ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(values, require)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultFnNamer() *namer.NameStrategy {
0000000000000000000000000000000000000000;;		return &namer.NameStrategy{
0000000000000000000000000000000000000000;;			Prefix: "SetDefaults_",
0000000000000000000000000000000000000000;;			Join: func(pre string, in []string, post string) string {
0000000000000000000000000000000000000000;;				return pre + strings.Join(in, "_") + post
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func objectDefaultFnNamer() *namer.NameStrategy {
0000000000000000000000000000000000000000;;		return &namer.NameStrategy{
0000000000000000000000000000000000000000;;			Prefix: "SetObjectDefaults_",
0000000000000000000000000000000000000000;;			Join: func(pre string, in []string, post string) string {
0000000000000000000000000000000000000000;;				return pre + strings.Join(in, "_") + post
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"public":          namer.NewPublicNamer(1),
0000000000000000000000000000000000000000;;			"raw":             namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;			"defaultfn":       defaultFnNamer(),
0000000000000000000000000000000000000000;;			"objectdefaultfn": objectDefaultFnNamer(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "public"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaults holds the declared defaulting functions for a given type (all defaulting functions
0000000000000000000000000000000000000000;;	// are expected to be func(1))
0000000000000000000000000000000000000000;;	type defaults struct {
0000000000000000000000000000000000000000;;		// object is the defaulter function for a top level type (typically one with TypeMeta) that
0000000000000000000000000000000000000000;;		// invokes all child defaulters. May be nil if the object defaulter has not yet been generated.
0000000000000000000000000000000000000000;;		object *types.Type
0000000000000000000000000000000000000000;;		// base is a defaulter function defined for a type SetDefaults_Pod which does not invoke all
0000000000000000000000000000000000000000;;		// child defaults - the base defaulter alone is insufficient to default a type
0000000000000000000000000000000000000000;;		base *types.Type
0000000000000000000000000000000000000000;;		// additional is zero or more defaulter functions of the form SetDefaults_Pod_XXXX that can be
0000000000000000000000000000000000000000;;		// included in the Object defaulter.
0000000000000000000000000000000000000000;;		additional []*types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All of the types in conversions map are of type "DeclarationOf" with
0000000000000000000000000000000000000000;;	// the underlying type being "Func".
0000000000000000000000000000000000000000;;	type defaulterFuncMap map[*types.Type]defaults
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns all manually-defined defaulting functions in the package.
0000000000000000000000000000000000000000;;	func getManualDefaultingFunctions(context *generator.Context, pkg *types.Package, manualMap defaulterFuncMap) {
0000000000000000000000000000000000000000;;		buffer := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(buffer, context, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range pkg.Functions {
0000000000000000000000000000000000000000;;			if f.Underlying == nil || f.Underlying.Kind != types.Func {
0000000000000000000000000000000000000000;;				glog.Errorf("Malformed function: %#v", f)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.Underlying.Signature == nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Function without signature: %#v", f)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			signature := f.Underlying.Signature
0000000000000000000000000000000000000000;;			// Check whether the function is defaulting function.
0000000000000000000000000000000000000000;;			// Note that all of them have signature:
0000000000000000000000000000000000000000;;			// object: func SetObjectDefaults_inType(*inType)
0000000000000000000000000000000000000000;;			// base: func SetDefaults_inType(*inType)
0000000000000000000000000000000000000000;;			// additional: func SetDefaults_inType_Qualifier(*inType)
0000000000000000000000000000000000000000;;			if signature.Receiver != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(signature.Parameters) != 1 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(signature.Results) != 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			inType := signature.Parameters[0]
0000000000000000000000000000000000000000;;			if inType.Kind != types.Pointer {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check if this is the primary defaulter.
0000000000000000000000000000000000000000;;			args := defaultingArgsFromType(inType.Elem)
0000000000000000000000000000000000000000;;			sw.Do("$.inType|defaultfn$", args)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case f.Name.Name == buffer.String():
0000000000000000000000000000000000000000;;				key := inType.Elem
0000000000000000000000000000000000000000;;				// We might scan the same package twice, and that's OK.
0000000000000000000000000000000000000000;;				v, ok := manualMap[key]
0000000000000000000000000000000000000000;;				if ok && v.base != nil && v.base.Name.Package != pkg.Path {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("duplicate static defaulter defined: %#v", key))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.base = f
0000000000000000000000000000000000000000;;				manualMap[key] = v
0000000000000000000000000000000000000000;;				glog.V(6).Infof("found base defaulter function for %s from %s", key.Name, f.Name)
0000000000000000000000000000000000000000;;			// Is one of the additional defaulters - a top level defaulter on a type that is
0000000000000000000000000000000000000000;;			// also invoked.
0000000000000000000000000000000000000000;;			case strings.HasPrefix(f.Name.Name, buffer.String()+"_"):
0000000000000000000000000000000000000000;;				key := inType.Elem
0000000000000000000000000000000000000000;;				v, ok := manualMap[key]
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					exists := false
0000000000000000000000000000000000000000;;					for _, existing := range v.additional {
0000000000000000000000000000000000000000;;						if existing.Name == f.Name {
0000000000000000000000000000000000000000;;							exists = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if exists {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.additional = append(v.additional, f)
0000000000000000000000000000000000000000;;				manualMap[key] = v
0000000000000000000000000000000000000000;;				glog.V(6).Infof("found additional defaulter function for %s from %s", key.Name, f.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.Reset()
0000000000000000000000000000000000000000;;			sw.Do("$.inType|objectdefaultfn$", args)
0000000000000000000000000000000000000000;;			if f.Name.Name == buffer.String() {
0000000000000000000000000000000000000000;;				key := inType.Elem
0000000000000000000000000000000000000000;;				// We might scan the same package twice, and that's OK.
0000000000000000000000000000000000000000;;				v, ok := manualMap[key]
0000000000000000000000000000000000000000;;				if ok && v.base != nil && v.base.Name.Package != pkg.Path {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("duplicate static defaulter defined: %#v", key))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.object = f
0000000000000000000000000000000000000000;;				manualMap[key] = v
0000000000000000000000000000000000000000;;				glog.V(6).Infof("found object defaulter function for %s from %s", key.Name, f.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packages := generator.Packages{}
0000000000000000000000000000000000000000;;		header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
0000000000000000000000000000000000000000;;		header = append(header, []byte(
0000000000000000000000000000000000000000;;			`
0000000000000000000000000000000000000000;;	// This file was autogenerated by defaulter-gen. Do not edit it manually!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Accumulate pre-existing default functions.
0000000000000000000000000000000000000000;;		// TODO: This is too ad-hoc.  We need a better way.
0000000000000000000000000000000000000000;;		existingDefaulters := defaulterFuncMap{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buffer := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(buffer, context, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We are generating defaults only for packages that are explicitly
0000000000000000000000000000000000000000;;		// passed as InputDir.
0000000000000000000000000000000000000000;;		for _, i := range context.Inputs {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("considering pkg %q", i)
0000000000000000000000000000000000000000;;			pkg := context.Universe[i]
0000000000000000000000000000000000000000;;			if pkg == nil {
0000000000000000000000000000000000000000;;				// If the input had no Go files, for example.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// typesPkg is where the types that needs defaulter are defined.
0000000000000000000000000000000000000000;;			// Sometimes it is different from pkg. For example, kubernetes core/v1
0000000000000000000000000000000000000000;;			// types are defined in vendor/k8s.io/api/core/v1, while pkg is at
0000000000000000000000000000000000000000;;			// pkg/api/v1.
0000000000000000000000000000000000000000;;			typesPkg := pkg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add defaulting functions.
0000000000000000000000000000000000000000;;			getManualDefaultingFunctions(context, pkg, existingDefaulters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var peerPkgs []string
0000000000000000000000000000000000000000;;			if customArgs, ok := arguments.CustomArgs.(*CustomArgs); ok {
0000000000000000000000000000000000000000;;				for _, pkg := range customArgs.ExtraPeerDirs {
0000000000000000000000000000000000000000;;					if i := strings.Index(pkg, "/vendor/"); i != -1 {
0000000000000000000000000000000000000000;;						pkg = pkg[i+len("/vendor/"):]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					peerPkgs = append(peerPkgs, pkg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make sure our peer-packages are added and fully parsed.
0000000000000000000000000000000000000000;;			for _, pp := range peerPkgs {
0000000000000000000000000000000000000000;;				context.AddDir(pp)
0000000000000000000000000000000000000000;;				getManualDefaultingFunctions(context, context.Universe[pp], existingDefaulters)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			typesWith := extractTag(pkg.Comments)
0000000000000000000000000000000000000000;;			shouldCreateObjectDefaulterFn := func(t *types.Type) bool {
0000000000000000000000000000000000000000;;				if defaults, ok := existingDefaulters[t]; ok && defaults.object != nil {
0000000000000000000000000000000000000000;;					// A default generator is defined
0000000000000000000000000000000000000000;;					glog.V(5).Infof("  an object defaulter already exists as %s", defaults.base.Name)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// opt-out
0000000000000000000000000000000000000000;;				if checkTag(t.SecondClosestCommentLines, "false") {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// opt-in
0000000000000000000000000000000000000000;;				if checkTag(t.SecondClosestCommentLines, "true") {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// For every k8s:defaulter-gen tag at the package level, interpret the value as a
0000000000000000000000000000000000000000;;				// field name (like TypeMeta, ListMeta, ObjectMeta) and trigger defaulter generation
0000000000000000000000000000000000000000;;				// for any type with any of the matching field names. Provides a more useful package
0000000000000000000000000000000000000000;;				// level defaulting than global (because we only need defaulters on a subset of objects -
0000000000000000000000000000000000000000;;				// usually those with TypeMeta).
0000000000000000000000000000000000000000;;				if t.Kind == types.Struct && len(typesWith) > 0 {
0000000000000000000000000000000000000000;;					for _, field := range t.Members {
0000000000000000000000000000000000000000;;						for _, s := range typesWith {
0000000000000000000000000000000000000000;;							if field.Name == s {
0000000000000000000000000000000000000000;;								return true
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if the types are not in the same package where the defaulter functions to be generated
0000000000000000000000000000000000000000;;			inputTags := extractInputTag(pkg.Comments)
0000000000000000000000000000000000000000;;			if len(inputTags) > 1 {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("there could only be one input tag, got %#v", inputTags))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(inputTags) == 1 {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				typesPkg, err = context.AddDirectory(filepath.Join(pkg.Path, inputTags[0]))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Fatalf("cannot import package %s", inputTags[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// update context.Order to the latest context.Universe
0000000000000000000000000000000000000000;;				orderer := namer.Orderer{Namer: namer.NewPublicNamer(1)}
0000000000000000000000000000000000000000;;				context.Order = orderer.OrderUniverse(context.Universe)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newDefaulters := defaulterFuncMap{}
0000000000000000000000000000000000000000;;			for _, t := range typesPkg.Types {
0000000000000000000000000000000000000000;;				if !shouldCreateObjectDefaulterFn(t) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if namer.IsPrivateGoName(t.Name.Name) {
0000000000000000000000000000000000000000;;					// We won't be able to convert to a private type.
0000000000000000000000000000000000000000;;					glog.V(5).Infof("  found a type %v, but it is a private name", t)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// create a synthetic type we can use during generation
0000000000000000000000000000000000000000;;				newDefaulters[t] = defaults{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// only generate defaulters for objects that actually have defined defaulters
0000000000000000000000000000000000000000;;			// prevents empty defaulters from being registered
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				promoted := 0
0000000000000000000000000000000000000000;;				for t, d := range newDefaulters {
0000000000000000000000000000000000000000;;					if d.object != nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if buildCallTreeForType(t, true, existingDefaulters, newDefaulters) != nil {
0000000000000000000000000000000000000000;;						args := defaultingArgsFromType(t)
0000000000000000000000000000000000000000;;						sw.Do("$.inType|objectdefaultfn$", args)
0000000000000000000000000000000000000000;;						newDefaulters[t] = defaults{
0000000000000000000000000000000000000000;;							object: &types.Type{
0000000000000000000000000000000000000000;;								Name: types.Name{
0000000000000000000000000000000000000000;;									Package: pkg.Path,
0000000000000000000000000000000000000000;;									Name:    buffer.String(),
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Kind: types.Func,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						buffer.Reset()
0000000000000000000000000000000000000000;;						promoted++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if promoted != 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// prune any types that were not used
0000000000000000000000000000000000000000;;				for t, d := range newDefaulters {
0000000000000000000000000000000000000000;;					if d.object == nil {
0000000000000000000000000000000000000000;;						glog.V(6).Infof("did not generate defaulter for %s because no child defaulters were registered", t.Name)
0000000000000000000000000000000000000000;;						delete(newDefaulters, t)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(newDefaulters) == 0 {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("no defaulters in package %s", pkg.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			path := pkg.Path
0000000000000000000000000000000000000000;;			// if the source path is within a /vendor/ directory (for example,
0000000000000000000000000000000000000000;;			// k8s.io/kubernetes/vendor/k8s.io/apimachinery/pkg/apis/meta/v1), allow
0000000000000000000000000000000000000000;;			// generation to output to the proper relative path (under vendor).
0000000000000000000000000000000000000000;;			// Otherwise, the generator will create the file in the wrong location
0000000000000000000000000000000000000000;;			// in the output directory.
0000000000000000000000000000000000000000;;			// TODO: build a more fundamental concept in gengo for dealing with modifications
0000000000000000000000000000000000000000;;			// to vendored packages.
0000000000000000000000000000000000000000;;			if strings.HasPrefix(pkg.SourcePath, arguments.OutputBase) {
0000000000000000000000000000000000000000;;				expandedPath := strings.TrimPrefix(pkg.SourcePath, arguments.OutputBase)
0000000000000000000000000000000000000000;;				if strings.Contains(expandedPath, "/vendor/") {
0000000000000000000000000000000000000000;;					path = expandedPath
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			packages = append(packages,
0000000000000000000000000000000000000000;;				&generator.DefaultPackage{
0000000000000000000000000000000000000000;;					PackageName: filepath.Base(pkg.Path),
0000000000000000000000000000000000000000;;					PackagePath: path,
0000000000000000000000000000000000000000;;					HeaderText:  header,
0000000000000000000000000000000000000000;;					GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;						return []generator.Generator{
0000000000000000000000000000000000000000;;							NewGenDefaulter(arguments.OutputFileBaseName, typesPkg.Path, pkg.Path, existingDefaulters, newDefaulters, peerPkgs),
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;						return t.Name.Package == typesPkg.Path
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return packages
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildCallTreeForType creates a tree of paths to fields (based on how they would be accessed in Go - pointer, elem,
0000000000000000000000000000000000000000;;	// slice, or key) and the functions that should be invoked on each field. An in-order traversal of the resulting tree
0000000000000000000000000000000000000000;;	// can be used to generate a Go function that invokes each nested function on the appropriate type. The return
0000000000000000000000000000000000000000;;	// value may be nil if there are no functions to call on type or the type is a primitive (Defaulters can only be
0000000000000000000000000000000000000000;;	// invoked on structs today). When root is true this function will not use a newDefaulter. existingDefaulters should
0000000000000000000000000000000000000000;;	// contain all defaulting functions by type defined in code - newDefaulters should contain all object defaulters
0000000000000000000000000000000000000000;;	// that could be or will be generated. If newDefaulters has an entry for a type, but the 'object' field is nil,
0000000000000000000000000000000000000000;;	// this function skips adding that defaulter - this allows us to avoid generating object defaulter functions for
0000000000000000000000000000000000000000;;	// list types that call empty defaulters.
0000000000000000000000000000000000000000;;	func buildCallTreeForType(t *types.Type, root bool, existingDefaulters, newDefaulters defaulterFuncMap) *callNode {
0000000000000000000000000000000000000000;;		parent := &callNode{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if root {
0000000000000000000000000000000000000000;;			// the root node is always a pointer
0000000000000000000000000000000000000000;;			parent.elem = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaults, _ := existingDefaulters[t]
0000000000000000000000000000000000000000;;		newDefaults, generated := newDefaulters[t]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case !root && generated && newDefaults.object != nil:
0000000000000000000000000000000000000000;;			parent.call = append(parent.call, newDefaults.object)
0000000000000000000000000000000000000000;;			// if we will be generating the defaulter, it by definition is a covering
0000000000000000000000000000000000000000;;			// defaulter, so we halt recursion
0000000000000000000000000000000000000000;;			glog.V(6).Infof("the defaulter %s will be generated as an object defaulter", t.Name)
0000000000000000000000000000000000000000;;			return parent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case defaults.object != nil:
0000000000000000000000000000000000000000;;			// object defaulters are always covering
0000000000000000000000000000000000000000;;			parent.call = append(parent.call, defaults.object)
0000000000000000000000000000000000000000;;			return parent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case defaults.base != nil:
0000000000000000000000000000000000000000;;			parent.call = append(parent.call, defaults.base)
0000000000000000000000000000000000000000;;			// if the base function indicates it "covers" (it already includes defaulters)
0000000000000000000000000000000000000000;;			// we can halt recursion
0000000000000000000000000000000000000000;;			if checkTag(defaults.base.CommentLines, "covers") {
0000000000000000000000000000000000000000;;				glog.V(6).Infof("the defaulter %s indicates it covers all sub generators", t.Name)
0000000000000000000000000000000000000000;;				return parent
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// base has been added already, now add any additional defaulters defined for this object
0000000000000000000000000000000000000000;;		parent.call = append(parent.call, defaults.additional...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Pointer:
0000000000000000000000000000000000000000;;			if child := buildCallTreeForType(t.Elem, false, existingDefaulters, newDefaulters); child != nil {
0000000000000000000000000000000000000000;;				child.elem = true
0000000000000000000000000000000000000000;;				parent.children = append(parent.children, *child)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Slice, types.Array:
0000000000000000000000000000000000000000;;			if child := buildCallTreeForType(t.Elem, false, existingDefaulters, newDefaulters); child != nil {
0000000000000000000000000000000000000000;;				child.index = true
0000000000000000000000000000000000000000;;				parent.children = append(parent.children, *child)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			if child := buildCallTreeForType(t.Elem, false, existingDefaulters, newDefaulters); child != nil {
0000000000000000000000000000000000000000;;				child.key = true
0000000000000000000000000000000000000000;;				parent.children = append(parent.children, *child)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			for _, field := range t.Members {
0000000000000000000000000000000000000000;;				name := field.Name
0000000000000000000000000000000000000000;;				if len(name) == 0 {
0000000000000000000000000000000000000000;;					if field.Type.Kind == types.Pointer {
0000000000000000000000000000000000000000;;						name = field.Type.Elem.Name.Name
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						name = field.Type.Name.Name
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if child := buildCallTreeForType(field.Type, false, existingDefaulters, newDefaulters); child != nil {
0000000000000000000000000000000000000000;;					child.field = name
0000000000000000000000000000000000000000;;					parent.children = append(parent.children, *child)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case types.Alias:
0000000000000000000000000000000000000000;;			if child := buildCallTreeForType(t.Underlying, false, existingDefaulters, newDefaulters); child != nil {
0000000000000000000000000000000000000000;;				parent.children = append(parent.children, *child)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(parent.children) == 0 && len(parent.call) == 0 {
0000000000000000000000000000000000000000;;			//glog.V(6).Infof("decided type %s needs no generation", t.Name)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		runtimePackagePath    = "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		conversionPackagePath = "k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genDefaulter produces a file with a autogenerated conversions.
0000000000000000000000000000000000000000;;	type genDefaulter struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		typesPackage       string
0000000000000000000000000000000000000000;;		outputPackage      string
0000000000000000000000000000000000000000;;		peerPackages       []string
0000000000000000000000000000000000000000;;		newDefaulters      defaulterFuncMap
0000000000000000000000000000000000000000;;		existingDefaulters defaulterFuncMap
0000000000000000000000000000000000000000;;		imports            namer.ImportTracker
0000000000000000000000000000000000000000;;		typesForInit       []*types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGenDefaulter(sanitizedName, typesPackage, outputPackage string, existingDefaulters, newDefaulters defaulterFuncMap, peerPkgs []string) generator.Generator {
0000000000000000000000000000000000000000;;		return &genDefaulter{
0000000000000000000000000000000000000000;;			DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;				OptionalName: sanitizedName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			typesPackage:       typesPackage,
0000000000000000000000000000000000000000;;			outputPackage:      outputPackage,
0000000000000000000000000000000000000000;;			peerPackages:       peerPkgs,
0000000000000000000000000000000000000000;;			newDefaulters:      newDefaulters,
0000000000000000000000000000000000000000;;			existingDefaulters: existingDefaulters,
0000000000000000000000000000000000000000;;			imports:            generator.NewImportTracker(),
0000000000000000000000000000000000000000;;			typesForInit:       make([]*types.Type, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDefaulter) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		// Have the raw namer for this file track what it imports.
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDefaulter) isOtherPackage(pkg string) bool {
0000000000000000000000000000000000000000;;		if pkg == g.outputPackage {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(pkg, `"`+g.outputPackage+`"`) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDefaulter) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		defaults, ok := g.newDefaulters[t]
0000000000000000000000000000000000000000;;		if !ok || defaults.object == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.typesForInit = append(g.typesForInit, t)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDefaulter) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		var importLines []string
0000000000000000000000000000000000000000;;		for _, singleImport := range g.imports.ImportLines() {
0000000000000000000000000000000000000000;;			if g.isOtherPackage(singleImport) {
0000000000000000000000000000000000000000;;				importLines = append(importLines, singleImport)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return importLines
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDefaulter) Init(c *generator.Context, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := c.Universe.Type(types.Name{Package: runtimePackagePath, Name: "Scheme"})
0000000000000000000000000000000000000000;;		schemePtr := &types.Type{
0000000000000000000000000000000000000000;;			Kind: types.Pointer,
0000000000000000000000000000000000000000;;			Elem: scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do("// RegisterDefaults adds defaulters functions to the given scheme.\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("// Public to allow building arbitrary schemes.\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("// All generated defaulters are covering - they call all nested defaulters.\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("func RegisterDefaults(scheme $.|raw$) error {\n", schemePtr)
0000000000000000000000000000000000000000;;		for _, t := range g.typesForInit {
0000000000000000000000000000000000000000;;			args := defaultingArgsFromType(t)
0000000000000000000000000000000000000000;;			sw.Do("scheme.AddTypeDefaultingFunc(&$.inType|raw${}, func(obj interface{}) { $.inType|objectdefaultfn$(obj.(*$.inType|raw$)) })\n", args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do("return nil\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDefaulter) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		if _, ok := g.newDefaulters[t]; !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("generating for type %v", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		callTree := buildCallTreeForType(t, true, g.existingDefaulters, g.newDefaulters)
0000000000000000000000000000000000000000;;		if callTree == nil {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("  no defaulters defined")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		callTree.VisitInOrder(func(ancestors []*callNode, current *callNode) {
0000000000000000000000000000000000000000;;			if len(current.call) == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			path := callPath(append(ancestors, current))
0000000000000000000000000000000000000000;;			glog.V(5).Infof("  %d: %s", i, path)
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		g.generateDefaulter(t, callTree, sw)
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultingArgsFromType(inType *types.Type) generator.Args {
0000000000000000000000000000000000000000;;		return generator.Args{
0000000000000000000000000000000000000000;;			"inType": inType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDefaulter) generateDefaulter(inType *types.Type, callTree *callNode, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("func $.inType|objectdefaultfn$(in *$.inType|raw$) {\n", defaultingArgsFromType(inType))
0000000000000000000000000000000000000000;;		callTree.WriteMethod("in", 0, nil, sw)
0000000000000000000000000000000000000000;;		sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// callNode represents an entry in a tree of Go type accessors - the path from the root to a leaf represents
0000000000000000000000000000000000000000;;	// how in Go code an access would be performed. For example, if a defaulting function exists on a container
0000000000000000000000000000000000000000;;	// lifecycle hook, to invoke that defaulter correctly would require this Go code:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     for i := range pod.Spec.Containers {
0000000000000000000000000000000000000000;;	//       o := &pod.Spec.Containers[i]
0000000000000000000000000000000000000000;;	//       if o.LifecycleHook != nil {
0000000000000000000000000000000000000000;;	//         SetDefaults_LifecycleHook(o.LifecycleHook)
0000000000000000000000000000000000000000;;	//       }
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// That would be represented by a call tree like:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   callNode
0000000000000000000000000000000000000000;;	//     field: "Spec"
0000000000000000000000000000000000000000;;	//     children:
0000000000000000000000000000000000000000;;	//     - field: "Containers"
0000000000000000000000000000000000000000;;	//       children:
0000000000000000000000000000000000000000;;	//       - index: true
0000000000000000000000000000000000000000;;	//         children:
0000000000000000000000000000000000000000;;	//         - field: "LifecycleHook"
0000000000000000000000000000000000000000;;	//           elem: true
0000000000000000000000000000000000000000;;	//           call:
0000000000000000000000000000000000000000;;	//           - SetDefaults_LifecycleHook
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// which we can traverse to build that Go struct (you must call the field Spec, then Containers, then range over
0000000000000000000000000000000000000000;;	// that field, then check whether the LifecycleHook field is nil, before calling SetDefaults_LifecycleHook on
0000000000000000000000000000000000000000;;	// the pointer to that field).
0000000000000000000000000000000000000000;;	type callNode struct {
0000000000000000000000000000000000000000;;		// field is the name of the Go member to access
0000000000000000000000000000000000000000;;		field string
0000000000000000000000000000000000000000;;		// key is true if this is a map and we must range over the key and values
0000000000000000000000000000000000000000;;		key bool
0000000000000000000000000000000000000000;;		// index is true if this is a slice and we must range over the slice values
0000000000000000000000000000000000000000;;		index bool
0000000000000000000000000000000000000000;;		// elem is true if the previous elements refer to a pointer (typically just field)
0000000000000000000000000000000000000000;;		elem bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// call is all of the functions that must be invoked on this particular node, in order
0000000000000000000000000000000000000000;;		call []*types.Type
0000000000000000000000000000000000000000;;		// children is the child call nodes that must also be traversed
0000000000000000000000000000000000000000;;		children []callNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CallNodeVisitorFunc is a function for visiting a call tree. ancestors is the list of all parents
0000000000000000000000000000000000000000;;	// of this node to the root of the tree - will be empty at the root.
0000000000000000000000000000000000000000;;	type CallNodeVisitorFunc func(ancestors []*callNode, node *callNode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *callNode) VisitInOrder(fn CallNodeVisitorFunc) {
0000000000000000000000000000000000000000;;		n.visitInOrder(nil, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *callNode) visitInOrder(ancestors []*callNode, fn CallNodeVisitorFunc) {
0000000000000000000000000000000000000000;;		fn(ancestors, n)
0000000000000000000000000000000000000000;;		ancestors = append(ancestors, n)
0000000000000000000000000000000000000000;;		for i := range n.children {
0000000000000000000000000000000000000000;;			n.children[i].visitInOrder(ancestors, fn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		indexVariables = "ijklmnop"
0000000000000000000000000000000000000000;;		localVariables = "abcdefgh"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// varsForDepth creates temporary variables guaranteed to be unique within lexical Go scopes
0000000000000000000000000000000000000000;;	// of this depth in a function. It uses canonical Go loop variables for the first 7 levels
0000000000000000000000000000000000000000;;	// and then resorts to uglier prefixes.
0000000000000000000000000000000000000000;;	func varsForDepth(depth int) (index, local string) {
0000000000000000000000000000000000000000;;		if depth > len(indexVariables) {
0000000000000000000000000000000000000000;;			index = fmt.Sprintf("i%d", depth)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			index = indexVariables[depth : depth+1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if depth > len(localVariables) {
0000000000000000000000000000000000000000;;			local = fmt.Sprintf("local%d", depth)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			local = localVariables[depth : depth+1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeCalls generates a list of function calls based on the calls field for the provided variable
0000000000000000000000000000000000000000;;	// name and pointer.
0000000000000000000000000000000000000000;;	func (n *callNode) writeCalls(varName string, isVarPointer bool, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		accessor := varName
0000000000000000000000000000000000000000;;		if !isVarPointer {
0000000000000000000000000000000000000000;;			accessor = "&" + accessor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, fn := range n.call {
0000000000000000000000000000000000000000;;			sw.Do("$.fn|raw$($.var$)\n", generator.Args{
0000000000000000000000000000000000000000;;				"fn":  fn,
0000000000000000000000000000000000000000;;				"var": accessor,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteMethod performs an in-order traversal of the calltree, generating loops and if blocks as necessary
0000000000000000000000000000000000000000;;	// to correctly turn the call tree into a method body that invokes all calls on all child nodes of the call tree.
0000000000000000000000000000000000000000;;	// Depth is used to generate local variables at the proper depth.
0000000000000000000000000000000000000000;;	func (n *callNode) WriteMethod(varName string, depth int, ancestors []*callNode, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		// if len(n.call) > 0 {
0000000000000000000000000000000000000000;;		// 	sw.Do(fmt.Sprintf("// %s\n", callPath(append(ancestors, n)).String()), nil)
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(n.field) > 0 {
0000000000000000000000000000000000000000;;			varName = varName + "." + n.field
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index, local := varsForDepth(depth)
0000000000000000000000000000000000000000;;		vars := generator.Args{
0000000000000000000000000000000000000000;;			"index": index,
0000000000000000000000000000000000000000;;			"local": local,
0000000000000000000000000000000000000000;;			"var":   varName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isPointer := n.elem
0000000000000000000000000000000000000000;;		if isPointer && len(ancestors) > 0 {
0000000000000000000000000000000000000000;;			sw.Do("if $.var$ != nil {\n", vars)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case n.index:
0000000000000000000000000000000000000000;;			sw.Do("for $.index$ := range $.var$ {\n", vars)
0000000000000000000000000000000000000000;;			sw.Do("$.local$ := &$.var$[$.index$]\n", vars)
0000000000000000000000000000000000000000;;			n.writeCalls(local, true, sw)
0000000000000000000000000000000000000000;;			for i := range n.children {
0000000000000000000000000000000000000000;;				n.children[i].WriteMethod(local, depth+1, append(ancestors, n), sw)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		case n.key:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			n.writeCalls(varName, isPointer, sw)
0000000000000000000000000000000000000000;;			for i := range n.children {
0000000000000000000000000000000000000000;;				n.children[i].WriteMethod(varName, depth, append(ancestors, n), sw)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isPointer && len(ancestors) > 0 {
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type callPath []*callNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String prints a representation of a callPath that roughly approximates what a Go accessor
0000000000000000000000000000000000000000;;	// would look like. Used for debugging only.
0000000000000000000000000000000000000000;;	func (path callPath) String() string {
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			return "<none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var parts []string
0000000000000000000000000000000000000000;;		for _, p := range path {
0000000000000000000000000000000000000000;;			last := len(parts) - 1
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case p.elem:
0000000000000000000000000000000000000000;;				if len(parts) > 0 {
0000000000000000000000000000000000000000;;					parts[last] = "*" + parts[last]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					parts = append(parts, "*")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case p.index:
0000000000000000000000000000000000000000;;				if len(parts) > 0 {
0000000000000000000000000000000000000000;;					parts[last] = parts[last] + "[i]"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					parts = append(parts, "[i]")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case p.key:
0000000000000000000000000000000000000000;;				if len(parts) > 0 {
0000000000000000000000000000000000000000;;					parts[last] = parts[last] + "[key]"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					parts = append(parts, "[key]")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if len(p.field) > 0 {
0000000000000000000000000000000000000000;;					parts = append(parts, p.field)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					parts = append(parts, "<root>")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var calls []string
0000000000000000000000000000000000000000;;		for _, fn := range path[len(path)-1].call {
0000000000000000000000000000000000000000;;			calls = append(calls, fn.Name.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(calls) == 0 {
0000000000000000000000000000000000000000;;			calls = append(calls, "<none>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(parts, ".") + " calls " + strings.Join(calls, ", ")
0000000000000000000000000000000000000000;;	}
