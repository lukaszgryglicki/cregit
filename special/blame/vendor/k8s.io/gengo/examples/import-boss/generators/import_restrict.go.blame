0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package generators has the generators for the import-boss utility.
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		importBossFileType = "import-boss"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "raw"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Packages makes the import-boss package definition.
0000000000000000000000000000000000000000;;	func Packages(c *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		pkgs := generator.Packages{}
0000000000000000000000000000000000000000;;		c.FileTypes = map[string]generator.FileType{
0000000000000000000000000000000000000000;;			importBossFileType: importRuleFile{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range c.Universe {
0000000000000000000000000000000000000000;;			if !arguments.InputIncludes(p) {
0000000000000000000000000000000000000000;;				// Don't run on e.g. third party dependencies.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			savedPackage := p
0000000000000000000000000000000000000000;;			pkgs = append(pkgs, &generator.DefaultPackage{
0000000000000000000000000000000000000000;;				PackageName: p.Name,
0000000000000000000000000000000000000000;;				PackagePath: p.Path,
0000000000000000000000000000000000000000;;				// GeneratorFunc returns a list of generators. Each generator makes a
0000000000000000000000000000000000000000;;				// single file.
0000000000000000000000000000000000000000;;				GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;					return []generator.Generator{&importRules{
0000000000000000000000000000000000000000;;						myPackage: savedPackage,
0000000000000000000000000000000000000000;;					}}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pkgs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A single import restriction rule.
0000000000000000000000000000000000000000;;	type Rule struct {
0000000000000000000000000000000000000000;;		// All import paths that match this regexp...
0000000000000000000000000000000000000000;;		SelectorRegexp string
0000000000000000000000000000000000000000;;		// ... must have one of these prefixes ...
0000000000000000000000000000000000000000;;		AllowedPrefixes []string
0000000000000000000000000000000000000000;;		// ... and must not have one of these prefixes.
0000000000000000000000000000000000000000;;		ForbiddenPrefixes []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fileFormat struct {
0000000000000000000000000000000000000000;;		CurrentImports []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Rules []Rule
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readFile(path string) (*fileFormat, error) {
0000000000000000000000000000000000000000;;		currentBytes, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't read %v: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var current fileFormat
0000000000000000000000000000000000000000;;		err = json.Unmarshal(currentBytes, &current)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't unmarshal %v: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &current, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeFile(path string, ff *fileFormat) error {
0000000000000000000000000000000000000000;;		raw, err := json.MarshalIndent(ff, "", "\t")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't format data for file %v.\n%#v", path, ff)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := os.Create(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't open %v for writing: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		_, err = f.Write(raw)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This does the actual checking, since it knows the literal destination file.
0000000000000000000000000000000000000000;;	type importRuleFile struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (importRuleFile) AssembleFile(f *generator.File, path string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: make a flag to enable this, or expose this information in some other way.
0000000000000000000000000000000000000000;;	func (importRuleFile) listEntireImportTree(f *generator.File, path string) error {
0000000000000000000000000000000000000000;;		// If the file exists, populate its current imports. This is mostly to help
0000000000000000000000000000000000000000;;		// humans figure out what they need to fix.
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err != nil {
0000000000000000000000000000000000000000;;			// Ignore packages which haven't opted in by adding an .import-restrictions file.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		current, err := readFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		current.CurrentImports = []string{}
0000000000000000000000000000000000000000;;		for v := range f.Imports {
0000000000000000000000000000000000000000;;			current.CurrentImports = append(current.CurrentImports, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(current.CurrentImports)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return writeFile(path, current)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeLastDir removes the last directory, but leaves the file name
0000000000000000000000000000000000000000;;	// unchanged. It returns the new path and the removed directory. So:
0000000000000000000000000000000000000000;;	// "a/b/c/file" -> ("a/b/file", "c")
0000000000000000000000000000000000000000;;	func removeLastDir(path string) (newPath, removedDir string) {
0000000000000000000000000000000000000000;;		dir, file := filepath.Split(path)
0000000000000000000000000000000000000000;;		dir = strings.TrimSuffix(dir, string(filepath.Separator))
0000000000000000000000000000000000000000;;		return filepath.Join(filepath.Dir(dir), file), filepath.Base(dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keep going up a directory until we find an .import-restrictions file.
0000000000000000000000000000000000000000;;	func recursiveRead(path string) (*fileFormat, string, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(path); err == nil {
0000000000000000000000000000000000000000;;				ff, err := readFile(path)
0000000000000000000000000000000000000000;;				return ff, path, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nextPath, removedDir := removeLastDir(path)
0000000000000000000000000000000000000000;;			if nextPath == path || removedDir == "src" {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			path = nextPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (importRuleFile) VerifyFile(f *generator.File, path string) error {
0000000000000000000000000000000000000000;;		rules, actualPath, err := recursiveRead(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error finding rules file: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rules == nil {
0000000000000000000000000000000000000000;;			// No restrictions on this directory.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range rules.Rules {
0000000000000000000000000000000000000000;;			re, err := regexp.Compile(r.SelectorRegexp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("regexp `%s` in file %q doesn't compile: %v", r.SelectorRegexp, actualPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for v := range f.Imports {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Checking %v matches %v: %v\n", r.SelectorRegexp, v, re.MatchString(v))
0000000000000000000000000000000000000000;;				if !re.MatchString(v) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, forbidden := range r.ForbiddenPrefixes {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Checking %v against %v\n", v, forbidden)
0000000000000000000000000000000000000000;;					if strings.HasPrefix(v, forbidden) {
0000000000000000000000000000000000000000;;						return fmt.Errorf("import %v has forbidden prefix %v", v, forbidden)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for _, allowed := range r.AllowedPrefixes {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Checking %v against %v\n", v, allowed)
0000000000000000000000000000000000000000;;					if strings.HasPrefix(v, allowed) {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					return fmt.Errorf("import %v did not match any allowed prefix", v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rules.Rules) > 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("%v passes rules found in %v\n", path, actualPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// importRules produces a file with a set for a single type.
0000000000000000000000000000000000000000;;	type importRules struct {
0000000000000000000000000000000000000000;;		myPackage *types.Package
0000000000000000000000000000000000000000;;		imports   namer.ImportTracker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = generator.Generator(&importRules{})
0000000000000000000000000000000000000000;;		_ = generator.FileType(importRuleFile{})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *importRules) Name() string                                                  { return "import rules" }
0000000000000000000000000000000000000000;;	func (r *importRules) Filter(*generator.Context, *types.Type) bool                   { return false }
0000000000000000000000000000000000000000;;	func (r *importRules) Namers(*generator.Context) namer.NameSystems                   { return nil }
0000000000000000000000000000000000000000;;	func (r *importRules) PackageVars(*generator.Context) []string                       { return []string{} }
0000000000000000000000000000000000000000;;	func (r *importRules) PackageConsts(*generator.Context) []string                     { return []string{} }
0000000000000000000000000000000000000000;;	func (r *importRules) GenerateType(*generator.Context, *types.Type, io.Writer) error { return nil }
0000000000000000000000000000000000000000;;	func (r *importRules) Filename() string                                              { return ".import-restrictions" }
0000000000000000000000000000000000000000;;	func (r *importRules) FileType() string                                              { return importBossFileType }
0000000000000000000000000000000000000000;;	func (r *importRules) Init(c *generator.Context, w io.Writer) error                  { return nil }
0000000000000000000000000000000000000000;;	func (r *importRules) Finalize(*generator.Context, io.Writer) error                  { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dfsImports(dest *[]string, seen map[string]bool, p *types.Package) {
0000000000000000000000000000000000000000;;		for _, p2 := range p.Imports {
0000000000000000000000000000000000000000;;			if seen[p2.Path] {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			seen[p2.Path] = true
0000000000000000000000000000000000000000;;			dfsImports(dest, seen, p2)
0000000000000000000000000000000000000000;;			*dest = append(*dest, p2.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *importRules) Imports(*generator.Context) []string {
0000000000000000000000000000000000000000;;		all := []string{}
0000000000000000000000000000000000000000;;		dfsImports(&all, map[string]bool{}, r.myPackage)
0000000000000000000000000000000000000000;;		return all
0000000000000000000000000000000000000000;;	}
