0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package generators has the generators for the set-gen utility.
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"public":  namer.NewPublicNamer(0),
0000000000000000000000000000000000000000;;			"private": namer.NewPrivateNamer(0),
0000000000000000000000000000000000000000;;			"raw":     namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "public"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Packages makes the sets package definition.
0000000000000000000000000000000000000000;;	func Packages(_ *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return generator.Packages{&generator.DefaultPackage{
0000000000000000000000000000000000000000;;			PackageName: "sets",
0000000000000000000000000000000000000000;;			PackagePath: arguments.OutputPackagePath,
0000000000000000000000000000000000000000;;			HeaderText: append(boilerplate, []byte(
0000000000000000000000000000000000000000;;				`
0000000000000000000000000000000000000000;;	// This file was autogenerated by set-gen. Do not edit it manually!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)...),
0000000000000000000000000000000000000000;;			PackageDocumentation: []byte(
0000000000000000000000000000000000000000;;				`// Package sets has auto-generated set types.
0000000000000000000000000000000000000000;;	`),
0000000000000000000000000000000000000000;;			// GeneratorFunc returns a list of generators. Each generator makes a
0000000000000000000000000000000000000000;;			// single file.
0000000000000000000000000000000000000000;;			GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;				generators = []generator.Generator{
0000000000000000000000000000000000000000;;					// Always generate a "doc.go" file.
0000000000000000000000000000000000000000;;					generator.DefaultGen{OptionalName: "doc"},
0000000000000000000000000000000000000000;;					// Make a separate file for the Empty type, since it's shared by every type.
0000000000000000000000000000000000000000;;					generator.DefaultGen{
0000000000000000000000000000000000000000;;						OptionalName: "empty",
0000000000000000000000000000000000000000;;						OptionalBody: []byte(emptyTypeDecl),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Since we want a file per type that we generate a set for, we
0000000000000000000000000000000000000000;;				// have to provide a function for this.
0000000000000000000000000000000000000000;;				for _, t := range c.Order {
0000000000000000000000000000000000000000;;					generators = append(generators, &genSet{
0000000000000000000000000000000000000000;;						DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;							// Use the privatized version of the
0000000000000000000000000000000000000000;;							// type name as the file name.
0000000000000000000000000000000000000000;;							//
0000000000000000000000000000000000000000;;							// TODO: make a namer that converts
0000000000000000000000000000000000000000;;							// camelCase to '-' separation for file
0000000000000000000000000000000000000000;;							// names?
0000000000000000000000000000000000000000;;							OptionalName: c.Namers["private"].Name(t),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						outputPackage: arguments.OutputPackagePath,
0000000000000000000000000000000000000000;;						typeToMatch:   t,
0000000000000000000000000000000000000000;;						imports:       generator.NewImportTracker(),
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return generators
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;				// It would be reasonable to filter by the type's package here.
0000000000000000000000000000000000000000;;				// It might be necessary if your input directory has a big
0000000000000000000000000000000000000000;;				// import graph.
0000000000000000000000000000000000000000;;				switch t.Kind {
0000000000000000000000000000000000000000;;				case types.Map, types.Slice, types.Pointer:
0000000000000000000000000000000000000000;;					// These types can't be keys in a map.
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				case types.Builtin:
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				case types.Struct:
0000000000000000000000000000000000000000;;					// Only some structs can be keys in a map. This is triggered by the line
0000000000000000000000000000000000000000;;					// // +genset
0000000000000000000000000000000000000000;;					// or
0000000000000000000000000000000000000000;;					// // +genset=true
0000000000000000000000000000000000000000;;					return extractBoolTagOrDie("genset", t.CommentLines) == true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genSet produces a file with a set for a single type.
0000000000000000000000000000000000000000;;	type genSet struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		outputPackage string
0000000000000000000000000000000000000000;;		typeToMatch   *types.Type
0000000000000000000000000000000000000000;;		imports       namer.ImportTracker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter ignores all but one type because we're making a single file per type.
0000000000000000000000000000000000000000;;	func (g *genSet) Filter(c *generator.Context, t *types.Type) bool { return t == g.typeToMatch }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genSet) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.outputPackage, g.imports),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genSet) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		return append(g.imports.ImportLines(), "reflect", "sort")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// args constructs arguments for templates. Usage:
0000000000000000000000000000000000000000;;	// g.args(t, "key1", value1, "key2", value2, ...)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 't' is loaded with the key 'type'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We could use t directly as the argument, but doing it this way makes it easy
0000000000000000000000000000000000000000;;	// to mix in additional parameters. This feature is not used in this set
0000000000000000000000000000000000000000;;	// generator, but is present as an example.
0000000000000000000000000000000000000000;;	func (g *genSet) args(t *types.Type, kv ...interface{}) interface{} {
0000000000000000000000000000000000000000;;		m := map[interface{}]interface{}{"type": t}
0000000000000000000000000000000000000000;;		for i := 0; i < len(kv)/2; i++ {
0000000000000000000000000000000000000000;;			m[kv[i*2]] = kv[i*2+1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateType makes the body of a file implementing a set for type t.
0000000000000000000000000000000000000000;;	func (g *genSet) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		sw.Do(setCode, g.args(t))
0000000000000000000000000000000000000000;;		sw.Do("func less$.type|public$(lhs, rhs $.type|raw$) bool {\n", g.args(t))
0000000000000000000000000000000000000000;;		g.lessBody(sw, t)
0000000000000000000000000000000000000000;;		sw.Do("}\n", g.args(t))
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genSet) lessBody(sw *generator.SnippetWriter, t *types.Type) {
0000000000000000000000000000000000000000;;		// TODO: make this recursive, handle pointers and multiple nested structs...
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			for _, m := range types.FlattenMembers(t.Members) {
0000000000000000000000000000000000000000;;				sw.Do("if lhs.$.Name$ < rhs.$.Name$ { return true }\n", m)
0000000000000000000000000000000000000000;;				sw.Do("if lhs.$.Name$ > rhs.$.Name$ { return false }\n", m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do("return false\n", nil)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			sw.Do("return lhs < rhs\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// written to the "empty.go" file.
0000000000000000000000000000000000000000;;	var emptyTypeDecl = `
0000000000000000000000000000000000000000;;	// Empty is public since it is used by some internal API objects for conversions between external
0000000000000000000000000000000000000000;;	// string arrays and internal sets, and conversion logic requires public types today.
0000000000000000000000000000000000000000;;	type Empty struct{}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Written for every type. If you've never used text/template before:
0000000000000000000000000000000000000000;;	// $.type$ refers to the source type; |public means to
0000000000000000000000000000000000000000;;	// call the function giving the public name, |raw the raw type name.
0000000000000000000000000000000000000000;;	var setCode = `// sets.$.type|public$ is a set of $.type|raw$s, implemented via map[$.type|raw$]struct{} for minimal memory consumption.
0000000000000000000000000000000000000000;;	type $.type|public$ map[$.type|raw$]Empty
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a $.type|public$ from a list of values.
0000000000000000000000000000000000000000;;	func New$.type|public$(items ...$.type|raw$) $.type|public$ {
0000000000000000000000000000000000000000;;		ss := $.type|public${}
0000000000000000000000000000000000000000;;		ss.Insert(items...)
0000000000000000000000000000000000000000;;		return ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// $.type|public$KeySet creates a $.type|public$ from a keys of a map[$.type|raw$](? extends interface{}).
0000000000000000000000000000000000000000;;	// If the value passed in is not actually a map, this will panic.
0000000000000000000000000000000000000000;;	func $.type|public$KeySet(theMap interface{}) $.type|public$ {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(theMap)
0000000000000000000000000000000000000000;;		ret := $.type|public${}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, keyValue := range v.MapKeys() {
0000000000000000000000000000000000000000;;			ret.Insert(keyValue.Interface().($.type|raw$))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert adds items to the set.
0000000000000000000000000000000000000000;;	func (s $.type|public$) Insert(items ...$.type|raw$) {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			s[item] = Empty{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes all items from the set.
0000000000000000000000000000000000000000;;	func (s $.type|public$) Delete(items ...$.type|raw$) {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			delete(s, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if and only if item is contained in the set.
0000000000000000000000000000000000000000;;	func (s $.type|public$) Has(item $.type|raw$) bool {
0000000000000000000000000000000000000000;;		_, contained := s[item]
0000000000000000000000000000000000000000;;		return contained
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAll returns true if and only if all items are contained in the set.
0000000000000000000000000000000000000000;;	func (s $.type|public$) HasAll(items ...$.type|raw$) bool {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if !s.Has(item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAny returns true if any items are contained in the set.
0000000000000000000000000000000000000000;;	func (s $.type|public$) HasAny(items ...$.type|raw$) bool {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if s.Has(item) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Difference returns a set of objects that are not in s2
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2, a3}
0000000000000000000000000000000000000000;;	// s2 = {a1, a2, a4, a5}
0000000000000000000000000000000000000000;;	// s1.Difference(s2) = {a3}
0000000000000000000000000000000000000000;;	// s2.Difference(s1) = {a4, a5}
0000000000000000000000000000000000000000;;	func (s $.type|public$) Difference(s2 $.type|public$) $.type|public$ {
0000000000000000000000000000000000000000;;		result := New$.type|public$()
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			if !s2.Has(key) {
0000000000000000000000000000000000000000;;				result.Insert(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Union returns a new set which includes items in either s1 or s2.
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2}
0000000000000000000000000000000000000000;;	// s2 = {a3, a4}
0000000000000000000000000000000000000000;;	// s1.Union(s2) = {a1, a2, a3, a4}
0000000000000000000000000000000000000000;;	// s2.Union(s1) = {a1, a2, a3, a4}
0000000000000000000000000000000000000000;;	func (s1 $.type|public$) Union(s2 $.type|public$) $.type|public$ {
0000000000000000000000000000000000000000;;		result := New$.type|public$()
0000000000000000000000000000000000000000;;		for key := range s1 {
0000000000000000000000000000000000000000;;			result.Insert(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key := range s2 {
0000000000000000000000000000000000000000;;			result.Insert(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Intersection returns a new set which includes the item in BOTH s1 and s2
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2}
0000000000000000000000000000000000000000;;	// s2 = {a2, a3}
0000000000000000000000000000000000000000;;	// s1.Intersection(s2) = {a2}
0000000000000000000000000000000000000000;;	func (s1 $.type|public$) Intersection(s2 $.type|public$) $.type|public$ {
0000000000000000000000000000000000000000;;		var walk, other $.type|public$
0000000000000000000000000000000000000000;;		result := New$.type|public$()
0000000000000000000000000000000000000000;;		if s1.Len() < s2.Len() {
0000000000000000000000000000000000000000;;			walk = s1
0000000000000000000000000000000000000000;;			other = s2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			walk = s2
0000000000000000000000000000000000000000;;			other = s1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key := range walk {
0000000000000000000000000000000000000000;;			if other.Has(key) {
0000000000000000000000000000000000000000;;				result.Insert(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSuperset returns true if and only if s1 is a superset of s2.
0000000000000000000000000000000000000000;;	func (s1 $.type|public$) IsSuperset(s2 $.type|public$) bool {
0000000000000000000000000000000000000000;;		for item := range s2 {
0000000000000000000000000000000000000000;;			if !s1.Has(item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if and only if s1 is equal (as a set) to s2.
0000000000000000000000000000000000000000;;	// Two sets are equal if their membership is identical.
0000000000000000000000000000000000000000;;	// (In practice, this means same elements, order doesn't matter)
0000000000000000000000000000000000000000;;	func (s1 $.type|public$) Equal(s2 $.type|public$) bool {
0000000000000000000000000000000000000000;;		return len(s1) == len(s2) && s1.IsSuperset(s2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortableSliceOf$.type|public$ []$.type|raw$
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortableSliceOf$.type|public$) Len() int { return len(s) }
0000000000000000000000000000000000000000;;	func (s sortableSliceOf$.type|public$) Less(i, j int) bool { return less$.type|public$(s[i], s[j]) }
0000000000000000000000000000000000000000;;	func (s sortableSliceOf$.type|public$) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns the contents as a sorted $.type|raw$ slice.
0000000000000000000000000000000000000000;;	func (s $.type|public$) List() []$.type|raw$ {
0000000000000000000000000000000000000000;;		res := make(sortableSliceOf$.type|public$, 0, len(s))
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			res = append(res, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(res)
0000000000000000000000000000000000000000;;		return []$.type|raw$(res)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsortedList returns the slice with contents in random order.
0000000000000000000000000000000000000000;;	func (s $.type|public$) UnsortedList() []$.type|raw$ {
0000000000000000000000000000000000000000;;		res :=make([]$.type|raw$, 0, len(s))
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			res = append(res, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a single element from the set.
0000000000000000000000000000000000000000;;	func (s $.type|public$) PopAny() ($.type|raw$, bool) {
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			s.Delete(key)
0000000000000000000000000000000000000000;;			return key, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var zeroValue $.type|raw$
0000000000000000000000000000000000000000;;		return zeroValue, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the size of the set.
0000000000000000000000000000000000000000;;	func (s $.type|public$) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`
