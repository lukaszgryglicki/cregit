0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file was autogenerated by set-gen. Do not edit it manually!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package sets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sets.Int is a set of ints, implemented via map[int]struct{} for minimal memory consumption.
0000000000000000000000000000000000000000;;	type Int map[int]Empty
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a Int from a list of values.
0000000000000000000000000000000000000000;;	func NewInt(items ...int) Int {
0000000000000000000000000000000000000000;;		ss := Int{}
0000000000000000000000000000000000000000;;		ss.Insert(items...)
0000000000000000000000000000000000000000;;		return ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntKeySet creates a Int from a keys of a map[int](? extends interface{}).
0000000000000000000000000000000000000000;;	// If the value passed in is not actually a map, this will panic.
0000000000000000000000000000000000000000;;	func IntKeySet(theMap interface{}) Int {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(theMap)
0000000000000000000000000000000000000000;;		ret := Int{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, keyValue := range v.MapKeys() {
0000000000000000000000000000000000000000;;			ret.Insert(keyValue.Interface().(int))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert adds items to the set.
0000000000000000000000000000000000000000;;	func (s Int) Insert(items ...int) {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			s[item] = Empty{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes all items from the set.
0000000000000000000000000000000000000000;;	func (s Int) Delete(items ...int) {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			delete(s, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if and only if item is contained in the set.
0000000000000000000000000000000000000000;;	func (s Int) Has(item int) bool {
0000000000000000000000000000000000000000;;		_, contained := s[item]
0000000000000000000000000000000000000000;;		return contained
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAll returns true if and only if all items are contained in the set.
0000000000000000000000000000000000000000;;	func (s Int) HasAll(items ...int) bool {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if !s.Has(item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAny returns true if any items are contained in the set.
0000000000000000000000000000000000000000;;	func (s Int) HasAny(items ...int) bool {
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			if s.Has(item) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Difference returns a set of objects that are not in s2
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2, a3}
0000000000000000000000000000000000000000;;	// s2 = {a1, a2, a4, a5}
0000000000000000000000000000000000000000;;	// s1.Difference(s2) = {a3}
0000000000000000000000000000000000000000;;	// s2.Difference(s1) = {a4, a5}
0000000000000000000000000000000000000000;;	func (s Int) Difference(s2 Int) Int {
0000000000000000000000000000000000000000;;		result := NewInt()
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			if !s2.Has(key) {
0000000000000000000000000000000000000000;;				result.Insert(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Union returns a new set which includes items in either s1 or s2.
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2}
0000000000000000000000000000000000000000;;	// s2 = {a3, a4}
0000000000000000000000000000000000000000;;	// s1.Union(s2) = {a1, a2, a3, a4}
0000000000000000000000000000000000000000;;	// s2.Union(s1) = {a1, a2, a3, a4}
0000000000000000000000000000000000000000;;	func (s1 Int) Union(s2 Int) Int {
0000000000000000000000000000000000000000;;		result := NewInt()
0000000000000000000000000000000000000000;;		for key := range s1 {
0000000000000000000000000000000000000000;;			result.Insert(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key := range s2 {
0000000000000000000000000000000000000000;;			result.Insert(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Intersection returns a new set which includes the item in BOTH s1 and s2
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// s1 = {a1, a2}
0000000000000000000000000000000000000000;;	// s2 = {a2, a3}
0000000000000000000000000000000000000000;;	// s1.Intersection(s2) = {a2}
0000000000000000000000000000000000000000;;	func (s1 Int) Intersection(s2 Int) Int {
0000000000000000000000000000000000000000;;		var walk, other Int
0000000000000000000000000000000000000000;;		result := NewInt()
0000000000000000000000000000000000000000;;		if s1.Len() < s2.Len() {
0000000000000000000000000000000000000000;;			walk = s1
0000000000000000000000000000000000000000;;			other = s2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			walk = s2
0000000000000000000000000000000000000000;;			other = s1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key := range walk {
0000000000000000000000000000000000000000;;			if other.Has(key) {
0000000000000000000000000000000000000000;;				result.Insert(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSuperset returns true if and only if s1 is a superset of s2.
0000000000000000000000000000000000000000;;	func (s1 Int) IsSuperset(s2 Int) bool {
0000000000000000000000000000000000000000;;		for item := range s2 {
0000000000000000000000000000000000000000;;			if !s1.Has(item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if and only if s1 is equal (as a set) to s2.
0000000000000000000000000000000000000000;;	// Two sets are equal if their membership is identical.
0000000000000000000000000000000000000000;;	// (In practice, this means same elements, order doesn't matter)
0000000000000000000000000000000000000000;;	func (s1 Int) Equal(s2 Int) bool {
0000000000000000000000000000000000000000;;		return len(s1) == len(s2) && s1.IsSuperset(s2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortableSliceOfInt []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortableSliceOfInt) Len() int           { return len(s) }
0000000000000000000000000000000000000000;;	func (s sortableSliceOfInt) Less(i, j int) bool { return lessInt(s[i], s[j]) }
0000000000000000000000000000000000000000;;	func (s sortableSliceOfInt) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns the contents as a sorted int slice.
0000000000000000000000000000000000000000;;	func (s Int) List() []int {
0000000000000000000000000000000000000000;;		res := make(sortableSliceOfInt, 0, len(s))
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			res = append(res, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(res)
0000000000000000000000000000000000000000;;		return []int(res)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsortedList returns the slice with contents in random order.
0000000000000000000000000000000000000000;;	func (s Int) UnsortedList() []int {
0000000000000000000000000000000000000000;;		res := make([]int, 0, len(s))
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			res = append(res, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a single element from the set.
0000000000000000000000000000000000000000;;	func (s Int) PopAny() (int, bool) {
0000000000000000000000000000000000000000;;		for key := range s {
0000000000000000000000000000000000000000;;			s.Delete(key)
0000000000000000000000000000000000000000;;			return key, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var zeroValue int
0000000000000000000000000000000000000000;;		return zeroValue, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the size of the set.
0000000000000000000000000000000000000000;;	func (s Int) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lessInt(lhs, rhs int) bool {
0000000000000000000000000000000000000000;;		return lhs < rhs
0000000000000000000000000000000000000000;;	}
