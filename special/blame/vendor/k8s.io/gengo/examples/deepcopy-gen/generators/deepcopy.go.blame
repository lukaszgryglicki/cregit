0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package generators
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/args"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/examples/set-gen/sets"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CustomArgs is used tby the go2idl framework to pass args specific to this
0000000000000000000000000000000000000000;;	// generator.
0000000000000000000000000000000000000000;;	type CustomArgs struct {
0000000000000000000000000000000000000000;;		BoundingDirs []string // Only deal with types rooted under these dirs.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the comment tag that carries parameters for deep-copy generation.
0000000000000000000000000000000000000000;;	const tagName = "k8s:deepcopy-gen"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Known values for the comment tag.
0000000000000000000000000000000000000000;;	const tagValuePackage = "package"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagValue holds parameters from a tagName tag.
0000000000000000000000000000000000000000;;	type tagValue struct {
0000000000000000000000000000000000000000;;		value    string
0000000000000000000000000000000000000000;;		register bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractTag(comments []string) *tagValue {
0000000000000000000000000000000000000000;;		tagVals := types.ExtractCommentTags("+", comments)[tagName]
0000000000000000000000000000000000000000;;		if tagVals == nil {
0000000000000000000000000000000000000000;;			// No match for the tag.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If there are multiple values, abort.
0000000000000000000000000000000000000000;;		if len(tagVals) > 1 {
0000000000000000000000000000000000000000;;			glog.Fatalf("Found %d %s tags: %q", len(tagVals), tagName, tagVals)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we got here we are returning something.
0000000000000000000000000000000000000000;;		tag := &tagValue{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the primary value.
0000000000000000000000000000000000000000;;		parts := strings.Split(tagVals[0], ",")
0000000000000000000000000000000000000000;;		if len(parts) >= 1 {
0000000000000000000000000000000000000000;;			tag.value = parts[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse extra arguments.
0000000000000000000000000000000000000000;;		parts = parts[1:]
0000000000000000000000000000000000000000;;		for i := range parts {
0000000000000000000000000000000000000000;;			kv := strings.SplitN(parts[i], "=", 2)
0000000000000000000000000000000000000000;;			k := kv[0]
0000000000000000000000000000000000000000;;			v := ""
0000000000000000000000000000000000000000;;			if len(kv) == 2 {
0000000000000000000000000000000000000000;;				v = kv[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case "register":
0000000000000000000000000000000000000000;;				if v != "false" {
0000000000000000000000000000000000000000;;					tag.register = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				glog.Fatalf("Unsupported %s param: %q", tagName, parts[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This is created only to reduce number of changes in a single PR.
0000000000000000000000000000000000000000;;	// Remove it and use PublicNamer instead.
0000000000000000000000000000000000000000;;	func deepCopyNamer() *namer.NameStrategy {
0000000000000000000000000000000000000000;;		return &namer.NameStrategy{
0000000000000000000000000000000000000000;;			Join: func(pre string, in []string, post string) string {
0000000000000000000000000000000000000000;;				return strings.Join(in, "_")
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PrependPackageNames: 1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameSystems returns the name system used by the generators in this package.
0000000000000000000000000000000000000000;;	func NameSystems() namer.NameSystems {
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"public": deepCopyNamer(),
0000000000000000000000000000000000000000;;			"raw":    namer.NewRawNamer("", nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameSystem returns the default name system for ordering the types to be
0000000000000000000000000000000000000000;;	// processed by the generators in this package.
0000000000000000000000000000000000000000;;	func DefaultNameSystem() string {
0000000000000000000000000000000000000000;;		return "public"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Packages(context *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
0000000000000000000000000000000000000000;;		boilerplate, err := arguments.LoadGoBoilerplate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed loading boilerplate: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inputs := sets.NewString(context.Inputs...)
0000000000000000000000000000000000000000;;		packages := generator.Packages{}
0000000000000000000000000000000000000000;;		header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
0000000000000000000000000000000000000000;;		header = append(header, []byte(`
0000000000000000000000000000000000000000;;		    // This file was autogenerated by deepcopy-gen. Do not edit it manually!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			`)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boundingDirs := []string{}
0000000000000000000000000000000000000000;;		if customArgs, ok := arguments.CustomArgs.(*CustomArgs); ok {
0000000000000000000000000000000000000000;;			if customArgs.BoundingDirs == nil {
0000000000000000000000000000000000000000;;				customArgs.BoundingDirs = context.Inputs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range customArgs.BoundingDirs {
0000000000000000000000000000000000000000;;				// Strip any trailing slashes - they are not exactly "correct" but
0000000000000000000000000000000000000000;;				// this is friendlier.
0000000000000000000000000000000000000000;;				boundingDirs = append(boundingDirs, strings.TrimRight(customArgs.BoundingDirs[i], "/"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range inputs {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Considering pkg %q", i)
0000000000000000000000000000000000000000;;			pkg := context.Universe[i]
0000000000000000000000000000000000000000;;			if pkg == nil {
0000000000000000000000000000000000000000;;				// If the input had no Go files, for example.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ptag := extractTag(pkg.Comments)
0000000000000000000000000000000000000000;;			ptagValue := ""
0000000000000000000000000000000000000000;;			ptagRegister := false
0000000000000000000000000000000000000000;;			if ptag != nil {
0000000000000000000000000000000000000000;;				ptagValue = ptag.value
0000000000000000000000000000000000000000;;				if ptagValue != tagValuePackage {
0000000000000000000000000000000000000000;;					glog.Fatalf("Package %v: unsupported %s value: %q", i, tagName, ptagValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ptagRegister = ptag.register
0000000000000000000000000000000000000000;;				glog.V(5).Infof("  tag.value: %q, tag.register: %t", ptagValue, ptagRegister)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("  no tag")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the pkg-scoped tag says to generate, we can skip scanning types.
0000000000000000000000000000000000000000;;			pkgNeedsGeneration := (ptagValue == tagValuePackage)
0000000000000000000000000000000000000000;;			if !pkgNeedsGeneration {
0000000000000000000000000000000000000000;;				// If the pkg-scoped tag did not exist, scan all types for one that
0000000000000000000000000000000000000000;;				// explicitly wants generation.
0000000000000000000000000000000000000000;;				for _, t := range pkg.Types {
0000000000000000000000000000000000000000;;					glog.V(5).Infof("  considering type %q", t.Name.String())
0000000000000000000000000000000000000000;;					ttag := extractTag(t.CommentLines)
0000000000000000000000000000000000000000;;					if ttag != nil && ttag.value == "true" {
0000000000000000000000000000000000000000;;						glog.V(5).Infof("    tag=true")
0000000000000000000000000000000000000000;;						if !copyableType(t) {
0000000000000000000000000000000000000000;;							glog.Fatalf("Type %v requests deepcopy generation but is not copyable", t)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						pkgNeedsGeneration = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pkgNeedsGeneration {
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Package %q needs generation", i)
0000000000000000000000000000000000000000;;				path := pkg.Path
0000000000000000000000000000000000000000;;				// if the source path is within a /vendor/ directory (for example,
0000000000000000000000000000000000000000;;				// k8s.io/kubernetes/vendor/k8s.io/apimachinery/pkg/apis/meta/v1), allow
0000000000000000000000000000000000000000;;				// generation to output to the proper relative path (under vendor).
0000000000000000000000000000000000000000;;				// Otherwise, the generator will create the file in the wrong location
0000000000000000000000000000000000000000;;				// in the output directory.
0000000000000000000000000000000000000000;;				// TODO: build a more fundamental concept in gengo for dealing with modifications
0000000000000000000000000000000000000000;;				// to vendored packages.
0000000000000000000000000000000000000000;;				if strings.HasPrefix(pkg.SourcePath, arguments.OutputBase) {
0000000000000000000000000000000000000000;;					expandedPath := strings.TrimPrefix(pkg.SourcePath, arguments.OutputBase)
0000000000000000000000000000000000000000;;					if strings.Contains(expandedPath, "/vendor/") {
0000000000000000000000000000000000000000;;						path = expandedPath
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				packages = append(packages,
0000000000000000000000000000000000000000;;					&generator.DefaultPackage{
0000000000000000000000000000000000000000;;						PackageName: strings.Split(filepath.Base(pkg.Path), ".")[0],
0000000000000000000000000000000000000000;;						PackagePath: path,
0000000000000000000000000000000000000000;;						HeaderText:  header,
0000000000000000000000000000000000000000;;						GeneratorFunc: func(c *generator.Context) (generators []generator.Generator) {
0000000000000000000000000000000000000000;;							return []generator.Generator{
0000000000000000000000000000000000000000;;								NewGenDeepCopy(arguments.OutputFileBaseName, pkg.Path, boundingDirs, (ptagValue == tagValuePackage), ptagRegister),
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						FilterFunc: func(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;							return t.Name.Package == pkg.Path
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return packages
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		conversionPackagePath = "k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		runtimePackagePath    = "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genDeepCopy produces a file with autogenerated deep-copy functions.
0000000000000000000000000000000000000000;;	type genDeepCopy struct {
0000000000000000000000000000000000000000;;		generator.DefaultGen
0000000000000000000000000000000000000000;;		targetPackage string
0000000000000000000000000000000000000000;;		boundingDirs  []string
0000000000000000000000000000000000000000;;		allTypes      bool
0000000000000000000000000000000000000000;;		registerTypes bool
0000000000000000000000000000000000000000;;		imports       namer.ImportTracker
0000000000000000000000000000000000000000;;		typesForInit  []*types.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGenDeepCopy(sanitizedName, targetPackage string, boundingDirs []string, allTypes, registerTypes bool) generator.Generator {
0000000000000000000000000000000000000000;;		return &genDeepCopy{
0000000000000000000000000000000000000000;;			DefaultGen: generator.DefaultGen{
0000000000000000000000000000000000000000;;				OptionalName: sanitizedName,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			targetPackage: targetPackage,
0000000000000000000000000000000000000000;;			boundingDirs:  boundingDirs,
0000000000000000000000000000000000000000;;			allTypes:      allTypes,
0000000000000000000000000000000000000000;;			registerTypes: registerTypes,
0000000000000000000000000000000000000000;;			imports:       generator.NewImportTracker(),
0000000000000000000000000000000000000000;;			typesForInit:  make([]*types.Type, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) Namers(c *generator.Context) namer.NameSystems {
0000000000000000000000000000000000000000;;		// Have the raw namer for this file track what it imports.
0000000000000000000000000000000000000000;;		return namer.NameSystems{
0000000000000000000000000000000000000000;;			"raw": namer.NewRawNamer(g.targetPackage, g.imports),
0000000000000000000000000000000000000000;;			"dcFnName": &dcFnNamer{
0000000000000000000000000000000000000000;;				public:    deepCopyNamer(),
0000000000000000000000000000000000000000;;				tracker:   g.imports,
0000000000000000000000000000000000000000;;				myPackage: g.targetPackage,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) Filter(c *generator.Context, t *types.Type) bool {
0000000000000000000000000000000000000000;;		// Filter out types not being processed or not copyable within the package.
0000000000000000000000000000000000000000;;		enabled := g.allTypes
0000000000000000000000000000000000000000;;		if !enabled {
0000000000000000000000000000000000000000;;			ttag := extractTag(t.CommentLines)
0000000000000000000000000000000000000000;;			if ttag != nil && ttag.value == "true" {
0000000000000000000000000000000000000000;;				enabled = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !enabled {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !copyableType(t) {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("Type %v is not copyable", t)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Type %v is copyable", t)
0000000000000000000000000000000000000000;;		g.typesForInit = append(g.typesForInit, t)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) copyableAndInBounds(t *types.Type) bool {
0000000000000000000000000000000000000000;;		if !copyableType(t) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only packages within the restricted range can be processed.
0000000000000000000000000000000000000000;;		if !isRootedUnder(t.Name.Package, g.boundingDirs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasDeepCopyMethod returns true if an appropriate DeepCopy() method is
0000000000000000000000000000000000000000;;	// defined for the given type.  This allows more efficient deep copy
0000000000000000000000000000000000000000;;	// implementations to be defined by the type's author.  The correct signature
0000000000000000000000000000000000000000;;	// for a type T is:
0000000000000000000000000000000000000000;;	//    func (t T) DeepCopy() T
0000000000000000000000000000000000000000;;	// or:
0000000000000000000000000000000000000000;;	//    func (t *T) DeepCopyt() T
0000000000000000000000000000000000000000;;	func hasDeepCopyMethod(t *types.Type) bool {
0000000000000000000000000000000000000000;;		for mn, mt := range t.Methods {
0000000000000000000000000000000000000000;;			if mn != "DeepCopy" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(mt.Signature.Parameters) != 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(mt.Signature.Results) != 1 || mt.Signature.Results[0].Name != t.Name {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isRootedUnder(pkg string, roots []string) bool {
0000000000000000000000000000000000000000;;		// Add trailing / to avoid false matches, e.g. foo/bar vs foo/barn.  This
0000000000000000000000000000000000000000;;		// assumes that bounding dirs do not have trailing slashes.
0000000000000000000000000000000000000000;;		pkg = pkg + "/"
0000000000000000000000000000000000000000;;		for _, root := range roots {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(pkg, root+"/") {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyableType(t *types.Type) bool {
0000000000000000000000000000000000000000;;		// If the type opts out of copy-generation, stop.
0000000000000000000000000000000000000000;;		ttag := extractTag(t.CommentLines)
0000000000000000000000000000000000000000;;		if ttag != nil && ttag.value == "false" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Consider generating functions for other kinds too.
0000000000000000000000000000000000000000;;		if t.Kind != types.Struct {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Also, filter out private types.
0000000000000000000000000000000000000000;;		if namer.IsPrivateGoName(t.Name.Name) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) isOtherPackage(pkg string) bool {
0000000000000000000000000000000000000000;;		if pkg == g.targetPackage {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(pkg, "\""+g.targetPackage+"\"") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) Imports(c *generator.Context) (imports []string) {
0000000000000000000000000000000000000000;;		importLines := []string{}
0000000000000000000000000000000000000000;;		for _, singleImport := range g.imports.ImportLines() {
0000000000000000000000000000000000000000;;			if g.isOtherPackage(singleImport) {
0000000000000000000000000000000000000000;;				importLines = append(importLines, singleImport)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return importLines
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func argsFromType(t *types.Type) generator.Args {
0000000000000000000000000000000000000000;;		return generator.Args{
0000000000000000000000000000000000000000;;			"type": t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dcFnNamer struct {
0000000000000000000000000000000000000000;;		public    namer.Namer
0000000000000000000000000000000000000000;;		tracker   namer.ImportTracker
0000000000000000000000000000000000000000;;		myPackage string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *dcFnNamer) Name(t *types.Type) string {
0000000000000000000000000000000000000000;;		pubName := n.public.Name(t)
0000000000000000000000000000000000000000;;		n.tracker.AddType(t)
0000000000000000000000000000000000000000;;		if t.Name.Package == n.myPackage {
0000000000000000000000000000000000000000;;			return "DeepCopy_" + pubName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s.DeepCopy_%s", n.tracker.LocalNameOf(t.Name.Package), pubName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) Init(c *generator.Context, w io.Writer) error {
0000000000000000000000000000000000000000;;		cloner := c.Universe.Type(types.Name{Package: conversionPackagePath, Name: "Cloner"})
0000000000000000000000000000000000000000;;		g.imports.AddType(cloner)
0000000000000000000000000000000000000000;;		if !g.registerTypes {
0000000000000000000000000000000000000000;;			sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;			sw.Do("// GetGeneratedDeepCopyFuncs returns the generated funcs, since we aren't registering them.\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("func GetGeneratedDeepCopyFuncs() []conversion.GeneratedDeepCopyFunc{\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("return []conversion.GeneratedDeepCopyFunc{\n", nil)
0000000000000000000000000000000000000000;;			for _, t := range g.typesForInit {
0000000000000000000000000000000000000000;;				args := argsFromType(t).
0000000000000000000000000000000000000000;;					With("typeof", c.Universe.Package("reflect").Function("TypeOf"))
0000000000000000000000000000000000000000;;				sw.Do("{Fn: $.type|dcFnName$, InType: $.typeof|raw$(&$.type|raw${})},\n", args)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;			return sw.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Registering types in pkg %q", g.targetPackage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		sw.Do("func init() {\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("SchemeBuilder.Register(RegisterDeepCopies)\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := c.Universe.Type(types.Name{Package: runtimePackagePath, Name: "Scheme"})
0000000000000000000000000000000000000000;;		schemePtr := &types.Type{
0000000000000000000000000000000000000000;;			Kind: types.Pointer,
0000000000000000000000000000000000000000;;			Elem: scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do("// RegisterDeepCopies adds deep-copy functions to the given scheme. Public\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("// to allow building arbitrary schemes.\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("func RegisterDeepCopies(scheme $.|raw$) error {\n", schemePtr)
0000000000000000000000000000000000000000;;		sw.Do("return scheme.AddGeneratedDeepCopyFuncs(\n", nil)
0000000000000000000000000000000000000000;;		for _, t := range g.typesForInit {
0000000000000000000000000000000000000000;;			args := argsFromType(t).
0000000000000000000000000000000000000000;;				With("typeof", c.Universe.Package("reflect").Function("TypeOf"))
0000000000000000000000000000000000000000;;			sw.Do("conversion.GeneratedDeepCopyFunc{Fn: $.type|dcFnName$, InType: $.typeof|raw$(&$.type|raw${})},\n", args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sw.Do(")\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}\n\n", nil)
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) needsGeneration(t *types.Type) bool {
0000000000000000000000000000000000000000;;		tag := extractTag(t.CommentLines)
0000000000000000000000000000000000000000;;		tv := ""
0000000000000000000000000000000000000000;;		if tag != nil {
0000000000000000000000000000000000000000;;			tv = tag.value
0000000000000000000000000000000000000000;;			if tv != "true" && tv != "false" {
0000000000000000000000000000000000000000;;				glog.Fatalf("Type %v: unsupported %s value: %q", t, tagName, tag.value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if g.allTypes && tv == "false" {
0000000000000000000000000000000000000000;;			// The whole package is being generated, but this type has opted out.
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Not generating for type %v because type opted out", t)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !g.allTypes && tv != "true" {
0000000000000000000000000000000000000000;;			// The whole package is NOT being generated, and this type has NOT opted in.
0000000000000000000000000000000000000000;;			glog.V(5).Infof("Not generating for type %v because type did not opt in", t)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {
0000000000000000000000000000000000000000;;		if !g.needsGeneration(t) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Generating deepcopy function for type %v", t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw := generator.NewSnippetWriter(w, c, "$", "$")
0000000000000000000000000000000000000000;;		args := argsFromType(t).
0000000000000000000000000000000000000000;;			With("clonerType", types.Ref(conversionPackagePath, "Cloner"))
0000000000000000000000000000000000000000;;		sw.Do("// $.type|dcFnName$ is an autogenerated deepcopy function.\n", args)
0000000000000000000000000000000000000000;;		sw.Do("func $.type|dcFnName$(in interface{}, out interface{}, c *$.clonerType|raw$) error {{\n", args)
0000000000000000000000000000000000000000;;		sw.Do("in := in.(*$.type|raw$)\nout := out.(*$.type|raw$)\n", argsFromType(t))
0000000000000000000000000000000000000000;;		g.generateFor(t, sw)
0000000000000000000000000000000000000000;;		sw.Do("return nil\n", nil)
0000000000000000000000000000000000000000;;		sw.Do("}}\n\n", nil)
0000000000000000000000000000000000000000;;		return sw.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// we use the system of shadowing 'in' and 'out' so that the same code is valid
0000000000000000000000000000000000000000;;	// at any nesting level. This makes the autogenerator easy to understand, and
0000000000000000000000000000000000000000;;	// the compiler shouldn't care.
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) generateFor(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		var f func(*types.Type, *generator.SnippetWriter)
0000000000000000000000000000000000000000;;		switch t.Kind {
0000000000000000000000000000000000000000;;		case types.Builtin:
0000000000000000000000000000000000000000;;			f = g.doBuiltin
0000000000000000000000000000000000000000;;		case types.Map:
0000000000000000000000000000000000000000;;			f = g.doMap
0000000000000000000000000000000000000000;;		case types.Slice:
0000000000000000000000000000000000000000;;			f = g.doSlice
0000000000000000000000000000000000000000;;		case types.Struct:
0000000000000000000000000000000000000000;;			f = g.doStruct
0000000000000000000000000000000000000000;;		case types.Interface:
0000000000000000000000000000000000000000;;			f = g.doInterface
0000000000000000000000000000000000000000;;		case types.Pointer:
0000000000000000000000000000000000000000;;			f = g.doPointer
0000000000000000000000000000000000000000;;		case types.Alias:
0000000000000000000000000000000000000000;;			f = g.doAlias
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			f = g.doUnknown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f(t, sw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doBuiltin(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("*out = *in\n", nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doMap(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("*out = make($.|raw$)\n", t)
0000000000000000000000000000000000000000;;		if t.Key.IsAssignable() {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case hasDeepCopyMethod(t.Elem):
0000000000000000000000000000000000000000;;				sw.Do("for key, val := range *in {\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("(*out)[key] = val.DeepCopy()\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			case t.Elem.IsAnonymousStruct():
0000000000000000000000000000000000000000;;				sw.Do("for key := range *in {\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("(*out)[key] = struct{}{}\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			case t.Elem.IsAssignable():
0000000000000000000000000000000000000000;;				sw.Do("for key, val := range *in {\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("(*out)[key] = val\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				sw.Do("for key, val := range *in {\n", nil)
0000000000000000000000000000000000000000;;				if g.copyableAndInBounds(t.Elem) {
0000000000000000000000000000000000000000;;					sw.Do("newVal := new($.|raw$)\n", t.Elem)
0000000000000000000000000000000000000000;;					sw.Do("if err := $.type|dcFnName$(&val, newVal, c); err != nil {\n", argsFromType(t.Elem))
0000000000000000000000000000000000000000;;					sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("(*out)[key] = *newVal\n", nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sw.Do("if newVal, err := c.DeepCopy(&val); err != nil {\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("} else {\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("(*out)[key] = *newVal.(*$.|raw$)\n", t.Elem)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: Implement it when necessary.
0000000000000000000000000000000000000000;;			sw.Do("for range *in {\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("// FIXME: Copying unassignable keys unsupported $.|raw$\n", t.Key)
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doSlice(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		if hasDeepCopyMethod(t) {
0000000000000000000000000000000000000000;;			sw.Do("*out = in.DeepCopy()\n", nil)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sw.Do("*out = make($.|raw$, len(*in))\n", t)
0000000000000000000000000000000000000000;;		if hasDeepCopyMethod(t.Elem) {
0000000000000000000000000000000000000000;;			sw.Do("for i := range *in {\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("(*out)[i] = (*in)[i].DeepCopy()\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		} else if t.Elem.Kind == types.Builtin || t.Elem.IsAssignable() {
0000000000000000000000000000000000000000;;			sw.Do("copy(*out, *in)\n", nil)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do("for i := range *in {\n", nil)
0000000000000000000000000000000000000000;;			if t.Elem.Kind == types.Slice {
0000000000000000000000000000000000000000;;				sw.Do("if (*in)[i] != nil {\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("in, out := &(*in)[i], &(*out)[i]\n", nil)
0000000000000000000000000000000000000000;;				g.generateFor(t.Elem, sw)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			} else if g.copyableAndInBounds(t.Elem) {
0000000000000000000000000000000000000000;;				sw.Do("if err := $.type|dcFnName$(&(*in)[i], &(*out)[i], c); err != nil {\n", argsFromType(t.Elem))
0000000000000000000000000000000000000000;;				sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sw.Do("if newVal, err := c.DeepCopy(&(*in)[i]); err != nil {\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("} else {\n", nil)
0000000000000000000000000000000000000000;;				sw.Do("(*out)[i] = *newVal.(*$.|raw$)\n", t.Elem)
0000000000000000000000000000000000000000;;				sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doStruct(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		if hasDeepCopyMethod(t) {
0000000000000000000000000000000000000000;;			sw.Do("*out = in.DeepCopy()\n", nil)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simple copy covers a lot of cases.
0000000000000000000000000000000000000000;;		sw.Do("*out = *in\n", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now fix-up fields as needed.
0000000000000000000000000000000000000000;;		for _, m := range t.Members {
0000000000000000000000000000000000000000;;			t := m.Type
0000000000000000000000000000000000000000;;			hasMethod := hasDeepCopyMethod(t)
0000000000000000000000000000000000000000;;			if t.Kind == types.Alias {
0000000000000000000000000000000000000000;;				copied := *t.Underlying
0000000000000000000000000000000000000000;;				copied.Name = t.Name
0000000000000000000000000000000000000000;;				t = &copied
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			args := generator.Args{
0000000000000000000000000000000000000000;;				"type": t,
0000000000000000000000000000000000000000;;				"kind": t.Kind,
0000000000000000000000000000000000000000;;				"name": m.Name,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t.Kind {
0000000000000000000000000000000000000000;;			case types.Builtin:
0000000000000000000000000000000000000000;;				if hasMethod {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = in.$.name$.DeepCopy()\n", args)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case types.Map, types.Slice, types.Pointer:
0000000000000000000000000000000000000000;;				if hasMethod {
0000000000000000000000000000000000000000;;					sw.Do("if in.$.name$ != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = in.$.name$.DeepCopy()\n", args)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Fixup non-nil reference-semantic types.
0000000000000000000000000000000000000000;;					sw.Do("if in.$.name$ != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("in, out := &in.$.name$, &out.$.name$\n", args)
0000000000000000000000000000000000000000;;					g.generateFor(t, sw)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case types.Struct:
0000000000000000000000000000000000000000;;				if hasMethod {
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = in.$.name$.DeepCopy()\n", args)
0000000000000000000000000000000000000000;;				} else if t.IsAssignable() {
0000000000000000000000000000000000000000;;					// Nothing else needed.
0000000000000000000000000000000000000000;;				} else if g.copyableAndInBounds(t) {
0000000000000000000000000000000000000000;;					// Not assignable but should have a deepcopy function.
0000000000000000000000000000000000000000;;					// TODO: do a topological sort of packages and ensure that this works, else inline it.
0000000000000000000000000000000000000000;;					sw.Do("if err := $.type|dcFnName$(&in.$.name$, &out.$.name$, c); err != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Fall back on the slow-path and hope it works.
0000000000000000000000000000000000000000;;					// TODO: don't depend on kubernetes code for this
0000000000000000000000000000000000000000;;					sw.Do("if newVal, err := c.DeepCopy(&in.$.name$); err != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("} else {\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = *newVal.(*$.type|raw$)\n", args)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Interfaces, Arrays, and other Kinds we don't understand.
0000000000000000000000000000000000000000;;				sw.Do("// in.$.name$ is kind '$.kind$'\n", args)
0000000000000000000000000000000000000000;;				if hasMethod {
0000000000000000000000000000000000000000;;					sw.Do("if in.$.name$ != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = in.$.name$.DeepCopy()\n", args)
0000000000000000000000000000000000000000;;					sw.Do("}\n", args)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// TODO: don't depend on kubernetes code for this
0000000000000000000000000000000000000000;;					sw.Do("if in.$.name$ != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("if newVal, err := c.DeepCopy(&in.$.name$); err != nil {\n", args)
0000000000000000000000000000000000000000;;					sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("} else {\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("out.$.name$ = *newVal.(*$.type|raw$)\n", args)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;					sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doInterface(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		// TODO: Add support for interfaces.
0000000000000000000000000000000000000000;;		g.doUnknown(t, sw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doPointer(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		if hasDeepCopyMethod(t.Elem) {
0000000000000000000000000000000000000000;;			sw.Do("*out = new($.Elem|raw$)\n", t)
0000000000000000000000000000000000000000;;			sw.Do("**out = (*in).DeepCopy()\n", nil)
0000000000000000000000000000000000000000;;		} else if t.Elem.IsAssignable() {
0000000000000000000000000000000000000000;;			sw.Do("*out = new($.Elem|raw$)\n", t)
0000000000000000000000000000000000000000;;			sw.Do("**out = **in", nil)
0000000000000000000000000000000000000000;;		} else if g.copyableAndInBounds(t.Elem) {
0000000000000000000000000000000000000000;;			sw.Do("*out = new($.Elem|raw$)\n", t)
0000000000000000000000000000000000000000;;			sw.Do("if err := $.type|dcFnName$(*in, *out, c); err != nil {\n", argsFromType(t.Elem))
0000000000000000000000000000000000000000;;			sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sw.Do("if newVal, err := c.DeepCopy(*in); err != nil {\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("return err\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("} else {\n", nil)
0000000000000000000000000000000000000000;;			sw.Do("*out = newVal.(*$.|raw$)\n", t.Elem)
0000000000000000000000000000000000000000;;			sw.Do("}\n", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doAlias(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		// TODO: Add support for aliases.
0000000000000000000000000000000000000000;;		g.doUnknown(t, sw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *genDeepCopy) doUnknown(t *types.Type, sw *generator.SnippetWriter) {
0000000000000000000000000000000000000000;;		sw.Do("// FIXME: Type $.|raw$ is unsupported.\n", t)
0000000000000000000000000000000000000000;;	}
