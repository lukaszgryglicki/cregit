0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
6547a7ca1fd679ace4f46c3b3c758abe031852fd;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package args has common command-line flags for generation programs.
0000000000000000000000000000000000000000;;	package args
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		goflag "flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/gengo/generator"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/namer"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/parser"
0000000000000000000000000000000000000000;;		"k8s.io/gengo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Default returns a defaulted GeneratorArgs. You may change the defaults
0000000000000000000000000000000000000000;;	// before calling AddFlags.
0000000000000000000000000000000000000000;;	func Default() *GeneratorArgs {
0000000000000000000000000000000000000000;;		generatorArgs := &GeneratorArgs{
0000000000000000000000000000000000000000;;			OutputBase:        DefaultSourceTree(),
0000000000000000000000000000000000000000;;			GoHeaderFilePath:  filepath.Join(DefaultSourceTree(), "k8s.io/gengo/boilerplate/boilerplate.go.txt"),
0000000000000000000000000000000000000000;;			GeneratedBuildTag: "ignore_autogenerated",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		generatorArgs.AddFlags(pflag.CommandLine)
0000000000000000000000000000000000000000;;		return generatorArgs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GeneratorArgs has arguments that are passed to generators.
0000000000000000000000000000000000000000;;	type GeneratorArgs struct {
0000000000000000000000000000000000000000;;		// Which directories to parse.
0000000000000000000000000000000000000000;;		InputDirs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Source tree to write results to.
0000000000000000000000000000000000000000;;		OutputBase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Package path within the source tree.
0000000000000000000000000000000000000000;;		OutputPackagePath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Output file name.
0000000000000000000000000000000000000000;;		OutputFileBaseName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Where to get copyright header text.
0000000000000000000000000000000000000000;;		GoHeaderFilePath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, only verify, don't write anything.
0000000000000000000000000000000000000000;;		VerifyOnly bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GeneratedBuildTag is the tag used to identify code generated by execution
0000000000000000000000000000000000000000;;		// of this type. Each generator should use a different tag, and different
0000000000000000000000000000000000000000;;		// groups of generators (external API that depends on Kube generations) should
0000000000000000000000000000000000000000;;		// keep tags distinct as well.
0000000000000000000000000000000000000000;;		GeneratedBuildTag string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Any custom arguments go here
0000000000000000000000000000000000000000;;		CustomArgs interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *GeneratorArgs) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		fs.StringSliceVarP(&g.InputDirs, "input-dirs", "i", g.InputDirs, "Comma-separated list of import paths to get input types from.")
0000000000000000000000000000000000000000;;		fs.StringVarP(&g.OutputBase, "output-base", "o", g.OutputBase, "Output base; defaults to $GOPATH/src/ or ./ if $GOPATH is not set.")
0000000000000000000000000000000000000000;;		fs.StringVarP(&g.OutputPackagePath, "output-package", "p", g.OutputPackagePath, "Base package path.")
0000000000000000000000000000000000000000;;		fs.StringVarP(&g.OutputFileBaseName, "output-file-base", "O", g.OutputFileBaseName, "Base name (without .go suffix) for output files.")
0000000000000000000000000000000000000000;;		fs.StringVarP(&g.GoHeaderFilePath, "go-header-file", "h", g.GoHeaderFilePath, "File containing boilerplate header text. The string YEAR will be replaced with the current 4-digit year.")
0000000000000000000000000000000000000000;;		fs.BoolVar(&g.VerifyOnly, "verify-only", g.VerifyOnly, "If true, only verify existing output, do not write anything.")
0000000000000000000000000000000000000000;;		fs.StringVar(&g.GeneratedBuildTag, "build-tag", g.GeneratedBuildTag, "A Go build tag to use to identify files generated by this command. Should be unique.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadGoBoilerplate loads the boilerplate file passed to --go-header-file.
0000000000000000000000000000000000000000;;	func (g *GeneratorArgs) LoadGoBoilerplate() ([]byte, error) {
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadFile(g.GoHeaderFilePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b = bytes.Replace(b, []byte("YEAR"), []byte(strconv.Itoa(time.Now().Year())), -1)
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBuilder makes a new parser.Builder and populates it with the input
0000000000000000000000000000000000000000;;	// directories.
0000000000000000000000000000000000000000;;	func (g *GeneratorArgs) NewBuilder() (*parser.Builder, error) {
0000000000000000000000000000000000000000;;		b := parser.New()
0000000000000000000000000000000000000000;;		// Ignore all auto-generated files.
0000000000000000000000000000000000000000;;		b.AddBuildTags(g.GeneratedBuildTag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, d := range g.InputDirs {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if strings.HasSuffix(d, "/...") {
0000000000000000000000000000000000000000;;				err = b.AddDirRecursive(strings.TrimSuffix(d, "/..."))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = b.AddDir(d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to add directory %q: %v", d, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InputIncludes returns true if the given package is a (sub) package of one of
0000000000000000000000000000000000000000;;	// the InputDirs.
0000000000000000000000000000000000000000;;	func (g *GeneratorArgs) InputIncludes(p *types.Package) bool {
0000000000000000000000000000000000000000;;		for _, dir := range g.InputDirs {
0000000000000000000000000000000000000000;;			d := dir
0000000000000000000000000000000000000000;;			if strings.HasSuffix(d, "...") {
0000000000000000000000000000000000000000;;				d = strings.TrimSuffix(d, "...")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(p.Path, d) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultSourceTree returns the /src directory of the first entry in $GOPATH.
0000000000000000000000000000000000000000;;	// If $GOPATH is empty, it returns "./". Useful as a default output location.
0000000000000000000000000000000000000000;;	func DefaultSourceTree() string {
0000000000000000000000000000000000000000;;		paths := strings.Split(os.Getenv("GOPATH"), string(filepath.ListSeparator))
0000000000000000000000000000000000000000;;		if len(paths) > 0 && len(paths[0]) > 0 {
0000000000000000000000000000000000000000;;			return filepath.Join(paths[0], "src")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "./"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Execute implements main().
0000000000000000000000000000000000000000;;	// If you don't need any non-default behavior, use as:
0000000000000000000000000000000000000000;;	// args.Default().Execute(...)
0000000000000000000000000000000000000000;;	func (g *GeneratorArgs) Execute(nameSystems namer.NameSystems, defaultSystem string, pkgs func(*generator.Context, *GeneratorArgs) generator.Packages) error {
0000000000000000000000000000000000000000;;		pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)
0000000000000000000000000000000000000000;;		pflag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := g.NewBuilder()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed making a parser: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := generator.NewContext(b, nameSystems, defaultSystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed making a context: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Verify = g.VerifyOnly
0000000000000000000000000000000000000000;;		packages := pkgs(c, g)
0000000000000000000000000000000000000000;;		if err := c.ExecutePackages(g.OutputBase, packages); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed executing generator: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
