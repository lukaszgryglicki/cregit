0000000000000000000000000000000000000000;;	package sortorder
922c6ae2fb4804fdef4bc466ef7880bcf9157d8d;;	
0000000000000000000000000000000000000000;;	// Natural implements sort.Interface to sort strings in natural order. This
0000000000000000000000000000000000000000;;	// means that e.g. "abc2" < "abc12".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Non-digit sequences and numbers are compared separately. The former are
0000000000000000000000000000000000000000;;	// compared bytewise, while the latter are compared numerically (except that
0000000000000000000000000000000000000000;;	// the number of leading zeros is used as a tie-breaker, so e.g. "2" < "02")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Limitation: only ASCII digits (0-9) are considered.
0000000000000000000000000000000000000000;;	type Natural []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n Natural) Len() int           { return len(n) }
0000000000000000000000000000000000000000;;	func (n Natural) Swap(i, j int)      { n[i], n[j] = n[j], n[i] }
0000000000000000000000000000000000000000;;	func (n Natural) Less(i, j int) bool { return NaturalLess(n[i], n[j]) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isdigit(b byte) bool { return '0' <= b && b <= '9' }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NaturalLess compares two strings using natural ordering. This means that e.g.
0000000000000000000000000000000000000000;;	// "abc2" < "abc12".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Non-digit sequences and numbers are compared separately. The former are
0000000000000000000000000000000000000000;;	// compared bytewise, while the latter are compared numerically (except that
0000000000000000000000000000000000000000;;	// the number of leading zeros is used as a tie-breaker, so e.g. "2" < "02")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Limitation: only ASCII digits (0-9) are considered.
0000000000000000000000000000000000000000;;	func NaturalLess(str1, str2 string) bool {
0000000000000000000000000000000000000000;;		idx1, idx2 := 0, 0
0000000000000000000000000000000000000000;;		for idx1 < len(str1) && idx2 < len(str2) {
0000000000000000000000000000000000000000;;			c1, c2 := str1[idx1], str2[idx2]
0000000000000000000000000000000000000000;;			dig1, dig2 := isdigit(c1), isdigit(c2)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case dig1 != dig2: // Digits before other characters.
0000000000000000000000000000000000000000;;				return dig1 // True if LHS is a digit, false if the RHS is one.
0000000000000000000000000000000000000000;;			case !dig1: // && !dig2, because dig1 == dig2
0000000000000000000000000000000000000000;;				// UTF-8 compares bytewise-lexicographically, no need to decode
0000000000000000000000000000000000000000;;				// codepoints.
0000000000000000000000000000000000000000;;				if c1 != c2 {
0000000000000000000000000000000000000000;;					return c1 < c2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				idx1++
0000000000000000000000000000000000000000;;				idx2++
0000000000000000000000000000000000000000;;			default: // Digits
0000000000000000000000000000000000000000;;				// Eat zeros.
0000000000000000000000000000000000000000;;				for ; idx1 < len(str1) && str1[idx1] == '0'; idx1++ {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for ; idx2 < len(str2) && str2[idx2] == '0'; idx2++ {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Eat all digits.
0000000000000000000000000000000000000000;;				nonZero1, nonZero2 := idx1, idx2
0000000000000000000000000000000000000000;;				for ; idx1 < len(str1) && isdigit(str1[idx1]); idx1++ {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for ; idx2 < len(str2) && isdigit(str2[idx2]); idx2++ {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If lengths of numbers with non-zero prefix differ, the shorter
0000000000000000000000000000000000000000;;				// one is less.
0000000000000000000000000000000000000000;;				if len1, len2 := idx1-nonZero1, idx2-nonZero2; len1 != len2 {
0000000000000000000000000000000000000000;;					return len1 < len2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If they're not equal, string comparison is correct.
0000000000000000000000000000000000000000;;				if nr1, nr2 := str1[nonZero1:idx1], str2[nonZero2:idx2]; nr1 != nr2 {
0000000000000000000000000000000000000000;;					return nr1 < nr2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Otherwise, the one with less zeros is less.
0000000000000000000000000000000000000000;;				// Because everything up to the number is equal, comparing the index
0000000000000000000000000000000000000000;;				// after the zeros is sufficient.
0000000000000000000000000000000000000000;;				if nonZero1 != nonZero2 {
0000000000000000000000000000000000000000;;					return nonZero1 < nonZero2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// They're identical so far, so continue comparing.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// So far they are identical. At least one is ended. If the other continues,
0000000000000000000000000000000000000000;;		// it sorts last.
0000000000000000000000000000000000000000;;		return len(str1) < len(str2)
0000000000000000000000000000000000000000;;	}
