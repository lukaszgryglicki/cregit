0000000000000000000000000000000000000000;;	package restful
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/container.go[Godeps/_workspace/src/github.com/emicklei/go-restful/container.go][vendor/github.com/emicklei/go-restful/container.go];	
0000000000000000000000000000000000000000;;	// Copyright 2013 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful/log"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container holds a collection of WebServices and a http.ServeMux to dispatch http requests.
0000000000000000000000000000000000000000;;	// The requests are further dispatched to routes of WebServices using a RouteSelector
0000000000000000000000000000000000000000;;	type Container struct {
0000000000000000000000000000000000000000;;		webServicesLock        sync.RWMutex
0000000000000000000000000000000000000000;;		webServices            []*WebService
0000000000000000000000000000000000000000;;		ServeMux               *http.ServeMux
0000000000000000000000000000000000000000;;		isRegisteredOnRoot     bool
0000000000000000000000000000000000000000;;		containerFilters       []FilterFunction
0000000000000000000000000000000000000000;;		doNotRecover           bool // default is true
0000000000000000000000000000000000000000;;		recoverHandleFunc      RecoverHandleFunction
0000000000000000000000000000000000000000;;		serviceErrorHandleFunc ServiceErrorHandleFunction
0000000000000000000000000000000000000000;;		router                 RouteSelector // default is a CurlyRouter (RouterJSR311 is a slower alternative)
0000000000000000000000000000000000000000;;		contentEncodingEnabled bool          // default is false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewContainer creates a new Container using a new ServeMux and default router (CurlyRouter)
0000000000000000000000000000000000000000;;	func NewContainer() *Container {
0000000000000000000000000000000000000000;;		return &Container{
0000000000000000000000000000000000000000;;			webServices:            []*WebService{},
0000000000000000000000000000000000000000;;			ServeMux:               http.NewServeMux(),
0000000000000000000000000000000000000000;;			isRegisteredOnRoot:     false,
0000000000000000000000000000000000000000;;			containerFilters:       []FilterFunction{},
0000000000000000000000000000000000000000;;			doNotRecover:           true,
0000000000000000000000000000000000000000;;			recoverHandleFunc:      logStackOnRecover,
0000000000000000000000000000000000000000;;			serviceErrorHandleFunc: writeServiceError,
0000000000000000000000000000000000000000;;			router:                 CurlyRouter{},
0000000000000000000000000000000000000000;;			contentEncodingEnabled: false}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecoverHandleFunction declares functions that can be used to handle a panic situation.
0000000000000000000000000000000000000000;;	// The first argument is what recover() returns. The second must be used to communicate an error response.
0000000000000000000000000000000000000000;;	type RecoverHandleFunction func(interface{}, http.ResponseWriter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecoverHandler changes the default function (logStackOnRecover) to be called
0000000000000000000000000000000000000000;;	// when a panic is detected. DoNotRecover must be have its default value (=false).
0000000000000000000000000000000000000000;;	func (c *Container) RecoverHandler(handler RecoverHandleFunction) {
0000000000000000000000000000000000000000;;		c.recoverHandleFunc = handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceErrorHandleFunction declares functions that can be used to handle a service error situation.
0000000000000000000000000000000000000000;;	// The first argument is the service error, the second is the request that resulted in the error and
0000000000000000000000000000000000000000;;	// the third must be used to communicate an error response.
0000000000000000000000000000000000000000;;	type ServiceErrorHandleFunction func(ServiceError, *Request, *Response)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceErrorHandler changes the default function (writeServiceError) to be called
0000000000000000000000000000000000000000;;	// when a ServiceError is detected.
0000000000000000000000000000000000000000;;	func (c *Container) ServiceErrorHandler(handler ServiceErrorHandleFunction) {
0000000000000000000000000000000000000000;;		c.serviceErrorHandleFunc = handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoNotRecover controls whether panics will be caught to return HTTP 500.
0000000000000000000000000000000000000000;;	// If set to true, Route functions are responsible for handling any error situation.
0000000000000000000000000000000000000000;;	// Default value is true.
0000000000000000000000000000000000000000;;	func (c *Container) DoNotRecover(doNot bool) {
0000000000000000000000000000000000000000;;		c.doNotRecover = doNot
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Router changes the default Router (currently CurlyRouter)
0000000000000000000000000000000000000000;;	func (c *Container) Router(aRouter RouteSelector) {
0000000000000000000000000000000000000000;;		c.router = aRouter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnableContentEncoding (default=false) allows for GZIP or DEFLATE encoding of responses.
0000000000000000000000000000000000000000;;	func (c *Container) EnableContentEncoding(enabled bool) {
0000000000000000000000000000000000000000;;		c.contentEncodingEnabled = enabled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a WebService to the Container. It will detect duplicate root paths and exit in that case.
0000000000000000000000000000000000000000;;	func (c *Container) Add(service *WebService) *Container {
0000000000000000000000000000000000000000;;		c.webServicesLock.Lock()
0000000000000000000000000000000000000000;;		defer c.webServicesLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if rootPath was not set then lazy initialize it
0000000000000000000000000000000000000000;;		if len(service.rootPath) == 0 {
0000000000000000000000000000000000000000;;			service.Path("/")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cannot have duplicate root paths
0000000000000000000000000000000000000000;;		for _, each := range c.webServices {
0000000000000000000000000000000000000000;;			if each.RootPath() == service.RootPath() {
0000000000000000000000000000000000000000;;				log.Printf("[restful] WebService with duplicate root path detected:['%v']", each)
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If not registered on root then add specific mapping
0000000000000000000000000000000000000000;;		if !c.isRegisteredOnRoot {
0000000000000000000000000000000000000000;;			c.isRegisteredOnRoot = c.addHandler(service, c.ServeMux)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.webServices = append(c.webServices, service)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addHandler may set a new HandleFunc for the serveMux
0000000000000000000000000000000000000000;;	// this function must run inside the critical region protected by the webServicesLock.
0000000000000000000000000000000000000000;;	// returns true if the function was registered on root ("/")
0000000000000000000000000000000000000000;;	func (c *Container) addHandler(service *WebService, serveMux *http.ServeMux) bool {
0000000000000000000000000000000000000000;;		pattern := fixedPrefixPath(service.RootPath())
0000000000000000000000000000000000000000;;		// check if root path registration is needed
0000000000000000000000000000000000000000;;		if "/" == pattern || "" == pattern {
0000000000000000000000000000000000000000;;			serveMux.HandleFunc("/", c.dispatch)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// detect if registration already exists
0000000000000000000000000000000000000000;;		alreadyMapped := false
0000000000000000000000000000000000000000;;		for _, each := range c.webServices {
0000000000000000000000000000000000000000;;			if each.RootPath() == service.RootPath() {
0000000000000000000000000000000000000000;;				alreadyMapped = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !alreadyMapped {
0000000000000000000000000000000000000000;;			serveMux.HandleFunc(pattern, c.dispatch)
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(pattern, "/") {
0000000000000000000000000000000000000000;;				serveMux.HandleFunc(pattern+"/", c.dispatch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Container) Remove(ws *WebService) error {
0000000000000000000000000000000000000000;;		if c.ServeMux == http.DefaultServeMux {
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("[restful] cannot remove a WebService from a Container using the DefaultServeMux: ['%v']", ws)
0000000000000000000000000000000000000000;;			log.Printf(errMsg)
0000000000000000000000000000000000000000;;			return errors.New(errMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.webServicesLock.Lock()
0000000000000000000000000000000000000000;;		defer c.webServicesLock.Unlock()
0000000000000000000000000000000000000000;;		// build a new ServeMux and re-register all WebServices
0000000000000000000000000000000000000000;;		newServeMux := http.NewServeMux()
0000000000000000000000000000000000000000;;		newServices := []*WebService{}
0000000000000000000000000000000000000000;;		newIsRegisteredOnRoot := false
0000000000000000000000000000000000000000;;		for _, each := range c.webServices {
0000000000000000000000000000000000000000;;			if each.rootPath != ws.rootPath {
0000000000000000000000000000000000000000;;				// If not registered on root then add specific mapping
0000000000000000000000000000000000000000;;				if !newIsRegisteredOnRoot {
0000000000000000000000000000000000000000;;					newIsRegisteredOnRoot = c.addHandler(each, newServeMux)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newServices = append(newServices, each)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.webServices, c.ServeMux, c.isRegisteredOnRoot = newServices, newServeMux, newIsRegisteredOnRoot
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logStackOnRecover is the default RecoverHandleFunction and is called
0000000000000000000000000000000000000000;;	// when DoNotRecover is false and the recoverHandleFunc is not set for the container.
0000000000000000000000000000000000000000;;	// Default implementation logs the stacktrace and writes the stacktrace on the response.
0000000000000000000000000000000000000000;;	// This may be a security issue as it exposes sourcecode information.
0000000000000000000000000000000000000000;;	func logStackOnRecover(panicReason interface{}, httpWriter http.ResponseWriter) {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		buffer.WriteString(fmt.Sprintf("[restful] recover from panic situation: - %v\r\n", panicReason))
0000000000000000000000000000000000000000;;		for i := 2; ; i += 1 {
0000000000000000000000000000000000000000;;			_, file, line, ok := runtime.Caller(i)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.WriteString(fmt.Sprintf("    %s:%d\r\n", file, line))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Print(buffer.String())
0000000000000000000000000000000000000000;;		httpWriter.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;		httpWriter.Write(buffer.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeServiceError is the default ServiceErrorHandleFunction and is called
0000000000000000000000000000000000000000;;	// when a ServiceError is returned during route selection. Default implementation
0000000000000000000000000000000000000000;;	// calls resp.WriteErrorString(err.Code, err.Message)
0000000000000000000000000000000000000000;;	func writeServiceError(err ServiceError, req *Request, resp *Response) {
0000000000000000000000000000000000000000;;		resp.WriteErrorString(err.Code, err.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dispatch the incoming Http Request to a matching WebService.
0000000000000000000000000000000000000000;;	func (c *Container) Dispatch(httpWriter http.ResponseWriter, httpRequest *http.Request) {
0000000000000000000000000000000000000000;;		if httpWriter == nil {
0000000000000000000000000000000000000000;;			panic("httpWriter cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if httpRequest == nil {
0000000000000000000000000000000000000000;;			panic("httpRequest cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.dispatch(httpWriter, httpRequest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dispatch the incoming Http Request to a matching WebService.
0000000000000000000000000000000000000000;;	func (c *Container) dispatch(httpWriter http.ResponseWriter, httpRequest *http.Request) {
0000000000000000000000000000000000000000;;		writer := httpWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CompressingResponseWriter should be closed after all operations are done
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if compressWriter, ok := writer.(*CompressingResponseWriter); ok {
0000000000000000000000000000000000000000;;				compressWriter.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Instal panic recovery unless told otherwise
0000000000000000000000000000000000000000;;		if !c.doNotRecover { // catch all for 500 response
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if r := recover(); r != nil {
0000000000000000000000000000000000000000;;					c.recoverHandleFunc(r, writer)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Detect if compression is needed
0000000000000000000000000000000000000000;;		// assume without compression, test for override
0000000000000000000000000000000000000000;;		if c.contentEncodingEnabled {
0000000000000000000000000000000000000000;;			doCompress, encoding := wantsCompressedResponse(httpRequest)
0000000000000000000000000000000000000000;;			if doCompress {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				writer, err = NewCompressingResponseWriter(httpWriter, encoding)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					log.Print("[restful] unable to install compressor: ", err)
0000000000000000000000000000000000000000;;					httpWriter.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Find best match Route ; err is non nil if no match was found
0000000000000000000000000000000000000000;;		var webService *WebService
0000000000000000000000000000000000000000;;		var route *Route
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			c.webServicesLock.RLock()
0000000000000000000000000000000000000000;;			defer c.webServicesLock.RUnlock()
0000000000000000000000000000000000000000;;			webService, route, err = c.router.SelectRoute(
0000000000000000000000000000000000000000;;				c.webServices,
0000000000000000000000000000000000000000;;				httpRequest)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// a non-200 response has already been written
0000000000000000000000000000000000000000;;			// run container filters anyway ; they should not touch the response...
0000000000000000000000000000000000000000;;			chain := FilterChain{Filters: c.containerFilters, Target: func(req *Request, resp *Response) {
0000000000000000000000000000000000000000;;				switch err.(type) {
0000000000000000000000000000000000000000;;				case ServiceError:
0000000000000000000000000000000000000000;;					ser := err.(ServiceError)
0000000000000000000000000000000000000000;;					c.serviceErrorHandleFunc(ser, req, resp)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;			chain.ProcessFilter(NewRequest(httpRequest), NewResponse(writer))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wrappedRequest, wrappedResponse := route.wrapRequestResponse(writer, httpRequest)
0000000000000000000000000000000000000000;;		// pass through filters (if any)
0000000000000000000000000000000000000000;;		if len(c.containerFilters)+len(webService.filters)+len(route.Filters) > 0 {
0000000000000000000000000000000000000000;;			// compose filter chain
0000000000000000000000000000000000000000;;			allFilters := []FilterFunction{}
0000000000000000000000000000000000000000;;			allFilters = append(allFilters, c.containerFilters...)
0000000000000000000000000000000000000000;;			allFilters = append(allFilters, webService.filters...)
0000000000000000000000000000000000000000;;			allFilters = append(allFilters, route.Filters...)
0000000000000000000000000000000000000000;;			chain := FilterChain{Filters: allFilters, Target: func(req *Request, resp *Response) {
0000000000000000000000000000000000000000;;				// handle request by route after passing all filters
0000000000000000000000000000000000000000;;				route.Function(wrappedRequest, wrappedResponse)
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;			chain.ProcessFilter(wrappedRequest, wrappedResponse)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// no filters, handle request by route
0000000000000000000000000000000000000000;;			route.Function(wrappedRequest, wrappedResponse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fixedPrefixPath returns the fixed part of the partspec ; it may include template vars {}
0000000000000000000000000000000000000000;;	func fixedPrefixPath(pathspec string) string {
0000000000000000000000000000000000000000;;		varBegin := strings.Index(pathspec, "{")
0000000000000000000000000000000000000000;;		if -1 == varBegin {
0000000000000000000000000000000000000000;;			return pathspec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pathspec[:varBegin]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP implements net/http.Handler therefore a Container can be a Handler in a http.Server
0000000000000000000000000000000000000000;;	func (c *Container) ServeHTTP(httpwriter http.ResponseWriter, httpRequest *http.Request) {
0000000000000000000000000000000000000000;;		c.ServeMux.ServeHTTP(httpwriter, httpRequest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics.
0000000000000000000000000000000000000000;;	func (c *Container) Handle(pattern string, handler http.Handler) {
0000000000000000000000000000000000000000;;		c.ServeMux.Handle(pattern, handler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleWithFilter registers the handler for the given pattern.
0000000000000000000000000000000000000000;;	// Container's filter chain is applied for handler.
0000000000000000000000000000000000000000;;	// If a handler already exists for pattern, HandleWithFilter panics.
0000000000000000000000000000000000000000;;	func (c *Container) HandleWithFilter(pattern string, handler http.Handler) {
0000000000000000000000000000000000000000;;		f := func(httpResponse http.ResponseWriter, httpRequest *http.Request) {
0000000000000000000000000000000000000000;;			if len(c.containerFilters) == 0 {
0000000000000000000000000000000000000000;;				handler.ServeHTTP(httpResponse, httpRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			chain := FilterChain{Filters: c.containerFilters, Target: func(req *Request, resp *Response) {
0000000000000000000000000000000000000000;;				handler.ServeHTTP(httpResponse, httpRequest)
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;			chain.ProcessFilter(NewRequest(httpRequest), NewResponse(httpResponse))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Handle(pattern, http.HandlerFunc(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter appends a container FilterFunction. These are called before dispatching
0000000000000000000000000000000000000000;;	// a http.Request to a WebService from the container
0000000000000000000000000000000000000000;;	func (c *Container) Filter(filter FilterFunction) {
0000000000000000000000000000000000000000;;		c.containerFilters = append(c.containerFilters, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisteredWebServices returns the collections of added WebServices
0000000000000000000000000000000000000000;;	func (c *Container) RegisteredWebServices() []*WebService {
0000000000000000000000000000000000000000;;		c.webServicesLock.RLock()
0000000000000000000000000000000000000000;;		defer c.webServicesLock.RUnlock()
0000000000000000000000000000000000000000;;		result := make([]*WebService, len(c.webServices))
0000000000000000000000000000000000000000;;		for ix := range c.webServices {
0000000000000000000000000000000000000000;;			result[ix] = c.webServices[ix]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// computeAllowedMethods returns a list of HTTP methods that are valid for a Request
0000000000000000000000000000000000000000;;	func (c *Container) computeAllowedMethods(req *Request) []string {
0000000000000000000000000000000000000000;;		// Go through all RegisteredWebServices() and all its Routes to collect the options
0000000000000000000000000000000000000000;;		methods := []string{}
0000000000000000000000000000000000000000;;		requestPath := req.Request.URL.Path
0000000000000000000000000000000000000000;;		for _, ws := range c.RegisteredWebServices() {
0000000000000000000000000000000000000000;;			matches := ws.pathExpr.Matcher.FindStringSubmatch(requestPath)
0000000000000000000000000000000000000000;;			if matches != nil {
0000000000000000000000000000000000000000;;				finalMatch := matches[len(matches)-1]
0000000000000000000000000000000000000000;;				for _, rt := range ws.Routes() {
0000000000000000000000000000000000000000;;					matches := rt.pathExpr.Matcher.FindStringSubmatch(finalMatch)
0000000000000000000000000000000000000000;;					if matches != nil {
0000000000000000000000000000000000000000;;						lastMatch := matches[len(matches)-1]
0000000000000000000000000000000000000000;;						if lastMatch == "" || lastMatch == "/" { // do not include if value is neither empty nor ‘/’.
0000000000000000000000000000000000000000;;							methods = append(methods, rt.Method)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// methods = append(methods, "OPTIONS")  not sure about this
0000000000000000000000000000000000000000;;		return methods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newBasicRequestResponse creates a pair of Request,Response from its http versions.
0000000000000000000000000000000000000000;;	// It is basic because no parameter or (produces) content-type information is given.
0000000000000000000000000000000000000000;;	func newBasicRequestResponse(httpWriter http.ResponseWriter, httpRequest *http.Request) (*Request, *Response) {
0000000000000000000000000000000000000000;;		resp := NewResponse(httpWriter)
0000000000000000000000000000000000000000;;		resp.requestAccept = httpRequest.Header.Get(HEADER_Accept)
0000000000000000000000000000000000000000;;		return NewRequest(httpRequest), resp
0000000000000000000000000000000000000000;;	}
