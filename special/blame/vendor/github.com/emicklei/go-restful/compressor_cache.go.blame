0000000000000000000000000000000000000000;;	package restful
99a62e6cc8d0504a0cf8f4ed1837e136da744673;Godeps/_workspace/src/github.com/emicklei/go-restful/compressor_cache.go[Godeps/_workspace/src/github.com/emicklei/go-restful/compressor_cache.go][vendor/github.com/emicklei/go-restful/compressor_cache.go];	
0000000000000000000000000000000000000000;;	// Copyright 2015 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"compress/zlib"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoundedCachedCompressors is a CompressorProvider that uses a cache with a fixed amount
0000000000000000000000000000000000000000;;	// of writers and readers (resources).
0000000000000000000000000000000000000000;;	// If a new resource is acquired and all are in use, it will return a new unmanaged resource.
0000000000000000000000000000000000000000;;	type BoundedCachedCompressors struct {
0000000000000000000000000000000000000000;;		gzipWriters     chan *gzip.Writer
0000000000000000000000000000000000000000;;		gzipReaders     chan *gzip.Reader
0000000000000000000000000000000000000000;;		zlibWriters     chan *zlib.Writer
0000000000000000000000000000000000000000;;		writersCapacity int
0000000000000000000000000000000000000000;;		readersCapacity int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBoundedCachedCompressors returns a new, with filled cache,  BoundedCachedCompressors.
0000000000000000000000000000000000000000;;	func NewBoundedCachedCompressors(writersCapacity, readersCapacity int) *BoundedCachedCompressors {
0000000000000000000000000000000000000000;;		b := &BoundedCachedCompressors{
0000000000000000000000000000000000000000;;			gzipWriters:     make(chan *gzip.Writer, writersCapacity),
0000000000000000000000000000000000000000;;			gzipReaders:     make(chan *gzip.Reader, readersCapacity),
0000000000000000000000000000000000000000;;			zlibWriters:     make(chan *zlib.Writer, writersCapacity),
0000000000000000000000000000000000000000;;			writersCapacity: writersCapacity,
0000000000000000000000000000000000000000;;			readersCapacity: readersCapacity,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ix := 0; ix < writersCapacity; ix++ {
0000000000000000000000000000000000000000;;			b.gzipWriters <- newGzipWriter()
0000000000000000000000000000000000000000;;			b.zlibWriters <- newZlibWriter()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ix := 0; ix < readersCapacity; ix++ {
0000000000000000000000000000000000000000;;			b.gzipReaders <- newGzipReader()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AcquireGzipWriter returns an resettable *gzip.Writer. Needs to be released.
0000000000000000000000000000000000000000;;	func (b *BoundedCachedCompressors) AcquireGzipWriter() *gzip.Writer {
0000000000000000000000000000000000000000;;		var writer *gzip.Writer
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case writer, _ = <-b.gzipWriters:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// return a new unmanaged one
0000000000000000000000000000000000000000;;			writer = newGzipWriter()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseGzipWriter accepts a writer (does not have to be one that was cached)
0000000000000000000000000000000000000000;;	// only when the cache has room for it. It will ignore it otherwise.
0000000000000000000000000000000000000000;;	func (b *BoundedCachedCompressors) ReleaseGzipWriter(w *gzip.Writer) {
0000000000000000000000000000000000000000;;		// forget the unmanaged ones
0000000000000000000000000000000000000000;;		if len(b.gzipWriters) < b.writersCapacity {
0000000000000000000000000000000000000000;;			b.gzipWriters <- w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AcquireGzipReader returns a *gzip.Reader. Needs to be released.
0000000000000000000000000000000000000000;;	func (b *BoundedCachedCompressors) AcquireGzipReader() *gzip.Reader {
0000000000000000000000000000000000000000;;		var reader *gzip.Reader
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case reader, _ = <-b.gzipReaders:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// return a new unmanaged one
0000000000000000000000000000000000000000;;			reader = newGzipReader()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseGzipReader accepts a reader (does not have to be one that was cached)
0000000000000000000000000000000000000000;;	// only when the cache has room for it. It will ignore it otherwise.
0000000000000000000000000000000000000000;;	func (b *BoundedCachedCompressors) ReleaseGzipReader(r *gzip.Reader) {
0000000000000000000000000000000000000000;;		// forget the unmanaged ones
0000000000000000000000000000000000000000;;		if len(b.gzipReaders) < b.readersCapacity {
0000000000000000000000000000000000000000;;			b.gzipReaders <- r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AcquireZlibWriter returns an resettable *zlib.Writer. Needs to be released.
0000000000000000000000000000000000000000;;	func (b *BoundedCachedCompressors) AcquireZlibWriter() *zlib.Writer {
0000000000000000000000000000000000000000;;		var writer *zlib.Writer
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case writer, _ = <-b.zlibWriters:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// return a new unmanaged one
0000000000000000000000000000000000000000;;			writer = newZlibWriter()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseZlibWriter accepts a writer (does not have to be one that was cached)
0000000000000000000000000000000000000000;;	// only when the cache has room for it. It will ignore it otherwise.
0000000000000000000000000000000000000000;;	func (b *BoundedCachedCompressors) ReleaseZlibWriter(w *zlib.Writer) {
0000000000000000000000000000000000000000;;		// forget the unmanaged ones
0000000000000000000000000000000000000000;;		if len(b.zlibWriters) < b.writersCapacity {
0000000000000000000000000000000000000000;;			b.zlibWriters <- w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
