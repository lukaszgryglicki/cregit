0000000000000000000000000000000000000000;;	package restful
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/path_expression.go[Godeps/_workspace/src/github.com/emicklei/go-restful/path_expression.go][vendor/github.com/emicklei/go-restful/path_expression.go];	
0000000000000000000000000000000000000000;;	// Copyright 2013 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathExpression holds a compiled path expression (RegExp) needed to match against
0000000000000000000000000000000000000000;;	// Http request paths and to extract path parameter values.
0000000000000000000000000000000000000000;;	type pathExpression struct {
0000000000000000000000000000000000000000;;		LiteralCount int // the number of literal characters (means those not resulting from template variable substitution)
0000000000000000000000000000000000000000;;		VarCount     int // the number of named parameters (enclosed by {}) in the path
0000000000000000000000000000000000000000;;		Matcher      *regexp.Regexp
0000000000000000000000000000000000000000;;		Source       string // Path as defined by the RouteBuilder
0000000000000000000000000000000000000000;;		tokens       []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPathExpression creates a PathExpression from the input URL path.
0000000000000000000000000000000000000000;;	// Returns an error if the path is invalid.
0000000000000000000000000000000000000000;;	func newPathExpression(path string) (*pathExpression, error) {
0000000000000000000000000000000000000000;;		expression, literalCount, varCount, tokens := templateToRegularExpression(path)
0000000000000000000000000000000000000000;;		compiled, err := regexp.Compile(expression)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &pathExpression{literalCount, varCount, compiled, expression, tokens}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-370003.7.3
0000000000000000000000000000000000000000;;	func templateToRegularExpression(template string) (expression string, literalCount int, varCount int, tokens []string) {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		buffer.WriteString("^")
0000000000000000000000000000000000000000;;		//tokens = strings.Split(template, "/")
0000000000000000000000000000000000000000;;		tokens = tokenizePath(template)
0000000000000000000000000000000000000000;;		for _, each := range tokens {
0000000000000000000000000000000000000000;;			if each == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.WriteString("/")
0000000000000000000000000000000000000000;;			if strings.HasPrefix(each, "{") {
0000000000000000000000000000000000000000;;				// check for regular expression in variable
0000000000000000000000000000000000000000;;				colon := strings.Index(each, ":")
0000000000000000000000000000000000000000;;				if colon != -1 {
0000000000000000000000000000000000000000;;					// extract expression
0000000000000000000000000000000000000000;;					paramExpr := strings.TrimSpace(each[colon+1 : len(each)-1])
0000000000000000000000000000000000000000;;					if paramExpr == "*" { // special case
0000000000000000000000000000000000000000;;						buffer.WriteString("(.*)")
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						buffer.WriteString(fmt.Sprintf("(%s)", paramExpr)) // between colon and closing moustache
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// plain var
0000000000000000000000000000000000000000;;					buffer.WriteString("([^/]+?)")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				varCount += 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				literalCount += len(each)
0000000000000000000000000000000000000000;;				encoded := each // TODO URI encode
0000000000000000000000000000000000000000;;				buffer.WriteString(regexp.QuoteMeta(encoded))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimRight(buffer.String(), "/") + "(/.*)?$", literalCount, varCount, tokens
0000000000000000000000000000000000000000;;	}
