0000000000000000000000000000000000000000;;	package restful
99a62e6cc8d0504a0cf8f4ed1837e136da744673;Godeps/_workspace/src/github.com/emicklei/go-restful/entity_accessors.go[Godeps/_workspace/src/github.com/emicklei/go-restful/entity_accessors.go][vendor/github.com/emicklei/go-restful/entity_accessors.go];	
0000000000000000000000000000000000000000;;	// Copyright 2015 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EntityReaderWriter can read and write values using an encoding such as JSON,XML.
0000000000000000000000000000000000000000;;	type EntityReaderWriter interface {
0000000000000000000000000000000000000000;;		// Read a serialized version of the value from the request.
0000000000000000000000000000000000000000;;		// The Request may have a decompressing reader. Depends on Content-Encoding.
0000000000000000000000000000000000000000;;		Read(req *Request, v interface{}) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write a serialized version of the value on the response.
0000000000000000000000000000000000000000;;		// The Response may have a compressing writer. Depends on Accept-Encoding.
0000000000000000000000000000000000000000;;		// status should be a valid Http Status code
0000000000000000000000000000000000000000;;		Write(resp *Response, status int, v interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// entityAccessRegistry is a singleton
0000000000000000000000000000000000000000;;	var entityAccessRegistry = &entityReaderWriters{
0000000000000000000000000000000000000000;;		protection: new(sync.RWMutex),
0000000000000000000000000000000000000000;;		accessors:  map[string]EntityReaderWriter{},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// entityReaderWriters associates MIME to an EntityReaderWriter
0000000000000000000000000000000000000000;;	type entityReaderWriters struct {
0000000000000000000000000000000000000000;;		protection *sync.RWMutex
0000000000000000000000000000000000000000;;		accessors  map[string]EntityReaderWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		RegisterEntityAccessor(MIME_JSON, NewEntityAccessorJSON(MIME_JSON))
0000000000000000000000000000000000000000;;		RegisterEntityAccessor(MIME_XML, NewEntityAccessorXML(MIME_XML))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterEntityAccessor add/overrides the ReaderWriter for encoding content with this MIME type.
0000000000000000000000000000000000000000;;	func RegisterEntityAccessor(mime string, erw EntityReaderWriter) {
0000000000000000000000000000000000000000;;		entityAccessRegistry.protection.Lock()
0000000000000000000000000000000000000000;;		defer entityAccessRegistry.protection.Unlock()
0000000000000000000000000000000000000000;;		entityAccessRegistry.accessors[mime] = erw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEntityAccessorJSON returns a new EntityReaderWriter for accessing JSON content.
0000000000000000000000000000000000000000;;	// This package is already initialized with such an accessor using the MIME_JSON contentType.
0000000000000000000000000000000000000000;;	func NewEntityAccessorJSON(contentType string) EntityReaderWriter {
0000000000000000000000000000000000000000;;		return entityJSONAccess{ContentType: contentType}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEntityAccessorXML returns a new EntityReaderWriter for accessing XML content.
0000000000000000000000000000000000000000;;	// This package is already initialized with such an accessor using the MIME_XML contentType.
0000000000000000000000000000000000000000;;	func NewEntityAccessorXML(contentType string) EntityReaderWriter {
0000000000000000000000000000000000000000;;		return entityXMLAccess{ContentType: contentType}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// accessorAt returns the registered ReaderWriter for this MIME type.
0000000000000000000000000000000000000000;;	func (r *entityReaderWriters) accessorAt(mime string) (EntityReaderWriter, bool) {
0000000000000000000000000000000000000000;;		r.protection.RLock()
0000000000000000000000000000000000000000;;		defer r.protection.RUnlock()
0000000000000000000000000000000000000000;;		er, ok := r.accessors[mime]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// retry with reverse lookup
0000000000000000000000000000000000000000;;			// more expensive but we are in an exceptional situation anyway
0000000000000000000000000000000000000000;;			for k, v := range r.accessors {
0000000000000000000000000000000000000000;;				if strings.Contains(mime, k) {
0000000000000000000000000000000000000000;;					return v, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return er, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// entityXMLAccess is a EntityReaderWriter for XML encoding
0000000000000000000000000000000000000000;;	type entityXMLAccess struct {
0000000000000000000000000000000000000000;;		// This is used for setting the Content-Type header when writing
0000000000000000000000000000000000000000;;		ContentType string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read unmarshalls the value from XML
0000000000000000000000000000000000000000;;	func (e entityXMLAccess) Read(req *Request, v interface{}) error {
0000000000000000000000000000000000000000;;		return xml.NewDecoder(req.Request.Body).Decode(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write marshalls the value to JSON and set the Content-Type Header.
0000000000000000000000000000000000000000;;	func (e entityXMLAccess) Write(resp *Response, status int, v interface{}) error {
0000000000000000000000000000000000000000;;		return writeXML(resp, status, e.ContentType, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeXML marshalls the value to JSON and set the Content-Type Header.
0000000000000000000000000000000000000000;;	func writeXML(resp *Response, status int, contentType string, v interface{}) error {
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			resp.WriteHeader(status)
0000000000000000000000000000000000000000;;			// do not write a nil representation
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.prettyPrint {
0000000000000000000000000000000000000000;;			// pretty output must be created and written explicitly
0000000000000000000000000000000000000000;;			output, err := xml.MarshalIndent(v, " ", " ")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp.Header().Set(HEADER_ContentType, contentType)
0000000000000000000000000000000000000000;;			resp.WriteHeader(status)
0000000000000000000000000000000000000000;;			_, err = resp.Write([]byte(xml.Header))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = resp.Write(output)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// not-so-pretty
0000000000000000000000000000000000000000;;		resp.Header().Set(HEADER_ContentType, contentType)
0000000000000000000000000000000000000000;;		resp.WriteHeader(status)
0000000000000000000000000000000000000000;;		return xml.NewEncoder(resp).Encode(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// entityJSONAccess is a EntityReaderWriter for JSON encoding
0000000000000000000000000000000000000000;;	type entityJSONAccess struct {
0000000000000000000000000000000000000000;;		// This is used for setting the Content-Type header when writing
0000000000000000000000000000000000000000;;		ContentType string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read unmarshalls the value from JSON
0000000000000000000000000000000000000000;;	func (e entityJSONAccess) Read(req *Request, v interface{}) error {
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(req.Request.Body)
0000000000000000000000000000000000000000;;		decoder.UseNumber()
0000000000000000000000000000000000000000;;		return decoder.Decode(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write marshalls the value to JSON and set the Content-Type Header.
0000000000000000000000000000000000000000;;	func (e entityJSONAccess) Write(resp *Response, status int, v interface{}) error {
0000000000000000000000000000000000000000;;		return writeJSON(resp, status, e.ContentType, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write marshalls the value to JSON and set the Content-Type Header.
0000000000000000000000000000000000000000;;	func writeJSON(resp *Response, status int, contentType string, v interface{}) error {
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			resp.WriteHeader(status)
0000000000000000000000000000000000000000;;			// do not write a nil representation
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.prettyPrint {
0000000000000000000000000000000000000000;;			// pretty output must be created and written explicitly
0000000000000000000000000000000000000000;;			output, err := json.MarshalIndent(v, " ", " ")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp.Header().Set(HEADER_ContentType, contentType)
0000000000000000000000000000000000000000;;			resp.WriteHeader(status)
0000000000000000000000000000000000000000;;			_, err = resp.Write(output)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// not-so-pretty
0000000000000000000000000000000000000000;;		resp.Header().Set(HEADER_ContentType, contentType)
0000000000000000000000000000000000000000;;		resp.WriteHeader(status)
0000000000000000000000000000000000000000;;		return json.NewEncoder(resp).Encode(v)
0000000000000000000000000000000000000000;;	}
