0000000000000000000000000000000000000000;;	package restful
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/response.go[Godeps/_workspace/src/github.com/emicklei/go-restful/response.go][vendor/github.com/emicklei/go-restful/response.go];	
0000000000000000000000000000000000000000;;	// Copyright 2013 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultResponseMimeType is DEPRECATED, use DefaultResponseContentType(mime)
0000000000000000000000000000000000000000;;	var DefaultResponseMimeType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//PrettyPrintResponses controls the indentation feature of XML and JSON serialization
0000000000000000000000000000000000000000;;	var PrettyPrintResponses = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Response is a wrapper on the actual http ResponseWriter
0000000000000000000000000000000000000000;;	// It provides several convenience methods to prepare and write response content.
0000000000000000000000000000000000000000;;	type Response struct {
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;		requestAccept string   // mime-type what the Http Request says it wants to receive
0000000000000000000000000000000000000000;;		routeProduces []string // mime-types what the Route says it can produce
0000000000000000000000000000000000000000;;		statusCode    int      // HTTP status code that has been written explicity (if zero then net/http has written 200)
0000000000000000000000000000000000000000;;		contentLength int      // number of bytes written for the response body
0000000000000000000000000000000000000000;;		prettyPrint   bool     // controls the indentation feature of XML and JSON serialization. It is initialized using var PrettyPrintResponses.
0000000000000000000000000000000000000000;;		err           error    // err property is kept when WriteError is called
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewResponse creates a new response based on a http ResponseWriter.
0000000000000000000000000000000000000000;;	func NewResponse(httpWriter http.ResponseWriter) *Response {
0000000000000000000000000000000000000000;;		return &Response{httpWriter, "", []string{}, http.StatusOK, 0, PrettyPrintResponses, nil} // empty content-types
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultResponseContentType set a default.
0000000000000000000000000000000000000000;;	// If Accept header matching fails, fall back to this type.
0000000000000000000000000000000000000000;;	// Valid values are restful.MIME_JSON and restful.MIME_XML
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	// 	restful.DefaultResponseContentType(restful.MIME_JSON)
0000000000000000000000000000000000000000;;	func DefaultResponseContentType(mime string) {
0000000000000000000000000000000000000000;;		DefaultResponseMimeType = mime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalServerError writes the StatusInternalServerError header.
0000000000000000000000000000000000000000;;	// DEPRECATED, use WriteErrorString(http.StatusInternalServerError,reason)
0000000000000000000000000000000000000000;;	func (r Response) InternalServerError() Response {
0000000000000000000000000000000000000000;;		r.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrettyPrint changes whether this response must produce pretty (line-by-line, indented) JSON or XML output.
0000000000000000000000000000000000000000;;	func (r *Response) PrettyPrint(bePretty bool) {
0000000000000000000000000000000000000000;;		r.prettyPrint = bePretty
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddHeader is a shortcut for .Header().Add(header,value)
0000000000000000000000000000000000000000;;	func (r Response) AddHeader(header string, value string) Response {
0000000000000000000000000000000000000000;;		r.Header().Add(header, value)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetRequestAccepts tells the response what Mime-type(s) the HTTP request said it wants to accept. Exposed for testing.
0000000000000000000000000000000000000000;;	func (r *Response) SetRequestAccepts(mime string) {
0000000000000000000000000000000000000000;;		r.requestAccept = mime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EntityWriter returns the registered EntityWriter that the entity (requested resource)
0000000000000000000000000000000000000000;;	// can write according to what the request wants (Accept) and what the Route can produce or what the restful defaults say.
0000000000000000000000000000000000000000;;	// If called before WriteEntity and WriteHeader then a false return value can be used to write a 406: Not Acceptable.
0000000000000000000000000000000000000000;;	func (r *Response) EntityWriter() (EntityReaderWriter, bool) {
0000000000000000000000000000000000000000;;		sorted := sortedMimes(r.requestAccept)
0000000000000000000000000000000000000000;;		for _, eachAccept := range sorted {
0000000000000000000000000000000000000000;;			for _, eachProduce := range r.routeProduces {
0000000000000000000000000000000000000000;;				if eachProduce == eachAccept.media {
0000000000000000000000000000000000000000;;					if w, ok := entityAccessRegistry.accessorAt(eachAccept.media); ok {
0000000000000000000000000000000000000000;;						return w, true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if eachAccept.media == "*/*" {
0000000000000000000000000000000000000000;;				for _, each := range r.routeProduces {
0000000000000000000000000000000000000000;;					if w, ok := entityAccessRegistry.accessorAt(each); ok {
0000000000000000000000000000000000000000;;						return w, true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if requestAccept is empty
0000000000000000000000000000000000000000;;		writer, ok := entityAccessRegistry.accessorAt(r.requestAccept)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// if not registered then fallback to the defaults (if set)
0000000000000000000000000000000000000000;;			if DefaultResponseMimeType == MIME_JSON {
0000000000000000000000000000000000000000;;				return entityAccessRegistry.accessorAt(MIME_JSON)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if DefaultResponseMimeType == MIME_XML {
0000000000000000000000000000000000000000;;				return entityAccessRegistry.accessorAt(MIME_XML)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Fallback to whatever the route says it can produce.
0000000000000000000000000000000000000000;;			// https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
0000000000000000000000000000000000000000;;			for _, each := range r.routeProduces {
0000000000000000000000000000000000000000;;				if w, ok := entityAccessRegistry.accessorAt(each); ok {
0000000000000000000000000000000000000000;;					return w, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("no registered EntityReaderWriter found for %s", r.requestAccept)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return writer, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteEntity calls WriteHeaderAndEntity with Http Status OK (200)
0000000000000000000000000000000000000000;;	func (r *Response) WriteEntity(value interface{}) error {
0000000000000000000000000000000000000000;;		return r.WriteHeaderAndEntity(http.StatusOK, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeaderAndEntity marshals the value using the representation denoted by the Accept Header and the registered EntityWriters.
0000000000000000000000000000000000000000;;	// If no Accept header is specified (or */*) then respond with the Content-Type as specified by the first in the Route.Produces.
0000000000000000000000000000000000000000;;	// If an Accept header is specified then respond with the Content-Type as specified by the first in the Route.Produces that is matched with the Accept header.
0000000000000000000000000000000000000000;;	// If the value is nil then no response is send except for the Http status. You may want to call WriteHeader(http.StatusNotFound) instead.
0000000000000000000000000000000000000000;;	// If there is no writer available that can represent the value in the requested MIME type then Http Status NotAcceptable is written.
0000000000000000000000000000000000000000;;	// Current implementation ignores any q-parameters in the Accept Header.
0000000000000000000000000000000000000000;;	// Returns an error if the value could not be written on the response.
0000000000000000000000000000000000000000;;	func (r *Response) WriteHeaderAndEntity(status int, value interface{}) error {
0000000000000000000000000000000000000000;;		writer, ok := r.EntityWriter()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			r.WriteHeader(http.StatusNotAcceptable)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return writer.Write(r, status, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteAsXml is a convenience method for writing a value in xml (requires Xml tags on the value)
0000000000000000000000000000000000000000;;	// It uses the standard encoding/xml package for marshalling the value ; not using a registered EntityReaderWriter.
0000000000000000000000000000000000000000;;	func (r *Response) WriteAsXml(value interface{}) error {
0000000000000000000000000000000000000000;;		return writeXML(r, http.StatusOK, MIME_XML, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeaderAndXml is a convenience method for writing a status and value in xml (requires Xml tags on the value)
0000000000000000000000000000000000000000;;	// It uses the standard encoding/xml package for marshalling the value ; not using a registered EntityReaderWriter.
0000000000000000000000000000000000000000;;	func (r *Response) WriteHeaderAndXml(status int, value interface{}) error {
0000000000000000000000000000000000000000;;		return writeXML(r, status, MIME_XML, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteAsJson is a convenience method for writing a value in json.
0000000000000000000000000000000000000000;;	// It uses the standard encoding/json package for marshalling the value ; not using a registered EntityReaderWriter.
0000000000000000000000000000000000000000;;	func (r *Response) WriteAsJson(value interface{}) error {
0000000000000000000000000000000000000000;;		return writeJSON(r, http.StatusOK, MIME_JSON, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteJson is a convenience method for writing a value in Json with a given Content-Type.
0000000000000000000000000000000000000000;;	// It uses the standard encoding/json package for marshalling the value ; not using a registered EntityReaderWriter.
0000000000000000000000000000000000000000;;	func (r *Response) WriteJson(value interface{}, contentType string) error {
0000000000000000000000000000000000000000;;		return writeJSON(r, http.StatusOK, contentType, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeaderAndJson is a convenience method for writing the status and a value in Json with a given Content-Type.
0000000000000000000000000000000000000000;;	// It uses the standard encoding/json package for marshalling the value ; not using a registered EntityReaderWriter.
0000000000000000000000000000000000000000;;	func (r *Response) WriteHeaderAndJson(status int, value interface{}, contentType string) error {
0000000000000000000000000000000000000000;;		return writeJSON(r, status, contentType, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteError write the http status and the error string on the response.
0000000000000000000000000000000000000000;;	func (r *Response) WriteError(httpStatus int, err error) error {
0000000000000000000000000000000000000000;;		r.err = err
0000000000000000000000000000000000000000;;		return r.WriteErrorString(httpStatus, err.Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteServiceError is a convenience method for a responding with a status and a ServiceError
0000000000000000000000000000000000000000;;	func (r *Response) WriteServiceError(httpStatus int, err ServiceError) error {
0000000000000000000000000000000000000000;;		r.err = err
0000000000000000000000000000000000000000;;		return r.WriteHeaderAndEntity(httpStatus, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteErrorString is a convenience method for an error status with the actual error
0000000000000000000000000000000000000000;;	func (r *Response) WriteErrorString(httpStatus int, errorReason string) error {
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			// if not called from WriteError
0000000000000000000000000000000000000000;;			r.err = errors.New(errorReason)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.WriteHeader(httpStatus)
0000000000000000000000000000000000000000;;		if _, err := r.Write([]byte(errorReason)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flush implements http.Flusher interface, which sends any buffered data to the client.
0000000000000000000000000000000000000000;;	func (r *Response) Flush() {
0000000000000000000000000000000000000000;;		if f, ok := r.ResponseWriter.(http.Flusher); ok {
0000000000000000000000000000000000000000;;			f.Flush()
0000000000000000000000000000000000000000;;		} else if trace {
0000000000000000000000000000000000000000;;			traceLogger.Printf("ResponseWriter %v doesn't support Flush", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeader is overridden to remember the Status Code that has been written.
0000000000000000000000000000000000000000;;	// Changes to the Header of the response have no effect after this.
0000000000000000000000000000000000000000;;	func (r *Response) WriteHeader(httpStatus int) {
0000000000000000000000000000000000000000;;		r.statusCode = httpStatus
0000000000000000000000000000000000000000;;		r.ResponseWriter.WriteHeader(httpStatus)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusCode returns the code that has been written using WriteHeader.
0000000000000000000000000000000000000000;;	func (r Response) StatusCode() int {
0000000000000000000000000000000000000000;;		if 0 == r.statusCode {
0000000000000000000000000000000000000000;;			// no status code has been written yet; assume OK
0000000000000000000000000000000000000000;;			return http.StatusOK
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.statusCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes the data to the connection as part of an HTTP reply.
0000000000000000000000000000000000000000;;	// Write is part of http.ResponseWriter interface.
0000000000000000000000000000000000000000;;	func (r *Response) Write(bytes []byte) (int, error) {
0000000000000000000000000000000000000000;;		written, err := r.ResponseWriter.Write(bytes)
0000000000000000000000000000000000000000;;		r.contentLength += written
0000000000000000000000000000000000000000;;		return written, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContentLength returns the number of bytes written for the response content.
0000000000000000000000000000000000000000;;	// Note that this value is only correct if all data is written through the Response using its Write* methods.
0000000000000000000000000000000000000000;;	// Data written directly using the underlying http.ResponseWriter is not accounted for.
0000000000000000000000000000000000000000;;	func (r Response) ContentLength() int {
0000000000000000000000000000000000000000;;		return r.contentLength
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseNotify is part of http.CloseNotifier interface
0000000000000000000000000000000000000000;;	func (r Response) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return r.ResponseWriter.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the err created by WriteError
0000000000000000000000000000000000000000;;	func (r Response) Error() error {
0000000000000000000000000000000000000000;;		return r.err
0000000000000000000000000000000000000000;;	}
