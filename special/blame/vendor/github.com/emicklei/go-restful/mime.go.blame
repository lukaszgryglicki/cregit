0000000000000000000000000000000000000000;;	package restful
c4045d8ac02856df7b432a5cd36ef363f91ffd14;Godeps/_workspace/src/github.com/emicklei/go-restful/mime.go[Godeps/_workspace/src/github.com/emicklei/go-restful/mime.go][vendor/github.com/emicklei/go-restful/mime.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mime struct {
0000000000000000000000000000000000000000;;		media   string
0000000000000000000000000000000000000000;;		quality float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertMime adds a mime to a list and keeps it sorted by quality.
0000000000000000000000000000000000000000;;	func insertMime(l []mime, e mime) []mime {
0000000000000000000000000000000000000000;;		for i, each := range l {
0000000000000000000000000000000000000000;;			// if current mime has lower quality then insert before
0000000000000000000000000000000000000000;;			if e.quality > each.quality {
0000000000000000000000000000000000000000;;				left := append([]mime{}, l[0:i]...)
0000000000000000000000000000000000000000;;				return append(append(left, e), l[i:]...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(l, e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sortedMimes returns a list of mime sorted (desc) by its specified quality.
0000000000000000000000000000000000000000;;	func sortedMimes(accept string) (sorted []mime) {
0000000000000000000000000000000000000000;;		for _, each := range strings.Split(accept, ",") {
0000000000000000000000000000000000000000;;			typeAndQuality := strings.Split(strings.Trim(each, " "), ";")
0000000000000000000000000000000000000000;;			if len(typeAndQuality) == 1 {
0000000000000000000000000000000000000000;;				sorted = insertMime(sorted, mime{typeAndQuality[0], 1.0})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// take factor
0000000000000000000000000000000000000000;;				parts := strings.Split(typeAndQuality[1], "=")
0000000000000000000000000000000000000000;;				if len(parts) == 2 {
0000000000000000000000000000000000000000;;					f, err := strconv.ParseFloat(parts[1], 64)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						traceLogger.Printf("unable to parse quality in %s, %v", each, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						sorted = insertMime(sorted, mime{typeAndQuality[0], f})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
