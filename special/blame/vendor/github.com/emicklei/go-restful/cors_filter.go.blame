0000000000000000000000000000000000000000;;	package restful
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/cors_filter.go[Godeps/_workspace/src/github.com/emicklei/go-restful/cors_filter.go][vendor/github.com/emicklei/go-restful/cors_filter.go];	
0000000000000000000000000000000000000000;;	// Copyright 2013 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CrossOriginResourceSharing is used to create a Container Filter that implements CORS.
0000000000000000000000000000000000000000;;	// Cross-origin resource sharing (CORS) is a mechanism that allows JavaScript on a web page
0000000000000000000000000000000000000000;;	// to make XMLHttpRequests to another domain, not the domain the JavaScript originated from.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://en.wikipedia.org/wiki/Cross-origin_resource_sharing
0000000000000000000000000000000000000000;;	// http://enable-cors.org/server.html
0000000000000000000000000000000000000000;;	// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request
0000000000000000000000000000000000000000;;	type CrossOriginResourceSharing struct {
0000000000000000000000000000000000000000;;		ExposeHeaders  []string // list of Header names
0000000000000000000000000000000000000000;;		AllowedHeaders []string // list of Header names
0000000000000000000000000000000000000000;;		AllowedDomains []string // list of allowed values for Http Origin. An allowed value can be a regular expression to support subdomain matching. If empty all are allowed.
0000000000000000000000000000000000000000;;		AllowedMethods []string
0000000000000000000000000000000000000000;;		MaxAge         int // number of seconds before requiring new Options request
0000000000000000000000000000000000000000;;		CookiesAllowed bool
0000000000000000000000000000000000000000;;		Container      *Container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowedOriginPatterns []*regexp.Regexp // internal field for origin regexp check.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter is a filter function that implements the CORS flow as documented on http://enable-cors.org/server.html
0000000000000000000000000000000000000000;;	// and http://www.html5rocks.com/static/images/cors_server_flowchart.png
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) Filter(req *Request, resp *Response, chain *FilterChain) {
0000000000000000000000000000000000000000;;		origin := req.Request.Header.Get(HEADER_Origin)
0000000000000000000000000000000000000000;;		if len(origin) == 0 {
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Print("no Http header Origin set")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chain.ProcessFilter(req, resp)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !c.isOriginAllowed(origin) { // check whether this origin is allowed
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("HTTP Origin:%s is not part of %v, neither matches any part of %v", origin, c.AllowedDomains, c.allowedOriginPatterns)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chain.ProcessFilter(req, resp)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.Request.Method != "OPTIONS" {
0000000000000000000000000000000000000000;;			c.doActualRequest(req, resp)
0000000000000000000000000000000000000000;;			chain.ProcessFilter(req, resp)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod); acrm != "" {
0000000000000000000000000000000000000000;;			c.doPreflightRequest(req, resp)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.doActualRequest(req, resp)
0000000000000000000000000000000000000000;;			chain.ProcessFilter(req, resp)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) doActualRequest(req *Request, resp *Response) {
0000000000000000000000000000000000000000;;		c.setOptionsHeaders(req, resp)
0000000000000000000000000000000000000000;;		// continue processing the response
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CrossOriginResourceSharing) doPreflightRequest(req *Request, resp *Response) {
0000000000000000000000000000000000000000;;		if len(c.AllowedMethods) == 0 {
0000000000000000000000000000000000000000;;			if c.Container == nil {
0000000000000000000000000000000000000000;;				c.AllowedMethods = DefaultContainer.computeAllowedMethods(req)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c.AllowedMethods = c.Container.computeAllowedMethods(req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod)
0000000000000000000000000000000000000000;;		if !c.isValidAccessControlRequestMethod(acrm, c.AllowedMethods) {
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("Http header %s:%s is not in %v",
0000000000000000000000000000000000000000;;					HEADER_AccessControlRequestMethod,
0000000000000000000000000000000000000000;;					acrm,
0000000000000000000000000000000000000000;;					c.AllowedMethods)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		acrhs := req.Request.Header.Get(HEADER_AccessControlRequestHeaders)
0000000000000000000000000000000000000000;;		if len(acrhs) > 0 {
0000000000000000000000000000000000000000;;			for _, each := range strings.Split(acrhs, ",") {
0000000000000000000000000000000000000000;;				if !c.isValidAccessControlRequestHeader(strings.Trim(each, " ")) {
0000000000000000000000000000000000000000;;					if trace {
0000000000000000000000000000000000000000;;						traceLogger.Printf("Http header %s:%s is not in %v",
0000000000000000000000000000000000000000;;							HEADER_AccessControlRequestHeaders,
0000000000000000000000000000000000000000;;							acrhs,
0000000000000000000000000000000000000000;;							c.AllowedHeaders)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.AddHeader(HEADER_AccessControlAllowMethods, strings.Join(c.AllowedMethods, ","))
0000000000000000000000000000000000000000;;		resp.AddHeader(HEADER_AccessControlAllowHeaders, acrhs)
0000000000000000000000000000000000000000;;		c.setOptionsHeaders(req, resp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return http 200 response, no body
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) setOptionsHeaders(req *Request, resp *Response) {
0000000000000000000000000000000000000000;;		c.checkAndSetExposeHeaders(resp)
0000000000000000000000000000000000000000;;		c.setAllowOriginHeader(req, resp)
0000000000000000000000000000000000000000;;		c.checkAndSetAllowCredentials(resp)
0000000000000000000000000000000000000000;;		if c.MaxAge > 0 {
0000000000000000000000000000000000000000;;			resp.AddHeader(HEADER_AccessControlMaxAge, strconv.Itoa(c.MaxAge))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) isOriginAllowed(origin string) bool {
0000000000000000000000000000000000000000;;		if len(origin) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.AllowedDomains) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allowed := false
0000000000000000000000000000000000000000;;		for _, domain := range c.AllowedDomains {
0000000000000000000000000000000000000000;;			if domain == origin {
0000000000000000000000000000000000000000;;				allowed = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !allowed {
0000000000000000000000000000000000000000;;			if len(c.allowedOriginPatterns) == 0 {
0000000000000000000000000000000000000000;;				// compile allowed domains to allowed origin patterns
0000000000000000000000000000000000000000;;				allowedOriginRegexps, err := compileRegexps(c.AllowedDomains)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.allowedOriginPatterns = allowedOriginRegexps
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, pattern := range c.allowedOriginPatterns {
0000000000000000000000000000000000000000;;				if allowed = pattern.MatchString(origin); allowed {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allowed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) setAllowOriginHeader(req *Request, resp *Response) {
0000000000000000000000000000000000000000;;		origin := req.Request.Header.Get(HEADER_Origin)
0000000000000000000000000000000000000000;;		if c.isOriginAllowed(origin) {
0000000000000000000000000000000000000000;;			resp.AddHeader(HEADER_AccessControlAllowOrigin, origin)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) checkAndSetExposeHeaders(resp *Response) {
0000000000000000000000000000000000000000;;		if len(c.ExposeHeaders) > 0 {
0000000000000000000000000000000000000000;;			resp.AddHeader(HEADER_AccessControlExposeHeaders, strings.Join(c.ExposeHeaders, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) checkAndSetAllowCredentials(resp *Response) {
0000000000000000000000000000000000000000;;		if c.CookiesAllowed {
0000000000000000000000000000000000000000;;			resp.AddHeader(HEADER_AccessControlAllowCredentials, "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) isValidAccessControlRequestMethod(method string, allowedMethods []string) bool {
0000000000000000000000000000000000000000;;		for _, each := range allowedMethods {
0000000000000000000000000000000000000000;;			if each == method {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header string) bool {
0000000000000000000000000000000000000000;;		for _, each := range c.AllowedHeaders {
0000000000000000000000000000000000000000;;			if strings.ToLower(each) == strings.ToLower(header) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Take a list of strings and compile them into a list of regular expressions.
0000000000000000000000000000000000000000;;	func compileRegexps(regexpStrings []string) ([]*regexp.Regexp, error) {
0000000000000000000000000000000000000000;;		regexps := []*regexp.Regexp{}
0000000000000000000000000000000000000000;;		for _, regexpStr := range regexpStrings {
0000000000000000000000000000000000000000;;			r, err := regexp.Compile(regexpStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return regexps, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			regexps = append(regexps, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return regexps, nil
0000000000000000000000000000000000000000;;	}
