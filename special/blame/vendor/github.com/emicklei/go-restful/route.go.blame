0000000000000000000000000000000000000000;;	package restful
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/route.go[Godeps/_workspace/src/github.com/emicklei/go-restful/route.go][vendor/github.com/emicklei/go-restful/route.go];	
0000000000000000000000000000000000000000;;	// Copyright 2013 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RouteFunction declares the signature of a function that can be bound to a Route.
0000000000000000000000000000000000000000;;	type RouteFunction func(*Request, *Response)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Route binds a HTTP Method,Path,Consumes combination to a RouteFunction.
0000000000000000000000000000000000000000;;	type Route struct {
0000000000000000000000000000000000000000;;		Method   string
0000000000000000000000000000000000000000;;		Produces []string
0000000000000000000000000000000000000000;;		Consumes []string
0000000000000000000000000000000000000000;;		Path     string // webservice root path + described path
0000000000000000000000000000000000000000;;		Function RouteFunction
0000000000000000000000000000000000000000;;		Filters  []FilterFunction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cached values for dispatching
0000000000000000000000000000000000000000;;		relativePath string
0000000000000000000000000000000000000000;;		pathParts    []string
0000000000000000000000000000000000000000;;		pathExpr     *pathExpression // cached compilation of relativePath as RegExp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// documentation
0000000000000000000000000000000000000000;;		Doc                     string
0000000000000000000000000000000000000000;;		Notes                   string
0000000000000000000000000000000000000000;;		Operation               string
0000000000000000000000000000000000000000;;		ParameterDocs           []*Parameter
0000000000000000000000000000000000000000;;		ResponseErrors          map[int]ResponseError
0000000000000000000000000000000000000000;;		ReadSample, WriteSample interface{} // structs that model an example request or response payload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extra information used to store custom information about the route.
0000000000000000000000000000000000000000;;		Metadata map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize for Route
0000000000000000000000000000000000000000;;	func (r *Route) postBuild() {
0000000000000000000000000000000000000000;;		r.pathParts = tokenizePath(r.Path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create Request and Response from their http versions
0000000000000000000000000000000000000000;;	func (r *Route) wrapRequestResponse(httpWriter http.ResponseWriter, httpRequest *http.Request) (*Request, *Response) {
0000000000000000000000000000000000000000;;		params := r.extractParameters(httpRequest.URL.Path)
0000000000000000000000000000000000000000;;		wrappedRequest := NewRequest(httpRequest)
0000000000000000000000000000000000000000;;		wrappedRequest.pathParameters = params
0000000000000000000000000000000000000000;;		wrappedRequest.selectedRoutePath = r.Path
0000000000000000000000000000000000000000;;		wrappedResponse := NewResponse(httpWriter)
0000000000000000000000000000000000000000;;		wrappedResponse.requestAccept = httpRequest.Header.Get(HEADER_Accept)
0000000000000000000000000000000000000000;;		wrappedResponse.routeProduces = r.Produces
0000000000000000000000000000000000000000;;		return wrappedRequest, wrappedResponse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dispatchWithFilters call the function after passing through its own filters
0000000000000000000000000000000000000000;;	func (r *Route) dispatchWithFilters(wrappedRequest *Request, wrappedResponse *Response) {
0000000000000000000000000000000000000000;;		if len(r.Filters) > 0 {
0000000000000000000000000000000000000000;;			chain := FilterChain{Filters: r.Filters, Target: r.Function}
0000000000000000000000000000000000000000;;			chain.ProcessFilter(wrappedRequest, wrappedResponse)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// unfiltered
0000000000000000000000000000000000000000;;			r.Function(wrappedRequest, wrappedResponse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return whether the mimeType matches to what this Route can produce.
0000000000000000000000000000000000000000;;	func (r Route) matchesAccept(mimeTypesWithQuality string) bool {
0000000000000000000000000000000000000000;;		parts := strings.Split(mimeTypesWithQuality, ",")
0000000000000000000000000000000000000000;;		for _, each := range parts {
0000000000000000000000000000000000000000;;			var withoutQuality string
0000000000000000000000000000000000000000;;			if strings.Contains(each, ";") {
0000000000000000000000000000000000000000;;				withoutQuality = strings.Split(each, ";")[0]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				withoutQuality = each
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// trim before compare
0000000000000000000000000000000000000000;;			withoutQuality = strings.Trim(withoutQuality, " ")
0000000000000000000000000000000000000000;;			if withoutQuality == "*/*" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, producibleType := range r.Produces {
0000000000000000000000000000000000000000;;				if producibleType == "*/*" || producibleType == withoutQuality {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return whether this Route can consume content with a type specified by mimeTypes (can be empty).
0000000000000000000000000000000000000000;;	func (r Route) matchesContentType(mimeTypes string) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(r.Consumes) == 0 {
0000000000000000000000000000000000000000;;			// did not specify what it can consume ;  any media type (“*/*”) is assumed
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(mimeTypes) == 0 {
0000000000000000000000000000000000000000;;			// idempotent methods with (most-likely or garanteed) empty content match missing Content-Type
0000000000000000000000000000000000000000;;			m := r.Method
0000000000000000000000000000000000000000;;			if m == "GET" || m == "HEAD" || m == "OPTIONS" || m == "DELETE" || m == "TRACE" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// proceed with default
0000000000000000000000000000000000000000;;			mimeTypes = MIME_OCTET
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := strings.Split(mimeTypes, ",")
0000000000000000000000000000000000000000;;		for _, each := range parts {
0000000000000000000000000000000000000000;;			var contentType string
0000000000000000000000000000000000000000;;			if strings.Contains(each, ";") {
0000000000000000000000000000000000000000;;				contentType = strings.Split(each, ";")[0]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				contentType = each
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// trim before compare
0000000000000000000000000000000000000000;;			contentType = strings.Trim(contentType, " ")
0000000000000000000000000000000000000000;;			for _, consumeableType := range r.Consumes {
0000000000000000000000000000000000000000;;				if consumeableType == "*/*" || consumeableType == contentType {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract the parameters from the request url path
0000000000000000000000000000000000000000;;	func (r Route) extractParameters(urlPath string) map[string]string {
0000000000000000000000000000000000000000;;		urlParts := tokenizePath(urlPath)
0000000000000000000000000000000000000000;;		pathParameters := map[string]string{}
0000000000000000000000000000000000000000;;		for i, key := range r.pathParts {
0000000000000000000000000000000000000000;;			var value string
0000000000000000000000000000000000000000;;			if i >= len(urlParts) {
0000000000000000000000000000000000000000;;				value = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value = urlParts[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(key, "{") { // path-parameter
0000000000000000000000000000000000000000;;				if colon := strings.Index(key, ":"); colon != -1 {
0000000000000000000000000000000000000000;;					// extract by regex
0000000000000000000000000000000000000000;;					regPart := key[colon+1 : len(key)-1]
0000000000000000000000000000000000000000;;					keyPart := key[1:colon]
0000000000000000000000000000000000000000;;					if regPart == "*" {
0000000000000000000000000000000000000000;;						pathParameters[keyPart] = untokenizePath(i, urlParts)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						pathParameters[keyPart] = value
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// without enclosing {}
0000000000000000000000000000000000000000;;					pathParameters[key[1:len(key)-1]] = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pathParameters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Untokenize back into an URL path using the slash separator
0000000000000000000000000000000000000000;;	func untokenizePath(offset int, parts []string) string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		for p := offset; p < len(parts); p++ {
0000000000000000000000000000000000000000;;			buffer.WriteString(parts[p])
0000000000000000000000000000000000000000;;			// do not end
0000000000000000000000000000000000000000;;			if p < len(parts)-1 {
0000000000000000000000000000000000000000;;				buffer.WriteString("/")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tokenize an URL path using the slash separator ; the result does not have empty tokens
0000000000000000000000000000000000000000;;	func tokenizePath(path string) []string {
0000000000000000000000000000000000000000;;		if "/" == path {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Split(strings.Trim(path, "/"), "/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// for debugging
0000000000000000000000000000000000000000;;	func (r Route) String() string {
0000000000000000000000000000000000000000;;		return r.Method + " " + r.Path
0000000000000000000000000000000000000000;;	}
