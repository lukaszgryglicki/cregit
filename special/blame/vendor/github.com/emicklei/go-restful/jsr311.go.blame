0000000000000000000000000000000000000000;;	package restful
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/jsr311.go[Godeps/_workspace/src/github.com/emicklei/go-restful/jsr311.go][vendor/github.com/emicklei/go-restful/jsr311.go];	
0000000000000000000000000000000000000000;;	// Copyright 2013 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RouterJSR311 implements the flow for matching Requests to Routes (and consequently Resource Functions)
0000000000000000000000000000000000000000;;	// as specified by the JSR311 http://jsr311.java.net/nonav/releases/1.1/spec/spec.html.
0000000000000000000000000000000000000000;;	// RouterJSR311 implements the Router interface.
0000000000000000000000000000000000000000;;	// Concept of locators is not implemented.
0000000000000000000000000000000000000000;;	type RouterJSR311 struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectRoute is part of the Router interface and returns the best match
0000000000000000000000000000000000000000;;	// for the WebService and its Route for the given Request.
0000000000000000000000000000000000000000;;	func (r RouterJSR311) SelectRoute(
0000000000000000000000000000000000000000;;		webServices []*WebService,
0000000000000000000000000000000000000000;;		httpRequest *http.Request) (selectedService *WebService, selectedRoute *Route, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Identify the root resource class (WebService)
0000000000000000000000000000000000000000;;		dispatcher, finalMatch, err := r.detectDispatcher(httpRequest.URL.Path, webServices)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, NewError(http.StatusNotFound, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Obtain the set of candidate methods (Routes)
0000000000000000000000000000000000000000;;		routes := r.selectRoutes(dispatcher, finalMatch)
0000000000000000000000000000000000000000;;		if len(routes) == 0 {
0000000000000000000000000000000000000000;;			return dispatcher, nil, NewError(http.StatusNotFound, "404: Page Not Found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Identify the method (Route) that will handle the request
0000000000000000000000000000000000000000;;		route, ok := r.detectRoute(routes, httpRequest)
0000000000000000000000000000000000000000;;		return dispatcher, route, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2
0000000000000000000000000000000000000000;;	func (r RouterJSR311) detectRoute(routes []Route, httpRequest *http.Request) (*Route, error) {
0000000000000000000000000000000000000000;;		// http method
0000000000000000000000000000000000000000;;		methodOk := []Route{}
0000000000000000000000000000000000000000;;		for _, each := range routes {
0000000000000000000000000000000000000000;;			if httpRequest.Method == each.Method {
0000000000000000000000000000000000000000;;				methodOk = append(methodOk, each)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(methodOk) == 0 {
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("no Route found (in %d routes) that matches HTTP method %s\n", len(routes), httpRequest.Method)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, NewError(http.StatusMethodNotAllowed, "405: Method Not Allowed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inputMediaOk := methodOk
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// content-type
0000000000000000000000000000000000000000;;		contentType := httpRequest.Header.Get(HEADER_ContentType)
0000000000000000000000000000000000000000;;		inputMediaOk = []Route{}
0000000000000000000000000000000000000000;;		for _, each := range methodOk {
0000000000000000000000000000000000000000;;			if each.matchesContentType(contentType) {
0000000000000000000000000000000000000000;;				inputMediaOk = append(inputMediaOk, each)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(inputMediaOk) == 0 {
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("no Route found (from %d) that matches HTTP Content-Type: %s\n", len(methodOk), contentType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, NewError(http.StatusUnsupportedMediaType, "415: Unsupported Media Type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// accept
0000000000000000000000000000000000000000;;		outputMediaOk := []Route{}
0000000000000000000000000000000000000000;;		accept := httpRequest.Header.Get(HEADER_Accept)
0000000000000000000000000000000000000000;;		if len(accept) == 0 {
0000000000000000000000000000000000000000;;			accept = "*/*"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, each := range inputMediaOk {
0000000000000000000000000000000000000000;;			if each.matchesAccept(accept) {
0000000000000000000000000000000000000000;;				outputMediaOk = append(outputMediaOk, each)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(outputMediaOk) == 0 {
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("no Route found (from %d) that matches HTTP Accept: %s\n", len(inputMediaOk), accept)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, NewError(http.StatusNotAcceptable, "406: Not Acceptable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// return r.bestMatchByMedia(outputMediaOk, contentType, accept), nil
0000000000000000000000000000000000000000;;		return &outputMediaOk[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2
0000000000000000000000000000000000000000;;	// n/m > n/* > */*
0000000000000000000000000000000000000000;;	func (r RouterJSR311) bestMatchByMedia(routes []Route, contentType string, accept string) *Route {
0000000000000000000000000000000000000000;;		// TODO
0000000000000000000000000000000000000000;;		return &routes[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2  (step 2)
0000000000000000000000000000000000000000;;	func (r RouterJSR311) selectRoutes(dispatcher *WebService, pathRemainder string) []Route {
0000000000000000000000000000000000000000;;		filtered := &sortableRouteCandidates{}
0000000000000000000000000000000000000000;;		for _, each := range dispatcher.Routes() {
0000000000000000000000000000000000000000;;			pathExpr := each.pathExpr
0000000000000000000000000000000000000000;;			matches := pathExpr.Matcher.FindStringSubmatch(pathRemainder)
0000000000000000000000000000000000000000;;			if matches != nil {
0000000000000000000000000000000000000000;;				lastMatch := matches[len(matches)-1]
0000000000000000000000000000000000000000;;				if len(lastMatch) == 0 || lastMatch == "/" { // do not include if value is neither empty nor ‘/’.
0000000000000000000000000000000000000000;;					filtered.candidates = append(filtered.candidates,
0000000000000000000000000000000000000000;;						routeCandidate{each, len(matches) - 1, pathExpr.LiteralCount, pathExpr.VarCount})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(filtered.candidates) == 0 {
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("WebService on path %s has no routes that match URL path remainder:%s\n", dispatcher.rootPath, pathRemainder)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []Route{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(filtered))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// select other routes from candidates whoes expression matches rmatch
0000000000000000000000000000000000000000;;		matchingRoutes := []Route{filtered.candidates[0].route}
0000000000000000000000000000000000000000;;		for c := 1; c < len(filtered.candidates); c++ {
0000000000000000000000000000000000000000;;			each := filtered.candidates[c]
0000000000000000000000000000000000000000;;			if each.route.pathExpr.Matcher.MatchString(pathRemainder) {
0000000000000000000000000000000000000000;;				matchingRoutes = append(matchingRoutes, each.route)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return matchingRoutes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// http://jsr311.java.net/nonav/releases/1.1/spec/spec3.html#x3-360003.7.2 (step 1)
0000000000000000000000000000000000000000;;	func (r RouterJSR311) detectDispatcher(requestPath string, dispatchers []*WebService) (*WebService, string, error) {
0000000000000000000000000000000000000000;;		filtered := &sortableDispatcherCandidates{}
0000000000000000000000000000000000000000;;		for _, each := range dispatchers {
0000000000000000000000000000000000000000;;			matches := each.pathExpr.Matcher.FindStringSubmatch(requestPath)
0000000000000000000000000000000000000000;;			if matches != nil {
0000000000000000000000000000000000000000;;				filtered.candidates = append(filtered.candidates,
0000000000000000000000000000000000000000;;					dispatcherCandidate{each, matches[len(matches)-1], len(matches), each.pathExpr.LiteralCount, each.pathExpr.VarCount})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(filtered.candidates) == 0 {
0000000000000000000000000000000000000000;;			if trace {
0000000000000000000000000000000000000000;;				traceLogger.Printf("no WebService was found to match URL path:%s\n", requestPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, "", errors.New("not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(filtered))
0000000000000000000000000000000000000000;;		return filtered.candidates[0].dispatcher, filtered.candidates[0].finalMatch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Types and functions to support the sorting of Routes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type routeCandidate struct {
0000000000000000000000000000000000000000;;		route           Route
0000000000000000000000000000000000000000;;		matchesCount    int // the number of capturing groups
0000000000000000000000000000000000000000;;		literalCount    int // the number of literal characters (means those not resulting from template variable substitution)
0000000000000000000000000000000000000000;;		nonDefaultCount int // the number of capturing groups with non-default regular expressions (i.e. not ‘([^  /]+?)’)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r routeCandidate) expressionToMatch() string {
0000000000000000000000000000000000000000;;		return r.route.pathExpr.Source
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r routeCandidate) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("(m=%d,l=%d,n=%d)", r.matchesCount, r.literalCount, r.nonDefaultCount)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortableRouteCandidates struct {
0000000000000000000000000000000000000000;;		candidates []routeCandidate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rcs *sortableRouteCandidates) Len() int {
0000000000000000000000000000000000000000;;		return len(rcs.candidates)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (rcs *sortableRouteCandidates) Swap(i, j int) {
0000000000000000000000000000000000000000;;		rcs.candidates[i], rcs.candidates[j] = rcs.candidates[j], rcs.candidates[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (rcs *sortableRouteCandidates) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		ci := rcs.candidates[i]
0000000000000000000000000000000000000000;;		cj := rcs.candidates[j]
0000000000000000000000000000000000000000;;		// primary key
0000000000000000000000000000000000000000;;		if ci.literalCount < cj.literalCount {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ci.literalCount > cj.literalCount {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// secundary key
0000000000000000000000000000000000000000;;		if ci.matchesCount < cj.matchesCount {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ci.matchesCount > cj.matchesCount {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// tertiary key
0000000000000000000000000000000000000000;;		if ci.nonDefaultCount < cj.nonDefaultCount {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ci.nonDefaultCount > cj.nonDefaultCount {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// quaternary key ("source" is interpreted as Path)
0000000000000000000000000000000000000000;;		return ci.route.Path < cj.route.Path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Types and functions to support the sorting of Dispatchers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dispatcherCandidate struct {
0000000000000000000000000000000000000000;;		dispatcher      *WebService
0000000000000000000000000000000000000000;;		finalMatch      string
0000000000000000000000000000000000000000;;		matchesCount    int // the number of capturing groups
0000000000000000000000000000000000000000;;		literalCount    int // the number of literal characters (means those not resulting from template variable substitution)
0000000000000000000000000000000000000000;;		nonDefaultCount int // the number of capturing groups with non-default regular expressions (i.e. not ‘([^  /]+?)’)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type sortableDispatcherCandidates struct {
0000000000000000000000000000000000000000;;		candidates []dispatcherCandidate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dc *sortableDispatcherCandidates) Len() int {
0000000000000000000000000000000000000000;;		return len(dc.candidates)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (dc *sortableDispatcherCandidates) Swap(i, j int) {
0000000000000000000000000000000000000000;;		dc.candidates[i], dc.candidates[j] = dc.candidates[j], dc.candidates[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (dc *sortableDispatcherCandidates) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		ci := dc.candidates[i]
0000000000000000000000000000000000000000;;		cj := dc.candidates[j]
0000000000000000000000000000000000000000;;		// primary key
0000000000000000000000000000000000000000;;		if ci.matchesCount < cj.matchesCount {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ci.matchesCount > cj.matchesCount {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// secundary key
0000000000000000000000000000000000000000;;		if ci.literalCount < cj.literalCount {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ci.literalCount > cj.literalCount {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// tertiary key
0000000000000000000000000000000000000000;;		return ci.nonDefaultCount < cj.nonDefaultCount
0000000000000000000000000000000000000000;;	}
