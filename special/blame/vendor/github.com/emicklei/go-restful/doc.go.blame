0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package restful , a lean package for creating REST-style WebServices without magic.
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/doc.go[Godeps/_workspace/src/github.com/emicklei/go-restful/doc.go][vendor/github.com/emicklei/go-restful/doc.go];	
0000000000000000000000000000000000000000;;	WebServices and Routes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A WebService has a collection of Route objects that dispatch incoming Http Requests to a function calls.
0000000000000000000000000000000000000000;;	Typically, a WebService has a root path (e.g. /users) and defines common MIME types for its routes.
0000000000000000000000000000000000000000;;	WebServices must be added to a container (see below) in order to handler Http requests from a server.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A Route is defined by a HTTP method, an URL path and (optionally) the MIME types it consumes (Content-Type) and produces (Accept).
0000000000000000000000000000000000000000;;	This package has the logic to find the best matching Route and if found, call its Function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws := new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.
0000000000000000000000000000000000000000;;			Path("/users").
0000000000000000000000000000000000000000;;			Consumes(restful.MIME_JSON, restful.MIME_XML).
0000000000000000000000000000000000000000;;			Produces(restful.MIME_JSON, restful.MIME_XML)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{user-id}").To(u.findUser))  // u is a UserResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GET http://localhost:8080/users/1
0000000000000000000000000000000000000000;;		func (u UserResource) findUser(request *restful.Request, response *restful.Response) {
0000000000000000000000000000000000000000;;			id := request.PathParameter("user-id")
0000000000000000000000000000000000000000;;			...
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The (*Request, *Response) arguments provide functions for reading information from the request and writing information back to the response.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the example https://github.com/emicklei/go-restful/blob/master/examples/restful-user-resource.go with a full implementation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Regular expression matching Routes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A Route parameter can be specified using the format "uri/{var[:regexp]}" or the special version "uri/{var:*}" for matching the tail of the path.
0000000000000000000000000000000000000000;;	For example, /persons/{name:[A-Z][A-Z]} can be used to restrict values for the parameter "name" to only contain capital alphabetic characters.
0000000000000000000000000000000000000000;;	Regular expressions must use the standard Go syntax as described in the regexp package. (https://code.google.com/p/re2/wiki/Syntax)
0000000000000000000000000000000000000000;;	This feature requires the use of a CurlyRouter.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Containers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A Container holds a collection of WebServices, Filters and a http.ServeMux for multiplexing http requests.
0000000000000000000000000000000000000000;;	Using the statements "restful.Add(...) and restful.Filter(...)" will register WebServices and Filters to the Default Container.
0000000000000000000000000000000000000000;;	The Default container of go-restful uses the http.DefaultServeMux.
0000000000000000000000000000000000000000;;	You can create your own Container and create a new http.Server for that particular container.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		container := restful.NewContainer()
0000000000000000000000000000000000000000;;		server := &http.Server{Addr: ":8081", Handler: container}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A filter dynamically intercepts requests and responses to transform or use the information contained in the requests or responses.
0000000000000000000000000000000000000000;;	You can use filters to perform generic logging, measurement, authentication, redirect, set response headers etc.
0000000000000000000000000000000000000000;;	In the restful package there are three hooks into the request,response flow where filters can be added.
0000000000000000000000000000000000000000;;	Each filter must define a FilterFunction:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (req *restful.Request, resp *restful.Response, chain *restful.FilterChain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Use the following statement to pass the request,response pair to the next filter or RouteFunction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chain.ProcessFilter(req, resp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Container Filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	These are processed before any registered WebService.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// install a (global) filter for the default container (processed before any webservice)
0000000000000000000000000000000000000000;;		restful.Filter(globalLogging)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	WebService Filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	These are processed before any Route of a WebService.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// install a webservice filter (processed before any route)
0000000000000000000000000000000000000000;;		ws.Filter(webserviceLogging).Filter(measureTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Route Filters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	These are processed before calling the function associated with the Route.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// install 2 chained route filters (processed before calling findUser)
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{user-id}").Filter(routeLogging).Filter(NewCountFilter().routeCounter).To(findUser))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the example https://github.com/emicklei/go-restful/blob/master/examples/restful-filters.go with full implementations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Response Encoding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Two encodings are supported: gzip and deflate. To enable this for all responses:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful.DefaultContainer.EnableContentEncoding(true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If a Http request includes the Accept-Encoding header then the response content will be compressed using the specified encoding.
0000000000000000000000000000000000000000;;	Alternatively, you can create a Filter that performs the encoding and install it per WebService or Route.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the example https://github.com/emicklei/go-restful/blob/master/examples/restful-encoding-filter.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	OPTIONS support
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	By installing a pre-defined container filter, your Webservice(s) can respond to the OPTIONS Http request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Filter(OPTIONSFilter())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	CORS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	By installing the filter of a CrossOriginResourceSharing (CORS), your WebService(s) can handle CORS requests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cors := CrossOriginResourceSharing{ExposeHeaders: []string{"X-My-Header"}, CookiesAllowed: false, Container: DefaultContainer}
0000000000000000000000000000000000000000;;		Filter(cors.Filter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Error Handling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unexpected things happen. If a request cannot be processed because of a failure, your service needs to tell via the response what happened and why.
0000000000000000000000000000000000000000;;	For this reason HTTP status codes exist and it is important to use the correct code in every exceptional situation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		400: Bad Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If path or query parameters are not valid (content or type) then use http.StatusBadRequest.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		404: Not Found
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Despite a valid URI, the resource requested may not be available
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		500: Internal Server Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If the application logic could not process the request (or write the response) then use http.StatusInternalServerError.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		405: Method Not Allowed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The request has a valid URL but the method (GET,PUT,POST,...) is not allowed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		406: Not Acceptable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The request does not have or has an unknown Accept Header set for this operation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		415: Unsupported Media Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The request does not have or has an unknown Content-Type Header set for this operation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	ServiceError
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In addition to setting the correct (error) Http status code, you can choose to write a ServiceError message on the response.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Performance options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This package has several options that affect the performance of your service. It is important to understand them and how you can change it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful.DefaultContainer.DoNotRecover(false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	DoNotRecover controls whether panics will be caught to return HTTP 500.
0000000000000000000000000000000000000000;;	If set to false, the container will recover from panics.
0000000000000000000000000000000000000000;;	Default value is true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful.SetCompressorProvider(NewBoundedCachedCompressors(20, 20))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If content encoding is enabled then the default strategy for getting new gzip/zlib writers and readers is to use a sync.Pool.
0000000000000000000000000000000000000000;;	Because writers are expensive structures, performance is even more improved when using a preloaded cache. You can also inject your own implementation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Trouble shooting
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This package has the means to produce detail logging of the complete Http request matching process and filter invocation.
0000000000000000000000000000000000000000;;	Enabling this feature requires you to set an implementation of restful.StdLogger (e.g. log.Logger) instance such as:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restful.TraceLogger(log.New(os.Stdout, "[restful] ", log.LstdFlags|log.Lshortfile))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Logging
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The restful.SetLogger() method allows you to override the logger used by the package. By default restful
0000000000000000000000000000000000000000;;	uses the standard library `log` package and logs to stdout. Different logging packages are supported as
0000000000000000000000000000000000000000;;	long as they conform to `StdLogger` interface defined in the `log` sub-package, writing an adapter for your
0000000000000000000000000000000000000000;;	preferred package is simple.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Resources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[project]: https://github.com/emicklei/go-restful
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[examples]: https://github.com/emicklei/go-restful/blob/master/examples
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[design]:  http://ernestmicklei.com/2012/11/11/go-restful-api-design/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[showcases]: https://github.com/emicklei/mora, https://github.com/emicklei/landskape
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	(c) 2012-2015, http://ernestmicklei.com. MIT License
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package restful
