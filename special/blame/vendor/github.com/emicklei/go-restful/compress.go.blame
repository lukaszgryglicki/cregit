0000000000000000000000000000000000000000;;	package restful
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/compress.go[Godeps/_workspace/src/github.com/emicklei/go-restful/compress.go][vendor/github.com/emicklei/go-restful/compress.go];	
0000000000000000000000000000000000000000;;	// Copyright 2013 Ernest Micklei. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a license
0000000000000000000000000000000000000000;;	// that can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"compress/zlib"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OBSOLETE : use restful.DefaultContainer.EnableContentEncoding(true) to change this setting.
0000000000000000000000000000000000000000;;	var EnableContentEncoding = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompressingResponseWriter is a http.ResponseWriter that can perform content encoding (gzip and zlib)
0000000000000000000000000000000000000000;;	type CompressingResponseWriter struct {
0000000000000000000000000000000000000000;;		writer     http.ResponseWriter
0000000000000000000000000000000000000000;;		compressor io.WriteCloser
0000000000000000000000000000000000000000;;		encoding   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header is part of http.ResponseWriter interface
0000000000000000000000000000000000000000;;	func (c *CompressingResponseWriter) Header() http.Header {
0000000000000000000000000000000000000000;;		return c.writer.Header()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeader is part of http.ResponseWriter interface
0000000000000000000000000000000000000000;;	func (c *CompressingResponseWriter) WriteHeader(status int) {
0000000000000000000000000000000000000000;;		c.writer.WriteHeader(status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write is part of http.ResponseWriter interface
0000000000000000000000000000000000000000;;	// It is passed through the compressor
0000000000000000000000000000000000000000;;	func (c *CompressingResponseWriter) Write(bytes []byte) (int, error) {
0000000000000000000000000000000000000000;;		if c.isCompressorClosed() {
0000000000000000000000000000000000000000;;			return -1, errors.New("Compressing error: tried to write data using closed compressor")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.compressor.Write(bytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseNotify is part of http.CloseNotifier interface
0000000000000000000000000000000000000000;;	func (c *CompressingResponseWriter) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return c.writer.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close the underlying compressor
0000000000000000000000000000000000000000;;	func (c *CompressingResponseWriter) Close() error {
0000000000000000000000000000000000000000;;		if c.isCompressorClosed() {
0000000000000000000000000000000000000000;;			return errors.New("Compressing error: tried to close already closed compressor")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.compressor.Close()
0000000000000000000000000000000000000000;;		if ENCODING_GZIP == c.encoding {
0000000000000000000000000000000000000000;;			currentCompressorProvider.ReleaseGzipWriter(c.compressor.(*gzip.Writer))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ENCODING_DEFLATE == c.encoding {
0000000000000000000000000000000000000000;;			currentCompressorProvider.ReleaseZlibWriter(c.compressor.(*zlib.Writer))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// gc hint needed?
0000000000000000000000000000000000000000;;		c.compressor = nil
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CompressingResponseWriter) isCompressorClosed() bool {
0000000000000000000000000000000000000000;;		return nil == c.compressor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hijack implements the Hijacker interface
0000000000000000000000000000000000000000;;	// This is especially useful when combining Container.EnabledContentEncoding
0000000000000000000000000000000000000000;;	// in combination with websockets (for instance gorilla/websocket)
0000000000000000000000000000000000000000;;	func (c *CompressingResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		hijacker, ok := c.writer.(http.Hijacker)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("ResponseWriter doesn't support Hijacker interface")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hijacker.Hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WantsCompressedResponse reads the Accept-Encoding header to see if and which encoding is requested.
0000000000000000000000000000000000000000;;	func wantsCompressedResponse(httpRequest *http.Request) (bool, string) {
0000000000000000000000000000000000000000;;		header := httpRequest.Header.Get(HEADER_AcceptEncoding)
0000000000000000000000000000000000000000;;		gi := strings.Index(header, ENCODING_GZIP)
0000000000000000000000000000000000000000;;		zi := strings.Index(header, ENCODING_DEFLATE)
0000000000000000000000000000000000000000;;		// use in order of appearance
0000000000000000000000000000000000000000;;		if gi == -1 {
0000000000000000000000000000000000000000;;			return zi != -1, ENCODING_DEFLATE
0000000000000000000000000000000000000000;;		} else if zi == -1 {
0000000000000000000000000000000000000000;;			return gi != -1, ENCODING_GZIP
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if gi < zi {
0000000000000000000000000000000000000000;;				return true, ENCODING_GZIP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, ENCODING_DEFLATE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCompressingResponseWriter create a CompressingResponseWriter for a known encoding = {gzip,deflate}
0000000000000000000000000000000000000000;;	func NewCompressingResponseWriter(httpWriter http.ResponseWriter, encoding string) (*CompressingResponseWriter, error) {
0000000000000000000000000000000000000000;;		httpWriter.Header().Set(HEADER_ContentEncoding, encoding)
0000000000000000000000000000000000000000;;		c := new(CompressingResponseWriter)
0000000000000000000000000000000000000000;;		c.writer = httpWriter
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if ENCODING_GZIP == encoding {
0000000000000000000000000000000000000000;;			w := currentCompressorProvider.AcquireGzipWriter()
0000000000000000000000000000000000000000;;			w.Reset(httpWriter)
0000000000000000000000000000000000000000;;			c.compressor = w
0000000000000000000000000000000000000000;;			c.encoding = ENCODING_GZIP
0000000000000000000000000000000000000000;;		} else if ENCODING_DEFLATE == encoding {
0000000000000000000000000000000000000000;;			w := currentCompressorProvider.AcquireZlibWriter()
0000000000000000000000000000000000000000;;			w.Reset(httpWriter)
0000000000000000000000000000000000000000;;			c.compressor = w
0000000000000000000000000000000000000000;;			c.encoding = ENCODING_DEFLATE
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, errors.New("Unknown encoding:" + encoding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, err
0000000000000000000000000000000000000000;;	}
