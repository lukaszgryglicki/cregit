0000000000000000000000000000000000000000;;	package swagger
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/swagger/swagger_webservice.go[Godeps/_workspace/src/github.com/emicklei/go-restful/swagger/swagger_webservice.go][vendor/github.com/emicklei/go-restful-swagger12/swagger_webservice.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful"
0000000000000000000000000000000000000000;;		// "github.com/emicklei/hopwatch"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/emicklei/go-restful/log"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SwaggerService struct {
0000000000000000000000000000000000000000;;		config            Config
0000000000000000000000000000000000000000;;		apiDeclarationMap *ApiDeclarationList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSwaggerService(config Config) *SwaggerService {
0000000000000000000000000000000000000000;;		sws := &SwaggerService{
0000000000000000000000000000000000000000;;			config:            config,
0000000000000000000000000000000000000000;;			apiDeclarationMap: new(ApiDeclarationList)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build all ApiDeclarations
0000000000000000000000000000000000000000;;		for _, each := range config.WebServices {
0000000000000000000000000000000000000000;;			rootPath := each.RootPath()
0000000000000000000000000000000000000000;;			// skip the api service itself
0000000000000000000000000000000000000000;;			if rootPath != config.ApiPath {
0000000000000000000000000000000000000000;;				if rootPath == "" || rootPath == "/" {
0000000000000000000000000000000000000000;;					// use routes
0000000000000000000000000000000000000000;;					for _, route := range each.Routes() {
0000000000000000000000000000000000000000;;						entry := staticPathFromRoute(route)
0000000000000000000000000000000000000000;;						_, exists := sws.apiDeclarationMap.At(entry)
0000000000000000000000000000000000000000;;						if !exists {
0000000000000000000000000000000000000000;;							sws.apiDeclarationMap.Put(entry, sws.composeDeclaration(each, entry))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else { // use root path
0000000000000000000000000000000000000000;;					sws.apiDeclarationMap.Put(each.RootPath(), sws.composeDeclaration(each, each.RootPath()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if specified then call the PostBuilderHandler
0000000000000000000000000000000000000000;;		if config.PostBuildHandler != nil {
0000000000000000000000000000000000000000;;			config.PostBuildHandler(sws.apiDeclarationMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sws
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogInfo is the function that is called when this package needs to log. It defaults to log.Printf
0000000000000000000000000000000000000000;;	var LogInfo = func(format string, v ...interface{}) {
0000000000000000000000000000000000000000;;		// use the restful package-wide logger
0000000000000000000000000000000000000000;;		log.Printf(format, v...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstallSwaggerService add the WebService that provides the API documentation of all services
0000000000000000000000000000000000000000;;	// conform the Swagger documentation specifcation. (https://github.com/wordnik/swagger-core/wiki).
0000000000000000000000000000000000000000;;	func InstallSwaggerService(aSwaggerConfig Config) {
0000000000000000000000000000000000000000;;		RegisterSwaggerService(aSwaggerConfig, restful.DefaultContainer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterSwaggerService add the WebService that provides the API documentation of all services
0000000000000000000000000000000000000000;;	// conform the Swagger documentation specifcation. (https://github.com/wordnik/swagger-core/wiki).
0000000000000000000000000000000000000000;;	func RegisterSwaggerService(config Config, wsContainer *restful.Container) {
0000000000000000000000000000000000000000;;		sws := newSwaggerService(config)
0000000000000000000000000000000000000000;;		ws := new(restful.WebService)
0000000000000000000000000000000000000000;;		ws.Path(config.ApiPath)
0000000000000000000000000000000000000000;;		ws.Produces(restful.MIME_JSON)
0000000000000000000000000000000000000000;;		if config.DisableCORS {
0000000000000000000000000000000000000000;;			ws.Filter(enableCORS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/").To(sws.getListing))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{a}").To(sws.getDeclarations))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{a}/{b}").To(sws.getDeclarations))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{a}/{b}/{c}").To(sws.getDeclarations))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{a}/{b}/{c}/{d}").To(sws.getDeclarations))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{a}/{b}/{c}/{d}/{e}").To(sws.getDeclarations))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{a}/{b}/{c}/{d}/{e}/{f}").To(sws.getDeclarations))
0000000000000000000000000000000000000000;;		ws.Route(ws.GET("/{a}/{b}/{c}/{d}/{e}/{f}/{g}").To(sws.getDeclarations))
0000000000000000000000000000000000000000;;		LogInfo("[restful/swagger] listing is available at %v%v", config.WebServicesUrl, config.ApiPath)
0000000000000000000000000000000000000000;;		wsContainer.Add(ws)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check paths for UI serving
0000000000000000000000000000000000000000;;		if config.StaticHandler == nil && config.SwaggerFilePath != "" && config.SwaggerPath != "" {
0000000000000000000000000000000000000000;;			swaggerPathSlash := config.SwaggerPath
0000000000000000000000000000000000000000;;			// path must end with slash /
0000000000000000000000000000000000000000;;			if "/" != config.SwaggerPath[len(config.SwaggerPath)-1:] {
0000000000000000000000000000000000000000;;				LogInfo("[restful/swagger] use corrected SwaggerPath ; must end with slash (/)")
0000000000000000000000000000000000000000;;				swaggerPathSlash += "/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			LogInfo("[restful/swagger] %v%v is mapped to folder %v", config.WebServicesUrl, swaggerPathSlash, config.SwaggerFilePath)
0000000000000000000000000000000000000000;;			wsContainer.Handle(swaggerPathSlash, http.StripPrefix(swaggerPathSlash, http.FileServer(http.Dir(config.SwaggerFilePath))))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//if we define a custom static handler use it
0000000000000000000000000000000000000000;;		} else if config.StaticHandler != nil && config.SwaggerPath != "" {
0000000000000000000000000000000000000000;;			swaggerPathSlash := config.SwaggerPath
0000000000000000000000000000000000000000;;			// path must end with slash /
0000000000000000000000000000000000000000;;			if "/" != config.SwaggerPath[len(config.SwaggerPath)-1:] {
0000000000000000000000000000000000000000;;				LogInfo("[restful/swagger] use corrected SwaggerFilePath ; must end with slash (/)")
0000000000000000000000000000000000000000;;				swaggerPathSlash += "/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			LogInfo("[restful/swagger] %v%v is mapped to custom Handler %T", config.WebServicesUrl, swaggerPathSlash, config.StaticHandler)
0000000000000000000000000000000000000000;;			wsContainer.Handle(swaggerPathSlash, config.StaticHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			LogInfo("[restful/swagger] Swagger(File)Path is empty ; no UI is served")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func staticPathFromRoute(r restful.Route) string {
0000000000000000000000000000000000000000;;		static := r.Path
0000000000000000000000000000000000000000;;		bracket := strings.Index(static, "{")
0000000000000000000000000000000000000000;;		if bracket <= 1 { // result cannot be empty
0000000000000000000000000000000000000000;;			return static
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bracket != -1 {
0000000000000000000000000000000000000000;;			static = r.Path[:bracket]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasSuffix(static, "/") {
0000000000000000000000000000000000000000;;			return static[:len(static)-1]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return static
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func enableCORS(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) {
0000000000000000000000000000000000000000;;		if origin := req.HeaderParameter(restful.HEADER_Origin); origin != "" {
0000000000000000000000000000000000000000;;			// prevent duplicate header
0000000000000000000000000000000000000000;;			if len(resp.Header().Get(restful.HEADER_AccessControlAllowOrigin)) == 0 {
0000000000000000000000000000000000000000;;				resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, origin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		chain.ProcessFilter(req, resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws SwaggerService) getListing(req *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;		listing := sws.produceListing()
0000000000000000000000000000000000000000;;		resp.WriteAsJson(listing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws SwaggerService) produceListing() ResourceListing {
0000000000000000000000000000000000000000;;		listing := ResourceListing{SwaggerVersion: swaggerVersion, ApiVersion: sws.config.ApiVersion, Info: sws.config.Info}
0000000000000000000000000000000000000000;;		sws.apiDeclarationMap.Do(func(k string, v ApiDeclaration) {
0000000000000000000000000000000000000000;;			ref := Resource{Path: k}
0000000000000000000000000000000000000000;;			if len(v.Apis) > 0 { // use description of first (could still be empty)
0000000000000000000000000000000000000000;;				ref.Description = v.Apis[0].Description
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			listing.Apis = append(listing.Apis, ref)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return listing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws SwaggerService) getDeclarations(req *restful.Request, resp *restful.Response) {
0000000000000000000000000000000000000000;;		decl, ok := sws.produceDeclarations(composeRootPath(req))
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			resp.WriteErrorString(http.StatusNotFound, "ApiDeclaration not found")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// unless WebServicesUrl is given
0000000000000000000000000000000000000000;;		if len(sws.config.WebServicesUrl) == 0 {
0000000000000000000000000000000000000000;;			// update base path from the actual request
0000000000000000000000000000000000000000;;			// TODO how to detect https? assume http for now
0000000000000000000000000000000000000000;;			var host string
0000000000000000000000000000000000000000;;			// X-Forwarded-Host or Host or Request.Host
0000000000000000000000000000000000000000;;			hostvalues, ok := req.Request.Header["X-Forwarded-Host"] // apache specific?
0000000000000000000000000000000000000000;;			if !ok || len(hostvalues) == 0 {
0000000000000000000000000000000000000000;;				forwarded, ok := req.Request.Header["Host"] // without reverse-proxy
0000000000000000000000000000000000000000;;				if !ok || len(forwarded) == 0 {
0000000000000000000000000000000000000000;;					// fallback to Host field
0000000000000000000000000000000000000000;;					host = req.Request.Host
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					host = forwarded[0]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				host = hostvalues[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// inspect Referer for the scheme (http vs https)
0000000000000000000000000000000000000000;;			scheme := "http"
0000000000000000000000000000000000000000;;			if referer := req.Request.Header["Referer"]; len(referer) > 0 {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(referer[0], "https") {
0000000000000000000000000000000000000000;;					scheme = "https"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			decl.BasePath = fmt.Sprintf("%s://%s", scheme, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.WriteAsJson(decl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws SwaggerService) produceAllDeclarations() map[string]ApiDeclaration {
0000000000000000000000000000000000000000;;		decls := map[string]ApiDeclaration{}
0000000000000000000000000000000000000000;;		sws.apiDeclarationMap.Do(func(k string, v ApiDeclaration) {
0000000000000000000000000000000000000000;;			decls[k] = v
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return decls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws SwaggerService) produceDeclarations(route string) (*ApiDeclaration, bool) {
0000000000000000000000000000000000000000;;		decl, ok := sws.apiDeclarationMap.At(route)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decl.BasePath = sws.config.WebServicesUrl
0000000000000000000000000000000000000000;;		return &decl, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// composeDeclaration uses all routes and parameters to create a ApiDeclaration
0000000000000000000000000000000000000000;;	func (sws SwaggerService) composeDeclaration(ws *restful.WebService, pathPrefix string) ApiDeclaration {
0000000000000000000000000000000000000000;;		decl := ApiDeclaration{
0000000000000000000000000000000000000000;;			SwaggerVersion: swaggerVersion,
0000000000000000000000000000000000000000;;			BasePath:       sws.config.WebServicesUrl,
0000000000000000000000000000000000000000;;			ResourcePath:   pathPrefix,
0000000000000000000000000000000000000000;;			Models:         ModelList{},
0000000000000000000000000000000000000000;;			ApiVersion:     ws.Version()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// collect any path parameters
0000000000000000000000000000000000000000;;		rootParams := []Parameter{}
0000000000000000000000000000000000000000;;		for _, param := range ws.PathParameters() {
0000000000000000000000000000000000000000;;			rootParams = append(rootParams, asSwaggerParameter(param.Data()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// aggregate by path
0000000000000000000000000000000000000000;;		pathToRoutes := newOrderedRouteMap()
0000000000000000000000000000000000000000;;		for _, other := range ws.Routes() {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(other.Path, pathPrefix) {
0000000000000000000000000000000000000000;;				if len(pathPrefix) > 1 && len(other.Path) > len(pathPrefix) && other.Path[len(pathPrefix)] != '/' {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pathToRoutes.Add(other.Path, other)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pathToRoutes.Do(func(path string, routes []restful.Route) {
0000000000000000000000000000000000000000;;			api := Api{Path: strings.TrimSuffix(withoutWildcard(path), "/"), Description: ws.Documentation()}
0000000000000000000000000000000000000000;;			voidString := "void"
0000000000000000000000000000000000000000;;			for _, route := range routes {
0000000000000000000000000000000000000000;;				operation := Operation{
0000000000000000000000000000000000000000;;					Method:  route.Method,
0000000000000000000000000000000000000000;;					Summary: route.Doc,
0000000000000000000000000000000000000000;;					Notes:   route.Notes,
0000000000000000000000000000000000000000;;					// Type gets overwritten if there is a write sample
0000000000000000000000000000000000000000;;					DataTypeFields:   DataTypeFields{Type: &voidString},
0000000000000000000000000000000000000000;;					Parameters:       []Parameter{},
0000000000000000000000000000000000000000;;					Nickname:         route.Operation,
0000000000000000000000000000000000000000;;					ResponseMessages: composeResponseMessages(route, &decl, &sws.config)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				operation.Consumes = route.Consumes
0000000000000000000000000000000000000000;;				operation.Produces = route.Produces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// share root params if any
0000000000000000000000000000000000000000;;				for _, swparam := range rootParams {
0000000000000000000000000000000000000000;;					operation.Parameters = append(operation.Parameters, swparam)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// route specific params
0000000000000000000000000000000000000000;;				for _, param := range route.ParameterDocs {
0000000000000000000000000000000000000000;;					operation.Parameters = append(operation.Parameters, asSwaggerParameter(param.Data()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sws.addModelsFromRouteTo(&operation, route, &decl)
0000000000000000000000000000000000000000;;				api.Operations = append(api.Operations, operation)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			decl.Apis = append(decl.Apis, api)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return decl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func withoutWildcard(path string) string {
0000000000000000000000000000000000000000;;		if strings.HasSuffix(path, ":*}") {
0000000000000000000000000000000000000000;;			return path[0:len(path)-3] + "}"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// composeResponseMessages takes the ResponseErrors (if any) and creates ResponseMessages from them.
0000000000000000000000000000000000000000;;	func composeResponseMessages(route restful.Route, decl *ApiDeclaration, config *Config) (messages []ResponseMessage) {
0000000000000000000000000000000000000000;;		if route.ResponseErrors == nil {
0000000000000000000000000000000000000000;;			return messages
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// sort by code
0000000000000000000000000000000000000000;;		codes := sort.IntSlice{}
0000000000000000000000000000000000000000;;		for code := range route.ResponseErrors {
0000000000000000000000000000000000000000;;			codes = append(codes, code)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		codes.Sort()
0000000000000000000000000000000000000000;;		for _, code := range codes {
0000000000000000000000000000000000000000;;			each := route.ResponseErrors[code]
0000000000000000000000000000000000000000;;			message := ResponseMessage{
0000000000000000000000000000000000000000;;				Code:    code,
0000000000000000000000000000000000000000;;				Message: each.Message,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if each.Model != nil {
0000000000000000000000000000000000000000;;				st := reflect.TypeOf(each.Model)
0000000000000000000000000000000000000000;;				isCollection, st := detectCollectionType(st)
0000000000000000000000000000000000000000;;				// collection cannot be in responsemodel
0000000000000000000000000000000000000000;;				if !isCollection {
0000000000000000000000000000000000000000;;					modelName := modelBuilder{}.keyFrom(st)
0000000000000000000000000000000000000000;;					modelBuilder{Models: &decl.Models, Config: config}.addModel(st, "")
0000000000000000000000000000000000000000;;					message.ResponseModel = modelName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			messages = append(messages, message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addModelsFromRoute takes any read or write sample from the Route and creates a Swagger model from it.
0000000000000000000000000000000000000000;;	func (sws SwaggerService) addModelsFromRouteTo(operation *Operation, route restful.Route, decl *ApiDeclaration) {
0000000000000000000000000000000000000000;;		if route.ReadSample != nil {
0000000000000000000000000000000000000000;;			sws.addModelFromSampleTo(operation, false, route.ReadSample, &decl.Models)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if route.WriteSample != nil {
0000000000000000000000000000000000000000;;			sws.addModelFromSampleTo(operation, true, route.WriteSample, &decl.Models)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func detectCollectionType(st reflect.Type) (bool, reflect.Type) {
0000000000000000000000000000000000000000;;		isCollection := false
0000000000000000000000000000000000000000;;		if st.Kind() == reflect.Slice || st.Kind() == reflect.Array {
0000000000000000000000000000000000000000;;			st = st.Elem()
0000000000000000000000000000000000000000;;			isCollection = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if st.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				if st.Elem().Kind() == reflect.Slice || st.Elem().Kind() == reflect.Array {
0000000000000000000000000000000000000000;;					st = st.Elem().Elem()
0000000000000000000000000000000000000000;;					isCollection = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return isCollection, st
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addModelFromSample creates and adds (or overwrites) a Model from a sample resource
0000000000000000000000000000000000000000;;	func (sws SwaggerService) addModelFromSampleTo(operation *Operation, isResponse bool, sample interface{}, models *ModelList) {
0000000000000000000000000000000000000000;;		mb := modelBuilder{Models: models, Config: &sws.config}
0000000000000000000000000000000000000000;;		if isResponse {
0000000000000000000000000000000000000000;;			sampleType, items := asDataType(sample, &sws.config)
0000000000000000000000000000000000000000;;			operation.Type = sampleType
0000000000000000000000000000000000000000;;			operation.Items = items
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mb.addModelFrom(sample)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func asSwaggerParameter(param restful.ParameterData) Parameter {
0000000000000000000000000000000000000000;;		return Parameter{
0000000000000000000000000000000000000000;;			DataTypeFields: DataTypeFields{
0000000000000000000000000000000000000000;;				Type:         &param.DataType,
0000000000000000000000000000000000000000;;				Format:       asFormat(param.DataType, param.DataFormat),
0000000000000000000000000000000000000000;;				DefaultValue: Special(param.DefaultValue),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Name:        param.Name,
0000000000000000000000000000000000000000;;			Description: param.Description,
0000000000000000000000000000000000000000;;			ParamType:   asParamType(param.Kind),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Required: param.Required}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Between 1..7 path parameters is supported
0000000000000000000000000000000000000000;;	func composeRootPath(req *restful.Request) string {
0000000000000000000000000000000000000000;;		path := "/" + req.PathParameter("a")
0000000000000000000000000000000000000000;;		b := req.PathParameter("b")
0000000000000000000000000000000000000000;;		if b == "" {
0000000000000000000000000000000000000000;;			return path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path = path + "/" + b
0000000000000000000000000000000000000000;;		c := req.PathParameter("c")
0000000000000000000000000000000000000000;;		if c == "" {
0000000000000000000000000000000000000000;;			return path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path = path + "/" + c
0000000000000000000000000000000000000000;;		d := req.PathParameter("d")
0000000000000000000000000000000000000000;;		if d == "" {
0000000000000000000000000000000000000000;;			return path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path = path + "/" + d
0000000000000000000000000000000000000000;;		e := req.PathParameter("e")
0000000000000000000000000000000000000000;;		if e == "" {
0000000000000000000000000000000000000000;;			return path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path = path + "/" + e
0000000000000000000000000000000000000000;;		f := req.PathParameter("f")
0000000000000000000000000000000000000000;;		if f == "" {
0000000000000000000000000000000000000000;;			return path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path = path + "/" + f
0000000000000000000000000000000000000000;;		g := req.PathParameter("g")
0000000000000000000000000000000000000000;;		if g == "" {
0000000000000000000000000000000000000000;;			return path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path + "/" + g
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func asFormat(dataType string, dataFormat string) string {
0000000000000000000000000000000000000000;;		if dataFormat != "" {
0000000000000000000000000000000000000000;;			return dataFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "" // TODO
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func asParamType(kind int) string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case kind == restful.PathParameterKind:
0000000000000000000000000000000000000000;;			return "path"
0000000000000000000000000000000000000000;;		case kind == restful.QueryParameterKind:
0000000000000000000000000000000000000000;;			return "query"
0000000000000000000000000000000000000000;;		case kind == restful.BodyParameterKind:
0000000000000000000000000000000000000000;;			return "body"
0000000000000000000000000000000000000000;;		case kind == restful.HeaderParameterKind:
0000000000000000000000000000000000000000;;			return "header"
0000000000000000000000000000000000000000;;		case kind == restful.FormParameterKind:
0000000000000000000000000000000000000000;;			return "form"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func asDataType(any interface{}, config *Config) (*string, *Item) {
0000000000000000000000000000000000000000;;		// If it's not a collection, return the suggested model name
0000000000000000000000000000000000000000;;		st := reflect.TypeOf(any)
0000000000000000000000000000000000000000;;		isCollection, st := detectCollectionType(st)
0000000000000000000000000000000000000000;;		modelName := modelBuilder{}.keyFrom(st)
0000000000000000000000000000000000000000;;		// if it's not a collection we are done
0000000000000000000000000000000000000000;;		if !isCollection {
0000000000000000000000000000000000000000;;			return &modelName, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// XXX: This is not very elegant
0000000000000000000000000000000000000000;;		// We create an Item object referring to the given model
0000000000000000000000000000000000000000;;		models := ModelList{}
0000000000000000000000000000000000000000;;		mb := modelBuilder{Models: &models, Config: config}
0000000000000000000000000000000000000000;;		mb.addModelFrom(any)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elemTypeName := mb.getElementTypeName(modelName, "", st)
0000000000000000000000000000000000000000;;		item := new(Item)
0000000000000000000000000000000000000000;;		if mb.isPrimitiveType(elemTypeName) {
0000000000000000000000000000000000000000;;			mapped := mb.jsonSchemaType(elemTypeName)
0000000000000000000000000000000000000000;;			item.Type = &mapped
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			item.Ref = &elemTypeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmp := "array"
0000000000000000000000000000000000000000;;		return &tmp, item
0000000000000000000000000000000000000000;;	}
