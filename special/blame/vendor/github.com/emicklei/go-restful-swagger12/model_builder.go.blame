0000000000000000000000000000000000000000;;	package swagger
faffbe4b32b67a5323e317a6025ba76cb607b435;Godeps/_workspace/src/github.com/emicklei/go-restful/swagger/model_builder.go[Godeps/_workspace/src/github.com/emicklei/go-restful/swagger/model_builder.go][vendor/github.com/emicklei/go-restful-swagger12/model_builder.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ModelBuildable is used for extending Structs that need more control over
0000000000000000000000000000000000000000;;	// how the Model appears in the Swagger api declaration.
0000000000000000000000000000000000000000;;	type ModelBuildable interface {
0000000000000000000000000000000000000000;;		PostBuildModel(m *Model) *Model
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type modelBuilder struct {
0000000000000000000000000000000000000000;;		Models *ModelList
0000000000000000000000000000000000000000;;		Config *Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type documentable interface {
0000000000000000000000000000000000000000;;		SwaggerDoc() map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if this structure has a method with signature func (<theModel>) SwaggerDoc() map[string]string
0000000000000000000000000000000000000000;;	// If it exists, retrive the documentation and overwrite all struct tag descriptions
0000000000000000000000000000000000000000;;	func getDocFromMethodSwaggerDoc2(model reflect.Type) map[string]string {
0000000000000000000000000000000000000000;;		if docable, ok := reflect.New(model).Elem().Interface().(documentable); ok {
0000000000000000000000000000000000000000;;			return docable.SwaggerDoc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return make(map[string]string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addModelFrom creates and adds a Model to the builder and detects and calls
0000000000000000000000000000000000000000;;	// the post build hook for customizations
0000000000000000000000000000000000000000;;	func (b modelBuilder) addModelFrom(sample interface{}) {
0000000000000000000000000000000000000000;;		if modelOrNil := b.addModel(reflect.TypeOf(sample), ""); modelOrNil != nil {
0000000000000000000000000000000000000000;;			// allow customizations
0000000000000000000000000000000000000000;;			if buildable, ok := sample.(ModelBuildable); ok {
0000000000000000000000000000000000000000;;				modelOrNil = buildable.PostBuildModel(modelOrNil)
0000000000000000000000000000000000000000;;				b.Models.Put(modelOrNil.Id, *modelOrNil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) addModel(st reflect.Type, nameOverride string) *Model {
0000000000000000000000000000000000000000;;		// Turn pointers into simpler types so further checks are
0000000000000000000000000000000000000000;;		// correct.
0000000000000000000000000000000000000000;;		if st.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			st = st.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modelName := b.keyFrom(st)
0000000000000000000000000000000000000000;;		if nameOverride != "" {
0000000000000000000000000000000000000000;;			modelName = nameOverride
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// no models needed for primitive types
0000000000000000000000000000000000000000;;		if b.isPrimitiveType(modelName) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// golang encoding/json packages says array and slice values encode as
0000000000000000000000000000000000000000;;		// JSON arrays, except that []byte encodes as a base64-encoded string.
0000000000000000000000000000000000000000;;		// If we see a []byte here, treat it at as a primitive type (string)
0000000000000000000000000000000000000000;;		// and deal with it in buildArrayTypeProperty.
0000000000000000000000000000000000000000;;		if (st.Kind() == reflect.Slice || st.Kind() == reflect.Array) &&
0000000000000000000000000000000000000000;;			st.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// see if we already have visited this model
0000000000000000000000000000000000000000;;		if _, ok := b.Models.At(modelName); ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sm := Model{
0000000000000000000000000000000000000000;;			Id:         modelName,
0000000000000000000000000000000000000000;;			Required:   []string{},
0000000000000000000000000000000000000000;;			Properties: ModelPropertyList{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reference the model before further initializing (enables recursive structs)
0000000000000000000000000000000000000000;;		b.Models.Put(modelName, sm)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for slice or array
0000000000000000000000000000000000000000;;		if st.Kind() == reflect.Slice || st.Kind() == reflect.Array {
0000000000000000000000000000000000000000;;			b.addModel(st.Elem(), "")
0000000000000000000000000000000000000000;;			return &sm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check for structure or primitive type
0000000000000000000000000000000000000000;;		if st.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return &sm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fullDoc := getDocFromMethodSwaggerDoc2(st)
0000000000000000000000000000000000000000;;		modelDescriptions := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < st.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := st.Field(i)
0000000000000000000000000000000000000000;;			jsonName, modelDescription, prop := b.buildProperty(field, &sm, modelName)
0000000000000000000000000000000000000000;;			if len(modelDescription) > 0 {
0000000000000000000000000000000000000000;;				modelDescriptions = append(modelDescriptions, modelDescription)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// add if not omitted
0000000000000000000000000000000000000000;;			if len(jsonName) != 0 {
0000000000000000000000000000000000000000;;				// update description
0000000000000000000000000000000000000000;;				if fieldDoc, ok := fullDoc[jsonName]; ok {
0000000000000000000000000000000000000000;;					prop.Description = fieldDoc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// update Required
0000000000000000000000000000000000000000;;				if b.isPropertyRequired(field) {
0000000000000000000000000000000000000000;;					sm.Required = append(sm.Required, jsonName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sm.Properties.Put(jsonName, prop)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We always overwrite documentation if SwaggerDoc method exists
0000000000000000000000000000000000000000;;		// "" is special for documenting the struct itself
0000000000000000000000000000000000000000;;		if modelDoc, ok := fullDoc[""]; ok {
0000000000000000000000000000000000000000;;			sm.Description = modelDoc
0000000000000000000000000000000000000000;;		} else if len(modelDescriptions) != 0 {
0000000000000000000000000000000000000000;;			sm.Description = strings.Join(modelDescriptions, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update model builder with completed model
0000000000000000000000000000000000000000;;		b.Models.Put(modelName, sm)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &sm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) isPropertyRequired(field reflect.StructField) bool {
0000000000000000000000000000000000000000;;		required := true
0000000000000000000000000000000000000000;;		if jsonTag := field.Tag.Get("json"); jsonTag != "" {
0000000000000000000000000000000000000000;;			s := strings.Split(jsonTag, ",")
0000000000000000000000000000000000000000;;			if len(s) > 1 && s[1] == "omitempty" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return required
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) buildProperty(field reflect.StructField, model *Model, modelName string) (jsonName, modelDescription string, prop ModelProperty) {
0000000000000000000000000000000000000000;;		jsonName = b.jsonNameOfField(field)
0000000000000000000000000000000000000000;;		if len(jsonName) == 0 {
0000000000000000000000000000000000000000;;			// empty name signals skip property
0000000000000000000000000000000000000000;;			return "", "", prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if field.Name == "XMLName" && field.Type.String() == "xml.Name" {
0000000000000000000000000000000000000000;;			// property is metadata for the xml.Name attribute, can be skipped
0000000000000000000000000000000000000000;;			return "", "", prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tag := field.Tag.Get("modelDescription"); tag != "" {
0000000000000000000000000000000000000000;;			modelDescription = tag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prop.setPropertyMetadata(field)
0000000000000000000000000000000000000000;;		if prop.Type != nil {
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fieldType := field.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if type is doing its own marshalling
0000000000000000000000000000000000000000;;		marshalerType := reflect.TypeOf((*json.Marshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		if fieldType.Implements(marshalerType) {
0000000000000000000000000000000000000000;;			var pType = "string"
0000000000000000000000000000000000000000;;			if prop.Type == nil {
0000000000000000000000000000000000000000;;				prop.Type = &pType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if prop.Format == "" {
0000000000000000000000000000000000000000;;				prop.Format = b.jsonSchemaFormat(b.keyFrom(fieldType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if annotation says it is a string
0000000000000000000000000000000000000000;;		if jsonTag := field.Tag.Get("json"); jsonTag != "" {
0000000000000000000000000000000000000000;;			s := strings.Split(jsonTag, ",")
0000000000000000000000000000000000000000;;			if len(s) > 1 && s[1] == "string" {
0000000000000000000000000000000000000000;;				stringt := "string"
0000000000000000000000000000000000000000;;				prop.Type = &stringt
0000000000000000000000000000000000000000;;				return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldKind := fieldType.Kind()
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case fieldKind == reflect.Struct:
0000000000000000000000000000000000000000;;			jsonName, prop := b.buildStructTypeProperty(field, jsonName, model)
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		case fieldKind == reflect.Slice || fieldKind == reflect.Array:
0000000000000000000000000000000000000000;;			jsonName, prop := b.buildArrayTypeProperty(field, jsonName, modelName)
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		case fieldKind == reflect.Ptr:
0000000000000000000000000000000000000000;;			jsonName, prop := b.buildPointerTypeProperty(field, jsonName, modelName)
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		case fieldKind == reflect.String:
0000000000000000000000000000000000000000;;			stringt := "string"
0000000000000000000000000000000000000000;;			prop.Type = &stringt
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		case fieldKind == reflect.Map:
0000000000000000000000000000000000000000;;			// if it's a map, it's unstructured, and swagger 1.2 can't handle it
0000000000000000000000000000000000000000;;			objectType := "object"
0000000000000000000000000000000000000000;;			prop.Type = &objectType
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldTypeName := b.keyFrom(fieldType)
0000000000000000000000000000000000000000;;		if b.isPrimitiveType(fieldTypeName) {
0000000000000000000000000000000000000000;;			mapped := b.jsonSchemaType(fieldTypeName)
0000000000000000000000000000000000000000;;			prop.Type = &mapped
0000000000000000000000000000000000000000;;			prop.Format = b.jsonSchemaFormat(fieldTypeName)
0000000000000000000000000000000000000000;;			return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modelType := b.keyFrom(fieldType)
0000000000000000000000000000000000000000;;		prop.Ref = &modelType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fieldType.Name() == "" { // override type of anonymous structs
0000000000000000000000000000000000000000;;			nestedTypeName := modelName + "." + jsonName
0000000000000000000000000000000000000000;;			prop.Ref = &nestedTypeName
0000000000000000000000000000000000000000;;			b.addModel(fieldType, nestedTypeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return jsonName, modelDescription, prop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasNamedJSONTag(field reflect.StructField) bool {
0000000000000000000000000000000000000000;;		parts := strings.Split(field.Tag.Get("json"), ",")
0000000000000000000000000000000000000000;;		if len(parts) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, s := range parts[1:] {
0000000000000000000000000000000000000000;;			if s == "inline" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(parts[0]) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) buildStructTypeProperty(field reflect.StructField, jsonName string, model *Model) (nameJson string, prop ModelProperty) {
0000000000000000000000000000000000000000;;		prop.setPropertyMetadata(field)
0000000000000000000000000000000000000000;;		// Check for type override in tag
0000000000000000000000000000000000000000;;		if prop.Type != nil {
0000000000000000000000000000000000000000;;			return jsonName, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fieldType := field.Type
0000000000000000000000000000000000000000;;		// check for anonymous
0000000000000000000000000000000000000000;;		if len(fieldType.Name()) == 0 {
0000000000000000000000000000000000000000;;			// anonymous
0000000000000000000000000000000000000000;;			anonType := model.Id + "." + jsonName
0000000000000000000000000000000000000000;;			b.addModel(fieldType, anonType)
0000000000000000000000000000000000000000;;			prop.Ref = &anonType
0000000000000000000000000000000000000000;;			return jsonName, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if field.Name == fieldType.Name() && field.Anonymous && !hasNamedJSONTag(field) {
0000000000000000000000000000000000000000;;			// embedded struct
0000000000000000000000000000000000000000;;			sub := modelBuilder{new(ModelList), b.Config}
0000000000000000000000000000000000000000;;			sub.addModel(fieldType, "")
0000000000000000000000000000000000000000;;			subKey := sub.keyFrom(fieldType)
0000000000000000000000000000000000000000;;			// merge properties from sub
0000000000000000000000000000000000000000;;			subModel, _ := sub.Models.At(subKey)
0000000000000000000000000000000000000000;;			subModel.Properties.Do(func(k string, v ModelProperty) {
0000000000000000000000000000000000000000;;				model.Properties.Put(k, v)
0000000000000000000000000000000000000000;;				// if subModel says this property is required then include it
0000000000000000000000000000000000000000;;				required := false
0000000000000000000000000000000000000000;;				for _, each := range subModel.Required {
0000000000000000000000000000000000000000;;					if k == each {
0000000000000000000000000000000000000000;;						required = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if required {
0000000000000000000000000000000000000000;;					model.Required = append(model.Required, k)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			// add all new referenced models
0000000000000000000000000000000000000000;;			sub.Models.Do(func(key string, sub Model) {
0000000000000000000000000000000000000000;;				if key != subKey {
0000000000000000000000000000000000000000;;					if _, ok := b.Models.At(key); !ok {
0000000000000000000000000000000000000000;;						b.Models.Put(key, sub)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			// empty name signals skip property
0000000000000000000000000000000000000000;;			return "", prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// simple struct
0000000000000000000000000000000000000000;;		b.addModel(fieldType, "")
0000000000000000000000000000000000000000;;		var pType = b.keyFrom(fieldType)
0000000000000000000000000000000000000000;;		prop.Ref = &pType
0000000000000000000000000000000000000000;;		return jsonName, prop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) buildArrayTypeProperty(field reflect.StructField, jsonName, modelName string) (nameJson string, prop ModelProperty) {
0000000000000000000000000000000000000000;;		// check for type override in tags
0000000000000000000000000000000000000000;;		prop.setPropertyMetadata(field)
0000000000000000000000000000000000000000;;		if prop.Type != nil {
0000000000000000000000000000000000000000;;			return jsonName, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fieldType := field.Type
0000000000000000000000000000000000000000;;		if fieldType.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;			stringt := "string"
0000000000000000000000000000000000000000;;			prop.Type = &stringt
0000000000000000000000000000000000000000;;			return jsonName, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var pType = "array"
0000000000000000000000000000000000000000;;		prop.Type = &pType
0000000000000000000000000000000000000000;;		isPrimitive := b.isPrimitiveType(fieldType.Elem().Name())
0000000000000000000000000000000000000000;;		elemTypeName := b.getElementTypeName(modelName, jsonName, fieldType.Elem())
0000000000000000000000000000000000000000;;		prop.Items = new(Item)
0000000000000000000000000000000000000000;;		if isPrimitive {
0000000000000000000000000000000000000000;;			mapped := b.jsonSchemaType(elemTypeName)
0000000000000000000000000000000000000000;;			prop.Items.Type = &mapped
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			prop.Items.Ref = &elemTypeName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// add|overwrite model for element type
0000000000000000000000000000000000000000;;		if fieldType.Elem().Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			fieldType = fieldType.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isPrimitive {
0000000000000000000000000000000000000000;;			b.addModel(fieldType.Elem(), elemTypeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return jsonName, prop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) buildPointerTypeProperty(field reflect.StructField, jsonName, modelName string) (nameJson string, prop ModelProperty) {
0000000000000000000000000000000000000000;;		prop.setPropertyMetadata(field)
0000000000000000000000000000000000000000;;		// Check for type override in tags
0000000000000000000000000000000000000000;;		if prop.Type != nil {
0000000000000000000000000000000000000000;;			return jsonName, prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fieldType := field.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// override type of pointer to list-likes
0000000000000000000000000000000000000000;;		if fieldType.Elem().Kind() == reflect.Slice || fieldType.Elem().Kind() == reflect.Array {
0000000000000000000000000000000000000000;;			var pType = "array"
0000000000000000000000000000000000000000;;			prop.Type = &pType
0000000000000000000000000000000000000000;;			isPrimitive := b.isPrimitiveType(fieldType.Elem().Elem().Name())
0000000000000000000000000000000000000000;;			elemName := b.getElementTypeName(modelName, jsonName, fieldType.Elem().Elem())
0000000000000000000000000000000000000000;;			if isPrimitive {
0000000000000000000000000000000000000000;;				primName := b.jsonSchemaType(elemName)
0000000000000000000000000000000000000000;;				prop.Items = &Item{Ref: &primName}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				prop.Items = &Item{Ref: &elemName}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isPrimitive {
0000000000000000000000000000000000000000;;				// add|overwrite model for element type
0000000000000000000000000000000000000000;;				b.addModel(fieldType.Elem().Elem(), elemName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// non-array, pointer type
0000000000000000000000000000000000000000;;			fieldTypeName := b.keyFrom(fieldType.Elem())
0000000000000000000000000000000000000000;;			var pType = b.jsonSchemaType(fieldTypeName) // no star, include pkg path
0000000000000000000000000000000000000000;;			if b.isPrimitiveType(fieldTypeName) {
0000000000000000000000000000000000000000;;				prop.Type = &pType
0000000000000000000000000000000000000000;;				prop.Format = b.jsonSchemaFormat(fieldTypeName)
0000000000000000000000000000000000000000;;				return jsonName, prop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prop.Ref = &pType
0000000000000000000000000000000000000000;;			elemName := ""
0000000000000000000000000000000000000000;;			if fieldType.Elem().Name() == "" {
0000000000000000000000000000000000000000;;				elemName = modelName + "." + jsonName
0000000000000000000000000000000000000000;;				prop.Ref = &elemName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.addModel(fieldType.Elem(), elemName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return jsonName, prop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) getElementTypeName(modelName, jsonName string, t reflect.Type) string {
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Name() == "" {
0000000000000000000000000000000000000000;;			return modelName + "." + jsonName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.keyFrom(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) keyFrom(st reflect.Type) string {
0000000000000000000000000000000000000000;;		key := st.String()
0000000000000000000000000000000000000000;;		if b.Config != nil && b.Config.ModelTypeNameHandler != nil {
0000000000000000000000000000000000000000;;			if name, ok := b.Config.ModelTypeNameHandler(st); ok {
0000000000000000000000000000000000000000;;				key = name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(st.Name()) == 0 { // unnamed type
0000000000000000000000000000000000000000;;			// Swagger UI has special meaning for [
0000000000000000000000000000000000000000;;			key = strings.Replace(key, "[]", "||", -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// see also https://golang.org/ref/spec#Numeric_types
0000000000000000000000000000000000000000;;	func (b modelBuilder) isPrimitiveType(modelName string) bool {
0000000000000000000000000000000000000000;;		if len(modelName) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Contains("uint uint8 uint16 uint32 uint64 int int8 int16 int32 int64 float32 float64 bool string byte rune time.Time", modelName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// jsonNameOfField returns the name of the field as it should appear in JSON format
0000000000000000000000000000000000000000;;	// An empty string indicates that this field is not part of the JSON representation
0000000000000000000000000000000000000000;;	func (b modelBuilder) jsonNameOfField(field reflect.StructField) string {
0000000000000000000000000000000000000000;;		if jsonTag := field.Tag.Get("json"); jsonTag != "" {
0000000000000000000000000000000000000000;;			s := strings.Split(jsonTag, ",")
0000000000000000000000000000000000000000;;			if s[0] == "-" {
0000000000000000000000000000000000000000;;				// empty name signals skip property
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			} else if s[0] != "" {
0000000000000000000000000000000000000000;;				return s[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return field.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// see also http://json-schema.org/latest/json-schema-core.html#anchor8
0000000000000000000000000000000000000000;;	func (b modelBuilder) jsonSchemaType(modelName string) string {
0000000000000000000000000000000000000000;;		schemaMap := map[string]string{
0000000000000000000000000000000000000000;;			"uint":   "integer",
0000000000000000000000000000000000000000;;			"uint8":  "integer",
0000000000000000000000000000000000000000;;			"uint16": "integer",
0000000000000000000000000000000000000000;;			"uint32": "integer",
0000000000000000000000000000000000000000;;			"uint64": "integer",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"int":   "integer",
0000000000000000000000000000000000000000;;			"int8":  "integer",
0000000000000000000000000000000000000000;;			"int16": "integer",
0000000000000000000000000000000000000000;;			"int32": "integer",
0000000000000000000000000000000000000000;;			"int64": "integer",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"byte":      "integer",
0000000000000000000000000000000000000000;;			"float64":   "number",
0000000000000000000000000000000000000000;;			"float32":   "number",
0000000000000000000000000000000000000000;;			"bool":      "boolean",
0000000000000000000000000000000000000000;;			"time.Time": "string",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapped, ok := schemaMap[modelName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return modelName // use as is (custom or struct)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mapped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b modelBuilder) jsonSchemaFormat(modelName string) string {
0000000000000000000000000000000000000000;;		if b.Config != nil && b.Config.SchemaFormatHandler != nil {
0000000000000000000000000000000000000000;;			if mapped := b.Config.SchemaFormatHandler(modelName); mapped != "" {
0000000000000000000000000000000000000000;;				return mapped
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schemaMap := map[string]string{
0000000000000000000000000000000000000000;;			"int":        "int32",
0000000000000000000000000000000000000000;;			"int32":      "int32",
0000000000000000000000000000000000000000;;			"int64":      "int64",
0000000000000000000000000000000000000000;;			"byte":       "byte",
0000000000000000000000000000000000000000;;			"uint":       "integer",
0000000000000000000000000000000000000000;;			"uint8":      "byte",
0000000000000000000000000000000000000000;;			"float64":    "double",
0000000000000000000000000000000000000000;;			"float32":    "float",
0000000000000000000000000000000000000000;;			"time.Time":  "date-time",
0000000000000000000000000000000000000000;;			"*time.Time": "date-time",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapped, ok := schemaMap[modelName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "" // no format
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mapped
0000000000000000000000000000000000000000;;	}
