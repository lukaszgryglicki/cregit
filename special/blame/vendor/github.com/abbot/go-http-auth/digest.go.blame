0000000000000000000000000000000000000000;;	package auth
ddb91896b60df07452d87846c6343678b1c48dde;Godeps/_workspace/src/github.com/abbot/go-http-auth/digest.go[Godeps/_workspace/src/github.com/abbot/go-http-auth/digest.go][vendor/github.com/abbot/go-http-auth/digest.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type digest_client struct {
0000000000000000000000000000000000000000;;		nc        uint64
0000000000000000000000000000000000000000;;		last_seen int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DigestAuth struct {
0000000000000000000000000000000000000000;;		Realm            string
0000000000000000000000000000000000000000;;		Opaque           string
0000000000000000000000000000000000000000;;		Secrets          SecretProvider
0000000000000000000000000000000000000000;;		PlainTextSecrets bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* 
0000000000000000000000000000000000000000;;		 Approximate size of Client's Cache. When actual number of
0000000000000000000000000000000000000000;;		 tracked client nonces exceeds
0000000000000000000000000000000000000000;;		 ClientCacheSize+ClientCacheTolerance, ClientCacheTolerance*2
0000000000000000000000000000000000000000;;		 older entries are purged.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		ClientCacheSize      int
0000000000000000000000000000000000000000;;		ClientCacheTolerance int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clients map[string]*digest_client
0000000000000000000000000000000000000000;;		mutex   sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type digest_cache_entry struct {
0000000000000000000000000000000000000000;;		nonce     string
0000000000000000000000000000000000000000;;		last_seen int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type digest_cache []digest_cache_entry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c digest_cache) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return c[i].last_seen < c[j].last_seen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c digest_cache) Len() int {
0000000000000000000000000000000000000000;;		return len(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c digest_cache) Swap(i, j int) {
0000000000000000000000000000000000000000;;		c[i], c[j] = c[j], c[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 Remove count oldest entries from DigestAuth.clients
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (a *DigestAuth) Purge(count int) {
0000000000000000000000000000000000000000;;		entries := make([]digest_cache_entry, 0, len(a.clients))
0000000000000000000000000000000000000000;;		for nonce, client := range a.clients {
0000000000000000000000000000000000000000;;			entries = append(entries, digest_cache_entry{nonce, client.last_seen})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cache := digest_cache(entries)
0000000000000000000000000000000000000000;;		sort.Sort(cache)
0000000000000000000000000000000000000000;;		for _, client := range cache[:count] {
0000000000000000000000000000000000000000;;			delete(a.clients, client.nonce)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 http.Handler for DigestAuth which initiates the authentication process
0000000000000000000000000000000000000000;;	 (or requires reauthentication).
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (a *DigestAuth) RequireAuth(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if len(a.clients) > a.ClientCacheSize+a.ClientCacheTolerance {
0000000000000000000000000000000000000000;;			a.Purge(a.ClientCacheTolerance * 2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nonce := RandomKey()
0000000000000000000000000000000000000000;;		a.clients[nonce] = &digest_client{nc: 0, last_seen: time.Now().UnixNano()}
0000000000000000000000000000000000000000;;		w.Header().Set("WWW-Authenticate",
0000000000000000000000000000000000000000;;			fmt.Sprintf(`Digest realm="%s", nonce="%s", opaque="%s", algorithm="MD5", qop="auth"`,
0000000000000000000000000000000000000000;;				a.Realm, nonce, a.Opaque))
0000000000000000000000000000000000000000;;		w.WriteHeader(401)
0000000000000000000000000000000000000000;;		w.Write([]byte("401 Unauthorized\n"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 Parse Authorization header from the http.Request. Returns a map of
0000000000000000000000000000000000000000;;	 auth parameters or nil if the header is not a valid parsable Digest
0000000000000000000000000000000000000000;;	 auth header.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func DigestAuthParams(r *http.Request) map[string]string {
0000000000000000000000000000000000000000;;		s := strings.SplitN(r.Header.Get("Authorization"), " ", 2)
0000000000000000000000000000000000000000;;		if len(s) != 2 || s[0] != "Digest" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := map[string]string{}
0000000000000000000000000000000000000000;;		for _, kv := range strings.Split(s[1], ",") {
0000000000000000000000000000000000000000;;			parts := strings.SplitN(kv, "=", 2)
0000000000000000000000000000000000000000;;			if len(parts) != 2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result[strings.Trim(parts[0], "\" ")] = strings.Trim(parts[1], "\" ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* 
0000000000000000000000000000000000000000;;	 Check if request contains valid authentication data. Returns a pair
0000000000000000000000000000000000000000;;	 of username, authinfo where username is the name of the authenticated
0000000000000000000000000000000000000000;;	 user or an empty string and authinfo is the contents for the optional
0000000000000000000000000000000000000000;;	 Authentication-Info response header.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (da *DigestAuth) CheckAuth(r *http.Request) (username string, authinfo *string) {
0000000000000000000000000000000000000000;;		da.mutex.Lock()
0000000000000000000000000000000000000000;;		defer da.mutex.Unlock()
0000000000000000000000000000000000000000;;		username = ""
0000000000000000000000000000000000000000;;		authinfo = nil
0000000000000000000000000000000000000000;;		auth := DigestAuthParams(r)
0000000000000000000000000000000000000000;;		if auth == nil || da.Opaque != auth["opaque"] || auth["algorithm"] != "MD5" || auth["qop"] != "auth" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the requested URI matches auth header
0000000000000000000000000000000000000000;;		switch u, err := url.Parse(auth["uri"]); {
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case r.URL == nil:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case len(u.Path) > len(r.URL.Path):
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case !strings.HasPrefix(r.URL.Path, u.Path):
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HA1 := da.Secrets(auth["username"], da.Realm)
0000000000000000000000000000000000000000;;		if da.PlainTextSecrets {
0000000000000000000000000000000000000000;;			HA1 = H(auth["username"] + ":" + da.Realm + ":" + HA1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		HA2 := H(r.Method + ":" + auth["uri"])
0000000000000000000000000000000000000000;;		KD := H(strings.Join([]string{HA1, auth["nonce"], auth["nc"], auth["cnonce"], auth["qop"], HA2}, ":"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if KD != auth["response"] {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// At this point crypto checks are completed and validated.
0000000000000000000000000000000000000000;;		// Now check if the session is valid.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nc, err := strconv.ParseUint(auth["nc"], 16, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client, ok := da.clients[auth["nonce"]]; !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if client.nc != 0 && client.nc >= nc {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			client.nc = nc
0000000000000000000000000000000000000000;;			client.last_seen = time.Now().UnixNano()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp_HA2 := H(":" + auth["uri"])
0000000000000000000000000000000000000000;;		rspauth := H(strings.Join([]string{HA1, auth["nonce"], auth["nc"], auth["cnonce"], auth["qop"], resp_HA2}, ":"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info := fmt.Sprintf(`qop="auth", rspauth="%s", cnonce="%s", nc="%s"`, rspauth, auth["cnonce"], auth["nc"])
0000000000000000000000000000000000000000;;		return auth["username"], &info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 Default values for ClientCacheSize and ClientCacheTolerance for DigestAuth
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	const DefaultClientCacheSize = 1000
0000000000000000000000000000000000000000;;	const DefaultClientCacheTolerance = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* 
0000000000000000000000000000000000000000;;	 Wrap returns an Authenticator which uses HTTP Digest
0000000000000000000000000000000000000000;;	 authentication. Arguments:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 realm: The authentication realm.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 secrets: SecretProvider which must return HA1 digests for the same
0000000000000000000000000000000000000000;;	 realm as above.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (a *DigestAuth) Wrap(wrapped AuthenticatedHandlerFunc) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			if username, authinfo := a.CheckAuth(r); username == "" {
0000000000000000000000000000000000000000;;				a.RequireAuth(w, r)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ar := &AuthenticatedRequest{Request: *r, Username: username}
0000000000000000000000000000000000000000;;				if authinfo != nil {
0000000000000000000000000000000000000000;;					w.Header().Set("Authentication-Info", *authinfo)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wrapped(w, ar)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* 
0000000000000000000000000000000000000000;;	 JustCheck returns function which converts an http.HandlerFunc into a
0000000000000000000000000000000000000000;;	 http.HandlerFunc which requires authentication. Username is passed as
0000000000000000000000000000000000000000;;	 an extra X-Authenticated-Username header.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (a *DigestAuth) JustCheck(wrapped http.HandlerFunc) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return a.Wrap(func(w http.ResponseWriter, ar *AuthenticatedRequest) {
0000000000000000000000000000000000000000;;			ar.Header.Set("X-Authenticated-Username", ar.Username)
0000000000000000000000000000000000000000;;			wrapped(w, &ar.Request)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDigestAuthenticator(realm string, secrets SecretProvider) *DigestAuth {
0000000000000000000000000000000000000000;;		da := &DigestAuth{
0000000000000000000000000000000000000000;;			Opaque:               RandomKey(),
0000000000000000000000000000000000000000;;			Realm:                realm,
0000000000000000000000000000000000000000;;			Secrets:              secrets,
0000000000000000000000000000000000000000;;			PlainTextSecrets:     false,
0000000000000000000000000000000000000000;;			ClientCacheSize:      DefaultClientCacheSize,
0000000000000000000000000000000000000000;;			ClientCacheTolerance: DefaultClientCacheTolerance,
0000000000000000000000000000000000000000;;			clients:              map[string]*digest_client{}}
0000000000000000000000000000000000000000;;		return da
0000000000000000000000000000000000000000;;	}
