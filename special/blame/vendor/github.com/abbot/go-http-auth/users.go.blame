0000000000000000000000000000000000000000;;	package auth
ddb91896b60df07452d87846c6343678b1c48dde;Godeps/_workspace/src/github.com/abbot/go-http-auth/users.go[Godeps/_workspace/src/github.com/abbot/go-http-auth/users.go][vendor/github.com/abbot/go-http-auth/users.go];	
0000000000000000000000000000000000000000;;	import "encoding/csv"
0000000000000000000000000000000000000000;;	import "os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* 
0000000000000000000000000000000000000000;;	 SecretProvider is used by authenticators. Takes user name and realm
0000000000000000000000000000000000000000;;	 as an argument, returns secret required for authentication (HA1 for
0000000000000000000000000000000000000000;;	 digest authentication, properly encrypted password for basic).
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type SecretProvider func(user, realm string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 Common functions for file auto-reloading
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		Info os.FileInfo
0000000000000000000000000000000000000000;;		/* must be set in inherited types during initialization */
0000000000000000000000000000000000000000;;		Reload func()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) ReloadIfNeeded() {
0000000000000000000000000000000000000000;;		info, err := os.Stat(f.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.Info == nil || f.Info.ModTime() != info.ModTime() {
0000000000000000000000000000000000000000;;			f.Info = info
0000000000000000000000000000000000000000;;			f.Reload()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 Structure used for htdigest file authentication. Users map realms to
0000000000000000000000000000000000000000;;	 maps of users to their HA1 digests.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type HtdigestFile struct {
0000000000000000000000000000000000000000;;		File
0000000000000000000000000000000000000000;;		Users map[string]map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reload_htdigest(hf *HtdigestFile) {
0000000000000000000000000000000000000000;;		r, err := os.Open(hf.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csv_reader := csv.NewReader(r)
0000000000000000000000000000000000000000;;		csv_reader.Comma = ':'
0000000000000000000000000000000000000000;;		csv_reader.Comment = '#'
0000000000000000000000000000000000000000;;		csv_reader.TrimLeadingSpace = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		records, err := csv_reader.ReadAll()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hf.Users = make(map[string]map[string]string)
0000000000000000000000000000000000000000;;		for _, record := range records {
0000000000000000000000000000000000000000;;			_, exists := hf.Users[record[1]]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				hf.Users[record[1]] = make(map[string]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hf.Users[record[1]][record[0]] = record[2]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 SecretProvider implementation based on htdigest-formated files. Will
0000000000000000000000000000000000000000;;	 reload htdigest file on changes. Will panic on syntax errors in
0000000000000000000000000000000000000000;;	 htdigest files.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func HtdigestFileProvider(filename string) SecretProvider {
0000000000000000000000000000000000000000;;		hf := &HtdigestFile{File: File{Path: filename}}
0000000000000000000000000000000000000000;;		hf.Reload = func() { reload_htdigest(hf) }
0000000000000000000000000000000000000000;;		return func(user, realm string) string {
0000000000000000000000000000000000000000;;			hf.ReloadIfNeeded()
0000000000000000000000000000000000000000;;			_, exists := hf.Users[realm]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			digest, exists := hf.Users[realm][user]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return digest
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 Structure used for htdigest file authentication. Users map users to
0000000000000000000000000000000000000000;;	 their salted encrypted password
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type HtpasswdFile struct {
0000000000000000000000000000000000000000;;		File
0000000000000000000000000000000000000000;;		Users map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reload_htpasswd(h *HtpasswdFile) {
0000000000000000000000000000000000000000;;		r, err := os.Open(h.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		csv_reader := csv.NewReader(r)
0000000000000000000000000000000000000000;;		csv_reader.Comma = ':'
0000000000000000000000000000000000000000;;		csv_reader.Comment = '#'
0000000000000000000000000000000000000000;;		csv_reader.TrimLeadingSpace = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		records, err := csv_reader.ReadAll()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.Users = make(map[string]string)
0000000000000000000000000000000000000000;;		for _, record := range records {
0000000000000000000000000000000000000000;;			h.Users[record[0]] = record[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 SecretProvider implementation based on htpasswd-formated files. Will
0000000000000000000000000000000000000000;;	 reload htpasswd file on changes. Will panic on syntax errors in
0000000000000000000000000000000000000000;;	 htpasswd files. Realm argument of the SecretProvider is ignored.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func HtpasswdFileProvider(filename string) SecretProvider {
0000000000000000000000000000000000000000;;		h := &HtpasswdFile{File: File{Path: filename}}
0000000000000000000000000000000000000000;;		h.Reload = func() { reload_htpasswd(h) }
0000000000000000000000000000000000000000;;		return func(user, realm string) string {
0000000000000000000000000000000000000000;;			h.ReloadIfNeeded()
0000000000000000000000000000000000000000;;			password, exists := h.Users[user]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return password
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
