0000000000000000000000000000000000000000;;	package auth
ddb91896b60df07452d87846c6343678b1c48dde;Godeps/_workspace/src/github.com/abbot/go-http-auth/basic.go[Godeps/_workspace/src/github.com/abbot/go-http-auth/basic.go][vendor/github.com/abbot/go-http-auth/basic.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BasicAuth struct {
0000000000000000000000000000000000000000;;		Realm   string
0000000000000000000000000000000000000000;;		Secrets SecretProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 Checks the username/password combination from the request. Returns
0000000000000000000000000000000000000000;;	 either an empty string (authentication failed) or the name of the
0000000000000000000000000000000000000000;;	 authenticated user.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 Supports MD5 and SHA1 password entries
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (a *BasicAuth) CheckAuth(r *http.Request) string {
0000000000000000000000000000000000000000;;		s := strings.SplitN(r.Header.Get("Authorization"), " ", 2)
0000000000000000000000000000000000000000;;		if len(s) != 2 || s[0] != "Basic" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := base64.StdEncoding.DecodeString(s[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pair := strings.SplitN(string(b), ":", 2)
0000000000000000000000000000000000000000;;		if len(pair) != 2 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		passwd := a.Secrets(pair[0], a.Realm)
0000000000000000000000000000000000000000;;		if passwd == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(passwd, "{SHA}") {
0000000000000000000000000000000000000000;;			d := sha1.New()
0000000000000000000000000000000000000000;;			d.Write([]byte(pair[1]))
0000000000000000000000000000000000000000;;			if passwd[5:] != base64.StdEncoding.EncodeToString(d.Sum(nil)) {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e := NewMD5Entry(passwd)
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if passwd != string(MD5Crypt([]byte(pair[1]), e.Salt, e.Magic)) {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pair[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 http.Handler for BasicAuth which initiates the authentication process
0000000000000000000000000000000000000000;;	 (or requires reauthentication).
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (a *BasicAuth) RequireAuth(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		w.Header().Set("WWW-Authenticate", `Basic realm="`+a.Realm+`"`)
0000000000000000000000000000000000000000;;		w.WriteHeader(401)
0000000000000000000000000000000000000000;;		w.Write([]byte("401 Unauthorized\n"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 BasicAuthenticator returns a function, which wraps an
0000000000000000000000000000000000000000;;	 AuthenticatedHandlerFunc converting it to http.HandlerFunc. This
0000000000000000000000000000000000000000;;	 wrapper function checks the authentication and either sends back
0000000000000000000000000000000000000000;;	 required authentication headers, or calls the wrapped function with
0000000000000000000000000000000000000000;;	 authenticated username in the AuthenticatedRequest.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (a *BasicAuth) Wrap(wrapped AuthenticatedHandlerFunc) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			if username := a.CheckAuth(r); username == "" {
0000000000000000000000000000000000000000;;				a.RequireAuth(w, r)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ar := &AuthenticatedRequest{Request: *r, Username: username}
0000000000000000000000000000000000000000;;				wrapped(w, ar)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBasicAuthenticator(realm string, secrets SecretProvider) *BasicAuth {
0000000000000000000000000000000000000000;;		return &BasicAuth{Realm: realm, Secrets: secrets}
0000000000000000000000000000000000000000;;	}
