0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Provides an HTTP Transport that implements the `RoundTripper` interface and
0000000000000000000000000000000000000000;;	can be used as a built in replacement for the standard library's, providing:
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;		* connection timeouts
0000000000000000000000000000000000000000;;		* request timeouts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This is a thin wrapper around `http.Transport` that sets dial timeouts and uses
0000000000000000000000000000000000000000;;	Go's internal timer scheduler to call the Go 1.1+ `CancelRequest()` API.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package httpclient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the current version of the package
0000000000000000000000000000000000000000;;	func Version() string {
0000000000000000000000000000000000000000;;		return "0.4.1"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transport implements the RoundTripper interface and can be used as a replacement
0000000000000000000000000000000000000000;;	// for Go's built in http.Transport implementing end-to-end request timeouts.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	transport := &httpclient.Transport{
0000000000000000000000000000000000000000;;	// 	    ConnectTimeout: 1*time.Second,
0000000000000000000000000000000000000000;;	// 	    ResponseHeaderTimeout: 5*time.Second,
0000000000000000000000000000000000000000;;	// 	    RequestTimeout: 10*time.Second,
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	defer transport.Close()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	client := &http.Client{Transport: transport}
0000000000000000000000000000000000000000;;	// 	req, _ := http.NewRequest("GET", "http://127.0.0.1/test", nil)
0000000000000000000000000000000000000000;;	// 	resp, err := client.Do(req)
0000000000000000000000000000000000000000;;	// 	if err != nil {
0000000000000000000000000000000000000000;;	// 	    return err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	defer resp.Body.Close()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Transport struct {
0000000000000000000000000000000000000000;;		// Proxy specifies a function to return a proxy for a given
0000000000000000000000000000000000000000;;		// *http.Request. If the function returns a non-nil error, the
0000000000000000000000000000000000000000;;		// request is aborted with the provided error.
0000000000000000000000000000000000000000;;		// If Proxy is nil or returns a nil *url.URL, no proxy is used.
0000000000000000000000000000000000000000;;		Proxy func(*http.Request) (*url.URL, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dial specifies the dial function for creating TCP
0000000000000000000000000000000000000000;;		// connections. This will override the Transport's ConnectTimeout and
0000000000000000000000000000000000000000;;		// ReadWriteTimeout settings.
0000000000000000000000000000000000000000;;		// If Dial is nil, a dialer is generated on demand matching the Transport's
0000000000000000000000000000000000000000;;		// options.
0000000000000000000000000000000000000000;;		Dial func(network, addr string) (net.Conn, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSClientConfig specifies the TLS configuration to use with
0000000000000000000000000000000000000000;;		// tls.Client. If nil, the default configuration is used.
0000000000000000000000000000000000000000;;		TLSClientConfig *tls.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DisableKeepAlives, if true, prevents re-use of TCP connections
0000000000000000000000000000000000000000;;		// between different HTTP requests.
0000000000000000000000000000000000000000;;		DisableKeepAlives bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DisableCompression, if true, prevents the Transport from
0000000000000000000000000000000000000000;;		// requesting compression with an "Accept-Encoding: gzip"
0000000000000000000000000000000000000000;;		// request header when the Request contains no existing
0000000000000000000000000000000000000000;;		// Accept-Encoding value. If the Transport requests gzip on
0000000000000000000000000000000000000000;;		// its own and gets a gzipped response, it's transparently
0000000000000000000000000000000000000000;;		// decoded in the Response.Body. However, if the user
0000000000000000000000000000000000000000;;		// explicitly requested gzip it is not automatically
0000000000000000000000000000000000000000;;		// uncompressed.
0000000000000000000000000000000000000000;;		DisableCompression bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxIdleConnsPerHost, if non-zero, controls the maximum idle
0000000000000000000000000000000000000000;;		// (keep-alive) to keep per-host.  If zero,
0000000000000000000000000000000000000000;;		// http.DefaultMaxIdleConnsPerHost is used.
0000000000000000000000000000000000000000;;		MaxIdleConnsPerHost int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConnectTimeout, if non-zero, is the maximum amount of time a dial will wait for
0000000000000000000000000000000000000000;;		// a connect to complete.
0000000000000000000000000000000000000000;;		ConnectTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResponseHeaderTimeout, if non-zero, specifies the amount of
0000000000000000000000000000000000000000;;		// time to wait for a server's response headers after fully
0000000000000000000000000000000000000000;;		// writing the request (including its body, if any). This
0000000000000000000000000000000000000000;;		// time does not include the time to read the response body.
0000000000000000000000000000000000000000;;		ResponseHeaderTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequestTimeout, if non-zero, specifies the amount of time for the entire
0000000000000000000000000000000000000000;;		// request to complete (including all of the above timeouts + entire response body).
0000000000000000000000000000000000000000;;		// This should never be less than the sum total of the above two timeouts.
0000000000000000000000000000000000000000;;		RequestTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadWriteTimeout, if non-zero, will set a deadline for every Read and
0000000000000000000000000000000000000000;;		// Write operation on the request connection.
0000000000000000000000000000000000000000;;		ReadWriteTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TCPWriteBufferSize, the size of the operating system's write
0000000000000000000000000000000000000000;;		// buffer associated with the connection.
0000000000000000000000000000000000000000;;		TCPWriteBufferSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TCPReadBuffserSize, the size of the operating system's read
0000000000000000000000000000000000000000;;		// buffer associated with the connection.
0000000000000000000000000000000000000000;;		TCPReadBufferSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		starter   sync.Once
0000000000000000000000000000000000000000;;		transport *http.Transport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close cleans up the Transport, currently a no-op
0000000000000000000000000000000000000000;;	func (t *Transport) Close() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) lazyStart() {
0000000000000000000000000000000000000000;;		if t.Dial == nil {
0000000000000000000000000000000000000000;;			t.Dial = func(netw, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;				c, err := net.DialTimeout(netw, addr, t.ConnectTimeout)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if t.TCPReadBufferSize != 0 || t.TCPWriteBufferSize != 0 {
0000000000000000000000000000000000000000;;					if tcpCon, ok := c.(*net.TCPConn); ok {
0000000000000000000000000000000000000000;;						if t.TCPWriteBufferSize != 0 {
0000000000000000000000000000000000000000;;							if err = tcpCon.SetWriteBuffer(t.TCPWriteBufferSize); err != nil {
0000000000000000000000000000000000000000;;								return nil, err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if t.TCPReadBufferSize != 0 {
0000000000000000000000000000000000000000;;							if err = tcpCon.SetReadBuffer(t.TCPReadBufferSize); err != nil {
0000000000000000000000000000000000000000;;								return nil, err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						err = errors.New("Not Tcp Connection")
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if t.ReadWriteTimeout > 0 {
0000000000000000000000000000000000000000;;					timeoutConn := &rwTimeoutConn{
0000000000000000000000000000000000000000;;						TCPConn:   c.(*net.TCPConn),
0000000000000000000000000000000000000000;;						rwTimeout: t.ReadWriteTimeout,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return timeoutConn, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.transport = &http.Transport{
0000000000000000000000000000000000000000;;			Dial:                  t.Dial,
0000000000000000000000000000000000000000;;			Proxy:                 t.Proxy,
0000000000000000000000000000000000000000;;			TLSClientConfig:       t.TLSClientConfig,
0000000000000000000000000000000000000000;;			DisableKeepAlives:     t.DisableKeepAlives,
0000000000000000000000000000000000000000;;			DisableCompression:    t.DisableCompression,
0000000000000000000000000000000000000000;;			MaxIdleConnsPerHost:   t.MaxIdleConnsPerHost,
0000000000000000000000000000000000000000;;			ResponseHeaderTimeout: t.ResponseHeaderTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		t.starter.Do(t.lazyStart)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.transport.CancelRequest(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) CloseIdleConnections() {
0000000000000000000000000000000000000000;;		t.starter.Do(t.lazyStart)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.transport.CloseIdleConnections()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) RegisterProtocol(scheme string, rt http.RoundTripper) {
0000000000000000000000000000000000000000;;		t.starter.Do(t.lazyStart)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.transport.RegisterProtocol(scheme, rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) RoundTrip(req *http.Request) (resp *http.Response, err error) {
0000000000000000000000000000000000000000;;		t.starter.Do(t.lazyStart)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.RequestTimeout > 0 {
0000000000000000000000000000000000000000;;			timer := time.AfterFunc(t.RequestTimeout, func() {
0000000000000000000000000000000000000000;;				t.transport.CancelRequest(req)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err = t.transport.RoundTrip(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				timer.Stop()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				resp.Body = &bodyCloseInterceptor{ReadCloser: resp.Body, timer: timer}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			resp, err = t.transport.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bodyCloseInterceptor struct {
0000000000000000000000000000000000000000;;		io.ReadCloser
0000000000000000000000000000000000000000;;		timer *time.Timer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bci *bodyCloseInterceptor) Close() error {
0000000000000000000000000000000000000000;;		bci.timer.Stop()
0000000000000000000000000000000000000000;;		return bci.ReadCloser.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A net.Conn that sets a deadline for every Read or Write operation
0000000000000000000000000000000000000000;;	type rwTimeoutConn struct {
0000000000000000000000000000000000000000;;		*net.TCPConn
0000000000000000000000000000000000000000;;		rwTimeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rwTimeoutConn) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		err := c.TCPConn.SetDeadline(time.Now().Add(c.rwTimeout))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.TCPConn.Read(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rwTimeoutConn) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		err := c.TCPConn.SetDeadline(time.Now().Add(c.rwTimeout))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.TCPConn.Write(b)
0000000000000000000000000000000000000000;;	}
