0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2013 Google Inc.
0d329cfb4f5d476524674aaaaac60bc457a297ec;Godeps/_workspace/src/github.com/golang/groupcache/lru/lru.go[Godeps/_workspace/src/github.com/golang/groupcache/lru/lru.go][vendor/github.com/golang/groupcache/lru/lru.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package lru implements an LRU cache.
0000000000000000000000000000000000000000;;	package lru
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "container/list"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cache is an LRU cache. It is not safe for concurrent access.
0000000000000000000000000000000000000000;;	type Cache struct {
0000000000000000000000000000000000000000;;		// MaxEntries is the maximum number of cache entries before
0000000000000000000000000000000000000000;;		// an item is evicted. Zero means no limit.
0000000000000000000000000000000000000000;;		MaxEntries int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OnEvicted optionally specificies a callback function to be
0000000000000000000000000000000000000000;;		// executed when an entry is purged from the cache.
0000000000000000000000000000000000000000;;		OnEvicted func(key Key, value interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ll    *list.List
0000000000000000000000000000000000000000;;		cache map[interface{}]*list.Element
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Key may be any value that is comparable. See http://golang.org/ref/spec#Comparison_operators
0000000000000000000000000000000000000000;;	type Key interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type entry struct {
0000000000000000000000000000000000000000;;		key   Key
0000000000000000000000000000000000000000;;		value interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new Cache.
0000000000000000000000000000000000000000;;	// If maxEntries is zero, the cache has no limit and it's assumed
0000000000000000000000000000000000000000;;	// that eviction is done by the caller.
0000000000000000000000000000000000000000;;	func New(maxEntries int) *Cache {
0000000000000000000000000000000000000000;;		return &Cache{
0000000000000000000000000000000000000000;;			MaxEntries: maxEntries,
0000000000000000000000000000000000000000;;			ll:         list.New(),
0000000000000000000000000000000000000000;;			cache:      make(map[interface{}]*list.Element),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a value to the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) Add(key Key, value interface{}) {
0000000000000000000000000000000000000000;;		if c.cache == nil {
0000000000000000000000000000000000000000;;			c.cache = make(map[interface{}]*list.Element)
0000000000000000000000000000000000000000;;			c.ll = list.New()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, ok := c.cache[key]; ok {
0000000000000000000000000000000000000000;;			c.ll.MoveToFront(ee)
0000000000000000000000000000000000000000;;			ee.Value.(*entry).value = value
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ele := c.ll.PushFront(&entry{key, value})
0000000000000000000000000000000000000000;;		c.cache[key] = ele
0000000000000000000000000000000000000000;;		if c.MaxEntries != 0 && c.ll.Len() > c.MaxEntries {
0000000000000000000000000000000000000000;;			c.RemoveOldest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get looks up a key's value from the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) Get(key Key) (value interface{}, ok bool) {
0000000000000000000000000000000000000000;;		if c.cache == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ele, hit := c.cache[key]; hit {
0000000000000000000000000000000000000000;;			c.ll.MoveToFront(ele)
0000000000000000000000000000000000000000;;			return ele.Value.(*entry).value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the provided key from the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) Remove(key Key) {
0000000000000000000000000000000000000000;;		if c.cache == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ele, hit := c.cache[key]; hit {
0000000000000000000000000000000000000000;;			c.removeElement(ele)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveOldest removes the oldest item from the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) RemoveOldest() {
0000000000000000000000000000000000000000;;		if c.cache == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ele := c.ll.Back()
0000000000000000000000000000000000000000;;		if ele != nil {
0000000000000000000000000000000000000000;;			c.removeElement(ele)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) removeElement(e *list.Element) {
0000000000000000000000000000000000000000;;		c.ll.Remove(e)
0000000000000000000000000000000000000000;;		kv := e.Value.(*entry)
0000000000000000000000000000000000000000;;		delete(c.cache, kv.key)
0000000000000000000000000000000000000000;;		if c.OnEvicted != nil {
0000000000000000000000000000000000000000;;			c.OnEvicted(kv.key, kv.value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of items in the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) Len() int {
0000000000000000000000000000000000000000;;		if c.cache == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ll.Len()
0000000000000000000000000000000000000000;;	}
