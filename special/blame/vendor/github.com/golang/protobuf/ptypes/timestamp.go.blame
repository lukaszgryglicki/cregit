0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8337c2fc62f66cf6db7638dc013660183869f458;;	
0000000000000000000000000000000000000000;;	package ptypes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file implements operations on google.protobuf.Timestamp.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tspb "github.com/golang/protobuf/ptypes/timestamp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Seconds field of the earliest valid Timestamp.
0000000000000000000000000000000000000000;;		// This is time.Date(1, 1, 1, 0, 0, 0, 0, time.UTC).Unix().
0000000000000000000000000000000000000000;;		minValidSeconds = -62135596800
0000000000000000000000000000000000000000;;		// Seconds field just after the latest valid Timestamp.
0000000000000000000000000000000000000000;;		// This is time.Date(10000, 1, 1, 0, 0, 0, 0, time.UTC).Unix().
0000000000000000000000000000000000000000;;		maxValidSeconds = 253402300800
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateTimestamp determines whether a Timestamp is valid.
0000000000000000000000000000000000000000;;	// A valid timestamp represents a time in the range
0000000000000000000000000000000000000000;;	// [0001-01-01, 10000-01-01) and has a Nanos field
0000000000000000000000000000000000000000;;	// in the range [0, 1e9).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the Timestamp is valid, validateTimestamp returns nil.
0000000000000000000000000000000000000000;;	// Otherwise, it returns an error that describes
0000000000000000000000000000000000000000;;	// the problem.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Every valid Timestamp can be represented by a time.Time, but the converse is not true.
0000000000000000000000000000000000000000;;	func validateTimestamp(ts *tspb.Timestamp) error {
0000000000000000000000000000000000000000;;		if ts == nil {
0000000000000000000000000000000000000000;;			return errors.New("timestamp: nil Timestamp")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ts.Seconds < minValidSeconds {
0000000000000000000000000000000000000000;;			return fmt.Errorf("timestamp: %v before 0001-01-01", ts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ts.Seconds >= maxValidSeconds {
0000000000000000000000000000000000000000;;			return fmt.Errorf("timestamp: %v after 10000-01-01", ts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ts.Nanos < 0 || ts.Nanos >= 1e9 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("timestamp: %v: nanos not in range [0, 1e9)", ts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Timestamp converts a google.protobuf.Timestamp proto to a time.Time.
0000000000000000000000000000000000000000;;	// It returns an error if the argument is invalid.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unlike most Go functions, if Timestamp returns an error, the first return value
0000000000000000000000000000000000000000;;	// is not the zero time.Time. Instead, it is the value obtained from the
0000000000000000000000000000000000000000;;	// time.Unix function when passed the contents of the Timestamp, in the UTC
0000000000000000000000000000000000000000;;	// locale. This may or may not be a meaningful time; many invalid Timestamps
0000000000000000000000000000000000000000;;	// do map to valid time.Times.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A nil Timestamp returns an error. The first return value in that case is
0000000000000000000000000000000000000000;;	// undefined.
0000000000000000000000000000000000000000;;	func Timestamp(ts *tspb.Timestamp) (time.Time, error) {
0000000000000000000000000000000000000000;;		// Don't return the zero value on error, because corresponds to a valid
0000000000000000000000000000000000000000;;		// timestamp. Instead return whatever time.Unix gives us.
0000000000000000000000000000000000000000;;		var t time.Time
0000000000000000000000000000000000000000;;		if ts == nil {
0000000000000000000000000000000000000000;;			t = time.Unix(0, 0).UTC() // treat nil like the empty Timestamp
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t = time.Unix(ts.Seconds, int64(ts.Nanos)).UTC()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, validateTimestamp(ts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimestampProto converts the time.Time to a google.protobuf.Timestamp proto.
0000000000000000000000000000000000000000;;	// It returns an error if the resulting Timestamp is invalid.
0000000000000000000000000000000000000000;;	func TimestampProto(t time.Time) (*tspb.Timestamp, error) {
0000000000000000000000000000000000000000;;		seconds := t.Unix()
0000000000000000000000000000000000000000;;		nanos := int32(t.Sub(time.Unix(seconds, 0)))
0000000000000000000000000000000000000000;;		ts := &tspb.Timestamp{
0000000000000000000000000000000000000000;;			Seconds: seconds,
0000000000000000000000000000000000000000;;			Nanos:   nanos,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := validateTimestamp(ts); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimestampString returns the RFC 3339 string for valid Timestamps. For invalid
0000000000000000000000000000000000000000;;	// Timestamps, it returns an error message in parentheses.
0000000000000000000000000000000000000000;;	func TimestampString(ts *tspb.Timestamp) string {
0000000000000000000000000000000000000000;;		t, err := Timestamp(ts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("(%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.Format(time.RFC3339Nano)
0000000000000000000000000000000000000000;;	}
