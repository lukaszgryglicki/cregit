0000000000000000000000000000000000000000;;	#!/bin/bash -e
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# This script fetches and rebuilds the "well-known types" protocol buffers.
0000000000000000000000000000000000000000;;	# To run this you will need protoc and goprotobuf installed;
0000000000000000000000000000000000000000;;	# see https://github.com/golang/protobuf for instructions.
0000000000000000000000000000000000000000;;	# You also need Go and Git installed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	PKG=github.com/golang/protobuf/ptypes
0000000000000000000000000000000000000000;;	UPSTREAM=https://github.com/google/protobuf
0000000000000000000000000000000000000000;;	UPSTREAM_SUBDIR=src/google/protobuf
0000000000000000000000000000000000000000;;	PROTO_FILES='
0000000000000000000000000000000000000000;;	  any.proto
0000000000000000000000000000000000000000;;	  duration.proto
0000000000000000000000000000000000000000;;	  empty.proto
0000000000000000000000000000000000000000;;	  struct.proto
0000000000000000000000000000000000000000;;	  timestamp.proto
0000000000000000000000000000000000000000;;	  wrappers.proto
0000000000000000000000000000000000000000;;	'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	function die() {
0000000000000000000000000000000000000000;;	  echo 1>&2 $*
0000000000000000000000000000000000000000;;	  exit 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Sanity check that the right tools are accessible.
0000000000000000000000000000000000000000;;	for tool in go git protoc protoc-gen-go; do
0000000000000000000000000000000000000000;;	  q=$(which $tool) || die "didn't find $tool"
0000000000000000000000000000000000000000;;	  echo 1>&2 "$tool: $q"
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	tmpdir=$(mktemp -d -t regen-wkt.XXXXXX)
0000000000000000000000000000000000000000;;	trap 'rm -rf $tmpdir' EXIT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo -n 1>&2 "finding package dir... "
0000000000000000000000000000000000000000;;	pkgdir=$(go list -f '{{.Dir}}' $PKG)
0000000000000000000000000000000000000000;;	echo 1>&2 $pkgdir
0000000000000000000000000000000000000000;;	base=$(echo $pkgdir | sed "s,/$PKG\$,,")
0000000000000000000000000000000000000000;;	echo 1>&2 "base: $base"
0000000000000000000000000000000000000000;;	cd $base
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo 1>&2 "fetching latest protos... "
0000000000000000000000000000000000000000;;	git clone -q $UPSTREAM $tmpdir
0000000000000000000000000000000000000000;;	# Pass 1: build mapping from upstream filename to our filename.
0000000000000000000000000000000000000000;;	declare -A filename_map
0000000000000000000000000000000000000000;;	for f in $(cd $PKG && find * -name '*.proto'); do
0000000000000000000000000000000000000000;;	  echo -n 1>&2 "looking for latest version of $f... "
0000000000000000000000000000000000000000;;	  up=$(cd $tmpdir/$UPSTREAM_SUBDIR && find * -name $(basename $f) | grep -v /testdata/)
0000000000000000000000000000000000000000;;	  echo 1>&2 $up
0000000000000000000000000000000000000000;;	  if [ $(echo $up | wc -w) != "1" ]; then
0000000000000000000000000000000000000000;;	    die "not exactly one match"
0000000000000000000000000000000000000000;;	  fi
0000000000000000000000000000000000000000;;	  filename_map[$up]=$f
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	# Pass 2: copy files
0000000000000000000000000000000000000000;;	for up in "${!filename_map[@]}"; do
0000000000000000000000000000000000000000;;	  f=${filename_map[$up]}
0000000000000000000000000000000000000000;;	  shortname=$(basename $f | sed 's,\.proto$,,')
0000000000000000000000000000000000000000;;	  cp $tmpdir/$UPSTREAM_SUBDIR/$up $PKG/$f
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Run protoc once per package.
0000000000000000000000000000000000000000;;	for dir in $(find $PKG -name '*.proto' | xargs dirname | sort | uniq); do
0000000000000000000000000000000000000000;;	  echo 1>&2 "* $dir"
0000000000000000000000000000000000000000;;	  protoc --go_out=. $dir/*.proto
0000000000000000000000000000000000000000;;	done
0000000000000000000000000000000000000000;;	echo 1>&2 "All OK"
