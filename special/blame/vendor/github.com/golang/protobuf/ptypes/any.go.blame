0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8337c2fc62f66cf6db7638dc013660183869f458;;	
0000000000000000000000000000000000000000;;	package ptypes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file implements functions to marshal proto.Message to/from
0000000000000000000000000000000000000000;;	// google.protobuf.Any message.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/ptypes/any"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const googleApis = "type.googleapis.com/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnyMessageName returns the name of the message contained in a google.protobuf.Any message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that regular type assertions should be done using the Is
0000000000000000000000000000000000000000;;	// function. AnyMessageName is provided for less common use cases like filtering a
0000000000000000000000000000000000000000;;	// sequence of Any messages based on a set of allowed message type names.
0000000000000000000000000000000000000000;;	func AnyMessageName(any *any.Any) (string, error) {
0000000000000000000000000000000000000000;;		slash := strings.LastIndex(any.TypeUrl, "/")
0000000000000000000000000000000000000000;;		if slash < 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("message type url %q is invalid", any.TypeUrl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return any.TypeUrl[slash+1:], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalAny takes the protocol buffer and encodes it into google.protobuf.Any.
0000000000000000000000000000000000000000;;	func MarshalAny(pb proto.Message) (*any.Any, error) {
0000000000000000000000000000000000000000;;		value, err := proto.Marshal(pb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &any.Any{TypeUrl: googleApis + proto.MessageName(pb), Value: value}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DynamicAny is a value that can be passed to UnmarshalAny to automatically
0000000000000000000000000000000000000000;;	// allocate a proto.Message for the type specified in a google.protobuf.Any
0000000000000000000000000000000000000000;;	// message. The allocated message is stored in the embedded proto.Message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   var x ptypes.DynamicAny
0000000000000000000000000000000000000000;;	//   if err := ptypes.UnmarshalAny(a, &x); err != nil { ... }
0000000000000000000000000000000000000000;;	//   fmt.Printf("unmarshaled message: %v", x.Message)
0000000000000000000000000000000000000000;;	type DynamicAny struct {
0000000000000000000000000000000000000000;;		proto.Message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns a new proto.Message of the type specified in a
0000000000000000000000000000000000000000;;	// google.protobuf.Any message. It returns an error if corresponding message
0000000000000000000000000000000000000000;;	// type isn't linked in.
0000000000000000000000000000000000000000;;	func Empty(any *any.Any) (proto.Message, error) {
0000000000000000000000000000000000000000;;		aname, err := AnyMessageName(any)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := proto.MessageType(aname)
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("any: message type %q isn't linked in", aname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.New(t.Elem()).Interface().(proto.Message), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalAny parses the protocol buffer representation in a google.protobuf.Any
0000000000000000000000000000000000000000;;	// message and places the decoded result in pb. It returns an error if type of
0000000000000000000000000000000000000000;;	// contents of Any message does not match type of pb message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// pb can be a proto.Message, or a *DynamicAny.
0000000000000000000000000000000000000000;;	func UnmarshalAny(any *any.Any, pb proto.Message) error {
0000000000000000000000000000000000000000;;		if d, ok := pb.(*DynamicAny); ok {
0000000000000000000000000000000000000000;;			if d.Message == nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				d.Message, err = Empty(any)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return UnmarshalAny(any, d.Message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aname, err := AnyMessageName(any)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mname := proto.MessageName(pb)
0000000000000000000000000000000000000000;;		if aname != mname {
0000000000000000000000000000000000000000;;			return fmt.Errorf("mismatched message type: got %q want %q", aname, mname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return proto.Unmarshal(any.Value, pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is returns true if any value contains a given message type.
0000000000000000000000000000000000000000;;	func Is(any *any.Any, pb proto.Message) bool {
0000000000000000000000000000000000000000;;		aname, err := AnyMessageName(any)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return aname == proto.MessageName(pb)
0000000000000000000000000000000000000000;;	}
