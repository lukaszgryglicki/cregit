0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/github.com/golang/protobuf/proto/lib.go[Godeps/_workspace/src/github.com/golang/protobuf/proto/lib.go][vendor/github.com/golang/protobuf/proto/lib.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package proto converts data structures to and from the wire format of
0000000000000000000000000000000000000000;;	protocol buffers.  It works in concert with the Go source code generated
0000000000000000000000000000000000000000;;	for .proto files by the protocol compiler.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A summary of the properties of the protocol buffer interface
0000000000000000000000000000000000000000;;	for a protocol buffer variable v:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - Names are turned from camel_case to CamelCase for export.
0000000000000000000000000000000000000000;;	  - There are no methods on v to set fields; just treat
0000000000000000000000000000000000000000;;		them as structure fields.
0000000000000000000000000000000000000000;;	  - There are getters that return a field's value if set,
0000000000000000000000000000000000000000;;		and return the field's default value if unset.
0000000000000000000000000000000000000000;;		The getters work even if the receiver is a nil message.
0000000000000000000000000000000000000000;;	  - The zero value for a struct is its correct initialization state.
0000000000000000000000000000000000000000;;		All desired fields must be set before marshaling.
0000000000000000000000000000000000000000;;	  - A Reset() method will restore a protobuf struct to its zero state.
0000000000000000000000000000000000000000;;	  - Non-repeated fields are pointers to the values; nil means unset.
0000000000000000000000000000000000000000;;		That is, optional or required field int32 f becomes F *int32.
0000000000000000000000000000000000000000;;	  - Repeated fields are slices.
0000000000000000000000000000000000000000;;	  - Helper functions are available to aid the setting of fields.
0000000000000000000000000000000000000000;;		msg.Foo = proto.String("hello") // set field
0000000000000000000000000000000000000000;;	  - Constants are defined to hold the default values of all fields that
0000000000000000000000000000000000000000;;		have them.  They have the form Default_StructName_FieldName.
0000000000000000000000000000000000000000;;		Because the getter methods handle defaulted values,
0000000000000000000000000000000000000000;;		direct use of these constants should be rare.
0000000000000000000000000000000000000000;;	  - Enums are given type names and maps from names to values.
0000000000000000000000000000000000000000;;		Enum values are prefixed by the enclosing message's name, or by the
0000000000000000000000000000000000000000;;		enum's type name if it is a top-level enum. Enum types have a String
0000000000000000000000000000000000000000;;		method, and a Enum method to assist in message construction.
0000000000000000000000000000000000000000;;	  - Nested messages, groups and enums have type names prefixed with the name of
0000000000000000000000000000000000000000;;		the surrounding message type.
0000000000000000000000000000000000000000;;	  - Extensions are given descriptor names that start with E_,
0000000000000000000000000000000000000000;;		followed by an underscore-delimited list of the nested messages
0000000000000000000000000000000000000000;;		that contain it (if any) followed by the CamelCased name of the
0000000000000000000000000000000000000000;;		extension field itself.  HasExtension, ClearExtension, GetExtension
0000000000000000000000000000000000000000;;		and SetExtension are functions for manipulating extensions.
0000000000000000000000000000000000000000;;	  - Oneof field sets are given a single field in their message,
0000000000000000000000000000000000000000;;		with distinguished wrapper types for each possible field value.
0000000000000000000000000000000000000000;;	  - Marshal and Unmarshal are functions to encode and decode the wire format.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When the .proto file specifies `syntax="proto3"`, there are some differences:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - Non-repeated fields of non-message type are values instead of pointers.
0000000000000000000000000000000000000000;;	  - Getters are only generated for message and oneof fields.
0000000000000000000000000000000000000000;;	  - Enum types do not get an Enum method.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The simplest way to describe this is to see an example.
0000000000000000000000000000000000000000;;	Given file test.proto, containing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		package example;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enum FOO { X = 17; }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		message Test {
0000000000000000000000000000000000000000;;		  required string label = 1;
0000000000000000000000000000000000000000;;		  optional int32 type = 2 [default=77];
0000000000000000000000000000000000000000;;		  repeated int64 reps = 3;
0000000000000000000000000000000000000000;;		  optional group OptionalGroup = 4 {
0000000000000000000000000000000000000000;;		    required string RequiredField = 5;
0000000000000000000000000000000000000000;;		  }
0000000000000000000000000000000000000000;;		  oneof union {
0000000000000000000000000000000000000000;;		    int32 number = 6;
0000000000000000000000000000000000000000;;		    string name = 7;
0000000000000000000000000000000000000000;;		  }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The resulting file, test.pb.go, is:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		package example
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		import proto "github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		import math "math"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type FOO int32
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			FOO_X FOO = 17
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		var FOO_name = map[int32]string{
0000000000000000000000000000000000000000;;			17: "X",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var FOO_value = map[string]int32{
0000000000000000000000000000000000000000;;			"X": 17,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (x FOO) Enum() *FOO {
0000000000000000000000000000000000000000;;			p := new(FOO)
0000000000000000000000000000000000000000;;			*p = x
0000000000000000000000000000000000000000;;			return p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		func (x FOO) String() string {
0000000000000000000000000000000000000000;;			return proto.EnumName(FOO_name, int32(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		func (x *FOO) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;			value, err := proto.UnmarshalJSONEnum(FOO_value, data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*x = FOO(value)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Test struct {
0000000000000000000000000000000000000000;;			Label         *string             `protobuf:"bytes,1,req,name=label" json:"label,omitempty"`
0000000000000000000000000000000000000000;;			Type          *int32              `protobuf:"varint,2,opt,name=type,def=77" json:"type,omitempty"`
0000000000000000000000000000000000000000;;			Reps          []int64             `protobuf:"varint,3,rep,name=reps" json:"reps,omitempty"`
0000000000000000000000000000000000000000;;			Optionalgroup *Test_OptionalGroup `protobuf:"group,4,opt,name=OptionalGroup" json:"optionalgroup,omitempty"`
0000000000000000000000000000000000000000;;			// Types that are valid to be assigned to Union:
0000000000000000000000000000000000000000;;			//	*Test_Number
0000000000000000000000000000000000000000;;			//	*Test_Name
0000000000000000000000000000000000000000;;			Union            isTest_Union `protobuf_oneof:"union"`
0000000000000000000000000000000000000000;;			XXX_unrecognized []byte       `json:"-"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		func (m *Test) Reset()         { *m = Test{} }
0000000000000000000000000000000000000000;;		func (m *Test) String() string { return proto.CompactTextString(m) }
0000000000000000000000000000000000000000;;		func (*Test) ProtoMessage() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type isTest_Union interface {
0000000000000000000000000000000000000000;;			isTest_Union()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Test_Number struct {
0000000000000000000000000000000000000000;;			Number int32 `protobuf:"varint,6,opt,name=number"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type Test_Name struct {
0000000000000000000000000000000000000000;;			Name string `protobuf:"bytes,7,opt,name=name"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (*Test_Number) isTest_Union() {}
0000000000000000000000000000000000000000;;		func (*Test_Name) isTest_Union()   {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (m *Test) GetUnion() isTest_Union {
0000000000000000000000000000000000000000;;			if m != nil {
0000000000000000000000000000000000000000;;				return m.Union
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		const Default_Test_Type int32 = 77
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (m *Test) GetLabel() string {
0000000000000000000000000000000000000000;;			if m != nil && m.Label != nil {
0000000000000000000000000000000000000000;;				return *m.Label
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (m *Test) GetType() int32 {
0000000000000000000000000000000000000000;;			if m != nil && m.Type != nil {
0000000000000000000000000000000000000000;;				return *m.Type
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Default_Test_Type
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (m *Test) GetOptionalgroup() *Test_OptionalGroup {
0000000000000000000000000000000000000000;;			if m != nil {
0000000000000000000000000000000000000000;;				return m.Optionalgroup
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Test_OptionalGroup struct {
0000000000000000000000000000000000000000;;			RequiredField *string `protobuf:"bytes,5,req" json:"RequiredField,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		func (m *Test_OptionalGroup) Reset()         { *m = Test_OptionalGroup{} }
0000000000000000000000000000000000000000;;		func (m *Test_OptionalGroup) String() string { return proto.CompactTextString(m) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (m *Test_OptionalGroup) GetRequiredField() string {
0000000000000000000000000000000000000000;;			if m != nil && m.RequiredField != nil {
0000000000000000000000000000000000000000;;				return *m.RequiredField
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (m *Test) GetNumber() int32 {
0000000000000000000000000000000000000000;;			if x, ok := m.GetUnion().(*Test_Number); ok {
0000000000000000000000000000000000000000;;				return x.Number
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (m *Test) GetName() string {
0000000000000000000000000000000000000000;;			if x, ok := m.GetUnion().(*Test_Name); ok {
0000000000000000000000000000000000000000;;				return x.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func init() {
0000000000000000000000000000000000000000;;			proto.RegisterEnum("example.FOO", FOO_name, FOO_value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To create and play with a Test object:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		import (
0000000000000000000000000000000000000000;;			"log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;			pb "./example.pb"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func main() {
0000000000000000000000000000000000000000;;			test := &pb.Test{
0000000000000000000000000000000000000000;;				Label: proto.String("hello"),
0000000000000000000000000000000000000000;;				Type:  proto.Int32(17),
0000000000000000000000000000000000000000;;				Reps:  []int64{1, 2, 3},
0000000000000000000000000000000000000000;;				Optionalgroup: &pb.Test_OptionalGroup{
0000000000000000000000000000000000000000;;					RequiredField: proto.String("good bye"),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Union: &pb.Test_Name{"fred"},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err := proto.Marshal(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatal("marshaling error: ", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newTest := &pb.Test{}
0000000000000000000000000000000000000000;;			err = proto.Unmarshal(data, newTest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatal("unmarshaling error: ", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Now test and newTest contain the same data.
0000000000000000000000000000000000000000;;			if test.GetLabel() != newTest.GetLabel() {
0000000000000000000000000000000000000000;;				log.Fatalf("data mismatch %q != %q", test.GetLabel(), newTest.GetLabel())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Use a type switch to determine which oneof was set.
0000000000000000000000000000000000000000;;			switch u := test.Union.(type) {
0000000000000000000000000000000000000000;;			case *pb.Test_Number: // u.Number contains the number.
0000000000000000000000000000000000000000;;			case *pb.Test_Name: // u.Name contains the string.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// etc.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Message is implemented by generated protocol buffer messages.
0000000000000000000000000000000000000000;;	type Message interface {
0000000000000000000000000000000000000000;;		Reset()
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;		ProtoMessage()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stats records allocation details about the protocol buffer encoders
0000000000000000000000000000000000000000;;	// and decoders.  Useful for tuning the library itself.
0000000000000000000000000000000000000000;;	type Stats struct {
0000000000000000000000000000000000000000;;		Emalloc uint64 // mallocs in encode
0000000000000000000000000000000000000000;;		Dmalloc uint64 // mallocs in decode
0000000000000000000000000000000000000000;;		Encode  uint64 // number of encodes
0000000000000000000000000000000000000000;;		Decode  uint64 // number of decodes
0000000000000000000000000000000000000000;;		Chit    uint64 // number of cache hits
0000000000000000000000000000000000000000;;		Cmiss   uint64 // number of cache misses
0000000000000000000000000000000000000000;;		Size    uint64 // number of sizes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set to true to enable stats collection.
0000000000000000000000000000000000000000;;	const collectStats = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var stats Stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStats returns a copy of the global Stats structure.
0000000000000000000000000000000000000000;;	func GetStats() Stats { return stats }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Buffer is a buffer manager for marshaling and unmarshaling
0000000000000000000000000000000000000000;;	// protocol buffers.  It may be reused between invocations to
0000000000000000000000000000000000000000;;	// reduce memory usage.  It is not necessary to use a Buffer;
0000000000000000000000000000000000000000;;	// the global functions Marshal and Unmarshal create a
0000000000000000000000000000000000000000;;	// temporary Buffer and are fine for most applications.
0000000000000000000000000000000000000000;;	type Buffer struct {
0000000000000000000000000000000000000000;;		buf   []byte // encode/decode byte stream
0000000000000000000000000000000000000000;;		index int    // read point
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pools of basic types to amortize allocation.
0000000000000000000000000000000000000000;;		bools   []bool
0000000000000000000000000000000000000000;;		uint32s []uint32
0000000000000000000000000000000000000000;;		uint64s []uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// extra pools, only used with pointer_reflect.go
0000000000000000000000000000000000000000;;		int32s   []int32
0000000000000000000000000000000000000000;;		int64s   []int64
0000000000000000000000000000000000000000;;		float32s []float32
0000000000000000000000000000000000000000;;		float64s []float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBuffer allocates a new Buffer and initializes its internal data to
0000000000000000000000000000000000000000;;	// the contents of the argument slice.
0000000000000000000000000000000000000000;;	func NewBuffer(e []byte) *Buffer {
0000000000000000000000000000000000000000;;		return &Buffer{buf: e}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the Buffer, ready for marshaling a new protocol buffer.
0000000000000000000000000000000000000000;;	func (p *Buffer) Reset() {
0000000000000000000000000000000000000000;;		p.buf = p.buf[0:0] // for reading/writing
0000000000000000000000000000000000000000;;		p.index = 0        // for reading
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBuf replaces the internal buffer with the slice,
0000000000000000000000000000000000000000;;	// ready for unmarshaling the contents of the slice.
0000000000000000000000000000000000000000;;	func (p *Buffer) SetBuf(s []byte) {
0000000000000000000000000000000000000000;;		p.buf = s
0000000000000000000000000000000000000000;;		p.index = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns the contents of the Buffer.
0000000000000000000000000000000000000000;;	func (p *Buffer) Bytes() []byte { return p.buf }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Helper routines for simplifying the creation of optional fields of basic type.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bool is a helper routine that allocates a new bool value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func Bool(v bool) *bool {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int32 is a helper routine that allocates a new int32 value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func Int32(v int32) *int32 {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int is a helper routine that allocates a new int32 value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it, but unlike Int32
0000000000000000000000000000000000000000;;	// its argument value is an int.
0000000000000000000000000000000000000000;;	func Int(v int) *int32 {
0000000000000000000000000000000000000000;;		p := new(int32)
0000000000000000000000000000000000000000;;		*p = int32(v)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int64 is a helper routine that allocates a new int64 value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func Int64(v int64) *int64 {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float32 is a helper routine that allocates a new float32 value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func Float32(v float32) *float32 {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float64 is a helper routine that allocates a new float64 value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func Float64(v float64) *float64 {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint32 is a helper routine that allocates a new uint32 value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func Uint32(v uint32) *uint32 {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint64 is a helper routine that allocates a new uint64 value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func Uint64(v uint64) *uint64 {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String is a helper routine that allocates a new string value
0000000000000000000000000000000000000000;;	// to store v and returns a pointer to it.
0000000000000000000000000000000000000000;;	func String(v string) *string {
0000000000000000000000000000000000000000;;		return &v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnumName is a helper function to simplify printing protocol buffer enums
0000000000000000000000000000000000000000;;	// by name.  Given an enum map and a value, it returns a useful string.
0000000000000000000000000000000000000000;;	func EnumName(m map[int32]string, v int32) string {
0000000000000000000000000000000000000000;;		s, ok := m[v]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.Itoa(int(v))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSONEnum is a helper function to simplify recovering enum int values
0000000000000000000000000000000000000000;;	// from their JSON-encoded representation. Given a map from the enum's symbolic
0000000000000000000000000000000000000000;;	// names to its int values, and a byte buffer containing the JSON-encoded
0000000000000000000000000000000000000000;;	// value, it returns an int32 that can be cast to the enum type by the caller.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The function can deal with both JSON representations, numeric and symbolic.
0000000000000000000000000000000000000000;;	func UnmarshalJSONEnum(m map[string]int32, data []byte, enumName string) (int32, error) {
0000000000000000000000000000000000000000;;		if data[0] == '"' {
0000000000000000000000000000000000000000;;			// New style: enums are strings.
0000000000000000000000000000000000000000;;			var repr string
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &repr); err != nil {
0000000000000000000000000000000000000000;;				return -1, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val, ok := m[repr]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("unrecognized enum %s value %q", enumName, repr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return val, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Old style: enums are ints.
0000000000000000000000000000000000000000;;		var val int32
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &val); err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("cannot unmarshal %#q into enum %s", data, enumName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DebugPrint dumps the encoded data in b in a debugging format with a header
0000000000000000000000000000000000000000;;	// including the string s. Used in testing but made available for general debugging.
0000000000000000000000000000000000000000;;	func (p *Buffer) DebugPrint(s string, b []byte) {
0000000000000000000000000000000000000000;;		var u uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obuf := p.buf
0000000000000000000000000000000000000000;;		index := p.index
0000000000000000000000000000000000000000;;		p.buf = b
0000000000000000000000000000000000000000;;		p.index = 0
0000000000000000000000000000000000000000;;		depth := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Printf("\n--- %s ---\n", s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	out:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			for i := 0; i < depth; i++ {
0000000000000000000000000000000000000000;;				fmt.Print("  ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			index := p.index
0000000000000000000000000000000000000000;;			if index == len(p.buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			op, err := p.DecodeVarint()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: fetching op err %v\n", index, err)
0000000000000000000000000000000000000000;;				break out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tag := op >> 3
0000000000000000000000000000000000000000;;			wire := op & 7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch wire {
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: t=%3d unknown wire=%d\n",
0000000000000000000000000000000000000000;;					index, tag, wire)
0000000000000000000000000000000000000000;;				break out
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case WireBytes:
0000000000000000000000000000000000000000;;				var r []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r, err = p.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break out
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: t=%3d bytes [%d]", index, tag, len(r))
0000000000000000000000000000000000000000;;				if len(r) <= 6 {
0000000000000000000000000000000000000000;;					for i := 0; i < len(r); i++ {
0000000000000000000000000000000000000000;;						fmt.Printf(" %.2x", r[i])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;						fmt.Printf(" %.2x", r[i])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fmt.Printf(" ..")
0000000000000000000000000000000000000000;;					for i := len(r) - 3; i < len(r); i++ {
0000000000000000000000000000000000000000;;						fmt.Printf(" %.2x", r[i])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Printf("\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case WireFixed32:
0000000000000000000000000000000000000000;;				u, err = p.DecodeFixed32()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					fmt.Printf("%3d: t=%3d fix32 err %v\n", index, tag, err)
0000000000000000000000000000000000000000;;					break out
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: t=%3d fix32 %d\n", index, tag, u)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case WireFixed64:
0000000000000000000000000000000000000000;;				u, err = p.DecodeFixed64()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					fmt.Printf("%3d: t=%3d fix64 err %v\n", index, tag, err)
0000000000000000000000000000000000000000;;					break out
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: t=%3d fix64 %d\n", index, tag, u)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case WireVarint:
0000000000000000000000000000000000000000;;				u, err = p.DecodeVarint()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					fmt.Printf("%3d: t=%3d varint err %v\n", index, tag, err)
0000000000000000000000000000000000000000;;					break out
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: t=%3d varint %d\n", index, tag, u)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case WireStartGroup:
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: t=%3d start\n", index, tag)
0000000000000000000000000000000000000000;;				depth++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case WireEndGroup:
0000000000000000000000000000000000000000;;				depth--
0000000000000000000000000000000000000000;;				fmt.Printf("%3d: t=%3d end\n", index, tag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if depth != 0 {
0000000000000000000000000000000000000000;;			fmt.Printf("%3d: start-end not balanced %d\n", p.index, depth)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Printf("\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.buf = obuf
0000000000000000000000000000000000000000;;		p.index = index
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDefaults sets unset protocol buffer fields to their default values.
0000000000000000000000000000000000000000;;	// It only modifies fields that are both unset and have defined defaults.
0000000000000000000000000000000000000000;;	// It recursively sets default values in any non-nil sub-messages.
0000000000000000000000000000000000000000;;	func SetDefaults(pb Message) {
0000000000000000000000000000000000000000;;		setDefaults(reflect.ValueOf(pb), true, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v is a pointer to a struct.
0000000000000000000000000000000000000000;;	func setDefaults(v reflect.Value, recur, zeros bool) {
0000000000000000000000000000000000000000;;		v = v.Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultMu.RLock()
0000000000000000000000000000000000000000;;		dm, ok := defaults[v.Type()]
0000000000000000000000000000000000000000;;		defaultMu.RUnlock()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			dm = buildDefaultMessage(v.Type())
0000000000000000000000000000000000000000;;			defaultMu.Lock()
0000000000000000000000000000000000000000;;			defaults[v.Type()] = dm
0000000000000000000000000000000000000000;;			defaultMu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sf := range dm.scalars {
0000000000000000000000000000000000000000;;			f := v.Field(sf.index)
0000000000000000000000000000000000000000;;			if !f.IsNil() {
0000000000000000000000000000000000000000;;				// field already set
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv := sf.value
0000000000000000000000000000000000000000;;			if dv == nil && !zeros {
0000000000000000000000000000000000000000;;				// no explicit default, and don't want to set zeros
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fptr := f.Addr().Interface() // **T
0000000000000000000000000000000000000000;;			// TODO: Consider batching the allocations we do here.
0000000000000000000000000000000000000000;;			switch sf.kind {
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				b := new(bool)
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					*b = dv.(bool)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(**bool)) = b
0000000000000000000000000000000000000000;;			case reflect.Float32:
0000000000000000000000000000000000000000;;				f := new(float32)
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					*f = dv.(float32)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(**float32)) = f
0000000000000000000000000000000000000000;;			case reflect.Float64:
0000000000000000000000000000000000000000;;				f := new(float64)
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					*f = dv.(float64)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(**float64)) = f
0000000000000000000000000000000000000000;;			case reflect.Int32:
0000000000000000000000000000000000000000;;				// might be an enum
0000000000000000000000000000000000000000;;				if ft := f.Type(); ft != int32PtrType {
0000000000000000000000000000000000000000;;					// enum
0000000000000000000000000000000000000000;;					f.Set(reflect.New(ft.Elem()))
0000000000000000000000000000000000000000;;					if dv != nil {
0000000000000000000000000000000000000000;;						f.Elem().SetInt(int64(dv.(int32)))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// int32 field
0000000000000000000000000000000000000000;;					i := new(int32)
0000000000000000000000000000000000000000;;					if dv != nil {
0000000000000000000000000000000000000000;;						*i = dv.(int32)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					*(fptr.(**int32)) = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Int64:
0000000000000000000000000000000000000000;;				i := new(int64)
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					*i = dv.(int64)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(**int64)) = i
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				s := new(string)
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					*s = dv.(string)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(**string)) = s
0000000000000000000000000000000000000000;;			case reflect.Uint8:
0000000000000000000000000000000000000000;;				// exceptional case: []byte
0000000000000000000000000000000000000000;;				var b []byte
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					db := dv.([]byte)
0000000000000000000000000000000000000000;;					b = make([]byte, len(db))
0000000000000000000000000000000000000000;;					copy(b, db)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					b = []byte{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(*[]byte)) = b
0000000000000000000000000000000000000000;;			case reflect.Uint32:
0000000000000000000000000000000000000000;;				u := new(uint32)
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					*u = dv.(uint32)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(**uint32)) = u
0000000000000000000000000000000000000000;;			case reflect.Uint64:
0000000000000000000000000000000000000000;;				u := new(uint64)
0000000000000000000000000000000000000000;;				if dv != nil {
0000000000000000000000000000000000000000;;					*u = dv.(uint64)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*(fptr.(**uint64)) = u
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				log.Printf("proto: can't set default for field %v (sf.kind=%v)", f, sf.kind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ni := range dm.nested {
0000000000000000000000000000000000000000;;			f := v.Field(ni)
0000000000000000000000000000000000000000;;			// f is *T or []*T or map[T]*T
0000000000000000000000000000000000000000;;			switch f.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;				if f.IsNil() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				setDefaults(f, recur, zeros)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				for i := 0; i < f.Len(); i++ {
0000000000000000000000000000000000000000;;					e := f.Index(i)
0000000000000000000000000000000000000000;;					if e.IsNil() {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					setDefaults(e, recur, zeros)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				for _, k := range f.MapKeys() {
0000000000000000000000000000000000000000;;					e := f.MapIndex(k)
0000000000000000000000000000000000000000;;					if e.IsNil() {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					setDefaults(e, recur, zeros)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// defaults maps a protocol buffer struct type to a slice of the fields,
0000000000000000000000000000000000000000;;		// with its scalar fields set to their proto-declared non-zero default values.
0000000000000000000000000000000000000000;;		defaultMu sync.RWMutex
0000000000000000000000000000000000000000;;		defaults  = make(map[reflect.Type]defaultMessage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		int32PtrType = reflect.TypeOf((*int32)(nil))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultMessage represents information about the default values of a message.
0000000000000000000000000000000000000000;;	type defaultMessage struct {
0000000000000000000000000000000000000000;;		scalars []scalarField
0000000000000000000000000000000000000000;;		nested  []int // struct field index of nested messages
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scalarField struct {
0000000000000000000000000000000000000000;;		index int          // struct field index
0000000000000000000000000000000000000000;;		kind  reflect.Kind // element type (the T in *T or []T)
0000000000000000000000000000000000000000;;		value interface{}  // the proto-declared default value, or nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// t is a struct type.
0000000000000000000000000000000000000000;;	func buildDefaultMessage(t reflect.Type) (dm defaultMessage) {
0000000000000000000000000000000000000000;;		sprop := GetProperties(t)
0000000000000000000000000000000000000000;;		for _, prop := range sprop.Prop {
0000000000000000000000000000000000000000;;			fi, ok := sprop.decoderTags.get(prop.Tag)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// XXX_unrecognized
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ft := t.Field(fi).Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sf, nested, err := fieldDefault(ft, prop)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				log.Print(err)
0000000000000000000000000000000000000000;;			case nested:
0000000000000000000000000000000000000000;;				dm.nested = append(dm.nested, fi)
0000000000000000000000000000000000000000;;			case sf != nil:
0000000000000000000000000000000000000000;;				sf.index = fi
0000000000000000000000000000000000000000;;				dm.scalars = append(dm.scalars, *sf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fieldDefault returns the scalarField for field type ft.
0000000000000000000000000000000000000000;;	// sf will be nil if the field can not have a default.
0000000000000000000000000000000000000000;;	// nestedMessage will be true if this is a nested message.
0000000000000000000000000000000000000000;;	// Note that sf.index is not set on return.
0000000000000000000000000000000000000000;;	func fieldDefault(ft reflect.Type, prop *Properties) (sf *scalarField, nestedMessage bool, err error) {
0000000000000000000000000000000000000000;;		var canHaveDefault bool
0000000000000000000000000000000000000000;;		switch ft.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if ft.Elem().Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;				nestedMessage = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				canHaveDefault = true // proto2 scalar field
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			switch ft.Elem().Kind() {
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;				nestedMessage = true // repeated message
0000000000000000000000000000000000000000;;			case reflect.Uint8:
0000000000000000000000000000000000000000;;				canHaveDefault = true // bytes field
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if ft.Elem().Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				nestedMessage = true // map with message values
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !canHaveDefault {
0000000000000000000000000000000000000000;;			if nestedMessage {
0000000000000000000000000000000000000000;;				return nil, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We now know that ft is a pointer or slice.
0000000000000000000000000000000000000000;;		sf = &scalarField{kind: ft.Elem().Kind()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scalar fields without defaults
0000000000000000000000000000000000000000;;		if !prop.HasDefault {
0000000000000000000000000000000000000000;;			return sf, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a scalar field: either *T or []byte
0000000000000000000000000000000000000000;;		switch ft.Elem().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			x, err := strconv.ParseBool(prop.Default)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("proto: bad default bool %q: %v", prop.Default, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sf.value = x
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			x, err := strconv.ParseFloat(prop.Default, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("proto: bad default float32 %q: %v", prop.Default, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sf.value = float32(x)
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			x, err := strconv.ParseFloat(prop.Default, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("proto: bad default float64 %q: %v", prop.Default, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sf.value = x
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			x, err := strconv.ParseInt(prop.Default, 10, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("proto: bad default int32 %q: %v", prop.Default, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sf.value = int32(x)
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			x, err := strconv.ParseInt(prop.Default, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("proto: bad default int64 %q: %v", prop.Default, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sf.value = x
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			sf.value = prop.Default
0000000000000000000000000000000000000000;;		case reflect.Uint8:
0000000000000000000000000000000000000000;;			// []byte (not *uint8)
0000000000000000000000000000000000000000;;			sf.value = []byte(prop.Default)
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			x, err := strconv.ParseUint(prop.Default, 10, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("proto: bad default uint32 %q: %v", prop.Default, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sf.value = uint32(x)
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			x, err := strconv.ParseUint(prop.Default, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, false, fmt.Errorf("proto: bad default uint64 %q: %v", prop.Default, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sf.value = x
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("proto: unhandled def kind %v", ft.Elem().Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sf, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map fields may have key types of non-float scalars, strings and enums.
0000000000000000000000000000000000000000;;	// The easiest way to sort them in some deterministic order is to use fmt.
0000000000000000000000000000000000000000;;	// If this turns out to be inefficient we can always consider other options,
0000000000000000000000000000000000000000;;	// such as doing a Schwartzian transform.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapKeys(vs []reflect.Value) sort.Interface {
0000000000000000000000000000000000000000;;		s := mapKeySorter{
0000000000000000000000000000000000000000;;			vs: vs,
0000000000000000000000000000000000000000;;			// default Less function: textual comparison
0000000000000000000000000000000000000000;;			less: func(a, b reflect.Value) bool {
0000000000000000000000000000000000000000;;				return fmt.Sprint(a.Interface()) < fmt.Sprint(b.Interface())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Type specialization per https://developers.google.com/protocol-buffers/docs/proto#maps;
0000000000000000000000000000000000000000;;		// numeric keys are sorted numerically.
0000000000000000000000000000000000000000;;		if len(vs) == 0 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch vs[0].Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			s.less = func(a, b reflect.Value) bool { return a.Int() < b.Int() }
0000000000000000000000000000000000000000;;		case reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			s.less = func(a, b reflect.Value) bool { return a.Uint() < b.Uint() }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mapKeySorter struct {
0000000000000000000000000000000000000000;;		vs   []reflect.Value
0000000000000000000000000000000000000000;;		less func(a, b reflect.Value) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s mapKeySorter) Len() int      { return len(s.vs) }
0000000000000000000000000000000000000000;;	func (s mapKeySorter) Swap(i, j int) { s.vs[i], s.vs[j] = s.vs[j], s.vs[i] }
0000000000000000000000000000000000000000;;	func (s mapKeySorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s.less(s.vs[i], s.vs[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isProto3Zero reports whether v is a zero proto3 value.
0000000000000000000000000000000000000000;;	func isProto3Zero(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return v.String() == ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProtoPackageIsVersion2 is referenced from generated protocol buffer files
0000000000000000000000000000000000000000;;	// to assert that that code is compatible with this version of the proto package.
0000000000000000000000000000000000000000;;	const ProtoPackageIsVersion2 = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProtoPackageIsVersion1 is referenced from generated protocol buffer files
0000000000000000000000000000000000000000;;	// to assert that that code is compatible with this version of the proto package.
0000000000000000000000000000000000000000;;	const ProtoPackageIsVersion1 = true
