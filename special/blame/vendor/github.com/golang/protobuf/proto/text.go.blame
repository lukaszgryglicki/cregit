0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/github.com/golang/protobuf/proto/text.go[Godeps/_workspace/src/github.com/golang/protobuf/proto/text.go][vendor/github.com/golang/protobuf/proto/text.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Functions for writing the text protocol buffer format.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		newline         = []byte("\n")
0000000000000000000000000000000000000000;;		spaces          = []byte("                                        ")
0000000000000000000000000000000000000000;;		gtNewline       = []byte(">\n")
0000000000000000000000000000000000000000;;		endBraceNewline = []byte("}\n")
0000000000000000000000000000000000000000;;		backslashN      = []byte{'\\', 'n'}
0000000000000000000000000000000000000000;;		backslashR      = []byte{'\\', 'r'}
0000000000000000000000000000000000000000;;		backslashT      = []byte{'\\', 't'}
0000000000000000000000000000000000000000;;		backslashDQ     = []byte{'\\', '"'}
0000000000000000000000000000000000000000;;		backslashBS     = []byte{'\\', '\\'}
0000000000000000000000000000000000000000;;		posInf          = []byte("inf")
0000000000000000000000000000000000000000;;		negInf          = []byte("-inf")
0000000000000000000000000000000000000000;;		nan             = []byte("nan")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writer interface {
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;		WriteByte(byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// textWriter is an io.Writer that tracks its indentation level.
0000000000000000000000000000000000000000;;	type textWriter struct {
0000000000000000000000000000000000000000;;		ind      int
0000000000000000000000000000000000000000;;		complete bool // if the current position is a complete line
0000000000000000000000000000000000000000;;		compact  bool // whether to write out as a one-liner
0000000000000000000000000000000000000000;;		w        writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *textWriter) WriteString(s string) (n int, err error) {
0000000000000000000000000000000000000000;;		if !strings.Contains(s, "\n") {
0000000000000000000000000000000000000000;;			if !w.compact && w.complete {
0000000000000000000000000000000000000000;;				w.writeIndent()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.complete = false
0000000000000000000000000000000000000000;;			return io.WriteString(w.w, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// WriteString is typically called without newlines, so this
0000000000000000000000000000000000000000;;		// codepath and its copy are rare.  We copy to avoid
0000000000000000000000000000000000000000;;		// duplicating all of Write's logic here.
0000000000000000000000000000000000000000;;		return w.Write([]byte(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *textWriter) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		newlines := bytes.Count(p, newline)
0000000000000000000000000000000000000000;;		if newlines == 0 {
0000000000000000000000000000000000000000;;			if !w.compact && w.complete {
0000000000000000000000000000000000000000;;				w.writeIndent()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, err = w.w.Write(p)
0000000000000000000000000000000000000000;;			w.complete = false
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frags := bytes.SplitN(p, newline, newlines+1)
0000000000000000000000000000000000000000;;		if w.compact {
0000000000000000000000000000000000000000;;			for i, frag := range frags {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					if err := w.w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;						return n, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					n++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nn, err := w.w.Write(frag)
0000000000000000000000000000000000000000;;				n += nn
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return n, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, frag := range frags {
0000000000000000000000000000000000000000;;			if w.complete {
0000000000000000000000000000000000000000;;				w.writeIndent()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nn, err := w.w.Write(frag)
0000000000000000000000000000000000000000;;			n += nn
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i+1 < len(frags) {
0000000000000000000000000000000000000000;;				if err := w.w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;					return n, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.complete = len(frags[len(frags)-1]) == 0
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *textWriter) WriteByte(c byte) error {
0000000000000000000000000000000000000000;;		if w.compact && c == '\n' {
0000000000000000000000000000000000000000;;			c = ' '
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !w.compact && w.complete {
0000000000000000000000000000000000000000;;			w.writeIndent()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := w.w.WriteByte(c)
0000000000000000000000000000000000000000;;		w.complete = c == '\n'
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *textWriter) indent() { w.ind++ }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *textWriter) unindent() {
0000000000000000000000000000000000000000;;		if w.ind == 0 {
0000000000000000000000000000000000000000;;			log.Print("proto: textWriter unindented too far")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.ind--
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeName(w *textWriter, props *Properties) error {
0000000000000000000000000000000000000000;;		if _, err := w.WriteString(props.OrigName); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if props.Wire != "group" {
0000000000000000000000000000000000000000;;			return w.WriteByte(':')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// raw is the interface satisfied by RawMessage.
0000000000000000000000000000000000000000;;	type raw interface {
0000000000000000000000000000000000000000;;		Bytes() []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func requiresQuotes(u string) bool {
0000000000000000000000000000000000000000;;		// When type URL contains any characters except [0-9A-Za-z./\-]*, it must be quoted.
0000000000000000000000000000000000000000;;		for _, ch := range u {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ch == '.' || ch == '/' || ch == '_':
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '0' <= ch && ch <= '9':
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case 'A' <= ch && ch <= 'Z':
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case 'a' <= ch && ch <= 'z':
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isAny reports whether sv is a google.protobuf.Any message
0000000000000000000000000000000000000000;;	func isAny(sv reflect.Value) bool {
0000000000000000000000000000000000000000;;		type wkt interface {
0000000000000000000000000000000000000000;;			XXX_WellKnownType() string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, ok := sv.Addr().Interface().(wkt)
0000000000000000000000000000000000000000;;		return ok && t.XXX_WellKnownType() == "Any"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeProto3Any writes an expanded google.protobuf.Any message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It returns (false, nil) if sv value can't be unmarshaled (e.g. because
0000000000000000000000000000000000000000;;	// required messages are not linked in).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It returns (true, error) when sv was written in expanded format or an error
0000000000000000000000000000000000000000;;	// was encountered.
0000000000000000000000000000000000000000;;	func (tm *TextMarshaler) writeProto3Any(w *textWriter, sv reflect.Value) (bool, error) {
0000000000000000000000000000000000000000;;		turl := sv.FieldByName("TypeUrl")
0000000000000000000000000000000000000000;;		val := sv.FieldByName("Value")
0000000000000000000000000000000000000000;;		if !turl.IsValid() || !val.IsValid() {
0000000000000000000000000000000000000000;;			return true, errors.New("proto: invalid google.protobuf.Any message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, ok := val.Interface().([]byte)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return true, errors.New("proto: invalid google.protobuf.Any message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := strings.Split(turl.String(), "/")
0000000000000000000000000000000000000000;;		mt := MessageType(parts[len(parts)-1])
0000000000000000000000000000000000000000;;		if mt == nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := reflect.New(mt.Elem())
0000000000000000000000000000000000000000;;		if err := Unmarshal(b, m.Interface().(Message)); err != nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write([]byte("["))
0000000000000000000000000000000000000000;;		u := turl.String()
0000000000000000000000000000000000000000;;		if requiresQuotes(u) {
0000000000000000000000000000000000000000;;			writeString(w, u)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.Write([]byte(u))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.compact {
0000000000000000000000000000000000000000;;			w.Write([]byte("]:<"))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.Write([]byte("]: <\n"))
0000000000000000000000000000000000000000;;			w.ind++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := tm.writeStruct(w, m.Elem()); err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.compact {
0000000000000000000000000000000000000000;;			w.Write([]byte("> "))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.ind--
0000000000000000000000000000000000000000;;			w.Write([]byte(">\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tm *TextMarshaler) writeStruct(w *textWriter, sv reflect.Value) error {
0000000000000000000000000000000000000000;;		if tm.ExpandAny && isAny(sv) {
0000000000000000000000000000000000000000;;			if canExpand, err := tm.writeProto3Any(w, sv); canExpand {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st := sv.Type()
0000000000000000000000000000000000000000;;		sprops := GetProperties(st)
0000000000000000000000000000000000000000;;		for i := 0; i < sv.NumField(); i++ {
0000000000000000000000000000000000000000;;			fv := sv.Field(i)
0000000000000000000000000000000000000000;;			props := sprops.Prop[i]
0000000000000000000000000000000000000000;;			name := st.Field(i).Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.HasPrefix(name, "XXX_") {
0000000000000000000000000000000000000000;;				// There are two XXX_ fields:
0000000000000000000000000000000000000000;;				//   XXX_unrecognized []byte
0000000000000000000000000000000000000000;;				//   XXX_extensions   map[int32]proto.Extension
0000000000000000000000000000000000000000;;				// The first is handled here;
0000000000000000000000000000000000000000;;				// the second is handled at the bottom of this function.
0000000000000000000000000000000000000000;;				if name == "XXX_unrecognized" && !fv.IsNil() {
0000000000000000000000000000000000000000;;					if err := writeUnknownStruct(w, fv.Interface().([]byte)); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fv.Kind() == reflect.Ptr && fv.IsNil() {
0000000000000000000000000000000000000000;;				// Field not filled in. This could be an optional field or
0000000000000000000000000000000000000000;;				// a required field that wasn't filled in. Either way, there
0000000000000000000000000000000000000000;;				// isn't anything we can show for it.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fv.Kind() == reflect.Slice && fv.IsNil() {
0000000000000000000000000000000000000000;;				// Repeated field that is empty, or a bytes field that is unused.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if props.Repeated && fv.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;				// Repeated field.
0000000000000000000000000000000000000000;;				for j := 0; j < fv.Len(); j++ {
0000000000000000000000000000000000000000;;					if err := writeName(w, props); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !w.compact {
0000000000000000000000000000000000000000;;						if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v := fv.Index(j)
0000000000000000000000000000000000000000;;					if v.Kind() == reflect.Ptr && v.IsNil() {
0000000000000000000000000000000000000000;;						// A nil message in a repeated field is not valid,
0000000000000000000000000000000000000000;;						// but we can handle that more gracefully than panicking.
0000000000000000000000000000000000000000;;						if _, err := w.Write([]byte("<nil>\n")); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := tm.writeAny(w, v, props); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fv.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;				// Map fields are rendered as a repeated struct with key/value fields.
0000000000000000000000000000000000000000;;				keys := fv.MapKeys()
0000000000000000000000000000000000000000;;				sort.Sort(mapKeys(keys))
0000000000000000000000000000000000000000;;				for _, key := range keys {
0000000000000000000000000000000000000000;;					val := fv.MapIndex(key)
0000000000000000000000000000000000000000;;					if err := writeName(w, props); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !w.compact {
0000000000000000000000000000000000000000;;						if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// open struct
0000000000000000000000000000000000000000;;					if err := w.WriteByte('<'); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !w.compact {
0000000000000000000000000000000000000000;;						if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.indent()
0000000000000000000000000000000000000000;;					// key
0000000000000000000000000000000000000000;;					if _, err := w.WriteString("key:"); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !w.compact {
0000000000000000000000000000000000000000;;						if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := tm.writeAny(w, key, props.mkeyprop); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// nil values aren't legal, but we can avoid panicking because of them.
0000000000000000000000000000000000000000;;					if val.Kind() != reflect.Ptr || !val.IsNil() {
0000000000000000000000000000000000000000;;						// value
0000000000000000000000000000000000000000;;						if _, err := w.WriteString("value:"); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !w.compact {
0000000000000000000000000000000000000000;;							if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := tm.writeAny(w, val, props.mvalprop); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// close struct
0000000000000000000000000000000000000000;;					w.unindent()
0000000000000000000000000000000000000000;;					if err := w.WriteByte('>'); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if props.proto3 && fv.Kind() == reflect.Slice && fv.Len() == 0 {
0000000000000000000000000000000000000000;;				// empty bytes field
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fv.Kind() != reflect.Ptr && fv.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;				// proto3 non-repeated scalar field; skip if zero value
0000000000000000000000000000000000000000;;				if isProto3Zero(fv) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fv.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;				// Check if it is a oneof.
0000000000000000000000000000000000000000;;				if st.Field(i).Tag.Get("protobuf_oneof") != "" {
0000000000000000000000000000000000000000;;					// fv is nil, or holds a pointer to generated struct.
0000000000000000000000000000000000000000;;					// That generated struct has exactly one field,
0000000000000000000000000000000000000000;;					// which has a protobuf struct tag.
0000000000000000000000000000000000000000;;					if fv.IsNil() {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					inner := fv.Elem().Elem() // interface -> *T -> T
0000000000000000000000000000000000000000;;					tag := inner.Type().Field(0).Tag.Get("protobuf")
0000000000000000000000000000000000000000;;					props = new(Properties) // Overwrite the outer props var, but not its pointee.
0000000000000000000000000000000000000000;;					props.Parse(tag)
0000000000000000000000000000000000000000;;					// Write the value in the oneof, not the oneof itself.
0000000000000000000000000000000000000000;;					fv = inner.Field(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Special case to cope with malformed messages gracefully:
0000000000000000000000000000000000000000;;					// If the value in the oneof is a nil pointer, don't panic
0000000000000000000000000000000000000000;;					// in writeAny.
0000000000000000000000000000000000000000;;					if fv.Kind() == reflect.Ptr && fv.IsNil() {
0000000000000000000000000000000000000000;;						// Use errors.New so writeAny won't render quotes.
0000000000000000000000000000000000000000;;						msg := errors.New("/* nil */")
0000000000000000000000000000000000000000;;						fv = reflect.ValueOf(&msg).Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := writeName(w, props); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !w.compact {
0000000000000000000000000000000000000000;;				if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b, ok := fv.Interface().(raw); ok {
0000000000000000000000000000000000000000;;				if err := writeRaw(w, b.Bytes()); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Enums have a String method, so writeAny will work fine.
0000000000000000000000000000000000000000;;			if err := tm.writeAny(w, fv, props); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extensions (the XXX_extensions field).
0000000000000000000000000000000000000000;;		pv := sv.Addr()
0000000000000000000000000000000000000000;;		if _, ok := extendable(pv.Interface()); ok {
0000000000000000000000000000000000000000;;			if err := tm.writeExtensions(w, pv); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeRaw writes an uninterpreted raw message.
0000000000000000000000000000000000000000;;	func writeRaw(w *textWriter, b []byte) error {
0000000000000000000000000000000000000000;;		if err := w.WriteByte('<'); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !w.compact {
0000000000000000000000000000000000000000;;			if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.indent()
0000000000000000000000000000000000000000;;		if err := writeUnknownStruct(w, b); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.unindent()
0000000000000000000000000000000000000000;;		if err := w.WriteByte('>'); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeAny writes an arbitrary field.
0000000000000000000000000000000000000000;;	func (tm *TextMarshaler) writeAny(w *textWriter, v reflect.Value, props *Properties) error {
0000000000000000000000000000000000000000;;		v = reflect.Indirect(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Floats have special cases.
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Float32 || v.Kind() == reflect.Float64 {
0000000000000000000000000000000000000000;;			x := v.Float()
0000000000000000000000000000000000000000;;			var b []byte
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case math.IsInf(x, 1):
0000000000000000000000000000000000000000;;				b = posInf
0000000000000000000000000000000000000000;;			case math.IsInf(x, -1):
0000000000000000000000000000000000000000;;				b = negInf
0000000000000000000000000000000000000000;;			case math.IsNaN(x):
0000000000000000000000000000000000000000;;				b = nan
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b != nil {
0000000000000000000000000000000000000000;;				_, err := w.Write(b)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Other values are handled below.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't attempt to serialise every possible value type; only those
0000000000000000000000000000000000000000;;		// that can occur in protocol buffers.
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			// Should only be a []byte; repeated fields are handled in writeStruct.
0000000000000000000000000000000000000000;;			if err := writeString(w, string(v.Bytes())); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if err := writeString(w, v.String()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			// Required/optional group/message.
0000000000000000000000000000000000000000;;			var bra, ket byte = '<', '>'
0000000000000000000000000000000000000000;;			if props != nil && props.Wire == "group" {
0000000000000000000000000000000000000000;;				bra, ket = '{', '}'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := w.WriteByte(bra); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !w.compact {
0000000000000000000000000000000000000000;;				if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.indent()
0000000000000000000000000000000000000000;;			if etm, ok := v.Interface().(encoding.TextMarshaler); ok {
0000000000000000000000000000000000000000;;				text, err := etm.MarshalText()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err = w.Write(text); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if err := tm.writeStruct(w, v); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.unindent()
0000000000000000000000000000000000000000;;			if err := w.WriteByte(ket); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			_, err := fmt.Fprint(w, v.Interface())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// equivalent to C's isprint.
0000000000000000000000000000000000000000;;	func isprint(c byte) bool {
0000000000000000000000000000000000000000;;		return c >= 0x20 && c < 0x7f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeString writes a string in the protocol buffer text format.
0000000000000000000000000000000000000000;;	// It is similar to strconv.Quote except we don't use Go escape sequences,
0000000000000000000000000000000000000000;;	// we treat the string as a byte sequence, and we use octal escapes.
0000000000000000000000000000000000000000;;	// These differences are to maintain interoperability with the other
0000000000000000000000000000000000000000;;	// languages' implementations of the text format.
0000000000000000000000000000000000000000;;	func writeString(w *textWriter, s string) error {
0000000000000000000000000000000000000000;;		// use WriteByte here to get any needed indent
0000000000000000000000000000000000000000;;		if err := w.WriteByte('"'); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Loop over the bytes, not the runes.
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			// Divergence from C++: we don't escape apostrophes.
0000000000000000000000000000000000000000;;			// There's no need to escape them, and the C++ parser
0000000000000000000000000000000000000000;;			// copes with a naked apostrophe.
0000000000000000000000000000000000000000;;			switch c := s[i]; c {
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				_, err = w.w.Write(backslashN)
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				_, err = w.w.Write(backslashR)
0000000000000000000000000000000000000000;;			case '\t':
0000000000000000000000000000000000000000;;				_, err = w.w.Write(backslashT)
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				_, err = w.w.Write(backslashDQ)
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				_, err = w.w.Write(backslashBS)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if isprint(c) {
0000000000000000000000000000000000000000;;					err = w.w.WriteByte(c)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					_, err = fmt.Fprintf(w.w, "\\%03o", c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.WriteByte('"')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeUnknownStruct(w *textWriter, data []byte) (err error) {
0000000000000000000000000000000000000000;;		if !w.compact {
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprintf(w, "/* %d unknown bytes */\n", len(data)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := NewBuffer(data)
0000000000000000000000000000000000000000;;		for b.index < len(b.buf) {
0000000000000000000000000000000000000000;;			x, err := b.DecodeVarint()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				_, err := fmt.Fprintf(w, "/* %v */\n", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wire, tag := x&7, x>>3
0000000000000000000000000000000000000000;;			if wire == WireEndGroup {
0000000000000000000000000000000000000000;;				w.unindent()
0000000000000000000000000000000000000000;;				if _, err := w.Write(endBraceNewline); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprint(w, tag); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if wire != WireStartGroup {
0000000000000000000000000000000000000000;;				if err := w.WriteByte(':'); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !w.compact || wire == WireStartGroup {
0000000000000000000000000000000000000000;;				if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch wire {
0000000000000000000000000000000000000000;;			case WireBytes:
0000000000000000000000000000000000000000;;				buf, e := b.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;				if e == nil {
0000000000000000000000000000000000000000;;					_, err = fmt.Fprintf(w, "%q", buf)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					_, err = fmt.Fprintf(w, "/* %v */", e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case WireFixed32:
0000000000000000000000000000000000000000;;				x, err = b.DecodeFixed32()
0000000000000000000000000000000000000000;;				err = writeUnknownInt(w, x, err)
0000000000000000000000000000000000000000;;			case WireFixed64:
0000000000000000000000000000000000000000;;				x, err = b.DecodeFixed64()
0000000000000000000000000000000000000000;;				err = writeUnknownInt(w, x, err)
0000000000000000000000000000000000000000;;			case WireStartGroup:
0000000000000000000000000000000000000000;;				err = w.WriteByte('{')
0000000000000000000000000000000000000000;;				w.indent()
0000000000000000000000000000000000000000;;			case WireVarint:
0000000000000000000000000000000000000000;;				x, err = b.DecodeVarint()
0000000000000000000000000000000000000000;;				err = writeUnknownInt(w, x, err)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				_, err = fmt.Fprintf(w, "/* unknown wire type %d */", wire)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeUnknownInt(w *textWriter, x uint64, err error) error {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			_, err = fmt.Fprint(w, x)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, err = fmt.Fprintf(w, "/* %v */", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type int32Slice []int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s int32Slice) Len() int           { return len(s) }
0000000000000000000000000000000000000000;;	func (s int32Slice) Less(i, j int) bool { return s[i] < s[j] }
0000000000000000000000000000000000000000;;	func (s int32Slice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeExtensions writes all the extensions in pv.
0000000000000000000000000000000000000000;;	// pv is assumed to be a pointer to a protocol message struct that is extendable.
0000000000000000000000000000000000000000;;	func (tm *TextMarshaler) writeExtensions(w *textWriter, pv reflect.Value) error {
0000000000000000000000000000000000000000;;		emap := extensionMaps[pv.Type().Elem()]
0000000000000000000000000000000000000000;;		ep, _ := extendable(pv.Interface())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Order the extensions by ID.
0000000000000000000000000000000000000000;;		// This isn't strictly necessary, but it will give us
0000000000000000000000000000000000000000;;		// canonical output, which will also make testing easier.
0000000000000000000000000000000000000000;;		m, mu := ep.extensionsRead()
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		ids := make([]int32, 0, len(m))
0000000000000000000000000000000000000000;;		for id := range m {
0000000000000000000000000000000000000000;;			ids = append(ids, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(int32Slice(ids))
0000000000000000000000000000000000000000;;		mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, extNum := range ids {
0000000000000000000000000000000000000000;;			ext := m[extNum]
0000000000000000000000000000000000000000;;			var desc *ExtensionDesc
0000000000000000000000000000000000000000;;			if emap != nil {
0000000000000000000000000000000000000000;;				desc = emap[extNum]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if desc == nil {
0000000000000000000000000000000000000000;;				// Unknown extension.
0000000000000000000000000000000000000000;;				if err := writeUnknownStruct(w, ext.enc); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pb, err := GetExtension(ep, desc)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed getting extension: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Repeated extensions will appear as a slice.
0000000000000000000000000000000000000000;;			if !desc.repeated() {
0000000000000000000000000000000000000000;;				if err := tm.writeExtension(w, desc.Name, pb); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				v := reflect.ValueOf(pb)
0000000000000000000000000000000000000000;;				for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;					if err := tm.writeExtension(w, desc.Name, v.Index(i).Interface()); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tm *TextMarshaler) writeExtension(w *textWriter, name string, pb interface{}) error {
0000000000000000000000000000000000000000;;		if _, err := fmt.Fprintf(w, "[%s]:", name); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !w.compact {
0000000000000000000000000000000000000000;;			if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := tm.writeAny(w, reflect.ValueOf(pb), nil); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *textWriter) writeIndent() {
0000000000000000000000000000000000000000;;		if !w.complete {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		remain := w.ind * 2
0000000000000000000000000000000000000000;;		for remain > 0 {
0000000000000000000000000000000000000000;;			n := remain
0000000000000000000000000000000000000000;;			if n > len(spaces) {
0000000000000000000000000000000000000000;;				n = len(spaces)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.w.Write(spaces[:n])
0000000000000000000000000000000000000000;;			remain -= n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.complete = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TextMarshaler is a configurable text format marshaler.
0000000000000000000000000000000000000000;;	type TextMarshaler struct {
0000000000000000000000000000000000000000;;		Compact   bool // use compact text format (one line).
0000000000000000000000000000000000000000;;		ExpandAny bool // expand google.protobuf.Any messages of known types
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal writes a given protocol buffer in text format.
0000000000000000000000000000000000000000;;	// The only errors returned are from w.
0000000000000000000000000000000000000000;;	func (tm *TextMarshaler) Marshal(w io.Writer, pb Message) error {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(pb)
0000000000000000000000000000000000000000;;		if pb == nil || val.IsNil() {
0000000000000000000000000000000000000000;;			w.Write([]byte("<nil>"))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var bw *bufio.Writer
0000000000000000000000000000000000000000;;		ww, ok := w.(writer)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			bw = bufio.NewWriter(w)
0000000000000000000000000000000000000000;;			ww = bw
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aw := &textWriter{
0000000000000000000000000000000000000000;;			w:        ww,
0000000000000000000000000000000000000000;;			complete: true,
0000000000000000000000000000000000000000;;			compact:  tm.Compact,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if etm, ok := pb.(encoding.TextMarshaler); ok {
0000000000000000000000000000000000000000;;			text, err := etm.MarshalText()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err = aw.Write(text); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bw != nil {
0000000000000000000000000000000000000000;;				return bw.Flush()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Dereference the received pointer so we don't have outer < and >.
0000000000000000000000000000000000000000;;		v := reflect.Indirect(val)
0000000000000000000000000000000000000000;;		if err := tm.writeStruct(aw, v); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bw != nil {
0000000000000000000000000000000000000000;;			return bw.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Text is the same as Marshal, but returns the string directly.
0000000000000000000000000000000000000000;;	func (tm *TextMarshaler) Text(pb Message) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		tm.Marshal(&buf, pb)
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultTextMarshaler = TextMarshaler{}
0000000000000000000000000000000000000000;;		compactTextMarshaler = TextMarshaler{Compact: true}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: consider removing some of the Marshal functions below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalText writes a given protocol buffer in text format.
0000000000000000000000000000000000000000;;	// The only errors returned are from w.
0000000000000000000000000000000000000000;;	func MarshalText(w io.Writer, pb Message) error { return defaultTextMarshaler.Marshal(w, pb) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalTextString is the same as MarshalText, but returns the string directly.
0000000000000000000000000000000000000000;;	func MarshalTextString(pb Message) string { return defaultTextMarshaler.Text(pb) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompactText writes a given protocol buffer in compact text format (one line).
0000000000000000000000000000000000000000;;	func CompactText(w io.Writer, pb Message) error { return compactTextMarshaler.Marshal(w, pb) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompactTextString is the same as CompactText, but returns the string directly.
0000000000000000000000000000000000000000;;	func CompactTextString(pb Message) string { return compactTextMarshaler.Text(pb) }
