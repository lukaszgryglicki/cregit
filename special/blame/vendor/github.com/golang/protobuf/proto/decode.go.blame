0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/github.com/golang/protobuf/proto/decode.go[Godeps/_workspace/src/github.com/golang/protobuf/proto/decode.go][vendor/github.com/golang/protobuf/proto/decode.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Routines for decoding protocol buffer data to construct in-memory representations.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errOverflow is returned when an integer is too large to be represented.
0000000000000000000000000000000000000000;;	var errOverflow = errors.New("proto: integer overflow")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrInternalBadWireType is returned by generated code when an incorrect
0000000000000000000000000000000000000000;;	// wire type is encountered. It does not get returned to user code.
0000000000000000000000000000000000000000;;	var ErrInternalBadWireType = errors.New("proto: internal error: bad wiretype for oneof")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The fundamental decoders that interpret bytes on the wire.
0000000000000000000000000000000000000000;;	// Those that take integer types all return uint64 and are
0000000000000000000000000000000000000000;;	// therefore of type valueDecoder.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeVarint reads a varint-encoded integer from the slice.
0000000000000000000000000000000000000000;;	// It returns the integer and the number of bytes consumed, or
0000000000000000000000000000000000000000;;	// zero if there is not enough.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// int32, int64, uint32, uint64, bool, and enum
0000000000000000000000000000000000000000;;	// protocol buffer types.
0000000000000000000000000000000000000000;;	func DecodeVarint(buf []byte) (x uint64, n int) {
0000000000000000000000000000000000000000;;		for shift := uint(0); shift < 64; shift += 7 {
0000000000000000000000000000000000000000;;			if n >= len(buf) {
0000000000000000000000000000000000000000;;				return 0, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b := uint64(buf[n])
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;			x |= (b & 0x7F) << shift
0000000000000000000000000000000000000000;;			if (b & 0x80) == 0 {
0000000000000000000000000000000000000000;;				return x, n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number is too large to represent in a 64-bit value.
0000000000000000000000000000000000000000;;		return 0, 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Buffer) decodeVarintSlow() (x uint64, err error) {
0000000000000000000000000000000000000000;;		i := p.index
0000000000000000000000000000000000000000;;		l := len(p.buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for shift := uint(0); shift < 64; shift += 7 {
0000000000000000000000000000000000000000;;			if i >= l {
0000000000000000000000000000000000000000;;				err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b := p.buf[i]
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			x |= (uint64(b) & 0x7F) << shift
0000000000000000000000000000000000000000;;			if b < 0x80 {
0000000000000000000000000000000000000000;;				p.index = i
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number is too large to represent in a 64-bit value.
0000000000000000000000000000000000000000;;		err = errOverflow
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeVarint reads a varint-encoded integer from the Buffer.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// int32, int64, uint32, uint64, bool, and enum
0000000000000000000000000000000000000000;;	// protocol buffer types.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeVarint() (x uint64, err error) {
0000000000000000000000000000000000000000;;		i := p.index
0000000000000000000000000000000000000000;;		buf := p.buf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i >= len(buf) {
0000000000000000000000000000000000000000;;			return 0, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		} else if buf[i] < 0x80 {
0000000000000000000000000000000000000000;;			p.index++
0000000000000000000000000000000000000000;;			return uint64(buf[i]), nil
0000000000000000000000000000000000000000;;		} else if len(buf)-i < 10 {
0000000000000000000000000000000000000000;;			return p.decodeVarintSlow()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var b uint64
0000000000000000000000000000000000000000;;		// we already checked the first byte
0000000000000000000000000000000000000000;;		x = uint64(buf[i]) - 0x80
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 7
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 14
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 14
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 21
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 21
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 28
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 28
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 35
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 35
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 42
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 42
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 49
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 49
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 56
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x -= 0x80 << 56
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b = uint64(buf[i])
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		x += b << 63
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			goto done
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// x -= 0x80 << 63 // Always zero.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0, errOverflow
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	done:
0000000000000000000000000000000000000000;;		p.index = i
0000000000000000000000000000000000000000;;		return x, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeFixed64 reads a 64-bit integer from the Buffer.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// fixed64, sfixed64, and double protocol buffer types.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeFixed64() (x uint64, err error) {
0000000000000000000000000000000000000000;;		// x, err already 0
0000000000000000000000000000000000000000;;		i := p.index + 8
0000000000000000000000000000000000000000;;		if i < 0 || i > len(p.buf) {
0000000000000000000000000000000000000000;;			err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.index = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x = uint64(p.buf[i-8])
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-7]) << 8
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-6]) << 16
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-5]) << 24
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-4]) << 32
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-3]) << 40
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-2]) << 48
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-1]) << 56
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeFixed32 reads a 32-bit integer from the Buffer.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// fixed32, sfixed32, and float protocol buffer types.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeFixed32() (x uint64, err error) {
0000000000000000000000000000000000000000;;		// x, err already 0
0000000000000000000000000000000000000000;;		i := p.index + 4
0000000000000000000000000000000000000000;;		if i < 0 || i > len(p.buf) {
0000000000000000000000000000000000000000;;			err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.index = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x = uint64(p.buf[i-4])
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-3]) << 8
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-2]) << 16
0000000000000000000000000000000000000000;;		x |= uint64(p.buf[i-1]) << 24
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeZigzag64 reads a zigzag-encoded 64-bit integer
0000000000000000000000000000000000000000;;	// from the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the sint64 protocol buffer type.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeZigzag64() (x uint64, err error) {
0000000000000000000000000000000000000000;;		x, err = p.DecodeVarint()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x = (x >> 1) ^ uint64((int64(x&1)<<63)>>63)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeZigzag32 reads a zigzag-encoded 32-bit integer
0000000000000000000000000000000000000000;;	// from  the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the sint32 protocol buffer type.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeZigzag32() (x uint64, err error) {
0000000000000000000000000000000000000000;;		x, err = p.DecodeVarint()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x = uint64((uint32(x) >> 1) ^ uint32((int32(x&1)<<31)>>31))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are not ValueDecoders: they produce an array of bytes or a string.
0000000000000000000000000000000000000000;;	// bytes, embedded messages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeRawBytes reads a count-delimited byte buffer from the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the bytes protocol buffer
0000000000000000000000000000000000000000;;	// type and for embedded messages.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeRawBytes(alloc bool) (buf []byte, err error) {
0000000000000000000000000000000000000000;;		n, err := p.DecodeVarint()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nb := int(n)
0000000000000000000000000000000000000000;;		if nb < 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("proto: bad byte length %d", nb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end := p.index + nb
0000000000000000000000000000000000000000;;		if end < p.index || end > len(p.buf) {
0000000000000000000000000000000000000000;;			return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !alloc {
0000000000000000000000000000000000000000;;			// todo: check if can get more uses of alloc=false
0000000000000000000000000000000000000000;;			buf = p.buf[p.index:end]
0000000000000000000000000000000000000000;;			p.index += nb
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf = make([]byte, nb)
0000000000000000000000000000000000000000;;		copy(buf, p.buf[p.index:])
0000000000000000000000000000000000000000;;		p.index += nb
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeStringBytes reads an encoded string from the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the proto2 string type.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeStringBytes() (s string, err error) {
0000000000000000000000000000000000000000;;		buf, err := p.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Skip the next item in the buffer. Its wire type is decoded and presented as an argument.
0000000000000000000000000000000000000000;;	// If the protocol buffer has extensions, and the field matches, add it as an extension.
0000000000000000000000000000000000000000;;	// Otherwise, if the XXX_unrecognized field exists, append the skipped data there.
0000000000000000000000000000000000000000;;	func (o *Buffer) skipAndSave(t reflect.Type, tag, wire int, base structPointer, unrecField field) error {
0000000000000000000000000000000000000000;;		oi := o.index
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := o.skip(t, tag, wire)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !unrecField.IsValid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ptr := structPointer_Bytes(base, unrecField)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the skipped field to struct field
0000000000000000000000000000000000000000;;		obuf := o.buf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = *ptr
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64(tag<<3 | wire))
0000000000000000000000000000000000000000;;		*ptr = append(o.buf, obuf[oi:o.index]...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = obuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Skip the next item in the buffer. Its wire type is decoded and presented as an argument.
0000000000000000000000000000000000000000;;	func (o *Buffer) skip(t reflect.Type, tag, wire int) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var u uint64
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch wire {
0000000000000000000000000000000000000000;;		case WireVarint:
0000000000000000000000000000000000000000;;			_, err = o.DecodeVarint()
0000000000000000000000000000000000000000;;		case WireFixed64:
0000000000000000000000000000000000000000;;			_, err = o.DecodeFixed64()
0000000000000000000000000000000000000000;;		case WireBytes:
0000000000000000000000000000000000000000;;			_, err = o.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		case WireFixed32:
0000000000000000000000000000000000000000;;			_, err = o.DecodeFixed32()
0000000000000000000000000000000000000000;;		case WireStartGroup:
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				u, err = o.DecodeVarint()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fwire := int(u & 0x7)
0000000000000000000000000000000000000000;;				if fwire == WireEndGroup {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ftag := int(u >> 3)
0000000000000000000000000000000000000000;;				err = o.skip(t, ftag, fwire)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("proto: can't skip unknown wire type %d for %s", wire, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshaler is the interface representing objects that can
0000000000000000000000000000000000000000;;	// unmarshal themselves.  The method should reset the receiver before
0000000000000000000000000000000000000000;;	// decoding starts.  The argument points to data that may be
0000000000000000000000000000000000000000;;	// overwritten, so implementations should not keep references to the
0000000000000000000000000000000000000000;;	// buffer.
0000000000000000000000000000000000000000;;	type Unmarshaler interface {
0000000000000000000000000000000000000000;;		Unmarshal([]byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal parses the protocol buffer representation in buf and places the
0000000000000000000000000000000000000000;;	// decoded result in pb.  If the struct underlying pb does not match
0000000000000000000000000000000000000000;;	// the data in buf, the results can be unpredictable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal resets pb before starting to unmarshal, so any
0000000000000000000000000000000000000000;;	// existing data in pb is always removed. Use UnmarshalMerge
0000000000000000000000000000000000000000;;	// to preserve and append to existing data.
0000000000000000000000000000000000000000;;	func Unmarshal(buf []byte, pb Message) error {
0000000000000000000000000000000000000000;;		pb.Reset()
0000000000000000000000000000000000000000;;		return UnmarshalMerge(buf, pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalMerge parses the protocol buffer representation in buf and
0000000000000000000000000000000000000000;;	// writes the decoded result to pb.  If the struct underlying pb does not match
0000000000000000000000000000000000000000;;	// the data in buf, the results can be unpredictable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// UnmarshalMerge merges into existing data in pb.
0000000000000000000000000000000000000000;;	// Most code should use Unmarshal instead.
0000000000000000000000000000000000000000;;	func UnmarshalMerge(buf []byte, pb Message) error {
0000000000000000000000000000000000000000;;		// If the object can unmarshal itself, let it.
0000000000000000000000000000000000000000;;		if u, ok := pb.(Unmarshaler); ok {
0000000000000000000000000000000000000000;;			return u.Unmarshal(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewBuffer(buf).Unmarshal(pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeMessage reads a count-delimited message from the Buffer.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeMessage(pb Message) error {
0000000000000000000000000000000000000000;;		enc, err := p.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewBuffer(enc).Unmarshal(pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeGroup reads a tag-delimited group from the Buffer.
0000000000000000000000000000000000000000;;	func (p *Buffer) DecodeGroup(pb Message) error {
0000000000000000000000000000000000000000;;		typ, base, err := getbase(pb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.unmarshalType(typ.Elem(), GetProperties(typ.Elem()), true, base)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal parses the protocol buffer representation in the
0000000000000000000000000000000000000000;;	// Buffer and places the decoded result in pb.  If the struct
0000000000000000000000000000000000000000;;	// underlying pb does not match the data in the buffer, the results can be
0000000000000000000000000000000000000000;;	// unpredictable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unlike proto.Unmarshal, this does not reset pb before starting to unmarshal.
0000000000000000000000000000000000000000;;	func (p *Buffer) Unmarshal(pb Message) error {
0000000000000000000000000000000000000000;;		// If the object can unmarshal itself, let it.
0000000000000000000000000000000000000000;;		if u, ok := pb.(Unmarshaler); ok {
0000000000000000000000000000000000000000;;			err := u.Unmarshal(p.buf[p.index:])
0000000000000000000000000000000000000000;;			p.index = len(p.buf)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typ, base, err := getbase(pb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = p.unmarshalType(typ.Elem(), GetProperties(typ.Elem()), false, base)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if collectStats {
0000000000000000000000000000000000000000;;			stats.Decode++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalType does the work of unmarshaling a structure.
0000000000000000000000000000000000000000;;	func (o *Buffer) unmarshalType(st reflect.Type, prop *StructProperties, is_group bool, base structPointer) error {
0000000000000000000000000000000000000000;;		var state errorState
0000000000000000000000000000000000000000;;		required, reqFields := prop.reqCount, uint64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for err == nil && o.index < len(o.buf) {
0000000000000000000000000000000000000000;;			oi := o.index
0000000000000000000000000000000000000000;;			var u uint64
0000000000000000000000000000000000000000;;			u, err = o.DecodeVarint()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wire := int(u & 0x7)
0000000000000000000000000000000000000000;;			if wire == WireEndGroup {
0000000000000000000000000000000000000000;;				if is_group {
0000000000000000000000000000000000000000;;					if required > 0 {
0000000000000000000000000000000000000000;;						// Not enough information to determine the exact field.
0000000000000000000000000000000000000000;;						// (See below.)
0000000000000000000000000000000000000000;;						return &RequiredNotSetError{"{Unknown}"}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil // input is satisfied
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("proto: %s: wiretype end group for non-group", st)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tag := int(u >> 3)
0000000000000000000000000000000000000000;;			if tag <= 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("proto: %s: illegal tag %d (wire type %d)", st, tag, wire)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fieldnum, ok := prop.decoderTags.get(tag)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// Maybe it's an extension?
0000000000000000000000000000000000000000;;				if prop.extendable {
0000000000000000000000000000000000000000;;					if e, _ := extendable(structPointer_Interface(base, st)); isExtensionField(e, int32(tag)) {
0000000000000000000000000000000000000000;;						if err = o.skip(st, tag, wire); err == nil {
0000000000000000000000000000000000000000;;							extmap := e.extensionsWrite()
0000000000000000000000000000000000000000;;							ext := extmap[int32(tag)] // may be missing
0000000000000000000000000000000000000000;;							ext.enc = append(ext.enc, o.buf[oi:o.index]...)
0000000000000000000000000000000000000000;;							extmap[int32(tag)] = ext
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Maybe it's a oneof?
0000000000000000000000000000000000000000;;				if prop.oneofUnmarshaler != nil {
0000000000000000000000000000000000000000;;					m := structPointer_Interface(base, st).(Message)
0000000000000000000000000000000000000000;;					// First return value indicates whether tag is a oneof field.
0000000000000000000000000000000000000000;;					ok, err = prop.oneofUnmarshaler(m, tag, wire, o)
0000000000000000000000000000000000000000;;					if err == ErrInternalBadWireType {
0000000000000000000000000000000000000000;;						// Map the error to something more descriptive.
0000000000000000000000000000000000000000;;						// Do the formatting here to save generated code space.
0000000000000000000000000000000000000000;;						err = fmt.Errorf("bad wiretype for oneof field in %T", m)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = o.skipAndSave(st, tag, wire, base, prop.unrecField)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p := prop.Prop[fieldnum]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.dec == nil {
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "proto: no protobuf decoder for %s.%s\n", st, st.Field(fieldnum).Name)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec := p.dec
0000000000000000000000000000000000000000;;			if wire != WireStartGroup && wire != p.WireType {
0000000000000000000000000000000000000000;;				if wire == WireBytes && p.packedDec != nil {
0000000000000000000000000000000000000000;;					// a packable field
0000000000000000000000000000000000000000;;					dec = p.packedDec
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("proto: bad wiretype for field %s.%s: got wiretype %d, want %d", st, st.Field(fieldnum).Name, wire, p.WireType)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			decErr := dec(o, p, base)
0000000000000000000000000000000000000000;;			if decErr != nil && !state.shouldContinue(decErr, p) {
0000000000000000000000000000000000000000;;				err = decErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && p.Required {
0000000000000000000000000000000000000000;;				// Successfully decoded a required field.
0000000000000000000000000000000000000000;;				if tag <= 64 {
0000000000000000000000000000000000000000;;					// use bitmap for fields 1-64 to catch field reuse.
0000000000000000000000000000000000000000;;					var mask uint64 = 1 << uint64(tag-1)
0000000000000000000000000000000000000000;;					if reqFields&mask == 0 {
0000000000000000000000000000000000000000;;						// new required field
0000000000000000000000000000000000000000;;						reqFields |= mask
0000000000000000000000000000000000000000;;						required--
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// This is imprecise. It can be fooled by a required field
0000000000000000000000000000000000000000;;					// with a tag > 64 that is encoded twice; that's very rare.
0000000000000000000000000000000000000000;;					// A fully correct implementation would require allocating
0000000000000000000000000000000000000000;;					// a data structure, which we would like to avoid.
0000000000000000000000000000000000000000;;					required--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if is_group {
0000000000000000000000000000000000000000;;				return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if state.err != nil {
0000000000000000000000000000000000000000;;				return state.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if required > 0 {
0000000000000000000000000000000000000000;;				// Not enough information to determine the exact field. If we use extra
0000000000000000000000000000000000000000;;				// CPU, we could determine the field only if the missing required field
0000000000000000000000000000000000000000;;				// has a tag <= 64 and we check reqFields.
0000000000000000000000000000000000000000;;				return &RequiredNotSetError{"{Unknown}"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Individual type decoders
0000000000000000000000000000000000000000;;	// For each,
0000000000000000000000000000000000000000;;	//	u is the decoded value,
0000000000000000000000000000000000000000;;	//	v is a pointer to the field (pointer) in the struct
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sizes of the pools to allocate inside the Buffer.
0000000000000000000000000000000000000000;;	// The goal is modest amortization and allocation
0000000000000000000000000000000000000000;;	// on at least 16-byte boundaries.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		boolPoolSize   = 16
0000000000000000000000000000000000000000;;		uint32PoolSize = 8
0000000000000000000000000000000000000000;;		uint64PoolSize = 4
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a bool.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(o.bools) == 0 {
0000000000000000000000000000000000000000;;			o.bools = make([]bool, boolPoolSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.bools[0] = u != 0
0000000000000000000000000000000000000000;;		*structPointer_Bool(base, p.field) = &o.bools[0]
0000000000000000000000000000000000000000;;		o.bools = o.bools[1:]
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_proto3_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*structPointer_BoolVal(base, p.field) = u != 0
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode an int32.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		word32_Set(structPointer_Word32(base, p.field), o, uint32(u))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_proto3_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		word32Val_Set(structPointer_Word32Val(base, p.field), uint32(u))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode an int64.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		word64_Set(structPointer_Word64(base, p.field), o, u)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_proto3_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		word64Val_Set(structPointer_Word64Val(base, p.field), o, u)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a string.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_string(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s, err := o.DecodeStringBytes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*structPointer_String(base, p.field) = &s
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_proto3_string(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s, err := o.DecodeStringBytes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*structPointer_StringVal(base, p.field) = s
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of bytes ([]byte).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_byte(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		b, err := o.DecodeRawBytes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*structPointer_Bytes(base, p.field) = b
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of bools ([]bool).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := structPointer_BoolSlice(base, p.field)
0000000000000000000000000000000000000000;;		*v = append(*v, u != 0)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of bools ([]bool) in packed format.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_packed_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_BoolSlice(base, p.field)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nn, err := o.DecodeVarint()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nb := int(nn) // number of bytes of encoded bools
0000000000000000000000000000000000000000;;		fin := o.index + nb
0000000000000000000000000000000000000000;;		if fin < o.index {
0000000000000000000000000000000000000000;;			return errOverflow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		y := *v
0000000000000000000000000000000000000000;;		for o.index < fin {
0000000000000000000000000000000000000000;;			u, err := p.valDec(o)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			y = append(y, u != 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*v = y
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of int32s ([]int32).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		structPointer_Word32Slice(base, p.field).Append(uint32(u))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of int32s ([]int32) in packed format.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_packed_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nn, err := o.DecodeVarint()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nb := int(nn) // number of bytes of encoded int32s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fin := o.index + nb
0000000000000000000000000000000000000000;;		if fin < o.index {
0000000000000000000000000000000000000000;;			return errOverflow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for o.index < fin {
0000000000000000000000000000000000000000;;			u, err := p.valDec(o)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Append(uint32(u))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of int64s ([]int64).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		u, err := p.valDec(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		structPointer_Word64Slice(base, p.field).Append(u)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of int64s ([]int64) in packed format.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_packed_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word64Slice(base, p.field)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nn, err := o.DecodeVarint()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nb := int(nn) // number of bytes of encoded int64s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fin := o.index + nb
0000000000000000000000000000000000000000;;		if fin < o.index {
0000000000000000000000000000000000000000;;			return errOverflow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for o.index < fin {
0000000000000000000000000000000000000000;;			u, err := p.valDec(o)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Append(u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of strings ([]string).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_string(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s, err := o.DecodeStringBytes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := structPointer_StringSlice(base, p.field)
0000000000000000000000000000000000000000;;		*v = append(*v, s)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of slice of bytes ([][]byte).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_slice_byte(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		b, err := o.DecodeRawBytes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := structPointer_BytesSlice(base, p.field)
0000000000000000000000000000000000000000;;		*v = append(*v, b)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a map field.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_new_map(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		raw, err := o.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oi := o.index       // index at the end of this map entry
0000000000000000000000000000000000000000;;		o.index -= len(raw) // move buffer back to start of map entry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mptr := structPointer_NewAt(base, p.field, p.mtype) // *map[K]V
0000000000000000000000000000000000000000;;		if mptr.Elem().IsNil() {
0000000000000000000000000000000000000000;;			mptr.Elem().Set(reflect.MakeMap(mptr.Type().Elem()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := mptr.Elem() // map[K]V
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prepare addressable doubly-indirect placeholders for the key and value types.
0000000000000000000000000000000000000000;;		// See enc_new_map for why.
0000000000000000000000000000000000000000;;		keyptr := reflect.New(reflect.PtrTo(p.mtype.Key())).Elem() // addressable *K
0000000000000000000000000000000000000000;;		keybase := toStructPointer(keyptr.Addr())                  // **K
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var valbase structPointer
0000000000000000000000000000000000000000;;		var valptr reflect.Value
0000000000000000000000000000000000000000;;		switch p.mtype.Elem().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			// []byte
0000000000000000000000000000000000000000;;			var dummy []byte
0000000000000000000000000000000000000000;;			valptr = reflect.ValueOf(&dummy)  // *[]byte
0000000000000000000000000000000000000000;;			valbase = toStructPointer(valptr) // *[]byte
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			// message; valptr is **Msg; need to allocate the intermediate pointer
0000000000000000000000000000000000000000;;			valptr = reflect.New(reflect.PtrTo(p.mtype.Elem())).Elem() // addressable *V
0000000000000000000000000000000000000000;;			valptr.Set(reflect.New(valptr.Type().Elem()))
0000000000000000000000000000000000000000;;			valbase = toStructPointer(valptr)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// everything else
0000000000000000000000000000000000000000;;			valptr = reflect.New(reflect.PtrTo(p.mtype.Elem())).Elem() // addressable *V
0000000000000000000000000000000000000000;;			valbase = toStructPointer(valptr.Addr())                   // **V
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decode.
0000000000000000000000000000000000000000;;		// This parses a restricted wire format, namely the encoding of a message
0000000000000000000000000000000000000000;;		// with two fields. See enc_new_map for the format.
0000000000000000000000000000000000000000;;		for o.index < oi {
0000000000000000000000000000000000000000;;			// tagcode for key and value properties are always a single byte
0000000000000000000000000000000000000000;;			// because they have tags 1 and 2.
0000000000000000000000000000000000000000;;			tagcode := o.buf[o.index]
0000000000000000000000000000000000000000;;			o.index++
0000000000000000000000000000000000000000;;			switch tagcode {
0000000000000000000000000000000000000000;;			case p.mkeyprop.tagcode[0]:
0000000000000000000000000000000000000000;;				if err := p.mkeyprop.dec(o, p.mkeyprop, keybase); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case p.mvalprop.tagcode[0]:
0000000000000000000000000000000000000000;;				if err := p.mvalprop.dec(o, p.mvalprop, valbase); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// TODO: Should we silently skip this instead?
0000000000000000000000000000000000000000;;				return fmt.Errorf("proto: bad map data tag %d", raw[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyelem, valelem := keyptr.Elem(), valptr.Elem()
0000000000000000000000000000000000000000;;		if !keyelem.IsValid() {
0000000000000000000000000000000000000000;;			keyelem = reflect.Zero(p.mtype.Key())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !valelem.IsValid() {
0000000000000000000000000000000000000000;;			valelem = reflect.Zero(p.mtype.Elem())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.SetMapIndex(keyelem, valelem)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a group.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_struct_group(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		bas := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(bas) {
0000000000000000000000000000000000000000;;			// allocate new nested message
0000000000000000000000000000000000000000;;			bas = toStructPointer(reflect.New(p.stype))
0000000000000000000000000000000000000000;;			structPointer_SetStructPointer(base, p.field, bas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o.unmarshalType(p.stype, p.sprop, true, bas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode an embedded message.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_struct_message(p *Properties, base structPointer) (err error) {
0000000000000000000000000000000000000000;;		raw, e := o.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bas := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(bas) {
0000000000000000000000000000000000000000;;			// allocate new nested message
0000000000000000000000000000000000000000;;			bas = toStructPointer(reflect.New(p.stype))
0000000000000000000000000000000000000000;;			structPointer_SetStructPointer(base, p.field, bas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the object can unmarshal itself, let it.
0000000000000000000000000000000000000000;;		if p.isUnmarshaler {
0000000000000000000000000000000000000000;;			iv := structPointer_Interface(bas, p.stype)
0000000000000000000000000000000000000000;;			return iv.(Unmarshaler).Unmarshal(raw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obuf := o.buf
0000000000000000000000000000000000000000;;		oi := o.index
0000000000000000000000000000000000000000;;		o.buf = raw
0000000000000000000000000000000000000000;;		o.index = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = o.unmarshalType(p.stype, p.sprop, false, bas)
0000000000000000000000000000000000000000;;		o.buf = obuf
0000000000000000000000000000000000000000;;		o.index = oi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of embedded messages.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_struct_message(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		return o.dec_slice_struct(p, false, base)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of embedded groups.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_struct_group(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		return o.dec_slice_struct(p, true, base)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of structs ([]*struct).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_struct(p *Properties, is_group bool, base structPointer) error {
0000000000000000000000000000000000000000;;		v := reflect.New(p.stype)
0000000000000000000000000000000000000000;;		bas := toStructPointer(v)
0000000000000000000000000000000000000000;;		structPointer_StructPointerSlice(base, p.field).Append(bas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if is_group {
0000000000000000000000000000000000000000;;			err := o.unmarshalType(p.stype, p.sprop, is_group, bas)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw, err := o.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the object can unmarshal itself, let it.
0000000000000000000000000000000000000000;;		if p.isUnmarshaler {
0000000000000000000000000000000000000000;;			iv := v.Interface()
0000000000000000000000000000000000000000;;			return iv.(Unmarshaler).Unmarshal(raw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obuf := o.buf
0000000000000000000000000000000000000000;;		oi := o.index
0000000000000000000000000000000000000000;;		o.buf = raw
0000000000000000000000000000000000000000;;		o.index = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = o.unmarshalType(p.stype, p.sprop, is_group, bas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = obuf
0000000000000000000000000000000000000000;;		o.index = oi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
