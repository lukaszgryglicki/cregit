0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/github.com/golang/protobuf/proto/clone.go[Godeps/_workspace/src/github.com/golang/protobuf/proto/clone.go][vendor/github.com/golang/protobuf/proto/clone.go];	
0000000000000000000000000000000000000000;;	// Protocol buffer deep copy and merge.
0000000000000000000000000000000000000000;;	// TODO: RawMessage.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clone returns a deep copy of a protocol buffer.
0000000000000000000000000000000000000000;;	func Clone(pb Message) Message {
0000000000000000000000000000000000000000;;		in := reflect.ValueOf(pb)
0000000000000000000000000000000000000000;;		if in.IsNil() {
0000000000000000000000000000000000000000;;			return pb
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := reflect.New(in.Type().Elem())
0000000000000000000000000000000000000000;;		// out is empty so a merge is a deep copy.
0000000000000000000000000000000000000000;;		mergeStruct(out.Elem(), in.Elem())
0000000000000000000000000000000000000000;;		return out.Interface().(Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge merges src into dst.
0000000000000000000000000000000000000000;;	// Required and optional fields that are set in src will be set to that value in dst.
0000000000000000000000000000000000000000;;	// Elements of repeated fields will be appended.
0000000000000000000000000000000000000000;;	// Merge panics if src and dst are not the same type, or if dst is nil.
0000000000000000000000000000000000000000;;	func Merge(dst, src Message) {
0000000000000000000000000000000000000000;;		in := reflect.ValueOf(src)
0000000000000000000000000000000000000000;;		out := reflect.ValueOf(dst)
0000000000000000000000000000000000000000;;		if out.IsNil() {
0000000000000000000000000000000000000000;;			panic("proto: nil destination")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if in.Type() != out.Type() {
0000000000000000000000000000000000000000;;			// Explicit test prior to mergeStruct so that mistyped nils will fail
0000000000000000000000000000000000000000;;			panic("proto: type mismatch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if in.IsNil() {
0000000000000000000000000000000000000000;;			// Merging nil into non-nil is a quiet no-op
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergeStruct(out.Elem(), in.Elem())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeStruct(out, in reflect.Value) {
0000000000000000000000000000000000000000;;		sprop := GetProperties(in.Type())
0000000000000000000000000000000000000000;;		for i := 0; i < in.NumField(); i++ {
0000000000000000000000000000000000000000;;			f := in.Type().Field(i)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(f.Name, "XXX_") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergeAny(out.Field(i), in.Field(i), false, sprop.Prop[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if emIn, ok := extendable(in.Addr().Interface()); ok {
0000000000000000000000000000000000000000;;			emOut, _ := extendable(out.Addr().Interface())
0000000000000000000000000000000000000000;;			mIn, muIn := emIn.extensionsRead()
0000000000000000000000000000000000000000;;			if mIn != nil {
0000000000000000000000000000000000000000;;				mOut := emOut.extensionsWrite()
0000000000000000000000000000000000000000;;				muIn.Lock()
0000000000000000000000000000000000000000;;				mergeExtension(mOut, mIn)
0000000000000000000000000000000000000000;;				muIn.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uf := in.FieldByName("XXX_unrecognized")
0000000000000000000000000000000000000000;;		if !uf.IsValid() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uin := uf.Bytes()
0000000000000000000000000000000000000000;;		if len(uin) > 0 {
0000000000000000000000000000000000000000;;			out.FieldByName("XXX_unrecognized").SetBytes(append([]byte(nil), uin...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeAny performs a merge between two values of the same type.
0000000000000000000000000000000000000000;;	// viaPtr indicates whether the values were indirected through a pointer (implying proto2).
0000000000000000000000000000000000000000;;	// prop is set if this is a struct field (it may be nil).
0000000000000000000000000000000000000000;;	func mergeAny(out, in reflect.Value, viaPtr bool, prop *Properties) {
0000000000000000000000000000000000000000;;		if in.Type() == protoMessageType {
0000000000000000000000000000000000000000;;			if !in.IsNil() {
0000000000000000000000000000000000000000;;				if out.IsNil() {
0000000000000000000000000000000000000000;;					out.Set(reflect.ValueOf(Clone(in.Interface().(Message))))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					Merge(out.Interface().(Message), in.Interface().(Message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch in.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool, reflect.Float32, reflect.Float64, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;			reflect.String, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			if !viaPtr && isProto3Zero(in) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Set(in)
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// Probably a oneof field; copy non-nil values.
0000000000000000000000000000000000000000;;			if in.IsNil() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Allocate destination if it is not set, or set to a different type.
0000000000000000000000000000000000000000;;			// Otherwise we will merge as normal.
0000000000000000000000000000000000000000;;			if out.IsNil() || out.Elem().Type() != in.Elem().Type() {
0000000000000000000000000000000000000000;;				out.Set(reflect.New(in.Elem().Elem().Type())) // interface -> *T -> T -> new(T)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergeAny(out.Elem(), in.Elem(), false, nil)
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if in.Len() == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out.IsNil() {
0000000000000000000000000000000000000000;;				out.Set(reflect.MakeMap(in.Type()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// For maps with value types of *T or []byte we need to deep copy each value.
0000000000000000000000000000000000000000;;			elemKind := in.Type().Elem().Kind()
0000000000000000000000000000000000000000;;			for _, key := range in.MapKeys() {
0000000000000000000000000000000000000000;;				var val reflect.Value
0000000000000000000000000000000000000000;;				switch elemKind {
0000000000000000000000000000000000000000;;				case reflect.Ptr:
0000000000000000000000000000000000000000;;					val = reflect.New(in.Type().Elem().Elem())
0000000000000000000000000000000000000000;;					mergeAny(val, in.MapIndex(key), false, nil)
0000000000000000000000000000000000000000;;				case reflect.Slice:
0000000000000000000000000000000000000000;;					val = in.MapIndex(key)
0000000000000000000000000000000000000000;;					val = reflect.ValueOf(append([]byte{}, val.Bytes()...))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					val = in.MapIndex(key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out.SetMapIndex(key, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if in.IsNil() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out.IsNil() {
0000000000000000000000000000000000000000;;				out.Set(reflect.New(in.Elem().Type()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergeAny(out.Elem(), in.Elem(), true, nil)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if in.IsNil() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if in.Type().Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				// []byte is a scalar bytes field, not a repeated field.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Edge case: if this is in a proto3 message, a zero length
0000000000000000000000000000000000000000;;				// bytes field is considered the zero value, and should not
0000000000000000000000000000000000000000;;				// be merged.
0000000000000000000000000000000000000000;;				if prop != nil && prop.proto3 && in.Len() == 0 {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Make a deep copy.
0000000000000000000000000000000000000000;;				// Append to []byte{} instead of []byte(nil) so that we never end up
0000000000000000000000000000000000000000;;				// with a nil result.
0000000000000000000000000000000000000000;;				out.SetBytes(append([]byte{}, in.Bytes()...))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n := in.Len()
0000000000000000000000000000000000000000;;			if out.IsNil() {
0000000000000000000000000000000000000000;;				out.Set(reflect.MakeSlice(in.Type(), 0, n))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch in.Type().Elem().Kind() {
0000000000000000000000000000000000000000;;			case reflect.Bool, reflect.Float32, reflect.Float64, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;				reflect.String, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;				out.Set(reflect.AppendSlice(out, in))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;					x := reflect.Indirect(reflect.New(in.Type().Elem()))
0000000000000000000000000000000000000000;;					mergeAny(x, in.Index(i), false, nil)
0000000000000000000000000000000000000000;;					out.Set(reflect.Append(out, x))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			mergeStruct(out, in)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// unknown type, so not a protocol buffer
0000000000000000000000000000000000000000;;			log.Printf("proto: don't know how to copy %v", in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeExtension(out, in map[int32]Extension) {
0000000000000000000000000000000000000000;;		for extNum, eIn := range in {
0000000000000000000000000000000000000000;;			eOut := Extension{desc: eIn.desc}
0000000000000000000000000000000000000000;;			if eIn.value != nil {
0000000000000000000000000000000000000000;;				v := reflect.New(reflect.TypeOf(eIn.value)).Elem()
0000000000000000000000000000000000000000;;				mergeAny(v, reflect.ValueOf(eIn.value), false, nil)
0000000000000000000000000000000000000000;;				eOut.value = v.Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if eIn.enc != nil {
0000000000000000000000000000000000000000;;				eOut.enc = make([]byte, len(eIn.enc))
0000000000000000000000000000000000000000;;				copy(eOut.enc, eIn.enc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out[extNum] = eOut
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
