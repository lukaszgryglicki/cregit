0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/github.com/golang/protobuf/proto/text_parser.go[Godeps/_workspace/src/github.com/golang/protobuf/proto/text_parser.go][vendor/github.com/golang/protobuf/proto/text_parser.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Functions for parsing the Text protocol buffer format.
0000000000000000000000000000000000000000;;	// TODO: message sets.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error string emitted when deserializing Any and fields are already set
0000000000000000000000000000000000000000;;	const anyRepeatedlyUnpacked = "Any message unpacked multiple times, or %q already set"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ParseError struct {
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;		Line    int // 1-based line number
0000000000000000000000000000000000000000;;		Offset  int // 0-based byte offset from start of input
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ParseError) Error() string {
0000000000000000000000000000000000000000;;		if p.Line == 1 {
0000000000000000000000000000000000000000;;			// show offset only for first line
0000000000000000000000000000000000000000;;			return fmt.Sprintf("line 1.%d: %v", p.Offset, p.Message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("line %d: %v", p.Line, p.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type token struct {
0000000000000000000000000000000000000000;;		value    string
0000000000000000000000000000000000000000;;		err      *ParseError
0000000000000000000000000000000000000000;;		line     int    // line number
0000000000000000000000000000000000000000;;		offset   int    // byte number from start of input, not start of line
0000000000000000000000000000000000000000;;		unquoted string // the unquoted version of value, if it was a quoted string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *token) String() string {
0000000000000000000000000000000000000000;;		if t.err == nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%q (line=%d, offset=%d)", t.value, t.line, t.offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("parse error: %v", t.err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type textParser struct {
0000000000000000000000000000000000000000;;		s            string // remaining input
0000000000000000000000000000000000000000;;		done         bool   // whether the parsing is finished (success or error)
0000000000000000000000000000000000000000;;		backed       bool   // whether back() was called
0000000000000000000000000000000000000000;;		offset, line int
0000000000000000000000000000000000000000;;		cur          token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTextParser(s string) *textParser {
0000000000000000000000000000000000000000;;		p := new(textParser)
0000000000000000000000000000000000000000;;		p.s = s
0000000000000000000000000000000000000000;;		p.line = 1
0000000000000000000000000000000000000000;;		p.cur.line = 1
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *textParser) errorf(format string, a ...interface{}) *ParseError {
0000000000000000000000000000000000000000;;		pe := &ParseError{fmt.Sprintf(format, a...), p.cur.line, p.cur.offset}
0000000000000000000000000000000000000000;;		p.cur.err = pe
0000000000000000000000000000000000000000;;		p.done = true
0000000000000000000000000000000000000000;;		return pe
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Numbers and identifiers are matched by [-+._A-Za-z0-9]
0000000000000000000000000000000000000000;;	func isIdentOrNumberChar(c byte) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case 'A' <= c && c <= 'Z', 'a' <= c && c <= 'z':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case '0' <= c && c <= '9':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-', '+', '.', '_':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isWhitespace(c byte) bool {
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case ' ', '\t', '\n', '\r':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isQuote(c byte) bool {
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '"', '\'':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *textParser) skipWhitespace() {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < len(p.s) && (isWhitespace(p.s[i]) || p.s[i] == '#') {
0000000000000000000000000000000000000000;;			if p.s[i] == '#' {
0000000000000000000000000000000000000000;;				// comment; skip to end of line or input
0000000000000000000000000000000000000000;;				for i < len(p.s) && p.s[i] != '\n' {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i == len(p.s) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.s[i] == '\n' {
0000000000000000000000000000000000000000;;				p.line++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.offset += i
0000000000000000000000000000000000000000;;		p.s = p.s[i:len(p.s)]
0000000000000000000000000000000000000000;;		if len(p.s) == 0 {
0000000000000000000000000000000000000000;;			p.done = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *textParser) advance() {
0000000000000000000000000000000000000000;;		// Skip whitespace
0000000000000000000000000000000000000000;;		p.skipWhitespace()
0000000000000000000000000000000000000000;;		if p.done {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start of non-whitespace
0000000000000000000000000000000000000000;;		p.cur.err = nil
0000000000000000000000000000000000000000;;		p.cur.offset, p.cur.line = p.offset, p.line
0000000000000000000000000000000000000000;;		p.cur.unquoted = ""
0000000000000000000000000000000000000000;;		switch p.s[0] {
0000000000000000000000000000000000000000;;		case '<', '>', '{', '}', ':', '[', ']', ';', ',', '/':
0000000000000000000000000000000000000000;;			// Single symbol
0000000000000000000000000000000000000000;;			p.cur.value, p.s = p.s[0:1], p.s[1:len(p.s)]
0000000000000000000000000000000000000000;;		case '"', '\'':
0000000000000000000000000000000000000000;;			// Quoted string
0000000000000000000000000000000000000000;;			i := 1
0000000000000000000000000000000000000000;;			for i < len(p.s) && p.s[i] != p.s[0] && p.s[i] != '\n' {
0000000000000000000000000000000000000000;;				if p.s[i] == '\\' && i+1 < len(p.s) {
0000000000000000000000000000000000000000;;					// skip escaped char
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i >= len(p.s) || p.s[i] != p.s[0] {
0000000000000000000000000000000000000000;;				p.errorf("unmatched quote")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unq, err := unquoteC(p.s[1:i], rune(p.s[0]))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				p.errorf("invalid quoted string %s: %v", p.s[0:i+1], err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.cur.value, p.s = p.s[0:i+1], p.s[i+1:len(p.s)]
0000000000000000000000000000000000000000;;			p.cur.unquoted = unq
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			i := 0
0000000000000000000000000000000000000000;;			for i < len(p.s) && isIdentOrNumberChar(p.s[i]) {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				p.errorf("unexpected byte %#x", p.s[0])
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.cur.value, p.s = p.s[0:i], p.s[i:len(p.s)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.offset += len(p.cur.value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errBadUTF8 = errors.New("proto: bad UTF-8")
0000000000000000000000000000000000000000;;		errBadHex  = errors.New("proto: bad hexadecimal")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unquoteC(s string, quote rune) (string, error) {
0000000000000000000000000000000000000000;;		// This is based on C++'s tokenizer.cc.
0000000000000000000000000000000000000000;;		// Despite its name, this is *not* parsing C syntax.
0000000000000000000000000000000000000000;;		// For instance, "\0" is an invalid quoted string.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Avoid allocation in trivial cases.
0000000000000000000000000000000000000000;;		simple := true
0000000000000000000000000000000000000000;;		for _, r := range s {
0000000000000000000000000000000000000000;;			if r == '\\' || r == quote {
0000000000000000000000000000000000000000;;				simple = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if simple {
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]byte, 0, 3*len(s)/2)
0000000000000000000000000000000000000000;;		for len(s) > 0 {
0000000000000000000000000000000000000000;;			r, n := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;			if r == utf8.RuneError && n == 1 {
0000000000000000000000000000000000000000;;				return "", errBadUTF8
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = s[n:]
0000000000000000000000000000000000000000;;			if r != '\\' {
0000000000000000000000000000000000000000;;				if r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;					buf = append(buf, byte(r))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					buf = append(buf, string(r)...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ch, tail, err := unescape(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = append(buf, ch...)
0000000000000000000000000000000000000000;;			s = tail
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unescape(s string) (ch string, tail string, err error) {
0000000000000000000000000000000000000000;;		r, n := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;		if r == utf8.RuneError && n == 1 {
0000000000000000000000000000000000000000;;			return "", "", errBadUTF8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = s[n:]
0000000000000000000000000000000000000000;;		switch r {
0000000000000000000000000000000000000000;;		case 'a':
0000000000000000000000000000000000000000;;			return "\a", s, nil
0000000000000000000000000000000000000000;;		case 'b':
0000000000000000000000000000000000000000;;			return "\b", s, nil
0000000000000000000000000000000000000000;;		case 'f':
0000000000000000000000000000000000000000;;			return "\f", s, nil
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			return "\n", s, nil
0000000000000000000000000000000000000000;;		case 'r':
0000000000000000000000000000000000000000;;			return "\r", s, nil
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			return "\t", s, nil
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			return "\v", s, nil
0000000000000000000000000000000000000000;;		case '?':
0000000000000000000000000000000000000000;;			return "?", s, nil // trigraph workaround
0000000000000000000000000000000000000000;;		case '\'', '"', '\\':
0000000000000000000000000000000000000000;;			return string(r), s, nil
0000000000000000000000000000000000000000;;		case '0', '1', '2', '3', '4', '5', '6', '7', 'x', 'X':
0000000000000000000000000000000000000000;;			if len(s) < 2 {
0000000000000000000000000000000000000000;;				return "", "", fmt.Errorf(`\%c requires 2 following digits`, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			base := 8
0000000000000000000000000000000000000000;;			ss := s[:2]
0000000000000000000000000000000000000000;;			s = s[2:]
0000000000000000000000000000000000000000;;			if r == 'x' || r == 'X' {
0000000000000000000000000000000000000000;;				base = 16
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ss = string(r) + ss
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i, err := strconv.ParseUint(ss, base, 8)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string([]byte{byte(i)}), s, nil
0000000000000000000000000000000000000000;;		case 'u', 'U':
0000000000000000000000000000000000000000;;			n := 4
0000000000000000000000000000000000000000;;			if r == 'U' {
0000000000000000000000000000000000000000;;				n = 8
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) < n {
0000000000000000000000000000000000000000;;				return "", "", fmt.Errorf(`\%c requires %d digits`, r, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			bs := make([]byte, n/2)
0000000000000000000000000000000000000000;;			for i := 0; i < n; i += 2 {
0000000000000000000000000000000000000000;;				a, ok1 := unhex(s[i])
0000000000000000000000000000000000000000;;				b, ok2 := unhex(s[i+1])
0000000000000000000000000000000000000000;;				if !ok1 || !ok2 {
0000000000000000000000000000000000000000;;					return "", "", errBadHex
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bs[i/2] = a<<4 | b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = s[n:]
0000000000000000000000000000000000000000;;			return string(bs), s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", fmt.Errorf(`unknown escape \%c`, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapted from src/pkg/strconv/quote.go.
0000000000000000000000000000000000000000;;	func unhex(b byte) (v byte, ok bool) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case '0' <= b && b <= '9':
0000000000000000000000000000000000000000;;			return b - '0', true
0000000000000000000000000000000000000000;;		case 'a' <= b && b <= 'f':
0000000000000000000000000000000000000000;;			return b - 'a' + 10, true
0000000000000000000000000000000000000000;;		case 'A' <= b && b <= 'F':
0000000000000000000000000000000000000000;;			return b - 'A' + 10, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Back off the parser by one token. Can only be done between calls to next().
0000000000000000000000000000000000000000;;	// It makes the next advance() a no-op.
0000000000000000000000000000000000000000;;	func (p *textParser) back() { p.backed = true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Advances the parser and returns the new current token.
0000000000000000000000000000000000000000;;	func (p *textParser) next() *token {
0000000000000000000000000000000000000000;;		if p.backed || p.done {
0000000000000000000000000000000000000000;;			p.backed = false
0000000000000000000000000000000000000000;;			return &p.cur
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.advance()
0000000000000000000000000000000000000000;;		if p.done {
0000000000000000000000000000000000000000;;			p.cur.value = ""
0000000000000000000000000000000000000000;;		} else if len(p.cur.value) > 0 && isQuote(p.cur.value[0]) {
0000000000000000000000000000000000000000;;			// Look for multiple quoted strings separated by whitespace,
0000000000000000000000000000000000000000;;			// and concatenate them.
0000000000000000000000000000000000000000;;			cat := p.cur
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				p.skipWhitespace()
0000000000000000000000000000000000000000;;				if p.done || !isQuote(p.s[0]) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.advance()
0000000000000000000000000000000000000000;;				if p.cur.err != nil {
0000000000000000000000000000000000000000;;					return &p.cur
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cat.value += " " + p.cur.value
0000000000000000000000000000000000000000;;				cat.unquoted += p.cur.unquoted
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.done = false // parser may have seen EOF, but we want to return cat
0000000000000000000000000000000000000000;;			p.cur = cat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &p.cur
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *textParser) consumeToken(s string) error {
0000000000000000000000000000000000000000;;		tok := p.next()
0000000000000000000000000000000000000000;;		if tok.err != nil {
0000000000000000000000000000000000000000;;			return tok.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.value != s {
0000000000000000000000000000000000000000;;			p.back()
0000000000000000000000000000000000000000;;			return p.errorf("expected %q, found %q", s, tok.value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a RequiredNotSetError indicating which required field was not set.
0000000000000000000000000000000000000000;;	func (p *textParser) missingRequiredFieldError(sv reflect.Value) *RequiredNotSetError {
0000000000000000000000000000000000000000;;		st := sv.Type()
0000000000000000000000000000000000000000;;		sprops := GetProperties(st)
0000000000000000000000000000000000000000;;		for i := 0; i < st.NumField(); i++ {
0000000000000000000000000000000000000000;;			if !isNil(sv.Field(i)) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			props := sprops.Prop[i]
0000000000000000000000000000000000000000;;			if props.Required {
0000000000000000000000000000000000000000;;				return &RequiredNotSetError{fmt.Sprintf("%v.%v", st, props.OrigName)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &RequiredNotSetError{fmt.Sprintf("%v.<unknown field name>", st)} // should not happen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the index in the struct for the named field, as well as the parsed tag properties.
0000000000000000000000000000000000000000;;	func structFieldByName(sprops *StructProperties, name string) (int, *Properties, bool) {
0000000000000000000000000000000000000000;;		i, ok := sprops.decoderOrigNames[name]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return i, sprops.Prop[i], true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Consume a ':' from the input stream (if the next token is a colon),
0000000000000000000000000000000000000000;;	// returning an error if a colon is needed but not present.
0000000000000000000000000000000000000000;;	func (p *textParser) checkForColon(props *Properties, typ reflect.Type) *ParseError {
0000000000000000000000000000000000000000;;		tok := p.next()
0000000000000000000000000000000000000000;;		if tok.err != nil {
0000000000000000000000000000000000000000;;			return tok.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.value != ":" {
0000000000000000000000000000000000000000;;			// Colon is optional when the field is a group or message.
0000000000000000000000000000000000000000;;			needColon := true
0000000000000000000000000000000000000000;;			switch props.Wire {
0000000000000000000000000000000000000000;;			case "group":
0000000000000000000000000000000000000000;;				needColon = false
0000000000000000000000000000000000000000;;			case "bytes":
0000000000000000000000000000000000000000;;				// A "bytes" field is either a message, a string, or a repeated field;
0000000000000000000000000000000000000000;;				// those three become *T, *string and []T respectively, so we can check for
0000000000000000000000000000000000000000;;				// this field being a pointer to a non-string.
0000000000000000000000000000000000000000;;				if typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;					// *T or *string
0000000000000000000000000000000000000000;;					if typ.Elem().Kind() == reflect.String {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if typ.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;					// []T or []*T
0000000000000000000000000000000000000000;;					if typ.Elem().Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if typ.Kind() == reflect.String {
0000000000000000000000000000000000000000;;					// The proto3 exception is for a string field,
0000000000000000000000000000000000000000;;					// which requires a colon.
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				needColon = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if needColon {
0000000000000000000000000000000000000000;;				return p.errorf("expected ':', found %q", tok.value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.back()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *textParser) readStruct(sv reflect.Value, terminator string) error {
0000000000000000000000000000000000000000;;		st := sv.Type()
0000000000000000000000000000000000000000;;		sprops := GetProperties(st)
0000000000000000000000000000000000000000;;		reqCount := sprops.reqCount
0000000000000000000000000000000000000000;;		var reqFieldErr error
0000000000000000000000000000000000000000;;		fieldSet := make(map[string]bool)
0000000000000000000000000000000000000000;;		// A struct is a sequence of "name: value", terminated by one of
0000000000000000000000000000000000000000;;		// '>' or '}', or the end of the input.  A name may also be
0000000000000000000000000000000000000000;;		// "[extension]" or "[type/url]".
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The whole struct can also be an expanded Any message, like:
0000000000000000000000000000000000000000;;		// [type/url] < ... struct contents ... >
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok := p.next()
0000000000000000000000000000000000000000;;			if tok.err != nil {
0000000000000000000000000000000000000000;;				return tok.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tok.value == terminator {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tok.value == "[" {
0000000000000000000000000000000000000000;;				// Looks like an extension or an Any.
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// TODO: Check whether we need to handle
0000000000000000000000000000000000000000;;				// namespace rooted names (e.g. ".something.Foo").
0000000000000000000000000000000000000000;;				extName, err := p.consumeExtName()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if s := strings.LastIndex(extName, "/"); s >= 0 {
0000000000000000000000000000000000000000;;					// If it contains a slash, it's an Any type URL.
0000000000000000000000000000000000000000;;					messageName := extName[s+1:]
0000000000000000000000000000000000000000;;					mt := MessageType(messageName)
0000000000000000000000000000000000000000;;					if mt == nil {
0000000000000000000000000000000000000000;;						return p.errorf("unrecognized message %q in google.protobuf.Any", messageName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tok = p.next()
0000000000000000000000000000000000000000;;					if tok.err != nil {
0000000000000000000000000000000000000000;;						return tok.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// consume an optional colon
0000000000000000000000000000000000000000;;					if tok.value == ":" {
0000000000000000000000000000000000000000;;						tok = p.next()
0000000000000000000000000000000000000000;;						if tok.err != nil {
0000000000000000000000000000000000000000;;							return tok.err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var terminator string
0000000000000000000000000000000000000000;;					switch tok.value {
0000000000000000000000000000000000000000;;					case "<":
0000000000000000000000000000000000000000;;						terminator = ">"
0000000000000000000000000000000000000000;;					case "{":
0000000000000000000000000000000000000000;;						terminator = "}"
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						return p.errorf("expected '{' or '<', found %q", tok.value)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v := reflect.New(mt.Elem())
0000000000000000000000000000000000000000;;					if pe := p.readStruct(v.Elem(), terminator); pe != nil {
0000000000000000000000000000000000000000;;						return pe
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					b, err := Marshal(v.Interface().(Message))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return p.errorf("failed to marshal message of type %q: %v", messageName, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if fieldSet["type_url"] {
0000000000000000000000000000000000000000;;						return p.errorf(anyRepeatedlyUnpacked, "type_url")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if fieldSet["value"] {
0000000000000000000000000000000000000000;;						return p.errorf(anyRepeatedlyUnpacked, "value")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sv.FieldByName("TypeUrl").SetString(extName)
0000000000000000000000000000000000000000;;					sv.FieldByName("Value").SetBytes(b)
0000000000000000000000000000000000000000;;					fieldSet["type_url"] = true
0000000000000000000000000000000000000000;;					fieldSet["value"] = true
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var desc *ExtensionDesc
0000000000000000000000000000000000000000;;				// This could be faster, but it's functional.
0000000000000000000000000000000000000000;;				// TODO: Do something smarter than a linear scan.
0000000000000000000000000000000000000000;;				for _, d := range RegisteredExtensions(reflect.New(st).Interface().(Message)) {
0000000000000000000000000000000000000000;;					if d.Name == extName {
0000000000000000000000000000000000000000;;						desc = d
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if desc == nil {
0000000000000000000000000000000000000000;;					return p.errorf("unrecognized extension %q", extName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				props := &Properties{}
0000000000000000000000000000000000000000;;				props.Parse(desc.Tag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				typ := reflect.TypeOf(desc.ExtensionType)
0000000000000000000000000000000000000000;;				if err := p.checkForColon(props, typ); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rep := desc.repeated()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Read the extension structure, and set it in
0000000000000000000000000000000000000000;;				// the value we're constructing.
0000000000000000000000000000000000000000;;				var ext reflect.Value
0000000000000000000000000000000000000000;;				if !rep {
0000000000000000000000000000000000000000;;					ext = reflect.New(typ).Elem()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ext = reflect.New(typ.Elem()).Elem()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := p.readAny(ext, props); err != nil {
0000000000000000000000000000000000000000;;					if _, ok := err.(*RequiredNotSetError); !ok {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					reqFieldErr = err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ep := sv.Addr().Interface().(Message)
0000000000000000000000000000000000000000;;				if !rep {
0000000000000000000000000000000000000000;;					SetExtension(ep, desc, ext.Interface())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					old, err := GetExtension(ep, desc)
0000000000000000000000000000000000000000;;					var sl reflect.Value
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						sl = reflect.ValueOf(old) // existing slice
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						sl = reflect.MakeSlice(typ, 0, 1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sl = reflect.Append(sl, ext)
0000000000000000000000000000000000000000;;					SetExtension(ep, desc, sl.Interface())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := p.consumeOptionalSeparator(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This is a normal, non-extension field.
0000000000000000000000000000000000000000;;			name := tok.value
0000000000000000000000000000000000000000;;			var dst reflect.Value
0000000000000000000000000000000000000000;;			fi, props, ok := structFieldByName(sprops, name)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				dst = sv.Field(fi)
0000000000000000000000000000000000000000;;			} else if oop, ok := sprops.OneofTypes[name]; ok {
0000000000000000000000000000000000000000;;				// It is a oneof.
0000000000000000000000000000000000000000;;				props = oop.Prop
0000000000000000000000000000000000000000;;				nv := reflect.New(oop.Type.Elem())
0000000000000000000000000000000000000000;;				dst = nv.Elem().Field(0)
0000000000000000000000000000000000000000;;				field := sv.Field(oop.Field)
0000000000000000000000000000000000000000;;				if !field.IsNil() {
0000000000000000000000000000000000000000;;					return p.errorf("field '%s' would overwrite already parsed oneof '%s'", name, sv.Type().Field(oop.Field).Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				field.Set(nv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !dst.IsValid() {
0000000000000000000000000000000000000000;;				return p.errorf("unknown field name %q in %v", name, st)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if dst.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;				// Consume any colon.
0000000000000000000000000000000000000000;;				if err := p.checkForColon(props, dst.Type()); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Construct the map if it doesn't already exist.
0000000000000000000000000000000000000000;;				if dst.IsNil() {
0000000000000000000000000000000000000000;;					dst.Set(reflect.MakeMap(dst.Type()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				key := reflect.New(dst.Type().Key()).Elem()
0000000000000000000000000000000000000000;;				val := reflect.New(dst.Type().Elem()).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// The map entry should be this sequence of tokens:
0000000000000000000000000000000000000000;;				//	< key : KEY value : VALUE >
0000000000000000000000000000000000000000;;				// However, implementations may omit key or value, and technically
0000000000000000000000000000000000000000;;				// we should support them in any order.  See b/28924776 for a time
0000000000000000000000000000000000000000;;				// this went wrong.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tok := p.next()
0000000000000000000000000000000000000000;;				var terminator string
0000000000000000000000000000000000000000;;				switch tok.value {
0000000000000000000000000000000000000000;;				case "<":
0000000000000000000000000000000000000000;;					terminator = ">"
0000000000000000000000000000000000000000;;				case "{":
0000000000000000000000000000000000000000;;					terminator = "}"
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return p.errorf("expected '{' or '<', found %q", tok.value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					tok := p.next()
0000000000000000000000000000000000000000;;					if tok.err != nil {
0000000000000000000000000000000000000000;;						return tok.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if tok.value == terminator {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					switch tok.value {
0000000000000000000000000000000000000000;;					case "key":
0000000000000000000000000000000000000000;;						if err := p.consumeToken(":"); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := p.readAny(key, props.mkeyprop); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := p.consumeOptionalSeparator(); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case "value":
0000000000000000000000000000000000000000;;						if err := p.checkForColon(props.mvalprop, dst.Type().Elem()); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := p.readAny(val, props.mvalprop); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := p.consumeOptionalSeparator(); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						p.back()
0000000000000000000000000000000000000000;;						return p.errorf(`expected "key", "value", or %q, found %q`, terminator, tok.value)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dst.SetMapIndex(key, val)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that it's not already set if it's not a repeated field.
0000000000000000000000000000000000000000;;			if !props.Repeated && fieldSet[name] {
0000000000000000000000000000000000000000;;				return p.errorf("non-repeated field %q was repeated", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := p.checkForColon(props, dst.Type()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Parse into the field.
0000000000000000000000000000000000000000;;			fieldSet[name] = true
0000000000000000000000000000000000000000;;			if err := p.readAny(dst, props); err != nil {
0000000000000000000000000000000000000000;;				if _, ok := err.(*RequiredNotSetError); !ok {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				reqFieldErr = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if props.Required {
0000000000000000000000000000000000000000;;				reqCount--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := p.consumeOptionalSeparator(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if reqCount > 0 {
0000000000000000000000000000000000000000;;			return p.missingRequiredFieldError(sv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reqFieldErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consumeExtName consumes extension name or expanded Any type URL and the
0000000000000000000000000000000000000000;;	// following ']'. It returns the name or URL consumed.
0000000000000000000000000000000000000000;;	func (p *textParser) consumeExtName() (string, error) {
0000000000000000000000000000000000000000;;		tok := p.next()
0000000000000000000000000000000000000000;;		if tok.err != nil {
0000000000000000000000000000000000000000;;			return "", tok.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If extension name or type url is quoted, it's a single token.
0000000000000000000000000000000000000000;;		if len(tok.value) > 2 && isQuote(tok.value[0]) && tok.value[len(tok.value)-1] == tok.value[0] {
0000000000000000000000000000000000000000;;			name, err := unquoteC(tok.value[1:len(tok.value)-1], rune(tok.value[0]))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return name, p.consumeToken("]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume everything up to "]"
0000000000000000000000000000000000000000;;		var parts []string
0000000000000000000000000000000000000000;;		for tok.value != "]" {
0000000000000000000000000000000000000000;;			parts = append(parts, tok.value)
0000000000000000000000000000000000000000;;			tok = p.next()
0000000000000000000000000000000000000000;;			if tok.err != nil {
0000000000000000000000000000000000000000;;				return "", p.errorf("unrecognized type_url or extension name: %s", tok.err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(parts, ""), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consumeOptionalSeparator consumes an optional semicolon or comma.
0000000000000000000000000000000000000000;;	// It is used in readStruct to provide backward compatibility.
0000000000000000000000000000000000000000;;	func (p *textParser) consumeOptionalSeparator() error {
0000000000000000000000000000000000000000;;		tok := p.next()
0000000000000000000000000000000000000000;;		if tok.err != nil {
0000000000000000000000000000000000000000;;			return tok.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.value != ";" && tok.value != "," {
0000000000000000000000000000000000000000;;			p.back()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *textParser) readAny(v reflect.Value, props *Properties) error {
0000000000000000000000000000000000000000;;		tok := p.next()
0000000000000000000000000000000000000000;;		if tok.err != nil {
0000000000000000000000000000000000000000;;			return tok.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.value == "" {
0000000000000000000000000000000000000000;;			return p.errorf("unexpected EOF")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch fv := v; fv.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			at := v.Type()
0000000000000000000000000000000000000000;;			if at.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				// Special case for []byte
0000000000000000000000000000000000000000;;				if tok.value[0] != '"' && tok.value[0] != '\'' {
0000000000000000000000000000000000000000;;					// Deliberately written out here, as the error after
0000000000000000000000000000000000000000;;					// this switch statement would write "invalid []byte: ...",
0000000000000000000000000000000000000000;;					// which is not as user-friendly.
0000000000000000000000000000000000000000;;					return p.errorf("invalid string: %v", tok.value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bytes := []byte(tok.unquoted)
0000000000000000000000000000000000000000;;				fv.Set(reflect.ValueOf(bytes))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Repeated field.
0000000000000000000000000000000000000000;;			if tok.value == "[" {
0000000000000000000000000000000000000000;;				// Repeated field with list notation, like [1,2,3].
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					fv.Set(reflect.Append(fv, reflect.New(at.Elem()).Elem()))
0000000000000000000000000000000000000000;;					err := p.readAny(fv.Index(fv.Len()-1), props)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tok := p.next()
0000000000000000000000000000000000000000;;					if tok.err != nil {
0000000000000000000000000000000000000000;;						return tok.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if tok.value == "]" {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if tok.value != "," {
0000000000000000000000000000000000000000;;						return p.errorf("Expected ']' or ',' found %q", tok.value)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// One value of the repeated field.
0000000000000000000000000000000000000000;;			p.back()
0000000000000000000000000000000000000000;;			fv.Set(reflect.Append(fv, reflect.New(at.Elem()).Elem()))
0000000000000000000000000000000000000000;;			return p.readAny(fv.Index(fv.Len()-1), props)
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			// true/1/t/True or false/f/0/False.
0000000000000000000000000000000000000000;;			switch tok.value {
0000000000000000000000000000000000000000;;			case "true", "1", "t", "True":
0000000000000000000000000000000000000000;;				fv.SetBool(true)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case "false", "0", "f", "False":
0000000000000000000000000000000000000000;;				fv.SetBool(false)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			v := tok.value
0000000000000000000000000000000000000000;;			// Ignore 'f' for compatibility with output generated by C++, but don't
0000000000000000000000000000000000000000;;			// remove 'f' when the value is "-inf" or "inf".
0000000000000000000000000000000000000000;;			if strings.HasSuffix(v, "f") && tok.value != "-inf" && tok.value != "inf" {
0000000000000000000000000000000000000000;;				v = v[:len(v)-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f, err := strconv.ParseFloat(v, fv.Type().Bits()); err == nil {
0000000000000000000000000000000000000000;;				fv.SetFloat(f)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			if x, err := strconv.ParseInt(tok.value, 0, 32); err == nil {
0000000000000000000000000000000000000000;;				fv.SetInt(x)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(props.Enum) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m, ok := enumValueMaps[props.Enum]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x, ok := m[tok.value]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fv.SetInt(int64(x))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			if x, err := strconv.ParseInt(tok.value, 0, 64); err == nil {
0000000000000000000000000000000000000000;;				fv.SetInt(x)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			// A basic field (indirected through pointer), or a repeated message/group
0000000000000000000000000000000000000000;;			p.back()
0000000000000000000000000000000000000000;;			fv.Set(reflect.New(fv.Type().Elem()))
0000000000000000000000000000000000000000;;			return p.readAny(fv.Elem(), props)
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if tok.value[0] == '"' || tok.value[0] == '\'' {
0000000000000000000000000000000000000000;;				fv.SetString(tok.unquoted)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			var terminator string
0000000000000000000000000000000000000000;;			switch tok.value {
0000000000000000000000000000000000000000;;			case "{":
0000000000000000000000000000000000000000;;				terminator = "}"
0000000000000000000000000000000000000000;;			case "<":
0000000000000000000000000000000000000000;;				terminator = ">"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return p.errorf("expected '{' or '<', found %q", tok.value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Handle nested messages which implement encoding.TextUnmarshaler.
0000000000000000000000000000000000000000;;			return p.readStruct(fv, terminator)
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			if x, err := strconv.ParseUint(tok.value, 0, 32); err == nil {
0000000000000000000000000000000000000000;;				fv.SetUint(uint64(x))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			if x, err := strconv.ParseUint(tok.value, 0, 64); err == nil {
0000000000000000000000000000000000000000;;				fv.SetUint(x)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.errorf("invalid %v: %v", v.Type(), tok.value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText reads a protocol buffer in Text format. UnmarshalText resets pb
0000000000000000000000000000000000000000;;	// before starting to unmarshal, so any existing data in pb is always removed.
0000000000000000000000000000000000000000;;	// If a required field is not set and no other error occurs,
0000000000000000000000000000000000000000;;	// UnmarshalText returns *RequiredNotSetError.
0000000000000000000000000000000000000000;;	func UnmarshalText(s string, pb Message) error {
0000000000000000000000000000000000000000;;		if um, ok := pb.(encoding.TextUnmarshaler); ok {
0000000000000000000000000000000000000000;;			err := um.UnmarshalText([]byte(s))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pb.Reset()
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(pb)
0000000000000000000000000000000000000000;;		if pe := newTextParser(s).readStruct(v.Elem(), ""); pe != nil {
0000000000000000000000000000000000000000;;			return pe
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
