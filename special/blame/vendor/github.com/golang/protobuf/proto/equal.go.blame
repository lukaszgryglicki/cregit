0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/github.com/golang/protobuf/proto/equal.go[Godeps/_workspace/src/github.com/golang/protobuf/proto/equal.go][vendor/github.com/golang/protobuf/proto/equal.go];	
0000000000000000000000000000000000000000;;	// Protocol buffer comparison.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Equal returns true iff protocol buffers a and b are equal.
0000000000000000000000000000000000000000;;	The arguments must both be pointers to protocol buffer structs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Equality is defined in this way:
0000000000000000000000000000000000000000;;	  - Two messages are equal iff they are the same type,
0000000000000000000000000000000000000000;;	    corresponding fields are equal, unknown field sets
0000000000000000000000000000000000000000;;	    are equal, and extensions sets are equal.
0000000000000000000000000000000000000000;;	  - Two set scalar fields are equal iff their values are equal.
0000000000000000000000000000000000000000;;	    If the fields are of a floating-point type, remember that
0000000000000000000000000000000000000000;;	    NaN != x for all x, including NaN. If the message is defined
0000000000000000000000000000000000000000;;	    in a proto3 .proto file, fields are not "set"; specifically,
0000000000000000000000000000000000000000;;	    zero length proto3 "bytes" fields are equal (nil == {}).
0000000000000000000000000000000000000000;;	  - Two repeated fields are equal iff their lengths are the same,
0000000000000000000000000000000000000000;;	    and their corresponding elements are equal. Note a "bytes" field,
0000000000000000000000000000000000000000;;	    although represented by []byte, is not a repeated field and the
0000000000000000000000000000000000000000;;	    rule for the scalar fields described above applies.
0000000000000000000000000000000000000000;;	  - Two unset fields are equal.
0000000000000000000000000000000000000000;;	  - Two unknown field sets are equal if their current
0000000000000000000000000000000000000000;;	    encoded state is equal.
0000000000000000000000000000000000000000;;	  - Two extension sets are equal iff they have corresponding
0000000000000000000000000000000000000000;;	    elements that are pairwise equal.
0000000000000000000000000000000000000000;;	  - Two map fields are equal iff their lengths are the same,
0000000000000000000000000000000000000000;;	    and they contain the same set of elements. Zero-length map
0000000000000000000000000000000000000000;;	    fields are equal.
0000000000000000000000000000000000000000;;	  - Every other combination of things are not equal.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The return value is undefined if a and b are not protocol buffers.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func Equal(a, b Message) bool {
0000000000000000000000000000000000000000;;		if a == nil || b == nil {
0000000000000000000000000000000000000000;;			return a == b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v1, v2 := reflect.ValueOf(a), reflect.ValueOf(b)
0000000000000000000000000000000000000000;;		if v1.Type() != v2.Type() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v1.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if v1.IsNil() {
0000000000000000000000000000000000000000;;				return v2.IsNil()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v2.IsNil() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v1, v2 = v1.Elem(), v2.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v1.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return equalStruct(v1, v2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v1 and v2 are known to have the same type.
0000000000000000000000000000000000000000;;	func equalStruct(v1, v2 reflect.Value) bool {
0000000000000000000000000000000000000000;;		sprop := GetProperties(v1.Type())
0000000000000000000000000000000000000000;;		for i := 0; i < v1.NumField(); i++ {
0000000000000000000000000000000000000000;;			f := v1.Type().Field(i)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(f.Name, "XXX_") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f1, f2 := v1.Field(i), v2.Field(i)
0000000000000000000000000000000000000000;;			if f.Type.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				if n1, n2 := f1.IsNil(), f2.IsNil(); n1 && n2 {
0000000000000000000000000000000000000000;;					// both unset
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else if n1 != n2 {
0000000000000000000000000000000000000000;;					// set/unset mismatch
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b1, ok := f1.Interface().(raw)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					b2 := f2.Interface().(raw)
0000000000000000000000000000000000000000;;					// RawMessage
0000000000000000000000000000000000000000;;					if !bytes.Equal(b1.Bytes(), b2.Bytes()) {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f1, f2 = f1.Elem(), f2.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !equalAny(f1, f2, sprop.Prop[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if em1 := v1.FieldByName("XXX_InternalExtensions"); em1.IsValid() {
0000000000000000000000000000000000000000;;			em2 := v2.FieldByName("XXX_InternalExtensions")
0000000000000000000000000000000000000000;;			if !equalExtensions(v1.Type(), em1.Interface().(XXX_InternalExtensions), em2.Interface().(XXX_InternalExtensions)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if em1 := v1.FieldByName("XXX_extensions"); em1.IsValid() {
0000000000000000000000000000000000000000;;			em2 := v2.FieldByName("XXX_extensions")
0000000000000000000000000000000000000000;;			if !equalExtMap(v1.Type(), em1.Interface().(map[int32]Extension), em2.Interface().(map[int32]Extension)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uf := v1.FieldByName("XXX_unrecognized")
0000000000000000000000000000000000000000;;		if !uf.IsValid() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u1 := uf.Bytes()
0000000000000000000000000000000000000000;;		u2 := v2.FieldByName("XXX_unrecognized").Bytes()
0000000000000000000000000000000000000000;;		if !bytes.Equal(u1, u2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v1 and v2 are known to have the same type.
0000000000000000000000000000000000000000;;	// prop may be nil.
0000000000000000000000000000000000000000;;	func equalAny(v1, v2 reflect.Value, prop *Properties) bool {
0000000000000000000000000000000000000000;;		if v1.Type() == protoMessageType {
0000000000000000000000000000000000000000;;			m1, _ := v1.Interface().(Message)
0000000000000000000000000000000000000000;;			m2, _ := v2.Interface().(Message)
0000000000000000000000000000000000000000;;			return Equal(m1, m2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch v1.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return v1.Bool() == v2.Bool()
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v1.Float() == v2.Float()
0000000000000000000000000000000000000000;;		case reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v1.Int() == v2.Int()
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// Probably a oneof field; compare the inner values.
0000000000000000000000000000000000000000;;			n1, n2 := v1.IsNil(), v2.IsNil()
0000000000000000000000000000000000000000;;			if n1 || n2 {
0000000000000000000000000000000000000000;;				return n1 == n2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e1, e2 := v1.Elem(), v2.Elem()
0000000000000000000000000000000000000000;;			if e1.Type() != e2.Type() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return equalAny(e1, e2, nil)
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if v1.Len() != v2.Len() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, key := range v1.MapKeys() {
0000000000000000000000000000000000000000;;				val2 := v2.MapIndex(key)
0000000000000000000000000000000000000000;;				if !val2.IsValid() {
0000000000000000000000000000000000000000;;					// This key was not found in the second map.
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !equalAny(v1.MapIndex(key), val2, nil) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			// Maps may have nil values in them, so check for nil.
0000000000000000000000000000000000000000;;			if v1.IsNil() && v2.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.IsNil() != v2.IsNil() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return equalAny(v1.Elem(), v2.Elem(), prop)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if v1.Type().Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				// short circuit: []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Edge case: if this is in a proto3 message, a zero length
0000000000000000000000000000000000000000;;				// bytes field is considered the zero value.
0000000000000000000000000000000000000000;;				if prop != nil && prop.proto3 && v1.Len() == 0 && v2.Len() == 0 {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v1.IsNil() != v2.IsNil() {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return bytes.Equal(v1.Interface().([]byte), v2.Interface().([]byte))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v1.Len() != v2.Len() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < v1.Len(); i++ {
0000000000000000000000000000000000000000;;				if !equalAny(v1.Index(i), v2.Index(i), prop) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return v1.Interface().(string) == v2.Interface().(string)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return equalStruct(v1, v2)
0000000000000000000000000000000000000000;;		case reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			return v1.Uint() == v2.Uint()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unknown type, so not a protocol buffer
0000000000000000000000000000000000000000;;		log.Printf("proto: don't know how to compare %v", v1)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// base is the struct type that the extensions are based on.
0000000000000000000000000000000000000000;;	// x1 and x2 are InternalExtensions.
0000000000000000000000000000000000000000;;	func equalExtensions(base reflect.Type, x1, x2 XXX_InternalExtensions) bool {
0000000000000000000000000000000000000000;;		em1, _ := x1.extensionsRead()
0000000000000000000000000000000000000000;;		em2, _ := x2.extensionsRead()
0000000000000000000000000000000000000000;;		return equalExtMap(base, em1, em2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func equalExtMap(base reflect.Type, em1, em2 map[int32]Extension) bool {
0000000000000000000000000000000000000000;;		if len(em1) != len(em2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for extNum, e1 := range em1 {
0000000000000000000000000000000000000000;;			e2, ok := em2[extNum]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			m1, m2 := e1.value, e2.value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m1 != nil && m2 != nil {
0000000000000000000000000000000000000000;;				// Both are unencoded.
0000000000000000000000000000000000000000;;				if !equalAny(reflect.ValueOf(m1), reflect.ValueOf(m2), nil) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// At least one is encoded. To do a semantically correct comparison
0000000000000000000000000000000000000000;;			// we need to unmarshal them first.
0000000000000000000000000000000000000000;;			var desc *ExtensionDesc
0000000000000000000000000000000000000000;;			if m := extensionMaps[base]; m != nil {
0000000000000000000000000000000000000000;;				desc = m[extNum]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if desc == nil {
0000000000000000000000000000000000000000;;				log.Printf("proto: don't know how to compare extension %d of %v", extNum, base)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if m1 == nil {
0000000000000000000000000000000000000000;;				m1, err = decodeExtension(e1.enc, desc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if m2 == nil && err == nil {
0000000000000000000000000000000000000000;;				m2, err = decodeExtension(e2.enc, desc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// The encoded form is invalid.
0000000000000000000000000000000000000000;;				log.Printf("proto: badly encoded extension %d of %v: %v", extNum, base, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !equalAny(reflect.ValueOf(m1), reflect.ValueOf(m2), nil) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
