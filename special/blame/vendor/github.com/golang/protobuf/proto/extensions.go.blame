0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/github.com/golang/protobuf/proto/extensions.go[Godeps/_workspace/src/github.com/golang/protobuf/proto/extensions.go][vendor/github.com/golang/protobuf/proto/extensions.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Types and routines for supporting protocol buffer extensions.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrMissingExtension is the error returned by GetExtension if the named extension is not in the message.
0000000000000000000000000000000000000000;;	var ErrMissingExtension = errors.New("proto: missing extension")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtensionRange represents a range of message extensions for a protocol buffer.
0000000000000000000000000000000000000000;;	// Used in code generated by the protocol compiler.
0000000000000000000000000000000000000000;;	type ExtensionRange struct {
0000000000000000000000000000000000000000;;		Start, End int32 // both inclusive
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extendableProto is an interface implemented by any protocol buffer generated by the current
0000000000000000000000000000000000000000;;	// proto compiler that may be extended.
0000000000000000000000000000000000000000;;	type extendableProto interface {
0000000000000000000000000000000000000000;;		Message
0000000000000000000000000000000000000000;;		ExtensionRangeArray() []ExtensionRange
0000000000000000000000000000000000000000;;		extensionsWrite() map[int32]Extension
0000000000000000000000000000000000000000;;		extensionsRead() (map[int32]Extension, sync.Locker)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extendableProtoV1 is an interface implemented by a protocol buffer generated by the previous
0000000000000000000000000000000000000000;;	// version of the proto compiler that may be extended.
0000000000000000000000000000000000000000;;	type extendableProtoV1 interface {
0000000000000000000000000000000000000000;;		Message
0000000000000000000000000000000000000000;;		ExtensionRangeArray() []ExtensionRange
0000000000000000000000000000000000000000;;		ExtensionMap() map[int32]Extension
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extensionAdapter is a wrapper around extendableProtoV1 that implements extendableProto.
0000000000000000000000000000000000000000;;	type extensionAdapter struct {
0000000000000000000000000000000000000000;;		extendableProtoV1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e extensionAdapter) extensionsWrite() map[int32]Extension {
0000000000000000000000000000000000000000;;		return e.ExtensionMap()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e extensionAdapter) extensionsRead() (map[int32]Extension, sync.Locker) {
0000000000000000000000000000000000000000;;		return e.ExtensionMap(), notLocker{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notLocker is a sync.Locker whose Lock and Unlock methods are nops.
0000000000000000000000000000000000000000;;	type notLocker struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n notLocker) Lock()   {}
0000000000000000000000000000000000000000;;	func (n notLocker) Unlock() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extendable returns the extendableProto interface for the given generated proto message.
0000000000000000000000000000000000000000;;	// If the proto message has the old extension format, it returns a wrapper that implements
0000000000000000000000000000000000000000;;	// the extendableProto interface.
0000000000000000000000000000000000000000;;	func extendable(p interface{}) (extendableProto, bool) {
0000000000000000000000000000000000000000;;		if ep, ok := p.(extendableProto); ok {
0000000000000000000000000000000000000000;;			return ep, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ep, ok := p.(extendableProtoV1); ok {
0000000000000000000000000000000000000000;;			return extensionAdapter{ep}, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// XXX_InternalExtensions is an internal representation of proto extensions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each generated message struct type embeds an anonymous XXX_InternalExtensions field,
0000000000000000000000000000000000000000;;	// thus gaining the unexported 'extensions' method, which can be called only from the proto package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The methods of XXX_InternalExtensions are not concurrency safe in general,
0000000000000000000000000000000000000000;;	// but calls to logically read-only methods such as has and get may be executed concurrently.
0000000000000000000000000000000000000000;;	type XXX_InternalExtensions struct {
0000000000000000000000000000000000000000;;		// The struct must be indirect so that if a user inadvertently copies a
0000000000000000000000000000000000000000;;		// generated message and its embedded XXX_InternalExtensions, they
0000000000000000000000000000000000000000;;		// avoid the mayhem of a copied mutex.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The mutex serializes all logically read-only operations to p.extensionMap.
0000000000000000000000000000000000000000;;		// It is up to the client to ensure that write operations to p.extensionMap are
0000000000000000000000000000000000000000;;		// mutually exclusive with other accesses.
0000000000000000000000000000000000000000;;		p *struct {
0000000000000000000000000000000000000000;;			mu           sync.Mutex
0000000000000000000000000000000000000000;;			extensionMap map[int32]Extension
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extensionsWrite returns the extension map, creating it on first use.
0000000000000000000000000000000000000000;;	func (e *XXX_InternalExtensions) extensionsWrite() map[int32]Extension {
0000000000000000000000000000000000000000;;		if e.p == nil {
0000000000000000000000000000000000000000;;			e.p = new(struct {
0000000000000000000000000000000000000000;;				mu           sync.Mutex
0000000000000000000000000000000000000000;;				extensionMap map[int32]Extension
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			e.p.extensionMap = make(map[int32]Extension)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.p.extensionMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extensionsRead returns the extensions map for read-only use.  It may be nil.
0000000000000000000000000000000000000000;;	// The caller must hold the returned mutex's lock when accessing Elements within the map.
0000000000000000000000000000000000000000;;	func (e *XXX_InternalExtensions) extensionsRead() (map[int32]Extension, sync.Locker) {
0000000000000000000000000000000000000000;;		if e.p == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.p.extensionMap, &e.p.mu
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var extendableProtoType = reflect.TypeOf((*extendableProto)(nil)).Elem()
0000000000000000000000000000000000000000;;	var extendableProtoV1Type = reflect.TypeOf((*extendableProtoV1)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtensionDesc represents an extension specification.
0000000000000000000000000000000000000000;;	// Used in generated code from the protocol compiler.
0000000000000000000000000000000000000000;;	type ExtensionDesc struct {
0000000000000000000000000000000000000000;;		ExtendedType  Message     // nil pointer to the type that is being extended
0000000000000000000000000000000000000000;;		ExtensionType interface{} // nil pointer to the extension type
0000000000000000000000000000000000000000;;		Field         int32       // field number
0000000000000000000000000000000000000000;;		Name          string      // fully-qualified name of extension, for text formatting
0000000000000000000000000000000000000000;;		Tag           string      // protobuf tag style
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ed *ExtensionDesc) repeated() bool {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(ed.ExtensionType)
0000000000000000000000000000000000000000;;		return t.Kind() == reflect.Slice && t.Elem().Kind() != reflect.Uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extension represents an extension in a message.
0000000000000000000000000000000000000000;;	type Extension struct {
0000000000000000000000000000000000000000;;		// When an extension is stored in a message using SetExtension
0000000000000000000000000000000000000000;;		// only desc and value are set. When the message is marshaled
0000000000000000000000000000000000000000;;		// enc will be set to the encoded form of the message.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When a message is unmarshaled and contains extensions, each
0000000000000000000000000000000000000000;;		// extension will have only enc set. When such an extension is
0000000000000000000000000000000000000000;;		// accessed using GetExtension (or GetExtensions) desc and value
0000000000000000000000000000000000000000;;		// will be set.
0000000000000000000000000000000000000000;;		desc  *ExtensionDesc
0000000000000000000000000000000000000000;;		value interface{}
0000000000000000000000000000000000000000;;		enc   []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetRawExtension is for testing only.
0000000000000000000000000000000000000000;;	func SetRawExtension(base Message, id int32, b []byte) {
0000000000000000000000000000000000000000;;		epb, ok := extendable(base)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extmap := epb.extensionsWrite()
0000000000000000000000000000000000000000;;		extmap[id] = Extension{enc: b}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isExtensionField returns true iff the given field number is in an extension range.
0000000000000000000000000000000000000000;;	func isExtensionField(pb extendableProto, field int32) bool {
0000000000000000000000000000000000000000;;		for _, er := range pb.ExtensionRangeArray() {
0000000000000000000000000000000000000000;;			if er.Start <= field && field <= er.End {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkExtensionTypes checks that the given extension is valid for pb.
0000000000000000000000000000000000000000;;	func checkExtensionTypes(pb extendableProto, extension *ExtensionDesc) error {
0000000000000000000000000000000000000000;;		var pbi interface{} = pb
0000000000000000000000000000000000000000;;		// Check the extended type.
0000000000000000000000000000000000000000;;		if ea, ok := pbi.(extensionAdapter); ok {
0000000000000000000000000000000000000000;;			pbi = ea.extendableProtoV1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a, b := reflect.TypeOf(pbi), reflect.TypeOf(extension.ExtendedType); a != b {
0000000000000000000000000000000000000000;;			return errors.New("proto: bad extended type; " + b.String() + " does not extend " + a.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check the range.
0000000000000000000000000000000000000000;;		if !isExtensionField(pb, extension.Field) {
0000000000000000000000000000000000000000;;			return errors.New("proto: bad extension number; not in declared ranges")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extPropKey is sufficient to uniquely identify an extension.
0000000000000000000000000000000000000000;;	type extPropKey struct {
0000000000000000000000000000000000000000;;		base  reflect.Type
0000000000000000000000000000000000000000;;		field int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var extProp = struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		m map[extPropKey]*Properties
0000000000000000000000000000000000000000;;	}{
0000000000000000000000000000000000000000;;		m: make(map[extPropKey]*Properties),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extensionProperties(ed *ExtensionDesc) *Properties {
0000000000000000000000000000000000000000;;		key := extPropKey{base: reflect.TypeOf(ed.ExtendedType), field: ed.Field}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extProp.RLock()
0000000000000000000000000000000000000000;;		if prop, ok := extProp.m[key]; ok {
0000000000000000000000000000000000000000;;			extProp.RUnlock()
0000000000000000000000000000000000000000;;			return prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extProp.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extProp.Lock()
0000000000000000000000000000000000000000;;		defer extProp.Unlock()
0000000000000000000000000000000000000000;;		// Check again.
0000000000000000000000000000000000000000;;		if prop, ok := extProp.m[key]; ok {
0000000000000000000000000000000000000000;;			return prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prop := new(Properties)
0000000000000000000000000000000000000000;;		prop.Init(reflect.TypeOf(ed.ExtensionType), "unknown_name", ed.Tag, nil)
0000000000000000000000000000000000000000;;		extProp.m[key] = prop
0000000000000000000000000000000000000000;;		return prop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encode encodes any unmarshaled (unencoded) extensions in e.
0000000000000000000000000000000000000000;;	func encodeExtensions(e *XXX_InternalExtensions) error {
0000000000000000000000000000000000000000;;		m, mu := e.extensionsRead()
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return nil // fast path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		return encodeExtensionsMap(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encode encodes any unmarshaled (unencoded) extensions in e.
0000000000000000000000000000000000000000;;	func encodeExtensionsMap(m map[int32]Extension) error {
0000000000000000000000000000000000000000;;		for k, e := range m {
0000000000000000000000000000000000000000;;			if e.value == nil || e.desc == nil {
0000000000000000000000000000000000000000;;				// Extension is only in its encoded form.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We don't skip extensions that have an encoded form set,
0000000000000000000000000000000000000000;;			// because the extension value may have been mutated after
0000000000000000000000000000000000000000;;			// the last time this function was called.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			et := reflect.TypeOf(e.desc.ExtensionType)
0000000000000000000000000000000000000000;;			props := extensionProperties(e.desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p := NewBuffer(nil)
0000000000000000000000000000000000000000;;			// If e.value has type T, the encoder expects a *struct{ X T }.
0000000000000000000000000000000000000000;;			// Pass a *T with a zero field and hope it all works out.
0000000000000000000000000000000000000000;;			x := reflect.New(et)
0000000000000000000000000000000000000000;;			x.Elem().Set(reflect.ValueOf(e.value))
0000000000000000000000000000000000000000;;			if err := props.enc(p, props, toStructPointer(x)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.enc = p.buf
0000000000000000000000000000000000000000;;			m[k] = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extensionsSize(e *XXX_InternalExtensions) (n int) {
0000000000000000000000000000000000000000;;		m, mu := e.extensionsRead()
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		return extensionsMapSize(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extensionsMapSize(m map[int32]Extension) (n int) {
0000000000000000000000000000000000000000;;		for _, e := range m {
0000000000000000000000000000000000000000;;			if e.value == nil || e.desc == nil {
0000000000000000000000000000000000000000;;				// Extension is only in its encoded form.
0000000000000000000000000000000000000000;;				n += len(e.enc)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We don't skip extensions that have an encoded form set,
0000000000000000000000000000000000000000;;			// because the extension value may have been mutated after
0000000000000000000000000000000000000000;;			// the last time this function was called.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			et := reflect.TypeOf(e.desc.ExtensionType)
0000000000000000000000000000000000000000;;			props := extensionProperties(e.desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If e.value has type T, the encoder expects a *struct{ X T }.
0000000000000000000000000000000000000000;;			// Pass a *T with a zero field and hope it all works out.
0000000000000000000000000000000000000000;;			x := reflect.New(et)
0000000000000000000000000000000000000000;;			x.Elem().Set(reflect.ValueOf(e.value))
0000000000000000000000000000000000000000;;			n += props.size(props, toStructPointer(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasExtension returns whether the given extension is present in pb.
0000000000000000000000000000000000000000;;	func HasExtension(pb Message, extension *ExtensionDesc) bool {
0000000000000000000000000000000000000000;;		// TODO: Check types, field numbers, etc.?
0000000000000000000000000000000000000000;;		epb, ok := extendable(pb)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extmap, mu := epb.extensionsRead()
0000000000000000000000000000000000000000;;		if extmap == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		_, ok = extmap[extension.Field]
0000000000000000000000000000000000000000;;		mu.Unlock()
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearExtension removes the given extension from pb.
0000000000000000000000000000000000000000;;	func ClearExtension(pb Message, extension *ExtensionDesc) {
0000000000000000000000000000000000000000;;		epb, ok := extendable(pb)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Check types, field numbers, etc.?
0000000000000000000000000000000000000000;;		extmap := epb.extensionsWrite()
0000000000000000000000000000000000000000;;		delete(extmap, extension.Field)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExtension parses and returns the given extension of pb.
0000000000000000000000000000000000000000;;	// If the extension is not present and has no default value it returns ErrMissingExtension.
0000000000000000000000000000000000000000;;	func GetExtension(pb Message, extension *ExtensionDesc) (interface{}, error) {
0000000000000000000000000000000000000000;;		epb, ok := extendable(pb)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("proto: not an extendable proto")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkExtensionTypes(epb, extension); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emap, mu := epb.extensionsRead()
0000000000000000000000000000000000000000;;		if emap == nil {
0000000000000000000000000000000000000000;;			return defaultExtensionValue(extension)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		e, ok := emap[extension.Field]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// defaultExtensionValue returns the default value or
0000000000000000000000000000000000000000;;			// ErrMissingExtension if there is no default.
0000000000000000000000000000000000000000;;			return defaultExtensionValue(extension)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.value != nil {
0000000000000000000000000000000000000000;;			// Already decoded. Check the descriptor, though.
0000000000000000000000000000000000000000;;			if e.desc != extension {
0000000000000000000000000000000000000000;;				// This shouldn't happen. If it does, it means that
0000000000000000000000000000000000000000;;				// GetExtension was called twice with two different
0000000000000000000000000000000000000000;;				// descriptors with the same field number.
0000000000000000000000000000000000000000;;				return nil, errors.New("proto: descriptor conflict")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return e.value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v, err := decodeExtension(e.enc, extension)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remember the decoded version and drop the encoded version.
0000000000000000000000000000000000000000;;		// That way it is safe to mutate what we return.
0000000000000000000000000000000000000000;;		e.value = v
0000000000000000000000000000000000000000;;		e.desc = extension
0000000000000000000000000000000000000000;;		e.enc = nil
0000000000000000000000000000000000000000;;		emap[extension.Field] = e
0000000000000000000000000000000000000000;;		return e.value, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultExtensionValue returns the default value for extension.
0000000000000000000000000000000000000000;;	// If no default for an extension is defined ErrMissingExtension is returned.
0000000000000000000000000000000000000000;;	func defaultExtensionValue(extension *ExtensionDesc) (interface{}, error) {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(extension.ExtensionType)
0000000000000000000000000000000000000000;;		props := extensionProperties(extension)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sf, _, err := fieldDefault(t, props)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sf == nil || sf.value == nil {
0000000000000000000000000000000000000000;;			// There is no default value.
0000000000000000000000000000000000000000;;			return nil, ErrMissingExtension
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			// We do not need to return a Ptr, we can directly return sf.value.
0000000000000000000000000000000000000000;;			return sf.value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need to return an interface{} that is a pointer to sf.value.
0000000000000000000000000000000000000000;;		value := reflect.New(t).Elem()
0000000000000000000000000000000000000000;;		value.Set(reflect.New(value.Type().Elem()))
0000000000000000000000000000000000000000;;		if sf.kind == reflect.Int32 {
0000000000000000000000000000000000000000;;			// We may have an int32 or an enum, but the underlying data is int32.
0000000000000000000000000000000000000000;;			// Since we can't set an int32 into a non int32 reflect.value directly
0000000000000000000000000000000000000000;;			// set it as a int32.
0000000000000000000000000000000000000000;;			value.Elem().SetInt(int64(sf.value.(int32)))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			value.Elem().Set(reflect.ValueOf(sf.value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value.Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeExtension decodes an extension encoded in b.
0000000000000000000000000000000000000000;;	func decodeExtension(b []byte, extension *ExtensionDesc) (interface{}, error) {
0000000000000000000000000000000000000000;;		o := NewBuffer(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(extension.ExtensionType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		props := extensionProperties(extension)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// t is a pointer to a struct, pointer to basic type or a slice.
0000000000000000000000000000000000000000;;		// Allocate a "field" to store the pointer/slice itself; the
0000000000000000000000000000000000000000;;		// pointer/slice will be stored here. We pass
0000000000000000000000000000000000000000;;		// the address of this field to props.dec.
0000000000000000000000000000000000000000;;		// This passes a zero field and a *t and lets props.dec
0000000000000000000000000000000000000000;;		// interpret it as a *struct{ x t }.
0000000000000000000000000000000000000000;;		value := reflect.New(t).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Discard wire type and field number varint. It isn't needed.
0000000000000000000000000000000000000000;;			if _, err := o.DecodeVarint(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := props.dec(o, props, toStructPointer(value.Addr())); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.index >= len(o.buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value.Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExtensions returns a slice of the extensions present in pb that are also listed in es.
0000000000000000000000000000000000000000;;	// The returned slice has the same length as es; missing extensions will appear as nil elements.
0000000000000000000000000000000000000000;;	func GetExtensions(pb Message, es []*ExtensionDesc) (extensions []interface{}, err error) {
0000000000000000000000000000000000000000;;		epb, ok := extendable(pb)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("proto: not an extendable proto")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extensions = make([]interface{}, len(es))
0000000000000000000000000000000000000000;;		for i, e := range es {
0000000000000000000000000000000000000000;;			extensions[i], err = GetExtension(epb, e)
0000000000000000000000000000000000000000;;			if err == ErrMissingExtension {
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtensionDescs returns a new slice containing pb's extension descriptors, in undefined order.
0000000000000000000000000000000000000000;;	// For non-registered extensions, ExtensionDescs returns an incomplete descriptor containing
0000000000000000000000000000000000000000;;	// just the Field field, which defines the extension's field number.
0000000000000000000000000000000000000000;;	func ExtensionDescs(pb Message) ([]*ExtensionDesc, error) {
0000000000000000000000000000000000000000;;		epb, ok := extendable(pb)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("proto: %T is not an extendable proto.Message", pb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		registeredExtensions := RegisteredExtensions(pb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emap, mu := epb.extensionsRead()
0000000000000000000000000000000000000000;;		if emap == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		extensions := make([]*ExtensionDesc, 0, len(emap))
0000000000000000000000000000000000000000;;		for extid, e := range emap {
0000000000000000000000000000000000000000;;			desc := e.desc
0000000000000000000000000000000000000000;;			if desc == nil {
0000000000000000000000000000000000000000;;				desc = registeredExtensions[extid]
0000000000000000000000000000000000000000;;				if desc == nil {
0000000000000000000000000000000000000000;;					desc = &ExtensionDesc{Field: extid}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			extensions = append(extensions, desc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return extensions, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetExtension sets the specified extension of pb to the specified value.
0000000000000000000000000000000000000000;;	func SetExtension(pb Message, extension *ExtensionDesc, value interface{}) error {
0000000000000000000000000000000000000000;;		epb, ok := extendable(pb)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("proto: not an extendable proto")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkExtensionTypes(epb, extension); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typ := reflect.TypeOf(extension.ExtensionType)
0000000000000000000000000000000000000000;;		if typ != reflect.TypeOf(value) {
0000000000000000000000000000000000000000;;			return errors.New("proto: bad extension value type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// nil extension values need to be caught early, because the
0000000000000000000000000000000000000000;;		// encoder can't distinguish an ErrNil due to a nil extension
0000000000000000000000000000000000000000;;		// from an ErrNil due to a missing field. Extensions are
0000000000000000000000000000000000000000;;		// always optional, so the encoder would just swallow the error
0000000000000000000000000000000000000000;;		// and drop all the extensions from the encoded message.
0000000000000000000000000000000000000000;;		if reflect.ValueOf(value).IsNil() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("proto: SetExtension called with nil value of type %T", value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extmap := epb.extensionsWrite()
0000000000000000000000000000000000000000;;		extmap[extension.Field] = Extension{desc: extension, value: value}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearAllExtensions clears all extensions from pb.
0000000000000000000000000000000000000000;;	func ClearAllExtensions(pb Message) {
0000000000000000000000000000000000000000;;		epb, ok := extendable(pb)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := epb.extensionsWrite()
0000000000000000000000000000000000000000;;		for k := range m {
0000000000000000000000000000000000000000;;			delete(m, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A global registry of extensions.
0000000000000000000000000000000000000000;;	// The generated code will register the generated descriptors by calling RegisterExtension.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var extensionMaps = make(map[reflect.Type]map[int32]*ExtensionDesc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterExtension is called from the generated code.
0000000000000000000000000000000000000000;;	func RegisterExtension(desc *ExtensionDesc) {
0000000000000000000000000000000000000000;;		st := reflect.TypeOf(desc.ExtendedType).Elem()
0000000000000000000000000000000000000000;;		m := extensionMaps[st]
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			m = make(map[int32]*ExtensionDesc)
0000000000000000000000000000000000000000;;			extensionMaps[st] = m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := m[desc.Field]; ok {
0000000000000000000000000000000000000000;;			panic("proto: duplicate extension registered: " + st.String() + " " + strconv.Itoa(int(desc.Field)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m[desc.Field] = desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisteredExtensions returns a map of the registered extensions of a
0000000000000000000000000000000000000000;;	// protocol buffer struct, indexed by the extension number.
0000000000000000000000000000000000000000;;	// The argument pb should be a nil pointer to the struct type.
0000000000000000000000000000000000000000;;	func RegisteredExtensions(pb Message) map[int32]*ExtensionDesc {
0000000000000000000000000000000000000000;;		return extensionMaps[reflect.TypeOf(pb).Elem()]
0000000000000000000000000000000000000000;;	}
