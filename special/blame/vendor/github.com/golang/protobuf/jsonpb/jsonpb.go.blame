0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package jsonpb provides marshaling and unmarshaling between protocol buffers and JSON.
0000000000000000000000000000000000000000;;	It follows the specification at https://developers.google.com/protocol-buffers/docs/proto3#json.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This package produces a different output than the standard "encoding/json" package,
0000000000000000000000000000000000000000;;	which does not operate correctly on protocol buffers.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package jsonpb
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshaler is a configurable object for converting between
0000000000000000000000000000000000000000;;	// protocol buffer objects and a JSON representation for them.
0000000000000000000000000000000000000000;;	type Marshaler struct {
0000000000000000000000000000000000000000;;		// Whether to render enum values as integers, as opposed to string values.
0000000000000000000000000000000000000000;;		EnumsAsInts bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether to render fields with zero values.
0000000000000000000000000000000000000000;;		EmitDefaults bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A string to indent each level by. The presence of this field will
0000000000000000000000000000000000000000;;		// also cause a space to appear between the field separator and
0000000000000000000000000000000000000000;;		// value, and for newlines to be appear between fields and array
0000000000000000000000000000000000000000;;		// elements.
0000000000000000000000000000000000000000;;		Indent string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether to use the original (.proto) name for fields.
0000000000000000000000000000000000000000;;		OrigName bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal marshals a protocol buffer into JSON.
0000000000000000000000000000000000000000;;	func (m *Marshaler) Marshal(out io.Writer, pb proto.Message) error {
0000000000000000000000000000000000000000;;		writer := &errWriter{writer: out}
0000000000000000000000000000000000000000;;		return m.marshalObject(writer, pb, "", "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalToString converts a protocol buffer object to JSON string.
0000000000000000000000000000000000000000;;	func (m *Marshaler) MarshalToString(pb proto.Message) (string, error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		if err := m.Marshal(&buf, pb); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type int32Slice []int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For sorting extensions ids to ensure stable output.
0000000000000000000000000000000000000000;;	func (s int32Slice) Len() int           { return len(s) }
0000000000000000000000000000000000000000;;	func (s int32Slice) Less(i, j int) bool { return s[i] < s[j] }
0000000000000000000000000000000000000000;;	func (s int32Slice) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wkt interface {
0000000000000000000000000000000000000000;;		XXX_WellKnownType() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// marshalObject writes a struct to the Writer.
0000000000000000000000000000000000000000;;	func (m *Marshaler) marshalObject(out *errWriter, v proto.Message, indent, typeURL string) error {
0000000000000000000000000000000000000000;;		s := reflect.ValueOf(v).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle well-known types.
0000000000000000000000000000000000000000;;		if wkt, ok := v.(wkt); ok {
0000000000000000000000000000000000000000;;			switch wkt.XXX_WellKnownType() {
0000000000000000000000000000000000000000;;			case "DoubleValue", "FloatValue", "Int64Value", "UInt64Value",
0000000000000000000000000000000000000000;;				"Int32Value", "UInt32Value", "BoolValue", "StringValue", "BytesValue":
0000000000000000000000000000000000000000;;				// "Wrappers use the same representation in JSON
0000000000000000000000000000000000000000;;				//  as the wrapped primitive type, ..."
0000000000000000000000000000000000000000;;				sprop := proto.GetProperties(s.Type())
0000000000000000000000000000000000000000;;				return m.marshalValue(out, sprop.Prop[0], s.Field(0), indent)
0000000000000000000000000000000000000000;;			case "Any":
0000000000000000000000000000000000000000;;				// Any is a bit more involved.
0000000000000000000000000000000000000000;;				return m.marshalAny(out, v, indent)
0000000000000000000000000000000000000000;;			case "Duration":
0000000000000000000000000000000000000000;;				// "Generated output always contains 3, 6, or 9 fractional digits,
0000000000000000000000000000000000000000;;				//  depending on required precision."
0000000000000000000000000000000000000000;;				s, ns := s.Field(0).Int(), s.Field(1).Int()
0000000000000000000000000000000000000000;;				d := time.Duration(s)*time.Second + time.Duration(ns)*time.Nanosecond
0000000000000000000000000000000000000000;;				x := fmt.Sprintf("%.9f", d.Seconds())
0000000000000000000000000000000000000000;;				x = strings.TrimSuffix(x, "000")
0000000000000000000000000000000000000000;;				x = strings.TrimSuffix(x, "000")
0000000000000000000000000000000000000000;;				out.write(`"`)
0000000000000000000000000000000000000000;;				out.write(x)
0000000000000000000000000000000000000000;;				out.write(`s"`)
0000000000000000000000000000000000000000;;				return out.err
0000000000000000000000000000000000000000;;			case "Struct":
0000000000000000000000000000000000000000;;				// Let marshalValue handle the `fields` map.
0000000000000000000000000000000000000000;;				// TODO: pass the correct Properties if needed.
0000000000000000000000000000000000000000;;				return m.marshalValue(out, &proto.Properties{}, s.Field(0), indent)
0000000000000000000000000000000000000000;;			case "Timestamp":
0000000000000000000000000000000000000000;;				// "RFC 3339, where generated output will always be Z-normalized
0000000000000000000000000000000000000000;;				//  and uses 3, 6 or 9 fractional digits."
0000000000000000000000000000000000000000;;				s, ns := s.Field(0).Int(), s.Field(1).Int()
0000000000000000000000000000000000000000;;				t := time.Unix(s, ns).UTC()
0000000000000000000000000000000000000000;;				// time.RFC3339Nano isn't exactly right (we need to get 3/6/9 fractional digits).
0000000000000000000000000000000000000000;;				x := t.Format("2006-01-02T15:04:05.000000000")
0000000000000000000000000000000000000000;;				x = strings.TrimSuffix(x, "000")
0000000000000000000000000000000000000000;;				x = strings.TrimSuffix(x, "000")
0000000000000000000000000000000000000000;;				out.write(`"`)
0000000000000000000000000000000000000000;;				out.write(x)
0000000000000000000000000000000000000000;;				out.write(`Z"`)
0000000000000000000000000000000000000000;;				return out.err
0000000000000000000000000000000000000000;;			case "Value":
0000000000000000000000000000000000000000;;				// Value has a single oneof.
0000000000000000000000000000000000000000;;				kind := s.Field(0)
0000000000000000000000000000000000000000;;				if kind.IsNil() {
0000000000000000000000000000000000000000;;					// "absence of any variant indicates an error"
0000000000000000000000000000000000000000;;					return errors.New("nil Value")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// oneof -> *T -> T -> T.F
0000000000000000000000000000000000000000;;				x := kind.Elem().Elem().Field(0)
0000000000000000000000000000000000000000;;				// TODO: pass the correct Properties if needed.
0000000000000000000000000000000000000000;;				return m.marshalValue(out, &proto.Properties{}, x, indent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.write("{")
0000000000000000000000000000000000000000;;		if m.Indent != "" {
0000000000000000000000000000000000000000;;			out.write("\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstField := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if typeURL != "" {
0000000000000000000000000000000000000000;;			if err := m.marshalTypeURL(out, indent, typeURL); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			firstField = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < s.NumField(); i++ {
0000000000000000000000000000000000000000;;			value := s.Field(i)
0000000000000000000000000000000000000000;;			valueField := s.Type().Field(i)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(valueField.Name, "XXX_") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// IsNil will panic on most value kinds.
0000000000000000000000000000000000000000;;			switch value.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
0000000000000000000000000000000000000000;;				if value.IsNil() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !m.EmitDefaults {
0000000000000000000000000000000000000000;;				switch value.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Bool:
0000000000000000000000000000000000000000;;					if !value.Bool() {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;					if value.Int() == 0 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;					if value.Uint() == 0 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;					if value.Float() == 0 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					if value.Len() == 0 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Oneof fields need special handling.
0000000000000000000000000000000000000000;;			if valueField.Tag.Get("protobuf_oneof") != "" {
0000000000000000000000000000000000000000;;				// value is an interface containing &T{real_value}.
0000000000000000000000000000000000000000;;				sv := value.Elem().Elem() // interface -> *T -> T
0000000000000000000000000000000000000000;;				value = sv.Field(0)
0000000000000000000000000000000000000000;;				valueField = sv.Type().Field(0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prop := jsonProperties(valueField, m.OrigName)
0000000000000000000000000000000000000000;;			if !firstField {
0000000000000000000000000000000000000000;;				m.writeSep(out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := m.marshalField(out, prop, value, indent); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			firstField = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle proto2 extensions.
0000000000000000000000000000000000000000;;		if ep, ok := v.(proto.Message); ok {
0000000000000000000000000000000000000000;;			extensions := proto.RegisteredExtensions(v)
0000000000000000000000000000000000000000;;			// Sort extensions for stable output.
0000000000000000000000000000000000000000;;			ids := make([]int32, 0, len(extensions))
0000000000000000000000000000000000000000;;			for id, desc := range extensions {
0000000000000000000000000000000000000000;;				if !proto.HasExtension(ep, desc) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ids = append(ids, id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(int32Slice(ids))
0000000000000000000000000000000000000000;;			for _, id := range ids {
0000000000000000000000000000000000000000;;				desc := extensions[id]
0000000000000000000000000000000000000000;;				if desc == nil {
0000000000000000000000000000000000000000;;					// unknown extension
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ext, extErr := proto.GetExtension(ep, desc)
0000000000000000000000000000000000000000;;				if extErr != nil {
0000000000000000000000000000000000000000;;					return extErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				value := reflect.ValueOf(ext)
0000000000000000000000000000000000000000;;				var prop proto.Properties
0000000000000000000000000000000000000000;;				prop.Parse(desc.Tag)
0000000000000000000000000000000000000000;;				prop.JSONName = fmt.Sprintf("[%s]", desc.Name)
0000000000000000000000000000000000000000;;				if !firstField {
0000000000000000000000000000000000000000;;					m.writeSep(out)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := m.marshalField(out, &prop, value, indent); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				firstField = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.Indent != "" {
0000000000000000000000000000000000000000;;			out.write("\n")
0000000000000000000000000000000000000000;;			out.write(indent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.write("}")
0000000000000000000000000000000000000000;;		return out.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Marshaler) writeSep(out *errWriter) {
0000000000000000000000000000000000000000;;		if m.Indent != "" {
0000000000000000000000000000000000000000;;			out.write(",\n")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.write(",")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Marshaler) marshalAny(out *errWriter, any proto.Message, indent string) error {
0000000000000000000000000000000000000000;;		// "If the Any contains a value that has a special JSON mapping,
0000000000000000000000000000000000000000;;		//  it will be converted as follows: {"@type": xxx, "value": yyy}.
0000000000000000000000000000000000000000;;		//  Otherwise, the value will be converted into a JSON object,
0000000000000000000000000000000000000000;;		//  and the "@type" field will be inserted to indicate the actual data type."
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(any).Elem()
0000000000000000000000000000000000000000;;		turl := v.Field(0).String()
0000000000000000000000000000000000000000;;		val := v.Field(1).Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only the part of type_url after the last slash is relevant.
0000000000000000000000000000000000000000;;		mname := turl
0000000000000000000000000000000000000000;;		if slash := strings.LastIndex(mname, "/"); slash >= 0 {
0000000000000000000000000000000000000000;;			mname = mname[slash+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mt := proto.MessageType(mname)
0000000000000000000000000000000000000000;;		if mt == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unknown message type %q", mname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg := reflect.New(mt.Elem()).Interface().(proto.Message)
0000000000000000000000000000000000000000;;		if err := proto.Unmarshal(val, msg); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := msg.(wkt); ok {
0000000000000000000000000000000000000000;;			out.write("{")
0000000000000000000000000000000000000000;;			if m.Indent != "" {
0000000000000000000000000000000000000000;;				out.write("\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := m.marshalTypeURL(out, indent, turl); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.writeSep(out)
0000000000000000000000000000000000000000;;			if m.Indent != "" {
0000000000000000000000000000000000000000;;				out.write(indent)
0000000000000000000000000000000000000000;;				out.write(m.Indent)
0000000000000000000000000000000000000000;;				out.write(`"value": `)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out.write(`"value":`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := m.marshalObject(out, msg, indent+m.Indent, ""); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if m.Indent != "" {
0000000000000000000000000000000000000000;;				out.write("\n")
0000000000000000000000000000000000000000;;				out.write(indent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.write("}")
0000000000000000000000000000000000000000;;			return out.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.marshalObject(out, msg, indent, turl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Marshaler) marshalTypeURL(out *errWriter, indent, typeURL string) error {
0000000000000000000000000000000000000000;;		if m.Indent != "" {
0000000000000000000000000000000000000000;;			out.write(indent)
0000000000000000000000000000000000000000;;			out.write(m.Indent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.write(`"@type":`)
0000000000000000000000000000000000000000;;		if m.Indent != "" {
0000000000000000000000000000000000000000;;			out.write(" ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := json.Marshal(typeURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.write(string(b))
0000000000000000000000000000000000000000;;		return out.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// marshalField writes field description and value to the Writer.
0000000000000000000000000000000000000000;;	func (m *Marshaler) marshalField(out *errWriter, prop *proto.Properties, v reflect.Value, indent string) error {
0000000000000000000000000000000000000000;;		if m.Indent != "" {
0000000000000000000000000000000000000000;;			out.write(indent)
0000000000000000000000000000000000000000;;			out.write(m.Indent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.write(`"`)
0000000000000000000000000000000000000000;;		out.write(prop.JSONName)
0000000000000000000000000000000000000000;;		out.write(`":`)
0000000000000000000000000000000000000000;;		if m.Indent != "" {
0000000000000000000000000000000000000000;;			out.write(" ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := m.marshalValue(out, prop, v, indent); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// marshalValue writes the value to the Writer.
0000000000000000000000000000000000000000;;	func (m *Marshaler) marshalValue(out *errWriter, prop *proto.Properties, v reflect.Value, indent string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		v = reflect.Indirect(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle repeated elements.
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Slice && v.Type().Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;			out.write("[")
0000000000000000000000000000000000000000;;			comma := ""
0000000000000000000000000000000000000000;;			for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;				sliceVal := v.Index(i)
0000000000000000000000000000000000000000;;				out.write(comma)
0000000000000000000000000000000000000000;;				if m.Indent != "" {
0000000000000000000000000000000000000000;;					out.write("\n")
0000000000000000000000000000000000000000;;					out.write(indent)
0000000000000000000000000000000000000000;;					out.write(m.Indent)
0000000000000000000000000000000000000000;;					out.write(m.Indent)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := m.marshalValue(out, prop, sliceVal, indent+m.Indent); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				comma = ","
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if m.Indent != "" {
0000000000000000000000000000000000000000;;				out.write("\n")
0000000000000000000000000000000000000000;;				out.write(indent)
0000000000000000000000000000000000000000;;				out.write(m.Indent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.write("]")
0000000000000000000000000000000000000000;;			return out.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle well-known types.
0000000000000000000000000000000000000000;;		// Most are handled up in marshalObject (because 99% are messages).
0000000000000000000000000000000000000000;;		type wkt interface {
0000000000000000000000000000000000000000;;			XXX_WellKnownType() string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wkt, ok := v.Interface().(wkt); ok {
0000000000000000000000000000000000000000;;			switch wkt.XXX_WellKnownType() {
0000000000000000000000000000000000000000;;			case "NullValue":
0000000000000000000000000000000000000000;;				out.write("null")
0000000000000000000000000000000000000000;;				return out.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle enumerations.
0000000000000000000000000000000000000000;;		if !m.EnumsAsInts && prop.Enum != "" {
0000000000000000000000000000000000000000;;			// Unknown enum values will are stringified by the proto library as their
0000000000000000000000000000000000000000;;			// value. Such values should _not_ be quoted or they will be interpreted
0000000000000000000000000000000000000000;;			// as an enum string instead of their value.
0000000000000000000000000000000000000000;;			enumStr := v.Interface().(fmt.Stringer).String()
0000000000000000000000000000000000000000;;			var valStr string
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				valStr = strconv.Itoa(int(v.Elem().Int()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				valStr = strconv.Itoa(int(v.Int()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			isKnownEnum := enumStr != valStr
0000000000000000000000000000000000000000;;			if isKnownEnum {
0000000000000000000000000000000000000000;;				out.write(`"`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.write(enumStr)
0000000000000000000000000000000000000000;;			if isKnownEnum {
0000000000000000000000000000000000000000;;				out.write(`"`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle nested messages.
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			return m.marshalObject(out, v.Addr().Interface().(proto.Message), indent+m.Indent, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle maps.
0000000000000000000000000000000000000000;;		// Since Go randomizes map iteration, we sort keys for stable output.
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;			out.write(`{`)
0000000000000000000000000000000000000000;;			keys := v.MapKeys()
0000000000000000000000000000000000000000;;			sort.Sort(mapKeys(keys))
0000000000000000000000000000000000000000;;			for i, k := range keys {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					out.write(`,`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if m.Indent != "" {
0000000000000000000000000000000000000000;;					out.write("\n")
0000000000000000000000000000000000000000;;					out.write(indent)
0000000000000000000000000000000000000000;;					out.write(m.Indent)
0000000000000000000000000000000000000000;;					out.write(m.Indent)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				b, err := json.Marshal(k.Interface())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s := string(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If the JSON is not a string value, encode it again to make it one.
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(s, `"`) {
0000000000000000000000000000000000000000;;					b, err := json.Marshal(s)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					s = string(b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				out.write(s)
0000000000000000000000000000000000000000;;				out.write(`:`)
0000000000000000000000000000000000000000;;				if m.Indent != "" {
0000000000000000000000000000000000000000;;					out.write(` `)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := m.marshalValue(out, prop, v.MapIndex(k), indent+m.Indent); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if m.Indent != "" {
0000000000000000000000000000000000000000;;				out.write("\n")
0000000000000000000000000000000000000000;;				out.write(indent)
0000000000000000000000000000000000000000;;				out.write(m.Indent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.write(`}`)
0000000000000000000000000000000000000000;;			return out.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default handling defers to the encoding/json library.
0000000000000000000000000000000000000000;;		b, err := json.Marshal(v.Interface())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		needToQuote := string(b[0]) != `"` && (v.Kind() == reflect.Int64 || v.Kind() == reflect.Uint64)
0000000000000000000000000000000000000000;;		if needToQuote {
0000000000000000000000000000000000000000;;			out.write(`"`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.write(string(b))
0000000000000000000000000000000000000000;;		if needToQuote {
0000000000000000000000000000000000000000;;			out.write(`"`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshaler is a configurable object for converting from a JSON
0000000000000000000000000000000000000000;;	// representation to a protocol buffer object.
0000000000000000000000000000000000000000;;	type Unmarshaler struct {
0000000000000000000000000000000000000000;;		// Whether to allow messages to contain unknown fields, as opposed to
0000000000000000000000000000000000000000;;		// failing to unmarshal.
0000000000000000000000000000000000000000;;		AllowUnknownFields bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalNext unmarshals the next protocol buffer from a JSON object stream.
0000000000000000000000000000000000000000;;	// This function is lenient and will decode any options permutations of the
0000000000000000000000000000000000000000;;	// related Marshaler.
0000000000000000000000000000000000000000;;	func (u *Unmarshaler) UnmarshalNext(dec *json.Decoder, pb proto.Message) error {
0000000000000000000000000000000000000000;;		inputValue := json.RawMessage{}
0000000000000000000000000000000000000000;;		if err := dec.Decode(&inputValue); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.unmarshalValue(reflect.ValueOf(pb).Elem(), inputValue, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal unmarshals a JSON object stream into a protocol
0000000000000000000000000000000000000000;;	// buffer. This function is lenient and will decode any options
0000000000000000000000000000000000000000;;	// permutations of the related Marshaler.
0000000000000000000000000000000000000000;;	func (u *Unmarshaler) Unmarshal(r io.Reader, pb proto.Message) error {
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(r)
0000000000000000000000000000000000000000;;		return u.UnmarshalNext(dec, pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalNext unmarshals the next protocol buffer from a JSON object stream.
0000000000000000000000000000000000000000;;	// This function is lenient and will decode any options permutations of the
0000000000000000000000000000000000000000;;	// related Marshaler.
0000000000000000000000000000000000000000;;	func UnmarshalNext(dec *json.Decoder, pb proto.Message) error {
0000000000000000000000000000000000000000;;		return new(Unmarshaler).UnmarshalNext(dec, pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal unmarshals a JSON object stream into a protocol
0000000000000000000000000000000000000000;;	// buffer. This function is lenient and will decode any options
0000000000000000000000000000000000000000;;	// permutations of the related Marshaler.
0000000000000000000000000000000000000000;;	func Unmarshal(r io.Reader, pb proto.Message) error {
0000000000000000000000000000000000000000;;		return new(Unmarshaler).Unmarshal(r, pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalString will populate the fields of a protocol buffer based
0000000000000000000000000000000000000000;;	// on a JSON string. This function is lenient and will decode any options
0000000000000000000000000000000000000000;;	// permutations of the related Marshaler.
0000000000000000000000000000000000000000;;	func UnmarshalString(str string, pb proto.Message) error {
0000000000000000000000000000000000000000;;		return new(Unmarshaler).Unmarshal(strings.NewReader(str), pb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalValue converts/copies a value into the target.
0000000000000000000000000000000000000000;;	// prop may be nil.
0000000000000000000000000000000000000000;;	func (u *Unmarshaler) unmarshalValue(target reflect.Value, inputValue json.RawMessage, prop *proto.Properties) error {
0000000000000000000000000000000000000000;;		targetType := target.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allocate memory for pointer fields.
0000000000000000000000000000000000000000;;		if targetType.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			target.Set(reflect.New(targetType.Elem()))
0000000000000000000000000000000000000000;;			return u.unmarshalValue(target.Elem(), inputValue, prop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle well-known types.
0000000000000000000000000000000000000000;;		type wkt interface {
0000000000000000000000000000000000000000;;			XXX_WellKnownType() string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wkt, ok := target.Addr().Interface().(wkt); ok {
0000000000000000000000000000000000000000;;			switch wkt.XXX_WellKnownType() {
0000000000000000000000000000000000000000;;			case "DoubleValue", "FloatValue", "Int64Value", "UInt64Value",
0000000000000000000000000000000000000000;;				"Int32Value", "UInt32Value", "BoolValue", "StringValue", "BytesValue":
0000000000000000000000000000000000000000;;				// "Wrappers use the same representation in JSON
0000000000000000000000000000000000000000;;				//  as the wrapped primitive type, except that null is allowed."
0000000000000000000000000000000000000000;;				// encoding/json will turn JSON `null` into Go `nil`,
0000000000000000000000000000000000000000;;				// so we don't have to do any extra work.
0000000000000000000000000000000000000000;;				return u.unmarshalValue(target.Field(0), inputValue, prop)
0000000000000000000000000000000000000000;;			case "Any":
0000000000000000000000000000000000000000;;				return fmt.Errorf("unmarshaling Any not supported yet")
0000000000000000000000000000000000000000;;			case "Duration":
0000000000000000000000000000000000000000;;				unq, err := strconv.Unquote(string(inputValue))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d, err := time.ParseDuration(unq)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("bad Duration: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ns := d.Nanoseconds()
0000000000000000000000000000000000000000;;				s := ns / 1e9
0000000000000000000000000000000000000000;;				ns %= 1e9
0000000000000000000000000000000000000000;;				target.Field(0).SetInt(s)
0000000000000000000000000000000000000000;;				target.Field(1).SetInt(ns)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case "Timestamp":
0000000000000000000000000000000000000000;;				unq, err := strconv.Unquote(string(inputValue))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t, err := time.Parse(time.RFC3339Nano, unq)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("bad Timestamp: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				target.Field(0).SetInt(int64(t.Unix()))
0000000000000000000000000000000000000000;;				target.Field(1).SetInt(int64(t.Nanosecond()))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle enums, which have an underlying type of int32,
0000000000000000000000000000000000000000;;		// and may appear as strings.
0000000000000000000000000000000000000000;;		// The case of an enum appearing as a number is handled
0000000000000000000000000000000000000000;;		// at the bottom of this function.
0000000000000000000000000000000000000000;;		if inputValue[0] == '"' && prop != nil && prop.Enum != "" {
0000000000000000000000000000000000000000;;			vmap := proto.EnumValueMap(prop.Enum)
0000000000000000000000000000000000000000;;			// Don't need to do unquoting; valid enum names
0000000000000000000000000000000000000000;;			// are from a limited character set.
0000000000000000000000000000000000000000;;			s := inputValue[1 : len(inputValue)-1]
0000000000000000000000000000000000000000;;			n, ok := vmap[string(s)]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unknown value %q for enum %s", s, prop.Enum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if target.Kind() == reflect.Ptr { // proto2
0000000000000000000000000000000000000000;;				target.Set(reflect.New(targetType.Elem()))
0000000000000000000000000000000000000000;;				target = target.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.SetInt(int64(n))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle nested messages.
0000000000000000000000000000000000000000;;		if targetType.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			var jsonFields map[string]json.RawMessage
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(inputValue, &jsonFields); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			consumeField := func(prop *proto.Properties) (json.RawMessage, bool) {
0000000000000000000000000000000000000000;;				// Be liberal in what names we accept; both orig_name and camelName are okay.
0000000000000000000000000000000000000000;;				fieldNames := acceptedJSONFieldNames(prop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				vOrig, okOrig := jsonFields[fieldNames.orig]
0000000000000000000000000000000000000000;;				vCamel, okCamel := jsonFields[fieldNames.camel]
0000000000000000000000000000000000000000;;				if !okOrig && !okCamel {
0000000000000000000000000000000000000000;;					return nil, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If, for some reason, both are present in the data, favour the camelName.
0000000000000000000000000000000000000000;;				var raw json.RawMessage
0000000000000000000000000000000000000000;;				if okOrig {
0000000000000000000000000000000000000000;;					raw = vOrig
0000000000000000000000000000000000000000;;					delete(jsonFields, fieldNames.orig)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if okCamel {
0000000000000000000000000000000000000000;;					raw = vCamel
0000000000000000000000000000000000000000;;					delete(jsonFields, fieldNames.camel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return raw, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sprops := proto.GetProperties(targetType)
0000000000000000000000000000000000000000;;			for i := 0; i < target.NumField(); i++ {
0000000000000000000000000000000000000000;;				ft := target.Type().Field(i)
0000000000000000000000000000000000000000;;				if strings.HasPrefix(ft.Name, "XXX_") {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				valueForField, ok := consumeField(sprops.Prop[i])
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := u.unmarshalValue(target.Field(i), valueForField, sprops.Prop[i]); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for any oneof fields.
0000000000000000000000000000000000000000;;			if len(jsonFields) > 0 {
0000000000000000000000000000000000000000;;				for _, oop := range sprops.OneofTypes {
0000000000000000000000000000000000000000;;					raw, ok := consumeField(oop.Prop)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					nv := reflect.New(oop.Type.Elem())
0000000000000000000000000000000000000000;;					target.Field(oop.Field).Set(nv)
0000000000000000000000000000000000000000;;					if err := u.unmarshalValue(nv.Elem().Field(0), raw, oop.Prop); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !u.AllowUnknownFields && len(jsonFields) > 0 {
0000000000000000000000000000000000000000;;				// Pick any field to be the scapegoat.
0000000000000000000000000000000000000000;;				var f string
0000000000000000000000000000000000000000;;				for fname := range jsonFields {
0000000000000000000000000000000000000000;;					f = fname
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("unknown field %q in %v", f, targetType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle arrays (which aren't encoded bytes)
0000000000000000000000000000000000000000;;		if targetType.Kind() == reflect.Slice && targetType.Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;			var slc []json.RawMessage
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(inputValue, &slc); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			len := len(slc)
0000000000000000000000000000000000000000;;			target.Set(reflect.MakeSlice(targetType, len, len))
0000000000000000000000000000000000000000;;			for i := 0; i < len; i++ {
0000000000000000000000000000000000000000;;				if err := u.unmarshalValue(target.Index(i), slc[i], prop); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle maps (whose keys are always strings)
0000000000000000000000000000000000000000;;		if targetType.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;			var mp map[string]json.RawMessage
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(inputValue, &mp); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.Set(reflect.MakeMap(targetType))
0000000000000000000000000000000000000000;;			var keyprop, valprop *proto.Properties
0000000000000000000000000000000000000000;;			if prop != nil {
0000000000000000000000000000000000000000;;				// These could still be nil if the protobuf metadata is broken somehow.
0000000000000000000000000000000000000000;;				// TODO: This won't work because the fields are unexported.
0000000000000000000000000000000000000000;;				// We should probably just reparse them.
0000000000000000000000000000000000000000;;				//keyprop, valprop = prop.mkeyprop, prop.mvalprop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for ks, raw := range mp {
0000000000000000000000000000000000000000;;				// Unmarshal map key. The core json library already decoded the key into a
0000000000000000000000000000000000000000;;				// string, so we handle that specially. Other types were quoted post-serialization.
0000000000000000000000000000000000000000;;				var k reflect.Value
0000000000000000000000000000000000000000;;				if targetType.Key().Kind() == reflect.String {
0000000000000000000000000000000000000000;;					k = reflect.ValueOf(ks)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					k = reflect.New(targetType.Key()).Elem()
0000000000000000000000000000000000000000;;					if err := u.unmarshalValue(k, json.RawMessage(ks), keyprop); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Unmarshal map value.
0000000000000000000000000000000000000000;;				v := reflect.New(targetType.Elem()).Elem()
0000000000000000000000000000000000000000;;				if err := u.unmarshalValue(v, raw, valprop); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				target.SetMapIndex(k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 64-bit integers can be encoded as strings. In this case we drop
0000000000000000000000000000000000000000;;		// the quotes and proceed as normal.
0000000000000000000000000000000000000000;;		isNum := targetType.Kind() == reflect.Int64 || targetType.Kind() == reflect.Uint64
0000000000000000000000000000000000000000;;		if isNum && strings.HasPrefix(string(inputValue), `"`) {
0000000000000000000000000000000000000000;;			inputValue = inputValue[1 : len(inputValue)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use the encoding/json for parsing other value types.
0000000000000000000000000000000000000000;;		return json.Unmarshal(inputValue, target.Addr().Interface())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// jsonProperties returns parsed proto.Properties for the field and corrects JSONName attribute.
0000000000000000000000000000000000000000;;	func jsonProperties(f reflect.StructField, origName bool) *proto.Properties {
0000000000000000000000000000000000000000;;		var prop proto.Properties
0000000000000000000000000000000000000000;;		prop.Init(f.Type, f.Name, f.Tag.Get("protobuf"), &f)
0000000000000000000000000000000000000000;;		if origName || prop.JSONName == "" {
0000000000000000000000000000000000000000;;			prop.JSONName = prop.OrigName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &prop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldNames struct {
0000000000000000000000000000000000000000;;		orig, camel string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func acceptedJSONFieldNames(prop *proto.Properties) fieldNames {
0000000000000000000000000000000000000000;;		opts := fieldNames{orig: prop.OrigName, camel: prop.OrigName}
0000000000000000000000000000000000000000;;		if prop.JSONName != "" {
0000000000000000000000000000000000000000;;			opts.camel = prop.JSONName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return opts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writer wrapper inspired by https://blog.golang.org/errors-are-values
0000000000000000000000000000000000000000;;	type errWriter struct {
0000000000000000000000000000000000000000;;		writer io.Writer
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *errWriter) write(str string) {
0000000000000000000000000000000000000000;;		if w.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, w.err = w.writer.Write([]byte(str))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map fields may have key types of non-float scalars, strings and enums.
0000000000000000000000000000000000000000;;	// The easiest way to sort them in some deterministic order is to use fmt.
0000000000000000000000000000000000000000;;	// If this turns out to be inefficient we can always consider other options,
0000000000000000000000000000000000000000;;	// such as doing a Schwartzian transform.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Numeric keys are sorted in numeric order per
0000000000000000000000000000000000000000;;	// https://developers.google.com/protocol-buffers/docs/proto#maps.
0000000000000000000000000000000000000000;;	type mapKeys []reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s mapKeys) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s mapKeys) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s mapKeys) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if k := s[i].Kind(); k == s[j].Kind() {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;				return s[i].Int() < s[j].Int()
0000000000000000000000000000000000000000;;			case reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;				return s[i].Uint() < s[j].Uint()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprint(s[i].Interface()) < fmt.Sprint(s[j].Interface())
0000000000000000000000000000000000000000;;	}
