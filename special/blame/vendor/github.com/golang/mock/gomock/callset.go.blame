0000000000000000000000000000000000000000;;	// Copyright 2011 Google Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5f87dac1429fcf199c11f22276df54821e7b72fb;Godeps/_workspace/src/github.com/golang/mock/gomock/callset.go[Godeps/_workspace/src/github.com/golang/mock/gomock/callset.go][vendor/github.com/golang/mock/gomock/callset.go];	
0000000000000000000000000000000000000000;;	package gomock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// callSet represents a set of expected calls, indexed by receiver and method
0000000000000000000000000000000000000000;;	// name.
0000000000000000000000000000000000000000;;	type callSet map[interface{}]map[string][]*Call
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a new expected call.
0000000000000000000000000000000000000000;;	func (cs callSet) Add(call *Call) {
0000000000000000000000000000000000000000;;		methodMap, ok := cs[call.receiver]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			methodMap = make(map[string][]*Call)
0000000000000000000000000000000000000000;;			cs[call.receiver] = methodMap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		methodMap[call.method] = append(methodMap[call.method], call)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes an expected call.
0000000000000000000000000000000000000000;;	func (cs callSet) Remove(call *Call) {
0000000000000000000000000000000000000000;;		methodMap, ok := cs[call.receiver]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sl := methodMap[call.method]
0000000000000000000000000000000000000000;;		for i, c := range sl {
0000000000000000000000000000000000000000;;			if c == call {
0000000000000000000000000000000000000000;;				// quick removal; we don't need to maintain call order
0000000000000000000000000000000000000000;;				if len(sl) > 1 {
0000000000000000000000000000000000000000;;					sl[i] = sl[len(sl)-1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				methodMap[call.method] = sl[:len(sl)-1]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindMatch searches for a matching call. Returns nil if no call matched.
0000000000000000000000000000000000000000;;	func (cs callSet) FindMatch(receiver interface{}, method string, args []interface{}) *Call {
0000000000000000000000000000000000000000;;		methodMap, ok := cs[receiver]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		calls, ok := methodMap[method]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Search through the unordered set of calls expected on a method on a
0000000000000000000000000000000000000000;;		// receiver.
0000000000000000000000000000000000000000;;		for _, call := range calls {
0000000000000000000000000000000000000000;;			// A call should not normally still be here if exhausted,
0000000000000000000000000000000000000000;;			// but it can happen if, for instance, .Times(0) was used.
0000000000000000000000000000000000000000;;			// Pretend the call doesn't match.
0000000000000000000000000000000000000000;;			if call.exhausted() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if call.matches(args) {
0000000000000000000000000000000000000000;;				return call
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
