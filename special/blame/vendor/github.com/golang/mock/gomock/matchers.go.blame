0000000000000000000000000000000000000000;;	// Copyright 2010 Google Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5f87dac1429fcf199c11f22276df54821e7b72fb;Godeps/_workspace/src/github.com/golang/mock/gomock/matchers.go[Godeps/_workspace/src/github.com/golang/mock/gomock/matchers.go][vendor/github.com/golang/mock/gomock/matchers.go];	
0000000000000000000000000000000000000000;;	package gomock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Matcher is a representation of a class of values.
0000000000000000000000000000000000000000;;	// It is used to represent the valid or expected arguments to a mocked method.
0000000000000000000000000000000000000000;;	type Matcher interface {
0000000000000000000000000000000000000000;;		// Matches returns whether y is a match.
0000000000000000000000000000000000000000;;		Matches(x interface{}) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// String describes what the matcher matches.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type anyMatcher struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (anyMatcher) Matches(x interface{}) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (anyMatcher) String() string {
0000000000000000000000000000000000000000;;		return "is anything"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type eqMatcher struct {
0000000000000000000000000000000000000000;;		x interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e eqMatcher) Matches(x interface{}) bool {
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(e.x, x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e eqMatcher) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("is equal to %v", e.x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nilMatcher struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nilMatcher) Matches(x interface{}) bool {
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(x)
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map,
0000000000000000000000000000000000000000;;			reflect.Ptr, reflect.Slice:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nilMatcher) String() string {
0000000000000000000000000000000000000000;;		return "is nil"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type notMatcher struct {
0000000000000000000000000000000000000000;;		m Matcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n notMatcher) Matches(x interface{}) bool {
0000000000000000000000000000000000000000;;		return !n.m.Matches(x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n notMatcher) String() string {
0000000000000000000000000000000000000000;;		// TODO: Improve this if we add a NotString method to the Matcher interface.
0000000000000000000000000000000000000000;;		return "not(" + n.m.String() + ")"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constructors
0000000000000000000000000000000000000000;;	func Any() Matcher             { return anyMatcher{} }
0000000000000000000000000000000000000000;;	func Eq(x interface{}) Matcher { return eqMatcher{x} }
0000000000000000000000000000000000000000;;	func Nil() Matcher             { return nilMatcher{} }
0000000000000000000000000000000000000000;;	func Not(x interface{}) Matcher {
0000000000000000000000000000000000000000;;		if m, ok := x.(Matcher); ok {
0000000000000000000000000000000000000000;;			return notMatcher{m}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return notMatcher{Eq(x)}
0000000000000000000000000000000000000000;;	}
