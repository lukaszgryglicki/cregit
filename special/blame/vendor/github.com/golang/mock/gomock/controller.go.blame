0000000000000000000000000000000000000000;;	// Copyright 2010 Google Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5f87dac1429fcf199c11f22276df54821e7b72fb;Godeps/_workspace/src/github.com/golang/mock/gomock/controller.go[Godeps/_workspace/src/github.com/golang/mock/gomock/controller.go][vendor/github.com/golang/mock/gomock/controller.go];	
0000000000000000000000000000000000000000;;	// GoMock - a mock framework for Go.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Standard usage:
0000000000000000000000000000000000000000;;	//   (1) Define an interface that you wish to mock.
0000000000000000000000000000000000000000;;	//         type MyInterface interface {
0000000000000000000000000000000000000000;;	//           SomeMethod(x int64, y string)
0000000000000000000000000000000000000000;;	//         }
0000000000000000000000000000000000000000;;	//   (2) Use mockgen to generate a mock from the interface.
0000000000000000000000000000000000000000;;	//   (3) Use the mock in a test:
0000000000000000000000000000000000000000;;	//         func TestMyThing(t *testing.T) {
0000000000000000000000000000000000000000;;	//           mockCtrl := gomock.NewController(t)
0000000000000000000000000000000000000000;;	//           defer mockCtrl.Finish()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//           mockObj := something.NewMockMyInterface(mockCtrl)
0000000000000000000000000000000000000000;;	//           mockObj.EXPECT().SomeMethod(4, "blah")
0000000000000000000000000000000000000000;;	//           // pass mockObj to a real object and play with it.
0000000000000000000000000000000000000000;;	//         }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// By default, expected calls are not enforced to run in any particular order.
0000000000000000000000000000000000000000;;	// Call order dependency can be enforced by use of InOrder and/or Call.After.
0000000000000000000000000000000000000000;;	// Call.After can create more varied call order dependencies, but InOrder is
0000000000000000000000000000000000000000;;	// often more convenient.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following examples create equivalent call order dependencies.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example of using Call.After to chain expected call order:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     firstCall := mockObj.EXPECT().SomeMethod(1, "first")
0000000000000000000000000000000000000000;;	//     secondCall := mockObj.EXPECT().SomeMethod(2, "second").After(firstCall)
0000000000000000000000000000000000000000;;	//     mockObj.EXPECT().SomeMethod(3, "third").After(secondCall)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example of using InOrder to declare expected call order:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     gomock.InOrder(
0000000000000000000000000000000000000000;;	//         mockObj.EXPECT().SomeMethod(1, "first"),
0000000000000000000000000000000000000000;;	//         mockObj.EXPECT().SomeMethod(2, "second"),
0000000000000000000000000000000000000000;;	//         mockObj.EXPECT().SomeMethod(3, "third"),
0000000000000000000000000000000000000000;;	//     )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	//	- Handle different argument/return types (e.g. ..., chan, map, interface).
0000000000000000000000000000000000000000;;	package gomock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A TestReporter is something that can be used to report test failures.
0000000000000000000000000000000000000000;;	// It is satisfied by the standard library's *testing.T.
0000000000000000000000000000000000000000;;	type TestReporter interface {
0000000000000000000000000000000000000000;;		Errorf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Fatalf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Controller represents the top-level control of a mock ecosystem.
0000000000000000000000000000000000000000;;	// It defines the scope and lifetime of mock objects, as well as their expectations.
0000000000000000000000000000000000000000;;	// It is safe to call Controller's methods from multiple goroutines.
0000000000000000000000000000000000000000;;	type Controller struct {
0000000000000000000000000000000000000000;;		mu            sync.Mutex
0000000000000000000000000000000000000000;;		t             TestReporter
0000000000000000000000000000000000000000;;		expectedCalls callSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewController(t TestReporter) *Controller {
0000000000000000000000000000000000000000;;		return &Controller{
0000000000000000000000000000000000000000;;			t:             t,
0000000000000000000000000000000000000000;;			expectedCalls: make(callSet),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctrl *Controller) RecordCall(receiver interface{}, method string, args ...interface{}) *Call {
0000000000000000000000000000000000000000;;		// TODO: check arity, types.
0000000000000000000000000000000000000000;;		margs := make([]Matcher, len(args))
0000000000000000000000000000000000000000;;		for i, arg := range args {
0000000000000000000000000000000000000000;;			if m, ok := arg.(Matcher); ok {
0000000000000000000000000000000000000000;;				margs[i] = m
0000000000000000000000000000000000000000;;			} else if arg == nil {
0000000000000000000000000000000000000000;;				// Handle nil specially so that passing a nil interface value
0000000000000000000000000000000000000000;;				// will match the typed nils of concrete args.
0000000000000000000000000000000000000000;;				margs[i] = Nil()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				margs[i] = Eq(arg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctrl.mu.Lock()
0000000000000000000000000000000000000000;;		defer ctrl.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		call := &Call{t: ctrl.t, receiver: receiver, method: method, args: margs, minCalls: 1, maxCalls: 1}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctrl.expectedCalls.Add(call)
0000000000000000000000000000000000000000;;		return call
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctrl *Controller) Call(receiver interface{}, method string, args ...interface{}) []interface{} {
0000000000000000000000000000000000000000;;		ctrl.mu.Lock()
0000000000000000000000000000000000000000;;		defer ctrl.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := ctrl.expectedCalls.FindMatch(receiver, method, args)
0000000000000000000000000000000000000000;;		if expected == nil {
0000000000000000000000000000000000000000;;			ctrl.t.Fatalf("no matching expected call: %T.%v(%v)", receiver, method, args)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two things happen here:
0000000000000000000000000000000000000000;;		// * the matching call no longer needs to check prerequite calls,
0000000000000000000000000000000000000000;;		// * and the prerequite calls are no longer expected, so remove them.
0000000000000000000000000000000000000000;;		preReqCalls := expected.dropPrereqs()
0000000000000000000000000000000000000000;;		for _, preReqCall := range preReqCalls {
0000000000000000000000000000000000000000;;			ctrl.expectedCalls.Remove(preReqCall)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rets, action := expected.call(args)
0000000000000000000000000000000000000000;;		if expected.exhausted() {
0000000000000000000000000000000000000000;;			ctrl.expectedCalls.Remove(expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't hold the lock while doing the call's action (if any)
0000000000000000000000000000000000000000;;		// so that actions may execute concurrently.
0000000000000000000000000000000000000000;;		// We use the deferred Unlock to capture any panics that happen above;
0000000000000000000000000000000000000000;;		// here we add a deferred Lock to balance it.
0000000000000000000000000000000000000000;;		ctrl.mu.Unlock()
0000000000000000000000000000000000000000;;		defer ctrl.mu.Lock()
0000000000000000000000000000000000000000;;		if action != nil {
0000000000000000000000000000000000000000;;			action()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctrl *Controller) Finish() {
0000000000000000000000000000000000000000;;		ctrl.mu.Lock()
0000000000000000000000000000000000000000;;		defer ctrl.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we're currently panicking, probably because this is a deferred call,
0000000000000000000000000000000000000000;;		// pass through the panic.
0000000000000000000000000000000000000000;;		if err := recover(); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that all remaining expected calls are satisfied.
0000000000000000000000000000000000000000;;		failures := false
0000000000000000000000000000000000000000;;		for _, methodMap := range ctrl.expectedCalls {
0000000000000000000000000000000000000000;;			for _, calls := range methodMap {
0000000000000000000000000000000000000000;;				for _, call := range calls {
0000000000000000000000000000000000000000;;					if !call.satisfied() {
0000000000000000000000000000000000000000;;						ctrl.t.Errorf("missing call(s) to %v", call)
0000000000000000000000000000000000000000;;						failures = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if failures {
0000000000000000000000000000000000000000;;			ctrl.t.Fatalf("aborting test due to missing call(s)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
