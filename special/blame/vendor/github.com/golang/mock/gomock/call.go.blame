0000000000000000000000000000000000000000;;	// Copyright 2010 Google Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5f87dac1429fcf199c11f22276df54821e7b72fb;Godeps/_workspace/src/github.com/golang/mock/gomock/call.go[Godeps/_workspace/src/github.com/golang/mock/gomock/call.go][vendor/github.com/golang/mock/gomock/call.go];	
0000000000000000000000000000000000000000;;	package gomock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call represents an expected call to a mock.
0000000000000000000000000000000000000000;;	type Call struct {
0000000000000000000000000000000000000000;;		t TestReporter // for triggering test failures on invalid call setup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		receiver interface{}   // the receiver of the method call
0000000000000000000000000000000000000000;;		method   string        // the name of the method
0000000000000000000000000000000000000000;;		args     []Matcher     // the args
0000000000000000000000000000000000000000;;		rets     []interface{} // the return values (if any)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preReqs []*Call // prerequisite calls
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expectations
0000000000000000000000000000000000000000;;		minCalls, maxCalls int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numCalls int // actual number made
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Actions
0000000000000000000000000000000000000000;;		doFunc  reflect.Value
0000000000000000000000000000000000000000;;		setArgs map[int]reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnyTimes allows the expectation to be called 0 or more times
0000000000000000000000000000000000000000;;	func (c *Call) AnyTimes() *Call {
0000000000000000000000000000000000000000;;		c.minCalls, c.maxCalls = 0, 1e8 // close enough to infinity
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinTimes requires the call to occur at least n times. If AnyTimes or MaxTimes have not been called, MinTimes also
0000000000000000000000000000000000000000;;	// sets the maximum number of calls to infinity.
0000000000000000000000000000000000000000;;	func (c *Call) MinTimes(n int) *Call {
0000000000000000000000000000000000000000;;		c.minCalls = n
0000000000000000000000000000000000000000;;		if c.maxCalls == 1 {
0000000000000000000000000000000000000000;;			c.maxCalls = 1e8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxTimes limits the number of calls to n times. If AnyTimes or MinTimes have not been called, MaxTimes also
0000000000000000000000000000000000000000;;	// sets the minimum number of calls to 0.
0000000000000000000000000000000000000000;;	func (c *Call) MaxTimes(n int) *Call {
0000000000000000000000000000000000000000;;		c.maxCalls = n
0000000000000000000000000000000000000000;;		if c.minCalls == 1 {
0000000000000000000000000000000000000000;;			c.minCalls = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do declares the action to run when the call is matched.
0000000000000000000000000000000000000000;;	// It takes an interface{} argument to support n-arity functions.
0000000000000000000000000000000000000000;;	func (c *Call) Do(f interface{}) *Call {
0000000000000000000000000000000000000000;;		// TODO: Check arity and types here, rather than dying badly elsewhere.
0000000000000000000000000000000000000000;;		c.doFunc = reflect.ValueOf(f)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Call) Return(rets ...interface{}) *Call {
0000000000000000000000000000000000000000;;		mt := c.methodType()
0000000000000000000000000000000000000000;;		if len(rets) != mt.NumOut() {
0000000000000000000000000000000000000000;;			c.t.Fatalf("wrong number of arguments to Return for %T.%v: got %d, want %d",
0000000000000000000000000000000000000000;;				c.receiver, c.method, len(rets), mt.NumOut())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, ret := range rets {
0000000000000000000000000000000000000000;;			if got, want := reflect.TypeOf(ret), mt.Out(i); got == want {
0000000000000000000000000000000000000000;;				// Identical types; nothing to do.
0000000000000000000000000000000000000000;;			} else if got == nil {
0000000000000000000000000000000000000000;;				// Nil needs special handling.
0000000000000000000000000000000000000000;;				switch want.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
0000000000000000000000000000000000000000;;					// ok
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					c.t.Fatalf("argument %d to Return for %T.%v is nil, but %v is not nillable",
0000000000000000000000000000000000000000;;						i, c.receiver, c.method, want)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if got.AssignableTo(want) {
0000000000000000000000000000000000000000;;				// Assignable type relation. Make the assignment now so that the generated code
0000000000000000000000000000000000000000;;				// can return the values with a type assertion.
0000000000000000000000000000000000000000;;				v := reflect.New(want).Elem()
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(ret))
0000000000000000000000000000000000000000;;				rets[i] = v.Interface()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c.t.Fatalf("wrong type of argument %d to Return for %T.%v: %v is not assignable to %v",
0000000000000000000000000000000000000000;;					i, c.receiver, c.method, got, want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.rets = rets
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Call) Times(n int) *Call {
0000000000000000000000000000000000000000;;		c.minCalls, c.maxCalls = n, n
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetArg declares an action that will set the nth argument's value,
0000000000000000000000000000000000000000;;	// indirected through a pointer.
0000000000000000000000000000000000000000;;	func (c *Call) SetArg(n int, value interface{}) *Call {
0000000000000000000000000000000000000000;;		if c.setArgs == nil {
0000000000000000000000000000000000000000;;			c.setArgs = make(map[int]reflect.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mt := c.methodType()
0000000000000000000000000000000000000000;;		// TODO: This will break on variadic methods.
0000000000000000000000000000000000000000;;		// We will need to check those at invocation time.
0000000000000000000000000000000000000000;;		if n < 0 || n >= mt.NumIn() {
0000000000000000000000000000000000000000;;			c.t.Fatalf("SetArg(%d, ...) called for a method with %d args", n, mt.NumIn())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Permit setting argument through an interface.
0000000000000000000000000000000000000000;;		// In the interface case, we don't (nay, can't) check the type here.
0000000000000000000000000000000000000000;;		at := mt.In(n)
0000000000000000000000000000000000000000;;		switch at.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			dt := at.Elem()
0000000000000000000000000000000000000000;;			if vt := reflect.TypeOf(value); !vt.AssignableTo(dt) {
0000000000000000000000000000000000000000;;				c.t.Fatalf("SetArg(%d, ...) argument is a %v, not assignable to %v", n, vt, dt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// nothing to do
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			c.t.Fatalf("SetArg(%d, ...) referring to argument of non-pointer non-interface type %v", n, at)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.setArgs[n] = reflect.ValueOf(value)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPreReq returns true if other is a direct or indirect prerequisite to c.
0000000000000000000000000000000000000000;;	func (c *Call) isPreReq(other *Call) bool {
0000000000000000000000000000000000000000;;		for _, preReq := range c.preReqs {
0000000000000000000000000000000000000000;;			if other == preReq || preReq.isPreReq(other) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// After declares that the call may only match after preReq has been exhausted.
0000000000000000000000000000000000000000;;	func (c *Call) After(preReq *Call) *Call {
0000000000000000000000000000000000000000;;		if preReq.isPreReq(c) {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf(
0000000000000000000000000000000000000000;;				"Loop in call order: %v is a prerequisite to %v (possibly indirectly).",
0000000000000000000000000000000000000000;;				c, preReq,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			panic(msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.preReqs = append(c.preReqs, preReq)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true iff the minimum number of calls have been made.
0000000000000000000000000000000000000000;;	func (c *Call) satisfied() bool {
0000000000000000000000000000000000000000;;		return c.numCalls >= c.minCalls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true iff the maximum number of calls have been made.
0000000000000000000000000000000000000000;;	func (c *Call) exhausted() bool {
0000000000000000000000000000000000000000;;		return c.numCalls >= c.maxCalls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Call) String() string {
0000000000000000000000000000000000000000;;		args := make([]string, len(c.args))
0000000000000000000000000000000000000000;;		for i, arg := range c.args {
0000000000000000000000000000000000000000;;			args[i] = arg.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		arguments := strings.Join(args, ", ")
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%T.%v(%s)", c.receiver, c.method, arguments)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests if the given call matches the expected call.
0000000000000000000000000000000000000000;;	func (c *Call) matches(args []interface{}) bool {
0000000000000000000000000000000000000000;;		if len(args) != len(c.args) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, m := range c.args {
0000000000000000000000000000000000000000;;			if !m.Matches(args[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that all prerequisite calls have been satisfied.
0000000000000000000000000000000000000000;;		for _, preReqCall := range c.preReqs {
0000000000000000000000000000000000000000;;			if !preReqCall.satisfied() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dropPrereqs tells the expected Call to not re-check prerequite calls any
0000000000000000000000000000000000000000;;	// longer, and to return its current set.
0000000000000000000000000000000000000000;;	func (c *Call) dropPrereqs() (preReqs []*Call) {
0000000000000000000000000000000000000000;;		preReqs = c.preReqs
0000000000000000000000000000000000000000;;		c.preReqs = nil
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Call) call(args []interface{}) (rets []interface{}, action func()) {
0000000000000000000000000000000000000000;;		c.numCalls++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Actions
0000000000000000000000000000000000000000;;		if c.doFunc.IsValid() {
0000000000000000000000000000000000000000;;			doArgs := make([]reflect.Value, len(args))
0000000000000000000000000000000000000000;;			ft := c.doFunc.Type()
0000000000000000000000000000000000000000;;			for i := 0; i < ft.NumIn(); i++ {
0000000000000000000000000000000000000000;;				if args[i] != nil {
0000000000000000000000000000000000000000;;					doArgs[i] = reflect.ValueOf(args[i])
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Use the zero value for the arg.
0000000000000000000000000000000000000000;;					doArgs[i] = reflect.Zero(ft.In(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			action = func() { c.doFunc.Call(doArgs) }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for n, v := range c.setArgs {
0000000000000000000000000000000000000000;;			reflect.ValueOf(args[n]).Elem().Set(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rets = c.rets
0000000000000000000000000000000000000000;;		if rets == nil {
0000000000000000000000000000000000000000;;			// Synthesize the zero value for each of the return args' types.
0000000000000000000000000000000000000000;;			mt := c.methodType()
0000000000000000000000000000000000000000;;			rets = make([]interface{}, mt.NumOut())
0000000000000000000000000000000000000000;;			for i := 0; i < mt.NumOut(); i++ {
0000000000000000000000000000000000000000;;				rets[i] = reflect.Zero(mt.Out(i)).Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Call) methodType() reflect.Type {
0000000000000000000000000000000000000000;;		recv := reflect.ValueOf(c.receiver)
0000000000000000000000000000000000000000;;		for i := 0; i < recv.Type().NumMethod(); i++ {
0000000000000000000000000000000000000000;;			if recv.Type().Method(i).Name == c.method {
0000000000000000000000000000000000000000;;				return recv.Method(i).Type()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("gomock: failed finding method %s on %T", c.method, c.receiver))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InOrder declares that the given calls should occur in order.
0000000000000000000000000000000000000000;;	func InOrder(calls ...*Call) {
0000000000000000000000000000000000000000;;		for i := 1; i < len(calls); i++ {
0000000000000000000000000000000000000000;;			calls[i].After(calls[i-1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
