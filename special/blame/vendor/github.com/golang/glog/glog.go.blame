0000000000000000000000000000000000000000;;	// Go support for leveled logs, analogous to https://code.google.com/p/google-glog/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2013 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b3faa8ca9b634f2668b82c3cc87176e792c846e2;third_party/src/github.com/golang/glog/glog.go[third_party/src/github.com/golang/glog/glog.go][vendor/github.com/golang/glog/glog.go];	
0000000000000000000000000000000000000000;;	// Package glog implements logging analogous to the Google-internal C++ INFO/ERROR/V setup.
0000000000000000000000000000000000000000;;	// It provides functions Info, Warning, Error, Fatal, plus formatting variants such as
0000000000000000000000000000000000000000;;	// Infof. It also provides V-style logging controlled by the -v and -vmodule=file=2 flags.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Basic examples:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	glog.Info("Prepare to repel boarders")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	glog.Fatalf("Initialization failed: %s", err)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the documentation for the V function for an explanation of these examples:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	if glog.V(2) {
0000000000000000000000000000000000000000;;	//		glog.Info("Starting transaction...")
0000000000000000000000000000000000000000;;	//	}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	glog.V(2).Infoln("Processed", nItems, "elements")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Log output is buffered and written periodically using Flush. Programs
0000000000000000000000000000000000000000;;	// should call Flush before exiting to guarantee all log output is written.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// By default, all log statements write to files in a temporary directory.
0000000000000000000000000000000000000000;;	// This package provides several flags that modify this behavior.
0000000000000000000000000000000000000000;;	// As a result, flag.Parse must be called before any logging is done.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	-logtostderr=false
0000000000000000000000000000000000000000;;	//		Logs are written to standard error instead of to files.
0000000000000000000000000000000000000000;;	//	-alsologtostderr=false
0000000000000000000000000000000000000000;;	//		Logs are written to standard error as well as to files.
0000000000000000000000000000000000000000;;	//	-stderrthreshold=ERROR
0000000000000000000000000000000000000000;;	//		Log events at or above this severity are logged to standard
0000000000000000000000000000000000000000;;	//		error as well as to files.
0000000000000000000000000000000000000000;;	//	-log_dir=""
0000000000000000000000000000000000000000;;	//		Log files will be written to this directory instead of the
0000000000000000000000000000000000000000;;	//		default temporary directory.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	Other flags provide aids to debugging.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	-log_backtrace_at=""
0000000000000000000000000000000000000000;;	//		When set to a file and line number holding a logging statement,
0000000000000000000000000000000000000000;;	//		such as
0000000000000000000000000000000000000000;;	//			-log_backtrace_at=gopherflakes.go:234
0000000000000000000000000000000000000000;;	//		a stack trace will be written to the Info log whenever execution
0000000000000000000000000000000000000000;;	//		hits that statement. (Unlike with -vmodule, the ".go" must be
0000000000000000000000000000000000000000;;	//		present.)
0000000000000000000000000000000000000000;;	//	-v=0
0000000000000000000000000000000000000000;;	//		Enable V-leveled logging at the specified level.
0000000000000000000000000000000000000000;;	//	-vmodule=""
0000000000000000000000000000000000000000;;	//		The syntax of the argument is a comma-separated list of pattern=N,
0000000000000000000000000000000000000000;;	//		where pattern is a literal file name (minus the ".go" suffix) or
0000000000000000000000000000000000000000;;	//		"glob" pattern and N is a V level. For instance,
0000000000000000000000000000000000000000;;	//			-vmodule=gopher*=3
0000000000000000000000000000000000000000;;	//		sets the V level to 3 in all Go files whose names begin "gopher".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package glog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		stdLog "log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// severity identifies the sort of log: info, warning etc. It also implements
0000000000000000000000000000000000000000;;	// the flag.Value interface. The -stderrthreshold flag is of type severity and
0000000000000000000000000000000000000000;;	// should be modified only through the flag.Value interface. The values match
0000000000000000000000000000000000000000;;	// the corresponding constants in C++.
0000000000000000000000000000000000000000;;	type severity int32 // sync/atomic int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These constants identify the log levels in order of increasing severity.
0000000000000000000000000000000000000000;;	// A message written to a high-severity log file is also written to each
0000000000000000000000000000000000000000;;	// lower-severity log file.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		infoLog severity = iota
0000000000000000000000000000000000000000;;		warningLog
0000000000000000000000000000000000000000;;		errorLog
0000000000000000000000000000000000000000;;		fatalLog
0000000000000000000000000000000000000000;;		numSeverity = 4
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const severityChar = "IWEF"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var severityName = []string{
0000000000000000000000000000000000000000;;		infoLog:    "INFO",
0000000000000000000000000000000000000000;;		warningLog: "WARNING",
0000000000000000000000000000000000000000;;		errorLog:   "ERROR",
0000000000000000000000000000000000000000;;		fatalLog:   "FATAL",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get returns the value of the severity.
0000000000000000000000000000000000000000;;	func (s *severity) get() severity {
0000000000000000000000000000000000000000;;		return severity(atomic.LoadInt32((*int32)(s)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// set sets the value of the severity.
0000000000000000000000000000000000000000;;	func (s *severity) set(val severity) {
0000000000000000000000000000000000000000;;		atomic.StoreInt32((*int32)(s), int32(val))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String is part of the flag.Value interface.
0000000000000000000000000000000000000000;;	func (s *severity) String() string {
0000000000000000000000000000000000000000;;		return strconv.FormatInt(int64(*s), 10)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get is part of the flag.Value interface.
0000000000000000000000000000000000000000;;	func (s *severity) Get() interface{} {
0000000000000000000000000000000000000000;;		return *s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set is part of the flag.Value interface.
0000000000000000000000000000000000000000;;	func (s *severity) Set(value string) error {
0000000000000000000000000000000000000000;;		var threshold severity
0000000000000000000000000000000000000000;;		// Is it a known name?
0000000000000000000000000000000000000000;;		if v, ok := severityByName(value); ok {
0000000000000000000000000000000000000000;;			threshold = v
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			v, err := strconv.Atoi(value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			threshold = severity(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logging.stderrThreshold.set(threshold)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func severityByName(s string) (severity, bool) {
0000000000000000000000000000000000000000;;		s = strings.ToUpper(s)
0000000000000000000000000000000000000000;;		for i, name := range severityName {
0000000000000000000000000000000000000000;;			if name == s {
0000000000000000000000000000000000000000;;				return severity(i), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OutputStats tracks the number of output lines and bytes written.
0000000000000000000000000000000000000000;;	type OutputStats struct {
0000000000000000000000000000000000000000;;		lines int64
0000000000000000000000000000000000000000;;		bytes int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lines returns the number of lines written.
0000000000000000000000000000000000000000;;	func (s *OutputStats) Lines() int64 {
0000000000000000000000000000000000000000;;		return atomic.LoadInt64(&s.lines)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns the number of bytes written.
0000000000000000000000000000000000000000;;	func (s *OutputStats) Bytes() int64 {
0000000000000000000000000000000000000000;;		return atomic.LoadInt64(&s.bytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stats tracks the number of lines of output and number of bytes
0000000000000000000000000000000000000000;;	// per severity level. Values must be read with atomic.LoadInt64.
0000000000000000000000000000000000000000;;	var Stats struct {
0000000000000000000000000000000000000000;;		Info, Warning, Error OutputStats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var severityStats = [numSeverity]*OutputStats{
0000000000000000000000000000000000000000;;		infoLog:    &Stats.Info,
0000000000000000000000000000000000000000;;		warningLog: &Stats.Warning,
0000000000000000000000000000000000000000;;		errorLog:   &Stats.Error,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Level is exported because it appears in the arguments to V and is
0000000000000000000000000000000000000000;;	// the type of the v flag, which can be set programmatically.
0000000000000000000000000000000000000000;;	// It's a distinct type because we want to discriminate it from logType.
0000000000000000000000000000000000000000;;	// Variables of type level are only changed under logging.mu.
0000000000000000000000000000000000000000;;	// The -v flag is read only with atomic ops, so the state of the logging
0000000000000000000000000000000000000000;;	// module is consistent.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Level is treated as a sync/atomic int32.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Level specifies a level of verbosity for V logs. *Level implements
0000000000000000000000000000000000000000;;	// flag.Value; the -v flag is of type Level and should be modified
0000000000000000000000000000000000000000;;	// only through the flag.Value interface.
0000000000000000000000000000000000000000;;	type Level int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get returns the value of the Level.
0000000000000000000000000000000000000000;;	func (l *Level) get() Level {
0000000000000000000000000000000000000000;;		return Level(atomic.LoadInt32((*int32)(l)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// set sets the value of the Level.
0000000000000000000000000000000000000000;;	func (l *Level) set(val Level) {
0000000000000000000000000000000000000000;;		atomic.StoreInt32((*int32)(l), int32(val))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String is part of the flag.Value interface.
0000000000000000000000000000000000000000;;	func (l *Level) String() string {
0000000000000000000000000000000000000000;;		return strconv.FormatInt(int64(*l), 10)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get is part of the flag.Value interface.
0000000000000000000000000000000000000000;;	func (l *Level) Get() interface{} {
0000000000000000000000000000000000000000;;		return *l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set is part of the flag.Value interface.
0000000000000000000000000000000000000000;;	func (l *Level) Set(value string) error {
0000000000000000000000000000000000000000;;		v, err := strconv.Atoi(value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logging.mu.Lock()
0000000000000000000000000000000000000000;;		defer logging.mu.Unlock()
0000000000000000000000000000000000000000;;		logging.setVState(Level(v), logging.vmodule.filter, false)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// moduleSpec represents the setting of the -vmodule flag.
0000000000000000000000000000000000000000;;	type moduleSpec struct {
0000000000000000000000000000000000000000;;		filter []modulePat
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modulePat contains a filter for the -vmodule flag.
0000000000000000000000000000000000000000;;	// It holds a verbosity level and a file pattern to match.
0000000000000000000000000000000000000000;;	type modulePat struct {
0000000000000000000000000000000000000000;;		pattern string
0000000000000000000000000000000000000000;;		literal bool // The pattern is a literal string
0000000000000000000000000000000000000000;;		level   Level
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match reports whether the file matches the pattern. It uses a string
0000000000000000000000000000000000000000;;	// comparison if the pattern contains no metacharacters.
0000000000000000000000000000000000000000;;	func (m *modulePat) match(file string) bool {
0000000000000000000000000000000000000000;;		if m.literal {
0000000000000000000000000000000000000000;;			return file == m.pattern
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		match, _ := filepath.Match(m.pattern, file)
0000000000000000000000000000000000000000;;		return match
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *moduleSpec) String() string {
0000000000000000000000000000000000000000;;		// Lock because the type is not atomic. TODO: clean this up.
0000000000000000000000000000000000000000;;		logging.mu.Lock()
0000000000000000000000000000000000000000;;		defer logging.mu.Unlock()
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		for i, f := range m.filter {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				b.WriteRune(',')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(&b, "%s=%d", f.pattern, f.level)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get is part of the (Go 1.2)  flag.Getter interface. It always returns nil for this flag type since the
0000000000000000000000000000000000000000;;	// struct is not exported.
0000000000000000000000000000000000000000;;	func (m *moduleSpec) Get() interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errVmoduleSyntax = errors.New("syntax error: expect comma-separated list of filename=N")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Syntax: -vmodule=recordio=2,file=1,gfs*=3
0000000000000000000000000000000000000000;;	func (m *moduleSpec) Set(value string) error {
0000000000000000000000000000000000000000;;		var filter []modulePat
0000000000000000000000000000000000000000;;		for _, pat := range strings.Split(value, ",") {
0000000000000000000000000000000000000000;;			if len(pat) == 0 {
0000000000000000000000000000000000000000;;				// Empty strings such as from a trailing comma can be ignored.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patLev := strings.Split(pat, "=")
0000000000000000000000000000000000000000;;			if len(patLev) != 2 || len(patLev[0]) == 0 || len(patLev[1]) == 0 {
0000000000000000000000000000000000000000;;				return errVmoduleSyntax
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pattern := patLev[0]
0000000000000000000000000000000000000000;;			v, err := strconv.Atoi(patLev[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return errors.New("syntax error: expect comma-separated list of filename=N")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v < 0 {
0000000000000000000000000000000000000000;;				return errors.New("negative value for vmodule level")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v == 0 {
0000000000000000000000000000000000000000;;				continue // Ignore. It's harmless but no point in paying the overhead.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: check syntax of filter?
0000000000000000000000000000000000000000;;			filter = append(filter, modulePat{pattern, isLiteral(pattern), Level(v)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logging.mu.Lock()
0000000000000000000000000000000000000000;;		defer logging.mu.Unlock()
0000000000000000000000000000000000000000;;		logging.setVState(logging.verbosity, filter, true)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isLiteral reports whether the pattern is a literal string, that is, has no metacharacters
0000000000000000000000000000000000000000;;	// that require filepath.Match to be called to match the pattern.
0000000000000000000000000000000000000000;;	func isLiteral(pattern string) bool {
0000000000000000000000000000000000000000;;		return !strings.ContainsAny(pattern, `\*?[]`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// traceLocation represents the setting of the -log_backtrace_at flag.
0000000000000000000000000000000000000000;;	type traceLocation struct {
0000000000000000000000000000000000000000;;		file string
0000000000000000000000000000000000000000;;		line int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSet reports whether the trace location has been specified.
0000000000000000000000000000000000000000;;	// logging.mu is held.
0000000000000000000000000000000000000000;;	func (t *traceLocation) isSet() bool {
0000000000000000000000000000000000000000;;		return t.line > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match reports whether the specified file and line matches the trace location.
0000000000000000000000000000000000000000;;	// The argument file name is the full path, not the basename specified in the flag.
0000000000000000000000000000000000000000;;	// logging.mu is held.
0000000000000000000000000000000000000000;;	func (t *traceLocation) match(file string, line int) bool {
0000000000000000000000000000000000000000;;		if t.line != line {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i := strings.LastIndex(file, "/"); i >= 0 {
0000000000000000000000000000000000000000;;			file = file[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.file == file
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *traceLocation) String() string {
0000000000000000000000000000000000000000;;		// Lock because the type is not atomic. TODO: clean this up.
0000000000000000000000000000000000000000;;		logging.mu.Lock()
0000000000000000000000000000000000000000;;		defer logging.mu.Unlock()
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s:%d", t.file, t.line)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get is part of the (Go 1.2) flag.Getter interface. It always returns nil for this flag type since the
0000000000000000000000000000000000000000;;	// struct is not exported
0000000000000000000000000000000000000000;;	func (t *traceLocation) Get() interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errTraceSyntax = errors.New("syntax error: expect file.go:234")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Syntax: -log_backtrace_at=gopherflakes.go:234
0000000000000000000000000000000000000000;;	// Note that unlike vmodule the file extension is included here.
0000000000000000000000000000000000000000;;	func (t *traceLocation) Set(value string) error {
0000000000000000000000000000000000000000;;		if value == "" {
0000000000000000000000000000000000000000;;			// Unset.
0000000000000000000000000000000000000000;;			t.line = 0
0000000000000000000000000000000000000000;;			t.file = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields := strings.Split(value, ":")
0000000000000000000000000000000000000000;;		if len(fields) != 2 {
0000000000000000000000000000000000000000;;			return errTraceSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		file, line := fields[0], fields[1]
0000000000000000000000000000000000000000;;		if !strings.Contains(file, ".") {
0000000000000000000000000000000000000000;;			return errTraceSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := strconv.Atoi(line)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return errTraceSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v <= 0 {
0000000000000000000000000000000000000000;;			return errors.New("negative or zero value for level")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logging.mu.Lock()
0000000000000000000000000000000000000000;;		defer logging.mu.Unlock()
0000000000000000000000000000000000000000;;		t.line = v
0000000000000000000000000000000000000000;;		t.file = file
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flushSyncWriter is the interface satisfied by logging destinations.
0000000000000000000000000000000000000000;;	type flushSyncWriter interface {
0000000000000000000000000000000000000000;;		Flush() error
0000000000000000000000000000000000000000;;		Sync() error
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		flag.BoolVar(&logging.toStderr, "logtostderr", false, "log to standard error instead of files")
0000000000000000000000000000000000000000;;		flag.BoolVar(&logging.alsoToStderr, "alsologtostderr", false, "log to standard error as well as files")
0000000000000000000000000000000000000000;;		flag.Var(&logging.verbosity, "v", "log level for V logs")
0000000000000000000000000000000000000000;;		flag.Var(&logging.stderrThreshold, "stderrthreshold", "logs at or above this threshold go to stderr")
0000000000000000000000000000000000000000;;		flag.Var(&logging.vmodule, "vmodule", "comma-separated list of pattern=N settings for file-filtered logging")
0000000000000000000000000000000000000000;;		flag.Var(&logging.traceLocation, "log_backtrace_at", "when logging hits line file:N, emit a stack trace")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default stderrThreshold is ERROR.
0000000000000000000000000000000000000000;;		logging.stderrThreshold = errorLog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logging.setVState(0, nil, false)
0000000000000000000000000000000000000000;;		go logging.flushDaemon()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flush flushes all pending log I/O.
0000000000000000000000000000000000000000;;	func Flush() {
0000000000000000000000000000000000000000;;		logging.lockAndFlushAll()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loggingT collects all the global state of the logging setup.
0000000000000000000000000000000000000000;;	type loggingT struct {
0000000000000000000000000000000000000000;;		// Boolean flags. Not handled atomically because the flag.Value interface
0000000000000000000000000000000000000000;;		// does not let us avoid the =true, and that shorthand is necessary for
0000000000000000000000000000000000000000;;		// compatibility. TODO: does this matter enough to fix? Seems unlikely.
0000000000000000000000000000000000000000;;		toStderr     bool // The -logtostderr flag.
0000000000000000000000000000000000000000;;		alsoToStderr bool // The -alsologtostderr flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Level flag. Handled atomically.
0000000000000000000000000000000000000000;;		stderrThreshold severity // The -stderrthreshold flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// freeList is a list of byte buffers, maintained under freeListMu.
0000000000000000000000000000000000000000;;		freeList *buffer
0000000000000000000000000000000000000000;;		// freeListMu maintains the free list. It is separate from the main mutex
0000000000000000000000000000000000000000;;		// so buffers can be grabbed and printed to without holding the main lock,
0000000000000000000000000000000000000000;;		// for better parallelization.
0000000000000000000000000000000000000000;;		freeListMu sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects the remaining elements of this structure and is
0000000000000000000000000000000000000000;;		// used to synchronize logging.
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		// file holds writer for each of the log types.
0000000000000000000000000000000000000000;;		file [numSeverity]flushSyncWriter
0000000000000000000000000000000000000000;;		// pcs is used in V to avoid an allocation when computing the caller's PC.
0000000000000000000000000000000000000000;;		pcs [1]uintptr
0000000000000000000000000000000000000000;;		// vmap is a cache of the V Level for each V() call site, identified by PC.
0000000000000000000000000000000000000000;;		// It is wiped whenever the vmodule flag changes state.
0000000000000000000000000000000000000000;;		vmap map[uintptr]Level
0000000000000000000000000000000000000000;;		// filterLength stores the length of the vmodule filter chain. If greater
0000000000000000000000000000000000000000;;		// than zero, it means vmodule is enabled. It may be read safely
0000000000000000000000000000000000000000;;		// using sync.LoadInt32, but is only modified under mu.
0000000000000000000000000000000000000000;;		filterLength int32
0000000000000000000000000000000000000000;;		// traceLocation is the state of the -log_backtrace_at flag.
0000000000000000000000000000000000000000;;		traceLocation traceLocation
0000000000000000000000000000000000000000;;		// These flags are modified only under lock, although verbosity may be fetched
0000000000000000000000000000000000000000;;		// safely using atomic.LoadInt32.
0000000000000000000000000000000000000000;;		vmodule   moduleSpec // The state of the -vmodule flag.
0000000000000000000000000000000000000000;;		verbosity Level      // V logging level, the value of the -v flag/
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buffer holds a byte Buffer for reuse. The zero value is ready for use.
0000000000000000000000000000000000000000;;	type buffer struct {
0000000000000000000000000000000000000000;;		bytes.Buffer
0000000000000000000000000000000000000000;;		tmp  [64]byte // temporary byte array for creating headers.
0000000000000000000000000000000000000000;;		next *buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var logging loggingT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setVState sets a consistent state for V logging.
0000000000000000000000000000000000000000;;	// l.mu is held.
0000000000000000000000000000000000000000;;	func (l *loggingT) setVState(verbosity Level, filter []modulePat, setFilter bool) {
0000000000000000000000000000000000000000;;		// Turn verbosity off so V will not fire while we are in transition.
0000000000000000000000000000000000000000;;		logging.verbosity.set(0)
0000000000000000000000000000000000000000;;		// Ditto for filter length.
0000000000000000000000000000000000000000;;		atomic.StoreInt32(&logging.filterLength, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the new filters and wipe the pc->Level map if the filter has changed.
0000000000000000000000000000000000000000;;		if setFilter {
0000000000000000000000000000000000000000;;			logging.vmodule.filter = filter
0000000000000000000000000000000000000000;;			logging.vmap = make(map[uintptr]Level)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Things are consistent now, so enable filtering and verbosity.
0000000000000000000000000000000000000000;;		// They are enabled in order opposite to that in V.
0000000000000000000000000000000000000000;;		atomic.StoreInt32(&logging.filterLength, int32(len(filter)))
0000000000000000000000000000000000000000;;		logging.verbosity.set(verbosity)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getBuffer returns a new, ready-to-use buffer.
0000000000000000000000000000000000000000;;	func (l *loggingT) getBuffer() *buffer {
0000000000000000000000000000000000000000;;		l.freeListMu.Lock()
0000000000000000000000000000000000000000;;		b := l.freeList
0000000000000000000000000000000000000000;;		if b != nil {
0000000000000000000000000000000000000000;;			l.freeList = b.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.freeListMu.Unlock()
0000000000000000000000000000000000000000;;		if b == nil {
0000000000000000000000000000000000000000;;			b = new(buffer)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			b.next = nil
0000000000000000000000000000000000000000;;			b.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// putBuffer returns a buffer to the free list.
0000000000000000000000000000000000000000;;	func (l *loggingT) putBuffer(b *buffer) {
0000000000000000000000000000000000000000;;		if b.Len() >= 256 {
0000000000000000000000000000000000000000;;			// Let big buffers die a natural death.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.freeListMu.Lock()
0000000000000000000000000000000000000000;;		b.next = l.freeList
0000000000000000000000000000000000000000;;		l.freeList = b
0000000000000000000000000000000000000000;;		l.freeListMu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var timeNow = time.Now // Stubbed out for testing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	header formats a log header as defined by the C++ implementation.
0000000000000000000000000000000000000000;;	It returns a buffer containing the formatted header and the user's file and line number.
0000000000000000000000000000000000000000;;	The depth specifies how many stack frames above lives the source line to be identified in the log message.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Log lines have this form:
0000000000000000000000000000000000000000;;		Lmmdd hh:mm:ss.uuuuuu threadid file:line] msg...
0000000000000000000000000000000000000000;;	where the fields are defined as follows:
0000000000000000000000000000000000000000;;		L                A single character, representing the log level (eg 'I' for INFO)
0000000000000000000000000000000000000000;;		mm               The month (zero padded; ie May is '05')
0000000000000000000000000000000000000000;;		dd               The day (zero padded)
0000000000000000000000000000000000000000;;		hh:mm:ss.uuuuuu  Time in hours, minutes and fractional seconds
0000000000000000000000000000000000000000;;		threadid         The space-padded thread ID as returned by GetTID()
0000000000000000000000000000000000000000;;		file             The file name
0000000000000000000000000000000000000000;;		line             The line number
0000000000000000000000000000000000000000;;		msg              The user-supplied message
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (l *loggingT) header(s severity, depth int) (*buffer, string, int) {
0000000000000000000000000000000000000000;;		_, file, line, ok := runtime.Caller(3 + depth)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			file = "???"
0000000000000000000000000000000000000000;;			line = 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			slash := strings.LastIndex(file, "/")
0000000000000000000000000000000000000000;;			if slash >= 0 {
0000000000000000000000000000000000000000;;				file = file[slash+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.formatHeader(s, file, line), file, line
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatHeader formats a log header using the provided file name and line number.
0000000000000000000000000000000000000000;;	func (l *loggingT) formatHeader(s severity, file string, line int) *buffer {
0000000000000000000000000000000000000000;;		now := timeNow()
0000000000000000000000000000000000000000;;		if line < 0 {
0000000000000000000000000000000000000000;;			line = 0 // not a real line number, but acceptable to someDigits
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s > fatalLog {
0000000000000000000000000000000000000000;;			s = infoLog // for safety.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := l.getBuffer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Avoid Fprintf, for speed. The format is so simple that we can do it quickly by hand.
0000000000000000000000000000000000000000;;		// It's worth about 3X. Fprintf is hard.
0000000000000000000000000000000000000000;;		_, month, day := now.Date()
0000000000000000000000000000000000000000;;		hour, minute, second := now.Clock()
0000000000000000000000000000000000000000;;		// Lmmdd hh:mm:ss.uuuuuu threadid file:line]
0000000000000000000000000000000000000000;;		buf.tmp[0] = severityChar[s]
0000000000000000000000000000000000000000;;		buf.twoDigits(1, int(month))
0000000000000000000000000000000000000000;;		buf.twoDigits(3, day)
0000000000000000000000000000000000000000;;		buf.tmp[5] = ' '
0000000000000000000000000000000000000000;;		buf.twoDigits(6, hour)
0000000000000000000000000000000000000000;;		buf.tmp[8] = ':'
0000000000000000000000000000000000000000;;		buf.twoDigits(9, minute)
0000000000000000000000000000000000000000;;		buf.tmp[11] = ':'
0000000000000000000000000000000000000000;;		buf.twoDigits(12, second)
0000000000000000000000000000000000000000;;		buf.tmp[14] = '.'
0000000000000000000000000000000000000000;;		buf.nDigits(6, 15, now.Nanosecond()/1000, '0')
0000000000000000000000000000000000000000;;		buf.tmp[21] = ' '
0000000000000000000000000000000000000000;;		buf.nDigits(7, 22, pid, ' ') // TODO: should be TID
0000000000000000000000000000000000000000;;		buf.tmp[29] = ' '
0000000000000000000000000000000000000000;;		buf.Write(buf.tmp[:30])
0000000000000000000000000000000000000000;;		buf.WriteString(file)
0000000000000000000000000000000000000000;;		buf.tmp[0] = ':'
0000000000000000000000000000000000000000;;		n := buf.someDigits(1, line)
0000000000000000000000000000000000000000;;		buf.tmp[n+1] = ']'
0000000000000000000000000000000000000000;;		buf.tmp[n+2] = ' '
0000000000000000000000000000000000000000;;		buf.Write(buf.tmp[:n+3])
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Some custom tiny helper functions to print the log header efficiently.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const digits = "0123456789"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// twoDigits formats a zero-prefixed two-digit integer at buf.tmp[i].
0000000000000000000000000000000000000000;;	func (buf *buffer) twoDigits(i, d int) {
0000000000000000000000000000000000000000;;		buf.tmp[i+1] = digits[d%10]
0000000000000000000000000000000000000000;;		d /= 10
0000000000000000000000000000000000000000;;		buf.tmp[i] = digits[d%10]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nDigits formats an n-digit integer at buf.tmp[i],
0000000000000000000000000000000000000000;;	// padding with pad on the left.
0000000000000000000000000000000000000000;;	// It assumes d >= 0.
0000000000000000000000000000000000000000;;	func (buf *buffer) nDigits(n, i, d int, pad byte) {
0000000000000000000000000000000000000000;;		j := n - 1
0000000000000000000000000000000000000000;;		for ; j >= 0 && d > 0; j-- {
0000000000000000000000000000000000000000;;			buf.tmp[i+j] = digits[d%10]
0000000000000000000000000000000000000000;;			d /= 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ; j >= 0; j-- {
0000000000000000000000000000000000000000;;			buf.tmp[i+j] = pad
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// someDigits formats a zero-prefixed variable-width integer at buf.tmp[i].
0000000000000000000000000000000000000000;;	func (buf *buffer) someDigits(i, d int) int {
0000000000000000000000000000000000000000;;		// Print into the top, then copy down. We know there's space for at least
0000000000000000000000000000000000000000;;		// a 10-digit number.
0000000000000000000000000000000000000000;;		j := len(buf.tmp)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			j--
0000000000000000000000000000000000000000;;			buf.tmp[j] = digits[d%10]
0000000000000000000000000000000000000000;;			d /= 10
0000000000000000000000000000000000000000;;			if d == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copy(buf.tmp[i:], buf.tmp[j:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loggingT) println(s severity, args ...interface{}) {
0000000000000000000000000000000000000000;;		buf, file, line := l.header(s, 0)
0000000000000000000000000000000000000000;;		fmt.Fprintln(buf, args...)
0000000000000000000000000000000000000000;;		l.output(s, buf, file, line, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loggingT) print(s severity, args ...interface{}) {
0000000000000000000000000000000000000000;;		l.printDepth(s, 1, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loggingT) printDepth(s severity, depth int, args ...interface{}) {
0000000000000000000000000000000000000000;;		buf, file, line := l.header(s, depth)
0000000000000000000000000000000000000000;;		fmt.Fprint(buf, args...)
0000000000000000000000000000000000000000;;		if buf.Bytes()[buf.Len()-1] != '\n' {
0000000000000000000000000000000000000000;;			buf.WriteByte('\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.output(s, buf, file, line, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loggingT) printf(s severity, format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		buf, file, line := l.header(s, 0)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, format, args...)
0000000000000000000000000000000000000000;;		if buf.Bytes()[buf.Len()-1] != '\n' {
0000000000000000000000000000000000000000;;			buf.WriteByte('\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.output(s, buf, file, line, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printWithFileLine behaves like print but uses the provided file and line number.  If
0000000000000000000000000000000000000000;;	// alsoLogToStderr is true, the log message always appears on standard error; it
0000000000000000000000000000000000000000;;	// will also appear in the log file unless --logtostderr is set.
0000000000000000000000000000000000000000;;	func (l *loggingT) printWithFileLine(s severity, file string, line int, alsoToStderr bool, args ...interface{}) {
0000000000000000000000000000000000000000;;		buf := l.formatHeader(s, file, line)
0000000000000000000000000000000000000000;;		fmt.Fprint(buf, args...)
0000000000000000000000000000000000000000;;		if buf.Bytes()[buf.Len()-1] != '\n' {
0000000000000000000000000000000000000000;;			buf.WriteByte('\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.output(s, buf, file, line, alsoToStderr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// output writes the data to the log files and releases the buffer.
0000000000000000000000000000000000000000;;	func (l *loggingT) output(s severity, buf *buffer, file string, line int, alsoToStderr bool) {
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		if l.traceLocation.isSet() {
0000000000000000000000000000000000000000;;			if l.traceLocation.match(file, line) {
0000000000000000000000000000000000000000;;				buf.Write(stacks(false))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := buf.Bytes()
0000000000000000000000000000000000000000;;		if l.toStderr {
0000000000000000000000000000000000000000;;			os.Stderr.Write(data)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if alsoToStderr || l.alsoToStderr || s >= l.stderrThreshold.get() {
0000000000000000000000000000000000000000;;				os.Stderr.Write(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if l.file[s] == nil {
0000000000000000000000000000000000000000;;				if err := l.createFiles(s); err != nil {
0000000000000000000000000000000000000000;;					os.Stderr.Write(data) // Make sure the message appears somewhere.
0000000000000000000000000000000000000000;;					l.exit(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch s {
0000000000000000000000000000000000000000;;			case fatalLog:
0000000000000000000000000000000000000000;;				l.file[fatalLog].Write(data)
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case errorLog:
0000000000000000000000000000000000000000;;				l.file[errorLog].Write(data)
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case warningLog:
0000000000000000000000000000000000000000;;				l.file[warningLog].Write(data)
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case infoLog:
0000000000000000000000000000000000000000;;				l.file[infoLog].Write(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == fatalLog {
0000000000000000000000000000000000000000;;			// If we got here via Exit rather than Fatal, print no stacks.
0000000000000000000000000000000000000000;;			if atomic.LoadUint32(&fatalNoStacks) > 0 {
0000000000000000000000000000000000000000;;				l.mu.Unlock()
0000000000000000000000000000000000000000;;				timeoutFlush(10 * time.Second)
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Dump all goroutine stacks before exiting.
0000000000000000000000000000000000000000;;			// First, make sure we see the trace for the current goroutine on standard error.
0000000000000000000000000000000000000000;;			// If -logtostderr has been specified, the loop below will do that anyway
0000000000000000000000000000000000000000;;			// as the first stack in the full dump.
0000000000000000000000000000000000000000;;			if !l.toStderr {
0000000000000000000000000000000000000000;;				os.Stderr.Write(stacks(false))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Write the stack trace for all goroutines to the files.
0000000000000000000000000000000000000000;;			trace := stacks(true)
0000000000000000000000000000000000000000;;			logExitFunc = func(error) {} // If we get a write error, we'll still exit below.
0000000000000000000000000000000000000000;;			for log := fatalLog; log >= infoLog; log-- {
0000000000000000000000000000000000000000;;				if f := l.file[log]; f != nil { // Can be nil if -logtostderr is set.
0000000000000000000000000000000000000000;;					f.Write(trace)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.mu.Unlock()
0000000000000000000000000000000000000000;;			timeoutFlush(10 * time.Second)
0000000000000000000000000000000000000000;;			os.Exit(255) // C++ uses -1, which is silly because it's anded with 255 anyway.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.putBuffer(buf)
0000000000000000000000000000000000000000;;		l.mu.Unlock()
0000000000000000000000000000000000000000;;		if stats := severityStats[s]; stats != nil {
0000000000000000000000000000000000000000;;			atomic.AddInt64(&stats.lines, 1)
0000000000000000000000000000000000000000;;			atomic.AddInt64(&stats.bytes, int64(len(data)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timeoutFlush calls Flush and returns when it completes or after timeout
0000000000000000000000000000000000000000;;	// elapses, whichever happens first.  This is needed because the hooks invoked
0000000000000000000000000000000000000000;;	// by Flush may deadlock when glog.Fatal is called from a hook that holds
0000000000000000000000000000000000000000;;	// a lock.
0000000000000000000000000000000000000000;;	func timeoutFlush(timeout time.Duration) {
0000000000000000000000000000000000000000;;		done := make(chan bool, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			Flush() // calls logging.lockAndFlushAll()
0000000000000000000000000000000000000000;;			done <- true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;		case <-time.After(timeout):
0000000000000000000000000000000000000000;;			fmt.Fprintln(os.Stderr, "glog: Flush took longer than", timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stacks is a wrapper for runtime.Stack that attempts to recover the data for all goroutines.
0000000000000000000000000000000000000000;;	func stacks(all bool) []byte {
0000000000000000000000000000000000000000;;		// We don't know how big the traces are, so grow a few times if they don't fit. Start large, though.
0000000000000000000000000000000000000000;;		n := 10000
0000000000000000000000000000000000000000;;		if all {
0000000000000000000000000000000000000000;;			n = 100000
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var trace []byte
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			trace = make([]byte, n)
0000000000000000000000000000000000000000;;			nbytes := runtime.Stack(trace, all)
0000000000000000000000000000000000000000;;			if nbytes < len(trace) {
0000000000000000000000000000000000000000;;				return trace[:nbytes]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n *= 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return trace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logExitFunc provides a simple mechanism to override the default behavior
0000000000000000000000000000000000000000;;	// of exiting on error. Used in testing and to guarantee we reach a required exit
0000000000000000000000000000000000000000;;	// for fatal logs. Instead, exit could be a function rather than a method but that
0000000000000000000000000000000000000000;;	// would make its use clumsier.
0000000000000000000000000000000000000000;;	var logExitFunc func(error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exit is called if there is trouble creating or writing log files.
0000000000000000000000000000000000000000;;	// It flushes the logs and exits the program; there's no point in hanging around.
0000000000000000000000000000000000000000;;	// l.mu is held.
0000000000000000000000000000000000000000;;	func (l *loggingT) exit(err error) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "log: exiting because of error: %s\n", err)
0000000000000000000000000000000000000000;;		// If logExitFunc is set, we do that instead of exiting.
0000000000000000000000000000000000000000;;		if logExitFunc != nil {
0000000000000000000000000000000000000000;;			logExitFunc(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.flushAll()
0000000000000000000000000000000000000000;;		os.Exit(2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncBuffer joins a bufio.Writer to its underlying file, providing access to the
0000000000000000000000000000000000000000;;	// file's Sync method and providing a wrapper for the Write method that provides log
0000000000000000000000000000000000000000;;	// file rotation. There are conflicting methods, so the file cannot be embedded.
0000000000000000000000000000000000000000;;	// l.mu is held for all its methods.
0000000000000000000000000000000000000000;;	type syncBuffer struct {
0000000000000000000000000000000000000000;;		logger *loggingT
0000000000000000000000000000000000000000;;		*bufio.Writer
0000000000000000000000000000000000000000;;		file   *os.File
0000000000000000000000000000000000000000;;		sev    severity
0000000000000000000000000000000000000000;;		nbytes uint64 // The number of bytes written to this file
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sb *syncBuffer) Sync() error {
0000000000000000000000000000000000000000;;		return sb.file.Sync()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sb *syncBuffer) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if sb.nbytes+uint64(len(p)) >= MaxSize {
0000000000000000000000000000000000000000;;			if err := sb.rotateFile(time.Now()); err != nil {
0000000000000000000000000000000000000000;;				sb.logger.exit(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = sb.Writer.Write(p)
0000000000000000000000000000000000000000;;		sb.nbytes += uint64(n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			sb.logger.exit(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rotateFile closes the syncBuffer's file and starts a new one.
0000000000000000000000000000000000000000;;	func (sb *syncBuffer) rotateFile(now time.Time) error {
0000000000000000000000000000000000000000;;		if sb.file != nil {
0000000000000000000000000000000000000000;;			sb.Flush()
0000000000000000000000000000000000000000;;			sb.file.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		sb.file, _, err = create(severityName[sb.sev], now)
0000000000000000000000000000000000000000;;		sb.nbytes = 0
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sb.Writer = bufio.NewWriterSize(sb.file, bufferSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write header.
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "Log file created at: %s\n", now.Format("2006/01/02 15:04:05"))
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "Running on machine: %s\n", host)
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "Binary: Built with %s %s for %s/%s\n", runtime.Compiler, runtime.Version(), runtime.GOOS, runtime.GOARCH)
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg\n")
0000000000000000000000000000000000000000;;		n, err := sb.file.Write(buf.Bytes())
0000000000000000000000000000000000000000;;		sb.nbytes += uint64(n)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bufferSize sizes the buffer associated with each log file. It's large
0000000000000000000000000000000000000000;;	// so that log records can accumulate without the logging thread blocking
0000000000000000000000000000000000000000;;	// on disk I/O. The flushDaemon will block instead.
0000000000000000000000000000000000000000;;	const bufferSize = 256 * 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createFiles creates all the log files for severity from sev down to infoLog.
0000000000000000000000000000000000000000;;	// l.mu is held.
0000000000000000000000000000000000000000;;	func (l *loggingT) createFiles(sev severity) error {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		// Files are created in decreasing severity order, so as soon as we find one
0000000000000000000000000000000000000000;;		// has already been created, we can stop.
0000000000000000000000000000000000000000;;		for s := sev; s >= infoLog && l.file[s] == nil; s-- {
0000000000000000000000000000000000000000;;			sb := &syncBuffer{
0000000000000000000000000000000000000000;;				logger: l,
0000000000000000000000000000000000000000;;				sev:    s,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := sb.rotateFile(now); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.file[s] = sb
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const flushInterval = 30 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flushDaemon periodically flushes the log file buffers.
0000000000000000000000000000000000000000;;	func (l *loggingT) flushDaemon() {
0000000000000000000000000000000000000000;;		for _ = range time.NewTicker(flushInterval).C {
0000000000000000000000000000000000000000;;			l.lockAndFlushAll()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lockAndFlushAll is like flushAll but locks l.mu first.
0000000000000000000000000000000000000000;;	func (l *loggingT) lockAndFlushAll() {
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		l.flushAll()
0000000000000000000000000000000000000000;;		l.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flushAll flushes all the logs and attempts to "sync" their data to disk.
0000000000000000000000000000000000000000;;	// l.mu is held.
0000000000000000000000000000000000000000;;	func (l *loggingT) flushAll() {
0000000000000000000000000000000000000000;;		// Flush from fatal down, in case there's trouble flushing.
0000000000000000000000000000000000000000;;		for s := fatalLog; s >= infoLog; s-- {
0000000000000000000000000000000000000000;;			file := l.file[s]
0000000000000000000000000000000000000000;;			if file != nil {
0000000000000000000000000000000000000000;;				file.Flush() // ignore error
0000000000000000000000000000000000000000;;				file.Sync()  // ignore error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyStandardLogTo arranges for messages written to the Go "log" package's
0000000000000000000000000000000000000000;;	// default logs to also appear in the Google logs for the named and lower
0000000000000000000000000000000000000000;;	// severities.  Subsequent changes to the standard log's default output location
0000000000000000000000000000000000000000;;	// or format may break this behavior.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Valid names are "INFO", "WARNING", "ERROR", and "FATAL".  If the name is not
0000000000000000000000000000000000000000;;	// recognized, CopyStandardLogTo panics.
0000000000000000000000000000000000000000;;	func CopyStandardLogTo(name string) {
0000000000000000000000000000000000000000;;		sev, ok := severityByName(name)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("log.CopyStandardLogTo(%q): unrecognized severity name", name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set a log format that captures the user's file and line:
0000000000000000000000000000000000000000;;		//   d.go:23: message
0000000000000000000000000000000000000000;;		stdLog.SetFlags(stdLog.Lshortfile)
0000000000000000000000000000000000000000;;		stdLog.SetOutput(logBridge(sev))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logBridge provides the Write method that enables CopyStandardLogTo to connect
0000000000000000000000000000000000000000;;	// Go's standard logs to the logs provided by this package.
0000000000000000000000000000000000000000;;	type logBridge severity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write parses the standard logging line and passes its components to the
0000000000000000000000000000000000000000;;	// logger for severity(lb).
0000000000000000000000000000000000000000;;	func (lb logBridge) Write(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			file = "???"
0000000000000000000000000000000000000000;;			line = 1
0000000000000000000000000000000000000000;;			text string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// Split "d.go:23: message" into "d.go", "23", and "message".
0000000000000000000000000000000000000000;;		if parts := bytes.SplitN(b, []byte{':'}, 3); len(parts) != 3 || len(parts[0]) < 1 || len(parts[2]) < 1 {
0000000000000000000000000000000000000000;;			text = fmt.Sprintf("bad log format: %s", b)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			file = string(parts[0])
0000000000000000000000000000000000000000;;			text = string(parts[2][1:]) // skip leading space
0000000000000000000000000000000000000000;;			line, err = strconv.Atoi(string(parts[1]))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				text = fmt.Sprintf("bad line number: %s", b)
0000000000000000000000000000000000000000;;				line = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// printWithFileLine with alsoToStderr=true, so standard log messages
0000000000000000000000000000000000000000;;		// always appear on standard error.
0000000000000000000000000000000000000000;;		logging.printWithFileLine(severity(lb), file, line, true, text)
0000000000000000000000000000000000000000;;		return len(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setV computes and remembers the V level for a given PC
0000000000000000000000000000000000000000;;	// when vmodule is enabled.
0000000000000000000000000000000000000000;;	// File pattern matching takes the basename of the file, stripped
0000000000000000000000000000000000000000;;	// of its .go suffix, and uses filepath.Match, which is a little more
0000000000000000000000000000000000000000;;	// general than the *? matching used in C++.
0000000000000000000000000000000000000000;;	// l.mu is held.
0000000000000000000000000000000000000000;;	func (l *loggingT) setV(pc uintptr) Level {
0000000000000000000000000000000000000000;;		fn := runtime.FuncForPC(pc)
0000000000000000000000000000000000000000;;		file, _ := fn.FileLine(pc)
0000000000000000000000000000000000000000;;		// The file is something like /a/b/c/d.go. We want just the d.
0000000000000000000000000000000000000000;;		if strings.HasSuffix(file, ".go") {
0000000000000000000000000000000000000000;;			file = file[:len(file)-3]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if slash := strings.LastIndex(file, "/"); slash >= 0 {
0000000000000000000000000000000000000000;;			file = file[slash+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, filter := range l.vmodule.filter {
0000000000000000000000000000000000000000;;			if filter.match(file) {
0000000000000000000000000000000000000000;;				l.vmap[pc] = filter.level
0000000000000000000000000000000000000000;;				return filter.level
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.vmap[pc] = 0
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verbose is a boolean type that implements Infof (like Printf) etc.
0000000000000000000000000000000000000000;;	// See the documentation of V for more information.
0000000000000000000000000000000000000000;;	type Verbose bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// V reports whether verbosity at the call site is at least the requested level.
0000000000000000000000000000000000000000;;	// The returned value is a boolean of type Verbose, which implements Info, Infoln
0000000000000000000000000000000000000000;;	// and Infof. These methods will write to the Info log if called.
0000000000000000000000000000000000000000;;	// Thus, one may write either
0000000000000000000000000000000000000000;;	//	if glog.V(2) { glog.Info("log this") }
0000000000000000000000000000000000000000;;	// or
0000000000000000000000000000000000000000;;	//	glog.V(2).Info("log this")
0000000000000000000000000000000000000000;;	// The second form is shorter but the first is cheaper if logging is off because it does
0000000000000000000000000000000000000000;;	// not evaluate its arguments.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Whether an individual call to V generates a log record depends on the setting of
0000000000000000000000000000000000000000;;	// the -v and --vmodule flags; both are off by default. If the level in the call to
0000000000000000000000000000000000000000;;	// V is at least the value of -v, or of -vmodule for the source file containing the
0000000000000000000000000000000000000000;;	// call, the V call will log.
0000000000000000000000000000000000000000;;	func V(level Level) Verbose {
0000000000000000000000000000000000000000;;		// This function tries hard to be cheap unless there's work to do.
0000000000000000000000000000000000000000;;		// The fast path is two atomic loads and compares.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Here is a cheap but safe test to see if V logging is enabled globally.
0000000000000000000000000000000000000000;;		if logging.verbosity.get() >= level {
0000000000000000000000000000000000000000;;			return Verbose(true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It's off globally but it vmodule may still be set.
0000000000000000000000000000000000000000;;		// Here is another cheap but safe test to see if vmodule is enabled.
0000000000000000000000000000000000000000;;		if atomic.LoadInt32(&logging.filterLength) > 0 {
0000000000000000000000000000000000000000;;			// Now we need a proper lock to use the logging structure. The pcs field
0000000000000000000000000000000000000000;;			// is shared so we must lock before accessing it. This is fairly expensive,
0000000000000000000000000000000000000000;;			// but if V logging is enabled we're slow anyway.
0000000000000000000000000000000000000000;;			logging.mu.Lock()
0000000000000000000000000000000000000000;;			defer logging.mu.Unlock()
0000000000000000000000000000000000000000;;			if runtime.Callers(2, logging.pcs[:]) == 0 {
0000000000000000000000000000000000000000;;				return Verbose(false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v, ok := logging.vmap[logging.pcs[0]]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				v = logging.setV(logging.pcs[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Verbose(v >= level)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Verbose(false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Info is equivalent to the global Info function, guarded by the value of v.
0000000000000000000000000000000000000000;;	// See the documentation of V for usage.
0000000000000000000000000000000000000000;;	func (v Verbose) Info(args ...interface{}) {
0000000000000000000000000000000000000000;;		if v {
0000000000000000000000000000000000000000;;			logging.print(infoLog, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Infoln is equivalent to the global Infoln function, guarded by the value of v.
0000000000000000000000000000000000000000;;	// See the documentation of V for usage.
0000000000000000000000000000000000000000;;	func (v Verbose) Infoln(args ...interface{}) {
0000000000000000000000000000000000000000;;		if v {
0000000000000000000000000000000000000000;;			logging.println(infoLog, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Infof is equivalent to the global Infof function, guarded by the value of v.
0000000000000000000000000000000000000000;;	// See the documentation of V for usage.
0000000000000000000000000000000000000000;;	func (v Verbose) Infof(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if v {
0000000000000000000000000000000000000000;;			logging.printf(infoLog, format, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Info logs to the INFO log.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Info(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.print(infoLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InfoDepth acts as Info but uses depth to determine which call frame to log.
0000000000000000000000000000000000000000;;	// InfoDepth(0, "msg") is the same as Info("msg").
0000000000000000000000000000000000000000;;	func InfoDepth(depth int, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printDepth(infoLog, depth, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Infoln logs to the INFO log.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Infoln(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.println(infoLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Infof logs to the INFO log.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Infof(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printf(infoLog, format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Warning logs to the WARNING and INFO logs.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Warning(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.print(warningLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WarningDepth acts as Warning but uses depth to determine which call frame to log.
0000000000000000000000000000000000000000;;	// WarningDepth(0, "msg") is the same as Warning("msg").
0000000000000000000000000000000000000000;;	func WarningDepth(depth int, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printDepth(warningLog, depth, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Warningln logs to the WARNING and INFO logs.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Warningln(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.println(warningLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Warningf logs to the WARNING and INFO logs.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Warningf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printf(warningLog, format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error logs to the ERROR, WARNING, and INFO logs.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Error(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.print(errorLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorDepth acts as Error but uses depth to determine which call frame to log.
0000000000000000000000000000000000000000;;	// ErrorDepth(0, "msg") is the same as Error("msg").
0000000000000000000000000000000000000000;;	func ErrorDepth(depth int, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printDepth(errorLog, depth, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errorln logs to the ERROR, WARNING, and INFO logs.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Errorln(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.println(errorLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errorf logs to the ERROR, WARNING, and INFO logs.
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Errorf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printf(errorLog, format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fatal logs to the FATAL, ERROR, WARNING, and INFO logs,
0000000000000000000000000000000000000000;;	// including a stack trace of all running goroutines, then calls os.Exit(255).
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Fatal(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.print(fatalLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FatalDepth acts as Fatal but uses depth to determine which call frame to log.
0000000000000000000000000000000000000000;;	// FatalDepth(0, "msg") is the same as Fatal("msg").
0000000000000000000000000000000000000000;;	func FatalDepth(depth int, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printDepth(fatalLog, depth, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fatalln logs to the FATAL, ERROR, WARNING, and INFO logs,
0000000000000000000000000000000000000000;;	// including a stack trace of all running goroutines, then calls os.Exit(255).
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Fatalln(args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.println(fatalLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fatalf logs to the FATAL, ERROR, WARNING, and INFO logs,
0000000000000000000000000000000000000000;;	// including a stack trace of all running goroutines, then calls os.Exit(255).
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Fatalf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		logging.printf(fatalLog, format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fatalNoStacks is non-zero if we are to exit without dumping goroutine stacks.
0000000000000000000000000000000000000000;;	// It allows Exit and relatives to use the Fatal logs.
0000000000000000000000000000000000000000;;	var fatalNoStacks uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exit logs to the FATAL, ERROR, WARNING, and INFO logs, then calls os.Exit(1).
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Exit(args ...interface{}) {
0000000000000000000000000000000000000000;;		atomic.StoreUint32(&fatalNoStacks, 1)
0000000000000000000000000000000000000000;;		logging.print(fatalLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExitDepth acts as Exit but uses depth to determine which call frame to log.
0000000000000000000000000000000000000000;;	// ExitDepth(0, "msg") is the same as Exit("msg").
0000000000000000000000000000000000000000;;	func ExitDepth(depth int, args ...interface{}) {
0000000000000000000000000000000000000000;;		atomic.StoreUint32(&fatalNoStacks, 1)
0000000000000000000000000000000000000000;;		logging.printDepth(fatalLog, depth, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exitln logs to the FATAL, ERROR, WARNING, and INFO logs, then calls os.Exit(1).
0000000000000000000000000000000000000000;;	func Exitln(args ...interface{}) {
0000000000000000000000000000000000000000;;		atomic.StoreUint32(&fatalNoStacks, 1)
0000000000000000000000000000000000000000;;		logging.println(fatalLog, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exitf logs to the FATAL, ERROR, WARNING, and INFO logs, then calls os.Exit(1).
0000000000000000000000000000000000000000;;	// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.
0000000000000000000000000000000000000000;;	func Exitf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		atomic.StoreUint32(&fatalNoStacks, 1)
0000000000000000000000000000000000000000;;		logging.printf(fatalLog, format, args...)
0000000000000000000000000000000000000000;;	}
