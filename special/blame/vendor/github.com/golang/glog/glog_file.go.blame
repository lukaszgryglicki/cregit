0000000000000000000000000000000000000000;;	// Go support for leveled logs, analogous to https://code.google.com/p/google-glog/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2013 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b3faa8ca9b634f2668b82c3cc87176e792c846e2;third_party/src/github.com/golang/glog/glog_file.go[third_party/src/github.com/golang/glog/glog_file.go][vendor/github.com/golang/glog/glog_file.go];	
0000000000000000000000000000000000000000;;	// File I/O for logs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package glog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/user"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxSize is the maximum size of a log file in bytes.
0000000000000000000000000000000000000000;;	var MaxSize uint64 = 1024 * 1024 * 1800
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logDirs lists the candidate directories for new log files.
0000000000000000000000000000000000000000;;	var logDirs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If non-empty, overrides the choice of directory in which to write logs.
0000000000000000000000000000000000000000;;	// See createLogDirs for the full list of possible destinations.
0000000000000000000000000000000000000000;;	var logDir = flag.String("log_dir", "", "If non-empty, write log files in this directory")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createLogDirs() {
0000000000000000000000000000000000000000;;		if *logDir != "" {
0000000000000000000000000000000000000000;;			logDirs = append(logDirs, *logDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logDirs = append(logDirs, os.TempDir())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		pid      = os.Getpid()
0000000000000000000000000000000000000000;;		program  = filepath.Base(os.Args[0])
0000000000000000000000000000000000000000;;		host     = "unknownhost"
0000000000000000000000000000000000000000;;		userName = "unknownuser"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		h, err := os.Hostname()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			host = shortHostname(h)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		current, err := user.Current()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			userName = current.Username
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sanitize userName since it may contain filepath separators on Windows.
0000000000000000000000000000000000000000;;		userName = strings.Replace(userName, `\`, "_", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shortHostname returns its argument, truncating at the first period.
0000000000000000000000000000000000000000;;	// For instance, given "www.google.com" it returns "www".
0000000000000000000000000000000000000000;;	func shortHostname(hostname string) string {
0000000000000000000000000000000000000000;;		if i := strings.Index(hostname, "."); i >= 0 {
0000000000000000000000000000000000000000;;			return hostname[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hostname
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logName returns a new log file name containing tag, with start time t, and
0000000000000000000000000000000000000000;;	// the name for the symlink for tag.
0000000000000000000000000000000000000000;;	func logName(tag string, t time.Time) (name, link string) {
0000000000000000000000000000000000000000;;		name = fmt.Sprintf("%s.%s.%s.log.%s.%04d%02d%02d-%02d%02d%02d.%d",
0000000000000000000000000000000000000000;;			program,
0000000000000000000000000000000000000000;;			host,
0000000000000000000000000000000000000000;;			userName,
0000000000000000000000000000000000000000;;			tag,
0000000000000000000000000000000000000000;;			t.Year(),
0000000000000000000000000000000000000000;;			t.Month(),
0000000000000000000000000000000000000000;;			t.Day(),
0000000000000000000000000000000000000000;;			t.Hour(),
0000000000000000000000000000000000000000;;			t.Minute(),
0000000000000000000000000000000000000000;;			t.Second(),
0000000000000000000000000000000000000000;;			pid)
0000000000000000000000000000000000000000;;		return name, program + "." + tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var onceLogDirs sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// create creates a new log file and returns the file and its filename, which
0000000000000000000000000000000000000000;;	// contains tag ("INFO", "FATAL", etc.) and t.  If the file is created
0000000000000000000000000000000000000000;;	// successfully, create also attempts to update the symlink for that tag, ignoring
0000000000000000000000000000000000000000;;	// errors.
0000000000000000000000000000000000000000;;	func create(tag string, t time.Time) (f *os.File, filename string, err error) {
0000000000000000000000000000000000000000;;		onceLogDirs.Do(createLogDirs)
0000000000000000000000000000000000000000;;		if len(logDirs) == 0 {
0000000000000000000000000000000000000000;;			return nil, "", errors.New("log: no log dirs")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name, link := logName(tag, t)
0000000000000000000000000000000000000000;;		var lastErr error
0000000000000000000000000000000000000000;;		for _, dir := range logDirs {
0000000000000000000000000000000000000000;;			fname := filepath.Join(dir, name)
0000000000000000000000000000000000000000;;			f, err := os.Create(fname)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				symlink := filepath.Join(dir, link)
0000000000000000000000000000000000000000;;				os.Remove(symlink)        // ignore err
0000000000000000000000000000000000000000;;				os.Symlink(name, symlink) // ignore err
0000000000000000000000000000000000000000;;				return f, fname, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastErr = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, "", fmt.Errorf("log: cannot create log: %v", lastErr)
0000000000000000000000000000000000000000;;	}
