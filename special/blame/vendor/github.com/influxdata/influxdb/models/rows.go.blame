0000000000000000000000000000000000000000;;	package models
98fa85693d398f10e97b3f66d66f93eefb348cf6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Row represents a single row returned from the execution of a statement.
0000000000000000000000000000000000000000;;	type Row struct {
0000000000000000000000000000000000000000;;		Name    string            `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		Tags    map[string]string `json:"tags,omitempty"`
0000000000000000000000000000000000000000;;		Columns []string          `json:"columns,omitempty"`
0000000000000000000000000000000000000000;;		Values  [][]interface{}   `json:"values,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SameSeries returns true if r contains values for the same series as o.
0000000000000000000000000000000000000000;;	func (r *Row) SameSeries(o *Row) bool {
0000000000000000000000000000000000000000;;		return r.tagsHash() == o.tagsHash() && r.Name == o.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagsHash returns a hash of tag key/value pairs.
0000000000000000000000000000000000000000;;	func (r *Row) tagsHash() uint64 {
0000000000000000000000000000000000000000;;		h := NewInlineFNV64a()
0000000000000000000000000000000000000000;;		keys := r.tagsKeys()
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			h.Write([]byte(k))
0000000000000000000000000000000000000000;;			h.Write([]byte(r.Tags[k]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h.Sum64()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagKeys returns a sorted list of tag keys.
0000000000000000000000000000000000000000;;	func (r *Row) tagsKeys() []string {
0000000000000000000000000000000000000000;;		a := make([]string, 0, len(r.Tags))
0000000000000000000000000000000000000000;;		for k := range r.Tags {
0000000000000000000000000000000000000000;;			a = append(a, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(a)
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rows represents a collection of rows. Rows implements sort.Interface.
0000000000000000000000000000000000000000;;	type Rows []*Row
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Rows) Len() int { return len(p) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Rows) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		// Sort by name first.
0000000000000000000000000000000000000000;;		if p[i].Name != p[j].Name {
0000000000000000000000000000000000000000;;			return p[i].Name < p[j].Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort by tag set hash. Tags don't have a meaningful sort order so we
0000000000000000000000000000000000000000;;		// just compute a hash and sort by that instead. This allows the tests
0000000000000000000000000000000000000000;;		// to receive rows in a predictable order every time.
0000000000000000000000000000000000000000;;		return p[i].tagsHash() < p[j].tagsHash()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Rows) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
