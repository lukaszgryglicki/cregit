0000000000000000000000000000000000000000;;	package models
85be1397737fb977b9aacb7b53118af0a1887817;Godeps/_workspace/src/github.com/influxdb/influxdb/tsdb/points.go[Godeps/_workspace/src/github.com/influxdb/influxdb/tsdb/points.go][vendor/github.com/influxdata/influxdb/models/points.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/influxdata/influxdb/pkg/escape"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		measurementEscapeCodes = map[byte][]byte{
0000000000000000000000000000000000000000;;			',': []byte(`\,`),
0000000000000000000000000000000000000000;;			' ': []byte(`\ `),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tagEscapeCodes = map[byte][]byte{
0000000000000000000000000000000000000000;;			',': []byte(`\,`),
0000000000000000000000000000000000000000;;			' ': []byte(`\ `),
0000000000000000000000000000000000000000;;			'=': []byte(`\=`),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrPointMustHaveAField  = errors.New("point without fields is unsupported")
0000000000000000000000000000000000000000;;		ErrInvalidNumber        = errors.New("invalid number")
0000000000000000000000000000000000000000;;		ErrInvalidPoint         = errors.New("point is invalid")
0000000000000000000000000000000000000000;;		ErrMaxKeyLengthExceeded = errors.New("max key length exceeded")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MaxKeyLength = 65535
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Point defines the values that will be written to the database
0000000000000000000000000000000000000000;;	type Point interface {
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		SetName(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Tags() Tags
0000000000000000000000000000000000000000;;		AddTag(key, value string)
0000000000000000000000000000000000000000;;		SetTags(tags Tags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Fields() Fields
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Time() time.Time
0000000000000000000000000000000000000000;;		SetTime(t time.Time)
0000000000000000000000000000000000000000;;		UnixNano() int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HashID() uint64
0000000000000000000000000000000000000000;;		Key() []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Data() []byte
0000000000000000000000000000000000000000;;		SetData(buf []byte)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// String returns a string representation of the point, if there is a
0000000000000000000000000000000000000000;;		// timestamp associated with the point then it will be specified with the default
0000000000000000000000000000000000000000;;		// precision of nanoseconds
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bytes returns a []byte representation of the point similar to string.
0000000000000000000000000000000000000000;;		MarshalBinary() ([]byte, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrecisionString returns a string representation of the point, if there
0000000000000000000000000000000000000000;;		// is a timestamp associated with the point then it will be specified in the
0000000000000000000000000000000000000000;;		// given unit
0000000000000000000000000000000000000000;;		PrecisionString(precision string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoundedString returns a string representation of the point, if there
0000000000000000000000000000000000000000;;		// is a timestamp associated with the point, then it will be rounded to the
0000000000000000000000000000000000000000;;		// given duration
0000000000000000000000000000000000000000;;		RoundedString(d time.Duration) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split will attempt to return multiple points with the same timestamp whose
0000000000000000000000000000000000000000;;		// string representations are no longer than size. Points with a single field or
0000000000000000000000000000000000000000;;		// a point without a timestamp may exceed the requested size.
0000000000000000000000000000000000000000;;		Split(size int) []Point
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Round will round the timestamp of the point to the given duration
0000000000000000000000000000000000000000;;		Round(d time.Duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StringSize returns the length of the string that would be returned by String()
0000000000000000000000000000000000000000;;		StringSize() int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AppendString appends the result of String() to the provided buffer and returns
0000000000000000000000000000000000000000;;		// the result, potentially reducing string allocations
0000000000000000000000000000000000000000;;		AppendString(buf []byte) []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FieldIterator retuns a FieldIterator that can be used to traverse the
0000000000000000000000000000000000000000;;		// fields of a point without constructing the in-memory map
0000000000000000000000000000000000000000;;		FieldIterator() FieldIterator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FieldType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Integer FieldType = iota
0000000000000000000000000000000000000000;;		Float
0000000000000000000000000000000000000000;;		Boolean
0000000000000000000000000000000000000000;;		String
0000000000000000000000000000000000000000;;		Empty
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FieldIterator interface {
0000000000000000000000000000000000000000;;		Next() bool
0000000000000000000000000000000000000000;;		FieldKey() []byte
0000000000000000000000000000000000000000;;		Type() FieldType
0000000000000000000000000000000000000000;;		StringValue() string
0000000000000000000000000000000000000000;;		IntegerValue() int64
0000000000000000000000000000000000000000;;		BooleanValue() bool
0000000000000000000000000000000000000000;;		FloatValue() float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Delete()
0000000000000000000000000000000000000000;;		Reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Points represents a sortable list of points by timestamp.
0000000000000000000000000000000000000000;;	type Points []Point
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Points) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a Points) Less(i, j int) bool { return a[i].Time().Before(a[j].Time()) }
0000000000000000000000000000000000000000;;	func (a Points) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// point is the default implementation of Point.
0000000000000000000000000000000000000000;;	type point struct {
0000000000000000000000000000000000000000;;		time time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// text encoding of measurement and tags
0000000000000000000000000000000000000000;;		// key must always be stored sorted by tags, if the original line was not sorted,
0000000000000000000000000000000000000000;;		// we need to resort it
0000000000000000000000000000000000000000;;		key []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// text encoding of field data
0000000000000000000000000000000000000000;;		fields []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// text encoding of timestamp
0000000000000000000000000000000000000000;;		ts []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// binary encoded field data
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cached version of parsed fields from data
0000000000000000000000000000000000000000;;		cachedFields map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cached version of parsed name from key
0000000000000000000000000000000000000000;;		cachedName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cached version of parsed tags
0000000000000000000000000000000000000000;;		cachedTags Tags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		it fieldIterator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// the number of characters for the largest possible int64 (9223372036854775807)
0000000000000000000000000000000000000000;;		maxInt64Digits = 19
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the number of characters for the smallest possible int64 (-9223372036854775808)
0000000000000000000000000000000000000000;;		minInt64Digits = 20
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the number of characters required for the largest float64 before a range check
0000000000000000000000000000000000000000;;		// would occur during parsing
0000000000000000000000000000000000000000;;		maxFloat64Digits = 25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the number of characters required for smallest float64 before a range check occur
0000000000000000000000000000000000000000;;		// would occur during parsing
0000000000000000000000000000000000000000;;		minFloat64Digits = 27
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePoints returns a slice of Points from a text representation of a point
0000000000000000000000000000000000000000;;	// with each point separated by newlines.  If any points fail to parse, a non-nil error
0000000000000000000000000000000000000000;;	// will be returned in addition to the points that parsed successfully.
0000000000000000000000000000000000000000;;	func ParsePoints(buf []byte) ([]Point, error) {
0000000000000000000000000000000000000000;;		return ParsePointsWithPrecision(buf, time.Now().UTC(), "n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePointsString is identical to ParsePoints but accepts a string
0000000000000000000000000000000000000000;;	// buffer.
0000000000000000000000000000000000000000;;	func ParsePointsString(buf string) ([]Point, error) {
0000000000000000000000000000000000000000;;		return ParsePoints([]byte(buf))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseKey returns the measurement name and tags from a point.
0000000000000000000000000000000000000000;;	func ParseKey(buf []byte) (string, Tags, error) {
0000000000000000000000000000000000000000;;		// Ignore the error because scanMeasurement returns "missing fields" which we ignore
0000000000000000000000000000000000000000;;		// when just parsing a key
0000000000000000000000000000000000000000;;		state, i, _ := scanMeasurement(buf, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tags Tags
0000000000000000000000000000000000000000;;		if state == tagKeyState {
0000000000000000000000000000000000000000;;			tags = parseTags(buf)
0000000000000000000000000000000000000000;;			// scanMeasurement returns the location of the comma if there are tags, strip that off
0000000000000000000000000000000000000000;;			return string(buf[:i-1]), tags, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf[:i]), tags, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePointsWithPrecision is similar to ParsePoints, but allows the
0000000000000000000000000000000000000000;;	// caller to provide a precision for time.
0000000000000000000000000000000000000000;;	func ParsePointsWithPrecision(buf []byte, defaultTime time.Time, precision string) ([]Point, error) {
0000000000000000000000000000000000000000;;		points := make([]Point, 0, bytes.Count(buf, []byte{'\n'})+1)
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			pos    int
0000000000000000000000000000000000000000;;			block  []byte
0000000000000000000000000000000000000000;;			failed []string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for pos < len(buf) {
0000000000000000000000000000000000000000;;			pos, block = scanLine(buf, pos)
0000000000000000000000000000000000000000;;			pos++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(block) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// lines which start with '#' are comments
0000000000000000000000000000000000000000;;			start := skipWhitespace(block, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If line is all whitespace, just skip it
0000000000000000000000000000000000000000;;			if start >= len(block) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if block[start] == '#' {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// strip the newline if one is present
0000000000000000000000000000000000000000;;			if block[len(block)-1] == '\n' {
0000000000000000000000000000000000000000;;				block = block[:len(block)-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pt, err := parsePoint(block[start:], defaultTime, precision)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				failed = append(failed, fmt.Sprintf("unable to parse '%s': %v", string(block[start:len(block)]), err))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				points = append(points, pt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(failed) > 0 {
0000000000000000000000000000000000000000;;			return points, fmt.Errorf("%s", strings.Join(failed, "\n"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return points, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePoint(buf []byte, defaultTime time.Time, precision string) (Point, error) {
0000000000000000000000000000000000000000;;		// scan the first block which is measurement[,tag1=value1,tag2=value=2...]
0000000000000000000000000000000000000000;;		pos, key, err := scanKey(buf, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// measurement name is required
0000000000000000000000000000000000000000;;		if len(key) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing measurement")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(key) > MaxKeyLength {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("max key length exceeded: %v > %v", len(key), MaxKeyLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scan the second block is which is field1=value1[,field2=value2,...]
0000000000000000000000000000000000000000;;		pos, fields, err := scanFields(buf, pos)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// at least one field is required
0000000000000000000000000000000000000000;;		if len(fields) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing fields")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scan the last block which is an optional integer timestamp
0000000000000000000000000000000000000000;;		pos, ts, err := scanTime(buf, pos)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pt := &point{
0000000000000000000000000000000000000000;;			key:    key,
0000000000000000000000000000000000000000;;			fields: fields,
0000000000000000000000000000000000000000;;			ts:     ts,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ts) == 0 {
0000000000000000000000000000000000000000;;			pt.time = defaultTime
0000000000000000000000000000000000000000;;			pt.SetPrecision(precision)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ts, err := parseIntBytes(ts, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pt.time, err = SafeCalcTime(ts, precision)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Determine if there are illegal non-whitespace characters after the
0000000000000000000000000000000000000000;;			// timestamp block.
0000000000000000000000000000000000000000;;			for pos < len(buf) {
0000000000000000000000000000000000000000;;				if buf[pos] != ' ' {
0000000000000000000000000000000000000000;;					return nil, ErrInvalidPoint
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pt, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPrecisionMultiplier will return a multiplier for the precision specified
0000000000000000000000000000000000000000;;	func GetPrecisionMultiplier(precision string) int64 {
0000000000000000000000000000000000000000;;		d := time.Nanosecond
0000000000000000000000000000000000000000;;		switch precision {
0000000000000000000000000000000000000000;;		case "u":
0000000000000000000000000000000000000000;;			d = time.Microsecond
0000000000000000000000000000000000000000;;		case "ms":
0000000000000000000000000000000000000000;;			d = time.Millisecond
0000000000000000000000000000000000000000;;		case "s":
0000000000000000000000000000000000000000;;			d = time.Second
0000000000000000000000000000000000000000;;		case "m":
0000000000000000000000000000000000000000;;			d = time.Minute
0000000000000000000000000000000000000000;;		case "h":
0000000000000000000000000000000000000000;;			d = time.Hour
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanKey scans buf starting at i for the measurement and tag portion of the point.
0000000000000000000000000000000000000000;;	// It returns the ending position and the byte slice of key within buf.  If there
0000000000000000000000000000000000000000;;	// are tags, they will be sorted if they are not already.
0000000000000000000000000000000000000000;;	func scanKey(buf []byte, i int) (int, []byte, error) {
0000000000000000000000000000000000000000;;		start := skipWhitespace(buf, i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i = start
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determines whether the tags are sort, assume they are
0000000000000000000000000000000000000000;;		sorted := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// indices holds the indexes within buf of the start of each tag.  For example,
0000000000000000000000000000000000000000;;		// a buf of 'cpu,host=a,region=b,zone=c' would have indices slice of [4,11,20]
0000000000000000000000000000000000000000;;		// which indicates that the first tag starts at buf[4], seconds at buf[11], and
0000000000000000000000000000000000000000;;		// last at buf[20]
0000000000000000000000000000000000000000;;		indices := make([]int, 100)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tracks how many commas we've seen so we know how many values are indices.
0000000000000000000000000000000000000000;;		// Since indices is an arbitrarily large slice,
0000000000000000000000000000000000000000;;		// we need to know how many values in the buffer are in use.
0000000000000000000000000000000000000000;;		commas := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First scan the Point's measurement.
0000000000000000000000000000000000000000;;		state, i, err := scanMeasurement(buf, i)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return i, buf[start:i], err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optionally scan tags if needed.
0000000000000000000000000000000000000000;;		if state == tagKeyState {
0000000000000000000000000000000000000000;;			i, commas, indices, err = scanTags(buf, i, indices)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return i, buf[start:i], err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we know where the key region is within buf, and the location of tags, we
0000000000000000000000000000000000000000;;		// need to determine if duplicate tags exist and if the tags are sorted. This iterates
0000000000000000000000000000000000000000;;		// over the list comparing each tag in the sequence with each other.
0000000000000000000000000000000000000000;;		for j := 0; j < commas-1; j++ {
0000000000000000000000000000000000000000;;			// get the left and right tags
0000000000000000000000000000000000000000;;			_, left := scanTo(buf[indices[j]:indices[j+1]-1], 0, '=')
0000000000000000000000000000000000000000;;			_, right := scanTo(buf[indices[j+1]:indices[j+2]-1], 0, '=')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If left is greater than right, the tags are not sorted. We do not have to
0000000000000000000000000000000000000000;;			// continue because the short path no longer works.
0000000000000000000000000000000000000000;;			// If the tags are equal, then there are duplicate tags, and we should abort.
0000000000000000000000000000000000000000;;			// If the tags are not sorted, this pass may not find duplicate tags and we
0000000000000000000000000000000000000000;;			// need to do a more exhaustive search later.
0000000000000000000000000000000000000000;;			if cmp := bytes.Compare(left, right); cmp > 0 {
0000000000000000000000000000000000000000;;				sorted = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if cmp == 0 {
0000000000000000000000000000000000000000;;				return i, buf[start:i], fmt.Errorf("duplicate tags")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the tags are not sorted, then sort them.  This sort is inline and
0000000000000000000000000000000000000000;;		// uses the tag indices we created earlier.  The actual buffer is not sorted, the
0000000000000000000000000000000000000000;;		// indices are using the buffer for value comparison.  After the indices are sorted,
0000000000000000000000000000000000000000;;		// the buffer is reconstructed from the sorted indices.
0000000000000000000000000000000000000000;;		if !sorted && commas > 0 {
0000000000000000000000000000000000000000;;			// Get the measurement name for later
0000000000000000000000000000000000000000;;			measurement := buf[start : indices[0]-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Sort the indices
0000000000000000000000000000000000000000;;			indices := indices[:commas]
0000000000000000000000000000000000000000;;			insertionSort(0, commas, buf, indices)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a new key using the measurement and sorted indices
0000000000000000000000000000000000000000;;			b := make([]byte, len(buf[start:i]))
0000000000000000000000000000000000000000;;			pos := copy(b, measurement)
0000000000000000000000000000000000000000;;			for _, i := range indices {
0000000000000000000000000000000000000000;;				b[pos] = ','
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;				_, v := scanToSpaceOr(buf, i, ',')
0000000000000000000000000000000000000000;;				pos += copy(b[pos:], v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check again for duplicate tags now that the tags are sorted.
0000000000000000000000000000000000000000;;			for j := 0; j < commas-1; j++ {
0000000000000000000000000000000000000000;;				// get the left and right tags
0000000000000000000000000000000000000000;;				_, left := scanTo(buf[indices[j]:], 0, '=')
0000000000000000000000000000000000000000;;				_, right := scanTo(buf[indices[j+1]:], 0, '=')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If the tags are equal, then there are duplicate tags, and we should abort.
0000000000000000000000000000000000000000;;				// If the tags are not sorted, this pass may not find duplicate tags and we
0000000000000000000000000000000000000000;;				// need to do a more exhaustive search later.
0000000000000000000000000000000000000000;;				if bytes.Equal(left, right) {
0000000000000000000000000000000000000000;;					return i, b, fmt.Errorf("duplicate tags")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return i, b, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i, buf[start:i], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following constants allow us to specify which state to move to
0000000000000000000000000000000000000000;;	// next, when scanning sections of a Point.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tagKeyState = iota
0000000000000000000000000000000000000000;;		tagValueState
0000000000000000000000000000000000000000;;		fieldsState
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanMeasurement examines the measurement part of a Point, returning
0000000000000000000000000000000000000000;;	// the next state to move to, and the current location in the buffer.
0000000000000000000000000000000000000000;;	func scanMeasurement(buf []byte, i int) (int, int, error) {
0000000000000000000000000000000000000000;;		// Check first byte of measurement, anything except a comma is fine.
0000000000000000000000000000000000000000;;		// It can't be a space, since whitespace is stripped prior to this
0000000000000000000000000000000000000000;;		// function call.
0000000000000000000000000000000000000000;;		if i >= len(buf) || buf[i] == ',' {
0000000000000000000000000000000000000000;;			return -1, i, fmt.Errorf("missing measurement")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				// cpu
0000000000000000000000000000000000000000;;				return -1, i, fmt.Errorf("missing fields")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i-1] == '\\' {
0000000000000000000000000000000000000000;;				// Skip character (it's escaped).
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Unescaped comma; move onto scanning the tags.
0000000000000000000000000000000000000000;;			if buf[i] == ',' {
0000000000000000000000000000000000000000;;				return tagKeyState, i + 1, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Unescaped space; move onto scanning the fields.
0000000000000000000000000000000000000000;;			if buf[i] == ' ' {
0000000000000000000000000000000000000000;;				// cpu value=1.0
0000000000000000000000000000000000000000;;				return fieldsState, i, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanTags examines all the tags in a Point, keeping track of and
0000000000000000000000000000000000000000;;	// returning the updated indices slice, number of commas and location
0000000000000000000000000000000000000000;;	// in buf where to start examining the Point fields.
0000000000000000000000000000000000000000;;	func scanTags(buf []byte, i int, indices []int) (int, int, []int, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;			commas int
0000000000000000000000000000000000000000;;			state  = tagKeyState
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch state {
0000000000000000000000000000000000000000;;			case tagKeyState:
0000000000000000000000000000000000000000;;				// Grow our indices slice if we have too many tags.
0000000000000000000000000000000000000000;;				if commas >= len(indices) {
0000000000000000000000000000000000000000;;					newIndics := make([]int, cap(indices)*2)
0000000000000000000000000000000000000000;;					copy(newIndics, indices)
0000000000000000000000000000000000000000;;					indices = newIndics
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				indices[commas] = i
0000000000000000000000000000000000000000;;				commas++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				i, err = scanTagsKey(buf, i)
0000000000000000000000000000000000000000;;				state = tagValueState // tag value always follows a tag key
0000000000000000000000000000000000000000;;			case tagValueState:
0000000000000000000000000000000000000000;;				state, i, err = scanTagsValue(buf, i)
0000000000000000000000000000000000000000;;			case fieldsState:
0000000000000000000000000000000000000000;;				indices[commas] = i + 1
0000000000000000000000000000000000000000;;				return i, commas, indices, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return i, commas, indices, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanTagsKey scans each character in a tag key.
0000000000000000000000000000000000000000;;	func scanTagsKey(buf []byte, i int) (int, error) {
0000000000000000000000000000000000000000;;		// First character of the key.
0000000000000000000000000000000000000000;;		if i >= len(buf) || buf[i] == ' ' || buf[i] == ',' || buf[i] == '=' {
0000000000000000000000000000000000000000;;			// cpu,{'', ' ', ',', '='}
0000000000000000000000000000000000000000;;			return i, fmt.Errorf("missing tag key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Examine each character in the tag key until we hit an unescaped
0000000000000000000000000000000000000000;;		// equals (the tag value), or we hit an error (i.e., unescaped
0000000000000000000000000000000000000000;;		// space or comma).
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Either we reached the end of the buffer or we hit an
0000000000000000000000000000000000000000;;			// unescaped comma or space.
0000000000000000000000000000000000000000;;			if i >= len(buf) ||
0000000000000000000000000000000000000000;;				((buf[i] == ' ' || buf[i] == ',') && buf[i-1] != '\\') {
0000000000000000000000000000000000000000;;				// cpu,tag{'', ' ', ','}
0000000000000000000000000000000000000000;;				return i, fmt.Errorf("missing tag value")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == '=' && buf[i-1] != '\\' {
0000000000000000000000000000000000000000;;				// cpu,tag=
0000000000000000000000000000000000000000;;				return i + 1, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanTagsValue scans each character in a tag value.
0000000000000000000000000000000000000000;;	func scanTagsValue(buf []byte, i int) (int, int, error) {
0000000000000000000000000000000000000000;;		// Tag value cannot be empty.
0000000000000000000000000000000000000000;;		if i >= len(buf) || buf[i] == ',' || buf[i] == ' ' {
0000000000000000000000000000000000000000;;			// cpu,tag={',', ' '}
0000000000000000000000000000000000000000;;			return -1, i, fmt.Errorf("missing tag value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Examine each character in the tag value until we hit an unescaped
0000000000000000000000000000000000000000;;		// comma (move onto next tag key), an unescaped space (move onto
0000000000000000000000000000000000000000;;		// fields), or we error out.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				// cpu,tag=value
0000000000000000000000000000000000000000;;				return -1, i, fmt.Errorf("missing fields")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// An unescaped equals sign is an invalid tag value.
0000000000000000000000000000000000000000;;			if buf[i] == '=' && buf[i-1] != '\\' {
0000000000000000000000000000000000000000;;				// cpu,tag={'=', 'fo=o'}
0000000000000000000000000000000000000000;;				return -1, i, fmt.Errorf("invalid tag format")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == ',' && buf[i-1] != '\\' {
0000000000000000000000000000000000000000;;				// cpu,tag=foo,
0000000000000000000000000000000000000000;;				return tagKeyState, i + 1, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// cpu,tag=foo value=1.0
0000000000000000000000000000000000000000;;			// cpu, tag=foo\= value=1.0
0000000000000000000000000000000000000000;;			if buf[i] == ' ' && buf[i-1] != '\\' {
0000000000000000000000000000000000000000;;				return fieldsState, i, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func insertionSort(l, r int, buf []byte, indices []int) {
0000000000000000000000000000000000000000;;		for i := l + 1; i < r; i++ {
0000000000000000000000000000000000000000;;			for j := i; j > l && less(buf, indices, j, j-1); j-- {
0000000000000000000000000000000000000000;;				indices[j], indices[j-1] = indices[j-1], indices[j]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func less(buf []byte, indices []int, i, j int) bool {
0000000000000000000000000000000000000000;;		// This grabs the tag names for i & j, it ignores the values
0000000000000000000000000000000000000000;;		_, a := scanTo(buf, indices[i], '=')
0000000000000000000000000000000000000000;;		_, b := scanTo(buf, indices[j], '=')
0000000000000000000000000000000000000000;;		return bytes.Compare(a, b) < 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanFields scans buf, starting at i for the fields section of a point.  It returns
0000000000000000000000000000000000000000;;	// the ending position and the byte slice of the fields within buf
0000000000000000000000000000000000000000;;	func scanFields(buf []byte, i int) (int, []byte, error) {
0000000000000000000000000000000000000000;;		start := skipWhitespace(buf, i)
0000000000000000000000000000000000000000;;		i = start
0000000000000000000000000000000000000000;;		quoted := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tracks how many '=' we've seen
0000000000000000000000000000000000000000;;		equals := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tracks how many commas we've seen
0000000000000000000000000000000000000000;;		commas := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// reached the end of buf?
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// escaped characters?
0000000000000000000000000000000000000000;;			if buf[i] == '\\' && i+1 < len(buf) {
0000000000000000000000000000000000000000;;				i += 2
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the value is quoted, scan until we get to the end quote
0000000000000000000000000000000000000000;;			// Only quote values in the field value since quotes are not significant
0000000000000000000000000000000000000000;;			// in the field key
0000000000000000000000000000000000000000;;			if buf[i] == '"' && equals > commas {
0000000000000000000000000000000000000000;;				quoted = !quoted
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we see an =, ensure that there is at least on char before and after it
0000000000000000000000000000000000000000;;			if buf[i] == '=' && !quoted {
0000000000000000000000000000000000000000;;				equals++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check for "... =123" but allow "a\ =123"
0000000000000000000000000000000000000000;;				if buf[i-1] == ' ' && buf[i-2] != '\\' {
0000000000000000000000000000000000000000;;					return i, buf[start:i], fmt.Errorf("missing field key")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check for "...a=123,=456" but allow "a=123,a\,=456"
0000000000000000000000000000000000000000;;				if buf[i-1] == ',' && buf[i-2] != '\\' {
0000000000000000000000000000000000000000;;					return i, buf[start:i], fmt.Errorf("missing field key")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check for "... value="
0000000000000000000000000000000000000000;;				if i+1 >= len(buf) {
0000000000000000000000000000000000000000;;					return i, buf[start:i], fmt.Errorf("missing field value")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check for "... value=,value2=..."
0000000000000000000000000000000000000000;;				if buf[i+1] == ',' || buf[i+1] == ' ' {
0000000000000000000000000000000000000000;;					return i, buf[start:i], fmt.Errorf("missing field value")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if isNumeric(buf[i+1]) || buf[i+1] == '-' || buf[i+1] == 'N' || buf[i+1] == 'n' {
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					i, err = scanNumber(buf, i+1)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return i, buf[start:i], err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If next byte is not a double-quote, the value must be a boolean
0000000000000000000000000000000000000000;;				if buf[i+1] != '"' {
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					i, _, err = scanBoolean(buf, i+1)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return i, buf[start:i], err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == ',' && !quoted {
0000000000000000000000000000000000000000;;				commas++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// reached end of block?
0000000000000000000000000000000000000000;;			if buf[i] == ' ' && !quoted {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if quoted {
0000000000000000000000000000000000000000;;			return i, buf[start:i], fmt.Errorf("unbalanced quotes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check that all field sections had key and values (e.g. prevent "a=1,b"
0000000000000000000000000000000000000000;;		if equals == 0 || commas != equals-1 {
0000000000000000000000000000000000000000;;			return i, buf[start:i], fmt.Errorf("invalid field format")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i, buf[start:i], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanTime scans buf, starting at i for the time section of a point. It
0000000000000000000000000000000000000000;;	// returns the ending position and the byte slice of the timestamp within buf
0000000000000000000000000000000000000000;;	// and and error if the timestamp is not in the correct numeric format.
0000000000000000000000000000000000000000;;	func scanTime(buf []byte, i int) (int, []byte, error) {
0000000000000000000000000000000000000000;;		start := skipWhitespace(buf, i)
0000000000000000000000000000000000000000;;		i = start
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// reached the end of buf?
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Reached end of block or trailing whitespace?
0000000000000000000000000000000000000000;;			if buf[i] == '\n' || buf[i] == ' ' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Handle negative timestamps
0000000000000000000000000000000000000000;;			if i == start && buf[i] == '-' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Timestamps should be integers, make sure they are so we don't need
0000000000000000000000000000000000000000;;			// to actually  parse the timestamp until needed.
0000000000000000000000000000000000000000;;			if buf[i] < '0' || buf[i] > '9' {
0000000000000000000000000000000000000000;;				return i, buf[start:i], fmt.Errorf("bad timestamp")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i, buf[start:i], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNumeric(b byte) bool {
0000000000000000000000000000000000000000;;		return (b >= '0' && b <= '9') || b == '.'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanNumber returns the end position within buf, start at i after
0000000000000000000000000000000000000000;;	// scanning over buf for an integer, or float.  It returns an
0000000000000000000000000000000000000000;;	// error if a invalid number is scanned.
0000000000000000000000000000000000000000;;	func scanNumber(buf []byte, i int) (int, error) {
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;		var isInt bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is negative number?
0000000000000000000000000000000000000000;;		if i < len(buf) && buf[i] == '-' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			// There must be more characters now, as just '-' is illegal.
0000000000000000000000000000000000000000;;			if i == len(buf) {
0000000000000000000000000000000000000000;;				return i, ErrInvalidNumber
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// how many decimal points we've see
0000000000000000000000000000000000000000;;		decimal := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// indicates the number is float in scientific notation
0000000000000000000000000000000000000000;;		scientific := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == ',' || buf[i] == ' ' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == 'i' && i > start && !isInt {
0000000000000000000000000000000000000000;;				isInt = true
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == '.' {
0000000000000000000000000000000000000000;;				// Can't have more than 1 decimal (e.g. 1.1.1 should fail)
0000000000000000000000000000000000000000;;				if decimal {
0000000000000000000000000000000000000000;;					return i, ErrInvalidNumber
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				decimal = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// `e` is valid for floats but not as the first char
0000000000000000000000000000000000000000;;			if i > start && (buf[i] == 'e' || buf[i] == 'E') {
0000000000000000000000000000000000000000;;				scientific = true
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// + and - are only valid at this point if they follow an e (scientific notation)
0000000000000000000000000000000000000000;;			if (buf[i] == '+' || buf[i] == '-') && (buf[i-1] == 'e' || buf[i-1] == 'E') {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// NaN is an unsupported value
0000000000000000000000000000000000000000;;			if i+2 < len(buf) && (buf[i] == 'N' || buf[i] == 'n') {
0000000000000000000000000000000000000000;;				return i, ErrInvalidNumber
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !isNumeric(buf[i]) {
0000000000000000000000000000000000000000;;				return i, ErrInvalidNumber
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isInt && (decimal || scientific) {
0000000000000000000000000000000000000000;;			return i, ErrInvalidNumber
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numericDigits := i - start
0000000000000000000000000000000000000000;;		if isInt {
0000000000000000000000000000000000000000;;			numericDigits--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if decimal {
0000000000000000000000000000000000000000;;			numericDigits--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buf[start] == '-' {
0000000000000000000000000000000000000000;;			numericDigits--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numericDigits == 0 {
0000000000000000000000000000000000000000;;			return i, ErrInvalidNumber
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It's more common that numbers will be within min/max range for their type but we need to prevent
0000000000000000000000000000000000000000;;		// out or range numbers from being parsed successfully.  This uses some simple heuristics to decide
0000000000000000000000000000000000000000;;		// if we should parse the number to the actual type.  It does not do it all the time because it incurs
0000000000000000000000000000000000000000;;		// extra allocations and we end up converting the type again when writing points to disk.
0000000000000000000000000000000000000000;;		if isInt {
0000000000000000000000000000000000000000;;			// Make sure the last char is an 'i' for integers (e.g. 9i10 is not valid)
0000000000000000000000000000000000000000;;			if buf[i-1] != 'i' {
0000000000000000000000000000000000000000;;				return i, ErrInvalidNumber
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Parse the int to check bounds the number of digits could be larger than the max range
0000000000000000000000000000000000000000;;			// We subtract 1 from the index to remove the `i` from our tests
0000000000000000000000000000000000000000;;			if len(buf[start:i-1]) >= maxInt64Digits || len(buf[start:i-1]) >= minInt64Digits {
0000000000000000000000000000000000000000;;				if _, err := parseIntBytes(buf[start:i-1], 10, 64); err != nil {
0000000000000000000000000000000000000000;;					return i, fmt.Errorf("unable to parse integer %s: %s", buf[start:i-1], err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Parse the float to check bounds if it's scientific or the number of digits could be larger than the max range
0000000000000000000000000000000000000000;;			if scientific || len(buf[start:i]) >= maxFloat64Digits || len(buf[start:i]) >= minFloat64Digits {
0000000000000000000000000000000000000000;;				if _, err := parseFloatBytes(buf[start:i], 10); err != nil {
0000000000000000000000000000000000000000;;					return i, fmt.Errorf("invalid float")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanBoolean returns the end position within buf, start at i after
0000000000000000000000000000000000000000;;	// scanning over buf for boolean. Valid values for a boolean are
0000000000000000000000000000000000000000;;	// t, T, true, TRUE, f, F, false, FALSE.  It returns an error if a invalid boolean
0000000000000000000000000000000000000000;;	// is scanned.
0000000000000000000000000000000000000000;;	func scanBoolean(buf []byte, i int) (int, []byte, error) {
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i < len(buf) && (buf[i] != 't' && buf[i] != 'f' && buf[i] != 'T' && buf[i] != 'F') {
0000000000000000000000000000000000000000;;			return i, buf[start:i], fmt.Errorf("invalid boolean")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == ',' || buf[i] == ' ' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Single char bool (t, T, f, F) is ok
0000000000000000000000000000000000000000;;		if i-start == 1 {
0000000000000000000000000000000000000000;;			return i, buf[start:i], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// length must be 4 for true or TRUE
0000000000000000000000000000000000000000;;		if (buf[start] == 't' || buf[start] == 'T') && i-start != 4 {
0000000000000000000000000000000000000000;;			return i, buf[start:i], fmt.Errorf("invalid boolean")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// length must be 5 for false or FALSE
0000000000000000000000000000000000000000;;		if (buf[start] == 'f' || buf[start] == 'F') && i-start != 5 {
0000000000000000000000000000000000000000;;			return i, buf[start:i], fmt.Errorf("invalid boolean")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise
0000000000000000000000000000000000000000;;		valid := false
0000000000000000000000000000000000000000;;		switch buf[start] {
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			valid = bytes.Equal(buf[start:i], []byte("true"))
0000000000000000000000000000000000000000;;		case 'f':
0000000000000000000000000000000000000000;;			valid = bytes.Equal(buf[start:i], []byte("false"))
0000000000000000000000000000000000000000;;		case 'T':
0000000000000000000000000000000000000000;;			valid = bytes.Equal(buf[start:i], []byte("TRUE")) || bytes.Equal(buf[start:i], []byte("True"))
0000000000000000000000000000000000000000;;		case 'F':
0000000000000000000000000000000000000000;;			valid = bytes.Equal(buf[start:i], []byte("FALSE")) || bytes.Equal(buf[start:i], []byte("False"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !valid {
0000000000000000000000000000000000000000;;			return i, buf[start:i], fmt.Errorf("invalid boolean")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i, buf[start:i], nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// skipWhitespace returns the end position within buf, starting at i after
0000000000000000000000000000000000000000;;	// scanning over spaces in tags
0000000000000000000000000000000000000000;;	func skipWhitespace(buf []byte, i int) int {
0000000000000000000000000000000000000000;;		for i < len(buf) {
0000000000000000000000000000000000000000;;			if buf[i] != ' ' && buf[i] != '\t' && buf[i] != 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanLine returns the end position in buf and the next line found within
0000000000000000000000000000000000000000;;	// buf.
0000000000000000000000000000000000000000;;	func scanLine(buf []byte, i int) (int, []byte) {
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;		quoted := false
0000000000000000000000000000000000000000;;		fields := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tracks how many '=' and commas we've seen
0000000000000000000000000000000000000000;;		// this duplicates some of the functionality in scanFields
0000000000000000000000000000000000000000;;		equals := 0
0000000000000000000000000000000000000000;;		commas := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// reached the end of buf?
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// skip past escaped characters
0000000000000000000000000000000000000000;;			if buf[i] == '\\' {
0000000000000000000000000000000000000000;;				i += 2
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == ' ' {
0000000000000000000000000000000000000000;;				fields = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we see a double quote, makes sure it is not escaped
0000000000000000000000000000000000000000;;			if fields {
0000000000000000000000000000000000000000;;				if !quoted && buf[i] == '=' {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					equals++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else if !quoted && buf[i] == ',' {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					commas++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else if buf[i] == '"' && equals > commas {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					quoted = !quoted
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == '\n' && !quoted {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i, buf[start:i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanTo returns the end position in buf and the next consecutive block
0000000000000000000000000000000000000000;;	// of bytes, starting from i and ending with stop byte, where stop byte
0000000000000000000000000000000000000000;;	// has not been escaped.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If there are leading spaces, they are skipped.
0000000000000000000000000000000000000000;;	func scanTo(buf []byte, i int, stop byte) (int, []byte) {
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// reached the end of buf?
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Reached unescaped stop value?
0000000000000000000000000000000000000000;;			if buf[i] == stop && (i == 0 || buf[i-1] != '\\') {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i, buf[start:i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanTo returns the end position in buf and the next consecutive block
0000000000000000000000000000000000000000;;	// of bytes, starting from i and ending with stop byte.  If there are leading
0000000000000000000000000000000000000000;;	// spaces, they are skipped.
0000000000000000000000000000000000000000;;	func scanToSpaceOr(buf []byte, i int, stop byte) (int, []byte) {
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;		if buf[i] == stop || buf[i] == ' ' {
0000000000000000000000000000000000000000;;			return i, buf[start:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			if buf[i-1] == '\\' {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// reached the end of buf?
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				return i, buf[start:i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// reached end of block?
0000000000000000000000000000000000000000;;			if buf[i] == stop || buf[i] == ' ' {
0000000000000000000000000000000000000000;;				return i, buf[start:i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scanTagValue(buf []byte, i int) (int, []byte) {
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == ',' && buf[i-1] != '\\' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i, buf[start:i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scanFieldValue(buf []byte, i int) (int, []byte) {
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;		quoted := false
0000000000000000000000000000000000000000;;		for i < len(buf) {
0000000000000000000000000000000000000000;;			// Only escape char for a field value is a double-quote and backslash
0000000000000000000000000000000000000000;;			if buf[i] == '\\' && i+1 < len(buf) && (buf[i+1] == '"' || buf[i+1] == '\\') {
0000000000000000000000000000000000000000;;				i += 2
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Quoted value? (e.g. string)
0000000000000000000000000000000000000000;;			if buf[i] == '"' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				quoted = !quoted
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf[i] == ',' && !quoted {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i, buf[start:i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escapeMeasurement(in []byte) []byte {
0000000000000000000000000000000000000000;;		for b, esc := range measurementEscapeCodes {
0000000000000000000000000000000000000000;;			in = bytes.Replace(in, []byte{b}, esc, -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unescapeMeasurement(in []byte) []byte {
0000000000000000000000000000000000000000;;		for b, esc := range measurementEscapeCodes {
0000000000000000000000000000000000000000;;			in = bytes.Replace(in, esc, []byte{b}, -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escapeTag(in []byte) []byte {
0000000000000000000000000000000000000000;;		for b, esc := range tagEscapeCodes {
0000000000000000000000000000000000000000;;			if bytes.IndexByte(in, b) != -1 {
0000000000000000000000000000000000000000;;				in = bytes.Replace(in, []byte{b}, esc, -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unescapeTag(in []byte) []byte {
0000000000000000000000000000000000000000;;		if bytes.IndexByte(in, '\\') == -1 {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for b, esc := range tagEscapeCodes {
0000000000000000000000000000000000000000;;			if bytes.IndexByte(in, b) != -1 {
0000000000000000000000000000000000000000;;				in = bytes.Replace(in, esc, []byte{b}, -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapeStringField returns a copy of in with any double quotes or
0000000000000000000000000000000000000000;;	// backslashes with escaped values
0000000000000000000000000000000000000000;;	func EscapeStringField(in string) string {
0000000000000000000000000000000000000000;;		var out []byte
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i >= len(in) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// escape double-quotes
0000000000000000000000000000000000000000;;			if in[i] == '\\' {
0000000000000000000000000000000000000000;;				out = append(out, '\\')
0000000000000000000000000000000000000000;;				out = append(out, '\\')
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// escape double-quotes
0000000000000000000000000000000000000000;;			if in[i] == '"' {
0000000000000000000000000000000000000000;;				out = append(out, '\\')
0000000000000000000000000000000000000000;;				out = append(out, '"')
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, in[i])
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unescapeStringField returns a copy of in with any escaped double-quotes
0000000000000000000000000000000000000000;;	// or backslashes unescaped
0000000000000000000000000000000000000000;;	func unescapeStringField(in string) string {
0000000000000000000000000000000000000000;;		if strings.IndexByte(in, '\\') == -1 {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out []byte
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i >= len(in) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// unescape backslashes
0000000000000000000000000000000000000000;;			if in[i] == '\\' && i+1 < len(in) && in[i+1] == '\\' {
0000000000000000000000000000000000000000;;				out = append(out, '\\')
0000000000000000000000000000000000000000;;				i += 2
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// unescape double-quotes
0000000000000000000000000000000000000000;;			if in[i] == '\\' && i+1 < len(in) && in[i+1] == '"' {
0000000000000000000000000000000000000000;;				out = append(out, '"')
0000000000000000000000000000000000000000;;				i += 2
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, in[i])
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPoint returns a new point with the given measurement name, tags, fields and timestamp.  If
0000000000000000000000000000000000000000;;	// an unsupported field value (NaN) or out of range time is passed, this function returns an error.
0000000000000000000000000000000000000000;;	func NewPoint(name string, tags Tags, fields Fields, t time.Time) (Point, error) {
0000000000000000000000000000000000000000;;		key, err := pointKey(name, tags, fields, t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &point{
0000000000000000000000000000000000000000;;			key:    key,
0000000000000000000000000000000000000000;;			time:   t,
0000000000000000000000000000000000000000;;			fields: fields.MarshalBinary(),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pointKey checks some basic requirements for valid points, and returns the
0000000000000000000000000000000000000000;;	// key, along with an possible error
0000000000000000000000000000000000000000;;	func pointKey(measurement string, tags Tags, fields Fields, t time.Time) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(fields) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrPointMustHaveAField
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !t.IsZero() {
0000000000000000000000000000000000000000;;			if err := CheckTime(t); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range fields {
0000000000000000000000000000000000000000;;			switch value := value.(type) {
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				// Ensure the caller validates and handles invalid field values
0000000000000000000000000000000000000000;;				if math.IsNaN(value) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("NaN is an unsupported value for field %s", key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case float32:
0000000000000000000000000000000000000000;;				// Ensure the caller validates and handles invalid field values
0000000000000000000000000000000000000000;;				if math.IsNaN(float64(value)) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("NaN is an unsupported value for field %s", key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(key) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("all fields must have non-empty names")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := MakeKey([]byte(measurement), tags)
0000000000000000000000000000000000000000;;		if len(key) > MaxKeyLength {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("max key length exceeded: %v > %v", len(key), MaxKeyLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPointFromBytes returns a new Point from a marshalled Point.
0000000000000000000000000000000000000000;;	func NewPointFromBytes(b []byte) (Point, error) {
0000000000000000000000000000000000000000;;		p := &point{}
0000000000000000000000000000000000000000;;		if err := p.UnmarshalBinary(b); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.Fields()) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrPointMustHaveAField
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustNewPoint returns a new point with the given measurement name, tags, fields and timestamp.  If
0000000000000000000000000000000000000000;;	// an unsupported field value (NaN) is passed, this function panics.
0000000000000000000000000000000000000000;;	func MustNewPoint(name string, tags Tags, fields Fields, time time.Time) Point {
0000000000000000000000000000000000000000;;		pt, err := NewPoint(name, tags, fields, time)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) Data() []byte {
0000000000000000000000000000000000000000;;		return p.data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) SetData(b []byte) {
0000000000000000000000000000000000000000;;		p.data = b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) Key() []byte {
0000000000000000000000000000000000000000;;		return p.key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) name() []byte {
0000000000000000000000000000000000000000;;		_, name := scanTo(p.key, 0, ',')
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name return the measurement name for the point
0000000000000000000000000000000000000000;;	func (p *point) Name() string {
0000000000000000000000000000000000000000;;		if p.cachedName != "" {
0000000000000000000000000000000000000000;;			return p.cachedName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cachedName = string(escape.Unescape(p.name()))
0000000000000000000000000000000000000000;;		return p.cachedName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetName updates the measurement name for the point
0000000000000000000000000000000000000000;;	func (p *point) SetName(name string) {
0000000000000000000000000000000000000000;;		p.cachedName = ""
0000000000000000000000000000000000000000;;		p.key = MakeKey([]byte(name), p.Tags())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time return the timestamp for the point
0000000000000000000000000000000000000000;;	func (p *point) Time() time.Time {
0000000000000000000000000000000000000000;;		return p.time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTime updates the timestamp for the point
0000000000000000000000000000000000000000;;	func (p *point) SetTime(t time.Time) {
0000000000000000000000000000000000000000;;		p.time = t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Round implements Point.Round
0000000000000000000000000000000000000000;;	func (p *point) Round(d time.Duration) {
0000000000000000000000000000000000000000;;		p.time = p.time.Round(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tags returns the tag set for the point
0000000000000000000000000000000000000000;;	func (p *point) Tags() Tags {
0000000000000000000000000000000000000000;;		if p.cachedTags != nil {
0000000000000000000000000000000000000000;;			return p.cachedTags
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cachedTags = parseTags(p.key)
0000000000000000000000000000000000000000;;		return p.cachedTags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseTags(buf []byte) Tags {
0000000000000000000000000000000000000000;;		if len(buf) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pos, name := scanTo(buf, 0, ',')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// it's an empty key, so there are no tags
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tags := make(Tags, 0, bytes.Count(buf, []byte(",")))
0000000000000000000000000000000000000000;;		hasEscape := bytes.IndexByte(buf, '\\') != -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := pos + 1
0000000000000000000000000000000000000000;;		var key, value []byte
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i >= len(buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i, key = scanTo(buf, i, '=')
0000000000000000000000000000000000000000;;			i, value = scanTagValue(buf, i+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(value) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hasEscape {
0000000000000000000000000000000000000000;;				tags = append(tags, Tag{Key: unescapeTag(key), Value: unescapeTag(value)})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tags = append(tags, Tag{Key: key, Value: value})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeKey creates a key for a set of tags.
0000000000000000000000000000000000000000;;	func MakeKey(name []byte, tags Tags) []byte {
0000000000000000000000000000000000000000;;		// unescape the name and then re-escape it to avoid double escaping.
0000000000000000000000000000000000000000;;		// The key should always be stored in escaped form.
0000000000000000000000000000000000000000;;		return append(escapeMeasurement(unescapeMeasurement(name)), tags.HashKey()...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTags replaces the tags for the point
0000000000000000000000000000000000000000;;	func (p *point) SetTags(tags Tags) {
0000000000000000000000000000000000000000;;		p.key = MakeKey([]byte(p.Name()), tags)
0000000000000000000000000000000000000000;;		p.cachedTags = tags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddTag adds or replaces a tag value for a point
0000000000000000000000000000000000000000;;	func (p *point) AddTag(key, value string) {
0000000000000000000000000000000000000000;;		tags := p.Tags()
0000000000000000000000000000000000000000;;		tags = append(tags, Tag{Key: []byte(key), Value: []byte(value)})
0000000000000000000000000000000000000000;;		sort.Sort(tags)
0000000000000000000000000000000000000000;;		p.cachedTags = tags
0000000000000000000000000000000000000000;;		p.key = MakeKey([]byte(p.Name()), tags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fields returns the fields for the point
0000000000000000000000000000000000000000;;	func (p *point) Fields() Fields {
0000000000000000000000000000000000000000;;		if p.cachedFields != nil {
0000000000000000000000000000000000000000;;			return p.cachedFields
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cachedFields = p.unmarshalBinary()
0000000000000000000000000000000000000000;;		return p.cachedFields
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPrecision will round a time to the specified precision
0000000000000000000000000000000000000000;;	func (p *point) SetPrecision(precision string) {
0000000000000000000000000000000000000000;;		switch precision {
0000000000000000000000000000000000000000;;		case "n":
0000000000000000000000000000000000000000;;		case "u":
0000000000000000000000000000000000000000;;			p.SetTime(p.Time().Truncate(time.Microsecond))
0000000000000000000000000000000000000000;;		case "ms":
0000000000000000000000000000000000000000;;			p.SetTime(p.Time().Truncate(time.Millisecond))
0000000000000000000000000000000000000000;;		case "s":
0000000000000000000000000000000000000000;;			p.SetTime(p.Time().Truncate(time.Second))
0000000000000000000000000000000000000000;;		case "m":
0000000000000000000000000000000000000000;;			p.SetTime(p.Time().Truncate(time.Minute))
0000000000000000000000000000000000000000;;		case "h":
0000000000000000000000000000000000000000;;			p.SetTime(p.Time().Truncate(time.Hour))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) String() string {
0000000000000000000000000000000000000000;;		if p.Time().IsZero() {
0000000000000000000000000000000000000000;;			return string(p.Key()) + " " + string(p.fields)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(p.Key()) + " " + string(p.fields) + " " + strconv.FormatInt(p.UnixNano(), 10)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendString implements Point.AppendString
0000000000000000000000000000000000000000;;	func (p *point) AppendString(buf []byte) []byte {
0000000000000000000000000000000000000000;;		buf = append(buf, p.key...)
0000000000000000000000000000000000000000;;		buf = append(buf, ' ')
0000000000000000000000000000000000000000;;		buf = append(buf, p.fields...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !p.time.IsZero() {
0000000000000000000000000000000000000000;;			buf = append(buf, ' ')
0000000000000000000000000000000000000000;;			buf = strconv.AppendInt(buf, p.UnixNano(), 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) StringSize() int {
0000000000000000000000000000000000000000;;		size := len(p.key) + len(p.fields) + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !p.time.IsZero() {
0000000000000000000000000000000000000000;;			digits := 1 // even "0" has one digit
0000000000000000000000000000000000000000;;			t := p.UnixNano()
0000000000000000000000000000000000000000;;			if t < 0 {
0000000000000000000000000000000000000000;;				// account for negative sign, then negate
0000000000000000000000000000000000000000;;				digits++
0000000000000000000000000000000000000000;;				t = -t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for t > 9 { // already accounted for one digit
0000000000000000000000000000000000000000;;				digits++
0000000000000000000000000000000000000000;;				t /= 10
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			size += digits + 1 // digits and a space
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) MarshalBinary() ([]byte, error) {
0000000000000000000000000000000000000000;;		tb, err := p.time.MarshalBinary()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, 8+len(p.key)+len(p.fields)+len(tb))
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(b[i:], uint32(len(p.key)))
0000000000000000000000000000000000000000;;		i += 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i += copy(b[i:], p.key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(b[i:i+4], uint32(len(p.fields)))
0000000000000000000000000000000000000000;;		i += 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i += copy(b[i:], p.fields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(b[i:], tb)
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) UnmarshalBinary(b []byte) error {
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		keyLen := int(binary.BigEndian.Uint32(b[:4]))
0000000000000000000000000000000000000000;;		i += int(4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.key = b[i : i+keyLen]
0000000000000000000000000000000000000000;;		i += keyLen
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldLen := int(binary.BigEndian.Uint32(b[i : i+4]))
0000000000000000000000000000000000000000;;		i += int(4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.fields = b[i : i+fieldLen]
0000000000000000000000000000000000000000;;		i += fieldLen
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.time = time.Now()
0000000000000000000000000000000000000000;;		p.time.UnmarshalBinary(b[i:])
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) PrecisionString(precision string) string {
0000000000000000000000000000000000000000;;		if p.Time().IsZero() {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s %s", p.Key(), string(p.fields))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s %s %d", p.Key(), string(p.fields),
0000000000000000000000000000000000000000;;			p.UnixNano()/GetPrecisionMultiplier(precision))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) RoundedString(d time.Duration) string {
0000000000000000000000000000000000000000;;		if p.Time().IsZero() {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s %s", p.Key(), string(p.fields))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s %s %d", p.Key(), string(p.fields),
0000000000000000000000000000000000000000;;			p.time.Round(d).UnixNano())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) unmarshalBinary() Fields {
0000000000000000000000000000000000000000;;		iter := p.FieldIterator()
0000000000000000000000000000000000000000;;		fields := make(Fields, 8)
0000000000000000000000000000000000000000;;		for iter.Next() {
0000000000000000000000000000000000000000;;			if len(iter.FieldKey()) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch iter.Type() {
0000000000000000000000000000000000000000;;			case Float:
0000000000000000000000000000000000000000;;				fields[string(iter.FieldKey())] = iter.FloatValue()
0000000000000000000000000000000000000000;;			case Integer:
0000000000000000000000000000000000000000;;				fields[string(iter.FieldKey())] = iter.IntegerValue()
0000000000000000000000000000000000000000;;			case String:
0000000000000000000000000000000000000000;;				fields[string(iter.FieldKey())] = iter.StringValue()
0000000000000000000000000000000000000000;;			case Boolean:
0000000000000000000000000000000000000000;;				fields[string(iter.FieldKey())] = iter.BooleanValue()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fields
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) HashID() uint64 {
0000000000000000000000000000000000000000;;		h := NewInlineFNV64a()
0000000000000000000000000000000000000000;;		h.Write(p.key)
0000000000000000000000000000000000000000;;		sum := h.Sum64()
0000000000000000000000000000000000000000;;		return sum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) UnixNano() int64 {
0000000000000000000000000000000000000000;;		return p.Time().UnixNano()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) Split(size int) []Point {
0000000000000000000000000000000000000000;;		if p.time.IsZero() || len(p.String()) <= size {
0000000000000000000000000000000000000000;;			return []Point{p}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// key string, timestamp string, spaces
0000000000000000000000000000000000000000;;		size -= len(p.key) + len(strconv.FormatInt(p.time.UnixNano(), 10)) + 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var points []Point
0000000000000000000000000000000000000000;;		var start, cur int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for cur < len(p.fields) {
0000000000000000000000000000000000000000;;			end, _ := scanTo(p.fields, cur, '=')
0000000000000000000000000000000000000000;;			end, _ = scanFieldValue(p.fields, end+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cur > start && end-start > size {
0000000000000000000000000000000000000000;;				points = append(points, &point{
0000000000000000000000000000000000000000;;					key:    p.key,
0000000000000000000000000000000000000000;;					time:   p.time,
0000000000000000000000000000000000000000;;					fields: p.fields[start : cur-1],
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				start = cur
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cur = end + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		points = append(points, &point{
0000000000000000000000000000000000000000;;			key:    p.key,
0000000000000000000000000000000000000000;;			time:   p.time,
0000000000000000000000000000000000000000;;			fields: p.fields[start:],
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return points
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tag represents a single key/value tag pair.
0000000000000000000000000000000000000000;;	type Tag struct {
0000000000000000000000000000000000000000;;		Key   []byte
0000000000000000000000000000000000000000;;		Value []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tags represents a sorted list of tags.
0000000000000000000000000000000000000000;;	type Tags []Tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTags returns a new Tags from a map.
0000000000000000000000000000000000000000;;	func NewTags(m map[string]string) Tags {
0000000000000000000000000000000000000000;;		if len(m) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := make(Tags, 0, len(m))
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			a = append(a, Tag{Key: []byte(k), Value: []byte(v)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(a)
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Tags) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a Tags) Less(i, j int) bool { return bytes.Compare(a[i].Key, a[j].Key) == -1 }
0000000000000000000000000000000000000000;;	func (a Tags) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the value for a key.
0000000000000000000000000000000000000000;;	func (a Tags) Get(key []byte) []byte {
0000000000000000000000000000000000000000;;		// OPTIMIZE: Use sort.Search if tagset is large.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, t := range a {
0000000000000000000000000000000000000000;;			if bytes.Equal(t.Key, key) {
0000000000000000000000000000000000000000;;				return t.Value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetString returns the string value for a string key.
0000000000000000000000000000000000000000;;	func (a Tags) GetString(key string) string {
0000000000000000000000000000000000000000;;		return string(a.Get([]byte(key)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets the value for a key.
0000000000000000000000000000000000000000;;	func (a *Tags) Set(key, value []byte) {
0000000000000000000000000000000000000000;;		for _, t := range *a {
0000000000000000000000000000000000000000;;			if bytes.Equal(t.Key, key) {
0000000000000000000000000000000000000000;;				t.Value = value
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*a = append(*a, Tag{Key: key, Value: value})
0000000000000000000000000000000000000000;;		sort.Sort(*a)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetString sets the string value for a string key.
0000000000000000000000000000000000000000;;	func (a *Tags) SetString(key, value string) {
0000000000000000000000000000000000000000;;		a.Set([]byte(key), []byte(value))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes a tag by key.
0000000000000000000000000000000000000000;;	func (a *Tags) Delete(key []byte) {
0000000000000000000000000000000000000000;;		for i, t := range *a {
0000000000000000000000000000000000000000;;			if bytes.Equal(t.Key, key) {
0000000000000000000000000000000000000000;;				copy((*a)[i:], (*a)[i+1:])
0000000000000000000000000000000000000000;;				(*a)[len(*a)-1] = Tag{}
0000000000000000000000000000000000000000;;				*a = (*a)[:len(*a)-1]
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map returns a map representation of the tags.
0000000000000000000000000000000000000000;;	func (a Tags) Map() map[string]string {
0000000000000000000000000000000000000000;;		m := make(map[string]string, len(a))
0000000000000000000000000000000000000000;;		for _, t := range a {
0000000000000000000000000000000000000000;;			m[string(t.Key)] = string(t.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge merges the tags combining the two. If both define a tag with the
0000000000000000000000000000000000000000;;	// same key, the merged value overwrites the old value.
0000000000000000000000000000000000000000;;	// A new map is returned.
0000000000000000000000000000000000000000;;	func (a Tags) Merge(other map[string]string) Tags {
0000000000000000000000000000000000000000;;		merged := make(map[string]string, len(a)+len(other))
0000000000000000000000000000000000000000;;		for _, t := range a {
0000000000000000000000000000000000000000;;			merged[string(t.Key)] = string(t.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range other {
0000000000000000000000000000000000000000;;			merged[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewTags(merged)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashKey hashes all of a tag's keys.
0000000000000000000000000000000000000000;;	func (a Tags) HashKey() []byte {
0000000000000000000000000000000000000000;;		// Empty maps marshal to empty bytes.
0000000000000000000000000000000000000000;;		if len(a) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		escaped := make(Tags, 0, len(a))
0000000000000000000000000000000000000000;;		for _, t := range a {
0000000000000000000000000000000000000000;;			ek := escapeTag(t.Key)
0000000000000000000000000000000000000000;;			ev := escapeTag(t.Value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(ev) > 0 {
0000000000000000000000000000000000000000;;				escaped = append(escaped, Tag{Key: ek, Value: ev})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extract keys and determine final size.
0000000000000000000000000000000000000000;;		sz := len(escaped) + (len(escaped) * 2) // separators
0000000000000000000000000000000000000000;;		keys := make([][]byte, len(escaped)+1)
0000000000000000000000000000000000000000;;		for i, t := range escaped {
0000000000000000000000000000000000000000;;			keys[i] = t.Key
0000000000000000000000000000000000000000;;			sz += len(t.Key) + len(t.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keys = keys[:len(escaped)]
0000000000000000000000000000000000000000;;		sort.Sort(byteSlices(keys))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate marshaled bytes.
0000000000000000000000000000000000000000;;		b := make([]byte, sz)
0000000000000000000000000000000000000000;;		buf := b
0000000000000000000000000000000000000000;;		idx := 0
0000000000000000000000000000000000000000;;		for i, k := range keys {
0000000000000000000000000000000000000000;;			buf[idx] = ','
0000000000000000000000000000000000000000;;			idx++
0000000000000000000000000000000000000000;;			copy(buf[idx:idx+len(k)], k)
0000000000000000000000000000000000000000;;			idx += len(k)
0000000000000000000000000000000000000000;;			buf[idx] = '='
0000000000000000000000000000000000000000;;			idx++
0000000000000000000000000000000000000000;;			v := escaped[i].Value
0000000000000000000000000000000000000000;;			copy(buf[idx:idx+len(v)], v)
0000000000000000000000000000000000000000;;			idx += len(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b[:idx]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fields represents a mapping between a Point's field names and their
0000000000000000000000000000000000000000;;	// values.
0000000000000000000000000000000000000000;;	type Fields map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseNumber(val []byte) (interface{}, error) {
0000000000000000000000000000000000000000;;		if val[len(val)-1] == 'i' {
0000000000000000000000000000000000000000;;			val = val[:len(val)-1]
0000000000000000000000000000000000000000;;			return parseIntBytes(val, 10, 64)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(val); i++ {
0000000000000000000000000000000000000000;;			// If there is a decimal or an N (NaN), I (Inf), parse as float
0000000000000000000000000000000000000000;;			if val[i] == '.' || val[i] == 'N' || val[i] == 'n' || val[i] == 'I' || val[i] == 'i' || val[i] == 'e' {
0000000000000000000000000000000000000000;;				return parseFloatBytes(val, 64)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if val[i] < '0' && val[i] > '9' {
0000000000000000000000000000000000000000;;				return string(val), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseFloatBytes(val, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) FieldIterator() FieldIterator {
0000000000000000000000000000000000000000;;		p.Reset()
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldIterator struct {
0000000000000000000000000000000000000000;;		start, end  int
0000000000000000000000000000000000000000;;		key, keybuf []byte
0000000000000000000000000000000000000000;;		valueBuf    []byte
0000000000000000000000000000000000000000;;		fieldType   FieldType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) Next() bool {
0000000000000000000000000000000000000000;;		p.it.start = p.it.end
0000000000000000000000000000000000000000;;		if p.it.start >= len(p.fields) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.it.end, p.it.key = scanTo(p.fields, p.it.start, '=')
0000000000000000000000000000000000000000;;		if escape.IsEscaped(p.it.key) {
0000000000000000000000000000000000000000;;			p.it.keybuf = escape.AppendUnescaped(p.it.keybuf[:0], p.it.key)
0000000000000000000000000000000000000000;;			p.it.key = p.it.keybuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.it.end, p.it.valueBuf = scanFieldValue(p.fields, p.it.end+1)
0000000000000000000000000000000000000000;;		p.it.end++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(p.it.valueBuf) == 0 {
0000000000000000000000000000000000000000;;			p.it.fieldType = Empty
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := p.it.valueBuf[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c == '"' {
0000000000000000000000000000000000000000;;			p.it.fieldType = String
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.IndexByte(`0123456789-.nNiI`, c) >= 0 {
0000000000000000000000000000000000000000;;			if p.it.valueBuf[len(p.it.valueBuf)-1] == 'i' {
0000000000000000000000000000000000000000;;				p.it.fieldType = Integer
0000000000000000000000000000000000000000;;				p.it.valueBuf = p.it.valueBuf[:len(p.it.valueBuf)-1]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.it.fieldType = Float
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// to keep the same behavior that currently exists, default to boolean
0000000000000000000000000000000000000000;;		p.it.fieldType = Boolean
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) FieldKey() []byte {
0000000000000000000000000000000000000000;;		return p.it.key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) Type() FieldType {
0000000000000000000000000000000000000000;;		return p.it.fieldType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) StringValue() string {
0000000000000000000000000000000000000000;;		return unescapeStringField(string(p.it.valueBuf[1 : len(p.it.valueBuf)-1]))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) IntegerValue() int64 {
0000000000000000000000000000000000000000;;		n, err := parseIntBytes(p.it.valueBuf, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unable to parse integer value %q: %v", p.it.valueBuf, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) BooleanValue() bool {
0000000000000000000000000000000000000000;;		b, err := parseBoolBytes(p.it.valueBuf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unable to parse bool value %q: %v", p.it.valueBuf, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) FloatValue() float64 {
0000000000000000000000000000000000000000;;		f, err := parseFloatBytes(p.it.valueBuf, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// panic because that's what the non-iterator code does
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unable to parse floating point value %q: %v", p.it.valueBuf, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) Delete() {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case p.it.end == p.it.start:
0000000000000000000000000000000000000000;;		case p.it.end >= len(p.fields):
0000000000000000000000000000000000000000;;			p.fields = p.fields[:p.it.start]
0000000000000000000000000000000000000000;;		case p.it.start == 0:
0000000000000000000000000000000000000000;;			p.fields = p.fields[p.it.end:]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			p.fields = append(p.fields[:p.it.start], p.fields[p.it.end:]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.it.end = p.it.start
0000000000000000000000000000000000000000;;		p.it.key = nil
0000000000000000000000000000000000000000;;		p.it.valueBuf = nil
0000000000000000000000000000000000000000;;		p.it.fieldType = Empty
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *point) Reset() {
0000000000000000000000000000000000000000;;		p.it.fieldType = Empty
0000000000000000000000000000000000000000;;		p.it.key = nil
0000000000000000000000000000000000000000;;		p.it.valueBuf = nil
0000000000000000000000000000000000000000;;		p.it.start = 0
0000000000000000000000000000000000000000;;		p.it.end = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalBinary encodes all the fields to their proper type and returns the binary
0000000000000000000000000000000000000000;;	// represenation
0000000000000000000000000000000000000000;;	// NOTE: uint64 is specifically not supported due to potential overflow when we decode
0000000000000000000000000000000000000000;;	// again later to an int64
0000000000000000000000000000000000000000;;	// NOTE2: uint is accepted, and may be 64 bits, and is for some reason accepted...
0000000000000000000000000000000000000000;;	func (p Fields) MarshalBinary() []byte {
0000000000000000000000000000000000000000;;		var b []byte
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(p))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := range p {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Not really necessary, can probably be removed.
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, k := range keys {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				b = append(b, ',')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b = appendField(b, k, p[k])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendField(b []byte, k string, v interface{}) []byte {
0000000000000000000000000000000000000000;;		b = append(b, []byte(escape.String(k))...)
0000000000000000000000000000000000000000;;		b = append(b, '=')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check popular types first
0000000000000000000000000000000000000000;;		switch v := v.(type) {
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			b = strconv.AppendFloat(b, v, 'f', -1, 64)
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, v, 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			b = append(b, '"')
0000000000000000000000000000000000000000;;			b = append(b, []byte(EscapeStringField(v))...)
0000000000000000000000000000000000000000;;			b = append(b, '"')
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			b = strconv.AppendBool(b, v)
0000000000000000000000000000000000000000;;		case int32:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case int16:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case int8:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case int:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case uint32:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case uint16:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case uint8:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		// TODO: 'uint' should be considered just as "dangerous" as a uint64,
0000000000000000000000000000000000000000;;		// perhaps the value should be checked and capped at MaxInt64? We could
0000000000000000000000000000000000000000;;		// then include uint64 as an accepted value
0000000000000000000000000000000000000000;;		case uint:
0000000000000000000000000000000000000000;;			b = strconv.AppendInt(b, int64(v), 10)
0000000000000000000000000000000000000000;;			b = append(b, 'i')
0000000000000000000000000000000000000000;;		case float32:
0000000000000000000000000000000000000000;;			b = strconv.AppendFloat(b, float64(v), 'f', -1, 32)
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			b = append(b, v...)
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			// skip
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Can't determine the type, so convert to string
0000000000000000000000000000000000000000;;			b = append(b, '"')
0000000000000000000000000000000000000000;;			b = append(b, []byte(EscapeStringField(fmt.Sprintf("%v", v)))...)
0000000000000000000000000000000000000000;;			b = append(b, '"')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byteSlices [][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a byteSlices) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a byteSlices) Less(i, j int) bool { return bytes.Compare(a[i], a[j]) == -1 }
0000000000000000000000000000000000000000;;	func (a byteSlices) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
