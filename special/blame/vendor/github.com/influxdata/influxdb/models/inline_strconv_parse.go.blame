0000000000000000000000000000000000000000;;	package models
cf78d6f9c105a96842189a7e8b713a3f65a7abac;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseIntBytes is a zero-alloc wrapper around strconv.ParseInt.
0000000000000000000000000000000000000000;;	func parseIntBytes(b []byte, base int, bitSize int) (i int64, err error) {
0000000000000000000000000000000000000000;;		s := unsafeBytesToString(b)
0000000000000000000000000000000000000000;;		return strconv.ParseInt(s, base, bitSize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseFloatBytes is a zero-alloc wrapper around strconv.ParseFloat.
0000000000000000000000000000000000000000;;	func parseFloatBytes(b []byte, bitSize int) (float64, error) {
0000000000000000000000000000000000000000;;		s := unsafeBytesToString(b)
0000000000000000000000000000000000000000;;		return strconv.ParseFloat(s, bitSize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseBoolBytes is a zero-alloc wrapper around strconv.ParseBool.
0000000000000000000000000000000000000000;;	func parseBoolBytes(b []byte) (bool, error) {
0000000000000000000000000000000000000000;;		return strconv.ParseBool(unsafeBytesToString(b))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unsafeBytesToString converts a []byte to a string without a heap allocation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is unsafe, and is intended to prepare input to short-lived functions
0000000000000000000000000000000000000000;;	// that require strings.
0000000000000000000000000000000000000000;;	func unsafeBytesToString(in []byte) string {
0000000000000000000000000000000000000000;;		src := *(*reflect.SliceHeader)(unsafe.Pointer(&in))
0000000000000000000000000000000000000000;;		dst := reflect.StringHeader{
0000000000000000000000000000000000000000;;			Data: src.Data,
0000000000000000000000000000000000000000;;			Len:  src.Len,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := *(*string)(unsafe.Pointer(&dst))
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
