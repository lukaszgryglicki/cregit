0000000000000000000000000000000000000000;;	package models
98fa85693d398f10e97b3f66d66f93eefb348cf6;;	
0000000000000000000000000000000000000000;;	// Helper time methods since parsing time can easily overflow and we only support a
0000000000000000000000000000000000000000;;	// specific time range.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// MinNanoTime is the minumum time that can be represented.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 1677-09-21 00:12:43.145224194 +0000 UTC
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The two lowest minimum integers are used as sentinel values.  The
0000000000000000000000000000000000000000;;		// minimum value needs to be used as a value lower than any other value for
0000000000000000000000000000000000000000;;		// comparisons and another separate value is needed to act as a sentinel
0000000000000000000000000000000000000000;;		// default value that is unusable by the user, but usable internally.
0000000000000000000000000000000000000000;;		// Because these two values need to be used for a special purpose, we do
0000000000000000000000000000000000000000;;		// not allow users to write points at these two times.
0000000000000000000000000000000000000000;;		MinNanoTime = int64(math.MinInt64) + 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxNanoTime is the maximum time that can be represented.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 2262-04-11 23:47:16.854775806 +0000 UTC
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The highest time represented by a nanosecond needs to be used for an
0000000000000000000000000000000000000000;;		// exclusive range in the shard group, so the maximum time needs to be one
0000000000000000000000000000000000000000;;		// less than the possible maximum number of nanoseconds representable by an
0000000000000000000000000000000000000000;;		// int64 so that we don't lose a point at that one time.
0000000000000000000000000000000000000000;;		MaxNanoTime = int64(math.MaxInt64) - 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		minNanoTime = time.Unix(0, MinNanoTime).UTC()
0000000000000000000000000000000000000000;;		maxNanoTime = time.Unix(0, MaxNanoTime).UTC()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrTimeOutOfRange gets returned when time is out of the representable range using int64 nanoseconds since the epoch.
0000000000000000000000000000000000000000;;		ErrTimeOutOfRange = fmt.Errorf("time outside range %d - %d", MinNanoTime, MaxNanoTime)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SafeCalcTime safely calculates the time given. Will return error if the time is outside the
0000000000000000000000000000000000000000;;	// supported range.
0000000000000000000000000000000000000000;;	func SafeCalcTime(timestamp int64, precision string) (time.Time, error) {
0000000000000000000000000000000000000000;;		mult := GetPrecisionMultiplier(precision)
0000000000000000000000000000000000000000;;		if t, ok := safeSignedMult(timestamp, mult); ok {
0000000000000000000000000000000000000000;;			tme := time.Unix(0, t).UTC()
0000000000000000000000000000000000000000;;			return tme, CheckTime(tme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return time.Time{}, ErrTimeOutOfRange
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckTime checks that a time is within the safe range.
0000000000000000000000000000000000000000;;	func CheckTime(t time.Time) error {
0000000000000000000000000000000000000000;;		if t.Before(minNanoTime) || t.After(maxNanoTime) {
0000000000000000000000000000000000000000;;			return ErrTimeOutOfRange
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Perform the multiplication and check to make sure it didn't overflow.
0000000000000000000000000000000000000000;;	func safeSignedMult(a, b int64) (int64, bool) {
0000000000000000000000000000000000000000;;		if a == 0 || b == 0 || a == 1 || b == 1 {
0000000000000000000000000000000000000000;;			return a * b, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a == MinNanoTime || b == MaxNanoTime {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := a * b
0000000000000000000000000000000000000000;;		return c, c/b == a
0000000000000000000000000000000000000000;;	}
