0000000000000000000000000000000000000000;;	package models
cf78d6f9c105a96842189a7e8b713a3f65a7abac;;	
0000000000000000000000000000000000000000;;	type Statistic struct {
0000000000000000000000000000000000000000;;		Name   string                 `json:"name"`
0000000000000000000000000000000000000000;;		Tags   map[string]string      `json:"tags"`
0000000000000000000000000000000000000000;;		Values map[string]interface{} `json:"values"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStatistic(name string) Statistic {
0000000000000000000000000000000000000000;;		return Statistic{
0000000000000000000000000000000000000000;;			Name:   name,
0000000000000000000000000000000000000000;;			Tags:   make(map[string]string),
0000000000000000000000000000000000000000;;			Values: make(map[string]interface{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatisticTags is a map that can be merged with others without causing
0000000000000000000000000000000000000000;;	// mutations to either map.
0000000000000000000000000000000000000000;;	type StatisticTags map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge creates a new map containing the merged contents of tags and t.
0000000000000000000000000000000000000000;;	// If both tags and the receiver map contain the same key, the value in tags
0000000000000000000000000000000000000000;;	// is used in the resulting map.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Merge always returns a usable map.
0000000000000000000000000000000000000000;;	func (t StatisticTags) Merge(tags map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		// Add everything in tags to the result.
0000000000000000000000000000000000000000;;		out := make(map[string]string, len(tags))
0000000000000000000000000000000000000000;;		for k, v := range tags {
0000000000000000000000000000000000000000;;			out[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only add values from t that don't appear in tags.
0000000000000000000000000000000000000000;;		for k, v := range t {
0000000000000000000000000000000000000000;;			if _, ok := tags[k]; !ok {
0000000000000000000000000000000000000000;;				out[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
