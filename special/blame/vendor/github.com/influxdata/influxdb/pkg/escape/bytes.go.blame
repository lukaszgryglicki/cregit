0000000000000000000000000000000000000000;;	package escape
98fa85693d398f10e97b3f66d66f93eefb348cf6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Bytes(in []byte) []byte {
0000000000000000000000000000000000000000;;		for b, esc := range Codes {
0000000000000000000000000000000000000000;;			in = bytes.Replace(in, []byte{b}, esc, -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const escapeChars = `," =`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsEscaped(b []byte) bool {
0000000000000000000000000000000000000000;;		for len(b) > 0 {
0000000000000000000000000000000000000000;;			i := bytes.IndexByte(b, '\\')
0000000000000000000000000000000000000000;;			if i < 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i+1 < len(b) && strings.IndexByte(escapeChars, b[i+1]) >= 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b = b[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AppendUnescaped(dst, src []byte) []byte {
0000000000000000000000000000000000000000;;		var pos int
0000000000000000000000000000000000000000;;		for len(src) > 0 {
0000000000000000000000000000000000000000;;			next := bytes.IndexByte(src[pos:], '\\')
0000000000000000000000000000000000000000;;			if next < 0 || pos+next+1 >= len(src) {
0000000000000000000000000000000000000000;;				return append(dst, src...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pos+next+1 < len(src) && strings.IndexByte(escapeChars, src[pos+next+1]) >= 0 {
0000000000000000000000000000000000000000;;				if pos+next > 0 {
0000000000000000000000000000000000000000;;					dst = append(dst, src[:pos+next]...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				src = src[pos+next+1:]
0000000000000000000000000000000000000000;;				pos = 0
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pos += next + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Unescape(in []byte) []byte {
0000000000000000000000000000000000000000;;		if len(in) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bytes.IndexByte(in, '\\') == -1 {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		inLen := len(in)
0000000000000000000000000000000000000000;;		var out []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i >= inLen {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if in[i] == '\\' && i+1 < inLen {
0000000000000000000000000000000000000000;;				switch in[i+1] {
0000000000000000000000000000000000000000;;				case ',':
0000000000000000000000000000000000000000;;					out = append(out, ',')
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case '"':
0000000000000000000000000000000000000000;;					out = append(out, '"')
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case ' ':
0000000000000000000000000000000000000000;;					out = append(out, ' ')
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case '=':
0000000000000000000000000000000000000000;;					out = append(out, '=')
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, in[i])
0000000000000000000000000000000000000000;;			i += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
