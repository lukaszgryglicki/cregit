0000000000000000000000000000000000000000;;	package client
cf78d6f9c105a96842189a7e8b713a3f65a7abac;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/influxdata/influxdb/models"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPConfig is the config data needed to create an HTTP Client
0000000000000000000000000000000000000000;;	type HTTPConfig struct {
0000000000000000000000000000000000000000;;		// Addr should be of the form "http://host:port"
0000000000000000000000000000000000000000;;		// or "http://[ipv6-host%zone]:port".
0000000000000000000000000000000000000000;;		Addr string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Username is the influxdb username, optional
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Password is the influxdb password, optional
0000000000000000000000000000000000000000;;		Password string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserAgent is the http User Agent, defaults to "InfluxDBClient"
0000000000000000000000000000000000000000;;		UserAgent string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Timeout for influxdb writes, defaults to no timeout
0000000000000000000000000000000000000000;;		Timeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InsecureSkipVerify gets passed to the http client, if true, it will
0000000000000000000000000000000000000000;;		// skip https certificate verification. Defaults to false
0000000000000000000000000000000000000000;;		InsecureSkipVerify bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSConfig allows the user to set their own TLS config for the HTTP
0000000000000000000000000000000000000000;;		// Client. If set, this option overrides InsecureSkipVerify.
0000000000000000000000000000000000000000;;		TLSConfig *tls.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BatchPointsConfig is the config data needed to create an instance of the BatchPoints struct
0000000000000000000000000000000000000000;;	type BatchPointsConfig struct {
0000000000000000000000000000000000000000;;		// Precision is the write precision of the points, defaults to "ns"
0000000000000000000000000000000000000000;;		Precision string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Database is the database to write points to
0000000000000000000000000000000000000000;;		Database string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RetentionPolicy is the retention policy of the points
0000000000000000000000000000000000000000;;		RetentionPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write consistency is the number of servers required to confirm write
0000000000000000000000000000000000000000;;		WriteConsistency string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client is a client interface for writing & querying the database
0000000000000000000000000000000000000000;;	type Client interface {
0000000000000000000000000000000000000000;;		// Ping checks that status of cluster, and will always return 0 time and no
0000000000000000000000000000000000000000;;		// error for UDP clients
0000000000000000000000000000000000000000;;		Ping(timeout time.Duration) (time.Duration, string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write takes a BatchPoints object and writes all Points to InfluxDB.
0000000000000000000000000000000000000000;;		Write(bp BatchPoints) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Query makes an InfluxDB Query on the database. This will fail if using
0000000000000000000000000000000000000000;;		// the UDP client.
0000000000000000000000000000000000000000;;		Query(q Query) (*Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close releases any resources a Client may be using.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHTTPClient returns a new Client from the provided config.
0000000000000000000000000000000000000000;;	// Client is safe for concurrent use by multiple goroutines.
0000000000000000000000000000000000000000;;	func NewHTTPClient(conf HTTPConfig) (Client, error) {
0000000000000000000000000000000000000000;;		if conf.UserAgent == "" {
0000000000000000000000000000000000000000;;			conf.UserAgent = "InfluxDBClient"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u, err := url.Parse(conf.Addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if u.Scheme != "http" && u.Scheme != "https" {
0000000000000000000000000000000000000000;;			m := fmt.Sprintf("Unsupported protocol scheme: %s, your address"+
0000000000000000000000000000000000000000;;				" must start with http:// or https://", u.Scheme)
0000000000000000000000000000000000000000;;			return nil, errors.New(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr := &http.Transport{
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;				InsecureSkipVerify: conf.InsecureSkipVerify,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if conf.TLSConfig != nil {
0000000000000000000000000000000000000000;;			tr.TLSClientConfig = conf.TLSConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &client{
0000000000000000000000000000000000000000;;			url:       *u,
0000000000000000000000000000000000000000;;			username:  conf.Username,
0000000000000000000000000000000000000000;;			password:  conf.Password,
0000000000000000000000000000000000000000;;			useragent: conf.UserAgent,
0000000000000000000000000000000000000000;;			httpClient: &http.Client{
0000000000000000000000000000000000000000;;				Timeout:   conf.Timeout,
0000000000000000000000000000000000000000;;				Transport: tr,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			transport: tr,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ping will check to see if the server is up with an optional timeout on waiting for leader.
0000000000000000000000000000000000000000;;	// Ping returns how long the request took, the version of the server it connected to, and an error if one occurred.
0000000000000000000000000000000000000000;;	func (c *client) Ping(timeout time.Duration) (time.Duration, string, error) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		u := c.url
0000000000000000000000000000000000000000;;		u.Path = "ping"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", u.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", c.useragent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.username != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if timeout > 0 {
0000000000000000000000000000000000000000;;			params := req.URL.Query()
0000000000000000000000000000000000000000;;			params.Set("wait_for_leader", fmt.Sprintf("%.0fs", timeout.Seconds()))
0000000000000000000000000000000000000000;;			req.URL.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusNoContent {
0000000000000000000000000000000000000000;;			var err = fmt.Errorf(string(body))
0000000000000000000000000000000000000000;;			return 0, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version := resp.Header.Get("X-Influxdb-Version")
0000000000000000000000000000000000000000;;		return time.Since(now), version, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close releases the client's resources.
0000000000000000000000000000000000000000;;	func (c *client) Close() error {
0000000000000000000000000000000000000000;;		c.transport.CloseIdleConnections()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// client is safe for concurrent use as the fields are all read-only
0000000000000000000000000000000000000000;;	// once the client is instantiated.
0000000000000000000000000000000000000000;;	type client struct {
0000000000000000000000000000000000000000;;		// N.B - if url.UserInfo is accessed in future modifications to the
0000000000000000000000000000000000000000;;		// methods on client, you will need to syncronise access to url.
0000000000000000000000000000000000000000;;		url        url.URL
0000000000000000000000000000000000000000;;		username   string
0000000000000000000000000000000000000000;;		password   string
0000000000000000000000000000000000000000;;		useragent  string
0000000000000000000000000000000000000000;;		httpClient *http.Client
0000000000000000000000000000000000000000;;		transport  *http.Transport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BatchPoints is an interface into a batched grouping of points to write into
0000000000000000000000000000000000000000;;	// InfluxDB together. BatchPoints is NOT thread-safe, you must create a separate
0000000000000000000000000000000000000000;;	// batch for each goroutine.
0000000000000000000000000000000000000000;;	type BatchPoints interface {
0000000000000000000000000000000000000000;;		// AddPoint adds the given point to the Batch of points
0000000000000000000000000000000000000000;;		AddPoint(p *Point)
0000000000000000000000000000000000000000;;		// AddPoints adds the given points to the Batch of points
0000000000000000000000000000000000000000;;		AddPoints(ps []*Point)
0000000000000000000000000000000000000000;;		// Points lists the points in the Batch
0000000000000000000000000000000000000000;;		Points() []*Point
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Precision returns the currently set precision of this Batch
0000000000000000000000000000000000000000;;		Precision() string
0000000000000000000000000000000000000000;;		// SetPrecision sets the precision of this batch.
0000000000000000000000000000000000000000;;		SetPrecision(s string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Database returns the currently set database of this Batch
0000000000000000000000000000000000000000;;		Database() string
0000000000000000000000000000000000000000;;		// SetDatabase sets the database of this Batch
0000000000000000000000000000000000000000;;		SetDatabase(s string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WriteConsistency returns the currently set write consistency of this Batch
0000000000000000000000000000000000000000;;		WriteConsistency() string
0000000000000000000000000000000000000000;;		// SetWriteConsistency sets the write consistency of this Batch
0000000000000000000000000000000000000000;;		SetWriteConsistency(s string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RetentionPolicy returns the currently set retention policy of this Batch
0000000000000000000000000000000000000000;;		RetentionPolicy() string
0000000000000000000000000000000000000000;;		// SetRetentionPolicy sets the retention policy of this Batch
0000000000000000000000000000000000000000;;		SetRetentionPolicy(s string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBatchPoints returns a BatchPoints interface based on the given config.
0000000000000000000000000000000000000000;;	func NewBatchPoints(conf BatchPointsConfig) (BatchPoints, error) {
0000000000000000000000000000000000000000;;		if conf.Precision == "" {
0000000000000000000000000000000000000000;;			conf.Precision = "ns"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := time.ParseDuration("1" + conf.Precision); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bp := &batchpoints{
0000000000000000000000000000000000000000;;			database:         conf.Database,
0000000000000000000000000000000000000000;;			precision:        conf.Precision,
0000000000000000000000000000000000000000;;			retentionPolicy:  conf.RetentionPolicy,
0000000000000000000000000000000000000000;;			writeConsistency: conf.WriteConsistency,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type batchpoints struct {
0000000000000000000000000000000000000000;;		points           []*Point
0000000000000000000000000000000000000000;;		database         string
0000000000000000000000000000000000000000;;		precision        string
0000000000000000000000000000000000000000;;		retentionPolicy  string
0000000000000000000000000000000000000000;;		writeConsistency string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) AddPoint(p *Point) {
0000000000000000000000000000000000000000;;		bp.points = append(bp.points, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) AddPoints(ps []*Point) {
0000000000000000000000000000000000000000;;		bp.points = append(bp.points, ps...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) Points() []*Point {
0000000000000000000000000000000000000000;;		return bp.points
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) Precision() string {
0000000000000000000000000000000000000000;;		return bp.precision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) Database() string {
0000000000000000000000000000000000000000;;		return bp.database
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) WriteConsistency() string {
0000000000000000000000000000000000000000;;		return bp.writeConsistency
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) RetentionPolicy() string {
0000000000000000000000000000000000000000;;		return bp.retentionPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) SetPrecision(p string) error {
0000000000000000000000000000000000000000;;		if _, err := time.ParseDuration("1" + p); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bp.precision = p
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) SetDatabase(db string) {
0000000000000000000000000000000000000000;;		bp.database = db
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) SetWriteConsistency(wc string) {
0000000000000000000000000000000000000000;;		bp.writeConsistency = wc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bp *batchpoints) SetRetentionPolicy(rp string) {
0000000000000000000000000000000000000000;;		bp.retentionPolicy = rp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Point represents a single data point
0000000000000000000000000000000000000000;;	type Point struct {
0000000000000000000000000000000000000000;;		pt models.Point
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPoint returns a point with the given timestamp. If a timestamp is not
0000000000000000000000000000000000000000;;	// given, then data is sent to the database without a timestamp, in which case
0000000000000000000000000000000000000000;;	// the server will assign local time upon reception. NOTE: it is recommended to
0000000000000000000000000000000000000000;;	// send data with a timestamp.
0000000000000000000000000000000000000000;;	func NewPoint(
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		tags map[string]string,
0000000000000000000000000000000000000000;;		fields map[string]interface{},
0000000000000000000000000000000000000000;;		t ...time.Time,
0000000000000000000000000000000000000000;;	) (*Point, error) {
0000000000000000000000000000000000000000;;		var T time.Time
0000000000000000000000000000000000000000;;		if len(t) > 0 {
0000000000000000000000000000000000000000;;			T = t[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pt, err := models.NewPoint(name, models.NewTags(tags), fields, T)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Point{
0000000000000000000000000000000000000000;;			pt: pt,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a line-protocol string of the Point
0000000000000000000000000000000000000000;;	func (p *Point) String() string {
0000000000000000000000000000000000000000;;		return p.pt.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrecisionString returns a line-protocol string of the Point, at precision
0000000000000000000000000000000000000000;;	func (p *Point) PrecisionString(precison string) string {
0000000000000000000000000000000000000000;;		return p.pt.PrecisionString(precison)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the measurement name of the point
0000000000000000000000000000000000000000;;	func (p *Point) Name() string {
0000000000000000000000000000000000000000;;		return p.pt.Name()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tags returns the tags associated with the point
0000000000000000000000000000000000000000;;	func (p *Point) Tags() map[string]string {
0000000000000000000000000000000000000000;;		return p.pt.Tags().Map()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time return the timestamp for the point
0000000000000000000000000000000000000000;;	func (p *Point) Time() time.Time {
0000000000000000000000000000000000000000;;		return p.pt.Time()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnixNano returns the unix nano time of the point
0000000000000000000000000000000000000000;;	func (p *Point) UnixNano() int64 {
0000000000000000000000000000000000000000;;		return p.pt.UnixNano()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fields returns the fields for the point
0000000000000000000000000000000000000000;;	func (p *Point) Fields() map[string]interface{} {
0000000000000000000000000000000000000000;;		return p.pt.Fields()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPointFrom returns a point from the provided models.Point.
0000000000000000000000000000000000000000;;	func NewPointFrom(pt models.Point) *Point {
0000000000000000000000000000000000000000;;		return &Point{pt: pt}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *client) Write(bp BatchPoints) error {
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range bp.Points() {
0000000000000000000000000000000000000000;;			if _, err := b.WriteString(p.pt.PrecisionString(bp.Precision())); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := b.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u := c.url
0000000000000000000000000000000000000000;;		u.Path = "write"
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", u.String(), &b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "")
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", c.useragent)
0000000000000000000000000000000000000000;;		if c.username != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := req.URL.Query()
0000000000000000000000000000000000000000;;		params.Set("db", bp.Database())
0000000000000000000000000000000000000000;;		params.Set("rp", bp.RetentionPolicy())
0000000000000000000000000000000000000000;;		params.Set("precision", bp.Precision())
0000000000000000000000000000000000000000;;		params.Set("consistency", bp.WriteConsistency())
0000000000000000000000000000000000000000;;		req.URL.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			var err = fmt.Errorf(string(body))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query defines a query to send to the server
0000000000000000000000000000000000000000;;	type Query struct {
0000000000000000000000000000000000000000;;		Command   string
0000000000000000000000000000000000000000;;		Database  string
0000000000000000000000000000000000000000;;		Precision string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewQuery returns a query object
0000000000000000000000000000000000000000;;	// database and precision strings can be empty strings if they are not needed
0000000000000000000000000000000000000000;;	// for the query.
0000000000000000000000000000000000000000;;	func NewQuery(command, database, precision string) Query {
0000000000000000000000000000000000000000;;		return Query{
0000000000000000000000000000000000000000;;			Command:   command,
0000000000000000000000000000000000000000;;			Database:  database,
0000000000000000000000000000000000000000;;			Precision: precision,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Response represents a list of statement results.
0000000000000000000000000000000000000000;;	type Response struct {
0000000000000000000000000000000000000000;;		Results []Result
0000000000000000000000000000000000000000;;		Err     string `json:"error,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the first error from any statement.
0000000000000000000000000000000000000000;;	// Returns nil if no errors occurred on any statements.
0000000000000000000000000000000000000000;;	func (r *Response) Error() error {
0000000000000000000000000000000000000000;;		if r.Err != "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf(r.Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, result := range r.Results {
0000000000000000000000000000000000000000;;			if result.Err != "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf(result.Err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Message represents a user message.
0000000000000000000000000000000000000000;;	type Message struct {
0000000000000000000000000000000000000000;;		Level string
0000000000000000000000000000000000000000;;		Text  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Result represents a resultset returned from a single statement.
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		Series   []models.Row
0000000000000000000000000000000000000000;;		Messages []*Message
0000000000000000000000000000000000000000;;		Err      string `json:"error,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query sends a command to the server and returns the Response
0000000000000000000000000000000000000000;;	func (c *client) Query(q Query) (*Response, error) {
0000000000000000000000000000000000000000;;		u := c.url
0000000000000000000000000000000000000000;;		u.Path = "query"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", u.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "")
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", c.useragent)
0000000000000000000000000000000000000000;;		if c.username != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := req.URL.Query()
0000000000000000000000000000000000000000;;		params.Set("q", q.Command)
0000000000000000000000000000000000000000;;		params.Set("db", q.Database)
0000000000000000000000000000000000000000;;		if q.Precision != "" {
0000000000000000000000000000000000000000;;			params.Set("epoch", q.Precision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.URL.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response Response
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(resp.Body)
0000000000000000000000000000000000000000;;		dec.UseNumber()
0000000000000000000000000000000000000000;;		decErr := dec.Decode(&response)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ignore this error if we got an invalid status code
0000000000000000000000000000000000000000;;		if decErr != nil && decErr.Error() == "EOF" && resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			decErr = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we got a valid decode error, send that back
0000000000000000000000000000000000000000;;		if decErr != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to decode json: received status code %d err: %s", resp.StatusCode, decErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we don't have an error in our json response, and didn't get statusOK
0000000000000000000000000000000000000000;;		// then send back an error
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK && response.Error() == nil {
0000000000000000000000000000000000000000;;			return &response, fmt.Errorf("received status code %d from server",
0000000000000000000000000000000000000000;;				resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &response, nil
0000000000000000000000000000000000000000;;	}
