0000000000000000000000000000000000000000;;	package client
cf78d6f9c105a96842189a7e8b713a3f65a7abac;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// UDPPayloadSize is a reasonable default payload size for UDP packets that
0000000000000000000000000000000000000000;;		// could be travelling over the internet.
0000000000000000000000000000000000000000;;		UDPPayloadSize = 512
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UDPConfig is the config data needed to create a UDP Client
0000000000000000000000000000000000000000;;	type UDPConfig struct {
0000000000000000000000000000000000000000;;		// Addr should be of the form "host:port"
0000000000000000000000000000000000000000;;		// or "[ipv6-host%zone]:port".
0000000000000000000000000000000000000000;;		Addr string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PayloadSize is the maximum size of a UDP client message, optional
0000000000000000000000000000000000000000;;		// Tune this based on your network. Defaults to UDPPayloadSize.
0000000000000000000000000000000000000000;;		PayloadSize int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUDPClient returns a client interface for writing to an InfluxDB UDP
0000000000000000000000000000000000000000;;	// service from the given config.
0000000000000000000000000000000000000000;;	func NewUDPClient(conf UDPConfig) (Client, error) {
0000000000000000000000000000000000000000;;		var udpAddr *net.UDPAddr
0000000000000000000000000000000000000000;;		udpAddr, err := net.ResolveUDPAddr("udp", conf.Addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := net.DialUDP("udp", nil, udpAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payloadSize := conf.PayloadSize
0000000000000000000000000000000000000000;;		if payloadSize == 0 {
0000000000000000000000000000000000000000;;			payloadSize = UDPPayloadSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &udpclient{
0000000000000000000000000000000000000000;;			conn:        conn,
0000000000000000000000000000000000000000;;			payloadSize: payloadSize,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close releases the udpclient's resources.
0000000000000000000000000000000000000000;;	func (uc *udpclient) Close() error {
0000000000000000000000000000000000000000;;		return uc.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type udpclient struct {
0000000000000000000000000000000000000000;;		conn        io.WriteCloser
0000000000000000000000000000000000000000;;		payloadSize int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (uc *udpclient) Write(bp BatchPoints) error {
0000000000000000000000000000000000000000;;		var b = make([]byte, 0, uc.payloadSize) // initial buffer size, it will grow as needed
0000000000000000000000000000000000000000;;		var d, _ = time.ParseDuration("1" + bp.Precision())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var delayedError error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var checkBuffer = func(n int) {
0000000000000000000000000000000000000000;;			if len(b) > 0 && len(b)+n > uc.payloadSize {
0000000000000000000000000000000000000000;;				if _, err := uc.conn.Write(b); err != nil {
0000000000000000000000000000000000000000;;					delayedError = err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b = b[:0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range bp.Points() {
0000000000000000000000000000000000000000;;			p.pt.Round(d)
0000000000000000000000000000000000000000;;			pointSize := p.pt.StringSize() + 1 // include newline in size
0000000000000000000000000000000000000000;;			//point := p.pt.RoundedString(d) + "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			checkBuffer(pointSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.Time().IsZero() || pointSize <= uc.payloadSize {
0000000000000000000000000000000000000000;;				b = p.pt.AppendString(b)
0000000000000000000000000000000000000000;;				b = append(b, '\n')
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			points := p.pt.Split(uc.payloadSize - 1) // account for newline character
0000000000000000000000000000000000000000;;			for _, sp := range points {
0000000000000000000000000000000000000000;;				checkBuffer(sp.StringSize() + 1)
0000000000000000000000000000000000000000;;				b = sp.AppendString(b)
0000000000000000000000000000000000000000;;				b = append(b, '\n')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b) > 0 {
0000000000000000000000000000000000000000;;			if _, err := uc.conn.Write(b); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return delayedError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (uc *udpclient) Query(q Query) (*Response, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Querying via UDP is not supported")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (uc *udpclient) Ping(timeout time.Duration) (time.Duration, string, error) {
0000000000000000000000000000000000000000;;		return 0, "", nil
0000000000000000000000000000000000000000;;	}
