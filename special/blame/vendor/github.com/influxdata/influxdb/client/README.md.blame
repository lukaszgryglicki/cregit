0000000000000000000000000000000000000000;;	# InfluxDB Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![GoDoc](https://godoc.org/github.com/influxdata/influxdb?status.svg)](http://godoc.org/github.com/influxdata/influxdb/client/v2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Description
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**NOTE:** The Go client library now has a "v2" version, with the old version
0000000000000000000000000000000000000000;;	being deprecated. The new version can be imported at
0000000000000000000000000000000000000000;;	`import "github.com/influxdata/influxdb/client/v2"`. It is not backwards-compatible.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A Go client library written and maintained by the **InfluxDB** team.
0000000000000000000000000000000000000000;;	This package provides convenience functions to read and write time series data.
0000000000000000000000000000000000000000;;	It uses the HTTP protocol to communicate with your **InfluxDB** cluster.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Getting Started
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Connecting To Your Database
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Connecting to an **InfluxDB** database is straightforward. You will need a host
0000000000000000000000000000000000000000;;	name, a port and the cluster user credentials if applicable. The default port is
0000000000000000000000000000000000000000;;	8086. You can customize these settings to your specific installation via the
0000000000000000000000000000000000000000;;	**InfluxDB** configuration file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Though not necessary for experimentation, you may want to create a new user
0000000000000000000000000000000000000000;;	and authenticate the connection to your database.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For more information please check out the
0000000000000000000000000000000000000000;;	[Admin Docs](https://docs.influxdata.com/influxdb/latest/administration/).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For the impatient, you can create a new admin user _bubba_ by firing off the
0000000000000000000000000000000000000000;;	[InfluxDB CLI](https://github.com/influxdata/influxdb/blob/master/cmd/influx/main.go).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```shell
0000000000000000000000000000000000000000;;	influx
0000000000000000000000000000000000000000;;	> create user bubba with password 'bumblebeetuna'
0000000000000000000000000000000000000000;;	> grant all privileges to bubba
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	And now for good measure set the credentials in you shell environment.
0000000000000000000000000000000000000000;;	In the example below we will use $INFLUX_USER and $INFLUX_PWD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now with the administrivia out of the way, let's connect to our database.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	NOTE: If you've opted out of creating a user, you can omit Username and Password in
0000000000000000000000000000000000000000;;	the configuration below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/influxdata/influxdb/client/v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MyDB = "square_holes"
0000000000000000000000000000000000000000;;		username = "bubba"
0000000000000000000000000000000000000000;;		password = "bumblebeetuna"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		// Make client
0000000000000000000000000000000000000000;;		c, err := client.NewHTTPClient(client.HTTPConfig{
0000000000000000000000000000000000000000;;			Addr: "http://localhost:8086",
0000000000000000000000000000000000000000;;			Username: username,
0000000000000000000000000000000000000000;;			Password: password,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;		    log.Fatalln("Error: ", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new point batch
0000000000000000000000000000000000000000;;		bp, err := client.NewBatchPoints(client.BatchPointsConfig{
0000000000000000000000000000000000000000;;			Database:  MyDB,
0000000000000000000000000000000000000000;;			Precision: "s",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;		    log.Fatalln("Error: ", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a point and add to batch
0000000000000000000000000000000000000000;;		tags := map[string]string{"cpu": "cpu-total"}
0000000000000000000000000000000000000000;;		fields := map[string]interface{}{
0000000000000000000000000000000000000000;;			"idle":   10.1,
0000000000000000000000000000000000000000;;			"system": 53.3,
0000000000000000000000000000000000000000;;			"user":   46.6,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pt, err := client.NewPoint("cpu_usage", tags, fields, time.Now())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;		    log.Fatalln("Error: ", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bp.AddPoint(pt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the batch
0000000000000000000000000000000000000000;;		c.Write(bp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Inserting Data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Time series data aka *points* are written to the database using batch inserts.
0000000000000000000000000000000000000000;;	The mechanism is to create one or more points and then create a batch aka
0000000000000000000000000000000000000000;;	*batch points* and write these to a given database and series. A series is a
0000000000000000000000000000000000000000;;	combination of a measurement (time/values) and a set of tags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In this sample we will create a batch of a 1,000 points. Each point has a time and
0000000000000000000000000000000000000000;;	a single value as well as 2 tags indicating a shape and color. We write these points
0000000000000000000000000000000000000000;;	to a database called _square_holes_ using a measurement named _shapes_.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	NOTE: You can specify a RetentionPolicy as part of the batch points. If not
0000000000000000000000000000000000000000;;	provided InfluxDB will use the database _default_ retention policy.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func writePoints(clnt client.Client) {
0000000000000000000000000000000000000000;;		sampleSize := 1000
0000000000000000000000000000000000000000;;		rand.Seed(42)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bp, _ := client.NewBatchPoints(client.BatchPointsConfig{
0000000000000000000000000000000000000000;;			Database:  "systemstats",
0000000000000000000000000000000000000000;;			Precision: "us",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < sampleSize; i++ {
0000000000000000000000000000000000000000;;			regions := []string{"us-west1", "us-west2", "us-west3", "us-east1"}
0000000000000000000000000000000000000000;;			tags := map[string]string{
0000000000000000000000000000000000000000;;				"cpu":    "cpu-total",
0000000000000000000000000000000000000000;;				"host":   fmt.Sprintf("host%d", rand.Intn(1000)),
0000000000000000000000000000000000000000;;				"region": regions[rand.Intn(len(regions))],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			idle := rand.Float64() * 100.0
0000000000000000000000000000000000000000;;			fields := map[string]interface{}{
0000000000000000000000000000000000000000;;				"idle": idle,
0000000000000000000000000000000000000000;;				"busy": 100.0 - idle,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			bp.AddPoint(client.NewPoint(
0000000000000000000000000000000000000000;;				"cpu_usage",
0000000000000000000000000000000000000000;;				tags,
0000000000000000000000000000000000000000;;				fields,
0000000000000000000000000000000000000000;;				time.Now(),
0000000000000000000000000000000000000000;;			))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := clnt.Write(bp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Querying Data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	One nice advantage of using **InfluxDB** the ability to query your data using familiar
0000000000000000000000000000000000000000;;	SQL constructs. In this example we can create a convenience function to query the database
0000000000000000000000000000000000000000;;	as follows:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// queryDB convenience function to query the database
0000000000000000000000000000000000000000;;	func queryDB(clnt client.Client, cmd string) (res []client.Result, err error) {
0000000000000000000000000000000000000000;;		q := client.Query{
0000000000000000000000000000000000000000;;			Command:  cmd,
0000000000000000000000000000000000000000;;			Database: MyDB,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if response, err := clnt.Query(q); err == nil {
0000000000000000000000000000000000000000;;			if response.Error() != nil {
0000000000000000000000000000000000000000;;				return res, response.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res = response.Results
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Creating a Database
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	_, err := queryDB(clnt, fmt.Sprintf("CREATE DATABASE %s", MyDB))
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		log.Fatal(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Count Records
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	q := fmt.Sprintf("SELECT count(%s) FROM %s", "value", MyMeasurement)
0000000000000000000000000000000000000000;;	res, err := queryDB(clnt, q)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		log.Fatal(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	count := res[0].Series[0].Values[0][1]
0000000000000000000000000000000000000000;;	log.Printf("Found a total of %v records\n", count)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Find the last 10 _shapes_ records
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	q := fmt.Sprintf("SELECT * FROM %s LIMIT %d", MyMeasurement, 20)
0000000000000000000000000000000000000000;;	res, err = queryDB(clnt, q)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		log.Fatal(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	for i, row := range res[0].Series[0].Values {
0000000000000000000000000000000000000000;;		t, err := time.Parse(time.RFC3339, row[0].(string))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := row[1].(string)
0000000000000000000000000000000000000000;;		log.Printf("[%2d] %s: %s\n", i, t.Format(time.Stamp), val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Using the UDP Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The **InfluxDB** client also supports writing over UDP.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func WriteUDP() {
0000000000000000000000000000000000000000;;		// Make client
0000000000000000000000000000000000000000;;		c := client.NewUDPClient("localhost:8089")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new point batch
0000000000000000000000000000000000000000;;		bp, _ := client.NewBatchPoints(client.BatchPointsConfig{
0000000000000000000000000000000000000000;;			Precision: "s",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a point and add to batch
0000000000000000000000000000000000000000;;		tags := map[string]string{"cpu": "cpu-total"}
0000000000000000000000000000000000000000;;		fields := map[string]interface{}{
0000000000000000000000000000000000000000;;			"idle":   10.1,
0000000000000000000000000000000000000000;;			"system": 53.3,
0000000000000000000000000000000000000000;;			"user":   46.6,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pt, err := client.NewPoint("cpu_usage", tags, fields, time.Now())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bp.AddPoint(pt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the batch
0000000000000000000000000000000000000000;;		c.Write(bp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Point Splitting
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The UDP client now supports splitting single points that exceed the configured
0000000000000000000000000000000000000000;;	payload size. The logic for processing each point is listed here, starting with
0000000000000000000000000000000000000000;;	an empty payload.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. If adding the point to the current (non-empty) payload would exceed the
0000000000000000000000000000000000000000;;	   configured size, send the current payload. Otherwise, add it to the current
0000000000000000000000000000000000000000;;	   payload.
0000000000000000000000000000000000000000;;	1. If the point is smaller than the configured size, add it to the payload.
0000000000000000000000000000000000000000;;	1. If the point has no timestamp, just try to send the entire point as a single
0000000000000000000000000000000000000000;;	   UDP payload, and process the next point.
0000000000000000000000000000000000000000;;	1. Since the point has a timestamp, re-use the existing measurement name,
0000000000000000000000000000000000000000;;	   tagset, and timestamp and create multiple new points by splitting up the
0000000000000000000000000000000000000000;;	   fields. The per-point length will be kept close to the configured size,
0000000000000000000000000000000000000000;;	   staying under it if possible. This does mean that one large field, maybe a
0000000000000000000000000000000000000000;;	   long string, could be sent as a larger-than-configured payload.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The above logic attempts to respect configured payload sizes, but not sacrifice
0000000000000000000000000000000000000000;;	any data integrity. Points without a timestamp can't be split, as that may
0000000000000000000000000000000000000000;;	cause fields to have differing timestamps when processed by the server.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Go Docs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Please refer to
0000000000000000000000000000000000000000;;	[http://godoc.org/github.com/influxdata/influxdb/client/v2](http://godoc.org/github.com/influxdata/influxdb/client/v2)
0000000000000000000000000000000000000000;;	for documentation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## See Also
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also examine how the client library is used by the
0000000000000000000000000000000000000000;;	[InfluxDB CLI](https://github.com/influxdata/influxdb/blob/master/cmd/influx/main.go).
