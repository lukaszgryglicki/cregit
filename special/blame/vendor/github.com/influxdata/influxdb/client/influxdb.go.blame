0000000000000000000000000000000000000000;;	package client
9f57a9117d3b09f98d6f501fa0f8e16f2f53df4b;Godeps/_workspace/src/github.com/influxdb/influxdb/client/influxdb.go[Godeps/_workspace/src/github.com/influxdb/influxdb/client/influxdb.go][vendor/github.com/influxdata/influxdb/client/influxdb.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/influxdata/influxdb/models"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultHost is the default host used to connect to an InfluxDB instance
0000000000000000000000000000000000000000;;		DefaultHost = "localhost"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultPort is the default port used to connect to an InfluxDB instance
0000000000000000000000000000000000000000;;		DefaultPort = 8086
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultTimeout is the default connection timeout used to connect to an InfluxDB instance
0000000000000000000000000000000000000000;;		DefaultTimeout = 0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query is used to send a command to the server. Both Command and Database are required.
0000000000000000000000000000000000000000;;	type Query struct {
0000000000000000000000000000000000000000;;		Command  string
0000000000000000000000000000000000000000;;		Database string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Chunked tells the server to send back chunked responses. This places
0000000000000000000000000000000000000000;;		// less load on the server by sending back chunks of the response rather
0000000000000000000000000000000000000000;;		// than waiting for the entire response all at once.
0000000000000000000000000000000000000000;;		Chunked bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ChunkSize sets the maximum number of rows that will be returned per
0000000000000000000000000000000000000000;;		// chunk. Chunks are either divided based on their series or if they hit
0000000000000000000000000000000000000000;;		// the chunk size limit.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Chunked must be set to true for this option to be used.
0000000000000000000000000000000000000000;;		ChunkSize int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseConnectionString will parse a string to create a valid connection URL
0000000000000000000000000000000000000000;;	func ParseConnectionString(path string, ssl bool) (url.URL, error) {
0000000000000000000000000000000000000000;;		var host string
0000000000000000000000000000000000000000;;		var port int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h, p, err := net.SplitHostPort(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if path == "" {
0000000000000000000000000000000000000000;;				host = DefaultHost
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				host = path
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If they didn't specify a port, always use the default port
0000000000000000000000000000000000000000;;			port = DefaultPort
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			host = h
0000000000000000000000000000000000000000;;			port, err = strconv.Atoi(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return url.URL{}, fmt.Errorf("invalid port number %q: %s\n", path, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u := url.URL{
0000000000000000000000000000000000000000;;			Scheme: "http",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ssl {
0000000000000000000000000000000000000000;;			u.Scheme = "https"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.Host = net.JoinHostPort(host, strconv.Itoa(port))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config is used to specify what server to connect to.
0000000000000000000000000000000000000000;;	// URL: The URL of the server connecting to.
0000000000000000000000000000000000000000;;	// Username/Password are optional. They will be passed via basic auth if provided.
0000000000000000000000000000000000000000;;	// UserAgent: If not provided, will default "InfluxDBClient",
0000000000000000000000000000000000000000;;	// Timeout: If not provided, will default to 0 (no timeout)
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		URL       url.URL
0000000000000000000000000000000000000000;;		Username  string
0000000000000000000000000000000000000000;;		Password  string
0000000000000000000000000000000000000000;;		UserAgent string
0000000000000000000000000000000000000000;;		Timeout   time.Duration
0000000000000000000000000000000000000000;;		Precision string
0000000000000000000000000000000000000000;;		UnsafeSsl bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConfig will create a config to be used in connecting to the client
0000000000000000000000000000000000000000;;	func NewConfig() Config {
0000000000000000000000000000000000000000;;		return Config{
0000000000000000000000000000000000000000;;			Timeout: DefaultTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client is used to make calls to the server.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		url        url.URL
0000000000000000000000000000000000000000;;		username   string
0000000000000000000000000000000000000000;;		password   string
0000000000000000000000000000000000000000;;		httpClient *http.Client
0000000000000000000000000000000000000000;;		userAgent  string
0000000000000000000000000000000000000000;;		precision  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ConsistencyOne requires at least one data node acknowledged a write.
0000000000000000000000000000000000000000;;		ConsistencyOne = "one"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConsistencyAll requires all data nodes to acknowledge a write.
0000000000000000000000000000000000000000;;		ConsistencyAll = "all"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConsistencyQuorum requires a quorum of data nodes to acknowledge a write.
0000000000000000000000000000000000000000;;		ConsistencyQuorum = "quorum"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConsistencyAny allows for hinted hand off, potentially no write happened yet.
0000000000000000000000000000000000000000;;		ConsistencyAny = "any"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient will instantiate and return a connected client to issue commands to the server.
0000000000000000000000000000000000000000;;	func NewClient(c Config) (*Client, error) {
0000000000000000000000000000000000000000;;		tlsConfig := &tls.Config{
0000000000000000000000000000000000000000;;			InsecureSkipVerify: c.UnsafeSsl,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr := &http.Transport{
0000000000000000000000000000000000000000;;			TLSClientConfig: tlsConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := Client{
0000000000000000000000000000000000000000;;			url:        c.URL,
0000000000000000000000000000000000000000;;			username:   c.Username,
0000000000000000000000000000000000000000;;			password:   c.Password,
0000000000000000000000000000000000000000;;			httpClient: &http.Client{Timeout: c.Timeout, Transport: tr},
0000000000000000000000000000000000000000;;			userAgent:  c.UserAgent,
0000000000000000000000000000000000000000;;			precision:  c.Precision,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if client.userAgent == "" {
0000000000000000000000000000000000000000;;			client.userAgent = "InfluxDBClient"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAuth will update the username and passwords
0000000000000000000000000000000000000000;;	func (c *Client) SetAuth(u, p string) {
0000000000000000000000000000000000000000;;		c.username = u
0000000000000000000000000000000000000000;;		c.password = p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPrecision will update the precision
0000000000000000000000000000000000000000;;	func (c *Client) SetPrecision(precision string) {
0000000000000000000000000000000000000000;;		c.precision = precision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query sends a command to the server and returns the Response
0000000000000000000000000000000000000000;;	func (c *Client) Query(q Query) (*Response, error) {
0000000000000000000000000000000000000000;;		u := c.url
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.Path = "query"
0000000000000000000000000000000000000000;;		values := u.Query()
0000000000000000000000000000000000000000;;		values.Set("q", q.Command)
0000000000000000000000000000000000000000;;		values.Set("db", q.Database)
0000000000000000000000000000000000000000;;		if q.Chunked {
0000000000000000000000000000000000000000;;			values.Set("chunked", "true")
0000000000000000000000000000000000000000;;			if q.ChunkSize > 0 {
0000000000000000000000000000000000000000;;				values.Set("chunk_size", strconv.Itoa(q.ChunkSize))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.precision != "" {
0000000000000000000000000000000000000000;;			values.Set("epoch", c.precision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.RawQuery = values.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", u.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", c.userAgent)
0000000000000000000000000000000000000000;;		if c.username != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response Response
0000000000000000000000000000000000000000;;		if q.Chunked {
0000000000000000000000000000000000000000;;			cr := NewChunkedResponse(resp.Body)
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				r, err := cr.NextResponse()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// If we got an error while decoding the response, send that back.
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if r == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				response.Results = append(response.Results, r.Results...)
0000000000000000000000000000000000000000;;				if r.Err != nil {
0000000000000000000000000000000000000000;;					response.Err = r.Err
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dec := json.NewDecoder(resp.Body)
0000000000000000000000000000000000000000;;			dec.UseNumber()
0000000000000000000000000000000000000000;;			if err := dec.Decode(&response); err != nil {
0000000000000000000000000000000000000000;;				// Ignore EOF errors if we got an invalid status code.
0000000000000000000000000000000000000000;;				if !(err == io.EOF && resp.StatusCode != http.StatusOK) {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we don't have an error in our json response, and didn't get StatusOK,
0000000000000000000000000000000000000000;;		// then send back an error.
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK && response.Error() == nil {
0000000000000000000000000000000000000000;;			return &response, fmt.Errorf("received status code %d from server", resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &response, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write takes BatchPoints and allows for writing of multiple points with defaults
0000000000000000000000000000000000000000;;	// If successful, error is nil and Response is nil
0000000000000000000000000000000000000000;;	// If an error occurs, Response may contain additional information if populated.
0000000000000000000000000000000000000000;;	func (c *Client) Write(bp BatchPoints) (*Response, error) {
0000000000000000000000000000000000000000;;		u := c.url
0000000000000000000000000000000000000000;;		u.Path = "write"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		for _, p := range bp.Points {
0000000000000000000000000000000000000000;;			err := checkPointTypes(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.Raw != "" {
0000000000000000000000000000000000000000;;				if _, err := b.WriteString(p.Raw); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for k, v := range bp.Tags {
0000000000000000000000000000000000000000;;					if p.Tags == nil {
0000000000000000000000000000000000000000;;						p.Tags = make(map[string]string, len(bp.Tags))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.Tags[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := b.WriteString(p.MarshalString()); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := b.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", u.String(), &b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "")
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", c.userAgent)
0000000000000000000000000000000000000000;;		if c.username != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		precision := bp.Precision
0000000000000000000000000000000000000000;;		if precision == "" {
0000000000000000000000000000000000000000;;			precision = c.precision
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := req.URL.Query()
0000000000000000000000000000000000000000;;		params.Set("db", bp.Database)
0000000000000000000000000000000000000000;;		params.Set("rp", bp.RetentionPolicy)
0000000000000000000000000000000000000000;;		params.Set("precision", precision)
0000000000000000000000000000000000000000;;		params.Set("consistency", bp.WriteConsistency)
0000000000000000000000000000000000000000;;		req.URL.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response Response
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			var err = fmt.Errorf(string(body))
0000000000000000000000000000000000000000;;			response.Err = err
0000000000000000000000000000000000000000;;			return &response, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteLineProtocol takes a string with line returns to delimit each write
0000000000000000000000000000000000000000;;	// If successful, error is nil and Response is nil
0000000000000000000000000000000000000000;;	// If an error occurs, Response may contain additional information if populated.
0000000000000000000000000000000000000000;;	func (c *Client) WriteLineProtocol(data, database, retentionPolicy, precision, writeConsistency string) (*Response, error) {
0000000000000000000000000000000000000000;;		u := c.url
0000000000000000000000000000000000000000;;		u.Path = "write"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := strings.NewReader(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", u.String(), r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "")
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", c.userAgent)
0000000000000000000000000000000000000000;;		if c.username != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := req.URL.Query()
0000000000000000000000000000000000000000;;		params.Set("db", database)
0000000000000000000000000000000000000000;;		params.Set("rp", retentionPolicy)
0000000000000000000000000000000000000000;;		params.Set("precision", precision)
0000000000000000000000000000000000000000;;		params.Set("consistency", writeConsistency)
0000000000000000000000000000000000000000;;		req.URL.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response Response
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusNoContent && resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			err := fmt.Errorf(string(body))
0000000000000000000000000000000000000000;;			response.Err = err
0000000000000000000000000000000000000000;;			return &response, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ping will check to see if the server is up
0000000000000000000000000000000000000000;;	// Ping returns how long the request took, the version of the server it connected to, and an error if one occurred.
0000000000000000000000000000000000000000;;	func (c *Client) Ping() (time.Duration, string, error) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		u := c.url
0000000000000000000000000000000000000000;;		u.Path = "ping"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", u.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", c.userAgent)
0000000000000000000000000000000000000000;;		if c.username != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.password)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version := resp.Header.Get("X-Influxdb-Version")
0000000000000000000000000000000000000000;;		return time.Since(now), version, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Structs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Message represents a user message.
0000000000000000000000000000000000000000;;	type Message struct {
0000000000000000000000000000000000000000;;		Level string `json:"level,omitempty"`
0000000000000000000000000000000000000000;;		Text  string `json:"text,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Result represents a resultset returned from a single statement.
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		Series   []models.Row
0000000000000000000000000000000000000000;;		Messages []*Message
0000000000000000000000000000000000000000;;		Err      error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON encodes the result into JSON.
0000000000000000000000000000000000000000;;	func (r *Result) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		// Define a struct that outputs "error" as a string.
0000000000000000000000000000000000000000;;		var o struct {
0000000000000000000000000000000000000000;;			Series   []models.Row `json:"series,omitempty"`
0000000000000000000000000000000000000000;;			Messages []*Message   `json:"messages,omitempty"`
0000000000000000000000000000000000000000;;			Err      string       `json:"error,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy fields to output struct.
0000000000000000000000000000000000000000;;		o.Series = r.Series
0000000000000000000000000000000000000000;;		o.Messages = r.Messages
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			o.Err = r.Err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(&o)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON decodes the data into the Result struct
0000000000000000000000000000000000000000;;	func (r *Result) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var o struct {
0000000000000000000000000000000000000000;;			Series   []models.Row `json:"series,omitempty"`
0000000000000000000000000000000000000000;;			Messages []*Message   `json:"messages,omitempty"`
0000000000000000000000000000000000000000;;			Err      string       `json:"error,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(bytes.NewBuffer(b))
0000000000000000000000000000000000000000;;		dec.UseNumber()
0000000000000000000000000000000000000000;;		err := dec.Decode(&o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.Series = o.Series
0000000000000000000000000000000000000000;;		r.Messages = o.Messages
0000000000000000000000000000000000000000;;		if o.Err != "" {
0000000000000000000000000000000000000000;;			r.Err = errors.New(o.Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Response represents a list of statement results.
0000000000000000000000000000000000000000;;	type Response struct {
0000000000000000000000000000000000000000;;		Results []Result
0000000000000000000000000000000000000000;;		Err     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON encodes the response into JSON.
0000000000000000000000000000000000000000;;	func (r *Response) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		// Define a struct that outputs "error" as a string.
0000000000000000000000000000000000000000;;		var o struct {
0000000000000000000000000000000000000000;;			Results []Result `json:"results,omitempty"`
0000000000000000000000000000000000000000;;			Err     string   `json:"error,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy fields to output struct.
0000000000000000000000000000000000000000;;		o.Results = r.Results
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			o.Err = r.Err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(&o)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON decodes the data into the Response struct
0000000000000000000000000000000000000000;;	func (r *Response) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var o struct {
0000000000000000000000000000000000000000;;			Results []Result `json:"results,omitempty"`
0000000000000000000000000000000000000000;;			Err     string   `json:"error,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(bytes.NewBuffer(b))
0000000000000000000000000000000000000000;;		dec.UseNumber()
0000000000000000000000000000000000000000;;		err := dec.Decode(&o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.Results = o.Results
0000000000000000000000000000000000000000;;		if o.Err != "" {
0000000000000000000000000000000000000000;;			r.Err = errors.New(o.Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the first error from any statement.
0000000000000000000000000000000000000000;;	// Returns nil if no errors occurred on any statements.
0000000000000000000000000000000000000000;;	func (r *Response) Error() error {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, result := range r.Results {
0000000000000000000000000000000000000000;;			if result.Err != nil {
0000000000000000000000000000000000000000;;				return result.Err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// duplexReader reads responses and writes it to another writer while
0000000000000000000000000000000000000000;;	// satisfying the reader interface.
0000000000000000000000000000000000000000;;	type duplexReader struct {
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;		w io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *duplexReader) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, err = r.r.Read(p)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			r.w.Write(p[:n])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChunkedResponse represents a response from the server that
0000000000000000000000000000000000000000;;	// uses chunking to stream the output.
0000000000000000000000000000000000000000;;	type ChunkedResponse struct {
0000000000000000000000000000000000000000;;		dec    *json.Decoder
0000000000000000000000000000000000000000;;		duplex *duplexReader
0000000000000000000000000000000000000000;;		buf    bytes.Buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewChunkedResponse reads a stream and produces responses from the stream.
0000000000000000000000000000000000000000;;	func NewChunkedResponse(r io.Reader) *ChunkedResponse {
0000000000000000000000000000000000000000;;		resp := &ChunkedResponse{}
0000000000000000000000000000000000000000;;		resp.duplex = &duplexReader{r: r, w: &resp.buf}
0000000000000000000000000000000000000000;;		resp.dec = json.NewDecoder(resp.duplex)
0000000000000000000000000000000000000000;;		resp.dec.UseNumber()
0000000000000000000000000000000000000000;;		return resp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextResponse reads the next line of the stream and returns a response.
0000000000000000000000000000000000000000;;	func (r *ChunkedResponse) NextResponse() (*Response, error) {
0000000000000000000000000000000000000000;;		var response Response
0000000000000000000000000000000000000000;;		if err := r.dec.Decode(&response); err != nil {
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// A decoding error happened. This probably means the server crashed
0000000000000000000000000000000000000000;;			// and sent a last-ditch error message to us. Ensure we have read the
0000000000000000000000000000000000000000;;			// entirety of the connection to get any remaining error text.
0000000000000000000000000000000000000000;;			io.Copy(ioutil.Discard, r.duplex)
0000000000000000000000000000000000000000;;			return nil, errors.New(strings.TrimSpace(r.buf.String()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.buf.Reset()
0000000000000000000000000000000000000000;;		return &response, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Point defines the fields that will be written to the database
0000000000000000000000000000000000000000;;	// Measurement, Time, and Fields are required
0000000000000000000000000000000000000000;;	// Precision can be specified if the time is in epoch format (integer).
0000000000000000000000000000000000000000;;	// Valid values for Precision are n, u, ms, s, m, and h
0000000000000000000000000000000000000000;;	type Point struct {
0000000000000000000000000000000000000000;;		Measurement string
0000000000000000000000000000000000000000;;		Tags        map[string]string
0000000000000000000000000000000000000000;;		Time        time.Time
0000000000000000000000000000000000000000;;		Fields      map[string]interface{}
0000000000000000000000000000000000000000;;		Precision   string
0000000000000000000000000000000000000000;;		Raw         string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON will format the time in RFC3339Nano
0000000000000000000000000000000000000000;;	// Precision is also ignored as it is only used for writing, not reading
0000000000000000000000000000000000000000;;	// Or another way to say it is we always send back in nanosecond precision
0000000000000000000000000000000000000000;;	func (p *Point) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		point := struct {
0000000000000000000000000000000000000000;;			Measurement string                 `json:"measurement,omitempty"`
0000000000000000000000000000000000000000;;			Tags        map[string]string      `json:"tags,omitempty"`
0000000000000000000000000000000000000000;;			Time        string                 `json:"time,omitempty"`
0000000000000000000000000000000000000000;;			Fields      map[string]interface{} `json:"fields,omitempty"`
0000000000000000000000000000000000000000;;			Precision   string                 `json:"precision,omitempty"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Measurement: p.Measurement,
0000000000000000000000000000000000000000;;			Tags:        p.Tags,
0000000000000000000000000000000000000000;;			Fields:      p.Fields,
0000000000000000000000000000000000000000;;			Precision:   p.Precision,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Let it omit empty if it's really zero
0000000000000000000000000000000000000000;;		if !p.Time.IsZero() {
0000000000000000000000000000000000000000;;			point.Time = p.Time.UTC().Format(time.RFC3339Nano)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(&point)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalString renders string representation of a Point with specified
0000000000000000000000000000000000000000;;	// precision. The default precision is nanoseconds.
0000000000000000000000000000000000000000;;	func (p *Point) MarshalString() string {
0000000000000000000000000000000000000000;;		pt, err := models.NewPoint(p.Measurement, models.NewTags(p.Tags), p.Fields, p.Time)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "# ERROR: " + err.Error() + " " + p.Measurement
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Precision == "" || p.Precision == "ns" || p.Precision == "n" {
0000000000000000000000000000000000000000;;			return pt.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pt.PrecisionString(p.Precision)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON decodes the data into the Point struct
0000000000000000000000000000000000000000;;	func (p *Point) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var normal struct {
0000000000000000000000000000000000000000;;			Measurement string                 `json:"measurement"`
0000000000000000000000000000000000000000;;			Tags        map[string]string      `json:"tags"`
0000000000000000000000000000000000000000;;			Time        time.Time              `json:"time"`
0000000000000000000000000000000000000000;;			Precision   string                 `json:"precision"`
0000000000000000000000000000000000000000;;			Fields      map[string]interface{} `json:"fields"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var epoch struct {
0000000000000000000000000000000000000000;;			Measurement string                 `json:"measurement"`
0000000000000000000000000000000000000000;;			Tags        map[string]string      `json:"tags"`
0000000000000000000000000000000000000000;;			Time        *int64                 `json:"time"`
0000000000000000000000000000000000000000;;			Precision   string                 `json:"precision"`
0000000000000000000000000000000000000000;;			Fields      map[string]interface{} `json:"fields"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := func() error {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			dec := json.NewDecoder(bytes.NewBuffer(b))
0000000000000000000000000000000000000000;;			dec.UseNumber()
0000000000000000000000000000000000000000;;			if err = dec.Decode(&epoch); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Convert from epoch to time.Time, but only if Time
0000000000000000000000000000000000000000;;			// was actually set.
0000000000000000000000000000000000000000;;			var ts time.Time
0000000000000000000000000000000000000000;;			if epoch.Time != nil {
0000000000000000000000000000000000000000;;				ts, err = EpochToTime(*epoch.Time, epoch.Precision)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Measurement = epoch.Measurement
0000000000000000000000000000000000000000;;			p.Tags = epoch.Tags
0000000000000000000000000000000000000000;;			p.Time = ts
0000000000000000000000000000000000000000;;			p.Precision = epoch.Precision
0000000000000000000000000000000000000000;;			p.Fields = normalizeFields(epoch.Fields)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}(); err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(bytes.NewBuffer(b))
0000000000000000000000000000000000000000;;		dec.UseNumber()
0000000000000000000000000000000000000000;;		if err := dec.Decode(&normal); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		normal.Time = SetPrecision(normal.Time, normal.Precision)
0000000000000000000000000000000000000000;;		p.Measurement = normal.Measurement
0000000000000000000000000000000000000000;;		p.Tags = normal.Tags
0000000000000000000000000000000000000000;;		p.Time = normal.Time
0000000000000000000000000000000000000000;;		p.Precision = normal.Precision
0000000000000000000000000000000000000000;;		p.Fields = normalizeFields(normal.Fields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove any notion of json.Number
0000000000000000000000000000000000000000;;	func normalizeFields(fields map[string]interface{}) map[string]interface{} {
0000000000000000000000000000000000000000;;		newFields := map[string]interface{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range fields {
0000000000000000000000000000000000000000;;			switch v := v.(type) {
0000000000000000000000000000000000000000;;			case json.Number:
0000000000000000000000000000000000000000;;				jv, e := v.Float64()
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("unable to convert json.Number to float64: %s", e))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newFields[k] = jv
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				newFields[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newFields
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BatchPoints is used to send batched data in a single write.
0000000000000000000000000000000000000000;;	// Database and Points are required
0000000000000000000000000000000000000000;;	// If no retention policy is specified, it will use the databases default retention policy.
0000000000000000000000000000000000000000;;	// If tags are specified, they will be "merged" with all points. If a point already has that tag, it will be ignored.
0000000000000000000000000000000000000000;;	// If time is specified, it will be applied to any point with an empty time.
0000000000000000000000000000000000000000;;	// Precision can be specified if the time is in epoch format (integer).
0000000000000000000000000000000000000000;;	// Valid values for Precision are n, u, ms, s, m, and h
0000000000000000000000000000000000000000;;	type BatchPoints struct {
0000000000000000000000000000000000000000;;		Points           []Point           `json:"points,omitempty"`
0000000000000000000000000000000000000000;;		Database         string            `json:"database,omitempty"`
0000000000000000000000000000000000000000;;		RetentionPolicy  string            `json:"retentionPolicy,omitempty"`
0000000000000000000000000000000000000000;;		Tags             map[string]string `json:"tags,omitempty"`
0000000000000000000000000000000000000000;;		Time             time.Time         `json:"time,omitempty"`
0000000000000000000000000000000000000000;;		Precision        string            `json:"precision,omitempty"`
0000000000000000000000000000000000000000;;		WriteConsistency string            `json:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON decodes the data into the BatchPoints struct
0000000000000000000000000000000000000000;;	func (bp *BatchPoints) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var normal struct {
0000000000000000000000000000000000000000;;			Points          []Point           `json:"points"`
0000000000000000000000000000000000000000;;			Database        string            `json:"database"`
0000000000000000000000000000000000000000;;			RetentionPolicy string            `json:"retentionPolicy"`
0000000000000000000000000000000000000000;;			Tags            map[string]string `json:"tags"`
0000000000000000000000000000000000000000;;			Time            time.Time         `json:"time"`
0000000000000000000000000000000000000000;;			Precision       string            `json:"precision"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var epoch struct {
0000000000000000000000000000000000000000;;			Points          []Point           `json:"points"`
0000000000000000000000000000000000000000;;			Database        string            `json:"database"`
0000000000000000000000000000000000000000;;			RetentionPolicy string            `json:"retentionPolicy"`
0000000000000000000000000000000000000000;;			Tags            map[string]string `json:"tags"`
0000000000000000000000000000000000000000;;			Time            *int64            `json:"time"`
0000000000000000000000000000000000000000;;			Precision       string            `json:"precision"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := func() error {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if err = json.Unmarshal(b, &epoch); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Convert from epoch to time.Time
0000000000000000000000000000000000000000;;			var ts time.Time
0000000000000000000000000000000000000000;;			if epoch.Time != nil {
0000000000000000000000000000000000000000;;				ts, err = EpochToTime(*epoch.Time, epoch.Precision)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bp.Points = epoch.Points
0000000000000000000000000000000000000000;;			bp.Database = epoch.Database
0000000000000000000000000000000000000000;;			bp.RetentionPolicy = epoch.RetentionPolicy
0000000000000000000000000000000000000000;;			bp.Tags = epoch.Tags
0000000000000000000000000000000000000000;;			bp.Time = ts
0000000000000000000000000000000000000000;;			bp.Precision = epoch.Precision
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}(); err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &normal); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		normal.Time = SetPrecision(normal.Time, normal.Precision)
0000000000000000000000000000000000000000;;		bp.Points = normal.Points
0000000000000000000000000000000000000000;;		bp.Database = normal.Database
0000000000000000000000000000000000000000;;		bp.RetentionPolicy = normal.RetentionPolicy
0000000000000000000000000000000000000000;;		bp.Tags = normal.Tags
0000000000000000000000000000000000000000;;		bp.Time = normal.Time
0000000000000000000000000000000000000000;;		bp.Precision = normal.Precision
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// utility functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addr provides the current url as a string of the server the client is connected to.
0000000000000000000000000000000000000000;;	func (c *Client) Addr() string {
0000000000000000000000000000000000000000;;		return c.url.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkPointTypes ensures no unsupported types are submitted to influxdb, returning error if they are found.
0000000000000000000000000000000000000000;;	func checkPointTypes(p Point) error {
0000000000000000000000000000000000000000;;		for _, v := range p.Fields {
0000000000000000000000000000000000000000;;			switch v.(type) {
0000000000000000000000000000000000000000;;			case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, float32, float64, bool, string, nil:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("unsupported point type: %T", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EpochToTime takes a unix epoch time and uses precision to return back a time.Time
0000000000000000000000000000000000000000;;	func EpochToTime(epoch int64, precision string) (time.Time, error) {
0000000000000000000000000000000000000000;;		if precision == "" {
0000000000000000000000000000000000000000;;			precision = "s"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var t time.Time
0000000000000000000000000000000000000000;;		switch precision {
0000000000000000000000000000000000000000;;		case "h":
0000000000000000000000000000000000000000;;			t = time.Unix(0, epoch*int64(time.Hour))
0000000000000000000000000000000000000000;;		case "m":
0000000000000000000000000000000000000000;;			t = time.Unix(0, epoch*int64(time.Minute))
0000000000000000000000000000000000000000;;		case "s":
0000000000000000000000000000000000000000;;			t = time.Unix(0, epoch*int64(time.Second))
0000000000000000000000000000000000000000;;		case "ms":
0000000000000000000000000000000000000000;;			t = time.Unix(0, epoch*int64(time.Millisecond))
0000000000000000000000000000000000000000;;		case "u":
0000000000000000000000000000000000000000;;			t = time.Unix(0, epoch*int64(time.Microsecond))
0000000000000000000000000000000000000000;;		case "n":
0000000000000000000000000000000000000000;;			t = time.Unix(0, epoch)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return time.Time{}, fmt.Errorf("Unknown precision %q", precision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPrecision will round a time to the specified precision
0000000000000000000000000000000000000000;;	func SetPrecision(t time.Time, precision string) time.Time {
0000000000000000000000000000000000000000;;		switch precision {
0000000000000000000000000000000000000000;;		case "n":
0000000000000000000000000000000000000000;;		case "u":
0000000000000000000000000000000000000000;;			return t.Round(time.Microsecond)
0000000000000000000000000000000000000000;;		case "ms":
0000000000000000000000000000000000000000;;			return t.Round(time.Millisecond)
0000000000000000000000000000000000000000;;		case "s":
0000000000000000000000000000000000000000;;			return t.Round(time.Second)
0000000000000000000000000000000000000000;;		case "m":
0000000000000000000000000000000000000000;;			return t.Round(time.Minute)
0000000000000000000000000000000000000000;;		case "h":
0000000000000000000000000000000000000000;;			return t.Round(time.Hour)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
