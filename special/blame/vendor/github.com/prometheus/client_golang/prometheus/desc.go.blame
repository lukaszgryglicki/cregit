0000000000000000000000000000000000000000;;	// Copyright 2016 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/desc.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/desc.go][vendor/github.com/prometheus/client_golang/prometheus/desc.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/model"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reservedLabelPrefix is a prefix which is not legal in user-supplied
0000000000000000000000000000000000000000;;	// label names.
0000000000000000000000000000000000000000;;	const reservedLabelPrefix = "__"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Labels represents a collection of label name -> value mappings. This type is
0000000000000000000000000000000000000000;;	// commonly used with the With(Labels) and GetMetricWith(Labels) methods of
0000000000000000000000000000000000000000;;	// metric vector Collectors, e.g.:
0000000000000000000000000000000000000000;;	//     myVec.With(Labels{"code": "404", "method": "GET"}).Add(42)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The other use-case is the specification of constant label pairs in Opts or to
0000000000000000000000000000000000000000;;	// create a Desc.
0000000000000000000000000000000000000000;;	type Labels map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Desc is the descriptor used by every Prometheus Metric. It is essentially
0000000000000000000000000000000000000000;;	// the immutable meta-data of a Metric. The normal Metric implementations
0000000000000000000000000000000000000000;;	// included in this package manage their Desc under the hood. Users only have to
0000000000000000000000000000000000000000;;	// deal with Desc if they use advanced features like the ExpvarCollector or
0000000000000000000000000000000000000000;;	// custom Collectors and Metrics.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Descriptors registered with the same registry have to fulfill certain
0000000000000000000000000000000000000000;;	// consistency and uniqueness criteria if they share the same fully-qualified
0000000000000000000000000000000000000000;;	// name: They must have the same help string and the same label names (aka label
0000000000000000000000000000000000000000;;	// dimensions) in each, constLabels and variableLabels, but they must differ in
0000000000000000000000000000000000000000;;	// the values of the constLabels.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Descriptors that share the same fully-qualified names and the same label
0000000000000000000000000000000000000000;;	// values of their constLabels are considered equal.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use NewDesc to create new Desc instances.
0000000000000000000000000000000000000000;;	type Desc struct {
0000000000000000000000000000000000000000;;		// fqName has been built from Namespace, Subsystem, and Name.
0000000000000000000000000000000000000000;;		fqName string
0000000000000000000000000000000000000000;;		// help provides some helpful information about this metric.
0000000000000000000000000000000000000000;;		help string
0000000000000000000000000000000000000000;;		// constLabelPairs contains precalculated DTO label pairs based on
0000000000000000000000000000000000000000;;		// the constant labels.
0000000000000000000000000000000000000000;;		constLabelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;		// VariableLabels contains names of labels for which the metric
0000000000000000000000000000000000000000;;		// maintains variable values.
0000000000000000000000000000000000000000;;		variableLabels []string
0000000000000000000000000000000000000000;;		// id is a hash of the values of the ConstLabels and fqName. This
0000000000000000000000000000000000000000;;		// must be unique among all registered descriptors and can therefore be
0000000000000000000000000000000000000000;;		// used as an identifier of the descriptor.
0000000000000000000000000000000000000000;;		id uint64
0000000000000000000000000000000000000000;;		// dimHash is a hash of the label names (preset and variable) and the
0000000000000000000000000000000000000000;;		// Help string. Each Desc with the same fqName must have the same
0000000000000000000000000000000000000000;;		// dimHash.
0000000000000000000000000000000000000000;;		dimHash uint64
0000000000000000000000000000000000000000;;		// err is an error that occurred during construction. It is reported on
0000000000000000000000000000000000000000;;		// registration time.
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDesc allocates and initializes a new Desc. Errors are recorded in the Desc
0000000000000000000000000000000000000000;;	// and will be reported on registration time. variableLabels and constLabels can
0000000000000000000000000000000000000000;;	// be nil if no such labels should be set. fqName and help must not be empty.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// variableLabels only contain the label names. Their label values are variable
0000000000000000000000000000000000000000;;	// and therefore not part of the Desc. (They are managed within the Metric.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For constLabels, the label values are constant. Therefore, they are fully
0000000000000000000000000000000000000000;;	// specified in the Desc. See the Opts documentation for the implications of
0000000000000000000000000000000000000000;;	// constant labels.
0000000000000000000000000000000000000000;;	func NewDesc(fqName, help string, variableLabels []string, constLabels Labels) *Desc {
0000000000000000000000000000000000000000;;		d := &Desc{
0000000000000000000000000000000000000000;;			fqName:         fqName,
0000000000000000000000000000000000000000;;			help:           help,
0000000000000000000000000000000000000000;;			variableLabels: variableLabels,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if help == "" {
0000000000000000000000000000000000000000;;			d.err = errors.New("empty help string")
0000000000000000000000000000000000000000;;			return d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !model.IsValidMetricName(model.LabelValue(fqName)) {
0000000000000000000000000000000000000000;;			d.err = fmt.Errorf("%q is not a valid metric name", fqName)
0000000000000000000000000000000000000000;;			return d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// labelValues contains the label values of const labels (in order of
0000000000000000000000000000000000000000;;		// their sorted label names) plus the fqName (at position 0).
0000000000000000000000000000000000000000;;		labelValues := make([]string, 1, len(constLabels)+1)
0000000000000000000000000000000000000000;;		labelValues[0] = fqName
0000000000000000000000000000000000000000;;		labelNames := make([]string, 0, len(constLabels)+len(variableLabels))
0000000000000000000000000000000000000000;;		labelNameSet := map[string]struct{}{}
0000000000000000000000000000000000000000;;		// First add only the const label names and sort them...
0000000000000000000000000000000000000000;;		for labelName := range constLabels {
0000000000000000000000000000000000000000;;			if !checkLabelName(labelName) {
0000000000000000000000000000000000000000;;				d.err = fmt.Errorf("%q is not a valid label name", labelName)
0000000000000000000000000000000000000000;;				return d
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			labelNames = append(labelNames, labelName)
0000000000000000000000000000000000000000;;			labelNameSet[labelName] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(labelNames)
0000000000000000000000000000000000000000;;		// ... so that we can now add const label values in the order of their names.
0000000000000000000000000000000000000000;;		for _, labelName := range labelNames {
0000000000000000000000000000000000000000;;			labelValues = append(labelValues, constLabels[labelName])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Now add the variable label names, but prefix them with something that
0000000000000000000000000000000000000000;;		// cannot be in a regular label name. That prevents matching the label
0000000000000000000000000000000000000000;;		// dimension with a different mix between preset and variable labels.
0000000000000000000000000000000000000000;;		for _, labelName := range variableLabels {
0000000000000000000000000000000000000000;;			if !checkLabelName(labelName) {
0000000000000000000000000000000000000000;;				d.err = fmt.Errorf("%q is not a valid label name", labelName)
0000000000000000000000000000000000000000;;				return d
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			labelNames = append(labelNames, "$"+labelName)
0000000000000000000000000000000000000000;;			labelNameSet[labelName] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(labelNames) != len(labelNameSet) {
0000000000000000000000000000000000000000;;			d.err = errors.New("duplicate label names")
0000000000000000000000000000000000000000;;			return d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vh := hashNew()
0000000000000000000000000000000000000000;;		for _, val := range labelValues {
0000000000000000000000000000000000000000;;			vh = hashAdd(vh, val)
0000000000000000000000000000000000000000;;			vh = hashAddByte(vh, separatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.id = vh
0000000000000000000000000000000000000000;;		// Sort labelNames so that order doesn't matter for the hash.
0000000000000000000000000000000000000000;;		sort.Strings(labelNames)
0000000000000000000000000000000000000000;;		// Now hash together (in this order) the help string and the sorted
0000000000000000000000000000000000000000;;		// label names.
0000000000000000000000000000000000000000;;		lh := hashNew()
0000000000000000000000000000000000000000;;		lh = hashAdd(lh, help)
0000000000000000000000000000000000000000;;		lh = hashAddByte(lh, separatorByte)
0000000000000000000000000000000000000000;;		for _, labelName := range labelNames {
0000000000000000000000000000000000000000;;			lh = hashAdd(lh, labelName)
0000000000000000000000000000000000000000;;			lh = hashAddByte(lh, separatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.dimHash = lh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.constLabelPairs = make([]*dto.LabelPair, 0, len(constLabels))
0000000000000000000000000000000000000000;;		for n, v := range constLabels {
0000000000000000000000000000000000000000;;			d.constLabelPairs = append(d.constLabelPairs, &dto.LabelPair{
0000000000000000000000000000000000000000;;				Name:  proto.String(n),
0000000000000000000000000000000000000000;;				Value: proto.String(v),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(LabelPairSorter(d.constLabelPairs))
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInvalidDesc returns an invalid descriptor, i.e. a descriptor with the
0000000000000000000000000000000000000000;;	// provided error set. If a collector returning such a descriptor is registered,
0000000000000000000000000000000000000000;;	// registration will fail with the provided error. NewInvalidDesc can be used by
0000000000000000000000000000000000000000;;	// a Collector to signal inability to describe itself.
0000000000000000000000000000000000000000;;	func NewInvalidDesc(err error) *Desc {
0000000000000000000000000000000000000000;;		return &Desc{
0000000000000000000000000000000000000000;;			err: err,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Desc) String() string {
0000000000000000000000000000000000000000;;		lpStrings := make([]string, 0, len(d.constLabelPairs))
0000000000000000000000000000000000000000;;		for _, lp := range d.constLabelPairs {
0000000000000000000000000000000000000000;;			lpStrings = append(
0000000000000000000000000000000000000000;;				lpStrings,
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s=%q", lp.GetName(), lp.GetValue()),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"Desc{fqName: %q, help: %q, constLabels: {%s}, variableLabels: %v}",
0000000000000000000000000000000000000000;;			d.fqName,
0000000000000000000000000000000000000000;;			d.help,
0000000000000000000000000000000000000000;;			strings.Join(lpStrings, ","),
0000000000000000000000000000000000000000;;			d.variableLabels,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkLabelName(l string) bool {
0000000000000000000000000000000000000000;;		return model.LabelName(l).IsValid() &&
0000000000000000000000000000000000000000;;			!strings.HasPrefix(l, reservedLabelPrefix)
0000000000000000000000000000000000000000;;	}
