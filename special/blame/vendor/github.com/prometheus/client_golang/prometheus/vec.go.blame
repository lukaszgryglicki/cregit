0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/vec.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/vec.go][vendor/github.com/prometheus/client_golang/prometheus/vec.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/model"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetricVec is a Collector to bundle metrics of the same name that
0000000000000000000000000000000000000000;;	// differ in their label values. MetricVec is usually not used directly but as a
0000000000000000000000000000000000000000;;	// building block for implementations of vectors of a given metric
0000000000000000000000000000000000000000;;	// type. GaugeVec, CounterVec, SummaryVec, and UntypedVec are examples already
0000000000000000000000000000000000000000;;	// provided in this package.
0000000000000000000000000000000000000000;;	type MetricVec struct {
0000000000000000000000000000000000000000;;		mtx      sync.RWMutex // Protects the children.
0000000000000000000000000000000000000000;;		children map[uint64][]metricWithLabelValues
0000000000000000000000000000000000000000;;		desc     *Desc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newMetric   func(labelValues ...string) Metric
0000000000000000000000000000000000000000;;		hashAdd     func(h uint64, s string) uint64 // replace hash function for testing collision handling
0000000000000000000000000000000000000000;;		hashAddByte func(h uint64, b byte) uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newMetricVec returns an initialized MetricVec. The concrete value is
0000000000000000000000000000000000000000;;	// returned for embedding into another struct.
0000000000000000000000000000000000000000;;	func newMetricVec(desc *Desc, newMetric func(lvs ...string) Metric) *MetricVec {
0000000000000000000000000000000000000000;;		return &MetricVec{
0000000000000000000000000000000000000000;;			children:    map[uint64][]metricWithLabelValues{},
0000000000000000000000000000000000000000;;			desc:        desc,
0000000000000000000000000000000000000000;;			newMetric:   newMetric,
0000000000000000000000000000000000000000;;			hashAdd:     hashAdd,
0000000000000000000000000000000000000000;;			hashAddByte: hashAddByte,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// metricWithLabelValues provides the metric and its label values for
0000000000000000000000000000000000000000;;	// disambiguation on hash collision.
0000000000000000000000000000000000000000;;	type metricWithLabelValues struct {
0000000000000000000000000000000000000000;;		values []string
0000000000000000000000000000000000000000;;		metric Metric
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describe implements Collector. The length of the returned slice
0000000000000000000000000000000000000000;;	// is always one.
0000000000000000000000000000000000000000;;	func (m *MetricVec) Describe(ch chan<- *Desc) {
0000000000000000000000000000000000000000;;		ch <- m.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Collect implements Collector.
0000000000000000000000000000000000000000;;	func (m *MetricVec) Collect(ch chan<- Metric) {
0000000000000000000000000000000000000000;;		m.mtx.RLock()
0000000000000000000000000000000000000000;;		defer m.mtx.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, metrics := range m.children {
0000000000000000000000000000000000000000;;			for _, metric := range metrics {
0000000000000000000000000000000000000000;;				ch <- metric.metric
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues returns the Metric for the given slice of label
0000000000000000000000000000000000000000;;	// values (same order as the VariableLabels in Desc). If that combination of
0000000000000000000000000000000000000000;;	// label values is accessed for the first time, a new Metric is created.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is possible to call this method without using the returned Metric to only
0000000000000000000000000000000000000000;;	// create the new Metric but leave it at its start value (e.g. a Summary or
0000000000000000000000000000000000000000;;	// Histogram without any observations). See also the SummaryVec example.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Keeping the Metric for later use is possible (and should be considered if
0000000000000000000000000000000000000000;;	// performance is critical), but keep in mind that Reset, DeleteLabelValues and
0000000000000000000000000000000000000000;;	// Delete can be used to delete the Metric from the MetricVec. In that case, the
0000000000000000000000000000000000000000;;	// Metric will still exist, but it will not be exported anymore, even if a
0000000000000000000000000000000000000000;;	// Metric with the same label values is created later. See also the CounterVec
0000000000000000000000000000000000000000;;	// example.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An error is returned if the number of label values is not the same as the
0000000000000000000000000000000000000000;;	// number of VariableLabels in Desc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that for more than one label value, this method is prone to mistakes
0000000000000000000000000000000000000000;;	// caused by an incorrect order of arguments. Consider GetMetricWith(Labels) as
0000000000000000000000000000000000000000;;	// an alternative to avoid that type of mistake. For higher label numbers, the
0000000000000000000000000000000000000000;;	// latter has a much more readable (albeit more verbose) syntax, but it comes
0000000000000000000000000000000000000000;;	// with a performance overhead (for creating and processing the Labels map).
0000000000000000000000000000000000000000;;	// See also the GaugeVec example.
0000000000000000000000000000000000000000;;	func (m *MetricVec) GetMetricWithLabelValues(lvs ...string) (Metric, error) {
0000000000000000000000000000000000000000;;		h, err := m.hashLabelValues(lvs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.getOrCreateMetricWithLabelValues(h, lvs), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWith returns the Metric for the given Labels map (the label names
0000000000000000000000000000000000000000;;	// must match those of the VariableLabels in Desc). If that label map is
0000000000000000000000000000000000000000;;	// accessed for the first time, a new Metric is created. Implications of
0000000000000000000000000000000000000000;;	// creating a Metric without using it and keeping the Metric for later use are
0000000000000000000000000000000000000000;;	// the same as for GetMetricWithLabelValues.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An error is returned if the number and names of the Labels are inconsistent
0000000000000000000000000000000000000000;;	// with those of the VariableLabels in Desc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method is used for the same purpose as
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues(...string). See there for pros and cons of the two
0000000000000000000000000000000000000000;;	// methods.
0000000000000000000000000000000000000000;;	func (m *MetricVec) GetMetricWith(labels Labels) (Metric, error) {
0000000000000000000000000000000000000000;;		h, err := m.hashLabels(labels)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.getOrCreateMetricWithLabels(h, labels), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithLabelValues works as GetMetricWithLabelValues, but panics if an error
0000000000000000000000000000000000000000;;	// occurs. The method allows neat syntax like:
0000000000000000000000000000000000000000;;	//     httpReqs.WithLabelValues("404", "POST").Inc()
0000000000000000000000000000000000000000;;	func (m *MetricVec) WithLabelValues(lvs ...string) Metric {
0000000000000000000000000000000000000000;;		metric, err := m.GetMetricWithLabelValues(lvs...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metric
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// With works as GetMetricWith, but panics if an error occurs. The method allows
0000000000000000000000000000000000000000;;	// neat syntax like:
0000000000000000000000000000000000000000;;	//     httpReqs.With(Labels{"status":"404", "method":"POST"}).Inc()
0000000000000000000000000000000000000000;;	func (m *MetricVec) With(labels Labels) Metric {
0000000000000000000000000000000000000000;;		metric, err := m.GetMetricWith(labels)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metric
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteLabelValues removes the metric where the variable labels are the same
0000000000000000000000000000000000000000;;	// as those passed in as labels (same order as the VariableLabels in Desc). It
0000000000000000000000000000000000000000;;	// returns true if a metric was deleted.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is not an error if the number of label values is not the same as the
0000000000000000000000000000000000000000;;	// number of VariableLabels in Desc.  However, such inconsistent label count can
0000000000000000000000000000000000000000;;	// never match an actual Metric, so the method will always return false in that
0000000000000000000000000000000000000000;;	// case.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that for more than one label value, this method is prone to mistakes
0000000000000000000000000000000000000000;;	// caused by an incorrect order of arguments. Consider Delete(Labels) as an
0000000000000000000000000000000000000000;;	// alternative to avoid that type of mistake. For higher label numbers, the
0000000000000000000000000000000000000000;;	// latter has a much more readable (albeit more verbose) syntax, but it comes
0000000000000000000000000000000000000000;;	// with a performance overhead (for creating and processing the Labels map).
0000000000000000000000000000000000000000;;	// See also the CounterVec example.
0000000000000000000000000000000000000000;;	func (m *MetricVec) DeleteLabelValues(lvs ...string) bool {
0000000000000000000000000000000000000000;;		m.mtx.Lock()
0000000000000000000000000000000000000000;;		defer m.mtx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h, err := m.hashLabelValues(lvs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.deleteByHashWithLabelValues(h, lvs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes the metric where the variable labels are the same as those
0000000000000000000000000000000000000000;;	// passed in as labels. It returns true if a metric was deleted.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is not an error if the number and names of the Labels are inconsistent
0000000000000000000000000000000000000000;;	// with those of the VariableLabels in the Desc of the MetricVec. However, such
0000000000000000000000000000000000000000;;	// inconsistent Labels can never match an actual Metric, so the method will
0000000000000000000000000000000000000000;;	// always return false in that case.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method is used for the same purpose as DeleteLabelValues(...string). See
0000000000000000000000000000000000000000;;	// there for pros and cons of the two methods.
0000000000000000000000000000000000000000;;	func (m *MetricVec) Delete(labels Labels) bool {
0000000000000000000000000000000000000000;;		m.mtx.Lock()
0000000000000000000000000000000000000000;;		defer m.mtx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h, err := m.hashLabels(labels)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.deleteByHashWithLabels(h, labels)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteByHashWithLabelValues removes the metric from the hash bucket h. If
0000000000000000000000000000000000000000;;	// there are multiple matches in the bucket, use lvs to select a metric and
0000000000000000000000000000000000000000;;	// remove only that metric.
0000000000000000000000000000000000000000;;	func (m *MetricVec) deleteByHashWithLabelValues(h uint64, lvs []string) bool {
0000000000000000000000000000000000000000;;		metrics, ok := m.children[h]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := m.findMetricWithLabelValues(metrics, lvs)
0000000000000000000000000000000000000000;;		if i >= len(metrics) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics) > 1 {
0000000000000000000000000000000000000000;;			m.children[h] = append(metrics[:i], metrics[i+1:]...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			delete(m.children, h)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteByHashWithLabels removes the metric from the hash bucket h. If there
0000000000000000000000000000000000000000;;	// are multiple matches in the bucket, use lvs to select a metric and remove
0000000000000000000000000000000000000000;;	// only that metric.
0000000000000000000000000000000000000000;;	func (m *MetricVec) deleteByHashWithLabels(h uint64, labels Labels) bool {
0000000000000000000000000000000000000000;;		metrics, ok := m.children[h]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := m.findMetricWithLabels(metrics, labels)
0000000000000000000000000000000000000000;;		if i >= len(metrics) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metrics) > 1 {
0000000000000000000000000000000000000000;;			m.children[h] = append(metrics[:i], metrics[i+1:]...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			delete(m.children, h)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset deletes all metrics in this vector.
0000000000000000000000000000000000000000;;	func (m *MetricVec) Reset() {
0000000000000000000000000000000000000000;;		m.mtx.Lock()
0000000000000000000000000000000000000000;;		defer m.mtx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for h := range m.children {
0000000000000000000000000000000000000000;;			delete(m.children, h)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MetricVec) hashLabelValues(vals []string) (uint64, error) {
0000000000000000000000000000000000000000;;		if len(vals) != len(m.desc.variableLabels) {
0000000000000000000000000000000000000000;;			return 0, errInconsistentCardinality
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := hashNew()
0000000000000000000000000000000000000000;;		for _, val := range vals {
0000000000000000000000000000000000000000;;			h = m.hashAdd(h, val)
0000000000000000000000000000000000000000;;			h = m.hashAddByte(h, model.SeparatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MetricVec) hashLabels(labels Labels) (uint64, error) {
0000000000000000000000000000000000000000;;		if len(labels) != len(m.desc.variableLabels) {
0000000000000000000000000000000000000000;;			return 0, errInconsistentCardinality
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := hashNew()
0000000000000000000000000000000000000000;;		for _, label := range m.desc.variableLabels {
0000000000000000000000000000000000000000;;			val, ok := labels[label]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("label name %q missing in label map", label)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h = m.hashAdd(h, val)
0000000000000000000000000000000000000000;;			h = m.hashAddByte(h, model.SeparatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getOrCreateMetricWithLabelValues retrieves the metric by hash and label value
0000000000000000000000000000000000000000;;	// or creates it and returns the new one.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function holds the mutex.
0000000000000000000000000000000000000000;;	func (m *MetricVec) getOrCreateMetricWithLabelValues(hash uint64, lvs []string) Metric {
0000000000000000000000000000000000000000;;		m.mtx.RLock()
0000000000000000000000000000000000000000;;		metric, ok := m.getMetricWithLabelValues(hash, lvs)
0000000000000000000000000000000000000000;;		m.mtx.RUnlock()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return metric
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mtx.Lock()
0000000000000000000000000000000000000000;;		defer m.mtx.Unlock()
0000000000000000000000000000000000000000;;		metric, ok = m.getMetricWithLabelValues(hash, lvs)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// Copy to avoid allocation in case wo don't go down this code path.
0000000000000000000000000000000000000000;;			copiedLVs := make([]string, len(lvs))
0000000000000000000000000000000000000000;;			copy(copiedLVs, lvs)
0000000000000000000000000000000000000000;;			metric = m.newMetric(copiedLVs...)
0000000000000000000000000000000000000000;;			m.children[hash] = append(m.children[hash], metricWithLabelValues{values: copiedLVs, metric: metric})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metric
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getOrCreateMetricWithLabelValues retrieves the metric by hash and label value
0000000000000000000000000000000000000000;;	// or creates it and returns the new one.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function holds the mutex.
0000000000000000000000000000000000000000;;	func (m *MetricVec) getOrCreateMetricWithLabels(hash uint64, labels Labels) Metric {
0000000000000000000000000000000000000000;;		m.mtx.RLock()
0000000000000000000000000000000000000000;;		metric, ok := m.getMetricWithLabels(hash, labels)
0000000000000000000000000000000000000000;;		m.mtx.RUnlock()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return metric
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mtx.Lock()
0000000000000000000000000000000000000000;;		defer m.mtx.Unlock()
0000000000000000000000000000000000000000;;		metric, ok = m.getMetricWithLabels(hash, labels)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			lvs := m.extractLabelValues(labels)
0000000000000000000000000000000000000000;;			metric = m.newMetric(lvs...)
0000000000000000000000000000000000000000;;			m.children[hash] = append(m.children[hash], metricWithLabelValues{values: lvs, metric: metric})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metric
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMetricWithLabelValues gets a metric while handling possible collisions in
0000000000000000000000000000000000000000;;	// the hash space. Must be called while holding read mutex.
0000000000000000000000000000000000000000;;	func (m *MetricVec) getMetricWithLabelValues(h uint64, lvs []string) (Metric, bool) {
0000000000000000000000000000000000000000;;		metrics, ok := m.children[h]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if i := m.findMetricWithLabelValues(metrics, lvs); i < len(metrics) {
0000000000000000000000000000000000000000;;				return metrics[i].metric, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMetricWithLabels gets a metric while handling possible collisions in
0000000000000000000000000000000000000000;;	// the hash space. Must be called while holding read mutex.
0000000000000000000000000000000000000000;;	func (m *MetricVec) getMetricWithLabels(h uint64, labels Labels) (Metric, bool) {
0000000000000000000000000000000000000000;;		metrics, ok := m.children[h]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if i := m.findMetricWithLabels(metrics, labels); i < len(metrics) {
0000000000000000000000000000000000000000;;				return metrics[i].metric, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findMetricWithLabelValues returns the index of the matching metric or
0000000000000000000000000000000000000000;;	// len(metrics) if not found.
0000000000000000000000000000000000000000;;	func (m *MetricVec) findMetricWithLabelValues(metrics []metricWithLabelValues, lvs []string) int {
0000000000000000000000000000000000000000;;		for i, metric := range metrics {
0000000000000000000000000000000000000000;;			if m.matchLabelValues(metric.values, lvs) {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(metrics)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findMetricWithLabels returns the index of the matching metric or len(metrics)
0000000000000000000000000000000000000000;;	// if not found.
0000000000000000000000000000000000000000;;	func (m *MetricVec) findMetricWithLabels(metrics []metricWithLabelValues, labels Labels) int {
0000000000000000000000000000000000000000;;		for i, metric := range metrics {
0000000000000000000000000000000000000000;;			if m.matchLabels(metric.values, labels) {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(metrics)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MetricVec) matchLabelValues(values []string, lvs []string) bool {
0000000000000000000000000000000000000000;;		if len(values) != len(lvs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range values {
0000000000000000000000000000000000000000;;			if v != lvs[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MetricVec) matchLabels(values []string, labels Labels) bool {
0000000000000000000000000000000000000000;;		if len(labels) != len(values) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, k := range m.desc.variableLabels {
0000000000000000000000000000000000000000;;			if values[i] != labels[k] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MetricVec) extractLabelValues(labels Labels) []string {
0000000000000000000000000000000000000000;;		labelValues := make([]string, len(labels))
0000000000000000000000000000000000000000;;		for i, k := range m.desc.variableLabels {
0000000000000000000000000000000000000000;;			labelValues[i] = labels[k]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labelValues
0000000000000000000000000000000000000000;;	}
