0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/doc.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/doc.go][vendor/github.com/prometheus/client_golang/prometheus/doc.go];	
0000000000000000000000000000000000000000;;	// Package prometheus provides metrics primitives to instrument code for
0000000000000000000000000000000000000000;;	// monitoring. It also offers a registry for metrics. Sub-packages allow to
0000000000000000000000000000000000000000;;	// expose the registered metrics via HTTP (package promhttp) or push them to a
0000000000000000000000000000000000000000;;	// Pushgateway (package push).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All exported functions and methods are safe to be used concurrently unless
0000000000000000000000000000000000000000;;	// specified otherwise.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A Basic Example
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As a starting point, a very basic usage example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    package main
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    import (
0000000000000000000000000000000000000000;;	//    	"log"
0000000000000000000000000000000000000000;;	//    	"net/http"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    	"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	//    	"github.com/prometheus/client_golang/prometheus/promhttp"
0000000000000000000000000000000000000000;;	//    )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    var (
0000000000000000000000000000000000000000;;	//    	cpuTemp = prometheus.NewGauge(prometheus.GaugeOpts{
0000000000000000000000000000000000000000;;	//    		Name: "cpu_temperature_celsius",
0000000000000000000000000000000000000000;;	//    		Help: "Current temperature of the CPU.",
0000000000000000000000000000000000000000;;	//    	})
0000000000000000000000000000000000000000;;	//    	hdFailures = prometheus.NewCounterVec(
0000000000000000000000000000000000000000;;	//    		prometheus.CounterOpts{
0000000000000000000000000000000000000000;;	//    			Name: "hd_errors_total",
0000000000000000000000000000000000000000;;	//    			Help: "Number of hard-disk errors.",
0000000000000000000000000000000000000000;;	//    		},
0000000000000000000000000000000000000000;;	//    		[]string{"device"},
0000000000000000000000000000000000000000;;	//    	)
0000000000000000000000000000000000000000;;	//    )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    func init() {
0000000000000000000000000000000000000000;;	//    	// Metrics have to be registered to be exposed:
0000000000000000000000000000000000000000;;	//    	prometheus.MustRegister(cpuTemp)
0000000000000000000000000000000000000000;;	//    	prometheus.MustRegister(hdFailures)
0000000000000000000000000000000000000000;;	//    }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    func main() {
0000000000000000000000000000000000000000;;	//    	cpuTemp.Set(65.3)
0000000000000000000000000000000000000000;;	//    	hdFailures.With(prometheus.Labels{"device":"/dev/sda"}).Inc()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    	// The Handler function provides a default handler to expose metrics
0000000000000000000000000000000000000000;;	//    	// via an HTTP server. "/metrics" is the usual endpoint for that.
0000000000000000000000000000000000000000;;	//    	http.Handle("/metrics", promhttp.Handler())
0000000000000000000000000000000000000000;;	//      log.Fatal(http.ListenAndServe(":8080", nil))
0000000000000000000000000000000000000000;;	//    }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is a complete program that exports two metrics, a Gauge and a Counter,
0000000000000000000000000000000000000000;;	// the latter with a label attached to turn it into a (one-dimensional) vector.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Metrics
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The number of exported identifiers in this package might appear a bit
0000000000000000000000000000000000000000;;	// overwhelming. However, in addition to the basic plumbing shown in the example
0000000000000000000000000000000000000000;;	// above, you only need to understand the different metric types and their
0000000000000000000000000000000000000000;;	// vector versions for basic usage.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Above, you have already touched the Counter and the Gauge. There are two more
0000000000000000000000000000000000000000;;	// advanced metric types: the Summary and Histogram. A more thorough description
0000000000000000000000000000000000000000;;	// of those four metric types can be found in the Prometheus docs:
0000000000000000000000000000000000000000;;	// https://prometheus.io/docs/concepts/metric_types/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A fifth "type" of metric is Untyped. It behaves like a Gauge, but signals the
0000000000000000000000000000000000000000;;	// Prometheus server not to assume anything about its type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In addition to the fundamental metric types Gauge, Counter, Summary,
0000000000000000000000000000000000000000;;	// Histogram, and Untyped, a very important part of the Prometheus data model is
0000000000000000000000000000000000000000;;	// the partitioning of samples along dimensions called labels, which results in
0000000000000000000000000000000000000000;;	// metric vectors. The fundamental types are GaugeVec, CounterVec, SummaryVec,
0000000000000000000000000000000000000000;;	// HistogramVec, and UntypedVec.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// While only the fundamental metric types implement the Metric interface, both
0000000000000000000000000000000000000000;;	// the metrics and their vector versions implement the Collector interface. A
0000000000000000000000000000000000000000;;	// Collector manages the collection of a number of Metrics, but for convenience,
0000000000000000000000000000000000000000;;	// a Metric can also “collect itself”. Note that Gauge, Counter, Summary,
0000000000000000000000000000000000000000;;	// Histogram, and Untyped are interfaces themselves while GaugeVec, CounterVec,
0000000000000000000000000000000000000000;;	// SummaryVec, HistogramVec, and UntypedVec are not.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create instances of Metrics and their vector versions, you need a suitable
0000000000000000000000000000000000000000;;	// …Opts struct, i.e. GaugeOpts, CounterOpts, SummaryOpts, HistogramOpts, or
0000000000000000000000000000000000000000;;	// UntypedOpts.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Custom Collectors and constant Metrics
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// While you could create your own implementations of Metric, most likely you
0000000000000000000000000000000000000000;;	// will only ever implement the Collector interface on your own. At a first
0000000000000000000000000000000000000000;;	// glance, a custom Collector seems handy to bundle Metrics for common
0000000000000000000000000000000000000000;;	// registration (with the prime example of the different metric vectors above,
0000000000000000000000000000000000000000;;	// which bundle all the metrics of the same name but with different labels).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There is a more involved use case, too: If you already have metrics
0000000000000000000000000000000000000000;;	// available, created outside of the Prometheus context, you don't need the
0000000000000000000000000000000000000000;;	// interface of the various Metric types. You essentially want to mirror the
0000000000000000000000000000000000000000;;	// existing numbers into Prometheus Metrics during collection. An own
0000000000000000000000000000000000000000;;	// implementation of the Collector interface is perfect for that. You can create
0000000000000000000000000000000000000000;;	// Metric instances “on the fly” using NewConstMetric, NewConstHistogram, and
0000000000000000000000000000000000000000;;	// NewConstSummary (and their respective Must… versions). That will happen in
0000000000000000000000000000000000000000;;	// the Collect method. The Describe method has to return separate Desc
0000000000000000000000000000000000000000;;	// instances, representative of the “throw-away” metrics to be created later.
0000000000000000000000000000000000000000;;	// NewDesc comes in handy to create those Desc instances.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Collector example illustrates the use case. You can also look at the
0000000000000000000000000000000000000000;;	// source code of the processCollector (mirroring process metrics), the
0000000000000000000000000000000000000000;;	// goCollector (mirroring Go metrics), or the expvarCollector (mirroring expvar
0000000000000000000000000000000000000000;;	// metrics) as examples that are used in this package itself.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you just need to call a function to get a single float value to collect as
0000000000000000000000000000000000000000;;	// a metric, GaugeFunc, CounterFunc, or UntypedFunc might be interesting
0000000000000000000000000000000000000000;;	// shortcuts.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Advanced Uses of the Registry
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// While MustRegister is the by far most common way of registering a Collector,
0000000000000000000000000000000000000000;;	// sometimes you might want to handle the errors the registration might cause.
0000000000000000000000000000000000000000;;	// As suggested by the name, MustRegister panics if an error occurs. With the
0000000000000000000000000000000000000000;;	// Register function, the error is returned and can be handled.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An error is returned if the registered Collector is incompatible or
0000000000000000000000000000000000000000;;	// inconsistent with already registered metrics. The registry aims for
0000000000000000000000000000000000000000;;	// consistency of the collected metrics according to the Prometheus data model.
0000000000000000000000000000000000000000;;	// Inconsistencies are ideally detected at registration time, not at collect
0000000000000000000000000000000000000000;;	// time. The former will usually be detected at start-up time of a program,
0000000000000000000000000000000000000000;;	// while the latter will only happen at scrape time, possibly not even on the
0000000000000000000000000000000000000000;;	// first scrape if the inconsistency only becomes relevant later. That is the
0000000000000000000000000000000000000000;;	// main reason why a Collector and a Metric have to describe themselves to the
0000000000000000000000000000000000000000;;	// registry.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// So far, everything we did operated on the so-called default registry, as it
0000000000000000000000000000000000000000;;	// can be found in the global DefaultRegistry variable. With NewRegistry, you
0000000000000000000000000000000000000000;;	// can create a custom registry, or you can even implement the Registerer or
0000000000000000000000000000000000000000;;	// Gatherer interfaces yourself. The methods Register and Unregister work in the
0000000000000000000000000000000000000000;;	// same way on a custom registry as the global functions Register and Unregister
0000000000000000000000000000000000000000;;	// on the default registry.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There are a number of uses for custom registries: You can use registries with
0000000000000000000000000000000000000000;;	// special properties, see NewPedanticRegistry. You can avoid global state, as
0000000000000000000000000000000000000000;;	// it is imposed by the DefaultRegistry. You can use multiple registries at the
0000000000000000000000000000000000000000;;	// same time to expose different metrics in different ways. You can use separate
0000000000000000000000000000000000000000;;	// registries for testing purposes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Also note that the DefaultRegistry comes registered with a Collector for Go
0000000000000000000000000000000000000000;;	// runtime metrics (via NewGoCollector) and a Collector for process metrics (via
0000000000000000000000000000000000000000;;	// NewProcessCollector). With a custom registry, you are in control and decide
0000000000000000000000000000000000000000;;	// yourself about the Collectors to register.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// HTTP Exposition
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Registry implements the Gatherer interface. The caller of the Gather
0000000000000000000000000000000000000000;;	// method can then expose the gathered metrics in some way. Usually, the metrics
0000000000000000000000000000000000000000;;	// are served via HTTP on the /metrics endpoint. That's happening in the example
0000000000000000000000000000000000000000;;	// above. The tools to expose metrics via HTTP are in the promhttp sub-package.
0000000000000000000000000000000000000000;;	// (The top-level functions in the prometheus package are deprecated.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Pushing to the Pushgateway
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Function for pushing to the Pushgateway can be found in the push sub-package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Graphite Bridge
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Functions and examples to push metrics from a Gatherer to Graphite can be
0000000000000000000000000000000000000000;;	// found in the graphite sub-package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Other Means of Exposition
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// More ways of exposing metrics can easily be added by following the approaches
0000000000000000000000000000000000000000;;	// of the existing implementations.
0000000000000000000000000000000000000000;;	package prometheus
