0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/summary.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/summary.go][vendor/github.com/prometheus/client_golang/prometheus/summary.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/beorn7/perks/quantile"
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// quantileLabel is used for the label that defines the quantile in a
0000000000000000000000000000000000000000;;	// summary.
0000000000000000000000000000000000000000;;	const quantileLabel = "quantile"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Summary captures individual observations from an event or sample stream and
0000000000000000000000000000000000000000;;	// summarizes them in a manner similar to traditional summary statistics: 1. sum
0000000000000000000000000000000000000000;;	// of observations, 2. observation count, 3. rank estimations.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A typical use-case is the observation of request latencies. By default, a
0000000000000000000000000000000000000000;;	// Summary provides the median, the 90th and the 99th percentile of the latency
0000000000000000000000000000000000000000;;	// as rank estimations.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that the rank estimations cannot be aggregated in a meaningful way with
0000000000000000000000000000000000000000;;	// the Prometheus query language (i.e. you cannot average or add them). If you
0000000000000000000000000000000000000000;;	// need aggregatable quantiles (e.g. you want the 99th percentile latency of all
0000000000000000000000000000000000000000;;	// queries served across all instances of a service), consider the Histogram
0000000000000000000000000000000000000000;;	// metric type. See the Prometheus documentation for more details.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create Summary instances, use NewSummary.
0000000000000000000000000000000000000000;;	type Summary interface {
0000000000000000000000000000000000000000;;		Metric
0000000000000000000000000000000000000000;;		Collector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Observe adds a single observation to the summary.
0000000000000000000000000000000000000000;;		Observe(float64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefObjectives are the default Summary quantile values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: DefObjectives will not be used as the default objectives in
0000000000000000000000000000000000000000;;	// v0.10 of the library. The default Summary will have no quantiles then.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		DefObjectives = map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errQuantileLabelNotAllowed = fmt.Errorf(
0000000000000000000000000000000000000000;;			"%q is not allowed as label name in summaries", quantileLabel,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Default values for SummaryOpts.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefMaxAge is the default duration for which observations stay
0000000000000000000000000000000000000000;;		// relevant.
0000000000000000000000000000000000000000;;		DefMaxAge time.Duration = 10 * time.Minute
0000000000000000000000000000000000000000;;		// DefAgeBuckets is the default number of buckets used to calculate the
0000000000000000000000000000000000000000;;		// age of observations.
0000000000000000000000000000000000000000;;		DefAgeBuckets = 5
0000000000000000000000000000000000000000;;		// DefBufCap is the standard buffer size for collecting Summary observations.
0000000000000000000000000000000000000000;;		DefBufCap = 500
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SummaryOpts bundles the options for creating a Summary metric. It is
0000000000000000000000000000000000000000;;	// mandatory to set Name and Help to a non-empty string. All other fields are
0000000000000000000000000000000000000000;;	// optional and can safely be left at their zero value.
0000000000000000000000000000000000000000;;	type SummaryOpts struct {
0000000000000000000000000000000000000000;;		// Namespace, Subsystem, and Name are components of the fully-qualified
0000000000000000000000000000000000000000;;		// name of the Summary (created by joining these components with
0000000000000000000000000000000000000000;;		// "_"). Only Name is mandatory, the others merely help structuring the
0000000000000000000000000000000000000000;;		// name. Note that the fully-qualified name of the Summary must be a
0000000000000000000000000000000000000000;;		// valid Prometheus metric name.
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Subsystem string
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Help provides information about this Summary. Mandatory!
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Metrics with the same fully-qualified name must have the same Help
0000000000000000000000000000000000000000;;		// string.
0000000000000000000000000000000000000000;;		Help string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConstLabels are used to attach fixed labels to this
0000000000000000000000000000000000000000;;		// Summary. Summaries with the same fully-qualified name must have the
0000000000000000000000000000000000000000;;		// same label names in their ConstLabels.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note that in most cases, labels have a value that varies during the
0000000000000000000000000000000000000000;;		// lifetime of a process. Those labels are usually managed with a
0000000000000000000000000000000000000000;;		// SummaryVec. ConstLabels serve only special purposes. One is for the
0000000000000000000000000000000000000000;;		// special case where the value of a label does not change during the
0000000000000000000000000000000000000000;;		// lifetime of a process, e.g. if the revision of the running binary is
0000000000000000000000000000000000000000;;		// put into a label. Another, more advanced purpose is if more than one
0000000000000000000000000000000000000000;;		// Collector needs to collect Summaries with the same fully-qualified
0000000000000000000000000000000000000000;;		// name. In that case, those Summaries must differ in the values of
0000000000000000000000000000000000000000;;		// their ConstLabels. See the Collector examples.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the value of a label never changes (not even between binaries),
0000000000000000000000000000000000000000;;		// that label most likely should not be a label at all (but part of the
0000000000000000000000000000000000000000;;		// metric name).
0000000000000000000000000000000000000000;;		ConstLabels Labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Objectives defines the quantile rank estimates with their respective
0000000000000000000000000000000000000000;;		// absolute error. If Objectives[q] = e, then the value reported for q
0000000000000000000000000000000000000000;;		// will be the φ-quantile value for some φ between q-e and q+e.  The
0000000000000000000000000000000000000000;;		// default value is DefObjectives. It is used if Objectives is left at
0000000000000000000000000000000000000000;;		// its zero value (i.e. nil). To create a Summary without Objectives,
0000000000000000000000000000000000000000;;		// set it to an empty map (i.e. map[float64]float64{}).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Deprecated: Note that the current value of DefObjectives is
0000000000000000000000000000000000000000;;		// deprecated. It will be replaced by an empty map in v0.10 of the
0000000000000000000000000000000000000000;;		// library. Please explicitly set Objectives to the desired value.
0000000000000000000000000000000000000000;;		Objectives map[float64]float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxAge defines the duration for which an observation stays relevant
0000000000000000000000000000000000000000;;		// for the summary. Must be positive. The default value is DefMaxAge.
0000000000000000000000000000000000000000;;		MaxAge time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AgeBuckets is the number of buckets used to exclude observations that
0000000000000000000000000000000000000000;;		// are older than MaxAge from the summary. A higher number has a
0000000000000000000000000000000000000000;;		// resource penalty, so only increase it if the higher resolution is
0000000000000000000000000000000000000000;;		// really required. For very high observation rates, you might want to
0000000000000000000000000000000000000000;;		// reduce the number of age buckets. With only one age bucket, you will
0000000000000000000000000000000000000000;;		// effectively see a complete reset of the summary each time MaxAge has
0000000000000000000000000000000000000000;;		// passed. The default value is DefAgeBuckets.
0000000000000000000000000000000000000000;;		AgeBuckets uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BufCap defines the default sample stream buffer size.  The default
0000000000000000000000000000000000000000;;		// value of DefBufCap should suffice for most uses. If there is a need
0000000000000000000000000000000000000000;;		// to increase the value, a multiple of 500 is recommended (because that
0000000000000000000000000000000000000000;;		// is the internal buffer size of the underlying package
0000000000000000000000000000000000000000;;		// "github.com/bmizerany/perks/quantile").
0000000000000000000000000000000000000000;;		BufCap uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Great fuck-up with the sliding-window decay algorithm... The Merge method of
0000000000000000000000000000000000000000;;	// perk/quantile is actually not working as advertised - and it might be
0000000000000000000000000000000000000000;;	// unfixable, as the underlying algorithm is apparently not capable of merging
0000000000000000000000000000000000000000;;	// summaries in the first place. To avoid using Merge, we are currently adding
0000000000000000000000000000000000000000;;	// observations to _each_ age bucket, i.e. the effort to add a sample is
0000000000000000000000000000000000000000;;	// essentially multiplied by the number of age buckets. When rotating age
0000000000000000000000000000000000000000;;	// buckets, we empty the previous head stream. On scrape time, we simply take
0000000000000000000000000000000000000000;;	// the quantiles from the head stream (no merging required). Result: More effort
0000000000000000000000000000000000000000;;	// on observation time, less effort on scrape time, which is exactly the
0000000000000000000000000000000000000000;;	// opposite of what we try to accomplish, but at least the results are correct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The quite elegant previous contraption to merge the age buckets efficiently
0000000000000000000000000000000000000000;;	// on scrape time (see code up commit 6b9530d72ea715f0ba612c0120e6e09fbf1d49d0)
0000000000000000000000000000000000000000;;	// can't be used anymore.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSummary creates a new Summary based on the provided SummaryOpts.
0000000000000000000000000000000000000000;;	func NewSummary(opts SummaryOpts) Summary {
0000000000000000000000000000000000000000;;		return newSummary(
0000000000000000000000000000000000000000;;			NewDesc(
0000000000000000000000000000000000000000;;				BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;				opts.Help,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				opts.ConstLabels,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			opts,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSummary(desc *Desc, opts SummaryOpts, labelValues ...string) Summary {
0000000000000000000000000000000000000000;;		if len(desc.variableLabels) != len(labelValues) {
0000000000000000000000000000000000000000;;			panic(errInconsistentCardinality)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range desc.variableLabels {
0000000000000000000000000000000000000000;;			if n == quantileLabel {
0000000000000000000000000000000000000000;;				panic(errQuantileLabelNotAllowed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, lp := range desc.constLabelPairs {
0000000000000000000000000000000000000000;;			if lp.GetName() == quantileLabel {
0000000000000000000000000000000000000000;;				panic(errQuantileLabelNotAllowed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.Objectives == nil {
0000000000000000000000000000000000000000;;			opts.Objectives = DefObjectives
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.MaxAge < 0 {
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("illegal max age MaxAge=%v", opts.MaxAge))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.MaxAge == 0 {
0000000000000000000000000000000000000000;;			opts.MaxAge = DefMaxAge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.AgeBuckets == 0 {
0000000000000000000000000000000000000000;;			opts.AgeBuckets = DefAgeBuckets
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.BufCap == 0 {
0000000000000000000000000000000000000000;;			opts.BufCap = DefBufCap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &summary{
0000000000000000000000000000000000000000;;			desc: desc,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			objectives:       opts.Objectives,
0000000000000000000000000000000000000000;;			sortedObjectives: make([]float64, 0, len(opts.Objectives)),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			labelPairs: makeLabelPairs(desc, labelValues),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hotBuf:         make([]float64, 0, opts.BufCap),
0000000000000000000000000000000000000000;;			coldBuf:        make([]float64, 0, opts.BufCap),
0000000000000000000000000000000000000000;;			streamDuration: opts.MaxAge / time.Duration(opts.AgeBuckets),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.headStreamExpTime = time.Now().Add(s.streamDuration)
0000000000000000000000000000000000000000;;		s.hotBufExpTime = s.headStreamExpTime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := uint32(0); i < opts.AgeBuckets; i++ {
0000000000000000000000000000000000000000;;			s.streams = append(s.streams, s.newStream())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.headStream = s.streams[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for qu := range s.objectives {
0000000000000000000000000000000000000000;;			s.sortedObjectives = append(s.sortedObjectives, qu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Float64s(s.sortedObjectives)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.init(s) // Init self-collection.
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type summary struct {
0000000000000000000000000000000000000000;;		selfCollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bufMtx sync.Mutex // Protects hotBuf and hotBufExpTime.
0000000000000000000000000000000000000000;;		mtx    sync.Mutex // Protects every other moving part.
0000000000000000000000000000000000000000;;		// Lock bufMtx before mtx if both are needed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desc *Desc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objectives       map[float64]float64
0000000000000000000000000000000000000000;;		sortedObjectives []float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sum float64
0000000000000000000000000000000000000000;;		cnt uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hotBuf, coldBuf []float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streams                          []*quantile.Stream
0000000000000000000000000000000000000000;;		streamDuration                   time.Duration
0000000000000000000000000000000000000000;;		headStream                       *quantile.Stream
0000000000000000000000000000000000000000;;		headStreamIdx                    int
0000000000000000000000000000000000000000;;		headStreamExpTime, hotBufExpTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *summary) Desc() *Desc {
0000000000000000000000000000000000000000;;		return s.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *summary) Observe(v float64) {
0000000000000000000000000000000000000000;;		s.bufMtx.Lock()
0000000000000000000000000000000000000000;;		defer s.bufMtx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		if now.After(s.hotBufExpTime) {
0000000000000000000000000000000000000000;;			s.asyncFlush(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hotBuf = append(s.hotBuf, v)
0000000000000000000000000000000000000000;;		if len(s.hotBuf) == cap(s.hotBuf) {
0000000000000000000000000000000000000000;;			s.asyncFlush(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *summary) Write(out *dto.Metric) error {
0000000000000000000000000000000000000000;;		sum := &dto.Summary{}
0000000000000000000000000000000000000000;;		qs := make([]*dto.Quantile, 0, len(s.objectives))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.bufMtx.Lock()
0000000000000000000000000000000000000000;;		s.mtx.Lock()
0000000000000000000000000000000000000000;;		// Swap bufs even if hotBuf is empty to set new hotBufExpTime.
0000000000000000000000000000000000000000;;		s.swapBufs(time.Now())
0000000000000000000000000000000000000000;;		s.bufMtx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.flushColdBuf()
0000000000000000000000000000000000000000;;		sum.SampleCount = proto.Uint64(s.cnt)
0000000000000000000000000000000000000000;;		sum.SampleSum = proto.Float64(s.sum)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rank := range s.sortedObjectives {
0000000000000000000000000000000000000000;;			var q float64
0000000000000000000000000000000000000000;;			if s.headStream.Count() == 0 {
0000000000000000000000000000000000000000;;				q = math.NaN()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				q = s.headStream.Query(rank)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			qs = append(qs, &dto.Quantile{
0000000000000000000000000000000000000000;;				Quantile: proto.Float64(rank),
0000000000000000000000000000000000000000;;				Value:    proto.Float64(q),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.mtx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(qs) > 0 {
0000000000000000000000000000000000000000;;			sort.Sort(quantSort(qs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sum.Quantile = qs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Summary = sum
0000000000000000000000000000000000000000;;		out.Label = s.labelPairs
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *summary) newStream() *quantile.Stream {
0000000000000000000000000000000000000000;;		return quantile.NewTargeted(s.objectives)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// asyncFlush needs bufMtx locked.
0000000000000000000000000000000000000000;;	func (s *summary) asyncFlush(now time.Time) {
0000000000000000000000000000000000000000;;		s.mtx.Lock()
0000000000000000000000000000000000000000;;		s.swapBufs(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unblock the original goroutine that was responsible for the mutation
0000000000000000000000000000000000000000;;		// that triggered the compaction.  But hold onto the global non-buffer
0000000000000000000000000000000000000000;;		// state mutex until the operation finishes.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			s.flushColdBuf()
0000000000000000000000000000000000000000;;			s.mtx.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rotateStreams needs mtx AND bufMtx locked.
0000000000000000000000000000000000000000;;	func (s *summary) maybeRotateStreams() {
0000000000000000000000000000000000000000;;		for !s.hotBufExpTime.Equal(s.headStreamExpTime) {
0000000000000000000000000000000000000000;;			s.headStream.Reset()
0000000000000000000000000000000000000000;;			s.headStreamIdx++
0000000000000000000000000000000000000000;;			if s.headStreamIdx >= len(s.streams) {
0000000000000000000000000000000000000000;;				s.headStreamIdx = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.headStream = s.streams[s.headStreamIdx]
0000000000000000000000000000000000000000;;			s.headStreamExpTime = s.headStreamExpTime.Add(s.streamDuration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flushColdBuf needs mtx locked.
0000000000000000000000000000000000000000;;	func (s *summary) flushColdBuf() {
0000000000000000000000000000000000000000;;		for _, v := range s.coldBuf {
0000000000000000000000000000000000000000;;			for _, stream := range s.streams {
0000000000000000000000000000000000000000;;				stream.Insert(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.cnt++
0000000000000000000000000000000000000000;;			s.sum += v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.coldBuf = s.coldBuf[0:0]
0000000000000000000000000000000000000000;;		s.maybeRotateStreams()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// swapBufs needs mtx AND bufMtx locked, coldBuf must be empty.
0000000000000000000000000000000000000000;;	func (s *summary) swapBufs(now time.Time) {
0000000000000000000000000000000000000000;;		if len(s.coldBuf) != 0 {
0000000000000000000000000000000000000000;;			panic("coldBuf is not empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hotBuf, s.coldBuf = s.coldBuf, s.hotBuf
0000000000000000000000000000000000000000;;		// hotBuf is now empty and gets new expiration set.
0000000000000000000000000000000000000000;;		for now.After(s.hotBufExpTime) {
0000000000000000000000000000000000000000;;			s.hotBufExpTime = s.hotBufExpTime.Add(s.streamDuration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type quantSort []*dto.Quantile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s quantSort) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s quantSort) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s quantSort) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i].GetQuantile() < s[j].GetQuantile()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SummaryVec is a Collector that bundles a set of Summaries that all share the
0000000000000000000000000000000000000000;;	// same Desc, but have different values for their variable labels. This is used
0000000000000000000000000000000000000000;;	// if you want to count the same thing partitioned by various dimensions
0000000000000000000000000000000000000000;;	// (e.g. HTTP request latencies, partitioned by status code and method). Create
0000000000000000000000000000000000000000;;	// instances with NewSummaryVec.
0000000000000000000000000000000000000000;;	type SummaryVec struct {
0000000000000000000000000000000000000000;;		*MetricVec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSummaryVec creates a new SummaryVec based on the provided SummaryOpts and
0000000000000000000000000000000000000000;;	// partitioned by the given label names. At least one label name must be
0000000000000000000000000000000000000000;;	// provided.
0000000000000000000000000000000000000000;;	func NewSummaryVec(opts SummaryOpts, labelNames []string) *SummaryVec {
0000000000000000000000000000000000000000;;		desc := NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			labelNames,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return &SummaryVec{
0000000000000000000000000000000000000000;;			MetricVec: newMetricVec(desc, func(lvs ...string) Metric {
0000000000000000000000000000000000000000;;				return newSummary(desc, opts, lvs...)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues replaces the method of the same name in MetricVec.
0000000000000000000000000000000000000000;;	// The difference is that this method returns an Observer and not a Metric so
0000000000000000000000000000000000000000;;	// that no type conversion to an Observer is required.
0000000000000000000000000000000000000000;;	func (m *SummaryVec) GetMetricWithLabelValues(lvs ...string) (Observer, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWithLabelValues(lvs...)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Observer), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWith replaces the method of the same name in MetricVec. The
0000000000000000000000000000000000000000;;	// difference is that this method returns an Observer and not a Metric so that
0000000000000000000000000000000000000000;;	// no type conversion to an Observer is required.
0000000000000000000000000000000000000000;;	func (m *SummaryVec) GetMetricWith(labels Labels) (Observer, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWith(labels)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Observer), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithLabelValues works as GetMetricWithLabelValues, but panics where
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues would have returned an error. By not returning an
0000000000000000000000000000000000000000;;	// error, WithLabelValues allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.WithLabelValues("404", "GET").Observe(42.21)
0000000000000000000000000000000000000000;;	func (m *SummaryVec) WithLabelValues(lvs ...string) Observer {
0000000000000000000000000000000000000000;;		return m.MetricVec.WithLabelValues(lvs...).(Observer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// With works as GetMetricWith, but panics where GetMetricWithLabels would have
0000000000000000000000000000000000000000;;	// returned an error. By not returning an error, With allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.With(Labels{"code": "404", "method": "GET"}).Observe(42.21)
0000000000000000000000000000000000000000;;	func (m *SummaryVec) With(labels Labels) Observer {
0000000000000000000000000000000000000000;;		return m.MetricVec.With(labels).(Observer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type constSummary struct {
0000000000000000000000000000000000000000;;		desc       *Desc
0000000000000000000000000000000000000000;;		count      uint64
0000000000000000000000000000000000000000;;		sum        float64
0000000000000000000000000000000000000000;;		quantiles  map[float64]float64
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *constSummary) Desc() *Desc {
0000000000000000000000000000000000000000;;		return s.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *constSummary) Write(out *dto.Metric) error {
0000000000000000000000000000000000000000;;		sum := &dto.Summary{}
0000000000000000000000000000000000000000;;		qs := make([]*dto.Quantile, 0, len(s.quantiles))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sum.SampleCount = proto.Uint64(s.count)
0000000000000000000000000000000000000000;;		sum.SampleSum = proto.Float64(s.sum)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for rank, q := range s.quantiles {
0000000000000000000000000000000000000000;;			qs = append(qs, &dto.Quantile{
0000000000000000000000000000000000000000;;				Quantile: proto.Float64(rank),
0000000000000000000000000000000000000000;;				Value:    proto.Float64(q),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(qs) > 0 {
0000000000000000000000000000000000000000;;			sort.Sort(quantSort(qs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sum.Quantile = qs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Summary = sum
0000000000000000000000000000000000000000;;		out.Label = s.labelPairs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConstSummary returns a metric representing a Prometheus summary with fixed
0000000000000000000000000000000000000000;;	// values for the count, sum, and quantiles. As those parameters cannot be
0000000000000000000000000000000000000000;;	// changed, the returned value does not implement the Summary interface (but
0000000000000000000000000000000000000000;;	// only the Metric interface). Users of this package will not have much use for
0000000000000000000000000000000000000000;;	// it in regular operations. However, when implementing custom Collectors, it is
0000000000000000000000000000000000000000;;	// useful as a throw-away metric that is generated on the fly to send it to
0000000000000000000000000000000000000000;;	// Prometheus in the Collect method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// quantiles maps ranks to quantile values. For example, a median latency of
0000000000000000000000000000000000000000;;	// 0.23s and a 99th percentile latency of 0.56s would be expressed as:
0000000000000000000000000000000000000000;;	//     map[float64]float64{0.5: 0.23, 0.99: 0.56}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NewConstSummary returns an error if the length of labelValues is not
0000000000000000000000000000000000000000;;	// consistent with the variable labels in Desc.
0000000000000000000000000000000000000000;;	func NewConstSummary(
0000000000000000000000000000000000000000;;		desc *Desc,
0000000000000000000000000000000000000000;;		count uint64,
0000000000000000000000000000000000000000;;		sum float64,
0000000000000000000000000000000000000000;;		quantiles map[float64]float64,
0000000000000000000000000000000000000000;;		labelValues ...string,
0000000000000000000000000000000000000000;;	) (Metric, error) {
0000000000000000000000000000000000000000;;		if len(desc.variableLabels) != len(labelValues) {
0000000000000000000000000000000000000000;;			return nil, errInconsistentCardinality
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &constSummary{
0000000000000000000000000000000000000000;;			desc:       desc,
0000000000000000000000000000000000000000;;			count:      count,
0000000000000000000000000000000000000000;;			sum:        sum,
0000000000000000000000000000000000000000;;			quantiles:  quantiles,
0000000000000000000000000000000000000000;;			labelPairs: makeLabelPairs(desc, labelValues),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustNewConstSummary is a version of NewConstSummary that panics where
0000000000000000000000000000000000000000;;	// NewConstMetric would have returned an error.
0000000000000000000000000000000000000000;;	func MustNewConstSummary(
0000000000000000000000000000000000000000;;		desc *Desc,
0000000000000000000000000000000000000000;;		count uint64,
0000000000000000000000000000000000000000;;		sum float64,
0000000000000000000000000000000000000000;;		quantiles map[float64]float64,
0000000000000000000000000000000000000000;;		labelValues ...string,
0000000000000000000000000000000000000000;;	) Metric {
0000000000000000000000000000000000000000;;		m, err := NewConstSummary(desc, count, sum, quantiles, labelValues...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
