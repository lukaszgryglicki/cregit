0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/registry.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/registry.go][vendor/github.com/prometheus/client_golang/prometheus/registry.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Capacity for the channel to collect metrics and descriptors.
0000000000000000000000000000000000000000;;		capMetricChan = 1000
0000000000000000000000000000000000000000;;		capDescChan   = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultRegisterer and DefaultGatherer are the implementations of the
0000000000000000000000000000000000000000;;	// Registerer and Gatherer interface a number of convenience functions in this
0000000000000000000000000000000000000000;;	// package act on. Initially, both variables point to the same Registry, which
0000000000000000000000000000000000000000;;	// has a process collector (see NewProcessCollector) and a Go collector (see
0000000000000000000000000000000000000000;;	// NewGoCollector) already registered. This approach to keep default instances
0000000000000000000000000000000000000000;;	// as global state mirrors the approach of other packages in the Go standard
0000000000000000000000000000000000000000;;	// library. Note that there are caveats. Change the variables with caution and
0000000000000000000000000000000000000000;;	// only if you understand the consequences. Users who want to avoid global state
0000000000000000000000000000000000000000;;	// altogether should not use the convenience function and act on custom
0000000000000000000000000000000000000000;;	// instances instead.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultRegistry              = NewRegistry()
0000000000000000000000000000000000000000;;		DefaultRegisterer Registerer = defaultRegistry
0000000000000000000000000000000000000000;;		DefaultGatherer   Gatherer   = defaultRegistry
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		MustRegister(NewProcessCollector(os.Getpid(), ""))
0000000000000000000000000000000000000000;;		MustRegister(NewGoCollector())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRegistry creates a new vanilla Registry without any Collectors
0000000000000000000000000000000000000000;;	// pre-registered.
0000000000000000000000000000000000000000;;	func NewRegistry() *Registry {
0000000000000000000000000000000000000000;;		return &Registry{
0000000000000000000000000000000000000000;;			collectorsByID:  map[uint64]Collector{},
0000000000000000000000000000000000000000;;			descIDs:         map[uint64]struct{}{},
0000000000000000000000000000000000000000;;			dimHashesByName: map[string]uint64{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPedanticRegistry returns a registry that checks during collection if each
0000000000000000000000000000000000000000;;	// collected Metric is consistent with its reported Desc, and if the Desc has
0000000000000000000000000000000000000000;;	// actually been registered with the registry.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Usually, a Registry will be happy as long as the union of all collected
0000000000000000000000000000000000000000;;	// Metrics is consistent and valid even if some metrics are not consistent with
0000000000000000000000000000000000000000;;	// their own Desc or a Desc provided by their registered Collector. Well-behaved
0000000000000000000000000000000000000000;;	// Collectors and Metrics will only provide consistent Descs. This Registry is
0000000000000000000000000000000000000000;;	// useful to test the implementation of Collectors and Metrics.
0000000000000000000000000000000000000000;;	func NewPedanticRegistry() *Registry {
0000000000000000000000000000000000000000;;		r := NewRegistry()
0000000000000000000000000000000000000000;;		r.pedanticChecksEnabled = true
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Registerer is the interface for the part of a registry in charge of
0000000000000000000000000000000000000000;;	// registering and unregistering. Users of custom registries should use
0000000000000000000000000000000000000000;;	// Registerer as type for registration purposes (rather then the Registry type
0000000000000000000000000000000000000000;;	// directly). In that way, they are free to use custom Registerer implementation
0000000000000000000000000000000000000000;;	// (e.g. for testing purposes).
0000000000000000000000000000000000000000;;	type Registerer interface {
0000000000000000000000000000000000000000;;		// Register registers a new Collector to be included in metrics
0000000000000000000000000000000000000000;;		// collection. It returns an error if the descriptors provided by the
0000000000000000000000000000000000000000;;		// Collector are invalid or if they — in combination with descriptors of
0000000000000000000000000000000000000000;;		// already registered Collectors — do not fulfill the consistency and
0000000000000000000000000000000000000000;;		// uniqueness criteria described in the documentation of metric.Desc.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the provided Collector is equal to a Collector already registered
0000000000000000000000000000000000000000;;		// (which includes the case of re-registering the same Collector), the
0000000000000000000000000000000000000000;;		// returned error is an instance of AlreadyRegisteredError, which
0000000000000000000000000000000000000000;;		// contains the previously registered Collector.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// It is in general not safe to register the same Collector multiple
0000000000000000000000000000000000000000;;		// times concurrently.
0000000000000000000000000000000000000000;;		Register(Collector) error
0000000000000000000000000000000000000000;;		// MustRegister works like Register but registers any number of
0000000000000000000000000000000000000000;;		// Collectors and panics upon the first registration that causes an
0000000000000000000000000000000000000000;;		// error.
0000000000000000000000000000000000000000;;		MustRegister(...Collector)
0000000000000000000000000000000000000000;;		// Unregister unregisters the Collector that equals the Collector passed
0000000000000000000000000000000000000000;;		// in as an argument.  (Two Collectors are considered equal if their
0000000000000000000000000000000000000000;;		// Describe method yields the same set of descriptors.) The function
0000000000000000000000000000000000000000;;		// returns whether a Collector was unregistered.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note that even after unregistering, it will not be possible to
0000000000000000000000000000000000000000;;		// register a new Collector that is inconsistent with the unregistered
0000000000000000000000000000000000000000;;		// Collector, e.g. a Collector collecting metrics with the same name but
0000000000000000000000000000000000000000;;		// a different help string. The rationale here is that the same registry
0000000000000000000000000000000000000000;;		// instance must only collect consistent metrics throughout its
0000000000000000000000000000000000000000;;		// lifetime.
0000000000000000000000000000000000000000;;		Unregister(Collector) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gatherer is the interface for the part of a registry in charge of gathering
0000000000000000000000000000000000000000;;	// the collected metrics into a number of MetricFamilies. The Gatherer interface
0000000000000000000000000000000000000000;;	// comes with the same general implication as described for the Registerer
0000000000000000000000000000000000000000;;	// interface.
0000000000000000000000000000000000000000;;	type Gatherer interface {
0000000000000000000000000000000000000000;;		// Gather calls the Collect method of the registered Collectors and then
0000000000000000000000000000000000000000;;		// gathers the collected metrics into a lexicographically sorted slice
0000000000000000000000000000000000000000;;		// of MetricFamily protobufs. Even if an error occurs, Gather attempts
0000000000000000000000000000000000000000;;		// to gather as many metrics as possible. Hence, if a non-nil error is
0000000000000000000000000000000000000000;;		// returned, the returned MetricFamily slice could be nil (in case of a
0000000000000000000000000000000000000000;;		// fatal error that prevented any meaningful metric collection) or
0000000000000000000000000000000000000000;;		// contain a number of MetricFamily protobufs, some of which might be
0000000000000000000000000000000000000000;;		// incomplete, and some might be missing altogether. The returned error
0000000000000000000000000000000000000000;;		// (which might be a MultiError) explains the details. In scenarios
0000000000000000000000000000000000000000;;		// where complete collection is critical, the returned MetricFamily
0000000000000000000000000000000000000000;;		// protobufs should be disregarded if the returned error is non-nil.
0000000000000000000000000000000000000000;;		Gather() ([]*dto.MetricFamily, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register registers the provided Collector with the DefaultRegisterer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Register is a shortcut for DefaultRegisterer.Register(c). See there for more
0000000000000000000000000000000000000000;;	// details.
0000000000000000000000000000000000000000;;	func Register(c Collector) error {
0000000000000000000000000000000000000000;;		return DefaultRegisterer.Register(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustRegister registers the provided Collectors with the DefaultRegisterer and
0000000000000000000000000000000000000000;;	// panics if any error occurs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// MustRegister is a shortcut for DefaultRegisterer.MustRegister(cs...). See
0000000000000000000000000000000000000000;;	// there for more details.
0000000000000000000000000000000000000000;;	func MustRegister(cs ...Collector) {
0000000000000000000000000000000000000000;;		DefaultRegisterer.MustRegister(cs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unregister removes the registration of the provided Collector from the
0000000000000000000000000000000000000000;;	// DefaultRegisterer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unregister is a shortcut for DefaultRegisterer.Unregister(c). See there for
0000000000000000000000000000000000000000;;	// more details.
0000000000000000000000000000000000000000;;	func Unregister(c Collector) bool {
0000000000000000000000000000000000000000;;		return DefaultRegisterer.Unregister(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GathererFunc turns a function into a Gatherer.
0000000000000000000000000000000000000000;;	type GathererFunc func() ([]*dto.MetricFamily, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gather implements Gatherer.
0000000000000000000000000000000000000000;;	func (gf GathererFunc) Gather() ([]*dto.MetricFamily, error) {
0000000000000000000000000000000000000000;;		return gf()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AlreadyRegisteredError is returned by the Register method if the Collector to
0000000000000000000000000000000000000000;;	// be registered has already been registered before, or a different Collector
0000000000000000000000000000000000000000;;	// that collects the same metrics has been registered before. Registration fails
0000000000000000000000000000000000000000;;	// in that case, but you can detect from the kind of error what has
0000000000000000000000000000000000000000;;	// happened. The error contains fields for the existing Collector and the
0000000000000000000000000000000000000000;;	// (rejected) new Collector that equals the existing one. This can be used to
0000000000000000000000000000000000000000;;	// find out if an equal Collector has been registered before and switch over to
0000000000000000000000000000000000000000;;	// using the old one, as demonstrated in the example.
0000000000000000000000000000000000000000;;	type AlreadyRegisteredError struct {
0000000000000000000000000000000000000000;;		ExistingCollector, NewCollector Collector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err AlreadyRegisteredError) Error() string {
0000000000000000000000000000000000000000;;		return "duplicate metrics collector registration attempted"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultiError is a slice of errors implementing the error interface. It is used
0000000000000000000000000000000000000000;;	// by a Gatherer to report multiple errors during MetricFamily gathering.
0000000000000000000000000000000000000000;;	type MultiError []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (errs MultiError) Error() string {
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "%d error(s) occurred:", len(errs))
0000000000000000000000000000000000000000;;		for _, err := range errs {
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "\n* %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaybeUnwrap returns nil if len(errs) is 0. It returns the first and only
0000000000000000000000000000000000000000;;	// contained error as error if len(errs is 1). In all other cases, it returns
0000000000000000000000000000000000000000;;	// the MultiError directly. This is helpful for returning a MultiError in a way
0000000000000000000000000000000000000000;;	// that only uses the MultiError if needed.
0000000000000000000000000000000000000000;;	func (errs MultiError) MaybeUnwrap() error {
0000000000000000000000000000000000000000;;		switch len(errs) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return errs[0]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Registry registers Prometheus collectors, collects their metrics, and gathers
0000000000000000000000000000000000000000;;	// them into MetricFamilies for exposition. It implements both Registerer and
0000000000000000000000000000000000000000;;	// Gatherer. The zero value is not usable. Create instances with NewRegistry or
0000000000000000000000000000000000000000;;	// NewPedanticRegistry.
0000000000000000000000000000000000000000;;	type Registry struct {
0000000000000000000000000000000000000000;;		mtx                   sync.RWMutex
0000000000000000000000000000000000000000;;		collectorsByID        map[uint64]Collector // ID is a hash of the descIDs.
0000000000000000000000000000000000000000;;		descIDs               map[uint64]struct{}
0000000000000000000000000000000000000000;;		dimHashesByName       map[string]uint64
0000000000000000000000000000000000000000;;		pedanticChecksEnabled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register implements Registerer.
0000000000000000000000000000000000000000;;	func (r *Registry) Register(c Collector) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			descChan           = make(chan *Desc, capDescChan)
0000000000000000000000000000000000000000;;			newDescIDs         = map[uint64]struct{}{}
0000000000000000000000000000000000000000;;			newDimHashesByName = map[string]uint64{}
0000000000000000000000000000000000000000;;			collectorID        uint64 // Just a sum of all desc IDs.
0000000000000000000000000000000000000000;;			duplicateDescErr   error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			c.Describe(descChan)
0000000000000000000000000000000000000000;;			close(descChan)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		r.mtx.Lock()
0000000000000000000000000000000000000000;;		defer r.mtx.Unlock()
0000000000000000000000000000000000000000;;		// Conduct various tests...
0000000000000000000000000000000000000000;;		for desc := range descChan {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Is the descriptor valid at all?
0000000000000000000000000000000000000000;;			if desc.err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("descriptor %s is invalid: %s", desc, desc.err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Is the descID unique?
0000000000000000000000000000000000000000;;			// (In other words: Is the fqName + constLabel combination unique?)
0000000000000000000000000000000000000000;;			if _, exists := r.descIDs[desc.id]; exists {
0000000000000000000000000000000000000000;;				duplicateDescErr = fmt.Errorf("descriptor %s already exists with the same fully-qualified name and const label values", desc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If it is not a duplicate desc in this collector, add it to
0000000000000000000000000000000000000000;;			// the collectorID.  (We allow duplicate descs within the same
0000000000000000000000000000000000000000;;			// collector, but their existence must be a no-op.)
0000000000000000000000000000000000000000;;			if _, exists := newDescIDs[desc.id]; !exists {
0000000000000000000000000000000000000000;;				newDescIDs[desc.id] = struct{}{}
0000000000000000000000000000000000000000;;				collectorID += desc.id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Are all the label names and the help string consistent with
0000000000000000000000000000000000000000;;			// previous descriptors of the same name?
0000000000000000000000000000000000000000;;			// First check existing descriptors...
0000000000000000000000000000000000000000;;			if dimHash, exists := r.dimHashesByName[desc.fqName]; exists {
0000000000000000000000000000000000000000;;				if dimHash != desc.dimHash {
0000000000000000000000000000000000000000;;					return fmt.Errorf("a previously registered descriptor with the same fully-qualified name as %s has different label names or a different help string", desc)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// ...then check the new descriptors already seen.
0000000000000000000000000000000000000000;;				if dimHash, exists := newDimHashesByName[desc.fqName]; exists {
0000000000000000000000000000000000000000;;					if dimHash != desc.dimHash {
0000000000000000000000000000000000000000;;						return fmt.Errorf("descriptors reported by collector have inconsistent label names or help strings for the same fully-qualified name, offender is %s", desc)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					newDimHashesByName[desc.fqName] = desc.dimHash
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Did anything happen at all?
0000000000000000000000000000000000000000;;		if len(newDescIDs) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("collector has no descriptors")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if existing, exists := r.collectorsByID[collectorID]; exists {
0000000000000000000000000000000000000000;;			return AlreadyRegisteredError{
0000000000000000000000000000000000000000;;				ExistingCollector: existing,
0000000000000000000000000000000000000000;;				NewCollector:      c,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the collectorID is new, but at least one of the descs existed
0000000000000000000000000000000000000000;;		// before, we are in trouble.
0000000000000000000000000000000000000000;;		if duplicateDescErr != nil {
0000000000000000000000000000000000000000;;			return duplicateDescErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only after all tests have passed, actually register.
0000000000000000000000000000000000000000;;		r.collectorsByID[collectorID] = c
0000000000000000000000000000000000000000;;		for hash := range newDescIDs {
0000000000000000000000000000000000000000;;			r.descIDs[hash] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, dimHash := range newDimHashesByName {
0000000000000000000000000000000000000000;;			r.dimHashesByName[name] = dimHash
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unregister implements Registerer.
0000000000000000000000000000000000000000;;	func (r *Registry) Unregister(c Collector) bool {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			descChan    = make(chan *Desc, capDescChan)
0000000000000000000000000000000000000000;;			descIDs     = map[uint64]struct{}{}
0000000000000000000000000000000000000000;;			collectorID uint64 // Just a sum of the desc IDs.
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			c.Describe(descChan)
0000000000000000000000000000000000000000;;			close(descChan)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		for desc := range descChan {
0000000000000000000000000000000000000000;;			if _, exists := descIDs[desc.id]; !exists {
0000000000000000000000000000000000000000;;				collectorID += desc.id
0000000000000000000000000000000000000000;;				descIDs[desc.id] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.mtx.RLock()
0000000000000000000000000000000000000000;;		if _, exists := r.collectorsByID[collectorID]; !exists {
0000000000000000000000000000000000000000;;			r.mtx.RUnlock()
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.mtx.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.mtx.Lock()
0000000000000000000000000000000000000000;;		defer r.mtx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(r.collectorsByID, collectorID)
0000000000000000000000000000000000000000;;		for id := range descIDs {
0000000000000000000000000000000000000000;;			delete(r.descIDs, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// dimHashesByName is left untouched as those must be consistent
0000000000000000000000000000000000000000;;		// throughout the lifetime of a program.
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustRegister implements Registerer.
0000000000000000000000000000000000000000;;	func (r *Registry) MustRegister(cs ...Collector) {
0000000000000000000000000000000000000000;;		for _, c := range cs {
0000000000000000000000000000000000000000;;			if err := r.Register(c); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gather implements Gatherer.
0000000000000000000000000000000000000000;;	func (r *Registry) Gather() ([]*dto.MetricFamily, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			metricChan        = make(chan Metric, capMetricChan)
0000000000000000000000000000000000000000;;			metricHashes      = map[uint64]struct{}{}
0000000000000000000000000000000000000000;;			dimHashes         = map[string]uint64{}
0000000000000000000000000000000000000000;;			wg                sync.WaitGroup
0000000000000000000000000000000000000000;;			errs              MultiError          // The collected errors to return in the end.
0000000000000000000000000000000000000000;;			registeredDescIDs map[uint64]struct{} // Only used for pedantic checks
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.mtx.RLock()
0000000000000000000000000000000000000000;;		metricFamiliesByName := make(map[string]*dto.MetricFamily, len(r.dimHashesByName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scatter.
0000000000000000000000000000000000000000;;		// (Collectors could be complex and slow, so we call them all at once.)
0000000000000000000000000000000000000000;;		wg.Add(len(r.collectorsByID))
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;			close(metricChan)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		for _, collector := range r.collectorsByID {
0000000000000000000000000000000000000000;;			go func(collector Collector) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				collector.Collect(metricChan)
0000000000000000000000000000000000000000;;			}(collector)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In case pedantic checks are enabled, we have to copy the map before
0000000000000000000000000000000000000000;;		// giving up the RLock.
0000000000000000000000000000000000000000;;		if r.pedanticChecksEnabled {
0000000000000000000000000000000000000000;;			registeredDescIDs = make(map[uint64]struct{}, len(r.descIDs))
0000000000000000000000000000000000000000;;			for id := range r.descIDs {
0000000000000000000000000000000000000000;;				registeredDescIDs[id] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.mtx.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Drain metricChan in case of premature return.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			for range metricChan {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gather.
0000000000000000000000000000000000000000;;		for metric := range metricChan {
0000000000000000000000000000000000000000;;			// This could be done concurrently, too, but it required locking
0000000000000000000000000000000000000000;;			// of metricFamiliesByName (and of metricHashes if checks are
0000000000000000000000000000000000000000;;			// enabled). Most likely not worth it.
0000000000000000000000000000000000000000;;			desc := metric.Desc()
0000000000000000000000000000000000000000;;			dtoMetric := &dto.Metric{}
0000000000000000000000000000000000000000;;			if err := metric.Write(dtoMetric); err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;					"error collecting metric %v: %s", desc, err,
0000000000000000000000000000000000000000;;				))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metricFamily, ok := metricFamiliesByName[desc.fqName]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				if metricFamily.GetHelp() != desc.help {
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;						"collected metric %s %s has help %q but should have %q",
0000000000000000000000000000000000000000;;						desc.fqName, dtoMetric, desc.help, metricFamily.GetHelp(),
0000000000000000000000000000000000000000;;					))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO(beorn7): Simplify switch once Desc has type.
0000000000000000000000000000000000000000;;				switch metricFamily.GetType() {
0000000000000000000000000000000000000000;;				case dto.MetricType_COUNTER:
0000000000000000000000000000000000000000;;					if dtoMetric.Counter == nil {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;							"collected metric %s %s should be a Counter",
0000000000000000000000000000000000000000;;							desc.fqName, dtoMetric,
0000000000000000000000000000000000000000;;						))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case dto.MetricType_GAUGE:
0000000000000000000000000000000000000000;;					if dtoMetric.Gauge == nil {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;							"collected metric %s %s should be a Gauge",
0000000000000000000000000000000000000000;;							desc.fqName, dtoMetric,
0000000000000000000000000000000000000000;;						))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case dto.MetricType_SUMMARY:
0000000000000000000000000000000000000000;;					if dtoMetric.Summary == nil {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;							"collected metric %s %s should be a Summary",
0000000000000000000000000000000000000000;;							desc.fqName, dtoMetric,
0000000000000000000000000000000000000000;;						))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case dto.MetricType_UNTYPED:
0000000000000000000000000000000000000000;;					if dtoMetric.Untyped == nil {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;							"collected metric %s %s should be Untyped",
0000000000000000000000000000000000000000;;							desc.fqName, dtoMetric,
0000000000000000000000000000000000000000;;						))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case dto.MetricType_HISTOGRAM:
0000000000000000000000000000000000000000;;					if dtoMetric.Histogram == nil {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;							"collected metric %s %s should be a Histogram",
0000000000000000000000000000000000000000;;							desc.fqName, dtoMetric,
0000000000000000000000000000000000000000;;						))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic("encountered MetricFamily with invalid type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				metricFamily = &dto.MetricFamily{}
0000000000000000000000000000000000000000;;				metricFamily.Name = proto.String(desc.fqName)
0000000000000000000000000000000000000000;;				metricFamily.Help = proto.String(desc.help)
0000000000000000000000000000000000000000;;				// TODO(beorn7): Simplify switch once Desc has type.
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case dtoMetric.Gauge != nil:
0000000000000000000000000000000000000000;;					metricFamily.Type = dto.MetricType_GAUGE.Enum()
0000000000000000000000000000000000000000;;				case dtoMetric.Counter != nil:
0000000000000000000000000000000000000000;;					metricFamily.Type = dto.MetricType_COUNTER.Enum()
0000000000000000000000000000000000000000;;				case dtoMetric.Summary != nil:
0000000000000000000000000000000000000000;;					metricFamily.Type = dto.MetricType_SUMMARY.Enum()
0000000000000000000000000000000000000000;;				case dtoMetric.Untyped != nil:
0000000000000000000000000000000000000000;;					metricFamily.Type = dto.MetricType_UNTYPED.Enum()
0000000000000000000000000000000000000000;;				case dtoMetric.Histogram != nil:
0000000000000000000000000000000000000000;;					metricFamily.Type = dto.MetricType_HISTOGRAM.Enum()
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;						"empty metric collected: %s", dtoMetric,
0000000000000000000000000000000000000000;;					))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				metricFamiliesByName[desc.fqName] = metricFamily
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := checkMetricConsistency(metricFamily, dtoMetric, metricHashes, dimHashes); err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.pedanticChecksEnabled {
0000000000000000000000000000000000000000;;				// Is the desc registered at all?
0000000000000000000000000000000000000000;;				if _, exist := registeredDescIDs[desc.id]; !exist {
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;						"collected metric %s %s with unregistered descriptor %s",
0000000000000000000000000000000000000000;;						metricFamily.GetName(), dtoMetric, desc,
0000000000000000000000000000000000000000;;					))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := checkDescConsistency(metricFamily, dtoMetric, desc); err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			metricFamily.Metric = append(metricFamily.Metric, dtoMetric)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return normalizeMetricFamilies(metricFamiliesByName), errs.MaybeUnwrap()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gatherers is a slice of Gatherer instances that implements the Gatherer
0000000000000000000000000000000000000000;;	// interface itself. Its Gather method calls Gather on all Gatherers in the
0000000000000000000000000000000000000000;;	// slice in order and returns the merged results. Errors returned from the
0000000000000000000000000000000000000000;;	// Gather calles are all returned in a flattened MultiError. Duplicate and
0000000000000000000000000000000000000000;;	// inconsistent Metrics are skipped (first occurrence in slice order wins) and
0000000000000000000000000000000000000000;;	// reported in the returned error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Gatherers can be used to merge the Gather results from multiple
0000000000000000000000000000000000000000;;	// Registries. It also provides a way to directly inject existing MetricFamily
0000000000000000000000000000000000000000;;	// protobufs into the gathering by creating a custom Gatherer with a Gather
0000000000000000000000000000000000000000;;	// method that simply returns the existing MetricFamily protobufs. Note that no
0000000000000000000000000000000000000000;;	// registration is involved (in contrast to Collector registration), so
0000000000000000000000000000000000000000;;	// obviously registration-time checks cannot happen. Any inconsistencies between
0000000000000000000000000000000000000000;;	// the gathered MetricFamilies are reported as errors by the Gather method, and
0000000000000000000000000000000000000000;;	// inconsistent Metrics are dropped. Invalid parts of the MetricFamilies
0000000000000000000000000000000000000000;;	// (e.g. syntactically invalid metric or label names) will go undetected.
0000000000000000000000000000000000000000;;	type Gatherers []Gatherer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gather implements Gatherer.
0000000000000000000000000000000000000000;;	func (gs Gatherers) Gather() ([]*dto.MetricFamily, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			metricFamiliesByName = map[string]*dto.MetricFamily{}
0000000000000000000000000000000000000000;;			metricHashes         = map[uint64]struct{}{}
0000000000000000000000000000000000000000;;			dimHashes            = map[string]uint64{}
0000000000000000000000000000000000000000;;			errs                 MultiError // The collected errors to return in the end.
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, g := range gs {
0000000000000000000000000000000000000000;;			mfs, err := g.Gather()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if multiErr, ok := err.(MultiError); ok {
0000000000000000000000000000000000000000;;					for _, err := range multiErr {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf("[from Gatherer #%d] %s", i+1, err))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Errorf("[from Gatherer #%d] %s", i+1, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, mf := range mfs {
0000000000000000000000000000000000000000;;				existingMF, exists := metricFamiliesByName[mf.GetName()]
0000000000000000000000000000000000000000;;				if exists {
0000000000000000000000000000000000000000;;					if existingMF.GetHelp() != mf.GetHelp() {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;							"gathered metric family %s has help %q but should have %q",
0000000000000000000000000000000000000000;;							mf.GetName(), mf.GetHelp(), existingMF.GetHelp(),
0000000000000000000000000000000000000000;;						))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if existingMF.GetType() != mf.GetType() {
0000000000000000000000000000000000000000;;						errs = append(errs, fmt.Errorf(
0000000000000000000000000000000000000000;;							"gathered metric family %s has type %s but should have %s",
0000000000000000000000000000000000000000;;							mf.GetName(), mf.GetType(), existingMF.GetType(),
0000000000000000000000000000000000000000;;						))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					existingMF = &dto.MetricFamily{}
0000000000000000000000000000000000000000;;					existingMF.Name = mf.Name
0000000000000000000000000000000000000000;;					existingMF.Help = mf.Help
0000000000000000000000000000000000000000;;					existingMF.Type = mf.Type
0000000000000000000000000000000000000000;;					metricFamiliesByName[mf.GetName()] = existingMF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, m := range mf.Metric {
0000000000000000000000000000000000000000;;					if err := checkMetricConsistency(existingMF, m, metricHashes, dimHashes); err != nil {
0000000000000000000000000000000000000000;;						errs = append(errs, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					existingMF.Metric = append(existingMF.Metric, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return normalizeMetricFamilies(metricFamiliesByName), errs.MaybeUnwrap()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// metricSorter is a sortable slice of *dto.Metric.
0000000000000000000000000000000000000000;;	type metricSorter []*dto.Metric
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s metricSorter) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s metricSorter) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s metricSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if len(s[i].Label) != len(s[j].Label) {
0000000000000000000000000000000000000000;;			// This should not happen. The metrics are
0000000000000000000000000000000000000000;;			// inconsistent. However, we have to deal with the fact, as
0000000000000000000000000000000000000000;;			// people might use custom collectors or metric family injection
0000000000000000000000000000000000000000;;			// to create inconsistent metrics. So let's simply compare the
0000000000000000000000000000000000000000;;			// number of labels in this case. That will still yield
0000000000000000000000000000000000000000;;			// reproducible sorting.
0000000000000000000000000000000000000000;;			return len(s[i].Label) < len(s[j].Label)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for n, lp := range s[i].Label {
0000000000000000000000000000000000000000;;			vi := lp.GetValue()
0000000000000000000000000000000000000000;;			vj := s[j].Label[n].GetValue()
0000000000000000000000000000000000000000;;			if vi != vj {
0000000000000000000000000000000000000000;;				return vi < vj
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We should never arrive here. Multiple metrics with the same
0000000000000000000000000000000000000000;;		// label set in the same scrape will lead to undefined ingestion
0000000000000000000000000000000000000000;;		// behavior. However, as above, we have to provide stable sorting
0000000000000000000000000000000000000000;;		// here, even for inconsistent metrics. So sort equal metrics
0000000000000000000000000000000000000000;;		// by their timestamp, with missing timestamps (implying "now")
0000000000000000000000000000000000000000;;		// coming last.
0000000000000000000000000000000000000000;;		if s[i].TimestampMs == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s[j].TimestampMs == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s[i].GetTimestampMs() < s[j].GetTimestampMs()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// normalizeMetricFamilies returns a MetricFamily slice with empty
0000000000000000000000000000000000000000;;	// MetricFamilies pruned and the remaining MetricFamilies sorted by name within
0000000000000000000000000000000000000000;;	// the slice, with the contained Metrics sorted within each MetricFamily.
0000000000000000000000000000000000000000;;	func normalizeMetricFamilies(metricFamiliesByName map[string]*dto.MetricFamily) []*dto.MetricFamily {
0000000000000000000000000000000000000000;;		for _, mf := range metricFamiliesByName {
0000000000000000000000000000000000000000;;			sort.Sort(metricSorter(mf.Metric))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		names := make([]string, 0, len(metricFamiliesByName))
0000000000000000000000000000000000000000;;		for name, mf := range metricFamiliesByName {
0000000000000000000000000000000000000000;;			if len(mf.Metric) > 0 {
0000000000000000000000000000000000000000;;				names = append(names, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(names)
0000000000000000000000000000000000000000;;		result := make([]*dto.MetricFamily, 0, len(names))
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			result = append(result, metricFamiliesByName[name])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkMetricConsistency checks if the provided Metric is consistent with the
0000000000000000000000000000000000000000;;	// provided MetricFamily. It also hashed the Metric labels and the MetricFamily
0000000000000000000000000000000000000000;;	// name. If the resulting hash is alread in the provided metricHashes, an error
0000000000000000000000000000000000000000;;	// is returned. If not, it is added to metricHashes. The provided dimHashes maps
0000000000000000000000000000000000000000;;	// MetricFamily names to their dimHash (hashed sorted label names). If dimHashes
0000000000000000000000000000000000000000;;	// doesn't yet contain a hash for the provided MetricFamily, it is
0000000000000000000000000000000000000000;;	// added. Otherwise, an error is returned if the existing dimHashes in not equal
0000000000000000000000000000000000000000;;	// the calculated dimHash.
0000000000000000000000000000000000000000;;	func checkMetricConsistency(
0000000000000000000000000000000000000000;;		metricFamily *dto.MetricFamily,
0000000000000000000000000000000000000000;;		dtoMetric *dto.Metric,
0000000000000000000000000000000000000000;;		metricHashes map[uint64]struct{},
0000000000000000000000000000000000000000;;		dimHashes map[string]uint64,
0000000000000000000000000000000000000000;;	) error {
0000000000000000000000000000000000000000;;		// Type consistency with metric family.
0000000000000000000000000000000000000000;;		if metricFamily.GetType() == dto.MetricType_GAUGE && dtoMetric.Gauge == nil ||
0000000000000000000000000000000000000000;;			metricFamily.GetType() == dto.MetricType_COUNTER && dtoMetric.Counter == nil ||
0000000000000000000000000000000000000000;;			metricFamily.GetType() == dto.MetricType_SUMMARY && dtoMetric.Summary == nil ||
0000000000000000000000000000000000000000;;			metricFamily.GetType() == dto.MetricType_HISTOGRAM && dtoMetric.Histogram == nil ||
0000000000000000000000000000000000000000;;			metricFamily.GetType() == dto.MetricType_UNTYPED && dtoMetric.Untyped == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"collected metric %s %s is not a %s",
0000000000000000000000000000000000000000;;				metricFamily.GetName(), dtoMetric, metricFamily.GetType(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is the metric unique (i.e. no other metric with the same name and the same label values)?
0000000000000000000000000000000000000000;;		h := hashNew()
0000000000000000000000000000000000000000;;		h = hashAdd(h, metricFamily.GetName())
0000000000000000000000000000000000000000;;		h = hashAddByte(h, separatorByte)
0000000000000000000000000000000000000000;;		dh := hashNew()
0000000000000000000000000000000000000000;;		// Make sure label pairs are sorted. We depend on it for the consistency
0000000000000000000000000000000000000000;;		// check.
0000000000000000000000000000000000000000;;		sort.Sort(LabelPairSorter(dtoMetric.Label))
0000000000000000000000000000000000000000;;		for _, lp := range dtoMetric.Label {
0000000000000000000000000000000000000000;;			h = hashAdd(h, lp.GetValue())
0000000000000000000000000000000000000000;;			h = hashAddByte(h, separatorByte)
0000000000000000000000000000000000000000;;			dh = hashAdd(dh, lp.GetName())
0000000000000000000000000000000000000000;;			dh = hashAddByte(dh, separatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, exists := metricHashes[h]; exists {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"collected metric %s %s was collected before with the same name and label values",
0000000000000000000000000000000000000000;;				metricFamily.GetName(), dtoMetric,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dimHash, ok := dimHashes[metricFamily.GetName()]; ok {
0000000000000000000000000000000000000000;;			if dimHash != dh {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"collected metric %s %s has label dimensions inconsistent with previously collected metrics in the same metric family",
0000000000000000000000000000000000000000;;					metricFamily.GetName(), dtoMetric,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dimHashes[metricFamily.GetName()] = dh
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metricHashes[h] = struct{}{}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkDescConsistency(
0000000000000000000000000000000000000000;;		metricFamily *dto.MetricFamily,
0000000000000000000000000000000000000000;;		dtoMetric *dto.Metric,
0000000000000000000000000000000000000000;;		desc *Desc,
0000000000000000000000000000000000000000;;	) error {
0000000000000000000000000000000000000000;;		// Desc help consistency with metric family help.
0000000000000000000000000000000000000000;;		if metricFamily.GetHelp() != desc.help {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"collected metric %s %s has help %q but should have %q",
0000000000000000000000000000000000000000;;				metricFamily.GetName(), dtoMetric, metricFamily.GetHelp(), desc.help,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is the desc consistent with the content of the metric?
0000000000000000000000000000000000000000;;		lpsFromDesc := make([]*dto.LabelPair, 0, len(dtoMetric.Label))
0000000000000000000000000000000000000000;;		lpsFromDesc = append(lpsFromDesc, desc.constLabelPairs...)
0000000000000000000000000000000000000000;;		for _, l := range desc.variableLabels {
0000000000000000000000000000000000000000;;			lpsFromDesc = append(lpsFromDesc, &dto.LabelPair{
0000000000000000000000000000000000000000;;				Name: proto.String(l),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(lpsFromDesc) != len(dtoMetric.Label) {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"labels in collected metric %s %s are inconsistent with descriptor %s",
0000000000000000000000000000000000000000;;				metricFamily.GetName(), dtoMetric, desc,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(LabelPairSorter(lpsFromDesc))
0000000000000000000000000000000000000000;;		for i, lpFromDesc := range lpsFromDesc {
0000000000000000000000000000000000000000;;			lpFromMetric := dtoMetric.Label[i]
0000000000000000000000000000000000000000;;			if lpFromDesc.GetName() != lpFromMetric.GetName() ||
0000000000000000000000000000000000000000;;				lpFromDesc.Value != nil && lpFromDesc.GetValue() != lpFromMetric.GetValue() {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"labels in collected metric %s %s are inconsistent with descriptor %s",
0000000000000000000000000000000000000000;;					metricFamily.GetName(), dtoMetric, desc,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
