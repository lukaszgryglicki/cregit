0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/gauge.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/gauge.go][vendor/github.com/prometheus/client_golang/prometheus/gauge.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gauge is a Metric that represents a single numerical value that can
0000000000000000000000000000000000000000;;	// arbitrarily go up and down.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A Gauge is typically used for measured values like temperatures or current
0000000000000000000000000000000000000000;;	// memory usage, but also "counts" that can go up and down, like the number of
0000000000000000000000000000000000000000;;	// running goroutines.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create Gauge instances, use NewGauge.
0000000000000000000000000000000000000000;;	type Gauge interface {
0000000000000000000000000000000000000000;;		Metric
0000000000000000000000000000000000000000;;		Collector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set sets the Gauge to an arbitrary value.
0000000000000000000000000000000000000000;;		Set(float64)
0000000000000000000000000000000000000000;;		// Inc increments the Gauge by 1. Use Add to increment it by arbitrary
0000000000000000000000000000000000000000;;		// values.
0000000000000000000000000000000000000000;;		Inc()
0000000000000000000000000000000000000000;;		// Dec decrements the Gauge by 1. Use Sub to decrement it by arbitrary
0000000000000000000000000000000000000000;;		// values.
0000000000000000000000000000000000000000;;		Dec()
0000000000000000000000000000000000000000;;		// Add adds the given value to the Gauge. (The value can be negative,
0000000000000000000000000000000000000000;;		// resulting in a decrease of the Gauge.)
0000000000000000000000000000000000000000;;		Add(float64)
0000000000000000000000000000000000000000;;		// Sub subtracts the given value from the Gauge. (The value can be
0000000000000000000000000000000000000000;;		// negative, resulting in an increase of the Gauge.)
0000000000000000000000000000000000000000;;		Sub(float64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetToCurrentTime sets the Gauge to the current Unix time in seconds.
0000000000000000000000000000000000000000;;		SetToCurrentTime()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GaugeOpts is an alias for Opts. See there for doc comments.
0000000000000000000000000000000000000000;;	type GaugeOpts Opts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGauge creates a new Gauge based on the provided GaugeOpts.
0000000000000000000000000000000000000000;;	func NewGauge(opts GaugeOpts) Gauge {
0000000000000000000000000000000000000000;;		return newValue(NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		), GaugeValue, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GaugeVec is a Collector that bundles a set of Gauges that all share the same
0000000000000000000000000000000000000000;;	// Desc, but have different values for their variable labels. This is used if
0000000000000000000000000000000000000000;;	// you want to count the same thing partitioned by various dimensions
0000000000000000000000000000000000000000;;	// (e.g. number of operations queued, partitioned by user and operation
0000000000000000000000000000000000000000;;	// type). Create instances with NewGaugeVec.
0000000000000000000000000000000000000000;;	type GaugeVec struct {
0000000000000000000000000000000000000000;;		*MetricVec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGaugeVec creates a new GaugeVec based on the provided GaugeOpts and
0000000000000000000000000000000000000000;;	// partitioned by the given label names. At least one label name must be
0000000000000000000000000000000000000000;;	// provided.
0000000000000000000000000000000000000000;;	func NewGaugeVec(opts GaugeOpts, labelNames []string) *GaugeVec {
0000000000000000000000000000000000000000;;		desc := NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			labelNames,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return &GaugeVec{
0000000000000000000000000000000000000000;;			MetricVec: newMetricVec(desc, func(lvs ...string) Metric {
0000000000000000000000000000000000000000;;				return newValue(desc, GaugeValue, 0, lvs...)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues replaces the method of the same name in
0000000000000000000000000000000000000000;;	// MetricVec. The difference is that this method returns a Gauge and not a
0000000000000000000000000000000000000000;;	// Metric so that no type conversion is required.
0000000000000000000000000000000000000000;;	func (m *GaugeVec) GetMetricWithLabelValues(lvs ...string) (Gauge, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWithLabelValues(lvs...)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Gauge), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWith replaces the method of the same name in MetricVec. The
0000000000000000000000000000000000000000;;	// difference is that this method returns a Gauge and not a Metric so that no
0000000000000000000000000000000000000000;;	// type conversion is required.
0000000000000000000000000000000000000000;;	func (m *GaugeVec) GetMetricWith(labels Labels) (Gauge, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWith(labels)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Gauge), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithLabelValues works as GetMetricWithLabelValues, but panics where
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues would have returned an error. By not returning an
0000000000000000000000000000000000000000;;	// error, WithLabelValues allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.WithLabelValues("404", "GET").Add(42)
0000000000000000000000000000000000000000;;	func (m *GaugeVec) WithLabelValues(lvs ...string) Gauge {
0000000000000000000000000000000000000000;;		return m.MetricVec.WithLabelValues(lvs...).(Gauge)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// With works as GetMetricWith, but panics where GetMetricWithLabels would have
0000000000000000000000000000000000000000;;	// returned an error. By not returning an error, With allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.With(Labels{"code": "404", "method": "GET"}).Add(42)
0000000000000000000000000000000000000000;;	func (m *GaugeVec) With(labels Labels) Gauge {
0000000000000000000000000000000000000000;;		return m.MetricVec.With(labels).(Gauge)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GaugeFunc is a Gauge whose value is determined at collect time by calling a
0000000000000000000000000000000000000000;;	// provided function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create GaugeFunc instances, use NewGaugeFunc.
0000000000000000000000000000000000000000;;	type GaugeFunc interface {
0000000000000000000000000000000000000000;;		Metric
0000000000000000000000000000000000000000;;		Collector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGaugeFunc creates a new GaugeFunc based on the provided GaugeOpts. The
0000000000000000000000000000000000000000;;	// value reported is determined by calling the given function from within the
0000000000000000000000000000000000000000;;	// Write method. Take into account that metric collection may happen
0000000000000000000000000000000000000000;;	// concurrently. If that results in concurrent calls to Write, like in the case
0000000000000000000000000000000000000000;;	// where a GaugeFunc is directly registered with Prometheus, the provided
0000000000000000000000000000000000000000;;	// function must be concurrency-safe.
0000000000000000000000000000000000000000;;	func NewGaugeFunc(opts GaugeOpts, function func() float64) GaugeFunc {
0000000000000000000000000000000000000000;;		return newValueFunc(NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		), GaugeValue, function)
0000000000000000000000000000000000000000;;	}
