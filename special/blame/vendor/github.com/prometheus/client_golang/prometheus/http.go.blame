0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/http.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/http.go][vendor/github.com/prometheus/client_golang/prometheus/http.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/expfmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(beorn7): Remove this whole file. It is a partial mirror of
0000000000000000000000000000000000000000;;	// promhttp/http.go (to avoid circular import chains) where everything HTTP
0000000000000000000000000000000000000000;;	// related should live. The functions here are just for avoiding
0000000000000000000000000000000000000000;;	// breakage. Everything is deprecated.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		contentTypeHeader     = "Content-Type"
0000000000000000000000000000000000000000;;		contentLengthHeader   = "Content-Length"
0000000000000000000000000000000000000000;;		contentEncodingHeader = "Content-Encoding"
0000000000000000000000000000000000000000;;		acceptEncodingHeader  = "Accept-Encoding"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bufPool sync.Pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getBuf() *bytes.Buffer {
0000000000000000000000000000000000000000;;		buf := bufPool.Get()
0000000000000000000000000000000000000000;;		if buf == nil {
0000000000000000000000000000000000000000;;			return &bytes.Buffer{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.(*bytes.Buffer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func giveBuf(buf *bytes.Buffer) {
0000000000000000000000000000000000000000;;		buf.Reset()
0000000000000000000000000000000000000000;;		bufPool.Put(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler returns an HTTP handler for the DefaultGatherer. It is
0000000000000000000000000000000000000000;;	// already instrumented with InstrumentHandler (using "prometheus" as handler
0000000000000000000000000000000000000000;;	// name).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: Please note the issues described in the doc comment of
0000000000000000000000000000000000000000;;	// InstrumentHandler. You might want to consider using promhttp.Handler instead
0000000000000000000000000000000000000000;;	// (which is not instrumented, but can be instrumented with the tooling provided
0000000000000000000000000000000000000000;;	// in package promhttp).
0000000000000000000000000000000000000000;;	func Handler() http.Handler {
0000000000000000000000000000000000000000;;		return InstrumentHandler("prometheus", UninstrumentedHandler())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UninstrumentedHandler returns an HTTP handler for the DefaultGatherer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: Use promhttp.Handler instead. See there for further documentation.
0000000000000000000000000000000000000000;;	func UninstrumentedHandler() http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			mfs, err := DefaultGatherer.Gather()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, "An error has occurred during metrics collection:\n\n"+err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			contentType := expfmt.Negotiate(req.Header)
0000000000000000000000000000000000000000;;			buf := getBuf()
0000000000000000000000000000000000000000;;			defer giveBuf(buf)
0000000000000000000000000000000000000000;;			writer, encoding := decorateWriter(req, buf)
0000000000000000000000000000000000000000;;			enc := expfmt.NewEncoder(writer, contentType)
0000000000000000000000000000000000000000;;			var lastErr error
0000000000000000000000000000000000000000;;			for _, mf := range mfs {
0000000000000000000000000000000000000000;;				if err := enc.Encode(mf); err != nil {
0000000000000000000000000000000000000000;;					lastErr = err
0000000000000000000000000000000000000000;;					http.Error(w, "An error has occurred during metrics encoding:\n\n"+err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if closer, ok := writer.(io.Closer); ok {
0000000000000000000000000000000000000000;;				closer.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lastErr != nil && buf.Len() == 0 {
0000000000000000000000000000000000000000;;				http.Error(w, "No metrics encoded, last error:\n\n"+err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			header := w.Header()
0000000000000000000000000000000000000000;;			header.Set(contentTypeHeader, string(contentType))
0000000000000000000000000000000000000000;;			header.Set(contentLengthHeader, fmt.Sprint(buf.Len()))
0000000000000000000000000000000000000000;;			if encoding != "" {
0000000000000000000000000000000000000000;;				header.Set(contentEncodingHeader, encoding)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(buf.Bytes())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decorateWriter wraps a writer to handle gzip compression if requested.  It
0000000000000000000000000000000000000000;;	// returns the decorated writer and the appropriate "Content-Encoding" header
0000000000000000000000000000000000000000;;	// (which is empty if no compression is enabled).
0000000000000000000000000000000000000000;;	func decorateWriter(request *http.Request, writer io.Writer) (io.Writer, string) {
0000000000000000000000000000000000000000;;		header := request.Header.Get(acceptEncodingHeader)
0000000000000000000000000000000000000000;;		parts := strings.Split(header, ",")
0000000000000000000000000000000000000000;;		for _, part := range parts {
0000000000000000000000000000000000000000;;			part := strings.TrimSpace(part)
0000000000000000000000000000000000000000;;			if part == "gzip" || strings.HasPrefix(part, "gzip;") {
0000000000000000000000000000000000000000;;				return gzip.NewWriter(writer), "gzip"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return writer, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var instLabels = []string{"method", "code"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nower interface {
0000000000000000000000000000000000000000;;		Now() time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nowFunc func() time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n nowFunc) Now() time.Time {
0000000000000000000000000000000000000000;;		return n()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var now nower = nowFunc(func() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nowSeries(t ...time.Time) nower {
0000000000000000000000000000000000000000;;		return nowFunc(func() time.Time {
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				t = t[1:]
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return t[0]
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandler wraps the given HTTP handler for instrumentation. It
0000000000000000000000000000000000000000;;	// registers four metric collectors (if not already done) and reports HTTP
0000000000000000000000000000000000000000;;	// metrics to the (newly or already) registered collectors: http_requests_total
0000000000000000000000000000000000000000;;	// (CounterVec), http_request_duration_microseconds (Summary),
0000000000000000000000000000000000000000;;	// http_request_size_bytes (Summary), http_response_size_bytes (Summary). Each
0000000000000000000000000000000000000000;;	// has a constant label named "handler" with the provided handlerName as
0000000000000000000000000000000000000000;;	// value. http_requests_total is a metric vector partitioned by HTTP method
0000000000000000000000000000000000000000;;	// (label name "method") and HTTP status code (label name "code").
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: InstrumentHandler has several issues. Use the tooling provided in
0000000000000000000000000000000000000000;;	// package promhttp instead. The issues are the following:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - It uses Summaries rather than Histograms. Summaries are not useful if
0000000000000000000000000000000000000000;;	// aggregation across multiple instances is required.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - It uses microseconds as unit, which is deprecated and should be replaced by
0000000000000000000000000000000000000000;;	// seconds.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - The size of the request is calculated in a separate goroutine. Since this
0000000000000000000000000000000000000000;;	// calculator requires access to the request header, it creates a race with
0000000000000000000000000000000000000000;;	// any writes to the header performed during request handling.
0000000000000000000000000000000000000000;;	// httputil.ReverseProxy is a prominent example for a handler
0000000000000000000000000000000000000000;;	// performing such writes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - It has additional issues with HTTP/2, cf.
0000000000000000000000000000000000000000;;	// https://github.com/prometheus/client_golang/issues/272.
0000000000000000000000000000000000000000;;	func InstrumentHandler(handlerName string, handler http.Handler) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return InstrumentHandlerFunc(handlerName, handler.ServeHTTP)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerFunc wraps the given function for instrumentation. It
0000000000000000000000000000000000000000;;	// otherwise works in the same way as InstrumentHandler (and shares the same
0000000000000000000000000000000000000000;;	// issues).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: InstrumentHandlerFunc is deprecated for the same reasons as
0000000000000000000000000000000000000000;;	// InstrumentHandler is. Use the tooling provided in package promhttp instead.
0000000000000000000000000000000000000000;;	func InstrumentHandlerFunc(handlerName string, handlerFunc func(http.ResponseWriter, *http.Request)) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return InstrumentHandlerFuncWithOpts(
0000000000000000000000000000000000000000;;			SummaryOpts{
0000000000000000000000000000000000000000;;				Subsystem:   "http",
0000000000000000000000000000000000000000;;				ConstLabels: Labels{"handler": handlerName},
0000000000000000000000000000000000000000;;				Objectives:  map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			handlerFunc,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerWithOpts works like InstrumentHandler (and shares the same
0000000000000000000000000000000000000000;;	// issues) but provides more flexibility (at the cost of a more complex call
0000000000000000000000000000000000000000;;	// syntax). As InstrumentHandler, this function registers four metric
0000000000000000000000000000000000000000;;	// collectors, but it uses the provided SummaryOpts to create them. However, the
0000000000000000000000000000000000000000;;	// fields "Name" and "Help" in the SummaryOpts are ignored. "Name" is replaced
0000000000000000000000000000000000000000;;	// by "requests_total", "request_duration_microseconds", "request_size_bytes",
0000000000000000000000000000000000000000;;	// and "response_size_bytes", respectively. "Help" is replaced by an appropriate
0000000000000000000000000000000000000000;;	// help string. The names of the variable labels of the http_requests_total
0000000000000000000000000000000000000000;;	// CounterVec are "method" (get, post, etc.), and "code" (HTTP status code).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If InstrumentHandlerWithOpts is called as follows, it mimics exactly the
0000000000000000000000000000000000000000;;	// behavior of InstrumentHandler:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     prometheus.InstrumentHandlerWithOpts(
0000000000000000000000000000000000000000;;	//         prometheus.SummaryOpts{
0000000000000000000000000000000000000000;;	//              Subsystem:   "http",
0000000000000000000000000000000000000000;;	//              ConstLabels: prometheus.Labels{"handler": handlerName},
0000000000000000000000000000000000000000;;	//         },
0000000000000000000000000000000000000000;;	//         handler,
0000000000000000000000000000000000000000;;	//     )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Technical detail: "requests_total" is a CounterVec, not a SummaryVec, so it
0000000000000000000000000000000000000000;;	// cannot use SummaryOpts. Instead, a CounterOpts struct is created internally,
0000000000000000000000000000000000000000;;	// and all its fields are set to the equally named fields in the provided
0000000000000000000000000000000000000000;;	// SummaryOpts.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: InstrumentHandlerWithOpts is deprecated for the same reasons as
0000000000000000000000000000000000000000;;	// InstrumentHandler is. Use the tooling provided in package promhttp instead.
0000000000000000000000000000000000000000;;	func InstrumentHandlerWithOpts(opts SummaryOpts, handler http.Handler) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return InstrumentHandlerFuncWithOpts(opts, handler.ServeHTTP)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerFuncWithOpts works like InstrumentHandlerFunc (and shares
0000000000000000000000000000000000000000;;	// the same issues) but provides more flexibility (at the cost of a more complex
0000000000000000000000000000000000000000;;	// call syntax). See InstrumentHandlerWithOpts for details how the provided
0000000000000000000000000000000000000000;;	// SummaryOpts are used.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: InstrumentHandlerFuncWithOpts is deprecated for the same reasons
0000000000000000000000000000000000000000;;	// as InstrumentHandler is. Use the tooling provided in package promhttp instead.
0000000000000000000000000000000000000000;;	func InstrumentHandlerFuncWithOpts(opts SummaryOpts, handlerFunc func(http.ResponseWriter, *http.Request)) http.HandlerFunc {
0000000000000000000000000000000000000000;;		reqCnt := NewCounterVec(
0000000000000000000000000000000000000000;;			CounterOpts{
0000000000000000000000000000000000000000;;				Namespace:   opts.Namespace,
0000000000000000000000000000000000000000;;				Subsystem:   opts.Subsystem,
0000000000000000000000000000000000000000;;				Name:        "requests_total",
0000000000000000000000000000000000000000;;				Help:        "Total number of HTTP requests made.",
0000000000000000000000000000000000000000;;				ConstLabels: opts.ConstLabels,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			instLabels,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err := Register(reqCnt); err != nil {
0000000000000000000000000000000000000000;;			if are, ok := err.(AlreadyRegisteredError); ok {
0000000000000000000000000000000000000000;;				reqCnt = are.ExistingCollector.(*CounterVec)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.Name = "request_duration_microseconds"
0000000000000000000000000000000000000000;;		opts.Help = "The HTTP request latencies in microseconds."
0000000000000000000000000000000000000000;;		reqDur := NewSummary(opts)
0000000000000000000000000000000000000000;;		if err := Register(reqDur); err != nil {
0000000000000000000000000000000000000000;;			if are, ok := err.(AlreadyRegisteredError); ok {
0000000000000000000000000000000000000000;;				reqDur = are.ExistingCollector.(Summary)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.Name = "request_size_bytes"
0000000000000000000000000000000000000000;;		opts.Help = "The HTTP request sizes in bytes."
0000000000000000000000000000000000000000;;		reqSz := NewSummary(opts)
0000000000000000000000000000000000000000;;		if err := Register(reqSz); err != nil {
0000000000000000000000000000000000000000;;			if are, ok := err.(AlreadyRegisteredError); ok {
0000000000000000000000000000000000000000;;				reqSz = are.ExistingCollector.(Summary)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts.Name = "response_size_bytes"
0000000000000000000000000000000000000000;;		opts.Help = "The HTTP response sizes in bytes."
0000000000000000000000000000000000000000;;		resSz := NewSummary(opts)
0000000000000000000000000000000000000000;;		if err := Register(resSz); err != nil {
0000000000000000000000000000000000000000;;			if are, ok := err.(AlreadyRegisteredError); ok {
0000000000000000000000000000000000000000;;				resSz = are.ExistingCollector.(Summary)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			delegate := &responseWriterDelegator{ResponseWriter: w}
0000000000000000000000000000000000000000;;			out := computeApproximateRequestSize(r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, cn := w.(http.CloseNotifier)
0000000000000000000000000000000000000000;;			_, fl := w.(http.Flusher)
0000000000000000000000000000000000000000;;			_, hj := w.(http.Hijacker)
0000000000000000000000000000000000000000;;			_, rf := w.(io.ReaderFrom)
0000000000000000000000000000000000000000;;			var rw http.ResponseWriter
0000000000000000000000000000000000000000;;			if cn && fl && hj && rf {
0000000000000000000000000000000000000000;;				rw = &fancyResponseWriterDelegator{delegate}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rw = delegate
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handlerFunc(rw, r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			elapsed := float64(time.Since(now)) / float64(time.Microsecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			method := sanitizeMethod(r.Method)
0000000000000000000000000000000000000000;;			code := sanitizeCode(delegate.status)
0000000000000000000000000000000000000000;;			reqCnt.WithLabelValues(method, code).Inc()
0000000000000000000000000000000000000000;;			reqDur.Observe(elapsed)
0000000000000000000000000000000000000000;;			resSz.Observe(float64(delegate.written))
0000000000000000000000000000000000000000;;			reqSz.Observe(float64(<-out))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func computeApproximateRequestSize(r *http.Request) <-chan int {
0000000000000000000000000000000000000000;;		// Get URL length in current go routine for avoiding a race condition.
0000000000000000000000000000000000000000;;		// HandlerFunc that runs in parallel may modify the URL.
0000000000000000000000000000000000000000;;		s := 0
0000000000000000000000000000000000000000;;		if r.URL != nil {
0000000000000000000000000000000000000000;;			s += len(r.URL.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := make(chan int, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			s += len(r.Method)
0000000000000000000000000000000000000000;;			s += len(r.Proto)
0000000000000000000000000000000000000000;;			for name, values := range r.Header {
0000000000000000000000000000000000000000;;				s += len(name)
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					s += len(value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s += len(r.Host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// N.B. r.Form and r.MultipartForm are assumed to be included in r.URL.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.ContentLength != -1 {
0000000000000000000000000000000000000000;;				s += int(r.ContentLength)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out <- s
0000000000000000000000000000000000000000;;			close(out)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type responseWriterDelegator struct {
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler, method string
0000000000000000000000000000000000000000;;		status          int
0000000000000000000000000000000000000000;;		written         int64
0000000000000000000000000000000000000000;;		wroteHeader     bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriterDelegator) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		r.status = code
0000000000000000000000000000000000000000;;		r.wroteHeader = true
0000000000000000000000000000000000000000;;		r.ResponseWriter.WriteHeader(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriterDelegator) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !r.wroteHeader {
0000000000000000000000000000000000000000;;			r.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := r.ResponseWriter.Write(b)
0000000000000000000000000000000000000000;;		r.written += int64(n)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fancyResponseWriterDelegator struct {
0000000000000000000000000000000000000000;;		*responseWriterDelegator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyResponseWriterDelegator) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return f.ResponseWriter.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyResponseWriterDelegator) Flush() {
0000000000000000000000000000000000000000;;		f.ResponseWriter.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyResponseWriterDelegator) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		return f.ResponseWriter.(http.Hijacker).Hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fancyResponseWriterDelegator) ReadFrom(r io.Reader) (int64, error) {
0000000000000000000000000000000000000000;;		if !f.wroteHeader {
0000000000000000000000000000000000000000;;			f.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := f.ResponseWriter.(io.ReaderFrom).ReadFrom(r)
0000000000000000000000000000000000000000;;		f.written += n
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sanitizeMethod(m string) string {
0000000000000000000000000000000000000000;;		switch m {
0000000000000000000000000000000000000000;;		case "GET", "get":
0000000000000000000000000000000000000000;;			return "get"
0000000000000000000000000000000000000000;;		case "PUT", "put":
0000000000000000000000000000000000000000;;			return "put"
0000000000000000000000000000000000000000;;		case "HEAD", "head":
0000000000000000000000000000000000000000;;			return "head"
0000000000000000000000000000000000000000;;		case "POST", "post":
0000000000000000000000000000000000000000;;			return "post"
0000000000000000000000000000000000000000;;		case "DELETE", "delete":
0000000000000000000000000000000000000000;;			return "delete"
0000000000000000000000000000000000000000;;		case "CONNECT", "connect":
0000000000000000000000000000000000000000;;			return "connect"
0000000000000000000000000000000000000000;;		case "OPTIONS", "options":
0000000000000000000000000000000000000000;;			return "options"
0000000000000000000000000000000000000000;;		case "NOTIFY", "notify":
0000000000000000000000000000000000000000;;			return "notify"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return strings.ToLower(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sanitizeCode(s int) string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case 100:
0000000000000000000000000000000000000000;;			return "100"
0000000000000000000000000000000000000000;;		case 101:
0000000000000000000000000000000000000000;;			return "101"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 200:
0000000000000000000000000000000000000000;;			return "200"
0000000000000000000000000000000000000000;;		case 201:
0000000000000000000000000000000000000000;;			return "201"
0000000000000000000000000000000000000000;;		case 202:
0000000000000000000000000000000000000000;;			return "202"
0000000000000000000000000000000000000000;;		case 203:
0000000000000000000000000000000000000000;;			return "203"
0000000000000000000000000000000000000000;;		case 204:
0000000000000000000000000000000000000000;;			return "204"
0000000000000000000000000000000000000000;;		case 205:
0000000000000000000000000000000000000000;;			return "205"
0000000000000000000000000000000000000000;;		case 206:
0000000000000000000000000000000000000000;;			return "206"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 300:
0000000000000000000000000000000000000000;;			return "300"
0000000000000000000000000000000000000000;;		case 301:
0000000000000000000000000000000000000000;;			return "301"
0000000000000000000000000000000000000000;;		case 302:
0000000000000000000000000000000000000000;;			return "302"
0000000000000000000000000000000000000000;;		case 304:
0000000000000000000000000000000000000000;;			return "304"
0000000000000000000000000000000000000000;;		case 305:
0000000000000000000000000000000000000000;;			return "305"
0000000000000000000000000000000000000000;;		case 307:
0000000000000000000000000000000000000000;;			return "307"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 400:
0000000000000000000000000000000000000000;;			return "400"
0000000000000000000000000000000000000000;;		case 401:
0000000000000000000000000000000000000000;;			return "401"
0000000000000000000000000000000000000000;;		case 402:
0000000000000000000000000000000000000000;;			return "402"
0000000000000000000000000000000000000000;;		case 403:
0000000000000000000000000000000000000000;;			return "403"
0000000000000000000000000000000000000000;;		case 404:
0000000000000000000000000000000000000000;;			return "404"
0000000000000000000000000000000000000000;;		case 405:
0000000000000000000000000000000000000000;;			return "405"
0000000000000000000000000000000000000000;;		case 406:
0000000000000000000000000000000000000000;;			return "406"
0000000000000000000000000000000000000000;;		case 407:
0000000000000000000000000000000000000000;;			return "407"
0000000000000000000000000000000000000000;;		case 408:
0000000000000000000000000000000000000000;;			return "408"
0000000000000000000000000000000000000000;;		case 409:
0000000000000000000000000000000000000000;;			return "409"
0000000000000000000000000000000000000000;;		case 410:
0000000000000000000000000000000000000000;;			return "410"
0000000000000000000000000000000000000000;;		case 411:
0000000000000000000000000000000000000000;;			return "411"
0000000000000000000000000000000000000000;;		case 412:
0000000000000000000000000000000000000000;;			return "412"
0000000000000000000000000000000000000000;;		case 413:
0000000000000000000000000000000000000000;;			return "413"
0000000000000000000000000000000000000000;;		case 414:
0000000000000000000000000000000000000000;;			return "414"
0000000000000000000000000000000000000000;;		case 415:
0000000000000000000000000000000000000000;;			return "415"
0000000000000000000000000000000000000000;;		case 416:
0000000000000000000000000000000000000000;;			return "416"
0000000000000000000000000000000000000000;;		case 417:
0000000000000000000000000000000000000000;;			return "417"
0000000000000000000000000000000000000000;;		case 418:
0000000000000000000000000000000000000000;;			return "418"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 500:
0000000000000000000000000000000000000000;;			return "500"
0000000000000000000000000000000000000000;;		case 501:
0000000000000000000000000000000000000000;;			return "501"
0000000000000000000000000000000000000000;;		case 502:
0000000000000000000000000000000000000000;;			return "502"
0000000000000000000000000000000000000000;;		case 503:
0000000000000000000000000000000000000000;;			return "503"
0000000000000000000000000000000000000000;;		case 504:
0000000000000000000000000000000000000000;;			return "504"
0000000000000000000000000000000000000000;;		case 505:
0000000000000000000000000000000000000000;;			return "505"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 428:
0000000000000000000000000000000000000000;;			return "428"
0000000000000000000000000000000000000000;;		case 429:
0000000000000000000000000000000000000000;;			return "429"
0000000000000000000000000000000000000000;;		case 431:
0000000000000000000000000000000000000000;;			return "431"
0000000000000000000000000000000000000000;;		case 511:
0000000000000000000000000000000000000000;;			return "511"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return strconv.Itoa(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
