0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/metric.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/metric.go][vendor/github.com/prometheus/client_golang/prometheus/metric.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const separatorByte byte = 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Metric models a single sample value with its meta data being exported to
0000000000000000000000000000000000000000;;	// Prometheus. Implementations of Metric in this package are Gauge, Counter,
0000000000000000000000000000000000000000;;	// Histogram, Summary, and Untyped.
0000000000000000000000000000000000000000;;	type Metric interface {
0000000000000000000000000000000000000000;;		// Desc returns the descriptor for the Metric. This method idempotently
0000000000000000000000000000000000000000;;		// returns the same descriptor throughout the lifetime of the
0000000000000000000000000000000000000000;;		// Metric. The returned descriptor is immutable by contract. A Metric
0000000000000000000000000000000000000000;;		// unable to describe itself must return an invalid descriptor (created
0000000000000000000000000000000000000000;;		// with NewInvalidDesc).
0000000000000000000000000000000000000000;;		Desc() *Desc
0000000000000000000000000000000000000000;;		// Write encodes the Metric into a "Metric" Protocol Buffer data
0000000000000000000000000000000000000000;;		// transmission object.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Metric implementations must observe concurrency safety as reads of
0000000000000000000000000000000000000000;;		// this metric may occur at any time, and any blocking occurs at the
0000000000000000000000000000000000000000;;		// expense of total performance of rendering all registered
0000000000000000000000000000000000000000;;		// metrics. Ideally, Metric implementations should support concurrent
0000000000000000000000000000000000000000;;		// readers.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// While populating dto.Metric, it is the responsibility of the
0000000000000000000000000000000000000000;;		// implementation to ensure validity of the Metric protobuf (like valid
0000000000000000000000000000000000000000;;		// UTF-8 strings or syntactically valid metric and label names). It is
0000000000000000000000000000000000000000;;		// recommended to sort labels lexicographically. (Implementers may find
0000000000000000000000000000000000000000;;		// LabelPairSorter useful for that.) Callers of Write should still make
0000000000000000000000000000000000000000;;		// sure of sorting if they depend on it.
0000000000000000000000000000000000000000;;		Write(*dto.Metric) error
0000000000000000000000000000000000000000;;		// TODO(beorn7): The original rationale of passing in a pre-allocated
0000000000000000000000000000000000000000;;		// dto.Metric protobuf to save allocations has disappeared. The
0000000000000000000000000000000000000000;;		// signature of this method should be changed to "Write() (*dto.Metric,
0000000000000000000000000000000000000000;;		// error)".
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Opts bundles the options for creating most Metric types. Each metric
0000000000000000000000000000000000000000;;	// implementation XXX has its own XXXOpts type, but in most cases, it is just be
0000000000000000000000000000000000000000;;	// an alias of this type (which might change when the requirement arises.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is mandatory to set Name and Help to a non-empty string. All other fields
0000000000000000000000000000000000000000;;	// are optional and can safely be left at their zero value.
0000000000000000000000000000000000000000;;	type Opts struct {
0000000000000000000000000000000000000000;;		// Namespace, Subsystem, and Name are components of the fully-qualified
0000000000000000000000000000000000000000;;		// name of the Metric (created by joining these components with
0000000000000000000000000000000000000000;;		// "_"). Only Name is mandatory, the others merely help structuring the
0000000000000000000000000000000000000000;;		// name. Note that the fully-qualified name of the metric must be a
0000000000000000000000000000000000000000;;		// valid Prometheus metric name.
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Subsystem string
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Help provides information about this metric. Mandatory!
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Metrics with the same fully-qualified name must have the same Help
0000000000000000000000000000000000000000;;		// string.
0000000000000000000000000000000000000000;;		Help string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConstLabels are used to attach fixed labels to this metric. Metrics
0000000000000000000000000000000000000000;;		// with the same fully-qualified name must have the same label names in
0000000000000000000000000000000000000000;;		// their ConstLabels.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note that in most cases, labels have a value that varies during the
0000000000000000000000000000000000000000;;		// lifetime of a process. Those labels are usually managed with a metric
0000000000000000000000000000000000000000;;		// vector collector (like CounterVec, GaugeVec, UntypedVec). ConstLabels
0000000000000000000000000000000000000000;;		// serve only special purposes. One is for the special case where the
0000000000000000000000000000000000000000;;		// value of a label does not change during the lifetime of a process,
0000000000000000000000000000000000000000;;		// e.g. if the revision of the running binary is put into a
0000000000000000000000000000000000000000;;		// label. Another, more advanced purpose is if more than one Collector
0000000000000000000000000000000000000000;;		// needs to collect Metrics with the same fully-qualified name. In that
0000000000000000000000000000000000000000;;		// case, those Metrics must differ in the values of their
0000000000000000000000000000000000000000;;		// ConstLabels. See the Collector examples.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the value of a label never changes (not even between binaries),
0000000000000000000000000000000000000000;;		// that label most likely should not be a label at all (but part of the
0000000000000000000000000000000000000000;;		// metric name).
0000000000000000000000000000000000000000;;		ConstLabels Labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildFQName joins the given three name components by "_". Empty name
0000000000000000000000000000000000000000;;	// components are ignored. If the name parameter itself is empty, an empty
0000000000000000000000000000000000000000;;	// string is returned, no matter what. Metric implementations included in this
0000000000000000000000000000000000000000;;	// library use this function internally to generate the fully-qualified metric
0000000000000000000000000000000000000000;;	// name from the name component in their Opts. Users of the library will only
0000000000000000000000000000000000000000;;	// need this function if they implement their own Metric or instantiate a Desc
0000000000000000000000000000000000000000;;	// (with NewDesc) directly.
0000000000000000000000000000000000000000;;	func BuildFQName(namespace, subsystem, name string) string {
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case namespace != "" && subsystem != "":
0000000000000000000000000000000000000000;;			return strings.Join([]string{namespace, subsystem, name}, "_")
0000000000000000000000000000000000000000;;		case namespace != "":
0000000000000000000000000000000000000000;;			return strings.Join([]string{namespace, name}, "_")
0000000000000000000000000000000000000000;;		case subsystem != "":
0000000000000000000000000000000000000000;;			return strings.Join([]string{subsystem, name}, "_")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelPairSorter implements sort.Interface. It is used to sort a slice of
0000000000000000000000000000000000000000;;	// dto.LabelPair pointers. This is useful for implementing the Write method of
0000000000000000000000000000000000000000;;	// custom metrics.
0000000000000000000000000000000000000000;;	type LabelPairSorter []*dto.LabelPair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s LabelPairSorter) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s LabelPairSorter) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s LabelPairSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i].GetName() < s[j].GetName()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hashSorter []uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s hashSorter) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s hashSorter) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s hashSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i] < s[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type invalidMetric struct {
0000000000000000000000000000000000000000;;		desc *Desc
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInvalidMetric returns a metric whose Write method always returns the
0000000000000000000000000000000000000000;;	// provided error. It is useful if a Collector finds itself unable to collect
0000000000000000000000000000000000000000;;	// a metric and wishes to report an error to the registry.
0000000000000000000000000000000000000000;;	func NewInvalidMetric(desc *Desc, err error) Metric {
0000000000000000000000000000000000000000;;		return &invalidMetric{desc, err}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *invalidMetric) Desc() *Desc { return m.desc }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *invalidMetric) Write(*dto.Metric) error { return m.err }
