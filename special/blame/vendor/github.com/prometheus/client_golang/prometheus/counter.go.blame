0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/counter.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/counter.go][vendor/github.com/prometheus/client_golang/prometheus/counter.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Counter is a Metric that represents a single numerical value that only ever
0000000000000000000000000000000000000000;;	// goes up. That implies that it cannot be used to count items whose number can
0000000000000000000000000000000000000000;;	// also go down, e.g. the number of currently running goroutines. Those
0000000000000000000000000000000000000000;;	// "counters" are represented by Gauges.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A Counter is typically used to count requests served, tasks completed, errors
0000000000000000000000000000000000000000;;	// occurred, etc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create Counter instances, use NewCounter.
0000000000000000000000000000000000000000;;	type Counter interface {
0000000000000000000000000000000000000000;;		Metric
0000000000000000000000000000000000000000;;		Collector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inc increments the counter by 1. Use Add to increment it by arbitrary
0000000000000000000000000000000000000000;;		// non-negative values.
0000000000000000000000000000000000000000;;		Inc()
0000000000000000000000000000000000000000;;		// Add adds the given value to the counter. It panics if the value is <
0000000000000000000000000000000000000000;;		// 0.
0000000000000000000000000000000000000000;;		Add(float64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CounterOpts is an alias for Opts. See there for doc comments.
0000000000000000000000000000000000000000;;	type CounterOpts Opts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCounter creates a new Counter based on the provided CounterOpts.
0000000000000000000000000000000000000000;;	func NewCounter(opts CounterOpts) Counter {
0000000000000000000000000000000000000000;;		desc := NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		result := &counter{value: value{desc: desc, valType: CounterValue, labelPairs: desc.constLabelPairs}}
0000000000000000000000000000000000000000;;		result.init(result) // Init self-collection.
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type counter struct {
0000000000000000000000000000000000000000;;		value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *counter) Add(v float64) {
0000000000000000000000000000000000000000;;		if v < 0 {
0000000000000000000000000000000000000000;;			panic(errors.New("counter cannot decrease in value"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.value.Add(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CounterVec is a Collector that bundles a set of Counters that all share the
0000000000000000000000000000000000000000;;	// same Desc, but have different values for their variable labels. This is used
0000000000000000000000000000000000000000;;	// if you want to count the same thing partitioned by various dimensions
0000000000000000000000000000000000000000;;	// (e.g. number of HTTP requests, partitioned by response code and
0000000000000000000000000000000000000000;;	// method). Create instances with NewCounterVec.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// CounterVec embeds MetricVec. See there for a full list of methods with
0000000000000000000000000000000000000000;;	// detailed documentation.
0000000000000000000000000000000000000000;;	type CounterVec struct {
0000000000000000000000000000000000000000;;		*MetricVec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCounterVec creates a new CounterVec based on the provided CounterOpts and
0000000000000000000000000000000000000000;;	// partitioned by the given label names. At least one label name must be
0000000000000000000000000000000000000000;;	// provided.
0000000000000000000000000000000000000000;;	func NewCounterVec(opts CounterOpts, labelNames []string) *CounterVec {
0000000000000000000000000000000000000000;;		desc := NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			labelNames,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return &CounterVec{
0000000000000000000000000000000000000000;;			MetricVec: newMetricVec(desc, func(lvs ...string) Metric {
0000000000000000000000000000000000000000;;				result := &counter{value: value{
0000000000000000000000000000000000000000;;					desc:       desc,
0000000000000000000000000000000000000000;;					valType:    CounterValue,
0000000000000000000000000000000000000000;;					labelPairs: makeLabelPairs(desc, lvs),
0000000000000000000000000000000000000000;;				}}
0000000000000000000000000000000000000000;;				result.init(result) // Init self-collection.
0000000000000000000000000000000000000000;;				return result
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues replaces the method of the same name in
0000000000000000000000000000000000000000;;	// MetricVec. The difference is that this method returns a Counter and not a
0000000000000000000000000000000000000000;;	// Metric so that no type conversion is required.
0000000000000000000000000000000000000000;;	func (m *CounterVec) GetMetricWithLabelValues(lvs ...string) (Counter, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWithLabelValues(lvs...)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Counter), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWith replaces the method of the same name in MetricVec. The
0000000000000000000000000000000000000000;;	// difference is that this method returns a Counter and not a Metric so that no
0000000000000000000000000000000000000000;;	// type conversion is required.
0000000000000000000000000000000000000000;;	func (m *CounterVec) GetMetricWith(labels Labels) (Counter, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWith(labels)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Counter), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithLabelValues works as GetMetricWithLabelValues, but panics where
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues would have returned an error. By not returning an
0000000000000000000000000000000000000000;;	// error, WithLabelValues allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.WithLabelValues("404", "GET").Add(42)
0000000000000000000000000000000000000000;;	func (m *CounterVec) WithLabelValues(lvs ...string) Counter {
0000000000000000000000000000000000000000;;		return m.MetricVec.WithLabelValues(lvs...).(Counter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// With works as GetMetricWith, but panics where GetMetricWithLabels would have
0000000000000000000000000000000000000000;;	// returned an error. By not returning an error, With allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.With(Labels{"code": "404", "method": "GET"}).Add(42)
0000000000000000000000000000000000000000;;	func (m *CounterVec) With(labels Labels) Counter {
0000000000000000000000000000000000000000;;		return m.MetricVec.With(labels).(Counter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CounterFunc is a Counter whose value is determined at collect time by calling a
0000000000000000000000000000000000000000;;	// provided function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create CounterFunc instances, use NewCounterFunc.
0000000000000000000000000000000000000000;;	type CounterFunc interface {
0000000000000000000000000000000000000000;;		Metric
0000000000000000000000000000000000000000;;		Collector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCounterFunc creates a new CounterFunc based on the provided
0000000000000000000000000000000000000000;;	// CounterOpts. The value reported is determined by calling the given function
0000000000000000000000000000000000000000;;	// from within the Write method. Take into account that metric collection may
0000000000000000000000000000000000000000;;	// happen concurrently. If that results in concurrent calls to Write, like in
0000000000000000000000000000000000000000;;	// the case where a CounterFunc is directly registered with Prometheus, the
0000000000000000000000000000000000000000;;	// provided function must be concurrency-safe. The function should also honor
0000000000000000000000000000000000000000;;	// the contract for a Counter (values only go up, not down), but compliance will
0000000000000000000000000000000000000000;;	// not be checked.
0000000000000000000000000000000000000000;;	func NewCounterFunc(opts CounterOpts, function func() float64) CounterFunc {
0000000000000000000000000000000000000000;;		return newValueFunc(NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		), CounterValue, function)
0000000000000000000000000000000000000000;;	}
