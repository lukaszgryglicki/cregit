0000000000000000000000000000000000000000;;	// Copyright 2015 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/process_collector.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/process_collector.go][vendor/github.com/prometheus/client_golang/prometheus/process_collector.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "github.com/prometheus/procfs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type processCollector struct {
0000000000000000000000000000000000000000;;		pid             int
0000000000000000000000000000000000000000;;		collectFn       func(chan<- Metric)
0000000000000000000000000000000000000000;;		pidFn           func() (int, error)
0000000000000000000000000000000000000000;;		cpuTotal        *Desc
0000000000000000000000000000000000000000;;		openFDs, maxFDs *Desc
0000000000000000000000000000000000000000;;		vsize, rss      *Desc
0000000000000000000000000000000000000000;;		startTime       *Desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProcessCollector returns a collector which exports the current state of
0000000000000000000000000000000000000000;;	// process metrics including cpu, memory and file descriptor usage as well as
0000000000000000000000000000000000000000;;	// the process start time for the given process id under the given namespace.
0000000000000000000000000000000000000000;;	func NewProcessCollector(pid int, namespace string) Collector {
0000000000000000000000000000000000000000;;		return NewProcessCollectorPIDFn(
0000000000000000000000000000000000000000;;			func() (int, error) { return pid, nil },
0000000000000000000000000000000000000000;;			namespace,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProcessCollectorPIDFn returns a collector which exports the current state
0000000000000000000000000000000000000000;;	// of process metrics including cpu, memory and file descriptor usage as well
0000000000000000000000000000000000000000;;	// as the process start time under the given namespace. The given pidFn is
0000000000000000000000000000000000000000;;	// called on each collect and is used to determine the process to export
0000000000000000000000000000000000000000;;	// metrics for.
0000000000000000000000000000000000000000;;	func NewProcessCollectorPIDFn(
0000000000000000000000000000000000000000;;		pidFn func() (int, error),
0000000000000000000000000000000000000000;;		namespace string,
0000000000000000000000000000000000000000;;	) Collector {
0000000000000000000000000000000000000000;;		ns := ""
0000000000000000000000000000000000000000;;		if len(namespace) > 0 {
0000000000000000000000000000000000000000;;			ns = namespace + "_"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := processCollector{
0000000000000000000000000000000000000000;;			pidFn:     pidFn,
0000000000000000000000000000000000000000;;			collectFn: func(chan<- Metric) {},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cpuTotal: NewDesc(
0000000000000000000000000000000000000000;;				ns+"process_cpu_seconds_total",
0000000000000000000000000000000000000000;;				"Total user and system CPU time spent in seconds.",
0000000000000000000000000000000000000000;;				nil, nil,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			openFDs: NewDesc(
0000000000000000000000000000000000000000;;				ns+"process_open_fds",
0000000000000000000000000000000000000000;;				"Number of open file descriptors.",
0000000000000000000000000000000000000000;;				nil, nil,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			maxFDs: NewDesc(
0000000000000000000000000000000000000000;;				ns+"process_max_fds",
0000000000000000000000000000000000000000;;				"Maximum number of open file descriptors.",
0000000000000000000000000000000000000000;;				nil, nil,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			vsize: NewDesc(
0000000000000000000000000000000000000000;;				ns+"process_virtual_memory_bytes",
0000000000000000000000000000000000000000;;				"Virtual memory size in bytes.",
0000000000000000000000000000000000000000;;				nil, nil,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			rss: NewDesc(
0000000000000000000000000000000000000000;;				ns+"process_resident_memory_bytes",
0000000000000000000000000000000000000000;;				"Resident memory size in bytes.",
0000000000000000000000000000000000000000;;				nil, nil,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			startTime: NewDesc(
0000000000000000000000000000000000000000;;				ns+"process_start_time_seconds",
0000000000000000000000000000000000000000;;				"Start time of the process since unix epoch in seconds.",
0000000000000000000000000000000000000000;;				nil, nil,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set up process metric collection if supported by the runtime.
0000000000000000000000000000000000000000;;		if _, err := procfs.NewStat(); err == nil {
0000000000000000000000000000000000000000;;			c.collectFn = c.processCollect
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describe returns all descriptions of the collector.
0000000000000000000000000000000000000000;;	func (c *processCollector) Describe(ch chan<- *Desc) {
0000000000000000000000000000000000000000;;		ch <- c.cpuTotal
0000000000000000000000000000000000000000;;		ch <- c.openFDs
0000000000000000000000000000000000000000;;		ch <- c.maxFDs
0000000000000000000000000000000000000000;;		ch <- c.vsize
0000000000000000000000000000000000000000;;		ch <- c.rss
0000000000000000000000000000000000000000;;		ch <- c.startTime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Collect returns the current state of all metrics of the collector.
0000000000000000000000000000000000000000;;	func (c *processCollector) Collect(ch chan<- Metric) {
0000000000000000000000000000000000000000;;		c.collectFn(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(ts): Bring back error reporting by reverting 7faf9e7 as soon as the
0000000000000000000000000000000000000000;;	// client allows users to configure the error behavior.
0000000000000000000000000000000000000000;;	func (c *processCollector) processCollect(ch chan<- Metric) {
0000000000000000000000000000000000000000;;		pid, err := c.pidFn()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := procfs.NewProc(pid)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if stat, err := p.NewStat(); err == nil {
0000000000000000000000000000000000000000;;			ch <- MustNewConstMetric(c.cpuTotal, CounterValue, stat.CPUTime())
0000000000000000000000000000000000000000;;			ch <- MustNewConstMetric(c.vsize, GaugeValue, float64(stat.VirtualMemory()))
0000000000000000000000000000000000000000;;			ch <- MustNewConstMetric(c.rss, GaugeValue, float64(stat.ResidentMemory()))
0000000000000000000000000000000000000000;;			if startTime, err := stat.StartTime(); err == nil {
0000000000000000000000000000000000000000;;				ch <- MustNewConstMetric(c.startTime, GaugeValue, startTime)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fds, err := p.FileDescriptorsLen(); err == nil {
0000000000000000000000000000000000000000;;			ch <- MustNewConstMetric(c.openFDs, GaugeValue, float64(fds))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if limits, err := p.NewLimits(); err == nil {
0000000000000000000000000000000000000000;;			ch <- MustNewConstMetric(c.maxFDs, GaugeValue, float64(limits.OpenFiles))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
