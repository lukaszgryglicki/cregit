0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/value.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/value.go][vendor/github.com/prometheus/client_golang/prometheus/value.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValueType is an enumeration of metric types that represent a simple value.
0000000000000000000000000000000000000000;;	type ValueType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Possible values for the ValueType enum.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_ ValueType = iota
0000000000000000000000000000000000000000;;		CounterValue
0000000000000000000000000000000000000000;;		GaugeValue
0000000000000000000000000000000000000000;;		UntypedValue
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errInconsistentCardinality = errors.New("inconsistent label cardinality")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// value is a generic metric for simple values. It implements Metric, Collector,
0000000000000000000000000000000000000000;;	// Counter, Gauge, and Untyped. Its effective type is determined by
0000000000000000000000000000000000000000;;	// ValueType. This is a low-level building block used by the library to back the
0000000000000000000000000000000000000000;;	// implementations of Counter, Gauge, and Untyped.
0000000000000000000000000000000000000000;;	type value struct {
0000000000000000000000000000000000000000;;		// valBits contains the bits of the represented float64 value. It has
0000000000000000000000000000000000000000;;		// to go first in the struct to guarantee alignment for atomic
0000000000000000000000000000000000000000;;		// operations.  http://golang.org/pkg/sync/atomic/#pkg-note-BUG
0000000000000000000000000000000000000000;;		valBits uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfCollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desc       *Desc
0000000000000000000000000000000000000000;;		valType    ValueType
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newValue returns a newly allocated value with the given Desc, ValueType,
0000000000000000000000000000000000000000;;	// sample value and label values. It panics if the number of label
0000000000000000000000000000000000000000;;	// values is different from the number of variable labels in Desc.
0000000000000000000000000000000000000000;;	func newValue(desc *Desc, valueType ValueType, val float64, labelValues ...string) *value {
0000000000000000000000000000000000000000;;		if len(labelValues) != len(desc.variableLabels) {
0000000000000000000000000000000000000000;;			panic(errInconsistentCardinality)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := &value{
0000000000000000000000000000000000000000;;			desc:       desc,
0000000000000000000000000000000000000000;;			valType:    valueType,
0000000000000000000000000000000000000000;;			valBits:    math.Float64bits(val),
0000000000000000000000000000000000000000;;			labelPairs: makeLabelPairs(desc, labelValues),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.init(result)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) Desc() *Desc {
0000000000000000000000000000000000000000;;		return v.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) Set(val float64) {
0000000000000000000000000000000000000000;;		atomic.StoreUint64(&v.valBits, math.Float64bits(val))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) SetToCurrentTime() {
0000000000000000000000000000000000000000;;		v.Set(float64(time.Now().UnixNano()) / 1e9)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) Inc() {
0000000000000000000000000000000000000000;;		v.Add(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) Dec() {
0000000000000000000000000000000000000000;;		v.Add(-1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) Add(val float64) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			oldBits := atomic.LoadUint64(&v.valBits)
0000000000000000000000000000000000000000;;			newBits := math.Float64bits(math.Float64frombits(oldBits) + val)
0000000000000000000000000000000000000000;;			if atomic.CompareAndSwapUint64(&v.valBits, oldBits, newBits) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) Sub(val float64) {
0000000000000000000000000000000000000000;;		v.Add(val * -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *value) Write(out *dto.Metric) error {
0000000000000000000000000000000000000000;;		val := math.Float64frombits(atomic.LoadUint64(&v.valBits))
0000000000000000000000000000000000000000;;		return populateMetric(v.valType, val, v.labelPairs, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valueFunc is a generic metric for simple values retrieved on collect time
0000000000000000000000000000000000000000;;	// from a function. It implements Metric and Collector. Its effective type is
0000000000000000000000000000000000000000;;	// determined by ValueType. This is a low-level building block used by the
0000000000000000000000000000000000000000;;	// library to back the implementations of CounterFunc, GaugeFunc, and
0000000000000000000000000000000000000000;;	// UntypedFunc.
0000000000000000000000000000000000000000;;	type valueFunc struct {
0000000000000000000000000000000000000000;;		selfCollector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desc       *Desc
0000000000000000000000000000000000000000;;		valType    ValueType
0000000000000000000000000000000000000000;;		function   func() float64
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newValueFunc returns a newly allocated valueFunc with the given Desc and
0000000000000000000000000000000000000000;;	// ValueType. The value reported is determined by calling the given function
0000000000000000000000000000000000000000;;	// from within the Write method. Take into account that metric collection may
0000000000000000000000000000000000000000;;	// happen concurrently. If that results in concurrent calls to Write, like in
0000000000000000000000000000000000000000;;	// the case where a valueFunc is directly registered with Prometheus, the
0000000000000000000000000000000000000000;;	// provided function must be concurrency-safe.
0000000000000000000000000000000000000000;;	func newValueFunc(desc *Desc, valueType ValueType, function func() float64) *valueFunc {
0000000000000000000000000000000000000000;;		result := &valueFunc{
0000000000000000000000000000000000000000;;			desc:       desc,
0000000000000000000000000000000000000000;;			valType:    valueType,
0000000000000000000000000000000000000000;;			function:   function,
0000000000000000000000000000000000000000;;			labelPairs: makeLabelPairs(desc, nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.init(result)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *valueFunc) Desc() *Desc {
0000000000000000000000000000000000000000;;		return v.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *valueFunc) Write(out *dto.Metric) error {
0000000000000000000000000000000000000000;;		return populateMetric(v.valType, v.function(), v.labelPairs, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConstMetric returns a metric with one fixed value that cannot be
0000000000000000000000000000000000000000;;	// changed. Users of this package will not have much use for it in regular
0000000000000000000000000000000000000000;;	// operations. However, when implementing custom Collectors, it is useful as a
0000000000000000000000000000000000000000;;	// throw-away metric that is generated on the fly to send it to Prometheus in
0000000000000000000000000000000000000000;;	// the Collect method. NewConstMetric returns an error if the length of
0000000000000000000000000000000000000000;;	// labelValues is not consistent with the variable labels in Desc.
0000000000000000000000000000000000000000;;	func NewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) (Metric, error) {
0000000000000000000000000000000000000000;;		if len(desc.variableLabels) != len(labelValues) {
0000000000000000000000000000000000000000;;			return nil, errInconsistentCardinality
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &constMetric{
0000000000000000000000000000000000000000;;			desc:       desc,
0000000000000000000000000000000000000000;;			valType:    valueType,
0000000000000000000000000000000000000000;;			val:        value,
0000000000000000000000000000000000000000;;			labelPairs: makeLabelPairs(desc, labelValues),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustNewConstMetric is a version of NewConstMetric that panics where
0000000000000000000000000000000000000000;;	// NewConstMetric would have returned an error.
0000000000000000000000000000000000000000;;	func MustNewConstMetric(desc *Desc, valueType ValueType, value float64, labelValues ...string) Metric {
0000000000000000000000000000000000000000;;		m, err := NewConstMetric(desc, valueType, value, labelValues...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type constMetric struct {
0000000000000000000000000000000000000000;;		desc       *Desc
0000000000000000000000000000000000000000;;		valType    ValueType
0000000000000000000000000000000000000000;;		val        float64
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *constMetric) Desc() *Desc {
0000000000000000000000000000000000000000;;		return m.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *constMetric) Write(out *dto.Metric) error {
0000000000000000000000000000000000000000;;		return populateMetric(m.valType, m.val, m.labelPairs, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func populateMetric(
0000000000000000000000000000000000000000;;		t ValueType,
0000000000000000000000000000000000000000;;		v float64,
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair,
0000000000000000000000000000000000000000;;		m *dto.Metric,
0000000000000000000000000000000000000000;;	) error {
0000000000000000000000000000000000000000;;		m.Label = labelPairs
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case CounterValue:
0000000000000000000000000000000000000000;;			m.Counter = &dto.Counter{Value: proto.Float64(v)}
0000000000000000000000000000000000000000;;		case GaugeValue:
0000000000000000000000000000000000000000;;			m.Gauge = &dto.Gauge{Value: proto.Float64(v)}
0000000000000000000000000000000000000000;;		case UntypedValue:
0000000000000000000000000000000000000000;;			m.Untyped = &dto.Untyped{Value: proto.Float64(v)}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("encountered unknown type %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLabelPairs(desc *Desc, labelValues []string) []*dto.LabelPair {
0000000000000000000000000000000000000000;;		totalLen := len(desc.variableLabels) + len(desc.constLabelPairs)
0000000000000000000000000000000000000000;;		if totalLen == 0 {
0000000000000000000000000000000000000000;;			// Super fast path.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(desc.variableLabels) == 0 {
0000000000000000000000000000000000000000;;			// Moderately fast path.
0000000000000000000000000000000000000000;;			return desc.constLabelPairs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelPairs := make([]*dto.LabelPair, 0, totalLen)
0000000000000000000000000000000000000000;;		for i, n := range desc.variableLabels {
0000000000000000000000000000000000000000;;			labelPairs = append(labelPairs, &dto.LabelPair{
0000000000000000000000000000000000000000;;				Name:  proto.String(n),
0000000000000000000000000000000000000000;;				Value: proto.String(labelValues[i]),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, lp := range desc.constLabelPairs {
0000000000000000000000000000000000000000;;			labelPairs = append(labelPairs, lp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(LabelPairSorter(labelPairs))
0000000000000000000000000000000000000000;;		return labelPairs
0000000000000000000000000000000000000000;;	}
