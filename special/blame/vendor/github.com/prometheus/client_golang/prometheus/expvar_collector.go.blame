0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/expvar.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/expvar.go][vendor/github.com/prometheus/client_golang/prometheus/expvar_collector.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"expvar"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type expvarCollector struct {
0000000000000000000000000000000000000000;;		exports map[string]*Desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewExpvarCollector returns a newly allocated expvar Collector that still has
0000000000000000000000000000000000000000;;	// to be registered with a Prometheus registry.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An expvar Collector collects metrics from the expvar interface. It provides a
0000000000000000000000000000000000000000;;	// quick way to expose numeric values that are already exported via expvar as
0000000000000000000000000000000000000000;;	// Prometheus metrics. Note that the data models of expvar and Prometheus are
0000000000000000000000000000000000000000;;	// fundamentally different, and that the expvar Collector is inherently slower
0000000000000000000000000000000000000000;;	// than native Prometheus metrics. Thus, the expvar Collector is probably great
0000000000000000000000000000000000000000;;	// for experiments and prototying, but you should seriously consider a more
0000000000000000000000000000000000000000;;	// direct implementation of Prometheus metrics for monitoring production
0000000000000000000000000000000000000000;;	// systems.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The exports map has the following meaning:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The keys in the map correspond to expvar keys, i.e. for every expvar key you
0000000000000000000000000000000000000000;;	// want to export as Prometheus metric, you need an entry in the exports
0000000000000000000000000000000000000000;;	// map. The descriptor mapped to each key describes how to export the expvar
0000000000000000000000000000000000000000;;	// value. It defines the name and the help string of the Prometheus metric
0000000000000000000000000000000000000000;;	// proxying the expvar value. The type will always be Untyped.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For descriptors without variable labels, the expvar value must be a number or
0000000000000000000000000000000000000000;;	// a bool. The number is then directly exported as the Prometheus sample
0000000000000000000000000000000000000000;;	// value. (For a bool, 'false' translates to 0 and 'true' to 1). Expvar values
0000000000000000000000000000000000000000;;	// that are not numbers or bools are silently ignored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the descriptor has one variable label, the expvar value must be an expvar
0000000000000000000000000000000000000000;;	// map. The keys in the expvar map become the various values of the one
0000000000000000000000000000000000000000;;	// Prometheus label. The values in the expvar map must be numbers or bools again
0000000000000000000000000000000000000000;;	// as above.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For descriptors with more than one variable label, the expvar must be a
0000000000000000000000000000000000000000;;	// nested expvar map, i.e. where the values of the topmost map are maps again
0000000000000000000000000000000000000000;;	// etc. until a depth is reached that corresponds to the number of labels. The
0000000000000000000000000000000000000000;;	// leaves of that structure must be numbers or bools as above to serve as the
0000000000000000000000000000000000000000;;	// sample values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Anything that does not fit into the scheme above is silently ignored.
0000000000000000000000000000000000000000;;	func NewExpvarCollector(exports map[string]*Desc) Collector {
0000000000000000000000000000000000000000;;		return &expvarCollector{
0000000000000000000000000000000000000000;;			exports: exports,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describe implements Collector.
0000000000000000000000000000000000000000;;	func (e *expvarCollector) Describe(ch chan<- *Desc) {
0000000000000000000000000000000000000000;;		for _, desc := range e.exports {
0000000000000000000000000000000000000000;;			ch <- desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Collect implements Collector.
0000000000000000000000000000000000000000;;	func (e *expvarCollector) Collect(ch chan<- Metric) {
0000000000000000000000000000000000000000;;		for name, desc := range e.exports {
0000000000000000000000000000000000000000;;			var m Metric
0000000000000000000000000000000000000000;;			expVar := expvar.Get(name)
0000000000000000000000000000000000000000;;			if expVar == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var v interface{}
0000000000000000000000000000000000000000;;			labels := make([]string, len(desc.variableLabels))
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(expVar.String()), &v); err != nil {
0000000000000000000000000000000000000000;;				ch <- NewInvalidMetric(desc, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var processValue func(v interface{}, i int)
0000000000000000000000000000000000000000;;			processValue = func(v interface{}, i int) {
0000000000000000000000000000000000000000;;				if i >= len(labels) {
0000000000000000000000000000000000000000;;					copiedLabels := append(make([]string, 0, len(labels)), labels...)
0000000000000000000000000000000000000000;;					switch v := v.(type) {
0000000000000000000000000000000000000000;;					case float64:
0000000000000000000000000000000000000000;;						m = MustNewConstMetric(desc, UntypedValue, v, copiedLabels...)
0000000000000000000000000000000000000000;;					case bool:
0000000000000000000000000000000000000000;;						if v {
0000000000000000000000000000000000000000;;							m = MustNewConstMetric(desc, UntypedValue, 1, copiedLabels...)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							m = MustNewConstMetric(desc, UntypedValue, 0, copiedLabels...)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ch <- m
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				vm, ok := v.(map[string]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for lv, val := range vm {
0000000000000000000000000000000000000000;;					labels[i] = lv
0000000000000000000000000000000000000000;;					processValue(val, i+1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			processValue(v, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
