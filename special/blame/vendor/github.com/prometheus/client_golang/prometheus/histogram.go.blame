0000000000000000000000000000000000000000;;	// Copyright 2015 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5cd931cb225e70fd04e30d60f894aa865fd598c3;Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/histogram.go[Godeps/_workspace/src/github.com/prometheus/client_golang/prometheus/histogram.go][vendor/github.com/prometheus/client_golang/prometheus/histogram.go];	
0000000000000000000000000000000000000000;;	package prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Histogram counts individual observations from an event or sample stream in
0000000000000000000000000000000000000000;;	// configurable buckets. Similar to a summary, it also provides a sum of
0000000000000000000000000000000000000000;;	// observations and an observation count.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// On the Prometheus server, quantiles can be calculated from a Histogram using
0000000000000000000000000000000000000000;;	// the histogram_quantile function in the query language.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that Histograms, in contrast to Summaries, can be aggregated with the
0000000000000000000000000000000000000000;;	// Prometheus query language (see the documentation for detailed
0000000000000000000000000000000000000000;;	// procedures). However, Histograms require the user to pre-define suitable
0000000000000000000000000000000000000000;;	// buckets, and they are in general less accurate. The Observe method of a
0000000000000000000000000000000000000000;;	// Histogram has a very low performance overhead in comparison with the Observe
0000000000000000000000000000000000000000;;	// method of a Summary.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create Histogram instances, use NewHistogram.
0000000000000000000000000000000000000000;;	type Histogram interface {
0000000000000000000000000000000000000000;;		Metric
0000000000000000000000000000000000000000;;		Collector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Observe adds a single observation to the histogram.
0000000000000000000000000000000000000000;;		Observe(float64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bucketLabel is used for the label that defines the upper bound of a
0000000000000000000000000000000000000000;;	// bucket of a histogram ("le" -> "less or equal").
0000000000000000000000000000000000000000;;	const bucketLabel = "le"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefBuckets are the default Histogram buckets. The default buckets are
0000000000000000000000000000000000000000;;	// tailored to broadly measure the response time (in seconds) of a network
0000000000000000000000000000000000000000;;	// service. Most likely, however, you will be required to define buckets
0000000000000000000000000000000000000000;;	// customized to your use case.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		DefBuckets = []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errBucketLabelNotAllowed = fmt.Errorf(
0000000000000000000000000000000000000000;;			"%q is not allowed as label name in histograms", bucketLabel,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinearBuckets creates 'count' buckets, each 'width' wide, where the lowest
0000000000000000000000000000000000000000;;	// bucket has an upper bound of 'start'. The final +Inf bucket is not counted
0000000000000000000000000000000000000000;;	// and not included in the returned slice. The returned slice is meant to be
0000000000000000000000000000000000000000;;	// used for the Buckets field of HistogramOpts.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The function panics if 'count' is zero or negative.
0000000000000000000000000000000000000000;;	func LinearBuckets(start, width float64, count int) []float64 {
0000000000000000000000000000000000000000;;		if count < 1 {
0000000000000000000000000000000000000000;;			panic("LinearBuckets needs a positive count")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buckets := make([]float64, count)
0000000000000000000000000000000000000000;;		for i := range buckets {
0000000000000000000000000000000000000000;;			buckets[i] = start
0000000000000000000000000000000000000000;;			start += width
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buckets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExponentialBuckets creates 'count' buckets, where the lowest bucket has an
0000000000000000000000000000000000000000;;	// upper bound of 'start' and each following bucket's upper bound is 'factor'
0000000000000000000000000000000000000000;;	// times the previous bucket's upper bound. The final +Inf bucket is not counted
0000000000000000000000000000000000000000;;	// and not included in the returned slice. The returned slice is meant to be
0000000000000000000000000000000000000000;;	// used for the Buckets field of HistogramOpts.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The function panics if 'count' is 0 or negative, if 'start' is 0 or negative,
0000000000000000000000000000000000000000;;	// or if 'factor' is less than or equal 1.
0000000000000000000000000000000000000000;;	func ExponentialBuckets(start, factor float64, count int) []float64 {
0000000000000000000000000000000000000000;;		if count < 1 {
0000000000000000000000000000000000000000;;			panic("ExponentialBuckets needs a positive count")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start <= 0 {
0000000000000000000000000000000000000000;;			panic("ExponentialBuckets needs a positive start value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if factor <= 1 {
0000000000000000000000000000000000000000;;			panic("ExponentialBuckets needs a factor greater than 1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buckets := make([]float64, count)
0000000000000000000000000000000000000000;;		for i := range buckets {
0000000000000000000000000000000000000000;;			buckets[i] = start
0000000000000000000000000000000000000000;;			start *= factor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buckets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HistogramOpts bundles the options for creating a Histogram metric. It is
0000000000000000000000000000000000000000;;	// mandatory to set Name and Help to a non-empty string. All other fields are
0000000000000000000000000000000000000000;;	// optional and can safely be left at their zero value.
0000000000000000000000000000000000000000;;	type HistogramOpts struct {
0000000000000000000000000000000000000000;;		// Namespace, Subsystem, and Name are components of the fully-qualified
0000000000000000000000000000000000000000;;		// name of the Histogram (created by joining these components with
0000000000000000000000000000000000000000;;		// "_"). Only Name is mandatory, the others merely help structuring the
0000000000000000000000000000000000000000;;		// name. Note that the fully-qualified name of the Histogram must be a
0000000000000000000000000000000000000000;;		// valid Prometheus metric name.
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Subsystem string
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Help provides information about this Histogram. Mandatory!
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Metrics with the same fully-qualified name must have the same Help
0000000000000000000000000000000000000000;;		// string.
0000000000000000000000000000000000000000;;		Help string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConstLabels are used to attach fixed labels to this
0000000000000000000000000000000000000000;;		// Histogram. Histograms with the same fully-qualified name must have the
0000000000000000000000000000000000000000;;		// same label names in their ConstLabels.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note that in most cases, labels have a value that varies during the
0000000000000000000000000000000000000000;;		// lifetime of a process. Those labels are usually managed with a
0000000000000000000000000000000000000000;;		// HistogramVec. ConstLabels serve only special purposes. One is for the
0000000000000000000000000000000000000000;;		// special case where the value of a label does not change during the
0000000000000000000000000000000000000000;;		// lifetime of a process, e.g. if the revision of the running binary is
0000000000000000000000000000000000000000;;		// put into a label. Another, more advanced purpose is if more than one
0000000000000000000000000000000000000000;;		// Collector needs to collect Histograms with the same fully-qualified
0000000000000000000000000000000000000000;;		// name. In that case, those Summaries must differ in the values of
0000000000000000000000000000000000000000;;		// their ConstLabels. See the Collector examples.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the value of a label never changes (not even between binaries),
0000000000000000000000000000000000000000;;		// that label most likely should not be a label at all (but part of the
0000000000000000000000000000000000000000;;		// metric name).
0000000000000000000000000000000000000000;;		ConstLabels Labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Buckets defines the buckets into which observations are counted. Each
0000000000000000000000000000000000000000;;		// element in the slice is the upper inclusive bound of a bucket. The
0000000000000000000000000000000000000000;;		// values must be sorted in strictly increasing order. There is no need
0000000000000000000000000000000000000000;;		// to add a highest bucket with +Inf bound, it will be added
0000000000000000000000000000000000000000;;		// implicitly. The default value is DefBuckets.
0000000000000000000000000000000000000000;;		Buckets []float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHistogram creates a new Histogram based on the provided HistogramOpts. It
0000000000000000000000000000000000000000;;	// panics if the buckets in HistogramOpts are not in strictly increasing order.
0000000000000000000000000000000000000000;;	func NewHistogram(opts HistogramOpts) Histogram {
0000000000000000000000000000000000000000;;		return newHistogram(
0000000000000000000000000000000000000000;;			NewDesc(
0000000000000000000000000000000000000000;;				BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;				opts.Help,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				opts.ConstLabels,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			opts,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newHistogram(desc *Desc, opts HistogramOpts, labelValues ...string) Histogram {
0000000000000000000000000000000000000000;;		if len(desc.variableLabels) != len(labelValues) {
0000000000000000000000000000000000000000;;			panic(errInconsistentCardinality)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range desc.variableLabels {
0000000000000000000000000000000000000000;;			if n == bucketLabel {
0000000000000000000000000000000000000000;;				panic(errBucketLabelNotAllowed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, lp := range desc.constLabelPairs {
0000000000000000000000000000000000000000;;			if lp.GetName() == bucketLabel {
0000000000000000000000000000000000000000;;				panic(errBucketLabelNotAllowed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(opts.Buckets) == 0 {
0000000000000000000000000000000000000000;;			opts.Buckets = DefBuckets
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := &histogram{
0000000000000000000000000000000000000000;;			desc:        desc,
0000000000000000000000000000000000000000;;			upperBounds: opts.Buckets,
0000000000000000000000000000000000000000;;			labelPairs:  makeLabelPairs(desc, labelValues),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, upperBound := range h.upperBounds {
0000000000000000000000000000000000000000;;			if i < len(h.upperBounds)-1 {
0000000000000000000000000000000000000000;;				if upperBound >= h.upperBounds[i+1] {
0000000000000000000000000000000000000000;;					panic(fmt.Errorf(
0000000000000000000000000000000000000000;;						"histogram buckets must be in increasing order: %f >= %f",
0000000000000000000000000000000000000000;;						upperBound, h.upperBounds[i+1],
0000000000000000000000000000000000000000;;					))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if math.IsInf(upperBound, +1) {
0000000000000000000000000000000000000000;;					// The +Inf bucket is implicit. Remove it here.
0000000000000000000000000000000000000000;;					h.upperBounds = h.upperBounds[:i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Finally we know the final length of h.upperBounds and can make counts.
0000000000000000000000000000000000000000;;		h.counts = make([]uint64, len(h.upperBounds))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.init(h) // Init self-collection.
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type histogram struct {
0000000000000000000000000000000000000000;;		// sumBits contains the bits of the float64 representing the sum of all
0000000000000000000000000000000000000000;;		// observations. sumBits and count have to go first in the struct to
0000000000000000000000000000000000000000;;		// guarantee alignment for atomic operations.
0000000000000000000000000000000000000000;;		// http://golang.org/pkg/sync/atomic/#pkg-note-BUG
0000000000000000000000000000000000000000;;		sumBits uint64
0000000000000000000000000000000000000000;;		count   uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfCollector
0000000000000000000000000000000000000000;;		// Note that there is no mutex required.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desc *Desc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		upperBounds []float64
0000000000000000000000000000000000000000;;		counts      []uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *histogram) Desc() *Desc {
0000000000000000000000000000000000000000;;		return h.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *histogram) Observe(v float64) {
0000000000000000000000000000000000000000;;		// TODO(beorn7): For small numbers of buckets (<30), a linear search is
0000000000000000000000000000000000000000;;		// slightly faster than the binary search. If we really care, we could
0000000000000000000000000000000000000000;;		// switch from one search strategy to the other depending on the number
0000000000000000000000000000000000000000;;		// of buckets.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Microbenchmarks (BenchmarkHistogramNoLabels):
0000000000000000000000000000000000000000;;		// 11 buckets: 38.3 ns/op linear - binary 48.7 ns/op
0000000000000000000000000000000000000000;;		// 100 buckets: 78.1 ns/op linear - binary 54.9 ns/op
0000000000000000000000000000000000000000;;		// 300 buckets: 154 ns/op linear - binary 61.6 ns/op
0000000000000000000000000000000000000000;;		i := sort.SearchFloat64s(h.upperBounds, v)
0000000000000000000000000000000000000000;;		if i < len(h.counts) {
0000000000000000000000000000000000000000;;			atomic.AddUint64(&h.counts[i], 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		atomic.AddUint64(&h.count, 1)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			oldBits := atomic.LoadUint64(&h.sumBits)
0000000000000000000000000000000000000000;;			newBits := math.Float64bits(math.Float64frombits(oldBits) + v)
0000000000000000000000000000000000000000;;			if atomic.CompareAndSwapUint64(&h.sumBits, oldBits, newBits) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *histogram) Write(out *dto.Metric) error {
0000000000000000000000000000000000000000;;		his := &dto.Histogram{}
0000000000000000000000000000000000000000;;		buckets := make([]*dto.Bucket, len(h.upperBounds))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		his.SampleSum = proto.Float64(math.Float64frombits(atomic.LoadUint64(&h.sumBits)))
0000000000000000000000000000000000000000;;		his.SampleCount = proto.Uint64(atomic.LoadUint64(&h.count))
0000000000000000000000000000000000000000;;		var count uint64
0000000000000000000000000000000000000000;;		for i, upperBound := range h.upperBounds {
0000000000000000000000000000000000000000;;			count += atomic.LoadUint64(&h.counts[i])
0000000000000000000000000000000000000000;;			buckets[i] = &dto.Bucket{
0000000000000000000000000000000000000000;;				CumulativeCount: proto.Uint64(count),
0000000000000000000000000000000000000000;;				UpperBound:      proto.Float64(upperBound),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		his.Bucket = buckets
0000000000000000000000000000000000000000;;		out.Histogram = his
0000000000000000000000000000000000000000;;		out.Label = h.labelPairs
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HistogramVec is a Collector that bundles a set of Histograms that all share the
0000000000000000000000000000000000000000;;	// same Desc, but have different values for their variable labels. This is used
0000000000000000000000000000000000000000;;	// if you want to count the same thing partitioned by various dimensions
0000000000000000000000000000000000000000;;	// (e.g. HTTP request latencies, partitioned by status code and method). Create
0000000000000000000000000000000000000000;;	// instances with NewHistogramVec.
0000000000000000000000000000000000000000;;	type HistogramVec struct {
0000000000000000000000000000000000000000;;		*MetricVec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHistogramVec creates a new HistogramVec based on the provided HistogramOpts and
0000000000000000000000000000000000000000;;	// partitioned by the given label names. At least one label name must be
0000000000000000000000000000000000000000;;	// provided.
0000000000000000000000000000000000000000;;	func NewHistogramVec(opts HistogramOpts, labelNames []string) *HistogramVec {
0000000000000000000000000000000000000000;;		desc := NewDesc(
0000000000000000000000000000000000000000;;			BuildFQName(opts.Namespace, opts.Subsystem, opts.Name),
0000000000000000000000000000000000000000;;			opts.Help,
0000000000000000000000000000000000000000;;			labelNames,
0000000000000000000000000000000000000000;;			opts.ConstLabels,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return &HistogramVec{
0000000000000000000000000000000000000000;;			MetricVec: newMetricVec(desc, func(lvs ...string) Metric {
0000000000000000000000000000000000000000;;				return newHistogram(desc, opts, lvs...)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues replaces the method of the same name in
0000000000000000000000000000000000000000;;	// MetricVec. The difference is that this method returns an Observer and not a
0000000000000000000000000000000000000000;;	// Metric so that no type conversion to an Observer is required.
0000000000000000000000000000000000000000;;	func (m *HistogramVec) GetMetricWithLabelValues(lvs ...string) (Observer, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWithLabelValues(lvs...)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Observer), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetricWith replaces the method of the same name in MetricVec. The
0000000000000000000000000000000000000000;;	// difference is that this method returns an Observer and not a Metric so that no
0000000000000000000000000000000000000000;;	// type conversion to an Observer is required.
0000000000000000000000000000000000000000;;	func (m *HistogramVec) GetMetricWith(labels Labels) (Observer, error) {
0000000000000000000000000000000000000000;;		metric, err := m.MetricVec.GetMetricWith(labels)
0000000000000000000000000000000000000000;;		if metric != nil {
0000000000000000000000000000000000000000;;			return metric.(Observer), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithLabelValues works as GetMetricWithLabelValues, but panics where
0000000000000000000000000000000000000000;;	// GetMetricWithLabelValues would have returned an error. By not returning an
0000000000000000000000000000000000000000;;	// error, WithLabelValues allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.WithLabelValues("404", "GET").Observe(42.21)
0000000000000000000000000000000000000000;;	func (m *HistogramVec) WithLabelValues(lvs ...string) Observer {
0000000000000000000000000000000000000000;;		return m.MetricVec.WithLabelValues(lvs...).(Observer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// With works as GetMetricWith, but panics where GetMetricWithLabels would have
0000000000000000000000000000000000000000;;	// returned an error. By not returning an error, With allows shortcuts like
0000000000000000000000000000000000000000;;	//     myVec.With(Labels{"code": "404", "method": "GET"}).Observe(42.21)
0000000000000000000000000000000000000000;;	func (m *HistogramVec) With(labels Labels) Observer {
0000000000000000000000000000000000000000;;		return m.MetricVec.With(labels).(Observer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type constHistogram struct {
0000000000000000000000000000000000000000;;		desc       *Desc
0000000000000000000000000000000000000000;;		count      uint64
0000000000000000000000000000000000000000;;		sum        float64
0000000000000000000000000000000000000000;;		buckets    map[float64]uint64
0000000000000000000000000000000000000000;;		labelPairs []*dto.LabelPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *constHistogram) Desc() *Desc {
0000000000000000000000000000000000000000;;		return h.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *constHistogram) Write(out *dto.Metric) error {
0000000000000000000000000000000000000000;;		his := &dto.Histogram{}
0000000000000000000000000000000000000000;;		buckets := make([]*dto.Bucket, 0, len(h.buckets))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		his.SampleCount = proto.Uint64(h.count)
0000000000000000000000000000000000000000;;		his.SampleSum = proto.Float64(h.sum)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for upperBound, count := range h.buckets {
0000000000000000000000000000000000000000;;			buckets = append(buckets, &dto.Bucket{
0000000000000000000000000000000000000000;;				CumulativeCount: proto.Uint64(count),
0000000000000000000000000000000000000000;;				UpperBound:      proto.Float64(upperBound),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(buckets) > 0 {
0000000000000000000000000000000000000000;;			sort.Sort(buckSort(buckets))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		his.Bucket = buckets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Histogram = his
0000000000000000000000000000000000000000;;		out.Label = h.labelPairs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConstHistogram returns a metric representing a Prometheus histogram with
0000000000000000000000000000000000000000;;	// fixed values for the count, sum, and bucket counts. As those parameters
0000000000000000000000000000000000000000;;	// cannot be changed, the returned value does not implement the Histogram
0000000000000000000000000000000000000000;;	// interface (but only the Metric interface). Users of this package will not
0000000000000000000000000000000000000000;;	// have much use for it in regular operations. However, when implementing custom
0000000000000000000000000000000000000000;;	// Collectors, it is useful as a throw-away metric that is generated on the fly
0000000000000000000000000000000000000000;;	// to send it to Prometheus in the Collect method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// buckets is a map of upper bounds to cumulative counts, excluding the +Inf
0000000000000000000000000000000000000000;;	// bucket.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NewConstHistogram returns an error if the length of labelValues is not
0000000000000000000000000000000000000000;;	// consistent with the variable labels in Desc.
0000000000000000000000000000000000000000;;	func NewConstHistogram(
0000000000000000000000000000000000000000;;		desc *Desc,
0000000000000000000000000000000000000000;;		count uint64,
0000000000000000000000000000000000000000;;		sum float64,
0000000000000000000000000000000000000000;;		buckets map[float64]uint64,
0000000000000000000000000000000000000000;;		labelValues ...string,
0000000000000000000000000000000000000000;;	) (Metric, error) {
0000000000000000000000000000000000000000;;		if len(desc.variableLabels) != len(labelValues) {
0000000000000000000000000000000000000000;;			return nil, errInconsistentCardinality
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &constHistogram{
0000000000000000000000000000000000000000;;			desc:       desc,
0000000000000000000000000000000000000000;;			count:      count,
0000000000000000000000000000000000000000;;			sum:        sum,
0000000000000000000000000000000000000000;;			buckets:    buckets,
0000000000000000000000000000000000000000;;			labelPairs: makeLabelPairs(desc, labelValues),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustNewConstHistogram is a version of NewConstHistogram that panics where
0000000000000000000000000000000000000000;;	// NewConstMetric would have returned an error.
0000000000000000000000000000000000000000;;	func MustNewConstHistogram(
0000000000000000000000000000000000000000;;		desc *Desc,
0000000000000000000000000000000000000000;;		count uint64,
0000000000000000000000000000000000000000;;		sum float64,
0000000000000000000000000000000000000000;;		buckets map[float64]uint64,
0000000000000000000000000000000000000000;;		labelValues ...string,
0000000000000000000000000000000000000000;;	) Metric {
0000000000000000000000000000000000000000;;		m, err := NewConstHistogram(desc, count, sum, buckets, labelValues...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type buckSort []*dto.Bucket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s buckSort) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s buckSort) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s buckSort) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s[i].GetUpperBound() < s[j].GetUpperBound()
0000000000000000000000000000000000000000;;	}
