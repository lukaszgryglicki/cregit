0000000000000000000000000000000000000000;;	// Copyright 2017 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
13e1e7cd1550dcd956d3e82fe798021f5812b15e;;	
0000000000000000000000000000000000000000;;	package promhttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The RoundTripperFunc type is an adapter to allow the use of ordinary
0000000000000000000000000000000000000000;;	// functions as RoundTrippers. If f is a function with the appropriate
0000000000000000000000000000000000000000;;	// signature, RountTripperFunc(f) is a RoundTripper that calls f.
0000000000000000000000000000000000000000;;	type RoundTripperFunc func(req *http.Request) (*http.Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTrip implements the RoundTripper interface.
0000000000000000000000000000000000000000;;	func (rt RoundTripperFunc) RoundTrip(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return rt(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentRoundTripperInFlight is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.RoundTripper. It sets the provided prometheus.Gauge to the number of
0000000000000000000000000000000000000000;;	// requests currently handled by the wrapped http.RoundTripper.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for ExampleInstrumentRoundTripperDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentRoundTripperInFlight(gauge prometheus.Gauge, next http.RoundTripper) RoundTripperFunc {
0000000000000000000000000000000000000000;;		return RoundTripperFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;			gauge.Inc()
0000000000000000000000000000000000000000;;			defer gauge.Dec()
0000000000000000000000000000000000000000;;			return next.RoundTrip(r)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentRoundTripperCounter is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.RoundTripper to observe the request result with the provided CounterVec.
0000000000000000000000000000000000000000;;	// The CounterVec must have zero, one, or two labels. The only allowed label
0000000000000000000000000000000000000000;;	// names are "code" and "method". The function panics if any other instance
0000000000000000000000000000000000000000;;	// labels are provided. Partitioning of the CounterVec happens by HTTP status
0000000000000000000000000000000000000000;;	// code and/or HTTP method if the respective instance label names are present
0000000000000000000000000000000000000000;;	// in the CounterVec. For unpartitioned counting, use a CounterVec with
0000000000000000000000000000000000000000;;	// zero labels.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped RoundTripper panics or returns a non-nil error, the Counter
0000000000000000000000000000000000000000;;	// is not incremented.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for ExampleInstrumentRoundTripperDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentRoundTripperCounter(counter *prometheus.CounterVec, next http.RoundTripper) RoundTripperFunc {
0000000000000000000000000000000000000000;;		code, method := checkLabels(counter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RoundTripperFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;			resp, err := next.RoundTrip(r)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				counter.With(labels(code, method, r.Method, resp.StatusCode)).Inc()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentRoundTripperDuration is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.RoundTripper to observe the request duration with the provided ObserverVec.
0000000000000000000000000000000000000000;;	// The ObserverVec must have zero, one, or two labels. The only allowed label
0000000000000000000000000000000000000000;;	// names are "code" and "method". The function panics if any other instance
0000000000000000000000000000000000000000;;	// labels are provided. The Observe method of the Observer in the ObserverVec
0000000000000000000000000000000000000000;;	// is called with the request duration in seconds. Partitioning happens by HTTP
0000000000000000000000000000000000000000;;	// status code and/or HTTP method if the respective instance label names are
0000000000000000000000000000000000000000;;	// present in the ObserverVec. For unpartitioned observations, use an
0000000000000000000000000000000000000000;;	// ObserverVec with zero labels. Note that partitioning of Histograms is
0000000000000000000000000000000000000000;;	// expensive and should be used judiciously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped RoundTripper panics or returns a non-nil error, no values are
0000000000000000000000000000000000000000;;	// reported.
0000000000000000000000000000000000000000;;	func InstrumentRoundTripperDuration(obs prometheus.ObserverVec, next http.RoundTripper) RoundTripperFunc {
0000000000000000000000000000000000000000;;		code, method := checkLabels(obs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RoundTripperFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;			start := time.Now()
0000000000000000000000000000000000000000;;			resp, err := next.RoundTrip(r)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				obs.With(labels(code, method, r.Method, resp.StatusCode)).Observe(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
