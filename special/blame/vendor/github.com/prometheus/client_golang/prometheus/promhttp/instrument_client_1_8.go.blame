0000000000000000000000000000000000000000;;	// Copyright 2017 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
13e1e7cd1550dcd956d3e82fe798021f5812b15e;;	
0000000000000000000000000000000000000000;;	// +build go1.8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package promhttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptrace"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentTrace is used to offer flexibility in instrumenting the available
0000000000000000000000000000000000000000;;	// httptrace.ClientTrace hook functions. Each function is passed a float64
0000000000000000000000000000000000000000;;	// representing the time in seconds since the start of the http request. A user
0000000000000000000000000000000000000000;;	// may choose to use separately buckets Histograms, or implement custom
0000000000000000000000000000000000000000;;	// instance labels on a per function basis.
0000000000000000000000000000000000000000;;	type InstrumentTrace struct {
0000000000000000000000000000000000000000;;		GotConn              func(float64)
0000000000000000000000000000000000000000;;		PutIdleConn          func(float64)
0000000000000000000000000000000000000000;;		GotFirstResponseByte func(float64)
0000000000000000000000000000000000000000;;		Got100Continue       func(float64)
0000000000000000000000000000000000000000;;		DNSStart             func(float64)
0000000000000000000000000000000000000000;;		DNSDone              func(float64)
0000000000000000000000000000000000000000;;		ConnectStart         func(float64)
0000000000000000000000000000000000000000;;		ConnectDone          func(float64)
0000000000000000000000000000000000000000;;		TLSHandshakeStart    func(float64)
0000000000000000000000000000000000000000;;		TLSHandshakeDone     func(float64)
0000000000000000000000000000000000000000;;		WroteHeaders         func(float64)
0000000000000000000000000000000000000000;;		Wait100Continue      func(float64)
0000000000000000000000000000000000000000;;		WroteRequest         func(float64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentRoundTripperTrace is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// RoundTripper and reports times to hook functions provided in the
0000000000000000000000000000000000000000;;	// InstrumentTrace struct. Hook functions that are not present in the provided
0000000000000000000000000000000000000000;;	// InstrumentTrace struct are ignored. Times reported to the hook functions are
0000000000000000000000000000000000000000;;	// time since the start of the request. Note that partitioning of Histograms
0000000000000000000000000000000000000000;;	// is expensive and should be used judiciously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For hook functions that receive an error as an argument, no observations are
0000000000000000000000000000000000000000;;	// made in the event of a non-nil error value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for ExampleInstrumentRoundTripperDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentRoundTripperTrace(it *InstrumentTrace, next http.RoundTripper) RoundTripperFunc {
0000000000000000000000000000000000000000;;		return RoundTripperFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;			start := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			trace := &httptrace.ClientTrace{
0000000000000000000000000000000000000000;;				GotConn: func(_ httptrace.GotConnInfo) {
0000000000000000000000000000000000000000;;					if it.GotConn != nil {
0000000000000000000000000000000000000000;;						it.GotConn(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PutIdleConn: func(err error) {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if it.PutIdleConn != nil {
0000000000000000000000000000000000000000;;						it.PutIdleConn(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				DNSStart: func(_ httptrace.DNSStartInfo) {
0000000000000000000000000000000000000000;;					if it.DNSStart != nil {
0000000000000000000000000000000000000000;;						it.DNSStart(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				DNSDone: func(_ httptrace.DNSDoneInfo) {
0000000000000000000000000000000000000000;;					if it.DNSStart != nil {
0000000000000000000000000000000000000000;;						it.DNSStart(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ConnectStart: func(_, _ string) {
0000000000000000000000000000000000000000;;					if it.ConnectStart != nil {
0000000000000000000000000000000000000000;;						it.ConnectStart(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ConnectDone: func(_, _ string, err error) {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if it.ConnectDone != nil {
0000000000000000000000000000000000000000;;						it.ConnectDone(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				GotFirstResponseByte: func() {
0000000000000000000000000000000000000000;;					if it.GotFirstResponseByte != nil {
0000000000000000000000000000000000000000;;						it.GotFirstResponseByte(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Got100Continue: func() {
0000000000000000000000000000000000000000;;					if it.Got100Continue != nil {
0000000000000000000000000000000000000000;;						it.Got100Continue(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				TLSHandshakeStart: func() {
0000000000000000000000000000000000000000;;					if it.TLSHandshakeStart != nil {
0000000000000000000000000000000000000000;;						it.TLSHandshakeStart(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				TLSHandshakeDone: func(_ tls.ConnectionState, err error) {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if it.TLSHandshakeDone != nil {
0000000000000000000000000000000000000000;;						it.TLSHandshakeDone(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WroteHeaders: func() {
0000000000000000000000000000000000000000;;					if it.WroteHeaders != nil {
0000000000000000000000000000000000000000;;						it.WroteHeaders(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Wait100Continue: func() {
0000000000000000000000000000000000000000;;					if it.Wait100Continue != nil {
0000000000000000000000000000000000000000;;						it.Wait100Continue(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				WroteRequest: func(_ httptrace.WroteRequestInfo) {
0000000000000000000000000000000000000000;;					if it.WroteRequest != nil {
0000000000000000000000000000000000000000;;						it.WroteRequest(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r = r.WithContext(httptrace.WithClientTrace(context.Background(), trace))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return next.RoundTrip(r)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
