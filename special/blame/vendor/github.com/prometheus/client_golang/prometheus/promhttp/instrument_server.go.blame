0000000000000000000000000000000000000000;;	// Copyright 2017 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
13e1e7cd1550dcd956d3e82fe798021f5812b15e;;	
0000000000000000000000000000000000000000;;	package promhttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// magicString is used for the hacky label test in checkLabels. Remove once fixed.
0000000000000000000000000000000000000000;;	const magicString = "zZgWfBxLqvG8kc8IMv3POi2Bb0tZI3vAnBx+gBaFi9FyPzB/CzKUer1yufDa"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerInFlight is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.Handler. It sets the provided prometheus.Gauge to the number of
0000000000000000000000000000000000000000;;	// requests currently handled by the wrapped http.Handler.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for InstrumentHandlerDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentHandlerInFlight(g prometheus.Gauge, next http.Handler) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			g.Inc()
0000000000000000000000000000000000000000;;			defer g.Dec()
0000000000000000000000000000000000000000;;			next.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerDuration is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.Handler to observe the request duration with the provided ObserverVec.
0000000000000000000000000000000000000000;;	// The ObserverVec must have zero, one, or two labels. The only allowed label
0000000000000000000000000000000000000000;;	// names are "code" and "method". The function panics if any other instance
0000000000000000000000000000000000000000;;	// labels are provided. The Observe method of the Observer in the ObserverVec
0000000000000000000000000000000000000000;;	// is called with the request duration in seconds. Partitioning happens by HTTP
0000000000000000000000000000000000000000;;	// status code and/or HTTP method if the respective instance label names are
0000000000000000000000000000000000000000;;	// present in the ObserverVec. For unpartitioned observations, use an
0000000000000000000000000000000000000000;;	// ObserverVec with zero labels. Note that partitioning of Histograms is
0000000000000000000000000000000000000000;;	// expensive and should be used judiciously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler does not set a status code, a status code of 200 is assumed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler panics, no values are reported.
0000000000000000000000000000000000000000;;	func InstrumentHandlerDuration(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc {
0000000000000000000000000000000000000000;;		code, method := checkLabels(obs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if code {
0000000000000000000000000000000000000000;;			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				now := time.Now()
0000000000000000000000000000000000000000;;				d := newDelegator(w, nil)
0000000000000000000000000000000000000000;;				next.ServeHTTP(d, r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				obs.With(labels(code, method, r.Method, d.Status())).Observe(time.Since(now).Seconds())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			next.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;			obs.With(labels(code, method, r.Method, 0)).Observe(time.Since(now).Seconds())
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerCounter is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.Handler to observe the request result with the provided CounterVec.
0000000000000000000000000000000000000000;;	// The CounterVec must have zero, one, or two labels. The only allowed label
0000000000000000000000000000000000000000;;	// names are "code" and "method". The function panics if any other instance
0000000000000000000000000000000000000000;;	// labels are provided. Partitioning of the CounterVec happens by HTTP status
0000000000000000000000000000000000000000;;	// code and/or HTTP method if the respective instance label names are present
0000000000000000000000000000000000000000;;	// in the CounterVec. For unpartitioned counting, use a CounterVec with
0000000000000000000000000000000000000000;;	// zero labels.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler does not set a status code, a status code of 200 is assumed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler panics, the Counter is not incremented.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for InstrumentHandlerDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler) http.HandlerFunc {
0000000000000000000000000000000000000000;;		code, method := checkLabels(counter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if code {
0000000000000000000000000000000000000000;;			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				d := newDelegator(w, nil)
0000000000000000000000000000000000000000;;				next.ServeHTTP(d, r)
0000000000000000000000000000000000000000;;				counter.With(labels(code, method, r.Method, d.Status())).Inc()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			next.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;			counter.With(labels(code, method, r.Method, 0)).Inc()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerTimeToWriteHeader is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.Handler to observe with the provided ObserverVec the request duration
0000000000000000000000000000000000000000;;	// until the response headers are written. The ObserverVec must have zero, one,
0000000000000000000000000000000000000000;;	// or two labels. The only allowed label names are "code" and "method". The
0000000000000000000000000000000000000000;;	// function panics if any other instance labels are provided. The Observe
0000000000000000000000000000000000000000;;	// method of the Observer in the ObserverVec is called with the request
0000000000000000000000000000000000000000;;	// duration in seconds. Partitioning happens by HTTP status code and/or HTTP
0000000000000000000000000000000000000000;;	// method if the respective instance label names are present in the
0000000000000000000000000000000000000000;;	// ObserverVec. For unpartitioned observations, use an ObserverVec with zero
0000000000000000000000000000000000000000;;	// labels. Note that partitioning of Histograms is expensive and should be used
0000000000000000000000000000000000000000;;	// judiciously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler panics before calling WriteHeader, no value is
0000000000000000000000000000000000000000;;	// reported.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for InstrumentHandlerDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentHandlerTimeToWriteHeader(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc {
0000000000000000000000000000000000000000;;		code, method := checkLabels(obs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			d := newDelegator(w, func(status int) {
0000000000000000000000000000000000000000;;				obs.With(labels(code, method, r.Method, status)).Observe(time.Since(now).Seconds())
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			next.ServeHTTP(d, r)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerRequestSize is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.Handler to observe the request size with the provided ObserverVec.
0000000000000000000000000000000000000000;;	// The ObserverVec must have zero, one, or two labels. The only allowed label
0000000000000000000000000000000000000000;;	// names are "code" and "method". The function panics if any other instance
0000000000000000000000000000000000000000;;	// labels are provided. The Observe method of the Observer in the ObserverVec
0000000000000000000000000000000000000000;;	// is called with the request size in bytes. Partitioning happens by HTTP
0000000000000000000000000000000000000000;;	// status code and/or HTTP method if the respective instance label names are
0000000000000000000000000000000000000000;;	// present in the ObserverVec. For unpartitioned observations, use an
0000000000000000000000000000000000000000;;	// ObserverVec with zero labels. Note that partitioning of Histograms is
0000000000000000000000000000000000000000;;	// expensive and should be used judiciously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler does not set a status code, a status code of 200 is assumed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler panics, no values are reported.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for InstrumentHandlerDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentHandlerRequestSize(obs prometheus.ObserverVec, next http.Handler) http.HandlerFunc {
0000000000000000000000000000000000000000;;		code, method := checkLabels(obs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if code {
0000000000000000000000000000000000000000;;			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				d := newDelegator(w, nil)
0000000000000000000000000000000000000000;;				next.ServeHTTP(d, r)
0000000000000000000000000000000000000000;;				size := computeApproximateRequestSize(r)
0000000000000000000000000000000000000000;;				obs.With(labels(code, method, r.Method, d.Status())).Observe(float64(size))
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			next.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;			size := computeApproximateRequestSize(r)
0000000000000000000000000000000000000000;;			obs.With(labels(code, method, r.Method, 0)).Observe(float64(size))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstrumentHandlerResponseSize is a middleware that wraps the provided
0000000000000000000000000000000000000000;;	// http.Handler to observe the response size with the provided ObserverVec.
0000000000000000000000000000000000000000;;	// The ObserverVec must have zero, one, or two labels. The only allowed label
0000000000000000000000000000000000000000;;	// names are "code" and "method". The function panics if any other instance
0000000000000000000000000000000000000000;;	// labels are provided. The Observe method of the Observer in the ObserverVec
0000000000000000000000000000000000000000;;	// is called with the response size in bytes. Partitioning happens by HTTP
0000000000000000000000000000000000000000;;	// status code and/or HTTP method if the respective instance label names are
0000000000000000000000000000000000000000;;	// present in the ObserverVec. For unpartitioned observations, use an
0000000000000000000000000000000000000000;;	// ObserverVec with zero labels. Note that partitioning of Histograms is
0000000000000000000000000000000000000000;;	// expensive and should be used judiciously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler does not set a status code, a status code of 200 is assumed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the wrapped Handler panics, no values are reported.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the example for InstrumentHandlerDuration for example usage.
0000000000000000000000000000000000000000;;	func InstrumentHandlerResponseSize(obs prometheus.ObserverVec, next http.Handler) http.Handler {
0000000000000000000000000000000000000000;;		code, method := checkLabels(obs)
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			d := newDelegator(w, nil)
0000000000000000000000000000000000000000;;			next.ServeHTTP(d, r)
0000000000000000000000000000000000000000;;			obs.With(labels(code, method, r.Method, d.Status())).Observe(float64(d.Written()))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkLabels(c prometheus.Collector) (code bool, method bool) {
0000000000000000000000000000000000000000;;		// TODO(beorn7): Remove this hacky way to check for instance labels
0000000000000000000000000000000000000000;;		// once Descriptors can have their dimensionality queried.
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			desc *prometheus.Desc
0000000000000000000000000000000000000000;;			pm   dto.Metric
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		descc := make(chan *prometheus.Desc, 1)
0000000000000000000000000000000000000000;;		c.Describe(descc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case desc = <-descc:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("no description provided by collector")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-descc:
0000000000000000000000000000000000000000;;			panic("more than one description provided by collector")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(descc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := prometheus.NewConstMetric(desc, prometheus.UntypedValue, 0); err == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m, err := prometheus.NewConstMetric(desc, prometheus.UntypedValue, 0, magicString); err == nil {
0000000000000000000000000000000000000000;;			if err := m.Write(&pm); err != nil {
0000000000000000000000000000000000000000;;				panic("error checking metric for labels")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, label := range pm.Label {
0000000000000000000000000000000000000000;;				name, value := label.GetName(), label.GetValue()
0000000000000000000000000000000000000000;;				if value != magicString {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch name {
0000000000000000000000000000000000000000;;				case "code":
0000000000000000000000000000000000000000;;					code = true
0000000000000000000000000000000000000000;;				case "method":
0000000000000000000000000000000000000000;;					method = true
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic("metric partitioned with non-supported labels")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			panic("previously set label not found – this must never happen")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m, err := prometheus.NewConstMetric(desc, prometheus.UntypedValue, 0, magicString, magicString); err == nil {
0000000000000000000000000000000000000000;;			if err := m.Write(&pm); err != nil {
0000000000000000000000000000000000000000;;				panic("error checking metric for labels")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, label := range pm.Label {
0000000000000000000000000000000000000000;;				name, value := label.GetName(), label.GetValue()
0000000000000000000000000000000000000000;;				if value != magicString {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if name == "code" || name == "method" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				panic("metric partitioned with non-supported labels")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			code = true
0000000000000000000000000000000000000000;;			method = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("metric partitioned with non-supported labels")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// emptyLabels is a one-time allocation for non-partitioned metrics to avoid
0000000000000000000000000000000000000000;;	// unnecessary allocations on each request.
0000000000000000000000000000000000000000;;	var emptyLabels = prometheus.Labels{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func labels(code, method bool, reqMethod string, status int) prometheus.Labels {
0000000000000000000000000000000000000000;;		if !(code || method) {
0000000000000000000000000000000000000000;;			return emptyLabels
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels := prometheus.Labels{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if code {
0000000000000000000000000000000000000000;;			labels["code"] = sanitizeCode(status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if method {
0000000000000000000000000000000000000000;;			labels["method"] = sanitizeMethod(reqMethod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func computeApproximateRequestSize(r *http.Request) int {
0000000000000000000000000000000000000000;;		s := 0
0000000000000000000000000000000000000000;;		if r.URL != nil {
0000000000000000000000000000000000000000;;			s += len(r.URL.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s += len(r.Method)
0000000000000000000000000000000000000000;;		s += len(r.Proto)
0000000000000000000000000000000000000000;;		for name, values := range r.Header {
0000000000000000000000000000000000000000;;			s += len(name)
0000000000000000000000000000000000000000;;			for _, value := range values {
0000000000000000000000000000000000000000;;				s += len(value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s += len(r.Host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// N.B. r.Form and r.MultipartForm are assumed to be included in r.URL.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.ContentLength != -1 {
0000000000000000000000000000000000000000;;			s += int(r.ContentLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sanitizeMethod(m string) string {
0000000000000000000000000000000000000000;;		switch m {
0000000000000000000000000000000000000000;;		case "GET", "get":
0000000000000000000000000000000000000000;;			return "get"
0000000000000000000000000000000000000000;;		case "PUT", "put":
0000000000000000000000000000000000000000;;			return "put"
0000000000000000000000000000000000000000;;		case "HEAD", "head":
0000000000000000000000000000000000000000;;			return "head"
0000000000000000000000000000000000000000;;		case "POST", "post":
0000000000000000000000000000000000000000;;			return "post"
0000000000000000000000000000000000000000;;		case "DELETE", "delete":
0000000000000000000000000000000000000000;;			return "delete"
0000000000000000000000000000000000000000;;		case "CONNECT", "connect":
0000000000000000000000000000000000000000;;			return "connect"
0000000000000000000000000000000000000000;;		case "OPTIONS", "options":
0000000000000000000000000000000000000000;;			return "options"
0000000000000000000000000000000000000000;;		case "NOTIFY", "notify":
0000000000000000000000000000000000000000;;			return "notify"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return strings.ToLower(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If the wrapped http.Handler has not set a status code, i.e. the value is
0000000000000000000000000000000000000000;;	// currently 0, santizeCode will return 200, for consistency with behavior in
0000000000000000000000000000000000000000;;	// the stdlib.
0000000000000000000000000000000000000000;;	func sanitizeCode(s int) string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case 100:
0000000000000000000000000000000000000000;;			return "100"
0000000000000000000000000000000000000000;;		case 101:
0000000000000000000000000000000000000000;;			return "101"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 200, 0:
0000000000000000000000000000000000000000;;			return "200"
0000000000000000000000000000000000000000;;		case 201:
0000000000000000000000000000000000000000;;			return "201"
0000000000000000000000000000000000000000;;		case 202:
0000000000000000000000000000000000000000;;			return "202"
0000000000000000000000000000000000000000;;		case 203:
0000000000000000000000000000000000000000;;			return "203"
0000000000000000000000000000000000000000;;		case 204:
0000000000000000000000000000000000000000;;			return "204"
0000000000000000000000000000000000000000;;		case 205:
0000000000000000000000000000000000000000;;			return "205"
0000000000000000000000000000000000000000;;		case 206:
0000000000000000000000000000000000000000;;			return "206"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 300:
0000000000000000000000000000000000000000;;			return "300"
0000000000000000000000000000000000000000;;		case 301:
0000000000000000000000000000000000000000;;			return "301"
0000000000000000000000000000000000000000;;		case 302:
0000000000000000000000000000000000000000;;			return "302"
0000000000000000000000000000000000000000;;		case 304:
0000000000000000000000000000000000000000;;			return "304"
0000000000000000000000000000000000000000;;		case 305:
0000000000000000000000000000000000000000;;			return "305"
0000000000000000000000000000000000000000;;		case 307:
0000000000000000000000000000000000000000;;			return "307"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 400:
0000000000000000000000000000000000000000;;			return "400"
0000000000000000000000000000000000000000;;		case 401:
0000000000000000000000000000000000000000;;			return "401"
0000000000000000000000000000000000000000;;		case 402:
0000000000000000000000000000000000000000;;			return "402"
0000000000000000000000000000000000000000;;		case 403:
0000000000000000000000000000000000000000;;			return "403"
0000000000000000000000000000000000000000;;		case 404:
0000000000000000000000000000000000000000;;			return "404"
0000000000000000000000000000000000000000;;		case 405:
0000000000000000000000000000000000000000;;			return "405"
0000000000000000000000000000000000000000;;		case 406:
0000000000000000000000000000000000000000;;			return "406"
0000000000000000000000000000000000000000;;		case 407:
0000000000000000000000000000000000000000;;			return "407"
0000000000000000000000000000000000000000;;		case 408:
0000000000000000000000000000000000000000;;			return "408"
0000000000000000000000000000000000000000;;		case 409:
0000000000000000000000000000000000000000;;			return "409"
0000000000000000000000000000000000000000;;		case 410:
0000000000000000000000000000000000000000;;			return "410"
0000000000000000000000000000000000000000;;		case 411:
0000000000000000000000000000000000000000;;			return "411"
0000000000000000000000000000000000000000;;		case 412:
0000000000000000000000000000000000000000;;			return "412"
0000000000000000000000000000000000000000;;		case 413:
0000000000000000000000000000000000000000;;			return "413"
0000000000000000000000000000000000000000;;		case 414:
0000000000000000000000000000000000000000;;			return "414"
0000000000000000000000000000000000000000;;		case 415:
0000000000000000000000000000000000000000;;			return "415"
0000000000000000000000000000000000000000;;		case 416:
0000000000000000000000000000000000000000;;			return "416"
0000000000000000000000000000000000000000;;		case 417:
0000000000000000000000000000000000000000;;			return "417"
0000000000000000000000000000000000000000;;		case 418:
0000000000000000000000000000000000000000;;			return "418"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 500:
0000000000000000000000000000000000000000;;			return "500"
0000000000000000000000000000000000000000;;		case 501:
0000000000000000000000000000000000000000;;			return "501"
0000000000000000000000000000000000000000;;		case 502:
0000000000000000000000000000000000000000;;			return "502"
0000000000000000000000000000000000000000;;		case 503:
0000000000000000000000000000000000000000;;			return "503"
0000000000000000000000000000000000000000;;		case 504:
0000000000000000000000000000000000000000;;			return "504"
0000000000000000000000000000000000000000;;		case 505:
0000000000000000000000000000000000000000;;			return "505"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 428:
0000000000000000000000000000000000000000;;			return "428"
0000000000000000000000000000000000000000;;		case 429:
0000000000000000000000000000000000000000;;			return "429"
0000000000000000000000000000000000000000;;		case 431:
0000000000000000000000000000000000000000;;			return "431"
0000000000000000000000000000000000000000;;		case 511:
0000000000000000000000000000000000000000;;			return "511"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return strconv.Itoa(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type delegator interface {
0000000000000000000000000000000000000000;;		Status() int
0000000000000000000000000000000000000000;;		Written() int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type responseWriterDelegator struct {
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler, method    string
0000000000000000000000000000000000000000;;		status             int
0000000000000000000000000000000000000000;;		written            int64
0000000000000000000000000000000000000000;;		wroteHeader        bool
0000000000000000000000000000000000000000;;		observeWriteHeader func(int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriterDelegator) Status() int {
0000000000000000000000000000000000000000;;		return r.status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriterDelegator) Written() int64 {
0000000000000000000000000000000000000000;;		return r.written
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriterDelegator) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		r.status = code
0000000000000000000000000000000000000000;;		r.wroteHeader = true
0000000000000000000000000000000000000000;;		r.ResponseWriter.WriteHeader(code)
0000000000000000000000000000000000000000;;		if r.observeWriteHeader != nil {
0000000000000000000000000000000000000000;;			r.observeWriteHeader(code)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriterDelegator) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !r.wroteHeader {
0000000000000000000000000000000000000000;;			r.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := r.ResponseWriter.Write(b)
0000000000000000000000000000000000000000;;		r.written += int64(n)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fancyDelegator struct {
0000000000000000000000000000000000000000;;		*responseWriterDelegator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *fancyDelegator) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		return r.ResponseWriter.(http.CloseNotifier).CloseNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *fancyDelegator) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		return r.ResponseWriter.(http.Hijacker).Hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *fancyDelegator) Flush() {
0000000000000000000000000000000000000000;;		r.ResponseWriter.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *fancyDelegator) ReadFrom(re io.Reader) (int64, error) {
0000000000000000000000000000000000000000;;		if !r.wroteHeader {
0000000000000000000000000000000000000000;;			r.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := r.ResponseWriter.(io.ReaderFrom).ReadFrom(re)
0000000000000000000000000000000000000000;;		r.written += n
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
