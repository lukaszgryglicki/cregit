0000000000000000000000000000000000000000;;	// Copyright 2016 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
13e1e7cd1550dcd956d3e82fe798021f5812b15e;;	
0000000000000000000000000000000000000000;;	// Package promhttp provides tooling around HTTP servers and clients.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// First, the package allows the creation of http.Handler instances to expose
0000000000000000000000000000000000000000;;	// Prometheus metrics via HTTP. promhttp.Handler acts on the
0000000000000000000000000000000000000000;;	// prometheus.DefaultGatherer. With HandlerFor, you can create a handler for a
0000000000000000000000000000000000000000;;	// custom registry or anything that implements the Gatherer interface. It also
0000000000000000000000000000000000000000;;	// allows the creation of handlers that act differently on errors or allow to
0000000000000000000000000000000000000000;;	// log errors.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Second, the package provides tooling to instrument instances of http.Handler
0000000000000000000000000000000000000000;;	// via middleware. Middleware wrappers follow the naming scheme
0000000000000000000000000000000000000000;;	// InstrumentHandlerX, where X describes the intended use of the middleware.
0000000000000000000000000000000000000000;;	// See each function's doc comment for specific details.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Finally, the package allows for an http.RoundTripper to be instrumented via
0000000000000000000000000000000000000000;;	// middleware. Middleware wrappers follow the naming scheme
0000000000000000000000000000000000000000;;	// InstrumentRoundTripperX, where X describes the intended use of the
0000000000000000000000000000000000000000;;	// middleware. See each function's doc comment for specific details.
0000000000000000000000000000000000000000;;	package promhttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/expfmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		contentTypeHeader     = "Content-Type"
0000000000000000000000000000000000000000;;		contentLengthHeader   = "Content-Length"
0000000000000000000000000000000000000000;;		contentEncodingHeader = "Content-Encoding"
0000000000000000000000000000000000000000;;		acceptEncodingHeader  = "Accept-Encoding"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bufPool sync.Pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getBuf() *bytes.Buffer {
0000000000000000000000000000000000000000;;		buf := bufPool.Get()
0000000000000000000000000000000000000000;;		if buf == nil {
0000000000000000000000000000000000000000;;			return &bytes.Buffer{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.(*bytes.Buffer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func giveBuf(buf *bytes.Buffer) {
0000000000000000000000000000000000000000;;		buf.Reset()
0000000000000000000000000000000000000000;;		bufPool.Put(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler returns an HTTP handler for the prometheus.DefaultGatherer. The
0000000000000000000000000000000000000000;;	// Handler uses the default HandlerOpts, i.e. report the first error as an HTTP
0000000000000000000000000000000000000000;;	// error, no error logging, and compression if requested by the client.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you want to create a Handler for the DefaultGatherer with different
0000000000000000000000000000000000000000;;	// HandlerOpts, create it with HandlerFor with prometheus.DefaultGatherer and
0000000000000000000000000000000000000000;;	// your desired HandlerOpts.
0000000000000000000000000000000000000000;;	func Handler() http.Handler {
0000000000000000000000000000000000000000;;		return HandlerFor(prometheus.DefaultGatherer, HandlerOpts{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerFor returns an http.Handler for the provided Gatherer. The behavior
0000000000000000000000000000000000000000;;	// of the Handler is defined by the provided HandlerOpts.
0000000000000000000000000000000000000000;;	func HandlerFor(reg prometheus.Gatherer, opts HandlerOpts) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			mfs, err := reg.Gather()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if opts.ErrorLog != nil {
0000000000000000000000000000000000000000;;					opts.ErrorLog.Println("error gathering metrics:", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch opts.ErrorHandling {
0000000000000000000000000000000000000000;;				case PanicOnError:
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				case ContinueOnError:
0000000000000000000000000000000000000000;;					if len(mfs) == 0 {
0000000000000000000000000000000000000000;;						http.Error(w, "No metrics gathered, last error:\n\n"+err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case HTTPErrorOnError:
0000000000000000000000000000000000000000;;					http.Error(w, "An error has occurred during metrics gathering:\n\n"+err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			contentType := expfmt.Negotiate(req.Header)
0000000000000000000000000000000000000000;;			buf := getBuf()
0000000000000000000000000000000000000000;;			defer giveBuf(buf)
0000000000000000000000000000000000000000;;			writer, encoding := decorateWriter(req, buf, opts.DisableCompression)
0000000000000000000000000000000000000000;;			enc := expfmt.NewEncoder(writer, contentType)
0000000000000000000000000000000000000000;;			var lastErr error
0000000000000000000000000000000000000000;;			for _, mf := range mfs {
0000000000000000000000000000000000000000;;				if err := enc.Encode(mf); err != nil {
0000000000000000000000000000000000000000;;					lastErr = err
0000000000000000000000000000000000000000;;					if opts.ErrorLog != nil {
0000000000000000000000000000000000000000;;						opts.ErrorLog.Println("error encoding metric family:", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					switch opts.ErrorHandling {
0000000000000000000000000000000000000000;;					case PanicOnError:
0000000000000000000000000000000000000000;;						panic(err)
0000000000000000000000000000000000000000;;					case ContinueOnError:
0000000000000000000000000000000000000000;;						// Handled later.
0000000000000000000000000000000000000000;;					case HTTPErrorOnError:
0000000000000000000000000000000000000000;;						http.Error(w, "An error has occurred during metrics encoding:\n\n"+err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if closer, ok := writer.(io.Closer); ok {
0000000000000000000000000000000000000000;;				closer.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lastErr != nil && buf.Len() == 0 {
0000000000000000000000000000000000000000;;				http.Error(w, "No metrics encoded, last error:\n\n"+err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			header := w.Header()
0000000000000000000000000000000000000000;;			header.Set(contentTypeHeader, string(contentType))
0000000000000000000000000000000000000000;;			header.Set(contentLengthHeader, fmt.Sprint(buf.Len()))
0000000000000000000000000000000000000000;;			if encoding != "" {
0000000000000000000000000000000000000000;;				header.Set(contentEncodingHeader, encoding)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(buf.Bytes())
0000000000000000000000000000000000000000;;			// TODO(beorn7): Consider streaming serving of metrics.
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerErrorHandling defines how a Handler serving metrics will handle
0000000000000000000000000000000000000000;;	// errors.
0000000000000000000000000000000000000000;;	type HandlerErrorHandling int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These constants cause handlers serving metrics to behave as described if
0000000000000000000000000000000000000000;;	// errors are encountered.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Serve an HTTP status code 500 upon the first error
0000000000000000000000000000000000000000;;		// encountered. Report the error message in the body.
0000000000000000000000000000000000000000;;		HTTPErrorOnError HandlerErrorHandling = iota
0000000000000000000000000000000000000000;;		// Ignore errors and try to serve as many metrics as possible.  However,
0000000000000000000000000000000000000000;;		// if no metrics can be served, serve an HTTP status code 500 and the
0000000000000000000000000000000000000000;;		// last error message in the body. Only use this in deliberate "best
0000000000000000000000000000000000000000;;		// effort" metrics collection scenarios. It is recommended to at least
0000000000000000000000000000000000000000;;		// log errors (by providing an ErrorLog in HandlerOpts) to not mask
0000000000000000000000000000000000000000;;		// errors completely.
0000000000000000000000000000000000000000;;		ContinueOnError
0000000000000000000000000000000000000000;;		// Panic upon the first error encountered (useful for "crash only" apps).
0000000000000000000000000000000000000000;;		PanicOnError
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Logger is the minimal interface HandlerOpts needs for logging. Note that
0000000000000000000000000000000000000000;;	// log.Logger from the standard library implements this interface, and it is
0000000000000000000000000000000000000000;;	// easy to implement by custom loggers, if they don't do so already anyway.
0000000000000000000000000000000000000000;;	type Logger interface {
0000000000000000000000000000000000000000;;		Println(v ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerOpts specifies options how to serve metrics via an http.Handler. The
0000000000000000000000000000000000000000;;	// zero value of HandlerOpts is a reasonable default.
0000000000000000000000000000000000000000;;	type HandlerOpts struct {
0000000000000000000000000000000000000000;;		// ErrorLog specifies an optional logger for errors collecting and
0000000000000000000000000000000000000000;;		// serving metrics. If nil, errors are not logged at all.
0000000000000000000000000000000000000000;;		ErrorLog Logger
0000000000000000000000000000000000000000;;		// ErrorHandling defines how errors are handled. Note that errors are
0000000000000000000000000000000000000000;;		// logged regardless of the configured ErrorHandling provided ErrorLog
0000000000000000000000000000000000000000;;		// is not nil.
0000000000000000000000000000000000000000;;		ErrorHandling HandlerErrorHandling
0000000000000000000000000000000000000000;;		// If DisableCompression is true, the handler will never compress the
0000000000000000000000000000000000000000;;		// response, even if requested by the client.
0000000000000000000000000000000000000000;;		DisableCompression bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decorateWriter wraps a writer to handle gzip compression if requested.  It
0000000000000000000000000000000000000000;;	// returns the decorated writer and the appropriate "Content-Encoding" header
0000000000000000000000000000000000000000;;	// (which is empty if no compression is enabled).
0000000000000000000000000000000000000000;;	func decorateWriter(request *http.Request, writer io.Writer, compressionDisabled bool) (io.Writer, string) {
0000000000000000000000000000000000000000;;		if compressionDisabled {
0000000000000000000000000000000000000000;;			return writer, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		header := request.Header.Get(acceptEncodingHeader)
0000000000000000000000000000000000000000;;		parts := strings.Split(header, ",")
0000000000000000000000000000000000000000;;		for _, part := range parts {
0000000000000000000000000000000000000000;;			part := strings.TrimSpace(part)
0000000000000000000000000000000000000000;;			if part == "gzip" || strings.HasPrefix(part, "gzip;") {
0000000000000000000000000000000000000000;;				return gzip.NewWriter(writer), "gzip"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return writer, ""
0000000000000000000000000000000000000000;;	}
