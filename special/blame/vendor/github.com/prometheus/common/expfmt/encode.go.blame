0000000000000000000000000000000000000000;;	// Copyright 2015 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b86cc30ece6ecc0d16bd8e3af4be75b963154490;Godeps/_workspace/src/github.com/prometheus/common/expfmt/encode.go[Godeps/_workspace/src/github.com/prometheus/common/expfmt/encode.go][vendor/github.com/prometheus/common/expfmt/encode.go];	
0000000000000000000000000000000000000000;;	package expfmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/matttproud/golang_protobuf_extensions/pbutil"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/internal/bitbucket.org/ww/goautoneg"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encoder types encode metric families into an underlying wire protocol.
0000000000000000000000000000000000000000;;	type Encoder interface {
0000000000000000000000000000000000000000;;		Encode(*dto.MetricFamily) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encoder func(*dto.MetricFamily) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e encoder) Encode(v *dto.MetricFamily) error {
0000000000000000000000000000000000000000;;		return e(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Negotiate returns the Content-Type based on the given Accept header.
0000000000000000000000000000000000000000;;	// If no appropriate accepted type is found, FmtText is returned.
0000000000000000000000000000000000000000;;	func Negotiate(h http.Header) Format {
0000000000000000000000000000000000000000;;		for _, ac := range goautoneg.ParseAccept(h.Get(hdrAccept)) {
0000000000000000000000000000000000000000;;			// Check for protocol buffer
0000000000000000000000000000000000000000;;			if ac.Type+"/"+ac.SubType == ProtoType && ac.Params["proto"] == ProtoProtocol {
0000000000000000000000000000000000000000;;				switch ac.Params["encoding"] {
0000000000000000000000000000000000000000;;				case "delimited":
0000000000000000000000000000000000000000;;					return FmtProtoDelim
0000000000000000000000000000000000000000;;				case "text":
0000000000000000000000000000000000000000;;					return FmtProtoText
0000000000000000000000000000000000000000;;				case "compact-text":
0000000000000000000000000000000000000000;;					return FmtProtoCompact
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for text format.
0000000000000000000000000000000000000000;;			ver := ac.Params["version"]
0000000000000000000000000000000000000000;;			if ac.Type == "text" && ac.SubType == "plain" && (ver == TextVersion || ver == "") {
0000000000000000000000000000000000000000;;				return FmtText
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FmtText
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder returns a new encoder based on content type negotiation.
0000000000000000000000000000000000000000;;	func NewEncoder(w io.Writer, format Format) Encoder {
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case FmtProtoDelim:
0000000000000000000000000000000000000000;;			return encoder(func(v *dto.MetricFamily) error {
0000000000000000000000000000000000000000;;				_, err := pbutil.WriteDelimited(w, v)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case FmtProtoCompact:
0000000000000000000000000000000000000000;;			return encoder(func(v *dto.MetricFamily) error {
0000000000000000000000000000000000000000;;				_, err := fmt.Fprintln(w, v.String())
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case FmtProtoText:
0000000000000000000000000000000000000000;;			return encoder(func(v *dto.MetricFamily) error {
0000000000000000000000000000000000000000;;				_, err := fmt.Fprintln(w, proto.MarshalTextString(v))
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case FmtText:
0000000000000000000000000000000000000000;;			return encoder(func(v *dto.MetricFamily) error {
0000000000000000000000000000000000000000;;				_, err := MetricFamilyToText(w, v)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("expfmt.NewEncoder: unknown format")
0000000000000000000000000000000000000000;;	}
