0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
f7e1dc03448db9e2d7d0160d5b6aa202c60d79bc;Godeps/_workspace/src/github.com/prometheus/common/expfmt/text_create.go[Godeps/_workspace/src/github.com/prometheus/common/expfmt/text_create.go][vendor/github.com/prometheus/common/expfmt/text_create.go];	
0000000000000000000000000000000000000000;;	package expfmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/model"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetricFamilyToText converts a MetricFamily proto message into text format and
0000000000000000000000000000000000000000;;	// writes the resulting lines to 'out'. It returns the number of bytes written
0000000000000000000000000000000000000000;;	// and any error encountered. The output will have the same order as the input,
0000000000000000000000000000000000000000;;	// no further sorting is performed. Furthermore, this function assumes the input
0000000000000000000000000000000000000000;;	// is already sanitized and does not perform any sanity checks. If the input
0000000000000000000000000000000000000000;;	// contains duplicate metrics or invalid metric or label names, the conversion
0000000000000000000000000000000000000000;;	// will result in invalid text format output.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method fulfills the type 'prometheus.encoder'.
0000000000000000000000000000000000000000;;	func MetricFamilyToText(out io.Writer, in *dto.MetricFamily) (int, error) {
0000000000000000000000000000000000000000;;		var written int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fail-fast checks.
0000000000000000000000000000000000000000;;		if len(in.Metric) == 0 {
0000000000000000000000000000000000000000;;			return written, fmt.Errorf("MetricFamily has no metrics: %s", in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := in.GetName()
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return written, fmt.Errorf("MetricFamily has no name: %s", in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Comments, first HELP, then TYPE.
0000000000000000000000000000000000000000;;		if in.Help != nil {
0000000000000000000000000000000000000000;;			n, err := fmt.Fprintf(
0000000000000000000000000000000000000000;;				out, "# HELP %s %s\n",
0000000000000000000000000000000000000000;;				name, escapeString(*in.Help, false),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			written += n
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return written, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metricType := in.GetType()
0000000000000000000000000000000000000000;;		n, err := fmt.Fprintf(
0000000000000000000000000000000000000000;;			out, "# TYPE %s %s\n",
0000000000000000000000000000000000000000;;			name, strings.ToLower(metricType.String()),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		written += n
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return written, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finally the samples, one line for each.
0000000000000000000000000000000000000000;;		for _, metric := range in.Metric {
0000000000000000000000000000000000000000;;			switch metricType {
0000000000000000000000000000000000000000;;			case dto.MetricType_COUNTER:
0000000000000000000000000000000000000000;;				if metric.Counter == nil {
0000000000000000000000000000000000000000;;					return written, fmt.Errorf(
0000000000000000000000000000000000000000;;						"expected counter in metric %s %s", name, metric,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err = writeSample(
0000000000000000000000000000000000000000;;					name, metric, "", "",
0000000000000000000000000000000000000000;;					metric.Counter.GetValue(),
0000000000000000000000000000000000000000;;					out,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			case dto.MetricType_GAUGE:
0000000000000000000000000000000000000000;;				if metric.Gauge == nil {
0000000000000000000000000000000000000000;;					return written, fmt.Errorf(
0000000000000000000000000000000000000000;;						"expected gauge in metric %s %s", name, metric,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err = writeSample(
0000000000000000000000000000000000000000;;					name, metric, "", "",
0000000000000000000000000000000000000000;;					metric.Gauge.GetValue(),
0000000000000000000000000000000000000000;;					out,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			case dto.MetricType_UNTYPED:
0000000000000000000000000000000000000000;;				if metric.Untyped == nil {
0000000000000000000000000000000000000000;;					return written, fmt.Errorf(
0000000000000000000000000000000000000000;;						"expected untyped in metric %s %s", name, metric,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err = writeSample(
0000000000000000000000000000000000000000;;					name, metric, "", "",
0000000000000000000000000000000000000000;;					metric.Untyped.GetValue(),
0000000000000000000000000000000000000000;;					out,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			case dto.MetricType_SUMMARY:
0000000000000000000000000000000000000000;;				if metric.Summary == nil {
0000000000000000000000000000000000000000;;					return written, fmt.Errorf(
0000000000000000000000000000000000000000;;						"expected summary in metric %s %s", name, metric,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, q := range metric.Summary.Quantile {
0000000000000000000000000000000000000000;;					n, err = writeSample(
0000000000000000000000000000000000000000;;						name, metric,
0000000000000000000000000000000000000000;;						model.QuantileLabel, fmt.Sprint(q.GetQuantile()),
0000000000000000000000000000000000000000;;						q.GetValue(),
0000000000000000000000000000000000000000;;						out,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					written += n
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return written, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err = writeSample(
0000000000000000000000000000000000000000;;					name+"_sum", metric, "", "",
0000000000000000000000000000000000000000;;					metric.Summary.GetSampleSum(),
0000000000000000000000000000000000000000;;					out,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return written, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				written += n
0000000000000000000000000000000000000000;;				n, err = writeSample(
0000000000000000000000000000000000000000;;					name+"_count", metric, "", "",
0000000000000000000000000000000000000000;;					float64(metric.Summary.GetSampleCount()),
0000000000000000000000000000000000000000;;					out,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			case dto.MetricType_HISTOGRAM:
0000000000000000000000000000000000000000;;				if metric.Histogram == nil {
0000000000000000000000000000000000000000;;					return written, fmt.Errorf(
0000000000000000000000000000000000000000;;						"expected histogram in metric %s %s", name, metric,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				infSeen := false
0000000000000000000000000000000000000000;;				for _, q := range metric.Histogram.Bucket {
0000000000000000000000000000000000000000;;					n, err = writeSample(
0000000000000000000000000000000000000000;;						name+"_bucket", metric,
0000000000000000000000000000000000000000;;						model.BucketLabel, fmt.Sprint(q.GetUpperBound()),
0000000000000000000000000000000000000000;;						float64(q.GetCumulativeCount()),
0000000000000000000000000000000000000000;;						out,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					written += n
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return written, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if math.IsInf(q.GetUpperBound(), +1) {
0000000000000000000000000000000000000000;;						infSeen = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !infSeen {
0000000000000000000000000000000000000000;;					n, err = writeSample(
0000000000000000000000000000000000000000;;						name+"_bucket", metric,
0000000000000000000000000000000000000000;;						model.BucketLabel, "+Inf",
0000000000000000000000000000000000000000;;						float64(metric.Histogram.GetSampleCount()),
0000000000000000000000000000000000000000;;						out,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return written, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					written += n
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err = writeSample(
0000000000000000000000000000000000000000;;					name+"_sum", metric, "", "",
0000000000000000000000000000000000000000;;					metric.Histogram.GetSampleSum(),
0000000000000000000000000000000000000000;;					out,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return written, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				written += n
0000000000000000000000000000000000000000;;				n, err = writeSample(
0000000000000000000000000000000000000000;;					name+"_count", metric, "", "",
0000000000000000000000000000000000000000;;					float64(metric.Histogram.GetSampleCount()),
0000000000000000000000000000000000000000;;					out,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return written, fmt.Errorf(
0000000000000000000000000000000000000000;;					"unexpected type in metric %s %s", name, metric,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			written += n
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return written, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return written, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeSample writes a single sample in text format to out, given the metric
0000000000000000000000000000000000000000;;	// name, the metric proto message itself, optionally an additional label name
0000000000000000000000000000000000000000;;	// and value (use empty strings if not required), and the value. The function
0000000000000000000000000000000000000000;;	// returns the number of bytes written and any error encountered.
0000000000000000000000000000000000000000;;	func writeSample(
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		metric *dto.Metric,
0000000000000000000000000000000000000000;;		additionalLabelName, additionalLabelValue string,
0000000000000000000000000000000000000000;;		value float64,
0000000000000000000000000000000000000000;;		out io.Writer,
0000000000000000000000000000000000000000;;	) (int, error) {
0000000000000000000000000000000000000000;;		var written int
0000000000000000000000000000000000000000;;		n, err := fmt.Fprint(out, name)
0000000000000000000000000000000000000000;;		written += n
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return written, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = labelPairsToText(
0000000000000000000000000000000000000000;;			metric.Label,
0000000000000000000000000000000000000000;;			additionalLabelName, additionalLabelValue,
0000000000000000000000000000000000000000;;			out,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		written += n
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return written, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = fmt.Fprintf(out, " %v", value)
0000000000000000000000000000000000000000;;		written += n
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return written, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if metric.TimestampMs != nil {
0000000000000000000000000000000000000000;;			n, err = fmt.Fprintf(out, " %v", *metric.TimestampMs)
0000000000000000000000000000000000000000;;			written += n
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return written, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = out.Write([]byte{'\n'})
0000000000000000000000000000000000000000;;		written += n
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return written, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return written, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// labelPairsToText converts a slice of LabelPair proto messages plus the
0000000000000000000000000000000000000000;;	// explicitly given additional label pair into text formatted as required by the
0000000000000000000000000000000000000000;;	// text format and writes it to 'out'. An empty slice in combination with an
0000000000000000000000000000000000000000;;	// empty string 'additionalLabelName' results in nothing being
0000000000000000000000000000000000000000;;	// written. Otherwise, the label pairs are written, escaped as required by the
0000000000000000000000000000000000000000;;	// text format, and enclosed in '{...}'. The function returns the number of
0000000000000000000000000000000000000000;;	// bytes written and any error encountered.
0000000000000000000000000000000000000000;;	func labelPairsToText(
0000000000000000000000000000000000000000;;		in []*dto.LabelPair,
0000000000000000000000000000000000000000;;		additionalLabelName, additionalLabelValue string,
0000000000000000000000000000000000000000;;		out io.Writer,
0000000000000000000000000000000000000000;;	) (int, error) {
0000000000000000000000000000000000000000;;		if len(in) == 0 && additionalLabelName == "" {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var written int
0000000000000000000000000000000000000000;;		separator := '{'
0000000000000000000000000000000000000000;;		for _, lp := range in {
0000000000000000000000000000000000000000;;			n, err := fmt.Fprintf(
0000000000000000000000000000000000000000;;				out, `%c%s="%s"`,
0000000000000000000000000000000000000000;;				separator, lp.GetName(), escapeString(lp.GetValue(), true),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			written += n
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return written, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			separator = ','
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if additionalLabelName != "" {
0000000000000000000000000000000000000000;;			n, err := fmt.Fprintf(
0000000000000000000000000000000000000000;;				out, `%c%s="%s"`,
0000000000000000000000000000000000000000;;				separator, additionalLabelName,
0000000000000000000000000000000000000000;;				escapeString(additionalLabelValue, true),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			written += n
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return written, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := out.Write([]byte{'}'})
0000000000000000000000000000000000000000;;		written += n
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return written, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return written, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		escape                = strings.NewReplacer("\\", `\\`, "\n", `\n`)
0000000000000000000000000000000000000000;;		escapeWithDoubleQuote = strings.NewReplacer("\\", `\\`, "\n", `\n`, "\"", `\"`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// escapeString replaces '\' by '\\', new line character by '\n', and - if
0000000000000000000000000000000000000000;;	// includeDoubleQuote is true - '"' by '\"'.
0000000000000000000000000000000000000000;;	func escapeString(v string, includeDoubleQuote bool) string {
0000000000000000000000000000000000000000;;		if includeDoubleQuote {
0000000000000000000000000000000000000000;;			return escapeWithDoubleQuote.Replace(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return escape.Replace(v)
0000000000000000000000000000000000000000;;	}
