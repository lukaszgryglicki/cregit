0000000000000000000000000000000000000000;;	// Copyright 2015 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
f7e1dc03448db9e2d7d0160d5b6aa202c60d79bc;Godeps/_workspace/src/github.com/prometheus/common/expfmt/decode.go[Godeps/_workspace/src/github.com/prometheus/common/expfmt/decode.go][vendor/github.com/prometheus/common/expfmt/decode.go];	
0000000000000000000000000000000000000000;;	package expfmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/matttproud/golang_protobuf_extensions/pbutil"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/model"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decoder types decode an input stream into metric families.
0000000000000000000000000000000000000000;;	type Decoder interface {
0000000000000000000000000000000000000000;;		Decode(*dto.MetricFamily) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeOptions contains options used by the Decoder and in sample extraction.
0000000000000000000000000000000000000000;;	type DecodeOptions struct {
0000000000000000000000000000000000000000;;		// Timestamp is added to each value from the stream that has no explicit timestamp set.
0000000000000000000000000000000000000000;;		Timestamp model.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResponseFormat extracts the correct format from a HTTP response header.
0000000000000000000000000000000000000000;;	// If no matching format can be found FormatUnknown is returned.
0000000000000000000000000000000000000000;;	func ResponseFormat(h http.Header) Format {
0000000000000000000000000000000000000000;;		ct := h.Get(hdrContentType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mediatype, params, err := mime.ParseMediaType(ct)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return FmtUnknown
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const textType = "text/plain"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch mediatype {
0000000000000000000000000000000000000000;;		case ProtoType:
0000000000000000000000000000000000000000;;			if p, ok := params["proto"]; ok && p != ProtoProtocol {
0000000000000000000000000000000000000000;;				return FmtUnknown
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, ok := params["encoding"]; ok && e != "delimited" {
0000000000000000000000000000000000000000;;				return FmtUnknown
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return FmtProtoDelim
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case textType:
0000000000000000000000000000000000000000;;			if v, ok := params["version"]; ok && v != TextVersion {
0000000000000000000000000000000000000000;;				return FmtUnknown
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return FmtText
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return FmtUnknown
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder returns a new decoder based on the given input format.
0000000000000000000000000000000000000000;;	// If the input format does not imply otherwise, a text format decoder is returned.
0000000000000000000000000000000000000000;;	func NewDecoder(r io.Reader, format Format) Decoder {
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case FmtProtoDelim:
0000000000000000000000000000000000000000;;			return &protoDecoder{r: r}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &textDecoder{r: r}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// protoDecoder implements the Decoder interface for protocol buffers.
0000000000000000000000000000000000000000;;	type protoDecoder struct {
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode implements the Decoder interface.
0000000000000000000000000000000000000000;;	func (d *protoDecoder) Decode(v *dto.MetricFamily) error {
0000000000000000000000000000000000000000;;		_, err := pbutil.ReadDelimited(d.r, v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !model.IsValidMetricName(model.LabelValue(v.GetName())) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid metric name %q", v.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, m := range v.GetMetric() {
0000000000000000000000000000000000000000;;			if m == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, l := range m.GetLabel() {
0000000000000000000000000000000000000000;;				if l == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !model.LabelValue(l.GetValue()).IsValid() {
0000000000000000000000000000000000000000;;					return fmt.Errorf("invalid label value %q", l.GetValue())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !model.LabelName(l.GetName()).IsValid() {
0000000000000000000000000000000000000000;;					return fmt.Errorf("invalid label name %q", l.GetName())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// textDecoder implements the Decoder interface for the text protocol.
0000000000000000000000000000000000000000;;	type textDecoder struct {
0000000000000000000000000000000000000000;;		r    io.Reader
0000000000000000000000000000000000000000;;		p    TextParser
0000000000000000000000000000000000000000;;		fams []*dto.MetricFamily
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode implements the Decoder interface.
0000000000000000000000000000000000000000;;	func (d *textDecoder) Decode(v *dto.MetricFamily) error {
0000000000000000000000000000000000000000;;		// TODO(fabxc): Wrap this as a line reader to make streaming safer.
0000000000000000000000000000000000000000;;		if len(d.fams) == 0 {
0000000000000000000000000000000000000000;;			// No cached metric families, read everything and parse metrics.
0000000000000000000000000000000000000000;;			fams, err := d.p.TextToMetricFamilies(d.r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(fams) == 0 {
0000000000000000000000000000000000000000;;				return io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.fams = make([]*dto.MetricFamily, 0, len(fams))
0000000000000000000000000000000000000000;;			for _, f := range fams {
0000000000000000000000000000000000000000;;				d.fams = append(d.fams, f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*v = *d.fams[0]
0000000000000000000000000000000000000000;;		d.fams = d.fams[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SampleDecoder wraps a Decoder to extract samples from the metric families
0000000000000000000000000000000000000000;;	// decoded by the wrapped Decoder.
0000000000000000000000000000000000000000;;	type SampleDecoder struct {
0000000000000000000000000000000000000000;;		Dec  Decoder
0000000000000000000000000000000000000000;;		Opts *DecodeOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f dto.MetricFamily
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode calls the Decode method of the wrapped Decoder and then extracts the
0000000000000000000000000000000000000000;;	// samples from the decoded MetricFamily into the provided model.Vector.
0000000000000000000000000000000000000000;;	func (sd *SampleDecoder) Decode(s *model.Vector) error {
0000000000000000000000000000000000000000;;		err := sd.Dec.Decode(&sd.f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*s, err = extractSamples(&sd.f, sd.Opts)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractSamples builds a slice of samples from the provided metric
0000000000000000000000000000000000000000;;	// families. If an error occurs during sample extraction, it continues to
0000000000000000000000000000000000000000;;	// extract from the remaining metric families. The returned error is the last
0000000000000000000000000000000000000000;;	// error that has occured.
0000000000000000000000000000000000000000;;	func ExtractSamples(o *DecodeOptions, fams ...*dto.MetricFamily) (model.Vector, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			all     model.Vector
0000000000000000000000000000000000000000;;			lastErr error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for _, f := range fams {
0000000000000000000000000000000000000000;;			some, err := extractSamples(f, o)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				lastErr = err
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			all = append(all, some...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return all, lastErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractSamples(f *dto.MetricFamily, o *DecodeOptions) (model.Vector, error) {
0000000000000000000000000000000000000000;;		switch f.GetType() {
0000000000000000000000000000000000000000;;		case dto.MetricType_COUNTER:
0000000000000000000000000000000000000000;;			return extractCounter(o, f), nil
0000000000000000000000000000000000000000;;		case dto.MetricType_GAUGE:
0000000000000000000000000000000000000000;;			return extractGauge(o, f), nil
0000000000000000000000000000000000000000;;		case dto.MetricType_SUMMARY:
0000000000000000000000000000000000000000;;			return extractSummary(o, f), nil
0000000000000000000000000000000000000000;;		case dto.MetricType_UNTYPED:
0000000000000000000000000000000000000000;;			return extractUntyped(o, f), nil
0000000000000000000000000000000000000000;;		case dto.MetricType_HISTOGRAM:
0000000000000000000000000000000000000000;;			return extractHistogram(o, f), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("expfmt.extractSamples: unknown metric family type %v", f.GetType())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractCounter(o *DecodeOptions, f *dto.MetricFamily) model.Vector {
0000000000000000000000000000000000000000;;		samples := make(model.Vector, 0, len(f.Metric))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range f.Metric {
0000000000000000000000000000000000000000;;			if m.Counter == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lset := make(model.LabelSet, len(m.Label)+1)
0000000000000000000000000000000000000000;;			for _, p := range m.Label {
0000000000000000000000000000000000000000;;				lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lset[model.MetricNameLabel] = model.LabelValue(f.GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			smpl := &model.Sample{
0000000000000000000000000000000000000000;;				Metric: model.Metric(lset),
0000000000000000000000000000000000000000;;				Value:  model.SampleValue(m.Counter.GetValue()),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m.TimestampMs != nil {
0000000000000000000000000000000000000000;;				smpl.Timestamp = model.TimeFromUnixNano(*m.TimestampMs * 1000000)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				smpl.Timestamp = o.Timestamp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			samples = append(samples, smpl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return samples
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractGauge(o *DecodeOptions, f *dto.MetricFamily) model.Vector {
0000000000000000000000000000000000000000;;		samples := make(model.Vector, 0, len(f.Metric))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range f.Metric {
0000000000000000000000000000000000000000;;			if m.Gauge == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lset := make(model.LabelSet, len(m.Label)+1)
0000000000000000000000000000000000000000;;			for _, p := range m.Label {
0000000000000000000000000000000000000000;;				lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lset[model.MetricNameLabel] = model.LabelValue(f.GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			smpl := &model.Sample{
0000000000000000000000000000000000000000;;				Metric: model.Metric(lset),
0000000000000000000000000000000000000000;;				Value:  model.SampleValue(m.Gauge.GetValue()),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m.TimestampMs != nil {
0000000000000000000000000000000000000000;;				smpl.Timestamp = model.TimeFromUnixNano(*m.TimestampMs * 1000000)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				smpl.Timestamp = o.Timestamp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			samples = append(samples, smpl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return samples
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractUntyped(o *DecodeOptions, f *dto.MetricFamily) model.Vector {
0000000000000000000000000000000000000000;;		samples := make(model.Vector, 0, len(f.Metric))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range f.Metric {
0000000000000000000000000000000000000000;;			if m.Untyped == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lset := make(model.LabelSet, len(m.Label)+1)
0000000000000000000000000000000000000000;;			for _, p := range m.Label {
0000000000000000000000000000000000000000;;				lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lset[model.MetricNameLabel] = model.LabelValue(f.GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			smpl := &model.Sample{
0000000000000000000000000000000000000000;;				Metric: model.Metric(lset),
0000000000000000000000000000000000000000;;				Value:  model.SampleValue(m.Untyped.GetValue()),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m.TimestampMs != nil {
0000000000000000000000000000000000000000;;				smpl.Timestamp = model.TimeFromUnixNano(*m.TimestampMs * 1000000)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				smpl.Timestamp = o.Timestamp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			samples = append(samples, smpl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return samples
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractSummary(o *DecodeOptions, f *dto.MetricFamily) model.Vector {
0000000000000000000000000000000000000000;;		samples := make(model.Vector, 0, len(f.Metric))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range f.Metric {
0000000000000000000000000000000000000000;;			if m.Summary == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			timestamp := o.Timestamp
0000000000000000000000000000000000000000;;			if m.TimestampMs != nil {
0000000000000000000000000000000000000000;;				timestamp = model.TimeFromUnixNano(*m.TimestampMs * 1000000)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, q := range m.Summary.Quantile {
0000000000000000000000000000000000000000;;				lset := make(model.LabelSet, len(m.Label)+2)
0000000000000000000000000000000000000000;;				for _, p := range m.Label {
0000000000000000000000000000000000000000;;					lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// BUG(matt): Update other names to "quantile".
0000000000000000000000000000000000000000;;				lset[model.LabelName(model.QuantileLabel)] = model.LabelValue(fmt.Sprint(q.GetQuantile()))
0000000000000000000000000000000000000000;;				lset[model.MetricNameLabel] = model.LabelValue(f.GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				samples = append(samples, &model.Sample{
0000000000000000000000000000000000000000;;					Metric:    model.Metric(lset),
0000000000000000000000000000000000000000;;					Value:     model.SampleValue(q.GetValue()),
0000000000000000000000000000000000000000;;					Timestamp: timestamp,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lset := make(model.LabelSet, len(m.Label)+1)
0000000000000000000000000000000000000000;;			for _, p := range m.Label {
0000000000000000000000000000000000000000;;				lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lset[model.MetricNameLabel] = model.LabelValue(f.GetName() + "_sum")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			samples = append(samples, &model.Sample{
0000000000000000000000000000000000000000;;				Metric:    model.Metric(lset),
0000000000000000000000000000000000000000;;				Value:     model.SampleValue(m.Summary.GetSampleSum()),
0000000000000000000000000000000000000000;;				Timestamp: timestamp,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lset = make(model.LabelSet, len(m.Label)+1)
0000000000000000000000000000000000000000;;			for _, p := range m.Label {
0000000000000000000000000000000000000000;;				lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lset[model.MetricNameLabel] = model.LabelValue(f.GetName() + "_count")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			samples = append(samples, &model.Sample{
0000000000000000000000000000000000000000;;				Metric:    model.Metric(lset),
0000000000000000000000000000000000000000;;				Value:     model.SampleValue(m.Summary.GetSampleCount()),
0000000000000000000000000000000000000000;;				Timestamp: timestamp,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return samples
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractHistogram(o *DecodeOptions, f *dto.MetricFamily) model.Vector {
0000000000000000000000000000000000000000;;		samples := make(model.Vector, 0, len(f.Metric))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range f.Metric {
0000000000000000000000000000000000000000;;			if m.Histogram == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			timestamp := o.Timestamp
0000000000000000000000000000000000000000;;			if m.TimestampMs != nil {
0000000000000000000000000000000000000000;;				timestamp = model.TimeFromUnixNano(*m.TimestampMs * 1000000)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			infSeen := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, q := range m.Histogram.Bucket {
0000000000000000000000000000000000000000;;				lset := make(model.LabelSet, len(m.Label)+2)
0000000000000000000000000000000000000000;;				for _, p := range m.Label {
0000000000000000000000000000000000000000;;					lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lset[model.LabelName(model.BucketLabel)] = model.LabelValue(fmt.Sprint(q.GetUpperBound()))
0000000000000000000000000000000000000000;;				lset[model.MetricNameLabel] = model.LabelValue(f.GetName() + "_bucket")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if math.IsInf(q.GetUpperBound(), +1) {
0000000000000000000000000000000000000000;;					infSeen = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				samples = append(samples, &model.Sample{
0000000000000000000000000000000000000000;;					Metric:    model.Metric(lset),
0000000000000000000000000000000000000000;;					Value:     model.SampleValue(q.GetCumulativeCount()),
0000000000000000000000000000000000000000;;					Timestamp: timestamp,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lset := make(model.LabelSet, len(m.Label)+1)
0000000000000000000000000000000000000000;;			for _, p := range m.Label {
0000000000000000000000000000000000000000;;				lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lset[model.MetricNameLabel] = model.LabelValue(f.GetName() + "_sum")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			samples = append(samples, &model.Sample{
0000000000000000000000000000000000000000;;				Metric:    model.Metric(lset),
0000000000000000000000000000000000000000;;				Value:     model.SampleValue(m.Histogram.GetSampleSum()),
0000000000000000000000000000000000000000;;				Timestamp: timestamp,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lset = make(model.LabelSet, len(m.Label)+1)
0000000000000000000000000000000000000000;;			for _, p := range m.Label {
0000000000000000000000000000000000000000;;				lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lset[model.MetricNameLabel] = model.LabelValue(f.GetName() + "_count")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			count := &model.Sample{
0000000000000000000000000000000000000000;;				Metric:    model.Metric(lset),
0000000000000000000000000000000000000000;;				Value:     model.SampleValue(m.Histogram.GetSampleCount()),
0000000000000000000000000000000000000000;;				Timestamp: timestamp,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			samples = append(samples, count)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !infSeen {
0000000000000000000000000000000000000000;;				// Append an infinity bucket sample.
0000000000000000000000000000000000000000;;				lset := make(model.LabelSet, len(m.Label)+2)
0000000000000000000000000000000000000000;;				for _, p := range m.Label {
0000000000000000000000000000000000000000;;					lset[model.LabelName(p.GetName())] = model.LabelValue(p.GetValue())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lset[model.LabelName(model.BucketLabel)] = model.LabelValue("+Inf")
0000000000000000000000000000000000000000;;				lset[model.MetricNameLabel] = model.LabelValue(f.GetName() + "_bucket")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				samples = append(samples, &model.Sample{
0000000000000000000000000000000000000000;;					Metric:    model.Metric(lset),
0000000000000000000000000000000000000000;;					Value:     count.Value,
0000000000000000000000000000000000000000;;					Timestamp: timestamp,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return samples
0000000000000000000000000000000000000000;;	}
