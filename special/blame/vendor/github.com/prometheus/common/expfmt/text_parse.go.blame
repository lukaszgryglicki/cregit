0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
f7e1dc03448db9e2d7d0160d5b6aa202c60d79bc;Godeps/_workspace/src/github.com/prometheus/common/expfmt/text_parse.go[Godeps/_workspace/src/github.com/prometheus/common/expfmt/text_parse.go][vendor/github.com/prometheus/common/expfmt/text_parse.go];	
0000000000000000000000000000000000000000;;	package expfmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dto "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/model"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A stateFn is a function that represents a state in a state machine. By
0000000000000000000000000000000000000000;;	// executing it, the state is progressed to the next state. The stateFn returns
0000000000000000000000000000000000000000;;	// another stateFn, which represents the new state. The end state is represented
0000000000000000000000000000000000000000;;	// by nil.
0000000000000000000000000000000000000000;;	type stateFn func() stateFn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseError signals errors while parsing the simple and flat text-based
0000000000000000000000000000000000000000;;	// exchange format.
0000000000000000000000000000000000000000;;	type ParseError struct {
0000000000000000000000000000000000000000;;		Line int
0000000000000000000000000000000000000000;;		Msg  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements the error interface.
0000000000000000000000000000000000000000;;	func (e ParseError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("text format parsing error in line %d: %s", e.Line, e.Msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TextParser is used to parse the simple and flat text-based exchange format. Its
0000000000000000000000000000000000000000;;	// zero value is ready to use.
0000000000000000000000000000000000000000;;	type TextParser struct {
0000000000000000000000000000000000000000;;		metricFamiliesByName map[string]*dto.MetricFamily
0000000000000000000000000000000000000000;;		buf                  *bufio.Reader // Where the parsed input is read through.
0000000000000000000000000000000000000000;;		err                  error         // Most recent error.
0000000000000000000000000000000000000000;;		lineCount            int           // Tracks the line count for error messages.
0000000000000000000000000000000000000000;;		currentByte          byte          // The most recent byte read.
0000000000000000000000000000000000000000;;		currentToken         bytes.Buffer  // Re-used each time a token has to be gathered from multiple bytes.
0000000000000000000000000000000000000000;;		currentMF            *dto.MetricFamily
0000000000000000000000000000000000000000;;		currentMetric        *dto.Metric
0000000000000000000000000000000000000000;;		currentLabelPair     *dto.LabelPair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The remaining member variables are only used for summaries/histograms.
0000000000000000000000000000000000000000;;		currentLabels map[string]string // All labels including '__name__' but excluding 'quantile'/'le'
0000000000000000000000000000000000000000;;		// Summary specific.
0000000000000000000000000000000000000000;;		summaries       map[uint64]*dto.Metric // Key is created with LabelsToSignature.
0000000000000000000000000000000000000000;;		currentQuantile float64
0000000000000000000000000000000000000000;;		// Histogram specific.
0000000000000000000000000000000000000000;;		histograms    map[uint64]*dto.Metric // Key is created with LabelsToSignature.
0000000000000000000000000000000000000000;;		currentBucket float64
0000000000000000000000000000000000000000;;		// These tell us if the currently processed line ends on '_count' or
0000000000000000000000000000000000000000;;		// '_sum' respectively and belong to a summary/histogram, representing the sample
0000000000000000000000000000000000000000;;		// count and sum of that summary/histogram.
0000000000000000000000000000000000000000;;		currentIsSummaryCount, currentIsSummarySum     bool
0000000000000000000000000000000000000000;;		currentIsHistogramCount, currentIsHistogramSum bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TextToMetricFamilies reads 'in' as the simple and flat text-based exchange
0000000000000000000000000000000000000000;;	// format and creates MetricFamily proto messages. It returns the MetricFamily
0000000000000000000000000000000000000000;;	// proto messages in a map where the metric names are the keys, along with any
0000000000000000000000000000000000000000;;	// error encountered.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the input contains duplicate metrics (i.e. lines with the same metric name
0000000000000000000000000000000000000000;;	// and exactly the same label set), the resulting MetricFamily will contain
0000000000000000000000000000000000000000;;	// duplicate Metric proto messages. Similar is true for duplicate label
0000000000000000000000000000000000000000;;	// names. Checks for duplicates have to be performed separately, if required.
0000000000000000000000000000000000000000;;	// Also note that neither the metrics within each MetricFamily are sorted nor
0000000000000000000000000000000000000000;;	// the label pairs within each Metric. Sorting is not required for the most
0000000000000000000000000000000000000000;;	// frequent use of this method, which is sample ingestion in the Prometheus
0000000000000000000000000000000000000000;;	// server. However, for presentation purposes, you might want to sort the
0000000000000000000000000000000000000000;;	// metrics, and in some cases, you must sort the labels, e.g. for consumption by
0000000000000000000000000000000000000000;;	// the metric family injection hook of the Prometheus registry.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Summaries and histograms are rather special beasts. You would probably not
0000000000000000000000000000000000000000;;	// use them in the simple text format anyway. This method can deal with
0000000000000000000000000000000000000000;;	// summaries and histograms if they are presented in exactly the way the
0000000000000000000000000000000000000000;;	// text.Create function creates them.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method must not be called concurrently. If you want to parse different
0000000000000000000000000000000000000000;;	// input concurrently, instantiate a separate Parser for each goroutine.
0000000000000000000000000000000000000000;;	func (p *TextParser) TextToMetricFamilies(in io.Reader) (map[string]*dto.MetricFamily, error) {
0000000000000000000000000000000000000000;;		p.reset(in)
0000000000000000000000000000000000000000;;		for nextState := p.startOfLine; nextState != nil; nextState = nextState() {
0000000000000000000000000000000000000000;;			// Magic happens here...
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get rid of empty metric families.
0000000000000000000000000000000000000000;;		for k, mf := range p.metricFamiliesByName {
0000000000000000000000000000000000000000;;			if len(mf.GetMetric()) == 0 {
0000000000000000000000000000000000000000;;				delete(p.metricFamiliesByName, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If p.err is io.EOF now, we have run into a premature end of the input
0000000000000000000000000000000000000000;;		// stream. Turn this error into something nicer and more
0000000000000000000000000000000000000000;;		// meaningful. (io.EOF is often used as a signal for the legitimate end
0000000000000000000000000000000000000000;;		// of an input stream.)
0000000000000000000000000000000000000000;;		if p.err == io.EOF {
0000000000000000000000000000000000000000;;			p.parseError("unexpected end of input stream")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.metricFamiliesByName, p.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *TextParser) reset(in io.Reader) {
0000000000000000000000000000000000000000;;		p.metricFamiliesByName = map[string]*dto.MetricFamily{}
0000000000000000000000000000000000000000;;		if p.buf == nil {
0000000000000000000000000000000000000000;;			p.buf = bufio.NewReader(in)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.buf.Reset(in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.err = nil
0000000000000000000000000000000000000000;;		p.lineCount = 0
0000000000000000000000000000000000000000;;		if p.summaries == nil || len(p.summaries) > 0 {
0000000000000000000000000000000000000000;;			p.summaries = map[uint64]*dto.Metric{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.histograms == nil || len(p.histograms) > 0 {
0000000000000000000000000000000000000000;;			p.histograms = map[uint64]*dto.Metric{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentQuantile = math.NaN()
0000000000000000000000000000000000000000;;		p.currentBucket = math.NaN()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startOfLine represents the state where the next byte read from p.buf is the
0000000000000000000000000000000000000000;;	// start of a line (or whitespace leading up to it).
0000000000000000000000000000000000000000;;	func (p *TextParser) startOfLine() stateFn {
0000000000000000000000000000000000000000;;		p.lineCount++
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			// End of input reached. This is the only case where
0000000000000000000000000000000000000000;;			// that is not an error but a signal that we are done.
0000000000000000000000000000000000000000;;			p.err = nil
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch p.currentByte {
0000000000000000000000000000000000000000;;		case '#':
0000000000000000000000000000000000000000;;			return p.startComment
0000000000000000000000000000000000000000;;		case '\n':
0000000000000000000000000000000000000000;;			return p.startOfLine // Empty line, start the next one.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.readingMetricName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startComment represents the state where the next byte read from p.buf is the
0000000000000000000000000000000000000000;;	// start of a comment (or whitespace leading up to it).
0000000000000000000000000000000000000000;;	func (p *TextParser) startComment() stateFn {
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte == '\n' {
0000000000000000000000000000000000000000;;			return p.startOfLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.readTokenUntilWhitespace(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we have hit the end of line already, there is nothing left
0000000000000000000000000000000000000000;;		// to do. This is not considered a syntax error.
0000000000000000000000000000000000000000;;		if p.currentByte == '\n' {
0000000000000000000000000000000000000000;;			return p.startOfLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyword := p.currentToken.String()
0000000000000000000000000000000000000000;;		if keyword != "HELP" && keyword != "TYPE" {
0000000000000000000000000000000000000000;;			// Generic comment, ignore by fast forwarding to end of line.
0000000000000000000000000000000000000000;;			for p.currentByte != '\n' {
0000000000000000000000000000000000000000;;				if p.currentByte, p.err = p.buf.ReadByte(); p.err != nil {
0000000000000000000000000000000000000000;;					return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.startOfLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// There is something. Next has to be a metric name.
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.readTokenAsMetricName(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte == '\n' {
0000000000000000000000000000000000000000;;			// At the end of the line already.
0000000000000000000000000000000000000000;;			// Again, this is not considered a syntax error.
0000000000000000000000000000000000000000;;			return p.startOfLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isBlankOrTab(p.currentByte) {
0000000000000000000000000000000000000000;;			p.parseError("invalid metric name in comment")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.setOrCreateCurrentMF()
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte == '\n' {
0000000000000000000000000000000000000000;;			// At the end of the line already.
0000000000000000000000000000000000000000;;			// Again, this is not considered a syntax error.
0000000000000000000000000000000000000000;;			return p.startOfLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch keyword {
0000000000000000000000000000000000000000;;		case "HELP":
0000000000000000000000000000000000000000;;			return p.readingHelp
0000000000000000000000000000000000000000;;		case "TYPE":
0000000000000000000000000000000000000000;;			return p.readingType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("code error: unexpected keyword %q", keyword))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readingMetricName represents the state where the last byte read (now in
0000000000000000000000000000000000000000;;	// p.currentByte) is the first byte of a metric name.
0000000000000000000000000000000000000000;;	func (p *TextParser) readingMetricName() stateFn {
0000000000000000000000000000000000000000;;		if p.readTokenAsMetricName(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentToken.Len() == 0 {
0000000000000000000000000000000000000000;;			p.parseError("invalid metric name")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.setOrCreateCurrentMF()
0000000000000000000000000000000000000000;;		// Now is the time to fix the type if it hasn't happened yet.
0000000000000000000000000000000000000000;;		if p.currentMF.Type == nil {
0000000000000000000000000000000000000000;;			p.currentMF.Type = dto.MetricType_UNTYPED.Enum()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentMetric = &dto.Metric{}
0000000000000000000000000000000000000000;;		// Do not append the newly created currentMetric to
0000000000000000000000000000000000000000;;		// currentMF.Metric right now. First wait if this is a summary,
0000000000000000000000000000000000000000;;		// and the metric exists already, which we can only know after
0000000000000000000000000000000000000000;;		// having read all the labels.
0000000000000000000000000000000000000000;;		if p.skipBlankTabIfCurrentBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.readingLabels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readingLabels represents the state where the last byte read (now in
0000000000000000000000000000000000000000;;	// p.currentByte) is either the first byte of the label set (i.e. a '{'), or the
0000000000000000000000000000000000000000;;	// first byte of the value (otherwise).
0000000000000000000000000000000000000000;;	func (p *TextParser) readingLabels() stateFn {
0000000000000000000000000000000000000000;;		// Summaries/histograms are special. We have to reset the
0000000000000000000000000000000000000000;;		// currentLabels map, currentQuantile and currentBucket before starting to
0000000000000000000000000000000000000000;;		// read labels.
0000000000000000000000000000000000000000;;		if p.currentMF.GetType() == dto.MetricType_SUMMARY || p.currentMF.GetType() == dto.MetricType_HISTOGRAM {
0000000000000000000000000000000000000000;;			p.currentLabels = map[string]string{}
0000000000000000000000000000000000000000;;			p.currentLabels[string(model.MetricNameLabel)] = p.currentMF.GetName()
0000000000000000000000000000000000000000;;			p.currentQuantile = math.NaN()
0000000000000000000000000000000000000000;;			p.currentBucket = math.NaN()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte != '{' {
0000000000000000000000000000000000000000;;			return p.readingValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.startLabelName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startLabelName represents the state where the next byte read from p.buf is
0000000000000000000000000000000000000000;;	// the start of a label name (or whitespace leading up to it).
0000000000000000000000000000000000000000;;	func (p *TextParser) startLabelName() stateFn {
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte == '}' {
0000000000000000000000000000000000000000;;			if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;				return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.readingValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.readTokenAsLabelName(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentToken.Len() == 0 {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("invalid label name for metric %q", p.currentMF.GetName()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentLabelPair = &dto.LabelPair{Name: proto.String(p.currentToken.String())}
0000000000000000000000000000000000000000;;		if p.currentLabelPair.GetName() == string(model.MetricNameLabel) {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("label name %q is reserved", model.MetricNameLabel))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Special summary/histogram treatment. Don't add 'quantile' and 'le'
0000000000000000000000000000000000000000;;		// labels to 'real' labels.
0000000000000000000000000000000000000000;;		if !(p.currentMF.GetType() == dto.MetricType_SUMMARY && p.currentLabelPair.GetName() == model.QuantileLabel) &&
0000000000000000000000000000000000000000;;			!(p.currentMF.GetType() == dto.MetricType_HISTOGRAM && p.currentLabelPair.GetName() == model.BucketLabel) {
0000000000000000000000000000000000000000;;			p.currentMetric.Label = append(p.currentMetric.Label, p.currentLabelPair)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.skipBlankTabIfCurrentBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte != '=' {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("expected '=' after label name, found %q", p.currentByte))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.startLabelValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startLabelValue represents the state where the next byte read from p.buf is
0000000000000000000000000000000000000000;;	// the start of a (quoted) label value (or whitespace leading up to it).
0000000000000000000000000000000000000000;;	func (p *TextParser) startLabelValue() stateFn {
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte != '"' {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("expected '\"' at start of label value, found %q", p.currentByte))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.readTokenAsLabelValue(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentLabelPair.Value = proto.String(p.currentToken.String())
0000000000000000000000000000000000000000;;		// Special treatment of summaries:
0000000000000000000000000000000000000000;;		// - Quantile labels are special, will result in dto.Quantile later.
0000000000000000000000000000000000000000;;		// - Other labels have to be added to currentLabels for signature calculation.
0000000000000000000000000000000000000000;;		if p.currentMF.GetType() == dto.MetricType_SUMMARY {
0000000000000000000000000000000000000000;;			if p.currentLabelPair.GetName() == model.QuantileLabel {
0000000000000000000000000000000000000000;;				if p.currentQuantile, p.err = strconv.ParseFloat(p.currentLabelPair.GetValue(), 64); p.err != nil {
0000000000000000000000000000000000000000;;					// Create a more helpful error message.
0000000000000000000000000000000000000000;;					p.parseError(fmt.Sprintf("expected float as value for 'quantile' label, got %q", p.currentLabelPair.GetValue()))
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.currentLabels[p.currentLabelPair.GetName()] = p.currentLabelPair.GetValue()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Similar special treatment of histograms.
0000000000000000000000000000000000000000;;		if p.currentMF.GetType() == dto.MetricType_HISTOGRAM {
0000000000000000000000000000000000000000;;			if p.currentLabelPair.GetName() == model.BucketLabel {
0000000000000000000000000000000000000000;;				if p.currentBucket, p.err = strconv.ParseFloat(p.currentLabelPair.GetValue(), 64); p.err != nil {
0000000000000000000000000000000000000000;;					// Create a more helpful error message.
0000000000000000000000000000000000000000;;					p.parseError(fmt.Sprintf("expected float as value for 'le' label, got %q", p.currentLabelPair.GetValue()))
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.currentLabels[p.currentLabelPair.GetName()] = p.currentLabelPair.GetValue()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch p.currentByte {
0000000000000000000000000000000000000000;;		case ',':
0000000000000000000000000000000000000000;;			return p.startLabelName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case '}':
0000000000000000000000000000000000000000;;			if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;				return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.readingValue
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("unexpected end of label value %q", p.currentLabelPair.Value))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readingValue represents the state where the last byte read (now in
0000000000000000000000000000000000000000;;	// p.currentByte) is the first byte of the sample value (i.e. a float).
0000000000000000000000000000000000000000;;	func (p *TextParser) readingValue() stateFn {
0000000000000000000000000000000000000000;;		// When we are here, we have read all the labels, so for the
0000000000000000000000000000000000000000;;		// special case of a summary/histogram, we can finally find out
0000000000000000000000000000000000000000;;		// if the metric already exists.
0000000000000000000000000000000000000000;;		if p.currentMF.GetType() == dto.MetricType_SUMMARY {
0000000000000000000000000000000000000000;;			signature := model.LabelsToSignature(p.currentLabels)
0000000000000000000000000000000000000000;;			if summary := p.summaries[signature]; summary != nil {
0000000000000000000000000000000000000000;;				p.currentMetric = summary
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.summaries[signature] = p.currentMetric
0000000000000000000000000000000000000000;;				p.currentMF.Metric = append(p.currentMF.Metric, p.currentMetric)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if p.currentMF.GetType() == dto.MetricType_HISTOGRAM {
0000000000000000000000000000000000000000;;			signature := model.LabelsToSignature(p.currentLabels)
0000000000000000000000000000000000000000;;			if histogram := p.histograms[signature]; histogram != nil {
0000000000000000000000000000000000000000;;				p.currentMetric = histogram
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.histograms[signature] = p.currentMetric
0000000000000000000000000000000000000000;;				p.currentMF.Metric = append(p.currentMF.Metric, p.currentMetric)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.currentMF.Metric = append(p.currentMF.Metric, p.currentMetric)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.readTokenUntilWhitespace(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value, err := strconv.ParseFloat(p.currentToken.String(), 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Create a more helpful error message.
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("expected float as value, got %q", p.currentToken.String()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch p.currentMF.GetType() {
0000000000000000000000000000000000000000;;		case dto.MetricType_COUNTER:
0000000000000000000000000000000000000000;;			p.currentMetric.Counter = &dto.Counter{Value: proto.Float64(value)}
0000000000000000000000000000000000000000;;		case dto.MetricType_GAUGE:
0000000000000000000000000000000000000000;;			p.currentMetric.Gauge = &dto.Gauge{Value: proto.Float64(value)}
0000000000000000000000000000000000000000;;		case dto.MetricType_UNTYPED:
0000000000000000000000000000000000000000;;			p.currentMetric.Untyped = &dto.Untyped{Value: proto.Float64(value)}
0000000000000000000000000000000000000000;;		case dto.MetricType_SUMMARY:
0000000000000000000000000000000000000000;;			// *sigh*
0000000000000000000000000000000000000000;;			if p.currentMetric.Summary == nil {
0000000000000000000000000000000000000000;;				p.currentMetric.Summary = &dto.Summary{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case p.currentIsSummaryCount:
0000000000000000000000000000000000000000;;				p.currentMetric.Summary.SampleCount = proto.Uint64(uint64(value))
0000000000000000000000000000000000000000;;			case p.currentIsSummarySum:
0000000000000000000000000000000000000000;;				p.currentMetric.Summary.SampleSum = proto.Float64(value)
0000000000000000000000000000000000000000;;			case !math.IsNaN(p.currentQuantile):
0000000000000000000000000000000000000000;;				p.currentMetric.Summary.Quantile = append(
0000000000000000000000000000000000000000;;					p.currentMetric.Summary.Quantile,
0000000000000000000000000000000000000000;;					&dto.Quantile{
0000000000000000000000000000000000000000;;						Quantile: proto.Float64(p.currentQuantile),
0000000000000000000000000000000000000000;;						Value:    proto.Float64(value),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case dto.MetricType_HISTOGRAM:
0000000000000000000000000000000000000000;;			// *sigh*
0000000000000000000000000000000000000000;;			if p.currentMetric.Histogram == nil {
0000000000000000000000000000000000000000;;				p.currentMetric.Histogram = &dto.Histogram{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case p.currentIsHistogramCount:
0000000000000000000000000000000000000000;;				p.currentMetric.Histogram.SampleCount = proto.Uint64(uint64(value))
0000000000000000000000000000000000000000;;			case p.currentIsHistogramSum:
0000000000000000000000000000000000000000;;				p.currentMetric.Histogram.SampleSum = proto.Float64(value)
0000000000000000000000000000000000000000;;			case !math.IsNaN(p.currentBucket):
0000000000000000000000000000000000000000;;				p.currentMetric.Histogram.Bucket = append(
0000000000000000000000000000000000000000;;					p.currentMetric.Histogram.Bucket,
0000000000000000000000000000000000000000;;					&dto.Bucket{
0000000000000000000000000000000000000000;;						UpperBound:      proto.Float64(p.currentBucket),
0000000000000000000000000000000000000000;;						CumulativeCount: proto.Uint64(uint64(value)),
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			p.err = fmt.Errorf("unexpected type for metric name %q", p.currentMF.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentByte == '\n' {
0000000000000000000000000000000000000000;;			return p.startOfLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.startTimestamp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startTimestamp represents the state where the next byte read from p.buf is
0000000000000000000000000000000000000000;;	// the start of the timestamp (or whitespace leading up to it).
0000000000000000000000000000000000000000;;	func (p *TextParser) startTimestamp() stateFn {
0000000000000000000000000000000000000000;;		if p.skipBlankTab(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.readTokenUntilWhitespace(); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timestamp, err := strconv.ParseInt(p.currentToken.String(), 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Create a more helpful error message.
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("expected integer as timestamp, got %q", p.currentToken.String()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentMetric.TimestampMs = proto.Int64(timestamp)
0000000000000000000000000000000000000000;;		if p.readTokenUntilNewline(false); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.currentToken.Len() > 0 {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("spurious string after timestamp: %q", p.currentToken.String()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.startOfLine
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readingHelp represents the state where the last byte read (now in
0000000000000000000000000000000000000000;;	// p.currentByte) is the first byte of the docstring after 'HELP'.
0000000000000000000000000000000000000000;;	func (p *TextParser) readingHelp() stateFn {
0000000000000000000000000000000000000000;;		if p.currentMF.Help != nil {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("second HELP line for metric name %q", p.currentMF.GetName()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Rest of line is the docstring.
0000000000000000000000000000000000000000;;		if p.readTokenUntilNewline(true); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentMF.Help = proto.String(p.currentToken.String())
0000000000000000000000000000000000000000;;		return p.startOfLine
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readingType represents the state where the last byte read (now in
0000000000000000000000000000000000000000;;	// p.currentByte) is the first byte of the type hint after 'HELP'.
0000000000000000000000000000000000000000;;	func (p *TextParser) readingType() stateFn {
0000000000000000000000000000000000000000;;		if p.currentMF.Type != nil {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("second TYPE line for metric name %q, or TYPE reported after samples", p.currentMF.GetName()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Rest of line is the type.
0000000000000000000000000000000000000000;;		if p.readTokenUntilNewline(false); p.err != nil {
0000000000000000000000000000000000000000;;			return nil // Unexpected end of input.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metricType, ok := dto.MetricType_value[strings.ToUpper(p.currentToken.String())]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			p.parseError(fmt.Sprintf("unknown metric type %q", p.currentToken.String()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentMF.Type = dto.MetricType(metricType).Enum()
0000000000000000000000000000000000000000;;		return p.startOfLine
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseError sets p.err to a ParseError at the current line with the given
0000000000000000000000000000000000000000;;	// message.
0000000000000000000000000000000000000000;;	func (p *TextParser) parseError(msg string) {
0000000000000000000000000000000000000000;;		p.err = ParseError{
0000000000000000000000000000000000000000;;			Line: p.lineCount,
0000000000000000000000000000000000000000;;			Msg:  msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// skipBlankTab reads (and discards) bytes from p.buf until it encounters a byte
0000000000000000000000000000000000000000;;	// that is neither ' ' nor '\t'. That byte is left in p.currentByte.
0000000000000000000000000000000000000000;;	func (p *TextParser) skipBlankTab() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if p.currentByte, p.err = p.buf.ReadByte(); p.err != nil || !isBlankOrTab(p.currentByte) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// skipBlankTabIfCurrentBlankTab works exactly as skipBlankTab but doesn't do
0000000000000000000000000000000000000000;;	// anything if p.currentByte is neither ' ' nor '\t'.
0000000000000000000000000000000000000000;;	func (p *TextParser) skipBlankTabIfCurrentBlankTab() {
0000000000000000000000000000000000000000;;		if isBlankOrTab(p.currentByte) {
0000000000000000000000000000000000000000;;			p.skipBlankTab()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTokenUntilWhitespace copies bytes from p.buf into p.currentToken.  The
0000000000000000000000000000000000000000;;	// first byte considered is the byte already read (now in p.currentByte).  The
0000000000000000000000000000000000000000;;	// first whitespace byte encountered is still copied into p.currentByte, but not
0000000000000000000000000000000000000000;;	// into p.currentToken.
0000000000000000000000000000000000000000;;	func (p *TextParser) readTokenUntilWhitespace() {
0000000000000000000000000000000000000000;;		p.currentToken.Reset()
0000000000000000000000000000000000000000;;		for p.err == nil && !isBlankOrTab(p.currentByte) && p.currentByte != '\n' {
0000000000000000000000000000000000000000;;			p.currentToken.WriteByte(p.currentByte)
0000000000000000000000000000000000000000;;			p.currentByte, p.err = p.buf.ReadByte()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTokenUntilNewline copies bytes from p.buf into p.currentToken.  The first
0000000000000000000000000000000000000000;;	// byte considered is the byte already read (now in p.currentByte).  The first
0000000000000000000000000000000000000000;;	// newline byte encountered is still copied into p.currentByte, but not into
0000000000000000000000000000000000000000;;	// p.currentToken. If recognizeEscapeSequence is true, two escape sequences are
0000000000000000000000000000000000000000;;	// recognized: '\\' tranlates into '\', and '\n' into a line-feed character. All
0000000000000000000000000000000000000000;;	// other escape sequences are invalid and cause an error.
0000000000000000000000000000000000000000;;	func (p *TextParser) readTokenUntilNewline(recognizeEscapeSequence bool) {
0000000000000000000000000000000000000000;;		p.currentToken.Reset()
0000000000000000000000000000000000000000;;		escaped := false
0000000000000000000000000000000000000000;;		for p.err == nil {
0000000000000000000000000000000000000000;;			if recognizeEscapeSequence && escaped {
0000000000000000000000000000000000000000;;				switch p.currentByte {
0000000000000000000000000000000000000000;;				case '\\':
0000000000000000000000000000000000000000;;					p.currentToken.WriteByte(p.currentByte)
0000000000000000000000000000000000000000;;				case 'n':
0000000000000000000000000000000000000000;;					p.currentToken.WriteByte('\n')
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					p.parseError(fmt.Sprintf("invalid escape sequence '\\%c'", p.currentByte))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				escaped = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch p.currentByte {
0000000000000000000000000000000000000000;;				case '\n':
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case '\\':
0000000000000000000000000000000000000000;;					escaped = true
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					p.currentToken.WriteByte(p.currentByte)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.currentByte, p.err = p.buf.ReadByte()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTokenAsMetricName copies a metric name from p.buf into p.currentToken.
0000000000000000000000000000000000000000;;	// The first byte considered is the byte already read (now in p.currentByte).
0000000000000000000000000000000000000000;;	// The first byte not part of a metric name is still copied into p.currentByte,
0000000000000000000000000000000000000000;;	// but not into p.currentToken.
0000000000000000000000000000000000000000;;	func (p *TextParser) readTokenAsMetricName() {
0000000000000000000000000000000000000000;;		p.currentToken.Reset()
0000000000000000000000000000000000000000;;		if !isValidMetricNameStart(p.currentByte) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			p.currentToken.WriteByte(p.currentByte)
0000000000000000000000000000000000000000;;			p.currentByte, p.err = p.buf.ReadByte()
0000000000000000000000000000000000000000;;			if p.err != nil || !isValidMetricNameContinuation(p.currentByte) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTokenAsLabelName copies a label name from p.buf into p.currentToken.
0000000000000000000000000000000000000000;;	// The first byte considered is the byte already read (now in p.currentByte).
0000000000000000000000000000000000000000;;	// The first byte not part of a label name is still copied into p.currentByte,
0000000000000000000000000000000000000000;;	// but not into p.currentToken.
0000000000000000000000000000000000000000;;	func (p *TextParser) readTokenAsLabelName() {
0000000000000000000000000000000000000000;;		p.currentToken.Reset()
0000000000000000000000000000000000000000;;		if !isValidLabelNameStart(p.currentByte) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			p.currentToken.WriteByte(p.currentByte)
0000000000000000000000000000000000000000;;			p.currentByte, p.err = p.buf.ReadByte()
0000000000000000000000000000000000000000;;			if p.err != nil || !isValidLabelNameContinuation(p.currentByte) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTokenAsLabelValue copies a label value from p.buf into p.currentToken.
0000000000000000000000000000000000000000;;	// In contrast to the other 'readTokenAs...' functions, which start with the
0000000000000000000000000000000000000000;;	// last read byte in p.currentByte, this method ignores p.currentByte and starts
0000000000000000000000000000000000000000;;	// with reading a new byte from p.buf. The first byte not part of a label value
0000000000000000000000000000000000000000;;	// is still copied into p.currentByte, but not into p.currentToken.
0000000000000000000000000000000000000000;;	func (p *TextParser) readTokenAsLabelValue() {
0000000000000000000000000000000000000000;;		p.currentToken.Reset()
0000000000000000000000000000000000000000;;		escaped := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if p.currentByte, p.err = p.buf.ReadByte(); p.err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if escaped {
0000000000000000000000000000000000000000;;				switch p.currentByte {
0000000000000000000000000000000000000000;;				case '"', '\\':
0000000000000000000000000000000000000000;;					p.currentToken.WriteByte(p.currentByte)
0000000000000000000000000000000000000000;;				case 'n':
0000000000000000000000000000000000000000;;					p.currentToken.WriteByte('\n')
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					p.parseError(fmt.Sprintf("invalid escape sequence '\\%c'", p.currentByte))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				escaped = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch p.currentByte {
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				p.parseError(fmt.Sprintf("label value %q contains unescaped new-line", p.currentToken.String()))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				escaped = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				p.currentToken.WriteByte(p.currentByte)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *TextParser) setOrCreateCurrentMF() {
0000000000000000000000000000000000000000;;		p.currentIsSummaryCount = false
0000000000000000000000000000000000000000;;		p.currentIsSummarySum = false
0000000000000000000000000000000000000000;;		p.currentIsHistogramCount = false
0000000000000000000000000000000000000000;;		p.currentIsHistogramSum = false
0000000000000000000000000000000000000000;;		name := p.currentToken.String()
0000000000000000000000000000000000000000;;		if p.currentMF = p.metricFamiliesByName[name]; p.currentMF != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Try out if this is a _sum or _count for a summary/histogram.
0000000000000000000000000000000000000000;;		summaryName := summaryMetricName(name)
0000000000000000000000000000000000000000;;		if p.currentMF = p.metricFamiliesByName[summaryName]; p.currentMF != nil {
0000000000000000000000000000000000000000;;			if p.currentMF.GetType() == dto.MetricType_SUMMARY {
0000000000000000000000000000000000000000;;				if isCount(name) {
0000000000000000000000000000000000000000;;					p.currentIsSummaryCount = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isSum(name) {
0000000000000000000000000000000000000000;;					p.currentIsSummarySum = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		histogramName := histogramMetricName(name)
0000000000000000000000000000000000000000;;		if p.currentMF = p.metricFamiliesByName[histogramName]; p.currentMF != nil {
0000000000000000000000000000000000000000;;			if p.currentMF.GetType() == dto.MetricType_HISTOGRAM {
0000000000000000000000000000000000000000;;				if isCount(name) {
0000000000000000000000000000000000000000;;					p.currentIsHistogramCount = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isSum(name) {
0000000000000000000000000000000000000000;;					p.currentIsHistogramSum = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentMF = &dto.MetricFamily{Name: proto.String(name)}
0000000000000000000000000000000000000000;;		p.metricFamiliesByName[name] = p.currentMF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isValidLabelNameStart(b byte) bool {
0000000000000000000000000000000000000000;;		return (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || b == '_'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isValidLabelNameContinuation(b byte) bool {
0000000000000000000000000000000000000000;;		return isValidLabelNameStart(b) || (b >= '0' && b <= '9')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isValidMetricNameStart(b byte) bool {
0000000000000000000000000000000000000000;;		return isValidLabelNameStart(b) || b == ':'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isValidMetricNameContinuation(b byte) bool {
0000000000000000000000000000000000000000;;		return isValidLabelNameContinuation(b) || b == ':'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isBlankOrTab(b byte) bool {
0000000000000000000000000000000000000000;;		return b == ' ' || b == '\t'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isCount(name string) bool {
0000000000000000000000000000000000000000;;		return len(name) > 6 && name[len(name)-6:] == "_count"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSum(name string) bool {
0000000000000000000000000000000000000000;;		return len(name) > 4 && name[len(name)-4:] == "_sum"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isBucket(name string) bool {
0000000000000000000000000000000000000000;;		return len(name) > 7 && name[len(name)-7:] == "_bucket"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func summaryMetricName(name string) string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isCount(name):
0000000000000000000000000000000000000000;;			return name[:len(name)-6]
0000000000000000000000000000000000000000;;		case isSum(name):
0000000000000000000000000000000000000000;;			return name[:len(name)-4]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func histogramMetricName(name string) string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isCount(name):
0000000000000000000000000000000000000000;;			return name[:len(name)-6]
0000000000000000000000000000000000000000;;		case isSum(name):
0000000000000000000000000000000000000000;;			return name[:len(name)-4]
0000000000000000000000000000000000000000;;		case isBucket(name):
0000000000000000000000000000000000000000;;			return name[:len(name)-7]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
