0000000000000000000000000000000000000000;;	// Copyright 2013 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b86cc30ece6ecc0d16bd8e3af4be75b963154490;Godeps/_workspace/src/github.com/prometheus/common/model/time.go[Godeps/_workspace/src/github.com/prometheus/common/model/time.go][vendor/github.com/prometheus/common/model/time.go];	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// MinimumTick is the minimum supported time resolution. This has to be
0000000000000000000000000000000000000000;;		// at least time.Second in order for the code below to work.
0000000000000000000000000000000000000000;;		minimumTick = time.Millisecond
0000000000000000000000000000000000000000;;		// second is the Time duration equivalent to one second.
0000000000000000000000000000000000000000;;		second = int64(time.Second / minimumTick)
0000000000000000000000000000000000000000;;		// The number of nanoseconds per minimum tick.
0000000000000000000000000000000000000000;;		nanosPerTick = int64(minimumTick / time.Nanosecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Earliest is the earliest Time representable. Handy for
0000000000000000000000000000000000000000;;		// initializing a high watermark.
0000000000000000000000000000000000000000;;		Earliest = Time(math.MinInt64)
0000000000000000000000000000000000000000;;		// Latest is the latest Time representable. Handy for initializing
0000000000000000000000000000000000000000;;		// a low watermark.
0000000000000000000000000000000000000000;;		Latest = Time(math.MaxInt64)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time is the number of milliseconds since the epoch
0000000000000000000000000000000000000000;;	// (1970-01-01 00:00 UTC) excluding leap seconds.
0000000000000000000000000000000000000000;;	type Time int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interval describes and interval between two timestamps.
0000000000000000000000000000000000000000;;	type Interval struct {
0000000000000000000000000000000000000000;;		Start, End Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now returns the current time as a Time.
0000000000000000000000000000000000000000;;	func Now() Time {
0000000000000000000000000000000000000000;;		return TimeFromUnixNano(time.Now().UnixNano())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeFromUnix returns the Time equivalent to the Unix Time t
0000000000000000000000000000000000000000;;	// provided in seconds.
0000000000000000000000000000000000000000;;	func TimeFromUnix(t int64) Time {
0000000000000000000000000000000000000000;;		return Time(t * second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeFromUnixNano returns the Time equivalent to the Unix Time
0000000000000000000000000000000000000000;;	// t provided in nanoseconds.
0000000000000000000000000000000000000000;;	func TimeFromUnixNano(t int64) Time {
0000000000000000000000000000000000000000;;		return Time(t / nanosPerTick)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal reports whether two Times represent the same instant.
0000000000000000000000000000000000000000;;	func (t Time) Equal(o Time) bool {
0000000000000000000000000000000000000000;;		return t == o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Before reports whether the Time t is before o.
0000000000000000000000000000000000000000;;	func (t Time) Before(o Time) bool {
0000000000000000000000000000000000000000;;		return t < o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// After reports whether the Time t is after o.
0000000000000000000000000000000000000000;;	func (t Time) After(o Time) bool {
0000000000000000000000000000000000000000;;		return t > o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add returns the Time t + d.
0000000000000000000000000000000000000000;;	func (t Time) Add(d time.Duration) Time {
0000000000000000000000000000000000000000;;		return t + Time(d/minimumTick)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sub returns the Duration t - o.
0000000000000000000000000000000000000000;;	func (t Time) Sub(o Time) time.Duration {
0000000000000000000000000000000000000000;;		return time.Duration(t-o) * minimumTick
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time returns the time.Time representation of t.
0000000000000000000000000000000000000000;;	func (t Time) Time() time.Time {
0000000000000000000000000000000000000000;;		return time.Unix(int64(t)/second, (int64(t)%second)*nanosPerTick)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unix returns t as a Unix time, the number of seconds elapsed
0000000000000000000000000000000000000000;;	// since January 1, 1970 UTC.
0000000000000000000000000000000000000000;;	func (t Time) Unix() int64 {
0000000000000000000000000000000000000000;;		return int64(t) / second
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnixNano returns t as a Unix time, the number of nanoseconds elapsed
0000000000000000000000000000000000000000;;	// since January 1, 1970 UTC.
0000000000000000000000000000000000000000;;	func (t Time) UnixNano() int64 {
0000000000000000000000000000000000000000;;		return int64(t) * nanosPerTick
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The number of digits after the dot.
0000000000000000000000000000000000000000;;	var dotPrecision = int(math.Log10(float64(second)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of the Time.
0000000000000000000000000000000000000000;;	func (t Time) String() string {
0000000000000000000000000000000000000000;;		return strconv.FormatFloat(float64(t)/float64(second), 'f', -1, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaler interface.
0000000000000000000000000000000000000000;;	func (t Time) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return []byte(t.String()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaler interface.
0000000000000000000000000000000000000000;;	func (t *Time) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		p := strings.Split(string(b), ".")
0000000000000000000000000000000000000000;;		switch len(p) {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			v, err := strconv.ParseInt(string(p[0]), 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*t = Time(v * second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			v, err := strconv.ParseInt(string(p[0]), 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v *= second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			prec := dotPrecision - len(p[1])
0000000000000000000000000000000000000000;;			if prec < 0 {
0000000000000000000000000000000000000000;;				p[1] = p[1][:dotPrecision]
0000000000000000000000000000000000000000;;			} else if prec > 0 {
0000000000000000000000000000000000000000;;				p[1] = p[1] + strings.Repeat("0", prec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			va, err := strconv.ParseInt(p[1], 10, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*t = Time(v + va)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid time %q", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Duration wraps time.Duration. It is used to parse the custom duration format
0000000000000000000000000000000000000000;;	// from YAML.
0000000000000000000000000000000000000000;;	// This type should not propagate beyond the scope of input/output processing.
0000000000000000000000000000000000000000;;	type Duration time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var durationRE = regexp.MustCompile("^([0-9]+)(y|w|d|h|m|s|ms)$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToDuration parses a string into a time.Duration, assuming that a year
0000000000000000000000000000000000000000;;	// always has 365d, a week always has 7d, and a day always has 24h.
0000000000000000000000000000000000000000;;	func ParseDuration(durationStr string) (Duration, error) {
0000000000000000000000000000000000000000;;		matches := durationRE.FindStringSubmatch(durationStr)
0000000000000000000000000000000000000000;;		if len(matches) != 3 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("not a valid duration string: %q", durationStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			n, _ = strconv.Atoi(matches[1])
0000000000000000000000000000000000000000;;			dur  = time.Duration(n) * time.Millisecond
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		switch unit := matches[2]; unit {
0000000000000000000000000000000000000000;;		case "y":
0000000000000000000000000000000000000000;;			dur *= 1000 * 60 * 60 * 24 * 365
0000000000000000000000000000000000000000;;		case "w":
0000000000000000000000000000000000000000;;			dur *= 1000 * 60 * 60 * 24 * 7
0000000000000000000000000000000000000000;;		case "d":
0000000000000000000000000000000000000000;;			dur *= 1000 * 60 * 60 * 24
0000000000000000000000000000000000000000;;		case "h":
0000000000000000000000000000000000000000;;			dur *= 1000 * 60 * 60
0000000000000000000000000000000000000000;;		case "m":
0000000000000000000000000000000000000000;;			dur *= 1000 * 60
0000000000000000000000000000000000000000;;		case "s":
0000000000000000000000000000000000000000;;			dur *= 1000
0000000000000000000000000000000000000000;;		case "ms":
0000000000000000000000000000000000000000;;			// Value already correct
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid time unit in duration string: %q", unit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Duration(dur), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Duration) String() string {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			ms   = int64(time.Duration(d) / time.Millisecond)
0000000000000000000000000000000000000000;;			unit = "ms"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		factors := map[string]int64{
0000000000000000000000000000000000000000;;			"y":  1000 * 60 * 60 * 24 * 365,
0000000000000000000000000000000000000000;;			"w":  1000 * 60 * 60 * 24 * 7,
0000000000000000000000000000000000000000;;			"d":  1000 * 60 * 60 * 24,
0000000000000000000000000000000000000000;;			"h":  1000 * 60 * 60,
0000000000000000000000000000000000000000;;			"m":  1000 * 60,
0000000000000000000000000000000000000000;;			"s":  1000,
0000000000000000000000000000000000000000;;			"ms": 1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch int64(0) {
0000000000000000000000000000000000000000;;		case ms % factors["y"]:
0000000000000000000000000000000000000000;;			unit = "y"
0000000000000000000000000000000000000000;;		case ms % factors["w"]:
0000000000000000000000000000000000000000;;			unit = "w"
0000000000000000000000000000000000000000;;		case ms % factors["d"]:
0000000000000000000000000000000000000000;;			unit = "d"
0000000000000000000000000000000000000000;;		case ms % factors["h"]:
0000000000000000000000000000000000000000;;			unit = "h"
0000000000000000000000000000000000000000;;		case ms % factors["m"]:
0000000000000000000000000000000000000000;;			unit = "m"
0000000000000000000000000000000000000000;;		case ms % factors["s"]:
0000000000000000000000000000000000000000;;			unit = "s"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v%v", ms/factors[unit], unit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalYAML implements the yaml.Marshaler interface.
0000000000000000000000000000000000000000;;	func (d Duration) MarshalYAML() (interface{}, error) {
0000000000000000000000000000000000000000;;		return d.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalYAML implements the yaml.Unmarshaler interface.
0000000000000000000000000000000000000000;;	func (d *Duration) UnmarshalYAML(unmarshal func(interface{}) error) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := unmarshal(&s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dur, err := ParseDuration(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*d = dur
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
