0000000000000000000000000000000000000000;;	// Copyright 2013 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
f7e1dc03448db9e2d7d0160d5b6aa202c60d79bc;Godeps/_workspace/src/github.com/prometheus/common/model/metric.go[Godeps/_workspace/src/github.com/prometheus/common/model/metric.go][vendor/github.com/prometheus/common/model/metric.go];	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		separator = []byte{0}
0000000000000000000000000000000000000000;;		// MetricNameRE is a regular expression matching valid metric
0000000000000000000000000000000000000000;;		// names. Note that the IsValidMetricName function performs the same
0000000000000000000000000000000000000000;;		// check but faster than a match with this regular expression.
0000000000000000000000000000000000000000;;		MetricNameRE = regexp.MustCompile(`^[a-zA-Z_:][a-zA-Z0-9_:]*$`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Metric is similar to a LabelSet, but the key difference is that a Metric is
0000000000000000000000000000000000000000;;	// a singleton and refers to one and only one stream of samples.
0000000000000000000000000000000000000000;;	type Metric LabelSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal compares the metrics.
0000000000000000000000000000000000000000;;	func (m Metric) Equal(o Metric) bool {
0000000000000000000000000000000000000000;;		return LabelSet(m).Equal(LabelSet(o))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Before compares the metrics' underlying label sets.
0000000000000000000000000000000000000000;;	func (m Metric) Before(o Metric) bool {
0000000000000000000000000000000000000000;;		return LabelSet(m).Before(LabelSet(o))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clone returns a copy of the Metric.
0000000000000000000000000000000000000000;;	func (m Metric) Clone() Metric {
0000000000000000000000000000000000000000;;		clone := make(Metric, len(m))
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			clone[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m Metric) String() string {
0000000000000000000000000000000000000000;;		metricName, hasName := m[MetricNameLabel]
0000000000000000000000000000000000000000;;		numLabels := len(m) - 1
0000000000000000000000000000000000000000;;		if !hasName {
0000000000000000000000000000000000000000;;			numLabels = len(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labelStrings := make([]string, 0, numLabels)
0000000000000000000000000000000000000000;;		for label, value := range m {
0000000000000000000000000000000000000000;;			if label != MetricNameLabel {
0000000000000000000000000000000000000000;;				labelStrings = append(labelStrings, fmt.Sprintf("%s=%q", label, value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch numLabels {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			if hasName {
0000000000000000000000000000000000000000;;				return string(metricName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "{}"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			sort.Strings(labelStrings)
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s{%s}", metricName, strings.Join(labelStrings, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fingerprint returns a Metric's Fingerprint.
0000000000000000000000000000000000000000;;	func (m Metric) Fingerprint() Fingerprint {
0000000000000000000000000000000000000000;;		return LabelSet(m).Fingerprint()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FastFingerprint returns a Metric's Fingerprint calculated by a faster hashing
0000000000000000000000000000000000000000;;	// algorithm, which is, however, more susceptible to hash collisions.
0000000000000000000000000000000000000000;;	func (m Metric) FastFingerprint() Fingerprint {
0000000000000000000000000000000000000000;;		return LabelSet(m).FastFingerprint()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidMetricName returns true iff name matches the pattern of MetricNameRE.
0000000000000000000000000000000000000000;;	// This function, however, does not use MetricNameRE for the check but a much
0000000000000000000000000000000000000000;;	// faster hardcoded implementation.
0000000000000000000000000000000000000000;;	func IsValidMetricName(n LabelValue) bool {
0000000000000000000000000000000000000000;;		if len(n) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, b := range n {
0000000000000000000000000000000000000000;;			if !((b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || b == '_' || b == ':' || (b >= '0' && b <= '9' && i > 0)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
