0000000000000000000000000000000000000000;;	// Copyright 2013 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b86cc30ece6ecc0d16bd8e3af4be75b963154490;Godeps/_workspace/src/github.com/prometheus/common/model/labelset.go[Godeps/_workspace/src/github.com/prometheus/common/model/labelset.go][vendor/github.com/prometheus/common/model/labelset.go];	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A LabelSet is a collection of LabelName and LabelValue pairs.  The LabelSet
0000000000000000000000000000000000000000;;	// may be fully-qualified down to the point where it may resolve to a single
0000000000000000000000000000000000000000;;	// Metric in the data store or not.  All operations that occur within the realm
0000000000000000000000000000000000000000;;	// of a LabelSet can emit a vector of Metric entities to which the LabelSet may
0000000000000000000000000000000000000000;;	// match.
0000000000000000000000000000000000000000;;	type LabelSet map[LabelName]LabelValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks whether all names and values in the label set
0000000000000000000000000000000000000000;;	// are valid.
0000000000000000000000000000000000000000;;	func (ls LabelSet) Validate() error {
0000000000000000000000000000000000000000;;		for ln, lv := range ls {
0000000000000000000000000000000000000000;;			if !ln.IsValid() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid name %q", ln)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !lv.IsValid() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid value %q", lv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true iff both label sets have exactly the same key/value pairs.
0000000000000000000000000000000000000000;;	func (ls LabelSet) Equal(o LabelSet) bool {
0000000000000000000000000000000000000000;;		if len(ls) != len(o) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ln, lv := range ls {
0000000000000000000000000000000000000000;;			olv, ok := o[ln]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if olv != lv {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Before compares the metrics, using the following criteria:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If m has fewer labels than o, it is before o. If it has more, it is not.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the number of labels is the same, the superset of all label names is
0000000000000000000000000000000000000000;;	// sorted alphanumerically. The first differing label pair found in that order
0000000000000000000000000000000000000000;;	// determines the outcome: If the label does not exist at all in m, then m is
0000000000000000000000000000000000000000;;	// before o, and vice versa. Otherwise the label value is compared
0000000000000000000000000000000000000000;;	// alphanumerically.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If m and o are equal, the method returns false.
0000000000000000000000000000000000000000;;	func (ls LabelSet) Before(o LabelSet) bool {
0000000000000000000000000000000000000000;;		if len(ls) < len(o) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ls) > len(o) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lns := make(LabelNames, 0, len(ls)+len(o))
0000000000000000000000000000000000000000;;		for ln := range ls {
0000000000000000000000000000000000000000;;			lns = append(lns, ln)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ln := range o {
0000000000000000000000000000000000000000;;			lns = append(lns, ln)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// It's probably not worth it to de-dup lns.
0000000000000000000000000000000000000000;;		sort.Sort(lns)
0000000000000000000000000000000000000000;;		for _, ln := range lns {
0000000000000000000000000000000000000000;;			mlv, ok := ls[ln]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			olv, ok := o[ln]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mlv < olv {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mlv > olv {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clone returns a copy of the label set.
0000000000000000000000000000000000000000;;	func (ls LabelSet) Clone() LabelSet {
0000000000000000000000000000000000000000;;		lsn := make(LabelSet, len(ls))
0000000000000000000000000000000000000000;;		for ln, lv := range ls {
0000000000000000000000000000000000000000;;			lsn[ln] = lv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lsn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge is a helper function to non-destructively merge two label sets.
0000000000000000000000000000000000000000;;	func (l LabelSet) Merge(other LabelSet) LabelSet {
0000000000000000000000000000000000000000;;		result := make(LabelSet, len(l))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range l {
0000000000000000000000000000000000000000;;			result[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range other {
0000000000000000000000000000000000000000;;			result[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelSet) String() string {
0000000000000000000000000000000000000000;;		lstrs := make([]string, 0, len(l))
0000000000000000000000000000000000000000;;		for l, v := range l {
0000000000000000000000000000000000000000;;			lstrs = append(lstrs, fmt.Sprintf("%s=%q", l, v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(lstrs)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("{%s}", strings.Join(lstrs, ", "))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fingerprint returns the LabelSet's fingerprint.
0000000000000000000000000000000000000000;;	func (ls LabelSet) Fingerprint() Fingerprint {
0000000000000000000000000000000000000000;;		return labelSetToFingerprint(ls)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FastFingerprint returns the LabelSet's Fingerprint calculated by a faster hashing
0000000000000000000000000000000000000000;;	// algorithm, which is, however, more susceptible to hash collisions.
0000000000000000000000000000000000000000;;	func (ls LabelSet) FastFingerprint() Fingerprint {
0000000000000000000000000000000000000000;;		return labelSetToFastFingerprint(ls)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaler interface.
0000000000000000000000000000000000000000;;	func (l *LabelSet) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var m map[LabelName]LabelValue
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &m); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// encoding/json only unmarshals maps of the form map[string]T. It treats
0000000000000000000000000000000000000000;;		// LabelName as a string and does not call its UnmarshalJSON method.
0000000000000000000000000000000000000000;;		// Thus, we have to replicate the behavior here.
0000000000000000000000000000000000000000;;		for ln := range m {
0000000000000000000000000000000000000000;;			if !ln.IsValid() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("%q is not a valid label name", ln)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*l = LabelSet(m)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
