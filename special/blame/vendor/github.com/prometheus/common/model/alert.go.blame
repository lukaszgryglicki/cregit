0000000000000000000000000000000000000000;;	// Copyright 2013 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
88b975cc595f9f01f269d01fab01b7f2e33a52d4;;	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AlertStatus string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AlertFiring   AlertStatus = "firing"
0000000000000000000000000000000000000000;;		AlertResolved AlertStatus = "resolved"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Alert is a generic representation of an alert in the Prometheus eco-system.
0000000000000000000000000000000000000000;;	type Alert struct {
0000000000000000000000000000000000000000;;		// Label value pairs for purpose of aggregation, matching, and disposition
0000000000000000000000000000000000000000;;		// dispatching. This must minimally include an "alertname" label.
0000000000000000000000000000000000000000;;		Labels LabelSet `json:"labels"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extra key/value information which does not define alert identity.
0000000000000000000000000000000000000000;;		Annotations LabelSet `json:"annotations"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The known time range for this alert. Both ends are optional.
0000000000000000000000000000000000000000;;		StartsAt     time.Time `json:"startsAt,omitempty"`
0000000000000000000000000000000000000000;;		EndsAt       time.Time `json:"endsAt,omitempty"`
0000000000000000000000000000000000000000;;		GeneratorURL string    `json:"generatorURL"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the name of the alert. It is equivalent to the "alertname" label.
0000000000000000000000000000000000000000;;	func (a *Alert) Name() string {
0000000000000000000000000000000000000000;;		return string(a.Labels[AlertNameLabel])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fingerprint returns a unique hash for the alert. It is equivalent to
0000000000000000000000000000000000000000;;	// the fingerprint of the alert's label set.
0000000000000000000000000000000000000000;;	func (a *Alert) Fingerprint() Fingerprint {
0000000000000000000000000000000000000000;;		return a.Labels.Fingerprint()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *Alert) String() string {
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("%s[%s]", a.Name(), a.Fingerprint().String()[:7])
0000000000000000000000000000000000000000;;		if a.Resolved() {
0000000000000000000000000000000000000000;;			return s + "[resolved]"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s + "[active]"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resolved returns true iff the activity interval ended in the past.
0000000000000000000000000000000000000000;;	func (a *Alert) Resolved() bool {
0000000000000000000000000000000000000000;;		return a.ResolvedAt(time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolvedAt returns true off the activity interval ended before
0000000000000000000000000000000000000000;;	// the given timestamp.
0000000000000000000000000000000000000000;;	func (a *Alert) ResolvedAt(ts time.Time) bool {
0000000000000000000000000000000000000000;;		if a.EndsAt.IsZero() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return !a.EndsAt.After(ts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns the status of the alert.
0000000000000000000000000000000000000000;;	func (a *Alert) Status() AlertStatus {
0000000000000000000000000000000000000000;;		if a.Resolved() {
0000000000000000000000000000000000000000;;			return AlertResolved
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return AlertFiring
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks whether the alert data is inconsistent.
0000000000000000000000000000000000000000;;	func (a *Alert) Validate() error {
0000000000000000000000000000000000000000;;		if a.StartsAt.IsZero() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("start time missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !a.EndsAt.IsZero() && a.EndsAt.Before(a.StartsAt) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("start time must be before end time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := a.Labels.Validate(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid label set: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(a.Labels) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one label pair required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := a.Annotations.Validate(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid annotations: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Alert is a list of alerts that can be sorted in chronological order.
0000000000000000000000000000000000000000;;	type Alerts []*Alert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as Alerts) Len() int      { return len(as) }
0000000000000000000000000000000000000000;;	func (as Alerts) Swap(i, j int) { as[i], as[j] = as[j], as[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as Alerts) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if as[i].StartsAt.Before(as[j].StartsAt) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if as[i].EndsAt.Before(as[j].EndsAt) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return as[i].Fingerprint() < as[j].Fingerprint()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasFiring returns true iff one of the alerts is not resolved.
0000000000000000000000000000000000000000;;	func (as Alerts) HasFiring() bool {
0000000000000000000000000000000000000000;;		for _, a := range as {
0000000000000000000000000000000000000000;;			if !a.Resolved() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns StatusFiring iff at least one of the alerts is firing.
0000000000000000000000000000000000000000;;	func (as Alerts) Status() AlertStatus {
0000000000000000000000000000000000000000;;		if as.HasFiring() {
0000000000000000000000000000000000000000;;			return AlertFiring
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return AlertResolved
0000000000000000000000000000000000000000;;	}
