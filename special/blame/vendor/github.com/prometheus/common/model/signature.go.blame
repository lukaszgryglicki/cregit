0000000000000000000000000000000000000000;;	// Copyright 2014 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
f7e1dc03448db9e2d7d0160d5b6aa202c60d79bc;Godeps/_workspace/src/github.com/prometheus/common/model/signature.go[Godeps/_workspace/src/github.com/prometheus/common/model/signature.go][vendor/github.com/prometheus/common/model/signature.go];	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SeparatorByte is a byte that cannot occur in valid UTF-8 sequences and is
0000000000000000000000000000000000000000;;	// used to separate label names, label values, and other strings from each other
0000000000000000000000000000000000000000;;	// when calculating their combined hash value (aka signature aka fingerprint).
0000000000000000000000000000000000000000;;	const SeparatorByte byte = 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// cache the signature of an empty label set.
0000000000000000000000000000000000000000;;		emptyLabelSignature = hashNew()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelsToSignature returns a quasi-unique signature (i.e., fingerprint) for a
0000000000000000000000000000000000000000;;	// given label set. (Collisions are possible but unlikely if the number of label
0000000000000000000000000000000000000000;;	// sets the function is applied to is small.)
0000000000000000000000000000000000000000;;	func LabelsToSignature(labels map[string]string) uint64 {
0000000000000000000000000000000000000000;;		if len(labels) == 0 {
0000000000000000000000000000000000000000;;			return emptyLabelSignature
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelNames := make([]string, 0, len(labels))
0000000000000000000000000000000000000000;;		for labelName := range labels {
0000000000000000000000000000000000000000;;			labelNames = append(labelNames, labelName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(labelNames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sum := hashNew()
0000000000000000000000000000000000000000;;		for _, labelName := range labelNames {
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, labelName)
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, labels[labelName])
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// labelSetToFingerprint works exactly as LabelsToSignature but takes a LabelSet as
0000000000000000000000000000000000000000;;	// parameter (rather than a label map) and returns a Fingerprint.
0000000000000000000000000000000000000000;;	func labelSetToFingerprint(ls LabelSet) Fingerprint {
0000000000000000000000000000000000000000;;		if len(ls) == 0 {
0000000000000000000000000000000000000000;;			return Fingerprint(emptyLabelSignature)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelNames := make(LabelNames, 0, len(ls))
0000000000000000000000000000000000000000;;		for labelName := range ls {
0000000000000000000000000000000000000000;;			labelNames = append(labelNames, labelName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(labelNames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sum := hashNew()
0000000000000000000000000000000000000000;;		for _, labelName := range labelNames {
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(labelName))
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(ls[labelName]))
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Fingerprint(sum)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// labelSetToFastFingerprint works similar to labelSetToFingerprint but uses a
0000000000000000000000000000000000000000;;	// faster and less allocation-heavy hash function, which is more susceptible to
0000000000000000000000000000000000000000;;	// create hash collisions. Therefore, collision detection should be applied.
0000000000000000000000000000000000000000;;	func labelSetToFastFingerprint(ls LabelSet) Fingerprint {
0000000000000000000000000000000000000000;;		if len(ls) == 0 {
0000000000000000000000000000000000000000;;			return Fingerprint(emptyLabelSignature)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result uint64
0000000000000000000000000000000000000000;;		for labelName, labelValue := range ls {
0000000000000000000000000000000000000000;;			sum := hashNew()
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(labelName))
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(labelValue))
0000000000000000000000000000000000000000;;			result ^= sum
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Fingerprint(result)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureForLabels works like LabelsToSignature but takes a Metric as
0000000000000000000000000000000000000000;;	// parameter (rather than a label map) and only includes the labels with the
0000000000000000000000000000000000000000;;	// specified LabelNames into the signature calculation. The labels passed in
0000000000000000000000000000000000000000;;	// will be sorted by this function.
0000000000000000000000000000000000000000;;	func SignatureForLabels(m Metric, labels ...LabelName) uint64 {
0000000000000000000000000000000000000000;;		if len(labels) == 0 {
0000000000000000000000000000000000000000;;			return emptyLabelSignature
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(LabelNames(labels))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sum := hashNew()
0000000000000000000000000000000000000000;;		for _, label := range labels {
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(label))
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(m[label]))
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureWithoutLabels works like LabelsToSignature but takes a Metric as
0000000000000000000000000000000000000000;;	// parameter (rather than a label map) and excludes the labels with any of the
0000000000000000000000000000000000000000;;	// specified LabelNames from the signature calculation.
0000000000000000000000000000000000000000;;	func SignatureWithoutLabels(m Metric, labels map[LabelName]struct{}) uint64 {
0000000000000000000000000000000000000000;;		if len(m) == 0 {
0000000000000000000000000000000000000000;;			return emptyLabelSignature
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelNames := make(LabelNames, 0, len(m))
0000000000000000000000000000000000000000;;		for labelName := range m {
0000000000000000000000000000000000000000;;			if _, exclude := labels[labelName]; !exclude {
0000000000000000000000000000000000000000;;				labelNames = append(labelNames, labelName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(labelNames) == 0 {
0000000000000000000000000000000000000000;;			return emptyLabelSignature
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(labelNames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sum := hashNew()
0000000000000000000000000000000000000000;;		for _, labelName := range labelNames {
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(labelName))
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;			sum = hashAdd(sum, string(m[labelName]))
0000000000000000000000000000000000000000;;			sum = hashAddByte(sum, SeparatorByte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sum
0000000000000000000000000000000000000000;;	}
