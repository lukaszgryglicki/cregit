0000000000000000000000000000000000000000;;	// Copyright 2013 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b86cc30ece6ecc0d16bd8e3af4be75b963154490;Godeps/_workspace/src/github.com/prometheus/common/model/value.go[Godeps/_workspace/src/github.com/prometheus/common/model/value.go][vendor/github.com/prometheus/common/model/value.go];	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ZeroSamplePair is the pseudo zero-value of SamplePair used to signal a
0000000000000000000000000000000000000000;;		// non-existing sample pair. It is a SamplePair with timestamp Earliest and
0000000000000000000000000000000000000000;;		// value 0.0. Note that the natural zero value of SamplePair has a timestamp
0000000000000000000000000000000000000000;;		// of 0, which is possible to appear in a real SamplePair and thus not
0000000000000000000000000000000000000000;;		// suitable to signal a non-existing SamplePair.
0000000000000000000000000000000000000000;;		ZeroSamplePair = SamplePair{Timestamp: Earliest}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ZeroSample is the pseudo zero-value of Sample used to signal a
0000000000000000000000000000000000000000;;		// non-existing sample. It is a Sample with timestamp Earliest, value 0.0,
0000000000000000000000000000000000000000;;		// and metric nil. Note that the natural zero value of Sample has a timestamp
0000000000000000000000000000000000000000;;		// of 0, which is possible to appear in a real Sample and thus not suitable
0000000000000000000000000000000000000000;;		// to signal a non-existing Sample.
0000000000000000000000000000000000000000;;		ZeroSample = Sample{Timestamp: Earliest}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SampleValue is a representation of a value for a given sample at a given
0000000000000000000000000000000000000000;;	// time.
0000000000000000000000000000000000000000;;	type SampleValue float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements json.Marshaler.
0000000000000000000000000000000000000000;;	func (v SampleValue) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return json.Marshal(v.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements json.Unmarshaler.
0000000000000000000000000000000000000000;;	func (v *SampleValue) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		if len(b) < 2 || b[0] != '"' || b[len(b)-1] != '"' {
0000000000000000000000000000000000000000;;			return fmt.Errorf("sample value must be a quoted string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := strconv.ParseFloat(string(b[1:len(b)-1]), 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*v = SampleValue(f)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if the value of v and o is equal or if both are NaN. Note
0000000000000000000000000000000000000000;;	// that v==o is false if both are NaN. If you want the conventional float
0000000000000000000000000000000000000000;;	// behavior, use == to compare two SampleValues.
0000000000000000000000000000000000000000;;	func (v SampleValue) Equal(o SampleValue) bool {
0000000000000000000000000000000000000000;;		if v == o {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return math.IsNaN(float64(v)) && math.IsNaN(float64(o))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v SampleValue) String() string {
0000000000000000000000000000000000000000;;		return strconv.FormatFloat(float64(v), 'f', -1, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SamplePair pairs a SampleValue with a Timestamp.
0000000000000000000000000000000000000000;;	type SamplePair struct {
0000000000000000000000000000000000000000;;		Timestamp Time
0000000000000000000000000000000000000000;;		Value     SampleValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements json.Marshaler.
0000000000000000000000000000000000000000;;	func (s SamplePair) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		t, err := json.Marshal(s.Timestamp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := json.Marshal(s.Value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []byte(fmt.Sprintf("[%s,%s]", t, v)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements json.Unmarshaler.
0000000000000000000000000000000000000000;;	func (s *SamplePair) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		v := [...]json.Unmarshaler{&s.Timestamp, &s.Value}
0000000000000000000000000000000000000000;;		return json.Unmarshal(b, &v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if this SamplePair and o have equal Values and equal
0000000000000000000000000000000000000000;;	// Timestamps. The sematics of Value equality is defined by SampleValue.Equal.
0000000000000000000000000000000000000000;;	func (s *SamplePair) Equal(o *SamplePair) bool {
0000000000000000000000000000000000000000;;		return s == o || (s.Value.Equal(o.Value) && s.Timestamp.Equal(o.Timestamp))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SamplePair) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s @[%s]", s.Value, s.Timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sample is a sample pair associated with a metric.
0000000000000000000000000000000000000000;;	type Sample struct {
0000000000000000000000000000000000000000;;		Metric    Metric      `json:"metric"`
0000000000000000000000000000000000000000;;		Value     SampleValue `json:"value"`
0000000000000000000000000000000000000000;;		Timestamp Time        `json:"timestamp"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal compares first the metrics, then the timestamp, then the value. The
0000000000000000000000000000000000000000;;	// sematics of value equality is defined by SampleValue.Equal.
0000000000000000000000000000000000000000;;	func (s *Sample) Equal(o *Sample) bool {
0000000000000000000000000000000000000000;;		if s == o {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.Metric.Equal(o.Metric) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.Timestamp.Equal(o.Timestamp) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.Value.Equal(o.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s Sample) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s => %s", s.Metric, SamplePair{
0000000000000000000000000000000000000000;;			Timestamp: s.Timestamp,
0000000000000000000000000000000000000000;;			Value:     s.Value,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements json.Marshaler.
0000000000000000000000000000000000000000;;	func (s Sample) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		v := struct {
0000000000000000000000000000000000000000;;			Metric Metric     `json:"metric"`
0000000000000000000000000000000000000000;;			Value  SamplePair `json:"value"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Metric: s.Metric,
0000000000000000000000000000000000000000;;			Value: SamplePair{
0000000000000000000000000000000000000000;;				Timestamp: s.Timestamp,
0000000000000000000000000000000000000000;;				Value:     s.Value,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(&v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements json.Unmarshaler.
0000000000000000000000000000000000000000;;	func (s *Sample) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		v := struct {
0000000000000000000000000000000000000000;;			Metric Metric     `json:"metric"`
0000000000000000000000000000000000000000;;			Value  SamplePair `json:"value"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Metric: s.Metric,
0000000000000000000000000000000000000000;;			Value: SamplePair{
0000000000000000000000000000000000000000;;				Timestamp: s.Timestamp,
0000000000000000000000000000000000000000;;				Value:     s.Value,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &v); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Metric = v.Metric
0000000000000000000000000000000000000000;;		s.Timestamp = v.Value.Timestamp
0000000000000000000000000000000000000000;;		s.Value = v.Value.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Samples is a sortable Sample slice. It implements sort.Interface.
0000000000000000000000000000000000000000;;	type Samples []*Sample
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s Samples) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less compares first the metrics, then the timestamp.
0000000000000000000000000000000000000000;;	func (s Samples) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case s[i].Metric.Before(s[j].Metric):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case s[j].Metric.Before(s[i].Metric):
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case s[i].Timestamp.Before(s[j].Timestamp):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s Samples) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal compares two sets of samples and returns true if they are equal.
0000000000000000000000000000000000000000;;	func (s Samples) Equal(o Samples) bool {
0000000000000000000000000000000000000000;;		if len(s) != len(o) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, sample := range s {
0000000000000000000000000000000000000000;;			if !sample.Equal(o[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SampleStream is a stream of Values belonging to an attached COWMetric.
0000000000000000000000000000000000000000;;	type SampleStream struct {
0000000000000000000000000000000000000000;;		Metric Metric       `json:"metric"`
0000000000000000000000000000000000000000;;		Values []SamplePair `json:"values"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss SampleStream) String() string {
0000000000000000000000000000000000000000;;		vals := make([]string, len(ss.Values))
0000000000000000000000000000000000000000;;		for i, v := range ss.Values {
0000000000000000000000000000000000000000;;			vals[i] = v.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s =>\n%s", ss.Metric, strings.Join(vals, "\n"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value is a generic interface for values resulting from a query evaluation.
0000000000000000000000000000000000000000;;	type Value interface {
0000000000000000000000000000000000000000;;		Type() ValueType
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (Matrix) Type() ValueType  { return ValMatrix }
0000000000000000000000000000000000000000;;	func (Vector) Type() ValueType  { return ValVector }
0000000000000000000000000000000000000000;;	func (*Scalar) Type() ValueType { return ValScalar }
0000000000000000000000000000000000000000;;	func (*String) Type() ValueType { return ValString }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ValueType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ValNone ValueType = iota
0000000000000000000000000000000000000000;;		ValScalar
0000000000000000000000000000000000000000;;		ValVector
0000000000000000000000000000000000000000;;		ValMatrix
0000000000000000000000000000000000000000;;		ValString
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements json.Marshaler.
0000000000000000000000000000000000000000;;	func (et ValueType) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return json.Marshal(et.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (et *ValueType) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "<ValNone>":
0000000000000000000000000000000000000000;;			*et = ValNone
0000000000000000000000000000000000000000;;		case "scalar":
0000000000000000000000000000000000000000;;			*et = ValScalar
0000000000000000000000000000000000000000;;		case "vector":
0000000000000000000000000000000000000000;;			*et = ValVector
0000000000000000000000000000000000000000;;		case "matrix":
0000000000000000000000000000000000000000;;			*et = ValMatrix
0000000000000000000000000000000000000000;;		case "string":
0000000000000000000000000000000000000000;;			*et = ValString
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unknown value type %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e ValueType) String() string {
0000000000000000000000000000000000000000;;		switch e {
0000000000000000000000000000000000000000;;		case ValNone:
0000000000000000000000000000000000000000;;			return "<ValNone>"
0000000000000000000000000000000000000000;;		case ValScalar:
0000000000000000000000000000000000000000;;			return "scalar"
0000000000000000000000000000000000000000;;		case ValVector:
0000000000000000000000000000000000000000;;			return "vector"
0000000000000000000000000000000000000000;;		case ValMatrix:
0000000000000000000000000000000000000000;;			return "matrix"
0000000000000000000000000000000000000000;;		case ValString:
0000000000000000000000000000000000000000;;			return "string"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("ValueType.String: unhandled value type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scalar is a scalar value evaluated at the set timestamp.
0000000000000000000000000000000000000000;;	type Scalar struct {
0000000000000000000000000000000000000000;;		Value     SampleValue `json:"value"`
0000000000000000000000000000000000000000;;		Timestamp Time        `json:"timestamp"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s Scalar) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("scalar: %v @[%v]", s.Value, s.Timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements json.Marshaler.
0000000000000000000000000000000000000000;;	func (s Scalar) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		v := strconv.FormatFloat(float64(s.Value), 'f', -1, 64)
0000000000000000000000000000000000000000;;		return json.Marshal([...]interface{}{s.Timestamp, string(v)})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements json.Unmarshaler.
0000000000000000000000000000000000000000;;	func (s *Scalar) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var f string
0000000000000000000000000000000000000000;;		v := [...]interface{}{&s.Timestamp, &f}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &v); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		value, err := strconv.ParseFloat(f, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error parsing sample value: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.Value = SampleValue(value)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String is a string value evaluated at the set timestamp.
0000000000000000000000000000000000000000;;	type String struct {
0000000000000000000000000000000000000000;;		Value     string `json:"value"`
0000000000000000000000000000000000000000;;		Timestamp Time   `json:"timestamp"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *String) String() string {
0000000000000000000000000000000000000000;;		return s.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements json.Marshaler.
0000000000000000000000000000000000000000;;	func (s String) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return json.Marshal([]interface{}{s.Timestamp, s.Value})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements json.Unmarshaler.
0000000000000000000000000000000000000000;;	func (s *String) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		v := [...]interface{}{&s.Timestamp, &s.Value}
0000000000000000000000000000000000000000;;		return json.Unmarshal(b, &v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Vector is basically only an alias for Samples, but the
0000000000000000000000000000000000000000;;	// contract is that in a Vector, all Samples have the same timestamp.
0000000000000000000000000000000000000000;;	type Vector []*Sample
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vec Vector) String() string {
0000000000000000000000000000000000000000;;		entries := make([]string, len(vec))
0000000000000000000000000000000000000000;;		for i, s := range vec {
0000000000000000000000000000000000000000;;			entries[i] = s.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(entries, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vec Vector) Len() int      { return len(vec) }
0000000000000000000000000000000000000000;;	func (vec Vector) Swap(i, j int) { vec[i], vec[j] = vec[j], vec[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less compares first the metrics, then the timestamp.
0000000000000000000000000000000000000000;;	func (vec Vector) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case vec[i].Metric.Before(vec[j].Metric):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case vec[j].Metric.Before(vec[i].Metric):
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case vec[i].Timestamp.Before(vec[j].Timestamp):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal compares two sets of samples and returns true if they are equal.
0000000000000000000000000000000000000000;;	func (vec Vector) Equal(o Vector) bool {
0000000000000000000000000000000000000000;;		if len(vec) != len(o) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, sample := range vec {
0000000000000000000000000000000000000000;;			if !sample.Equal(o[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matrix is a list of time series.
0000000000000000000000000000000000000000;;	type Matrix []*SampleStream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m Matrix) Len() int           { return len(m) }
0000000000000000000000000000000000000000;;	func (m Matrix) Less(i, j int) bool { return m[i].Metric.Before(m[j].Metric) }
0000000000000000000000000000000000000000;;	func (m Matrix) Swap(i, j int)      { m[i], m[j] = m[j], m[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mat Matrix) String() string {
0000000000000000000000000000000000000000;;		matCp := make(Matrix, len(mat))
0000000000000000000000000000000000000000;;		copy(matCp, mat)
0000000000000000000000000000000000000000;;		sort.Sort(matCp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strs := make([]string, len(matCp))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, ss := range matCp {
0000000000000000000000000000000000000000;;			strs[i] = ss.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(strs, "\n")
0000000000000000000000000000000000000000;;	}
