0000000000000000000000000000000000000000;;	// Copyright 2015 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
88b975cc595f9f01f269d01fab01b7f2e33a52d4;;	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matcher describes a matches the value of a given label.
0000000000000000000000000000000000000000;;	type Matcher struct {
0000000000000000000000000000000000000000;;		Name    LabelName `json:"name"`
0000000000000000000000000000000000000000;;		Value   string    `json:"value"`
0000000000000000000000000000000000000000;;		IsRegex bool      `json:"isRegex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Matcher) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		type plain Matcher
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, (*plain)(m)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(m.Name) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("label name in matcher must not be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.IsRegex {
0000000000000000000000000000000000000000;;			if _, err := regexp.Compile(m.Value); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate returns true iff all fields of the matcher have valid values.
0000000000000000000000000000000000000000;;	func (m *Matcher) Validate() error {
0000000000000000000000000000000000000000;;		if !m.Name.IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid name %q", m.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.IsRegex {
0000000000000000000000000000000000000000;;			if _, err := regexp.Compile(m.Value); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid regular expression %q", m.Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if !LabelValue(m.Value).IsValid() || len(m.Value) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid value %q", m.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Silence defines the representation of a silence definiton
0000000000000000000000000000000000000000;;	// in the Prometheus eco-system.
0000000000000000000000000000000000000000;;	type Silence struct {
0000000000000000000000000000000000000000;;		ID uint64 `json:"id,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Matchers []*Matcher `json:"matchers"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		StartsAt time.Time `json:"startsAt"`
0000000000000000000000000000000000000000;;		EndsAt   time.Time `json:"endsAt"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CreatedAt time.Time `json:"createdAt,omitempty"`
0000000000000000000000000000000000000000;;		CreatedBy string    `json:"createdBy"`
0000000000000000000000000000000000000000;;		Comment   string    `json:"comment,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate returns true iff all fields of the silence have valid values.
0000000000000000000000000000000000000000;;	func (s *Silence) Validate() error {
0000000000000000000000000000000000000000;;		if len(s.Matchers) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("at least one matcher required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, m := range s.Matchers {
0000000000000000000000000000000000000000;;			if err := m.Validate(); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid matcher: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.StartsAt.IsZero() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("start time missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.EndsAt.IsZero() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("end time missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.EndsAt.Before(s.StartsAt) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("start time must be before end time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.CreatedBy == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("creator information missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Comment == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("comment missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.CreatedAt.IsZero() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("creation timestamp missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
