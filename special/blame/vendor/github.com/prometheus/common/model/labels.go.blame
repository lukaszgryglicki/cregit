0000000000000000000000000000000000000000;;	// Copyright 2013 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b86cc30ece6ecc0d16bd8e3af4be75b963154490;Godeps/_workspace/src/github.com/prometheus/common/model/labels.go[Godeps/_workspace/src/github.com/prometheus/common/model/labels.go][vendor/github.com/prometheus/common/model/labels.go];	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// AlertNameLabel is the name of the label containing the an alert's name.
0000000000000000000000000000000000000000;;		AlertNameLabel = "alertname"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExportedLabelPrefix is the prefix to prepend to the label names present in
0000000000000000000000000000000000000000;;		// exported metrics if a label of the same name is added by the server.
0000000000000000000000000000000000000000;;		ExportedLabelPrefix = "exported_"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MetricNameLabel is the label name indicating the metric name of a
0000000000000000000000000000000000000000;;		// timeseries.
0000000000000000000000000000000000000000;;		MetricNameLabel = "__name__"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SchemeLabel is the name of the label that holds the scheme on which to
0000000000000000000000000000000000000000;;		// scrape a target.
0000000000000000000000000000000000000000;;		SchemeLabel = "__scheme__"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AddressLabel is the name of the label that holds the address of
0000000000000000000000000000000000000000;;		// a scrape target.
0000000000000000000000000000000000000000;;		AddressLabel = "__address__"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MetricsPathLabel is the name of the label that holds the path on which to
0000000000000000000000000000000000000000;;		// scrape a target.
0000000000000000000000000000000000000000;;		MetricsPathLabel = "__metrics_path__"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReservedLabelPrefix is a prefix which is not legal in user-supplied
0000000000000000000000000000000000000000;;		// label names.
0000000000000000000000000000000000000000;;		ReservedLabelPrefix = "__"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MetaLabelPrefix is a prefix for labels that provide meta information.
0000000000000000000000000000000000000000;;		// Labels with this prefix are used for intermediate label processing and
0000000000000000000000000000000000000000;;		// will not be attached to time series.
0000000000000000000000000000000000000000;;		MetaLabelPrefix = "__meta_"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TmpLabelPrefix is a prefix for temporary labels as part of relabelling.
0000000000000000000000000000000000000000;;		// Labels with this prefix are used for intermediate label processing and
0000000000000000000000000000000000000000;;		// will not be attached to time series. This is reserved for use in
0000000000000000000000000000000000000000;;		// Prometheus configuration files by users.
0000000000000000000000000000000000000000;;		TmpLabelPrefix = "__tmp_"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ParamLabelPrefix is a prefix for labels that provide URL parameters
0000000000000000000000000000000000000000;;		// used to scrape a target.
0000000000000000000000000000000000000000;;		ParamLabelPrefix = "__param_"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// JobLabel is the label name indicating the job from which a timeseries
0000000000000000000000000000000000000000;;		// was scraped.
0000000000000000000000000000000000000000;;		JobLabel = "job"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InstanceLabel is the label name used for the instance label.
0000000000000000000000000000000000000000;;		InstanceLabel = "instance"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BucketLabel is used for the label that defines the upper bound of a
0000000000000000000000000000000000000000;;		// bucket of a histogram ("le" -> "less or equal").
0000000000000000000000000000000000000000;;		BucketLabel = "le"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// QuantileLabel is used for the label that defines the quantile in a
0000000000000000000000000000000000000000;;		// summary.
0000000000000000000000000000000000000000;;		QuantileLabel = "quantile"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelNameRE is a regular expression matching valid label names. Note that the
0000000000000000000000000000000000000000;;	// IsValid method of LabelName performs the same check but faster than a match
0000000000000000000000000000000000000000;;	// with this regular expression.
0000000000000000000000000000000000000000;;	var LabelNameRE = regexp.MustCompile("^[a-zA-Z_][a-zA-Z0-9_]*$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A LabelName is a key for a LabelSet or Metric.  It has a value associated
0000000000000000000000000000000000000000;;	// therewith.
0000000000000000000000000000000000000000;;	type LabelName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid is true iff the label name matches the pattern of LabelNameRE. This
0000000000000000000000000000000000000000;;	// method, however, does not use LabelNameRE for the check but a much faster
0000000000000000000000000000000000000000;;	// hardcoded implementation.
0000000000000000000000000000000000000000;;	func (ln LabelName) IsValid() bool {
0000000000000000000000000000000000000000;;		if len(ln) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, b := range ln {
0000000000000000000000000000000000000000;;			if !((b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z') || b == '_' || (b >= '0' && b <= '9' && i > 0)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalYAML implements the yaml.Unmarshaler interface.
0000000000000000000000000000000000000000;;	func (ln *LabelName) UnmarshalYAML(unmarshal func(interface{}) error) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := unmarshal(&s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !LabelName(s).IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%q is not a valid label name", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*ln = LabelName(s)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaler interface.
0000000000000000000000000000000000000000;;	func (ln *LabelName) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !LabelName(s).IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%q is not a valid label name", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*ln = LabelName(s)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelNames is a sortable LabelName slice. In implements sort.Interface.
0000000000000000000000000000000000000000;;	type LabelNames []LabelName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelNames) Len() int {
0000000000000000000000000000000000000000;;		return len(l)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelNames) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return l[i] < l[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelNames) Swap(i, j int) {
0000000000000000000000000000000000000000;;		l[i], l[j] = l[j], l[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelNames) String() string {
0000000000000000000000000000000000000000;;		labelStrings := make([]string, 0, len(l))
0000000000000000000000000000000000000000;;		for _, label := range l {
0000000000000000000000000000000000000000;;			labelStrings = append(labelStrings, string(label))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(labelStrings, ", ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A LabelValue is an associated value for a LabelName.
0000000000000000000000000000000000000000;;	type LabelValue string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid returns true iff the string is a valid UTF8.
0000000000000000000000000000000000000000;;	func (lv LabelValue) IsValid() bool {
0000000000000000000000000000000000000000;;		return utf8.ValidString(string(lv))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelValues is a sortable LabelValue slice. It implements sort.Interface.
0000000000000000000000000000000000000000;;	type LabelValues []LabelValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelValues) Len() int {
0000000000000000000000000000000000000000;;		return len(l)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelValues) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return string(l[i]) < string(l[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelValues) Swap(i, j int) {
0000000000000000000000000000000000000000;;		l[i], l[j] = l[j], l[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelPair pairs a name with a value.
0000000000000000000000000000000000000000;;	type LabelPair struct {
0000000000000000000000000000000000000000;;		Name  LabelName
0000000000000000000000000000000000000000;;		Value LabelValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelPairs is a sortable slice of LabelPair pointers. It implements
0000000000000000000000000000000000000000;;	// sort.Interface.
0000000000000000000000000000000000000000;;	type LabelPairs []*LabelPair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelPairs) Len() int {
0000000000000000000000000000000000000000;;		return len(l)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelPairs) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case l[i].Name > l[j].Name:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case l[i].Name < l[j].Name:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case l[i].Value > l[j].Value:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case l[i].Value < l[j].Value:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l LabelPairs) Swap(i, j int) {
0000000000000000000000000000000000000000;;		l[i], l[j] = l[j], l[i]
0000000000000000000000000000000000000000;;	}
