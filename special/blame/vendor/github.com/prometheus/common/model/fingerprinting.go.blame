0000000000000000000000000000000000000000;;	// Copyright 2013 The Prometheus Authors
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
f7e1dc03448db9e2d7d0160d5b6aa202c60d79bc;Godeps/_workspace/src/github.com/prometheus/common/model/fingerprinting.go[Godeps/_workspace/src/github.com/prometheus/common/model/fingerprinting.go][vendor/github.com/prometheus/common/model/fingerprinting.go];	
0000000000000000000000000000000000000000;;	package model
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fingerprint provides a hash-capable representation of a Metric.
0000000000000000000000000000000000000000;;	// For our purposes, FNV-1A 64-bit is used.
0000000000000000000000000000000000000000;;	type Fingerprint uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FingerprintFromString transforms a string representation into a Fingerprint.
0000000000000000000000000000000000000000;;	func FingerprintFromString(s string) (Fingerprint, error) {
0000000000000000000000000000000000000000;;		num, err := strconv.ParseUint(s, 16, 64)
0000000000000000000000000000000000000000;;		return Fingerprint(num), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseFingerprint parses the input string into a fingerprint.
0000000000000000000000000000000000000000;;	func ParseFingerprint(s string) (Fingerprint, error) {
0000000000000000000000000000000000000000;;		num, err := strconv.ParseUint(s, 16, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Fingerprint(num), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Fingerprint) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%016x", uint64(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fingerprints represents a collection of Fingerprint subject to a given
0000000000000000000000000000000000000000;;	// natural sorting scheme. It implements sort.Interface.
0000000000000000000000000000000000000000;;	type Fingerprints []Fingerprint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len implements sort.Interface.
0000000000000000000000000000000000000000;;	func (f Fingerprints) Len() int {
0000000000000000000000000000000000000000;;		return len(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less implements sort.Interface.
0000000000000000000000000000000000000000;;	func (f Fingerprints) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return f[i] < f[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Swap implements sort.Interface.
0000000000000000000000000000000000000000;;	func (f Fingerprints) Swap(i, j int) {
0000000000000000000000000000000000000000;;		f[i], f[j] = f[j], f[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FingerprintSet is a set of Fingerprints.
0000000000000000000000000000000000000000;;	type FingerprintSet map[Fingerprint]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if both sets contain the same elements (and not more).
0000000000000000000000000000000000000000;;	func (s FingerprintSet) Equal(o FingerprintSet) bool {
0000000000000000000000000000000000000000;;		if len(s) != len(o) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := range s {
0000000000000000000000000000000000000000;;			if _, ok := o[k]; !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Intersection returns the elements contained in both sets.
0000000000000000000000000000000000000000;;	func (s FingerprintSet) Intersection(o FingerprintSet) FingerprintSet {
0000000000000000000000000000000000000000;;		myLength, otherLength := len(s), len(o)
0000000000000000000000000000000000000000;;		if myLength == 0 || otherLength == 0 {
0000000000000000000000000000000000000000;;			return FingerprintSet{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subSet := s
0000000000000000000000000000000000000000;;		superSet := o
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if otherLength < myLength {
0000000000000000000000000000000000000000;;			subSet = o
0000000000000000000000000000000000000000;;			superSet = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := FingerprintSet{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := range subSet {
0000000000000000000000000000000000000000;;			if _, ok := superSet[k]; ok {
0000000000000000000000000000000000000000;;				out[k] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
