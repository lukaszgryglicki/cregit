0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	HTTP Content-Type Autonegotiation.
13e1e7cd1550dcd956d3e82fe798021f5812b15e;;	
0000000000000000000000000000000000000000;;	The functions in this package implement the behaviour specified in
0000000000000000000000000000000000000000;;	http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Copyright (c) 2011, Open Knowledge Foundation Ltd.
0000000000000000000000000000000000000000;;	All rights reserved.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	met:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	    notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Redistributions in binary form must reproduce the above copyright
0000000000000000000000000000000000000000;;	    notice, this list of conditions and the following disclaimer in
0000000000000000000000000000000000000000;;	    the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	    distribution.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Neither the name of the Open Knowledge Foundation Ltd. nor the
0000000000000000000000000000000000000000;;	    names of its contributors may be used to endorse or promote
0000000000000000000000000000000000000000;;	    products derived from this software without specific prior written
0000000000000000000000000000000000000000;;	    permission.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package goautoneg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Structure to represent a clause in an HTTP Accept Header
0000000000000000000000000000000000000000;;	type Accept struct {
0000000000000000000000000000000000000000;;		Type, SubType string
0000000000000000000000000000000000000000;;		Q             float64
0000000000000000000000000000000000000000;;		Params        map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For internal use, so that we can use the sort interface
0000000000000000000000000000000000000000;;	type accept_slice []Accept
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (accept accept_slice) Len() int {
0000000000000000000000000000000000000000;;		slice := []Accept(accept)
0000000000000000000000000000000000000000;;		return len(slice)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (accept accept_slice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		slice := []Accept(accept)
0000000000000000000000000000000000000000;;		ai, aj := slice[i], slice[j]
0000000000000000000000000000000000000000;;		if ai.Q > aj.Q {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ai.Type != "*" && aj.Type == "*" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ai.SubType != "*" && aj.SubType == "*" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (accept accept_slice) Swap(i, j int) {
0000000000000000000000000000000000000000;;		slice := []Accept(accept)
0000000000000000000000000000000000000000;;		slice[i], slice[j] = slice[j], slice[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse an Accept Header string returning a sorted list
0000000000000000000000000000000000000000;;	// of clauses
0000000000000000000000000000000000000000;;	func ParseAccept(header string) (accept []Accept) {
0000000000000000000000000000000000000000;;		parts := strings.Split(header, ",")
0000000000000000000000000000000000000000;;		accept = make([]Accept, 0, len(parts))
0000000000000000000000000000000000000000;;		for _, part := range parts {
0000000000000000000000000000000000000000;;			part := strings.Trim(part, " ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			a := Accept{}
0000000000000000000000000000000000000000;;			a.Params = make(map[string]string)
0000000000000000000000000000000000000000;;			a.Q = 1.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mrp := strings.Split(part, ";")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			media_range := mrp[0]
0000000000000000000000000000000000000000;;			sp := strings.Split(media_range, "/")
0000000000000000000000000000000000000000;;			a.Type = strings.Trim(sp[0], " ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case len(sp) == 1 && a.Type == "*":
0000000000000000000000000000000000000000;;				a.SubType = "*"
0000000000000000000000000000000000000000;;			case len(sp) == 2:
0000000000000000000000000000000000000000;;				a.SubType = strings.Trim(sp[1], " ")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(mrp) == 1 {
0000000000000000000000000000000000000000;;				accept = append(accept, a)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, param := range mrp[1:] {
0000000000000000000000000000000000000000;;				sp := strings.SplitN(param, "=", 2)
0000000000000000000000000000000000000000;;				if len(sp) != 2 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				token := strings.Trim(sp[0], " ")
0000000000000000000000000000000000000000;;				if token == "q" {
0000000000000000000000000000000000000000;;					a.Q, _ = strconv.ParseFloat(sp[1], 32)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					a.Params[token] = strings.Trim(sp[1], " ")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			accept = append(accept, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		slice := accept_slice(accept)
0000000000000000000000000000000000000000;;		sort.Sort(slice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Negotiate the most appropriate content_type given the accept header
0000000000000000000000000000000000000000;;	// and a list of alternatives.
0000000000000000000000000000000000000000;;	func Negotiate(header string, alternatives []string) (content_type string) {
0000000000000000000000000000000000000000;;		asp := make([][]string, 0, len(alternatives))
0000000000000000000000000000000000000000;;		for _, ctype := range alternatives {
0000000000000000000000000000000000000000;;			asp = append(asp, strings.SplitN(ctype, "/", 2))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, clause := range ParseAccept(header) {
0000000000000000000000000000000000000000;;			for i, ctsp := range asp {
0000000000000000000000000000000000000000;;				if clause.Type == ctsp[0] && clause.SubType == ctsp[1] {
0000000000000000000000000000000000000000;;					content_type = alternatives[i]
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if clause.Type == ctsp[0] && clause.SubType == "*" {
0000000000000000000000000000000000000000;;					content_type = alternatives[i]
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if clause.Type == "*" && clause.SubType == "*" {
0000000000000000000000000000000000000000;;					content_type = alternatives[i]
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
