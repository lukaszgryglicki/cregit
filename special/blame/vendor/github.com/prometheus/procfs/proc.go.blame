0000000000000000000000000000000000000000;;	package procfs
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/procfs/proc.go[Godeps/_workspace/src/github.com/prometheus/procfs/proc.go][vendor/github.com/prometheus/procfs/proc.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Proc provides information about a running process.
0000000000000000000000000000000000000000;;	type Proc struct {
0000000000000000000000000000000000000000;;		// The process ID.
0000000000000000000000000000000000000000;;		PID int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs FS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Procs represents a list of Proc structs.
0000000000000000000000000000000000000000;;	type Procs []Proc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Procs) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p Procs) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	func (p Procs) Less(i, j int) bool { return p[i].PID < p[j].PID }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Self returns a process for the current process read via /proc/self.
0000000000000000000000000000000000000000;;	func Self() (Proc, error) {
0000000000000000000000000000000000000000;;		fs, err := NewFS(DefaultMountPoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Proc{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fs.Self()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProc returns a process for the given pid under /proc.
0000000000000000000000000000000000000000;;	func NewProc(pid int) (Proc, error) {
0000000000000000000000000000000000000000;;		fs, err := NewFS(DefaultMountPoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Proc{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fs.NewProc(pid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllProcs returns a list of all currently available processes under /proc.
0000000000000000000000000000000000000000;;	func AllProcs() (Procs, error) {
0000000000000000000000000000000000000000;;		fs, err := NewFS(DefaultMountPoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Procs{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fs.AllProcs()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Self returns a process for the current process.
0000000000000000000000000000000000000000;;	func (fs FS) Self() (Proc, error) {
0000000000000000000000000000000000000000;;		p, err := os.Readlink(fs.Path("self"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Proc{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pid, err := strconv.Atoi(strings.Replace(p, string(fs), "", -1))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Proc{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fs.NewProc(pid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProc returns a process for the given pid.
0000000000000000000000000000000000000000;;	func (fs FS) NewProc(pid int) (Proc, error) {
0000000000000000000000000000000000000000;;		if _, err := os.Stat(fs.Path(strconv.Itoa(pid))); err != nil {
0000000000000000000000000000000000000000;;			return Proc{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Proc{PID: pid, fs: fs}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllProcs returns a list of all currently available processes.
0000000000000000000000000000000000000000;;	func (fs FS) AllProcs() (Procs, error) {
0000000000000000000000000000000000000000;;		d, err := os.Open(fs.Path())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Procs{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer d.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names, err := d.Readdirnames(-1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Procs{}, fmt.Errorf("could not read %s: %s", d.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := Procs{}
0000000000000000000000000000000000000000;;		for _, n := range names {
0000000000000000000000000000000000000000;;			pid, err := strconv.ParseInt(n, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p = append(p, Proc{PID: int(pid), fs: fs})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CmdLine returns the command line of a process.
0000000000000000000000000000000000000000;;	func (p Proc) CmdLine() ([]string, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(p.path("cmdline"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) < 1 {
0000000000000000000000000000000000000000;;			return []string{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Split(string(data[:len(data)-1]), string(byte(0))), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Comm returns the command name of a process.
0000000000000000000000000000000000000000;;	func (p Proc) Comm() (string, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(p.path("comm"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.TrimSpace(string(data)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Executable returns the absolute path of the executable command of a process.
0000000000000000000000000000000000000000;;	func (p Proc) Executable() (string, error) {
0000000000000000000000000000000000000000;;		exe, err := os.Readlink(p.path("exe"))
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return exe, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileDescriptors returns the currently open file descriptors of a process.
0000000000000000000000000000000000000000;;	func (p Proc) FileDescriptors() ([]uintptr, error) {
0000000000000000000000000000000000000000;;		names, err := p.fileDescriptors()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fds := make([]uintptr, len(names))
0000000000000000000000000000000000000000;;		for i, n := range names {
0000000000000000000000000000000000000000;;			fd, err := strconv.ParseInt(n, 10, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse fd %s: %s", n, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fds[i] = uintptr(fd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fds, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileDescriptorTargets returns the targets of all file descriptors of a process.
0000000000000000000000000000000000000000;;	// If a file descriptor is not a symlink to a file (like a socket), that value will be the empty string.
0000000000000000000000000000000000000000;;	func (p Proc) FileDescriptorTargets() ([]string, error) {
0000000000000000000000000000000000000000;;		names, err := p.fileDescriptors()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		targets := make([]string, len(names))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, name := range names {
0000000000000000000000000000000000000000;;			target, err := os.Readlink(p.path("fd", name))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				targets[i] = target
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return targets, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileDescriptorsLen returns the number of currently open file descriptors of
0000000000000000000000000000000000000000;;	// a process.
0000000000000000000000000000000000000000;;	func (p Proc) FileDescriptorsLen() (int, error) {
0000000000000000000000000000000000000000;;		fds, err := p.fileDescriptors()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(fds), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MountStats retrieves statistics and configuration for mount points in a
0000000000000000000000000000000000000000;;	// process's namespace.
0000000000000000000000000000000000000000;;	func (p Proc) MountStats() ([]*Mount, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(p.path("mountstats"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseMountStats(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Proc) fileDescriptors() ([]string, error) {
0000000000000000000000000000000000000000;;		d, err := os.Open(p.path("fd"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer d.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names, err := d.Readdirnames(-1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not read %s: %s", d.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return names, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Proc) path(pa ...string) string {
0000000000000000000000000000000000000000;;		return p.fs.Path(append([]string{strconv.Itoa(p.PID)}, pa...)...)
0000000000000000000000000000000000000000;;	}
