0000000000000000000000000000000000000000;;	package procfs
13e1e7cd1550dcd956d3e82fe798021f5812b15e;;	
0000000000000000000000000000000000000000;;	// While implementing parsing of /proc/[pid]/mountstats, this blog was used
0000000000000000000000000000000000000000;;	// heavily as a reference:
0000000000000000000000000000000000000000;;	//   https://utcc.utoronto.ca/~cks/space/blog/linux/NFSMountstatsIndex
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Special thanks to Chris Siebenmann for all of his posts explaining the
0000000000000000000000000000000000000000;;	// various statistics available for NFS.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constants shared between multiple functions.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		deviceEntryLen = 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldBytesLen  = 8
0000000000000000000000000000000000000000;;		fieldEventsLen = 27
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		statVersion10 = "1.0"
0000000000000000000000000000000000000000;;		statVersion11 = "1.1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldTransport10Len = 10
0000000000000000000000000000000000000000;;		fieldTransport11Len = 13
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Mount is a device mount parsed from /proc/[pid]/mountstats.
0000000000000000000000000000000000000000;;	type Mount struct {
0000000000000000000000000000000000000000;;		// Name of the device.
0000000000000000000000000000000000000000;;		Device string
0000000000000000000000000000000000000000;;		// The mount point of the device.
0000000000000000000000000000000000000000;;		Mount string
0000000000000000000000000000000000000000;;		// The filesystem type used by the device.
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;		// If available additional statistics related to this Mount.
0000000000000000000000000000000000000000;;		// Use a type assertion to determine if additional statistics are available.
0000000000000000000000000000000000000000;;		Stats MountStats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A MountStats is a type which contains detailed statistics for a specific
0000000000000000000000000000000000000000;;	// type of Mount.
0000000000000000000000000000000000000000;;	type MountStats interface {
0000000000000000000000000000000000000000;;		mountStats()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A MountStatsNFS is a MountStats implementation for NFSv3 and v4 mounts.
0000000000000000000000000000000000000000;;	type MountStatsNFS struct {
0000000000000000000000000000000000000000;;		// The version of statistics provided.
0000000000000000000000000000000000000000;;		StatVersion string
0000000000000000000000000000000000000000;;		// The age of the NFS mount.
0000000000000000000000000000000000000000;;		Age time.Duration
0000000000000000000000000000000000000000;;		// Statistics related to byte counters for various operations.
0000000000000000000000000000000000000000;;		Bytes NFSBytesStats
0000000000000000000000000000000000000000;;		// Statistics related to various NFS event occurrences.
0000000000000000000000000000000000000000;;		Events NFSEventsStats
0000000000000000000000000000000000000000;;		// Statistics broken down by filesystem operation.
0000000000000000000000000000000000000000;;		Operations []NFSOperationStats
0000000000000000000000000000000000000000;;		// Statistics about the NFS RPC transport.
0000000000000000000000000000000000000000;;		Transport NFSTransportStats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mountStats implements MountStats.
0000000000000000000000000000000000000000;;	func (m MountStatsNFS) mountStats() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A NFSBytesStats contains statistics about the number of bytes read and written
0000000000000000000000000000000000000000;;	// by an NFS client to and from an NFS server.
0000000000000000000000000000000000000000;;	type NFSBytesStats struct {
0000000000000000000000000000000000000000;;		// Number of bytes read using the read() syscall.
0000000000000000000000000000000000000000;;		Read uint64
0000000000000000000000000000000000000000;;		// Number of bytes written using the write() syscall.
0000000000000000000000000000000000000000;;		Write uint64
0000000000000000000000000000000000000000;;		// Number of bytes read using the read() syscall in O_DIRECT mode.
0000000000000000000000000000000000000000;;		DirectRead uint64
0000000000000000000000000000000000000000;;		// Number of bytes written using the write() syscall in O_DIRECT mode.
0000000000000000000000000000000000000000;;		DirectWrite uint64
0000000000000000000000000000000000000000;;		// Number of bytes read from the NFS server, in total.
0000000000000000000000000000000000000000;;		ReadTotal uint64
0000000000000000000000000000000000000000;;		// Number of bytes written to the NFS server, in total.
0000000000000000000000000000000000000000;;		WriteTotal uint64
0000000000000000000000000000000000000000;;		// Number of pages read directly via mmap()'d files.
0000000000000000000000000000000000000000;;		ReadPages uint64
0000000000000000000000000000000000000000;;		// Number of pages written directly via mmap()'d files.
0000000000000000000000000000000000000000;;		WritePages uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A NFSEventsStats contains statistics about NFS event occurrences.
0000000000000000000000000000000000000000;;	type NFSEventsStats struct {
0000000000000000000000000000000000000000;;		// Number of times cached inode attributes are re-validated from the server.
0000000000000000000000000000000000000000;;		InodeRevalidate uint64
0000000000000000000000000000000000000000;;		// Number of times cached dentry nodes are re-validated from the server.
0000000000000000000000000000000000000000;;		DnodeRevalidate uint64
0000000000000000000000000000000000000000;;		// Number of times an inode cache is cleared.
0000000000000000000000000000000000000000;;		DataInvalidate uint64
0000000000000000000000000000000000000000;;		// Number of times cached inode attributes are invalidated.
0000000000000000000000000000000000000000;;		AttributeInvalidate uint64
0000000000000000000000000000000000000000;;		// Number of times files or directories have been open()'d.
0000000000000000000000000000000000000000;;		VFSOpen uint64
0000000000000000000000000000000000000000;;		// Number of times a directory lookup has occurred.
0000000000000000000000000000000000000000;;		VFSLookup uint64
0000000000000000000000000000000000000000;;		// Number of times permissions have been checked.
0000000000000000000000000000000000000000;;		VFSAccess uint64
0000000000000000000000000000000000000000;;		// Number of updates (and potential writes) to pages.
0000000000000000000000000000000000000000;;		VFSUpdatePage uint64
0000000000000000000000000000000000000000;;		// Number of pages read directly via mmap()'d files.
0000000000000000000000000000000000000000;;		VFSReadPage uint64
0000000000000000000000000000000000000000;;		// Number of times a group of pages have been read.
0000000000000000000000000000000000000000;;		VFSReadPages uint64
0000000000000000000000000000000000000000;;		// Number of pages written directly via mmap()'d files.
0000000000000000000000000000000000000000;;		VFSWritePage uint64
0000000000000000000000000000000000000000;;		// Number of times a group of pages have been written.
0000000000000000000000000000000000000000;;		VFSWritePages uint64
0000000000000000000000000000000000000000;;		// Number of times directory entries have been read with getdents().
0000000000000000000000000000000000000000;;		VFSGetdents uint64
0000000000000000000000000000000000000000;;		// Number of times attributes have been set on inodes.
0000000000000000000000000000000000000000;;		VFSSetattr uint64
0000000000000000000000000000000000000000;;		// Number of pending writes that have been forcefully flushed to the server.
0000000000000000000000000000000000000000;;		VFSFlush uint64
0000000000000000000000000000000000000000;;		// Number of times fsync() has been called on directories and files.
0000000000000000000000000000000000000000;;		VFSFsync uint64
0000000000000000000000000000000000000000;;		// Number of times locking has been attempted on a file.
0000000000000000000000000000000000000000;;		VFSLock uint64
0000000000000000000000000000000000000000;;		// Number of times files have been closed and released.
0000000000000000000000000000000000000000;;		VFSFileRelease uint64
0000000000000000000000000000000000000000;;		// Unknown.  Possibly unused.
0000000000000000000000000000000000000000;;		CongestionWait uint64
0000000000000000000000000000000000000000;;		// Number of times files have been truncated.
0000000000000000000000000000000000000000;;		Truncation uint64
0000000000000000000000000000000000000000;;		// Number of times a file has been grown due to writes beyond its existing end.
0000000000000000000000000000000000000000;;		WriteExtension uint64
0000000000000000000000000000000000000000;;		// Number of times a file was removed while still open by another process.
0000000000000000000000000000000000000000;;		SillyRename uint64
0000000000000000000000000000000000000000;;		// Number of times the NFS server gave less data than expected while reading.
0000000000000000000000000000000000000000;;		ShortRead uint64
0000000000000000000000000000000000000000;;		// Number of times the NFS server wrote less data than expected while writing.
0000000000000000000000000000000000000000;;		ShortWrite uint64
0000000000000000000000000000000000000000;;		// Number of times the NFS server indicated EJUKEBOX; retrieving data from
0000000000000000000000000000000000000000;;		// offline storage.
0000000000000000000000000000000000000000;;		JukeboxDelay uint64
0000000000000000000000000000000000000000;;		// Number of NFS v4.1+ pNFS reads.
0000000000000000000000000000000000000000;;		PNFSRead uint64
0000000000000000000000000000000000000000;;		// Number of NFS v4.1+ pNFS writes.
0000000000000000000000000000000000000000;;		PNFSWrite uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A NFSOperationStats contains statistics for a single operation.
0000000000000000000000000000000000000000;;	type NFSOperationStats struct {
0000000000000000000000000000000000000000;;		// The name of the operation.
0000000000000000000000000000000000000000;;		Operation string
0000000000000000000000000000000000000000;;		// Number of requests performed for this operation.
0000000000000000000000000000000000000000;;		Requests uint64
0000000000000000000000000000000000000000;;		// Number of times an actual RPC request has been transmitted for this operation.
0000000000000000000000000000000000000000;;		Transmissions uint64
0000000000000000000000000000000000000000;;		// Number of times a request has had a major timeout.
0000000000000000000000000000000000000000;;		MajorTimeouts uint64
0000000000000000000000000000000000000000;;		// Number of bytes sent for this operation, including RPC headers and payload.
0000000000000000000000000000000000000000;;		BytesSent uint64
0000000000000000000000000000000000000000;;		// Number of bytes received for this operation, including RPC headers and payload.
0000000000000000000000000000000000000000;;		BytesReceived uint64
0000000000000000000000000000000000000000;;		// Duration all requests spent queued for transmission before they were sent.
0000000000000000000000000000000000000000;;		CumulativeQueueTime time.Duration
0000000000000000000000000000000000000000;;		// Duration it took to get a reply back after the request was transmitted.
0000000000000000000000000000000000000000;;		CumulativeTotalResponseTime time.Duration
0000000000000000000000000000000000000000;;		// Duration from when a request was enqueued to when it was completely handled.
0000000000000000000000000000000000000000;;		CumulativeTotalRequestTime time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A NFSTransportStats contains statistics for the NFS mount RPC requests and
0000000000000000000000000000000000000000;;	// responses.
0000000000000000000000000000000000000000;;	type NFSTransportStats struct {
0000000000000000000000000000000000000000;;		// The local port used for the NFS mount.
0000000000000000000000000000000000000000;;		Port uint64
0000000000000000000000000000000000000000;;		// Number of times the client has had to establish a connection from scratch
0000000000000000000000000000000000000000;;		// to the NFS server.
0000000000000000000000000000000000000000;;		Bind uint64
0000000000000000000000000000000000000000;;		// Number of times the client has made a TCP connection to the NFS server.
0000000000000000000000000000000000000000;;		Connect uint64
0000000000000000000000000000000000000000;;		// Duration (in jiffies, a kernel internal unit of time) the NFS mount has
0000000000000000000000000000000000000000;;		// spent waiting for connections to the server to be established.
0000000000000000000000000000000000000000;;		ConnectIdleTime uint64
0000000000000000000000000000000000000000;;		// Duration since the NFS mount last saw any RPC traffic.
0000000000000000000000000000000000000000;;		IdleTime time.Duration
0000000000000000000000000000000000000000;;		// Number of RPC requests for this mount sent to the NFS server.
0000000000000000000000000000000000000000;;		Sends uint64
0000000000000000000000000000000000000000;;		// Number of RPC responses for this mount received from the NFS server.
0000000000000000000000000000000000000000;;		Receives uint64
0000000000000000000000000000000000000000;;		// Number of times the NFS server sent a response with a transaction ID
0000000000000000000000000000000000000000;;		// unknown to this client.
0000000000000000000000000000000000000000;;		BadTransactionIDs uint64
0000000000000000000000000000000000000000;;		// A running counter, incremented on each request as the current difference
0000000000000000000000000000000000000000;;		// ebetween sends and receives.
0000000000000000000000000000000000000000;;		CumulativeActiveRequests uint64
0000000000000000000000000000000000000000;;		// A running counter, incremented on each request by the current backlog
0000000000000000000000000000000000000000;;		// queue size.
0000000000000000000000000000000000000000;;		CumulativeBacklog uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stats below only available with stat version 1.1.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum number of simultaneously active RPC requests ever used.
0000000000000000000000000000000000000000;;		MaximumRPCSlotsUsed uint64
0000000000000000000000000000000000000000;;		// A running counter, incremented on each request as the current size of the
0000000000000000000000000000000000000000;;		// sending queue.
0000000000000000000000000000000000000000;;		CumulativeSendingQueue uint64
0000000000000000000000000000000000000000;;		// A running counter, incremented on each request as the current size of the
0000000000000000000000000000000000000000;;		// pending queue.
0000000000000000000000000000000000000000;;		CumulativePendingQueue uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseMountStats parses a /proc/[pid]/mountstats file and returns a slice
0000000000000000000000000000000000000000;;	// of Mount structures containing detailed information about each mount.
0000000000000000000000000000000000000000;;	// If available, statistics for each mount are parsed as well.
0000000000000000000000000000000000000000;;	func parseMountStats(r io.Reader) ([]*Mount, error) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			device            = "device"
0000000000000000000000000000000000000000;;			statVersionPrefix = "statvers="
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nfs3Type = "nfs"
0000000000000000000000000000000000000000;;			nfs4Type = "nfs4"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var mounts []*Mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(r)
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			// Only look for device entries in this function
0000000000000000000000000000000000000000;;			ss := strings.Fields(string(s.Bytes()))
0000000000000000000000000000000000000000;;			if len(ss) == 0 || ss[0] != device {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			m, err := parseMount(ss)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Does this mount also possess statistics information?
0000000000000000000000000000000000000000;;			if len(ss) > deviceEntryLen {
0000000000000000000000000000000000000000;;				// Only NFSv3 and v4 are supported for parsing statistics
0000000000000000000000000000000000000000;;				if m.Type != nfs3Type && m.Type != nfs4Type {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("cannot parse MountStats for fstype %q", m.Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				statVersion := strings.TrimPrefix(ss[8], statVersionPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				stats, err := parseMountStatsNFS(s, statVersion)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				m.Stats = stats
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mounts = append(mounts, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mounts, s.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseMount parses an entry in /proc/[pid]/mountstats in the format:
0000000000000000000000000000000000000000;;	//   device [device] mounted on [mount] with fstype [type]
0000000000000000000000000000000000000000;;	func parseMount(ss []string) (*Mount, error) {
0000000000000000000000000000000000000000;;		if len(ss) < deviceEntryLen {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid device entry: %v", ss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for specific words appearing at specific indices to ensure
0000000000000000000000000000000000000000;;		// the format is consistent with what we expect
0000000000000000000000000000000000000000;;		format := []struct {
0000000000000000000000000000000000000000;;			i int
0000000000000000000000000000000000000000;;			s string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{i: 0, s: "device"},
0000000000000000000000000000000000000000;;			{i: 2, s: "mounted"},
0000000000000000000000000000000000000000;;			{i: 3, s: "on"},
0000000000000000000000000000000000000000;;			{i: 5, s: "with"},
0000000000000000000000000000000000000000;;			{i: 6, s: "fstype"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range format {
0000000000000000000000000000000000000000;;			if ss[f.i] != f.s {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid device entry: %v", ss)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Mount{
0000000000000000000000000000000000000000;;			Device: ss[1],
0000000000000000000000000000000000000000;;			Mount:  ss[4],
0000000000000000000000000000000000000000;;			Type:   ss[7],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseMountStatsNFS parses a MountStatsNFS by scanning additional information
0000000000000000000000000000000000000000;;	// related to NFS statistics.
0000000000000000000000000000000000000000;;	func parseMountStatsNFS(s *bufio.Scanner, statVersion string) (*MountStatsNFS, error) {
0000000000000000000000000000000000000000;;		// Field indicators for parsing specific types of data
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			fieldAge        = "age:"
0000000000000000000000000000000000000000;;			fieldBytes      = "bytes:"
0000000000000000000000000000000000000000;;			fieldEvents     = "events:"
0000000000000000000000000000000000000000;;			fieldPerOpStats = "per-op"
0000000000000000000000000000000000000000;;			fieldTransport  = "xprt:"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats := &MountStatsNFS{
0000000000000000000000000000000000000000;;			StatVersion: statVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			ss := strings.Fields(string(s.Bytes()))
0000000000000000000000000000000000000000;;			if len(ss) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ss) < 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("not enough information for NFS stats: %v", ss)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch ss[0] {
0000000000000000000000000000000000000000;;			case fieldAge:
0000000000000000000000000000000000000000;;				// Age integer is in seconds
0000000000000000000000000000000000000000;;				d, err := time.ParseDuration(ss[1] + "s")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				stats.Age = d
0000000000000000000000000000000000000000;;			case fieldBytes:
0000000000000000000000000000000000000000;;				bstats, err := parseNFSBytesStats(ss[1:])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				stats.Bytes = *bstats
0000000000000000000000000000000000000000;;			case fieldEvents:
0000000000000000000000000000000000000000;;				estats, err := parseNFSEventsStats(ss[1:])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				stats.Events = *estats
0000000000000000000000000000000000000000;;			case fieldTransport:
0000000000000000000000000000000000000000;;				if len(ss) < 3 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("not enough information for NFS transport stats: %v", ss)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tstats, err := parseNFSTransportStats(ss[2:], statVersion)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				stats.Transport = *tstats
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// When encountering "per-operation statistics", we must break this
0000000000000000000000000000000000000000;;			// loop and parse them separately to ensure we can terminate parsing
0000000000000000000000000000000000000000;;			// before reaching another device entry; hence why this 'if' statement
0000000000000000000000000000000000000000;;			// is not just another switch case
0000000000000000000000000000000000000000;;			if ss[0] == fieldPerOpStats {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NFS per-operation stats appear last before the next device entry
0000000000000000000000000000000000000000;;		perOpStats, err := parseNFSOperationStats(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats.Operations = perOpStats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseNFSBytesStats parses a NFSBytesStats line using an input set of
0000000000000000000000000000000000000000;;	// integer fields.
0000000000000000000000000000000000000000;;	func parseNFSBytesStats(ss []string) (*NFSBytesStats, error) {
0000000000000000000000000000000000000000;;		if len(ss) != fieldBytesLen {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid NFS bytes stats: %v", ss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := make([]uint64, 0, fieldBytesLen)
0000000000000000000000000000000000000000;;		for _, s := range ss {
0000000000000000000000000000000000000000;;			n, err := strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ns = append(ns, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &NFSBytesStats{
0000000000000000000000000000000000000000;;			Read:        ns[0],
0000000000000000000000000000000000000000;;			Write:       ns[1],
0000000000000000000000000000000000000000;;			DirectRead:  ns[2],
0000000000000000000000000000000000000000;;			DirectWrite: ns[3],
0000000000000000000000000000000000000000;;			ReadTotal:   ns[4],
0000000000000000000000000000000000000000;;			WriteTotal:  ns[5],
0000000000000000000000000000000000000000;;			ReadPages:   ns[6],
0000000000000000000000000000000000000000;;			WritePages:  ns[7],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseNFSEventsStats parses a NFSEventsStats line using an input set of
0000000000000000000000000000000000000000;;	// integer fields.
0000000000000000000000000000000000000000;;	func parseNFSEventsStats(ss []string) (*NFSEventsStats, error) {
0000000000000000000000000000000000000000;;		if len(ss) != fieldEventsLen {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid NFS events stats: %v", ss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := make([]uint64, 0, fieldEventsLen)
0000000000000000000000000000000000000000;;		for _, s := range ss {
0000000000000000000000000000000000000000;;			n, err := strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ns = append(ns, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &NFSEventsStats{
0000000000000000000000000000000000000000;;			InodeRevalidate:     ns[0],
0000000000000000000000000000000000000000;;			DnodeRevalidate:     ns[1],
0000000000000000000000000000000000000000;;			DataInvalidate:      ns[2],
0000000000000000000000000000000000000000;;			AttributeInvalidate: ns[3],
0000000000000000000000000000000000000000;;			VFSOpen:             ns[4],
0000000000000000000000000000000000000000;;			VFSLookup:           ns[5],
0000000000000000000000000000000000000000;;			VFSAccess:           ns[6],
0000000000000000000000000000000000000000;;			VFSUpdatePage:       ns[7],
0000000000000000000000000000000000000000;;			VFSReadPage:         ns[8],
0000000000000000000000000000000000000000;;			VFSReadPages:        ns[9],
0000000000000000000000000000000000000000;;			VFSWritePage:        ns[10],
0000000000000000000000000000000000000000;;			VFSWritePages:       ns[11],
0000000000000000000000000000000000000000;;			VFSGetdents:         ns[12],
0000000000000000000000000000000000000000;;			VFSSetattr:          ns[13],
0000000000000000000000000000000000000000;;			VFSFlush:            ns[14],
0000000000000000000000000000000000000000;;			VFSFsync:            ns[15],
0000000000000000000000000000000000000000;;			VFSLock:             ns[16],
0000000000000000000000000000000000000000;;			VFSFileRelease:      ns[17],
0000000000000000000000000000000000000000;;			CongestionWait:      ns[18],
0000000000000000000000000000000000000000;;			Truncation:          ns[19],
0000000000000000000000000000000000000000;;			WriteExtension:      ns[20],
0000000000000000000000000000000000000000;;			SillyRename:         ns[21],
0000000000000000000000000000000000000000;;			ShortRead:           ns[22],
0000000000000000000000000000000000000000;;			ShortWrite:          ns[23],
0000000000000000000000000000000000000000;;			JukeboxDelay:        ns[24],
0000000000000000000000000000000000000000;;			PNFSRead:            ns[25],
0000000000000000000000000000000000000000;;			PNFSWrite:           ns[26],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseNFSOperationStats parses a slice of NFSOperationStats by scanning
0000000000000000000000000000000000000000;;	// additional information about per-operation statistics until an empty
0000000000000000000000000000000000000000;;	// line is reached.
0000000000000000000000000000000000000000;;	func parseNFSOperationStats(s *bufio.Scanner) ([]NFSOperationStats, error) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			// Number of expected fields in each per-operation statistics set
0000000000000000000000000000000000000000;;			numFields = 9
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ops []NFSOperationStats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			ss := strings.Fields(string(s.Bytes()))
0000000000000000000000000000000000000000;;			if len(ss) == 0 {
0000000000000000000000000000000000000000;;				// Must break when reading a blank line after per-operation stats to
0000000000000000000000000000000000000000;;				// enable top-level function to parse the next device entry
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(ss) != numFields {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid NFS per-operations stats: %v", ss)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Skip string operation name for integers
0000000000000000000000000000000000000000;;			ns := make([]uint64, 0, numFields-1)
0000000000000000000000000000000000000000;;			for _, st := range ss[1:] {
0000000000000000000000000000000000000000;;				n, err := strconv.ParseUint(st, 10, 64)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ns = append(ns, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ops = append(ops, NFSOperationStats{
0000000000000000000000000000000000000000;;				Operation:                   strings.TrimSuffix(ss[0], ":"),
0000000000000000000000000000000000000000;;				Requests:                    ns[0],
0000000000000000000000000000000000000000;;				Transmissions:               ns[1],
0000000000000000000000000000000000000000;;				MajorTimeouts:               ns[2],
0000000000000000000000000000000000000000;;				BytesSent:                   ns[3],
0000000000000000000000000000000000000000;;				BytesReceived:               ns[4],
0000000000000000000000000000000000000000;;				CumulativeQueueTime:         time.Duration(ns[5]) * time.Millisecond,
0000000000000000000000000000000000000000;;				CumulativeTotalResponseTime: time.Duration(ns[6]) * time.Millisecond,
0000000000000000000000000000000000000000;;				CumulativeTotalRequestTime:  time.Duration(ns[7]) * time.Millisecond,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ops, s.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseNFSTransportStats parses a NFSTransportStats line using an input set of
0000000000000000000000000000000000000000;;	// integer fields matched to a specific stats version.
0000000000000000000000000000000000000000;;	func parseNFSTransportStats(ss []string, statVersion string) (*NFSTransportStats, error) {
0000000000000000000000000000000000000000;;		switch statVersion {
0000000000000000000000000000000000000000;;		case statVersion10:
0000000000000000000000000000000000000000;;			if len(ss) != fieldTransport10Len {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid NFS transport stats 1.0 statement: %v", ss)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case statVersion11:
0000000000000000000000000000000000000000;;			if len(ss) != fieldTransport11Len {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid NFS transport stats 1.1 statement: %v", ss)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unrecognized NFS transport stats version: %q", statVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allocate enough for v1.1 stats since zero value for v1.1 stats will be okay
0000000000000000000000000000000000000000;;		// in a v1.0 response.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note: slice length must be set to length of v1.1 stats to avoid a panic when
0000000000000000000000000000000000000000;;		// only v1.0 stats are present.
0000000000000000000000000000000000000000;;		// See: https://github.com/prometheus/node_exporter/issues/571.
0000000000000000000000000000000000000000;;		ns := make([]uint64, fieldTransport11Len)
0000000000000000000000000000000000000000;;		for i, s := range ss {
0000000000000000000000000000000000000000;;			n, err := strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ns[i] = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &NFSTransportStats{
0000000000000000000000000000000000000000;;			Port:                     ns[0],
0000000000000000000000000000000000000000;;			Bind:                     ns[1],
0000000000000000000000000000000000000000;;			Connect:                  ns[2],
0000000000000000000000000000000000000000;;			ConnectIdleTime:          ns[3],
0000000000000000000000000000000000000000;;			IdleTime:                 time.Duration(ns[4]) * time.Second,
0000000000000000000000000000000000000000;;			Sends:                    ns[5],
0000000000000000000000000000000000000000;;			Receives:                 ns[6],
0000000000000000000000000000000000000000;;			BadTransactionIDs:        ns[7],
0000000000000000000000000000000000000000;;			CumulativeActiveRequests: ns[8],
0000000000000000000000000000000000000000;;			CumulativeBacklog:        ns[9],
0000000000000000000000000000000000000000;;			MaximumRPCSlotsUsed:      ns[10],
0000000000000000000000000000000000000000;;			CumulativeSendingQueue:   ns[11],
0000000000000000000000000000000000000000;;			CumulativePendingQueue:   ns[12],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
