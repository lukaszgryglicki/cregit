0000000000000000000000000000000000000000;;	package procfs
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/procfs/proc_limits.go[Godeps/_workspace/src/github.com/prometheus/procfs/proc_limits.go][vendor/github.com/prometheus/procfs/proc_limits.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProcLimits represents the soft limits for each of the process's resource
0000000000000000000000000000000000000000;;	// limits. For more information see getrlimit(2):
0000000000000000000000000000000000000000;;	// http://man7.org/linux/man-pages/man2/getrlimit.2.html.
0000000000000000000000000000000000000000;;	type ProcLimits struct {
0000000000000000000000000000000000000000;;		// CPU time limit in seconds.
0000000000000000000000000000000000000000;;		CPUTime int
0000000000000000000000000000000000000000;;		// Maximum size of files that the process may create.
0000000000000000000000000000000000000000;;		FileSize int
0000000000000000000000000000000000000000;;		// Maximum size of the process's data segment (initialized data,
0000000000000000000000000000000000000000;;		// uninitialized data, and heap).
0000000000000000000000000000000000000000;;		DataSize int
0000000000000000000000000000000000000000;;		// Maximum size of the process stack in bytes.
0000000000000000000000000000000000000000;;		StackSize int
0000000000000000000000000000000000000000;;		// Maximum size of a core file.
0000000000000000000000000000000000000000;;		CoreFileSize int
0000000000000000000000000000000000000000;;		// Limit of the process's resident set in pages.
0000000000000000000000000000000000000000;;		ResidentSet int
0000000000000000000000000000000000000000;;		// Maximum number of processes that can be created for the real user ID of
0000000000000000000000000000000000000000;;		// the calling process.
0000000000000000000000000000000000000000;;		Processes int
0000000000000000000000000000000000000000;;		// Value one greater than the maximum file descriptor number that can be
0000000000000000000000000000000000000000;;		// opened by this process.
0000000000000000000000000000000000000000;;		OpenFiles int
0000000000000000000000000000000000000000;;		// Maximum number of bytes of memory that may be locked into RAM.
0000000000000000000000000000000000000000;;		LockedMemory int
0000000000000000000000000000000000000000;;		// Maximum size of the process's virtual memory address space in bytes.
0000000000000000000000000000000000000000;;		AddressSpace int
0000000000000000000000000000000000000000;;		// Limit on the combined number of flock(2) locks and fcntl(2) leases that
0000000000000000000000000000000000000000;;		// this process may establish.
0000000000000000000000000000000000000000;;		FileLocks int
0000000000000000000000000000000000000000;;		// Limit of signals that may be queued for the real user ID of the calling
0000000000000000000000000000000000000000;;		// process.
0000000000000000000000000000000000000000;;		PendingSignals int
0000000000000000000000000000000000000000;;		// Limit on the number of bytes that can be allocated for POSIX message
0000000000000000000000000000000000000000;;		// queues for the real user ID of the calling process.
0000000000000000000000000000000000000000;;		MsqqueueSize int
0000000000000000000000000000000000000000;;		// Limit of the nice priority set using setpriority(2) or nice(2).
0000000000000000000000000000000000000000;;		NicePriority int
0000000000000000000000000000000000000000;;		// Limit of the real-time priority set using sched_setscheduler(2) or
0000000000000000000000000000000000000000;;		// sched_setparam(2).
0000000000000000000000000000000000000000;;		RealtimePriority int
0000000000000000000000000000000000000000;;		// Limit (in microseconds) on the amount of CPU time that a process
0000000000000000000000000000000000000000;;		// scheduled under a real-time scheduling policy may consume without making
0000000000000000000000000000000000000000;;		// a blocking system call.
0000000000000000000000000000000000000000;;		RealtimeTimeout int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		limitsFields    = 3
0000000000000000000000000000000000000000;;		limitsUnlimited = "unlimited"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		limitsDelimiter = regexp.MustCompile("  +")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLimits returns the current soft limits of the process.
0000000000000000000000000000000000000000;;	func (p Proc) NewLimits() (ProcLimits, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(p.path("limits"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ProcLimits{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			l = ProcLimits{}
0000000000000000000000000000000000000000;;			s = bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			fields := limitsDelimiter.Split(s.Text(), limitsFields)
0000000000000000000000000000000000000000;;			if len(fields) != limitsFields {
0000000000000000000000000000000000000000;;				return ProcLimits{}, fmt.Errorf(
0000000000000000000000000000000000000000;;					"couldn't parse %s line %s", f.Name(), s.Text())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch fields[0] {
0000000000000000000000000000000000000000;;			case "Max cpu time":
0000000000000000000000000000000000000000;;				l.CPUTime, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max file size":
0000000000000000000000000000000000000000;;				l.FileSize, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max data size":
0000000000000000000000000000000000000000;;				l.DataSize, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max stack size":
0000000000000000000000000000000000000000;;				l.StackSize, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max core file size":
0000000000000000000000000000000000000000;;				l.CoreFileSize, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max resident set":
0000000000000000000000000000000000000000;;				l.ResidentSet, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max processes":
0000000000000000000000000000000000000000;;				l.Processes, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max open files":
0000000000000000000000000000000000000000;;				l.OpenFiles, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max locked memory":
0000000000000000000000000000000000000000;;				l.LockedMemory, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max address space":
0000000000000000000000000000000000000000;;				l.AddressSpace, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max file locks":
0000000000000000000000000000000000000000;;				l.FileLocks, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max pending signals":
0000000000000000000000000000000000000000;;				l.PendingSignals, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max msgqueue size":
0000000000000000000000000000000000000000;;				l.MsqqueueSize, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max nice priority":
0000000000000000000000000000000000000000;;				l.NicePriority, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max realtime priority":
0000000000000000000000000000000000000000;;				l.RealtimePriority, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			case "Max realtime timeout":
0000000000000000000000000000000000000000;;				l.RealtimeTimeout, err = parseInt(fields[1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ProcLimits{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l, s.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseInt(s string) (int, error) {
0000000000000000000000000000000000000000;;		if s == limitsUnlimited {
0000000000000000000000000000000000000000;;			return -1, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, err := strconv.ParseInt(s, 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("couldn't parse value %s: %s", s, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(i), nil
0000000000000000000000000000000000000000;;	}
