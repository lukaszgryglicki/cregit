0000000000000000000000000000000000000000;;	package procfs
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		statuslineRE = regexp.MustCompile(`(\d+) blocks .*\[(\d+)/(\d+)\] \[[U_]+\]`)
0000000000000000000000000000000000000000;;		buildlineRE  = regexp.MustCompile(`\((\d+)/\d+\)`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MDStat holds info parsed from /proc/mdstat.
0000000000000000000000000000000000000000;;	type MDStat struct {
0000000000000000000000000000000000000000;;		// Name of the device.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// activity-state of the device.
0000000000000000000000000000000000000000;;		ActivityState string
0000000000000000000000000000000000000000;;		// Number of active disks.
0000000000000000000000000000000000000000;;		DisksActive int64
0000000000000000000000000000000000000000;;		// Total number of disks the device consists of.
0000000000000000000000000000000000000000;;		DisksTotal int64
0000000000000000000000000000000000000000;;		// Number of blocks the device holds.
0000000000000000000000000000000000000000;;		BlocksTotal int64
0000000000000000000000000000000000000000;;		// Number of blocks on the device that are in sync.
0000000000000000000000000000000000000000;;		BlocksSynced int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseMDStat parses an mdstat-file and returns a struct with the relevant infos.
0000000000000000000000000000000000000000;;	func (fs FS) ParseMDStat() (mdstates []MDStat, err error) {
0000000000000000000000000000000000000000;;		mdStatusFilePath := fs.Path("mdstat")
0000000000000000000000000000000000000000;;		content, err := ioutil.ReadFile(mdStatusFilePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []MDStat{}, fmt.Errorf("error parsing %s: %s", mdStatusFilePath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mdStates := []MDStat{}
0000000000000000000000000000000000000000;;		lines := strings.Split(string(content), "\n")
0000000000000000000000000000000000000000;;		for i, l := range lines {
0000000000000000000000000000000000000000;;			if l == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if l[0] == ' ' {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(l, "Personalities") || strings.HasPrefix(l, "unused") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mainLine := strings.Split(l, " ")
0000000000000000000000000000000000000000;;			if len(mainLine) < 3 {
0000000000000000000000000000000000000000;;				return mdStates, fmt.Errorf("error parsing mdline: %s", l)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mdName := mainLine[0]
0000000000000000000000000000000000000000;;			activityState := mainLine[2]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(lines) <= i+3 {
0000000000000000000000000000000000000000;;				return mdStates, fmt.Errorf(
0000000000000000000000000000000000000000;;					"error parsing %s: too few lines for md device %s",
0000000000000000000000000000000000000000;;					mdStatusFilePath,
0000000000000000000000000000000000000000;;					mdName,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			active, total, size, err := evalStatusline(lines[i+1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return mdStates, fmt.Errorf("error parsing %s: %s", mdStatusFilePath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// j is the line number of the syncing-line.
0000000000000000000000000000000000000000;;			j := i + 2
0000000000000000000000000000000000000000;;			if strings.Contains(lines[i+2], "bitmap") { // skip bitmap line
0000000000000000000000000000000000000000;;				j = i + 3
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If device is syncing at the moment, get the number of currently
0000000000000000000000000000000000000000;;			// synced bytes, otherwise that number equals the size of the device.
0000000000000000000000000000000000000000;;			syncedBlocks := size
0000000000000000000000000000000000000000;;			if strings.Contains(lines[j], "recovery") || strings.Contains(lines[j], "resync") {
0000000000000000000000000000000000000000;;				syncedBlocks, err = evalBuildline(lines[j])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return mdStates, fmt.Errorf("error parsing %s: %s", mdStatusFilePath, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mdStates = append(mdStates, MDStat{
0000000000000000000000000000000000000000;;				Name:          mdName,
0000000000000000000000000000000000000000;;				ActivityState: activityState,
0000000000000000000000000000000000000000;;				DisksActive:   active,
0000000000000000000000000000000000000000;;				DisksTotal:    total,
0000000000000000000000000000000000000000;;				BlocksTotal:   size,
0000000000000000000000000000000000000000;;				BlocksSynced:  syncedBlocks,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mdStates, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func evalStatusline(statusline string) (active, total, size int64, err error) {
0000000000000000000000000000000000000000;;		matches := statuslineRE.FindStringSubmatch(statusline)
0000000000000000000000000000000000000000;;		if len(matches) != 4 {
0000000000000000000000000000000000000000;;			return 0, 0, 0, fmt.Errorf("unexpected statusline: %s", statusline)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size, err = strconv.ParseInt(matches[1], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, fmt.Errorf("unexpected statusline %s: %s", statusline, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		total, err = strconv.ParseInt(matches[2], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, fmt.Errorf("unexpected statusline %s: %s", statusline, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		active, err = strconv.ParseInt(matches[3], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, fmt.Errorf("unexpected statusline %s: %s", statusline, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return active, total, size, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func evalBuildline(buildline string) (syncedBlocks int64, err error) {
0000000000000000000000000000000000000000;;		matches := buildlineRE.FindStringSubmatch(buildline)
0000000000000000000000000000000000000000;;		if len(matches) != 2 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("unexpected buildline: %s", buildline)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		syncedBlocks, err = strconv.ParseInt(matches[1], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("%s in buildline: %s", err, buildline)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return syncedBlocks, nil
0000000000000000000000000000000000000000;;	}
