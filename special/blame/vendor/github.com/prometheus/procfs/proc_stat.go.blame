0000000000000000000000000000000000000000;;	package procfs
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/procfs/proc_stat.go[Godeps/_workspace/src/github.com/prometheus/procfs/proc_stat.go][vendor/github.com/prometheus/procfs/proc_stat.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Originally, this USER_HZ value was dynamically retrieved via a sysconf call
0000000000000000000000000000000000000000;;	// which required cgo. However, that caused a lot of problems regarding
0000000000000000000000000000000000000000;;	// cross-compilation. Alternatives such as running a binary to determine the
0000000000000000000000000000000000000000;;	// value, or trying to derive it in some other way were all problematic.  After
0000000000000000000000000000000000000000;;	// much research it was determined that USER_HZ is actually hardcoded to 100 on
0000000000000000000000000000000000000000;;	// all Go-supported platforms as of the time of this writing. This is why we
0000000000000000000000000000000000000000;;	// decided to hardcode it here as well. It is not impossible that there could
0000000000000000000000000000000000000000;;	// be systems with exceptions, but they should be very exotic edge cases, and
0000000000000000000000000000000000000000;;	// in that case, the worst outcome will be two misreported metrics.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See also the following discussions:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - https://github.com/prometheus/node_exporter/issues/52
0000000000000000000000000000000000000000;;	// - https://github.com/prometheus/procfs/pull/2
0000000000000000000000000000000000000000;;	// - http://stackoverflow.com/questions/17410841/how-does-user-hz-solve-the-jiffy-scaling-issue
0000000000000000000000000000000000000000;;	const userHZ = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProcStat provides status information about the process,
0000000000000000000000000000000000000000;;	// read from /proc/[pid]/stat.
0000000000000000000000000000000000000000;;	type ProcStat struct {
0000000000000000000000000000000000000000;;		// The process ID.
0000000000000000000000000000000000000000;;		PID int
0000000000000000000000000000000000000000;;		// The filename of the executable.
0000000000000000000000000000000000000000;;		Comm string
0000000000000000000000000000000000000000;;		// The process state.
0000000000000000000000000000000000000000;;		State string
0000000000000000000000000000000000000000;;		// The PID of the parent of this process.
0000000000000000000000000000000000000000;;		PPID int
0000000000000000000000000000000000000000;;		// The process group ID of the process.
0000000000000000000000000000000000000000;;		PGRP int
0000000000000000000000000000000000000000;;		// The session ID of the process.
0000000000000000000000000000000000000000;;		Session int
0000000000000000000000000000000000000000;;		// The controlling terminal of the process.
0000000000000000000000000000000000000000;;		TTY int
0000000000000000000000000000000000000000;;		// The ID of the foreground process group of the controlling terminal of
0000000000000000000000000000000000000000;;		// the process.
0000000000000000000000000000000000000000;;		TPGID int
0000000000000000000000000000000000000000;;		// The kernel flags word of the process.
0000000000000000000000000000000000000000;;		Flags uint
0000000000000000000000000000000000000000;;		// The number of minor faults the process has made which have not required
0000000000000000000000000000000000000000;;		// loading a memory page from disk.
0000000000000000000000000000000000000000;;		MinFlt uint
0000000000000000000000000000000000000000;;		// The number of minor faults that the process's waited-for children have
0000000000000000000000000000000000000000;;		// made.
0000000000000000000000000000000000000000;;		CMinFlt uint
0000000000000000000000000000000000000000;;		// The number of major faults the process has made which have required
0000000000000000000000000000000000000000;;		// loading a memory page from disk.
0000000000000000000000000000000000000000;;		MajFlt uint
0000000000000000000000000000000000000000;;		// The number of major faults that the process's waited-for children have
0000000000000000000000000000000000000000;;		// made.
0000000000000000000000000000000000000000;;		CMajFlt uint
0000000000000000000000000000000000000000;;		// Amount of time that this process has been scheduled in user mode,
0000000000000000000000000000000000000000;;		// measured in clock ticks.
0000000000000000000000000000000000000000;;		UTime uint
0000000000000000000000000000000000000000;;		// Amount of time that this process has been scheduled in kernel mode,
0000000000000000000000000000000000000000;;		// measured in clock ticks.
0000000000000000000000000000000000000000;;		STime uint
0000000000000000000000000000000000000000;;		// Amount of time that this process's waited-for children have been
0000000000000000000000000000000000000000;;		// scheduled in user mode, measured in clock ticks.
0000000000000000000000000000000000000000;;		CUTime uint
0000000000000000000000000000000000000000;;		// Amount of time that this process's waited-for children have been
0000000000000000000000000000000000000000;;		// scheduled in kernel mode, measured in clock ticks.
0000000000000000000000000000000000000000;;		CSTime uint
0000000000000000000000000000000000000000;;		// For processes running a real-time scheduling policy, this is the negated
0000000000000000000000000000000000000000;;		// scheduling priority, minus one.
0000000000000000000000000000000000000000;;		Priority int
0000000000000000000000000000000000000000;;		// The nice value, a value in the range 19 (low priority) to -20 (high
0000000000000000000000000000000000000000;;		// priority).
0000000000000000000000000000000000000000;;		Nice int
0000000000000000000000000000000000000000;;		// Number of threads in this process.
0000000000000000000000000000000000000000;;		NumThreads int
0000000000000000000000000000000000000000;;		// The time the process started after system boot, the value is expressed
0000000000000000000000000000000000000000;;		// in clock ticks.
0000000000000000000000000000000000000000;;		Starttime uint64
0000000000000000000000000000000000000000;;		// Virtual memory size in bytes.
0000000000000000000000000000000000000000;;		VSize int
0000000000000000000000000000000000000000;;		// Resident set size in pages.
0000000000000000000000000000000000000000;;		RSS int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs FS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStat returns the current status information of the process.
0000000000000000000000000000000000000000;;	func (p Proc) NewStat() (ProcStat, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(p.path("stat"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ProcStat{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ProcStat{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			ignore int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s = ProcStat{PID: p.PID, fs: p.fs}
0000000000000000000000000000000000000000;;			l = bytes.Index(data, []byte("("))
0000000000000000000000000000000000000000;;			r = bytes.LastIndex(data, []byte(")"))
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l < 0 || r < 0 {
0000000000000000000000000000000000000000;;			return ProcStat{}, fmt.Errorf(
0000000000000000000000000000000000000000;;				"unexpected format, couldn't extract comm: %s",
0000000000000000000000000000000000000000;;				data,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Comm = string(data[l+1 : r])
0000000000000000000000000000000000000000;;		_, err = fmt.Fscan(
0000000000000000000000000000000000000000;;			bytes.NewBuffer(data[r+2:]),
0000000000000000000000000000000000000000;;			&s.State,
0000000000000000000000000000000000000000;;			&s.PPID,
0000000000000000000000000000000000000000;;			&s.PGRP,
0000000000000000000000000000000000000000;;			&s.Session,
0000000000000000000000000000000000000000;;			&s.TTY,
0000000000000000000000000000000000000000;;			&s.TPGID,
0000000000000000000000000000000000000000;;			&s.Flags,
0000000000000000000000000000000000000000;;			&s.MinFlt,
0000000000000000000000000000000000000000;;			&s.CMinFlt,
0000000000000000000000000000000000000000;;			&s.MajFlt,
0000000000000000000000000000000000000000;;			&s.CMajFlt,
0000000000000000000000000000000000000000;;			&s.UTime,
0000000000000000000000000000000000000000;;			&s.STime,
0000000000000000000000000000000000000000;;			&s.CUTime,
0000000000000000000000000000000000000000;;			&s.CSTime,
0000000000000000000000000000000000000000;;			&s.Priority,
0000000000000000000000000000000000000000;;			&s.Nice,
0000000000000000000000000000000000000000;;			&s.NumThreads,
0000000000000000000000000000000000000000;;			&ignore,
0000000000000000000000000000000000000000;;			&s.Starttime,
0000000000000000000000000000000000000000;;			&s.VSize,
0000000000000000000000000000000000000000;;			&s.RSS,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ProcStat{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VirtualMemory returns the virtual memory size in bytes.
0000000000000000000000000000000000000000;;	func (s ProcStat) VirtualMemory() int {
0000000000000000000000000000000000000000;;		return s.VSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResidentMemory returns the resident memory size in bytes.
0000000000000000000000000000000000000000;;	func (s ProcStat) ResidentMemory() int {
0000000000000000000000000000000000000000;;		return s.RSS * os.Getpagesize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartTime returns the unix timestamp of the process in seconds.
0000000000000000000000000000000000000000;;	func (s ProcStat) StartTime() (float64, error) {
0000000000000000000000000000000000000000;;		stat, err := s.fs.NewStat()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return float64(stat.BootTime) + (float64(s.Starttime) / userHZ), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CPUTime returns the total CPU user and system time in seconds.
0000000000000000000000000000000000000000;;	func (s ProcStat) CPUTime() float64 {
0000000000000000000000000000000000000000;;		return float64(s.UTime+s.STime) / userHZ
0000000000000000000000000000000000000000;;	}
