0000000000000000000000000000000000000000;;	package jmespath
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/jmespath/go-jmespath/functions.go[Godeps/_workspace/src/github.com/jmespath/go-jmespath/functions.go][vendor/github.com/jmespath/go-jmespath/functions.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jpFunction func(arguments []interface{}) (interface{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jpType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		jpUnknown     jpType = "unknown"
0000000000000000000000000000000000000000;;		jpNumber      jpType = "number"
0000000000000000000000000000000000000000;;		jpString      jpType = "string"
0000000000000000000000000000000000000000;;		jpArray       jpType = "array"
0000000000000000000000000000000000000000;;		jpObject      jpType = "object"
0000000000000000000000000000000000000000;;		jpArrayNumber jpType = "array[number]"
0000000000000000000000000000000000000000;;		jpArrayString jpType = "array[string]"
0000000000000000000000000000000000000000;;		jpExpref      jpType = "expref"
0000000000000000000000000000000000000000;;		jpAny         jpType = "any"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type functionEntry struct {
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		arguments []argSpec
0000000000000000000000000000000000000000;;		handler   jpFunction
0000000000000000000000000000000000000000;;		hasExpRef bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type argSpec struct {
0000000000000000000000000000000000000000;;		types    []jpType
0000000000000000000000000000000000000000;;		variadic bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byExprString struct {
0000000000000000000000000000000000000000;;		intr     *treeInterpreter
0000000000000000000000000000000000000000;;		node     ASTNode
0000000000000000000000000000000000000000;;		items    []interface{}
0000000000000000000000000000000000000000;;		hasError bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *byExprString) Len() int {
0000000000000000000000000000000000000000;;		return len(a.items)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (a *byExprString) Swap(i, j int) {
0000000000000000000000000000000000000000;;		a.items[i], a.items[j] = a.items[j], a.items[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (a *byExprString) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		first, err := a.intr.Execute(a.node, a.items[i])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			// Return a dummy value.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ith, ok := first.(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		second, err := a.intr.Execute(a.node, a.items[j])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			// Return a dummy value.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jth, ok := second.(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ith < jth
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byExprFloat struct {
0000000000000000000000000000000000000000;;		intr     *treeInterpreter
0000000000000000000000000000000000000000;;		node     ASTNode
0000000000000000000000000000000000000000;;		items    []interface{}
0000000000000000000000000000000000000000;;		hasError bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *byExprFloat) Len() int {
0000000000000000000000000000000000000000;;		return len(a.items)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (a *byExprFloat) Swap(i, j int) {
0000000000000000000000000000000000000000;;		a.items[i], a.items[j] = a.items[j], a.items[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (a *byExprFloat) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		first, err := a.intr.Execute(a.node, a.items[i])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			// Return a dummy value.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ith, ok := first.(float64)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		second, err := a.intr.Execute(a.node, a.items[j])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			// Return a dummy value.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jth, ok := second.(float64)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			a.hasError = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ith < jth
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type functionCaller struct {
0000000000000000000000000000000000000000;;		functionTable map[string]functionEntry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFunctionCaller() *functionCaller {
0000000000000000000000000000000000000000;;		caller := &functionCaller{}
0000000000000000000000000000000000000000;;		caller.functionTable = map[string]functionEntry{
0000000000000000000000000000000000000000;;			"length": functionEntry{
0000000000000000000000000000000000000000;;				name: "length",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpString, jpArray, jpObject}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfLength,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"starts_with": functionEntry{
0000000000000000000000000000000000000000;;				name: "starts_with",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpString}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpString}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfStartsWith,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"abs": functionEntry{
0000000000000000000000000000000000000000;;				name: "abs",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpNumber}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfAbs,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"avg": functionEntry{
0000000000000000000000000000000000000000;;				name: "avg",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArrayNumber}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfAvg,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"ceil": functionEntry{
0000000000000000000000000000000000000000;;				name: "ceil",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpNumber}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfCeil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"contains": functionEntry{
0000000000000000000000000000000000000000;;				name: "contains",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArray, jpString}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpAny}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfContains,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"ends_with": functionEntry{
0000000000000000000000000000000000000000;;				name: "ends_with",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpString}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpString}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfEndsWith,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"floor": functionEntry{
0000000000000000000000000000000000000000;;				name: "floor",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpNumber}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfFloor,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"map": functionEntry{
0000000000000000000000000000000000000000;;				name: "amp",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpExpref}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArray}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler:   jpfMap,
0000000000000000000000000000000000000000;;				hasExpRef: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"max": functionEntry{
0000000000000000000000000000000000000000;;				name: "max",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArrayNumber, jpArrayString}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfMax,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"merge": functionEntry{
0000000000000000000000000000000000000000;;				name: "merge",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpObject}, variadic: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfMerge,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"max_by": functionEntry{
0000000000000000000000000000000000000000;;				name: "max_by",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArray}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpExpref}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler:   jpfMaxBy,
0000000000000000000000000000000000000000;;				hasExpRef: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"sum": functionEntry{
0000000000000000000000000000000000000000;;				name: "sum",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArrayNumber}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfSum,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"min": functionEntry{
0000000000000000000000000000000000000000;;				name: "min",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArrayNumber, jpArrayString}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfMin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"min_by": functionEntry{
0000000000000000000000000000000000000000;;				name: "min_by",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArray}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpExpref}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler:   jpfMinBy,
0000000000000000000000000000000000000000;;				hasExpRef: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"type": functionEntry{
0000000000000000000000000000000000000000;;				name: "type",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpAny}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfType,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"keys": functionEntry{
0000000000000000000000000000000000000000;;				name: "keys",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpObject}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfKeys,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"values": functionEntry{
0000000000000000000000000000000000000000;;				name: "values",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpObject}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfValues,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"sort": functionEntry{
0000000000000000000000000000000000000000;;				name: "sort",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArrayString, jpArrayNumber}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfSort,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"sort_by": functionEntry{
0000000000000000000000000000000000000000;;				name: "sort_by",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArray}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpExpref}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler:   jpfSortBy,
0000000000000000000000000000000000000000;;				hasExpRef: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"join": functionEntry{
0000000000000000000000000000000000000000;;				name: "join",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpString}},
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArrayString}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfJoin,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"reverse": functionEntry{
0000000000000000000000000000000000000000;;				name: "reverse",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpArray, jpString}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfReverse,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"to_array": functionEntry{
0000000000000000000000000000000000000000;;				name: "to_array",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpAny}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfToArray,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"to_string": functionEntry{
0000000000000000000000000000000000000000;;				name: "to_string",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpAny}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfToString,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"to_number": functionEntry{
0000000000000000000000000000000000000000;;				name: "to_number",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpAny}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfToNumber,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"not_null": functionEntry{
0000000000000000000000000000000000000000;;				name: "not_null",
0000000000000000000000000000000000000000;;				arguments: []argSpec{
0000000000000000000000000000000000000000;;					argSpec{types: []jpType{jpAny}, variadic: true},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handler: jpfNotNull,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return caller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *functionEntry) resolveArgs(arguments []interface{}) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		if len(e.arguments) == 0 {
0000000000000000000000000000000000000000;;			return arguments, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !e.arguments[len(e.arguments)-1].variadic {
0000000000000000000000000000000000000000;;			if len(e.arguments) != len(arguments) {
0000000000000000000000000000000000000000;;				return nil, errors.New("incorrect number of args")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, spec := range e.arguments {
0000000000000000000000000000000000000000;;				userArg := arguments[i]
0000000000000000000000000000000000000000;;				err := spec.typeCheck(userArg)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return arguments, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(arguments) < len(e.arguments) {
0000000000000000000000000000000000000000;;			return nil, errors.New("Invalid arity.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return arguments, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *argSpec) typeCheck(arg interface{}) error {
0000000000000000000000000000000000000000;;		for _, t := range a.types {
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case jpNumber:
0000000000000000000000000000000000000000;;				if _, ok := arg.(float64); ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case jpString:
0000000000000000000000000000000000000000;;				if _, ok := arg.(string); ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case jpArray:
0000000000000000000000000000000000000000;;				if _, ok := arg.([]interface{}); ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case jpObject:
0000000000000000000000000000000000000000;;				if _, ok := arg.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case jpArrayNumber:
0000000000000000000000000000000000000000;;				if _, ok := toArrayNum(arg); ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case jpArrayString:
0000000000000000000000000000000000000000;;				if _, ok := toArrayStr(arg); ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case jpAny:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case jpExpref:
0000000000000000000000000000000000000000;;				if _, ok := arg.(expRef); ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Invalid type for: %v, expected: %#v", arg, a.types)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *functionCaller) CallFunction(name string, arguments []interface{}, intr *treeInterpreter) (interface{}, error) {
0000000000000000000000000000000000000000;;		entry, ok := f.functionTable[name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("unknown function: " + name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resolvedArgs, err := entry.resolveArgs(arguments)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if entry.hasExpRef {
0000000000000000000000000000000000000000;;			var extra []interface{}
0000000000000000000000000000000000000000;;			extra = append(extra, intr)
0000000000000000000000000000000000000000;;			resolvedArgs = append(extra, resolvedArgs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return entry.handler(resolvedArgs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jpfAbs(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		num := arguments[0].(float64)
0000000000000000000000000000000000000000;;		return math.Abs(num), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jpfLength(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		arg := arguments[0]
0000000000000000000000000000000000000000;;		if c, ok := arg.(string); ok {
0000000000000000000000000000000000000000;;			return float64(utf8.RuneCountInString(c)), nil
0000000000000000000000000000000000000000;;		} else if c, ok := arg.([]interface{}); ok {
0000000000000000000000000000000000000000;;			return float64(len(c)), nil
0000000000000000000000000000000000000000;;		} else if c, ok := arg.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;			return float64(len(c)), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.New("could not compute length()")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jpfStartsWith(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		search := arguments[0].(string)
0000000000000000000000000000000000000000;;		prefix := arguments[1].(string)
0000000000000000000000000000000000000000;;		return strings.HasPrefix(search, prefix), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jpfAvg(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		// We've already type checked the value so we can safely use
0000000000000000000000000000000000000000;;		// type assertions.
0000000000000000000000000000000000000000;;		args := arguments[0].([]interface{})
0000000000000000000000000000000000000000;;		length := float64(len(args))
0000000000000000000000000000000000000000;;		numerator := 0.0
0000000000000000000000000000000000000000;;		for _, n := range args {
0000000000000000000000000000000000000000;;			numerator += n.(float64)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return numerator / length, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfCeil(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		val := arguments[0].(float64)
0000000000000000000000000000000000000000;;		return math.Ceil(val), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfContains(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		search := arguments[0]
0000000000000000000000000000000000000000;;		el := arguments[1]
0000000000000000000000000000000000000000;;		if searchStr, ok := search.(string); ok {
0000000000000000000000000000000000000000;;			if elStr, ok := el.(string); ok {
0000000000000000000000000000000000000000;;				return strings.Index(searchStr, elStr) != -1, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Otherwise this is a generic contains for []interface{}
0000000000000000000000000000000000000000;;		general := search.([]interface{})
0000000000000000000000000000000000000000;;		for _, item := range general {
0000000000000000000000000000000000000000;;			if item == el {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfEndsWith(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		search := arguments[0].(string)
0000000000000000000000000000000000000000;;		suffix := arguments[1].(string)
0000000000000000000000000000000000000000;;		return strings.HasSuffix(search, suffix), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfFloor(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		val := arguments[0].(float64)
0000000000000000000000000000000000000000;;		return math.Floor(val), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfMap(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		intr := arguments[0].(*treeInterpreter)
0000000000000000000000000000000000000000;;		exp := arguments[1].(expRef)
0000000000000000000000000000000000000000;;		node := exp.ref
0000000000000000000000000000000000000000;;		arr := arguments[2].([]interface{})
0000000000000000000000000000000000000000;;		mapped := make([]interface{}, 0, len(arr))
0000000000000000000000000000000000000000;;		for _, value := range arr {
0000000000000000000000000000000000000000;;			current, err := intr.Execute(node, value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mapped = append(mapped, current)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mapped, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfMax(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if items, ok := toArrayNum(arguments[0]); ok {
0000000000000000000000000000000000000000;;			if len(items) == 0 {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(items) == 1 {
0000000000000000000000000000000000000000;;				return items[0], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			best := items[0]
0000000000000000000000000000000000000000;;			for _, item := range items[1:] {
0000000000000000000000000000000000000000;;				if item > best {
0000000000000000000000000000000000000000;;					best = item
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return best, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Otherwise we're dealing with a max() of strings.
0000000000000000000000000000000000000000;;		items, _ := toArrayStr(arguments[0])
0000000000000000000000000000000000000000;;		if len(items) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(items) == 1 {
0000000000000000000000000000000000000000;;			return items[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		best := items[0]
0000000000000000000000000000000000000000;;		for _, item := range items[1:] {
0000000000000000000000000000000000000000;;			if item > best {
0000000000000000000000000000000000000000;;				best = item
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return best, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfMerge(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		final := make(map[string]interface{})
0000000000000000000000000000000000000000;;		for _, m := range arguments {
0000000000000000000000000000000000000000;;			mapped := m.(map[string]interface{})
0000000000000000000000000000000000000000;;			for key, value := range mapped {
0000000000000000000000000000000000000000;;				final[key] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return final, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfMaxBy(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		intr := arguments[0].(*treeInterpreter)
0000000000000000000000000000000000000000;;		arr := arguments[1].([]interface{})
0000000000000000000000000000000000000000;;		exp := arguments[2].(expRef)
0000000000000000000000000000000000000000;;		node := exp.ref
0000000000000000000000000000000000000000;;		if len(arr) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		} else if len(arr) == 1 {
0000000000000000000000000000000000000000;;			return arr[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start, err := intr.Execute(node, arr[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := start.(type) {
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			bestVal := t
0000000000000000000000000000000000000000;;			bestItem := arr[0]
0000000000000000000000000000000000000000;;			for _, item := range arr[1:] {
0000000000000000000000000000000000000000;;				result, err := intr.Execute(node, item)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				current, ok := result.(float64)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, errors.New("invalid type, must be number")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if current > bestVal {
0000000000000000000000000000000000000000;;					bestVal = current
0000000000000000000000000000000000000000;;					bestItem = item
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return bestItem, nil
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			bestVal := t
0000000000000000000000000000000000000000;;			bestItem := arr[0]
0000000000000000000000000000000000000000;;			for _, item := range arr[1:] {
0000000000000000000000000000000000000000;;				result, err := intr.Execute(node, item)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				current, ok := result.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, errors.New("invalid type, must be string")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if current > bestVal {
0000000000000000000000000000000000000000;;					bestVal = current
0000000000000000000000000000000000000000;;					bestItem = item
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return bestItem, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid type, must be number of string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfSum(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		items, _ := toArrayNum(arguments[0])
0000000000000000000000000000000000000000;;		sum := 0.0
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			sum += item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sum, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jpfMin(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if items, ok := toArrayNum(arguments[0]); ok {
0000000000000000000000000000000000000000;;			if len(items) == 0 {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(items) == 1 {
0000000000000000000000000000000000000000;;				return items[0], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			best := items[0]
0000000000000000000000000000000000000000;;			for _, item := range items[1:] {
0000000000000000000000000000000000000000;;				if item < best {
0000000000000000000000000000000000000000;;					best = item
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return best, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, _ := toArrayStr(arguments[0])
0000000000000000000000000000000000000000;;		if len(items) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(items) == 1 {
0000000000000000000000000000000000000000;;			return items[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		best := items[0]
0000000000000000000000000000000000000000;;		for _, item := range items[1:] {
0000000000000000000000000000000000000000;;			if item < best {
0000000000000000000000000000000000000000;;				best = item
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return best, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jpfMinBy(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		intr := arguments[0].(*treeInterpreter)
0000000000000000000000000000000000000000;;		arr := arguments[1].([]interface{})
0000000000000000000000000000000000000000;;		exp := arguments[2].(expRef)
0000000000000000000000000000000000000000;;		node := exp.ref
0000000000000000000000000000000000000000;;		if len(arr) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		} else if len(arr) == 1 {
0000000000000000000000000000000000000000;;			return arr[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start, err := intr.Execute(node, arr[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t, ok := start.(float64); ok {
0000000000000000000000000000000000000000;;			bestVal := t
0000000000000000000000000000000000000000;;			bestItem := arr[0]
0000000000000000000000000000000000000000;;			for _, item := range arr[1:] {
0000000000000000000000000000000000000000;;				result, err := intr.Execute(node, item)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				current, ok := result.(float64)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, errors.New("invalid type, must be number")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if current < bestVal {
0000000000000000000000000000000000000000;;					bestVal = current
0000000000000000000000000000000000000000;;					bestItem = item
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return bestItem, nil
0000000000000000000000000000000000000000;;		} else if t, ok := start.(string); ok {
0000000000000000000000000000000000000000;;			bestVal := t
0000000000000000000000000000000000000000;;			bestItem := arr[0]
0000000000000000000000000000000000000000;;			for _, item := range arr[1:] {
0000000000000000000000000000000000000000;;				result, err := intr.Execute(node, item)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				current, ok := result.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, errors.New("invalid type, must be string")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if current < bestVal {
0000000000000000000000000000000000000000;;					bestVal = current
0000000000000000000000000000000000000000;;					bestItem = item
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return bestItem, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid type, must be number of string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfType(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		arg := arguments[0]
0000000000000000000000000000000000000000;;		if _, ok := arg.(float64); ok {
0000000000000000000000000000000000000000;;			return "number", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := arg.(string); ok {
0000000000000000000000000000000000000000;;			return "string", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := arg.([]interface{}); ok {
0000000000000000000000000000000000000000;;			return "array", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := arg.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;			return "object", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if arg == nil {
0000000000000000000000000000000000000000;;			return "null", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if arg == true || arg == false {
0000000000000000000000000000000000000000;;			return "boolean", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.New("unknown type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfKeys(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		arg := arguments[0].(map[string]interface{})
0000000000000000000000000000000000000000;;		collected := make([]interface{}, 0, len(arg))
0000000000000000000000000000000000000000;;		for key := range arg {
0000000000000000000000000000000000000000;;			collected = append(collected, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return collected, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfValues(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		arg := arguments[0].(map[string]interface{})
0000000000000000000000000000000000000000;;		collected := make([]interface{}, 0, len(arg))
0000000000000000000000000000000000000000;;		for _, value := range arg {
0000000000000000000000000000000000000000;;			collected = append(collected, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return collected, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfSort(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if items, ok := toArrayNum(arguments[0]); ok {
0000000000000000000000000000000000000000;;			d := sort.Float64Slice(items)
0000000000000000000000000000000000000000;;			sort.Stable(d)
0000000000000000000000000000000000000000;;			final := make([]interface{}, len(d))
0000000000000000000000000000000000000000;;			for i, val := range d {
0000000000000000000000000000000000000000;;				final[i] = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return final, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Otherwise we're dealing with sort()'ing strings.
0000000000000000000000000000000000000000;;		items, _ := toArrayStr(arguments[0])
0000000000000000000000000000000000000000;;		d := sort.StringSlice(items)
0000000000000000000000000000000000000000;;		sort.Stable(d)
0000000000000000000000000000000000000000;;		final := make([]interface{}, len(d))
0000000000000000000000000000000000000000;;		for i, val := range d {
0000000000000000000000000000000000000000;;			final[i] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return final, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfSortBy(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		intr := arguments[0].(*treeInterpreter)
0000000000000000000000000000000000000000;;		arr := arguments[1].([]interface{})
0000000000000000000000000000000000000000;;		exp := arguments[2].(expRef)
0000000000000000000000000000000000000000;;		node := exp.ref
0000000000000000000000000000000000000000;;		if len(arr) == 0 {
0000000000000000000000000000000000000000;;			return arr, nil
0000000000000000000000000000000000000000;;		} else if len(arr) == 1 {
0000000000000000000000000000000000000000;;			return arr, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start, err := intr.Execute(node, arr[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := start.(float64); ok {
0000000000000000000000000000000000000000;;			sortable := &byExprFloat{intr, node, arr, false}
0000000000000000000000000000000000000000;;			sort.Stable(sortable)
0000000000000000000000000000000000000000;;			if sortable.hasError {
0000000000000000000000000000000000000000;;				return nil, errors.New("error in sort_by comparison")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return arr, nil
0000000000000000000000000000000000000000;;		} else if _, ok := start.(string); ok {
0000000000000000000000000000000000000000;;			sortable := &byExprString{intr, node, arr, false}
0000000000000000000000000000000000000000;;			sort.Stable(sortable)
0000000000000000000000000000000000000000;;			if sortable.hasError {
0000000000000000000000000000000000000000;;				return nil, errors.New("error in sort_by comparison")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return arr, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid type, must be number of string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfJoin(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		sep := arguments[0].(string)
0000000000000000000000000000000000000000;;		// We can't just do arguments[1].([]string), we have to
0000000000000000000000000000000000000000;;		// manually convert each item to a string.
0000000000000000000000000000000000000000;;		arrayStr := []string{}
0000000000000000000000000000000000000000;;		for _, item := range arguments[1].([]interface{}) {
0000000000000000000000000000000000000000;;			arrayStr = append(arrayStr, item.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(arrayStr, sep), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfReverse(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if s, ok := arguments[0].(string); ok {
0000000000000000000000000000000000000000;;			r := []rune(s)
0000000000000000000000000000000000000000;;			for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
0000000000000000000000000000000000000000;;				r[i], r[j] = r[j], r[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string(r), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items := arguments[0].([]interface{})
0000000000000000000000000000000000000000;;		length := len(items)
0000000000000000000000000000000000000000;;		reversed := make([]interface{}, length)
0000000000000000000000000000000000000000;;		for i, item := range items {
0000000000000000000000000000000000000000;;			reversed[length-(i+1)] = item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reversed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfToArray(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if _, ok := arguments[0].([]interface{}); ok {
0000000000000000000000000000000000000000;;			return arguments[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return arguments[:1:1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfToString(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if v, ok := arguments[0].(string); ok {
0000000000000000000000000000000000000000;;			return v, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := json.Marshal(arguments[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(result), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfToNumber(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		arg := arguments[0]
0000000000000000000000000000000000000000;;		if v, ok := arg.(float64); ok {
0000000000000000000000000000000000000000;;			return v, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := arg.(string); ok {
0000000000000000000000000000000000000000;;			conv, err := strconv.ParseFloat(v, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return conv, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := arg.([]interface{}); ok {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := arg.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if arg == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if arg == true || arg == false {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.New("unknown type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func jpfNotNull(arguments []interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		for _, arg := range arguments {
0000000000000000000000000000000000000000;;			if arg != nil {
0000000000000000000000000000000000000000;;				return arg, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
