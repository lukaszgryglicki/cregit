0000000000000000000000000000000000000000;;	package jmespath
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/jmespath/go-jmespath/util.go[Godeps/_workspace/src/github.com/jmespath/go-jmespath/util.go][vendor/github.com/jmespath/go-jmespath/util.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFalse determines if an object is false based on the JMESPath spec.
0000000000000000000000000000000000000000;;	// JMESPath defines false values to be any of:
0000000000000000000000000000000000000000;;	// - An empty string array, or hash.
0000000000000000000000000000000000000000;;	// - The boolean value false.
0000000000000000000000000000000000000000;;	// - nil
0000000000000000000000000000000000000000;;	func isFalse(value interface{}) bool {
0000000000000000000000000000000000000000;;		switch v := value.(type) {
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			return !v
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			return len(v) == 0
0000000000000000000000000000000000000000;;		case map[string]interface{}:
0000000000000000000000000000000000000000;;			return len(v) == 0
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return len(v) == 0
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Try the reflection cases before returning false.
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;		switch rv.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			// A struct type will never be false, even if
0000000000000000000000000000000000000000;;			// all of its values are the zero type.
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case reflect.Slice, reflect.Map:
0000000000000000000000000000000000000000;;			return rv.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if rv.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If it's a pointer type, we'll try to deref the pointer
0000000000000000000000000000000000000000;;			// and evaluate the pointer value for isFalse.
0000000000000000000000000000000000000000;;			element := rv.Elem()
0000000000000000000000000000000000000000;;			return isFalse(element.Interface())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjsEqual is a generic object equality check.
0000000000000000000000000000000000000000;;	// It will take two arbitrary objects and recursively determine
0000000000000000000000000000000000000000;;	// if they are equal.
0000000000000000000000000000000000000000;;	func objsEqual(left interface{}, right interface{}) bool {
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(left, right)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SliceParam refers to a single part of a slice.
0000000000000000000000000000000000000000;;	// A slice consists of a start, a stop, and a step, similar to
0000000000000000000000000000000000000000;;	// python slices.
0000000000000000000000000000000000000000;;	type sliceParam struct {
0000000000000000000000000000000000000000;;		N         int
0000000000000000000000000000000000000000;;		Specified bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Slice supports [start:stop:step] style slicing that's supported in JMESPath.
0000000000000000000000000000000000000000;;	func slice(slice []interface{}, parts []sliceParam) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		computed, err := computeSliceParams(len(slice), parts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start, stop, step := computed[0], computed[1], computed[2]
0000000000000000000000000000000000000000;;		result := []interface{}{}
0000000000000000000000000000000000000000;;		if step > 0 {
0000000000000000000000000000000000000000;;			for i := start; i < stop; i += step {
0000000000000000000000000000000000000000;;				result = append(result, slice[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for i := start; i > stop; i += step {
0000000000000000000000000000000000000000;;				result = append(result, slice[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func computeSliceParams(length int, parts []sliceParam) ([]int, error) {
0000000000000000000000000000000000000000;;		var start, stop, step int
0000000000000000000000000000000000000000;;		if !parts[2].Specified {
0000000000000000000000000000000000000000;;			step = 1
0000000000000000000000000000000000000000;;		} else if parts[2].N == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("Invalid slice, step cannot be 0")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			step = parts[2].N
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var stepValueNegative bool
0000000000000000000000000000000000000000;;		if step < 0 {
0000000000000000000000000000000000000000;;			stepValueNegative = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			stepValueNegative = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !parts[0].Specified {
0000000000000000000000000000000000000000;;			if stepValueNegative {
0000000000000000000000000000000000000000;;				start = length - 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				start = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			start = capSlice(length, parts[0].N, step)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !parts[1].Specified {
0000000000000000000000000000000000000000;;			if stepValueNegative {
0000000000000000000000000000000000000000;;				stop = -1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				stop = length
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			stop = capSlice(length, parts[1].N, step)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []int{start, stop, step}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func capSlice(length int, actual int, step int) int {
0000000000000000000000000000000000000000;;		if actual < 0 {
0000000000000000000000000000000000000000;;			actual += length
0000000000000000000000000000000000000000;;			if actual < 0 {
0000000000000000000000000000000000000000;;				if step < 0 {
0000000000000000000000000000000000000000;;					actual = -1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					actual = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if actual >= length {
0000000000000000000000000000000000000000;;			if step < 0 {
0000000000000000000000000000000000000000;;				actual = length - 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				actual = length
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return actual
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToArrayNum converts an empty interface type to a slice of float64.
0000000000000000000000000000000000000000;;	// If any element in the array cannot be converted, then nil is returned
0000000000000000000000000000000000000000;;	// along with a second value of false.
0000000000000000000000000000000000000000;;	func toArrayNum(data interface{}) ([]float64, bool) {
0000000000000000000000000000000000000000;;		// Is there a better way to do this with reflect?
0000000000000000000000000000000000000000;;		if d, ok := data.([]interface{}); ok {
0000000000000000000000000000000000000000;;			result := make([]float64, len(d))
0000000000000000000000000000000000000000;;			for i, el := range d {
0000000000000000000000000000000000000000;;				item, ok := el.(float64)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result[i] = item
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToArrayStr converts an empty interface type to a slice of strings.
0000000000000000000000000000000000000000;;	// If any element in the array cannot be converted, then nil is returned
0000000000000000000000000000000000000000;;	// along with a second value of false.  If the input data could be entirely
0000000000000000000000000000000000000000;;	// converted, then the converted data, along with a second value of true,
0000000000000000000000000000000000000000;;	// will be returned.
0000000000000000000000000000000000000000;;	func toArrayStr(data interface{}) ([]string, bool) {
0000000000000000000000000000000000000000;;		// Is there a better way to do this with reflect?
0000000000000000000000000000000000000000;;		if d, ok := data.([]interface{}); ok {
0000000000000000000000000000000000000000;;			result := make([]string, len(d))
0000000000000000000000000000000000000000;;			for i, el := range d {
0000000000000000000000000000000000000000;;				item, ok := el.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result[i] = item
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSliceType(v interface{}) bool {
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.TypeOf(v).Kind() == reflect.Slice
0000000000000000000000000000000000000000;;	}
