0000000000000000000000000000000000000000;;	package jmespath
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/jmespath/go-jmespath/interpreter.go[Godeps/_workspace/src/github.com/jmespath/go-jmespath/interpreter.go][vendor/github.com/jmespath/go-jmespath/interpreter.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* This is a tree based interpreter.  It walks the AST and directly
0000000000000000000000000000000000000000;;	   interprets the AST to search through a JSON document.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type treeInterpreter struct {
0000000000000000000000000000000000000000;;		fCall *functionCaller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInterpreter() *treeInterpreter {
0000000000000000000000000000000000000000;;		interpreter := treeInterpreter{}
0000000000000000000000000000000000000000;;		interpreter.fCall = newFunctionCaller()
0000000000000000000000000000000000000000;;		return &interpreter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type expRef struct {
0000000000000000000000000000000000000000;;		ref ASTNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Execute takes an ASTNode and input data and interprets the AST directly.
0000000000000000000000000000000000000000;;	// It will produce the result of applying the JMESPath expression associated
0000000000000000000000000000000000000000;;	// with the ASTNode to the input data "value".
0000000000000000000000000000000000000000;;	func (intr *treeInterpreter) Execute(node ASTNode, value interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		switch node.nodeType {
0000000000000000000000000000000000000000;;		case ASTComparator:
0000000000000000000000000000000000000000;;			left, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			right, err := intr.Execute(node.children[1], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch node.value {
0000000000000000000000000000000000000000;;			case tEQ:
0000000000000000000000000000000000000000;;				return objsEqual(left, right), nil
0000000000000000000000000000000000000000;;			case tNE:
0000000000000000000000000000000000000000;;				return !objsEqual(left, right), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			leftNum, ok := left.(float64)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rightNum, ok := right.(float64)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch node.value {
0000000000000000000000000000000000000000;;			case tGT:
0000000000000000000000000000000000000000;;				return leftNum > rightNum, nil
0000000000000000000000000000000000000000;;			case tGTE:
0000000000000000000000000000000000000000;;				return leftNum >= rightNum, nil
0000000000000000000000000000000000000000;;			case tLT:
0000000000000000000000000000000000000000;;				return leftNum < rightNum, nil
0000000000000000000000000000000000000000;;			case tLTE:
0000000000000000000000000000000000000000;;				return leftNum <= rightNum, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ASTExpRef:
0000000000000000000000000000000000000000;;			return expRef{ref: node.children[0]}, nil
0000000000000000000000000000000000000000;;		case ASTFunctionExpression:
0000000000000000000000000000000000000000;;			resolvedArgs := []interface{}{}
0000000000000000000000000000000000000000;;			for _, arg := range node.children {
0000000000000000000000000000000000000000;;				current, err := intr.Execute(arg, value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resolvedArgs = append(resolvedArgs, current)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return intr.fCall.CallFunction(node.value.(string), resolvedArgs, intr)
0000000000000000000000000000000000000000;;		case ASTField:
0000000000000000000000000000000000000000;;			if m, ok := value.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;				key := node.value.(string)
0000000000000000000000000000000000000000;;				return m[key], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return intr.fieldFromStruct(node.value.(string), value)
0000000000000000000000000000000000000000;;		case ASTFilterProjection:
0000000000000000000000000000000000000000;;			left, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sliceType, ok := left.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if isSliceType(left) {
0000000000000000000000000000000000000000;;					return intr.filterProjectionWithReflection(node, left)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			compareNode := node.children[2]
0000000000000000000000000000000000000000;;			collected := []interface{}{}
0000000000000000000000000000000000000000;;			for _, element := range sliceType {
0000000000000000000000000000000000000000;;				result, err := intr.Execute(compareNode, element)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !isFalse(result) {
0000000000000000000000000000000000000000;;					current, err := intr.Execute(node.children[1], element)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if current != nil {
0000000000000000000000000000000000000000;;						collected = append(collected, current)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return collected, nil
0000000000000000000000000000000000000000;;		case ASTFlatten:
0000000000000000000000000000000000000000;;			left, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sliceType, ok := left.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// If we can't type convert to []interface{}, there's
0000000000000000000000000000000000000000;;				// a chance this could still work via reflection if we're
0000000000000000000000000000000000000000;;				// dealing with user provided types.
0000000000000000000000000000000000000000;;				if isSliceType(left) {
0000000000000000000000000000000000000000;;					return intr.flattenWithReflection(left)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			flattened := []interface{}{}
0000000000000000000000000000000000000000;;			for _, element := range sliceType {
0000000000000000000000000000000000000000;;				if elementSlice, ok := element.([]interface{}); ok {
0000000000000000000000000000000000000000;;					flattened = append(flattened, elementSlice...)
0000000000000000000000000000000000000000;;				} else if isSliceType(element) {
0000000000000000000000000000000000000000;;					reflectFlat := []interface{}{}
0000000000000000000000000000000000000000;;					v := reflect.ValueOf(element)
0000000000000000000000000000000000000000;;					for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;						reflectFlat = append(reflectFlat, v.Index(i).Interface())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					flattened = append(flattened, reflectFlat...)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					flattened = append(flattened, element)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return flattened, nil
0000000000000000000000000000000000000000;;		case ASTIdentity, ASTCurrentNode:
0000000000000000000000000000000000000000;;			return value, nil
0000000000000000000000000000000000000000;;		case ASTIndex:
0000000000000000000000000000000000000000;;			if sliceType, ok := value.([]interface{}); ok {
0000000000000000000000000000000000000000;;				index := node.value.(int)
0000000000000000000000000000000000000000;;				if index < 0 {
0000000000000000000000000000000000000000;;					index += len(sliceType)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if index < len(sliceType) && index >= 0 {
0000000000000000000000000000000000000000;;					return sliceType[index], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Otherwise try via reflection.
0000000000000000000000000000000000000000;;			rv := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;			if rv.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;				index := node.value.(int)
0000000000000000000000000000000000000000;;				if index < 0 {
0000000000000000000000000000000000000000;;					index += rv.Len()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if index < rv.Len() && index >= 0 {
0000000000000000000000000000000000000000;;					v := rv.Index(index)
0000000000000000000000000000000000000000;;					return v.Interface(), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		case ASTKeyValPair:
0000000000000000000000000000000000000000;;			return intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;		case ASTLiteral:
0000000000000000000000000000000000000000;;			return node.value, nil
0000000000000000000000000000000000000000;;		case ASTMultiSelectHash:
0000000000000000000000000000000000000000;;			if value == nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			collected := make(map[string]interface{})
0000000000000000000000000000000000000000;;			for _, child := range node.children {
0000000000000000000000000000000000000000;;				current, err := intr.Execute(child, value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				key := child.value.(string)
0000000000000000000000000000000000000000;;				collected[key] = current
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return collected, nil
0000000000000000000000000000000000000000;;		case ASTMultiSelectList:
0000000000000000000000000000000000000000;;			if value == nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			collected := []interface{}{}
0000000000000000000000000000000000000000;;			for _, child := range node.children {
0000000000000000000000000000000000000000;;				current, err := intr.Execute(child, value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				collected = append(collected, current)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return collected, nil
0000000000000000000000000000000000000000;;		case ASTOrExpression:
0000000000000000000000000000000000000000;;			matched, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isFalse(matched) {
0000000000000000000000000000000000000000;;				matched, err = intr.Execute(node.children[1], value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return matched, nil
0000000000000000000000000000000000000000;;		case ASTAndExpression:
0000000000000000000000000000000000000000;;			matched, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isFalse(matched) {
0000000000000000000000000000000000000000;;				return matched, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return intr.Execute(node.children[1], value)
0000000000000000000000000000000000000000;;		case ASTNotExpression:
0000000000000000000000000000000000000000;;			matched, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isFalse(matched) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		case ASTPipe:
0000000000000000000000000000000000000000;;			result := value
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			for _, child := range node.children {
0000000000000000000000000000000000000000;;				result, err = intr.Execute(child, result)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		case ASTProjection:
0000000000000000000000000000000000000000;;			left, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sliceType, ok := left.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if isSliceType(left) {
0000000000000000000000000000000000000000;;					return intr.projectWithReflection(node, left)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			collected := []interface{}{}
0000000000000000000000000000000000000000;;			var current interface{}
0000000000000000000000000000000000000000;;			for _, element := range sliceType {
0000000000000000000000000000000000000000;;				current, err = intr.Execute(node.children[1], element)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if current != nil {
0000000000000000000000000000000000000000;;					collected = append(collected, current)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return collected, nil
0000000000000000000000000000000000000000;;		case ASTSubexpression, ASTIndexExpression:
0000000000000000000000000000000000000000;;			left, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return intr.Execute(node.children[1], left)
0000000000000000000000000000000000000000;;		case ASTSlice:
0000000000000000000000000000000000000000;;			sliceType, ok := value.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if isSliceType(value) {
0000000000000000000000000000000000000000;;					return intr.sliceWithReflection(node, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts := node.value.([]*int)
0000000000000000000000000000000000000000;;			sliceParams := make([]sliceParam, 3)
0000000000000000000000000000000000000000;;			for i, part := range parts {
0000000000000000000000000000000000000000;;				if part != nil {
0000000000000000000000000000000000000000;;					sliceParams[i].Specified = true
0000000000000000000000000000000000000000;;					sliceParams[i].N = *part
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return slice(sliceType, sliceParams)
0000000000000000000000000000000000000000;;		case ASTValueProjection:
0000000000000000000000000000000000000000;;			left, err := intr.Execute(node.children[0], value)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mapType, ok := left.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			values := make([]interface{}, len(mapType))
0000000000000000000000000000000000000000;;			for _, value := range mapType {
0000000000000000000000000000000000000000;;				values = append(values, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			collected := []interface{}{}
0000000000000000000000000000000000000000;;			for _, element := range values {
0000000000000000000000000000000000000000;;				current, err := intr.Execute(node.children[1], element)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if current != nil {
0000000000000000000000000000000000000000;;					collected = append(collected, current)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return collected, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.New("Unknown AST node: " + node.nodeType.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (intr *treeInterpreter) fieldFromStruct(key string, value interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;		first, n := utf8.DecodeRuneInString(key)
0000000000000000000000000000000000000000;;		fieldName := string(unicode.ToUpper(first)) + key[n:]
0000000000000000000000000000000000000000;;		if rv.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			v := rv.FieldByName(fieldName)
0000000000000000000000000000000000000000;;			if !v.IsValid() {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v.Interface(), nil
0000000000000000000000000000000000000000;;		} else if rv.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			// Handle multiple levels of indirection?
0000000000000000000000000000000000000000;;			if rv.IsNil() {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rv = rv.Elem()
0000000000000000000000000000000000000000;;			v := rv.FieldByName(fieldName)
0000000000000000000000000000000000000000;;			if !v.IsValid() {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v.Interface(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (intr *treeInterpreter) flattenWithReflection(value interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;		flattened := []interface{}{}
0000000000000000000000000000000000000000;;		for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;			element := v.Index(i).Interface()
0000000000000000000000000000000000000000;;			if reflect.TypeOf(element).Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;				// Then insert the contents of the element
0000000000000000000000000000000000000000;;				// slice into the flattened slice,
0000000000000000000000000000000000000000;;				// i.e flattened = append(flattened, mySlice...)
0000000000000000000000000000000000000000;;				elementV := reflect.ValueOf(element)
0000000000000000000000000000000000000000;;				for j := 0; j < elementV.Len(); j++ {
0000000000000000000000000000000000000000;;					flattened = append(
0000000000000000000000000000000000000000;;						flattened, elementV.Index(j).Interface())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				flattened = append(flattened, element)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return flattened, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (intr *treeInterpreter) sliceWithReflection(node ASTNode, value interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;		parts := node.value.([]*int)
0000000000000000000000000000000000000000;;		sliceParams := make([]sliceParam, 3)
0000000000000000000000000000000000000000;;		for i, part := range parts {
0000000000000000000000000000000000000000;;			if part != nil {
0000000000000000000000000000000000000000;;				sliceParams[i].Specified = true
0000000000000000000000000000000000000000;;				sliceParams[i].N = *part
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		final := []interface{}{}
0000000000000000000000000000000000000000;;		for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;			element := v.Index(i).Interface()
0000000000000000000000000000000000000000;;			final = append(final, element)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return slice(final, sliceParams)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (intr *treeInterpreter) filterProjectionWithReflection(node ASTNode, value interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		compareNode := node.children[2]
0000000000000000000000000000000000000000;;		collected := []interface{}{}
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;		for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;			element := v.Index(i).Interface()
0000000000000000000000000000000000000000;;			result, err := intr.Execute(compareNode, element)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isFalse(result) {
0000000000000000000000000000000000000000;;				current, err := intr.Execute(node.children[1], element)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if current != nil {
0000000000000000000000000000000000000000;;					collected = append(collected, current)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return collected, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (intr *treeInterpreter) projectWithReflection(node ASTNode, value interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		collected := []interface{}{}
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;		for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;			element := v.Index(i).Interface()
0000000000000000000000000000000000000000;;			result, err := intr.Execute(node.children[1], element)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result != nil {
0000000000000000000000000000000000000000;;				collected = append(collected, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return collected, nil
0000000000000000000000000000000000000000;;	}
