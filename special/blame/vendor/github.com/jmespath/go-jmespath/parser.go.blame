0000000000000000000000000000000000000000;;	package jmespath
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/jmespath/go-jmespath/parser.go[Godeps/_workspace/src/github.com/jmespath/go-jmespath/parser.go][vendor/github.com/jmespath/go-jmespath/parser.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type astNodeType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:generate stringer -type astNodeType
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ASTEmpty astNodeType = iota
0000000000000000000000000000000000000000;;		ASTComparator
0000000000000000000000000000000000000000;;		ASTCurrentNode
0000000000000000000000000000000000000000;;		ASTExpRef
0000000000000000000000000000000000000000;;		ASTFunctionExpression
0000000000000000000000000000000000000000;;		ASTField
0000000000000000000000000000000000000000;;		ASTFilterProjection
0000000000000000000000000000000000000000;;		ASTFlatten
0000000000000000000000000000000000000000;;		ASTIdentity
0000000000000000000000000000000000000000;;		ASTIndex
0000000000000000000000000000000000000000;;		ASTIndexExpression
0000000000000000000000000000000000000000;;		ASTKeyValPair
0000000000000000000000000000000000000000;;		ASTLiteral
0000000000000000000000000000000000000000;;		ASTMultiSelectHash
0000000000000000000000000000000000000000;;		ASTMultiSelectList
0000000000000000000000000000000000000000;;		ASTOrExpression
0000000000000000000000000000000000000000;;		ASTAndExpression
0000000000000000000000000000000000000000;;		ASTNotExpression
0000000000000000000000000000000000000000;;		ASTPipe
0000000000000000000000000000000000000000;;		ASTProjection
0000000000000000000000000000000000000000;;		ASTSubexpression
0000000000000000000000000000000000000000;;		ASTSlice
0000000000000000000000000000000000000000;;		ASTValueProjection
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASTNode represents the abstract syntax tree of a JMESPath expression.
0000000000000000000000000000000000000000;;	type ASTNode struct {
0000000000000000000000000000000000000000;;		nodeType astNodeType
0000000000000000000000000000000000000000;;		value    interface{}
0000000000000000000000000000000000000000;;		children []ASTNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node ASTNode) String() string {
0000000000000000000000000000000000000000;;		return node.PrettyPrint(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrettyPrint will pretty print the parsed AST.
0000000000000000000000000000000000000000;;	// The AST is an implementation detail and this pretty print
0000000000000000000000000000000000000000;;	// function is provided as a convenience method to help with
0000000000000000000000000000000000000000;;	// debugging.  You should not rely on its output as the internal
0000000000000000000000000000000000000000;;	// structure of the AST may change at any time.
0000000000000000000000000000000000000000;;	func (node ASTNode) PrettyPrint(indent int) string {
0000000000000000000000000000000000000000;;		spaces := strings.Repeat(" ", indent)
0000000000000000000000000000000000000000;;		output := fmt.Sprintf("%s%s {\n", spaces, node.nodeType)
0000000000000000000000000000000000000000;;		nextIndent := indent + 2
0000000000000000000000000000000000000000;;		if node.value != nil {
0000000000000000000000000000000000000000;;			if converted, ok := node.value.(fmt.Stringer); ok {
0000000000000000000000000000000000000000;;				// Account for things like comparator nodes
0000000000000000000000000000000000000000;;				// that are enums with a String() method.
0000000000000000000000000000000000000000;;				output += fmt.Sprintf("%svalue: %s\n", strings.Repeat(" ", nextIndent), converted.String())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				output += fmt.Sprintf("%svalue: %#v\n", strings.Repeat(" ", nextIndent), node.value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lastIndex := len(node.children)
0000000000000000000000000000000000000000;;		if lastIndex > 0 {
0000000000000000000000000000000000000000;;			output += fmt.Sprintf("%schildren: {\n", strings.Repeat(" ", nextIndent))
0000000000000000000000000000000000000000;;			childIndent := nextIndent + 2
0000000000000000000000000000000000000000;;			for _, elem := range node.children {
0000000000000000000000000000000000000000;;				output += elem.PrettyPrint(childIndent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output += fmt.Sprintf("%s}\n", spaces)
0000000000000000000000000000000000000000;;		return output
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bindingPowers = map[tokType]int{
0000000000000000000000000000000000000000;;		tEOF:                0,
0000000000000000000000000000000000000000;;		tUnquotedIdentifier: 0,
0000000000000000000000000000000000000000;;		tQuotedIdentifier:   0,
0000000000000000000000000000000000000000;;		tRbracket:           0,
0000000000000000000000000000000000000000;;		tRparen:             0,
0000000000000000000000000000000000000000;;		tComma:              0,
0000000000000000000000000000000000000000;;		tRbrace:             0,
0000000000000000000000000000000000000000;;		tNumber:             0,
0000000000000000000000000000000000000000;;		tCurrent:            0,
0000000000000000000000000000000000000000;;		tExpref:             0,
0000000000000000000000000000000000000000;;		tColon:              0,
0000000000000000000000000000000000000000;;		tPipe:               1,
0000000000000000000000000000000000000000;;		tOr:                 2,
0000000000000000000000000000000000000000;;		tAnd:                3,
0000000000000000000000000000000000000000;;		tEQ:                 5,
0000000000000000000000000000000000000000;;		tLT:                 5,
0000000000000000000000000000000000000000;;		tLTE:                5,
0000000000000000000000000000000000000000;;		tGT:                 5,
0000000000000000000000000000000000000000;;		tGTE:                5,
0000000000000000000000000000000000000000;;		tNE:                 5,
0000000000000000000000000000000000000000;;		tFlatten:            9,
0000000000000000000000000000000000000000;;		tStar:               20,
0000000000000000000000000000000000000000;;		tFilter:             21,
0000000000000000000000000000000000000000;;		tDot:                40,
0000000000000000000000000000000000000000;;		tNot:                45,
0000000000000000000000000000000000000000;;		tLbrace:             50,
0000000000000000000000000000000000000000;;		tLbracket:           55,
0000000000000000000000000000000000000000;;		tLparen:             60,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parser holds state about the current expression being parsed.
0000000000000000000000000000000000000000;;	type Parser struct {
0000000000000000000000000000000000000000;;		expression string
0000000000000000000000000000000000000000;;		tokens     []token
0000000000000000000000000000000000000000;;		index      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewParser creates a new JMESPath parser.
0000000000000000000000000000000000000000;;	func NewParser() *Parser {
0000000000000000000000000000000000000000;;		p := Parser{}
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse will compile a JMESPath expression.
0000000000000000000000000000000000000000;;	func (p *Parser) Parse(expression string) (ASTNode, error) {
0000000000000000000000000000000000000000;;		lexer := NewLexer()
0000000000000000000000000000000000000000;;		p.expression = expression
0000000000000000000000000000000000000000;;		p.index = 0
0000000000000000000000000000000000000000;;		tokens, err := lexer.tokenize(expression)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.tokens = tokens
0000000000000000000000000000000000000000;;		parsed, err := p.parseExpression(0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.current() != tEOF {
0000000000000000000000000000000000000000;;			return ASTNode{}, p.syntaxError(fmt.Sprintf(
0000000000000000000000000000000000000000;;				"Unexpected token at the end of the expresssion: %s", p.current()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parsed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseExpression(bindingPower int) (ASTNode, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		leftToken := p.lookaheadToken(0)
0000000000000000000000000000000000000000;;		p.advance()
0000000000000000000000000000000000000000;;		leftNode, err := p.nud(leftToken)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentToken := p.current()
0000000000000000000000000000000000000000;;		for bindingPower < bindingPowers[currentToken] {
0000000000000000000000000000000000000000;;			p.advance()
0000000000000000000000000000000000000000;;			leftNode, err = p.led(currentToken, leftNode)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentToken = p.current()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return leftNode, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseIndexExpression() (ASTNode, error) {
0000000000000000000000000000000000000000;;		if p.lookahead(0) == tColon || p.lookahead(1) == tColon {
0000000000000000000000000000000000000000;;			return p.parseSliceExpression()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		indexStr := p.lookaheadToken(0).value
0000000000000000000000000000000000000000;;		parsedInt, err := strconv.Atoi(indexStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		indexNode := ASTNode{nodeType: ASTIndex, value: parsedInt}
0000000000000000000000000000000000000000;;		p.advance()
0000000000000000000000000000000000000000;;		if err := p.match(tRbracket); err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return indexNode, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseSliceExpression() (ASTNode, error) {
0000000000000000000000000000000000000000;;		parts := []*int{nil, nil, nil}
0000000000000000000000000000000000000000;;		index := 0
0000000000000000000000000000000000000000;;		current := p.current()
0000000000000000000000000000000000000000;;		for current != tRbracket && index < 3 {
0000000000000000000000000000000000000000;;			if current == tColon {
0000000000000000000000000000000000000000;;				index++
0000000000000000000000000000000000000000;;				p.advance()
0000000000000000000000000000000000000000;;			} else if current == tNumber {
0000000000000000000000000000000000000000;;				parsedInt, err := strconv.Atoi(p.lookaheadToken(0).value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				parts[index] = &parsedInt
0000000000000000000000000000000000000000;;				p.advance()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return ASTNode{}, p.syntaxError(
0000000000000000000000000000000000000000;;					"Expected tColon or tNumber" + ", received: " + p.current().String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			current = p.current()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := p.match(tRbracket); err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ASTNode{
0000000000000000000000000000000000000000;;			nodeType: ASTSlice,
0000000000000000000000000000000000000000;;			value:    parts,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) match(tokenType tokType) error {
0000000000000000000000000000000000000000;;		if p.current() == tokenType {
0000000000000000000000000000000000000000;;			p.advance()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.syntaxError("Expected " + tokenType.String() + ", received: " + p.current().String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) led(tokenType tokType, node ASTNode) (ASTNode, error) {
0000000000000000000000000000000000000000;;		switch tokenType {
0000000000000000000000000000000000000000;;		case tDot:
0000000000000000000000000000000000000000;;			if p.current() != tStar {
0000000000000000000000000000000000000000;;				right, err := p.parseDotRHS(bindingPowers[tDot])
0000000000000000000000000000000000000000;;				return ASTNode{
0000000000000000000000000000000000000000;;					nodeType: ASTSubexpression,
0000000000000000000000000000000000000000;;					children: []ASTNode{node, right},
0000000000000000000000000000000000000000;;				}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.advance()
0000000000000000000000000000000000000000;;			right, err := p.parseProjectionRHS(bindingPowers[tDot])
0000000000000000000000000000000000000000;;			return ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTValueProjection,
0000000000000000000000000000000000000000;;				children: []ASTNode{node, right},
0000000000000000000000000000000000000000;;			}, err
0000000000000000000000000000000000000000;;		case tPipe:
0000000000000000000000000000000000000000;;			right, err := p.parseExpression(bindingPowers[tPipe])
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTPipe, children: []ASTNode{node, right}}, err
0000000000000000000000000000000000000000;;		case tOr:
0000000000000000000000000000000000000000;;			right, err := p.parseExpression(bindingPowers[tOr])
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTOrExpression, children: []ASTNode{node, right}}, err
0000000000000000000000000000000000000000;;		case tAnd:
0000000000000000000000000000000000000000;;			right, err := p.parseExpression(bindingPowers[tAnd])
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTAndExpression, children: []ASTNode{node, right}}, err
0000000000000000000000000000000000000000;;		case tLparen:
0000000000000000000000000000000000000000;;			name := node.value
0000000000000000000000000000000000000000;;			var args []ASTNode
0000000000000000000000000000000000000000;;			for p.current() != tRparen {
0000000000000000000000000000000000000000;;				expression, err := p.parseExpression(0)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p.current() == tComma {
0000000000000000000000000000000000000000;;					if err := p.match(tComma); err != nil {
0000000000000000000000000000000000000000;;						return ASTNode{}, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				args = append(args, expression)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := p.match(tRparen); err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTFunctionExpression,
0000000000000000000000000000000000000000;;				value:    name,
0000000000000000000000000000000000000000;;				children: args,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case tFilter:
0000000000000000000000000000000000000000;;			return p.parseFilter(node)
0000000000000000000000000000000000000000;;		case tFlatten:
0000000000000000000000000000000000000000;;			left := ASTNode{nodeType: ASTFlatten, children: []ASTNode{node}}
0000000000000000000000000000000000000000;;			right, err := p.parseProjectionRHS(bindingPowers[tFlatten])
0000000000000000000000000000000000000000;;			return ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTProjection,
0000000000000000000000000000000000000000;;				children: []ASTNode{left, right},
0000000000000000000000000000000000000000;;			}, err
0000000000000000000000000000000000000000;;		case tEQ, tNE, tGT, tGTE, tLT, tLTE:
0000000000000000000000000000000000000000;;			right, err := p.parseExpression(bindingPowers[tokenType])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTComparator,
0000000000000000000000000000000000000000;;				value:    tokenType,
0000000000000000000000000000000000000000;;				children: []ASTNode{node, right},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case tLbracket:
0000000000000000000000000000000000000000;;			tokenType := p.current()
0000000000000000000000000000000000000000;;			var right ASTNode
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if tokenType == tNumber || tokenType == tColon {
0000000000000000000000000000000000000000;;				right, err = p.parseIndexExpression()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return p.projectIfSlice(node, right)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Otherwise this is a projection.
0000000000000000000000000000000000000000;;			if err := p.match(tStar); err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := p.match(tRbracket); err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			right, err = p.parseProjectionRHS(bindingPowers[tStar])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTProjection,
0000000000000000000000000000000000000000;;				children: []ASTNode{node, right},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ASTNode{}, p.syntaxError("Unexpected token: " + tokenType.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) nud(token token) (ASTNode, error) {
0000000000000000000000000000000000000000;;		switch token.tokenType {
0000000000000000000000000000000000000000;;		case tJSONLiteral:
0000000000000000000000000000000000000000;;			var parsed interface{}
0000000000000000000000000000000000000000;;			err := json.Unmarshal([]byte(token.value), &parsed)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTLiteral, value: parsed}, nil
0000000000000000000000000000000000000000;;		case tStringLiteral:
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTLiteral, value: token.value}, nil
0000000000000000000000000000000000000000;;		case tUnquotedIdentifier:
0000000000000000000000000000000000000000;;			return ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTField,
0000000000000000000000000000000000000000;;				value:    token.value,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case tQuotedIdentifier:
0000000000000000000000000000000000000000;;			node := ASTNode{nodeType: ASTField, value: token.value}
0000000000000000000000000000000000000000;;			if p.current() == tLparen {
0000000000000000000000000000000000000000;;				return ASTNode{}, p.syntaxErrorToken("Can't have quoted identifier as function name.", token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return node, nil
0000000000000000000000000000000000000000;;		case tStar:
0000000000000000000000000000000000000000;;			left := ASTNode{nodeType: ASTIdentity}
0000000000000000000000000000000000000000;;			var right ASTNode
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if p.current() == tRbracket {
0000000000000000000000000000000000000000;;				right = ASTNode{nodeType: ASTIdentity}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				right, err = p.parseProjectionRHS(bindingPowers[tStar])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTValueProjection, children: []ASTNode{left, right}}, err
0000000000000000000000000000000000000000;;		case tFilter:
0000000000000000000000000000000000000000;;			return p.parseFilter(ASTNode{nodeType: ASTIdentity})
0000000000000000000000000000000000000000;;		case tLbrace:
0000000000000000000000000000000000000000;;			return p.parseMultiSelectHash()
0000000000000000000000000000000000000000;;		case tFlatten:
0000000000000000000000000000000000000000;;			left := ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTFlatten,
0000000000000000000000000000000000000000;;				children: []ASTNode{ASTNode{nodeType: ASTIdentity}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			right, err := p.parseProjectionRHS(bindingPowers[tFlatten])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTProjection, children: []ASTNode{left, right}}, nil
0000000000000000000000000000000000000000;;		case tLbracket:
0000000000000000000000000000000000000000;;			tokenType := p.current()
0000000000000000000000000000000000000000;;			//var right ASTNode
0000000000000000000000000000000000000000;;			if tokenType == tNumber || tokenType == tColon {
0000000000000000000000000000000000000000;;				right, err := p.parseIndexExpression()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return p.projectIfSlice(ASTNode{nodeType: ASTIdentity}, right)
0000000000000000000000000000000000000000;;			} else if tokenType == tStar && p.lookahead(1) == tRbracket {
0000000000000000000000000000000000000000;;				p.advance()
0000000000000000000000000000000000000000;;				p.advance()
0000000000000000000000000000000000000000;;				right, err := p.parseProjectionRHS(bindingPowers[tStar])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return ASTNode{
0000000000000000000000000000000000000000;;					nodeType: ASTProjection,
0000000000000000000000000000000000000000;;					children: []ASTNode{ASTNode{nodeType: ASTIdentity}, right},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return p.parseMultiSelectList()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case tCurrent:
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTCurrentNode}, nil
0000000000000000000000000000000000000000;;		case tExpref:
0000000000000000000000000000000000000000;;			expression, err := p.parseExpression(bindingPowers[tExpref])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTExpRef, children: []ASTNode{expression}}, nil
0000000000000000000000000000000000000000;;		case tNot:
0000000000000000000000000000000000000000;;			expression, err := p.parseExpression(bindingPowers[tNot])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTNotExpression, children: []ASTNode{expression}}, nil
0000000000000000000000000000000000000000;;		case tLparen:
0000000000000000000000000000000000000000;;			expression, err := p.parseExpression(0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := p.match(tRparen); err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return expression, nil
0000000000000000000000000000000000000000;;		case tEOF:
0000000000000000000000000000000000000000;;			return ASTNode{}, p.syntaxErrorToken("Incomplete expression", token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ASTNode{}, p.syntaxErrorToken("Invalid token: "+token.tokenType.String(), token)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseMultiSelectList() (ASTNode, error) {
0000000000000000000000000000000000000000;;		var expressions []ASTNode
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			expression, err := p.parseExpression(0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expressions = append(expressions, expression)
0000000000000000000000000000000000000000;;			if p.current() == tRbracket {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = p.match(tComma)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := p.match(tRbracket)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ASTNode{
0000000000000000000000000000000000000000;;			nodeType: ASTMultiSelectList,
0000000000000000000000000000000000000000;;			children: expressions,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseMultiSelectHash() (ASTNode, error) {
0000000000000000000000000000000000000000;;		var children []ASTNode
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			keyToken := p.lookaheadToken(0)
0000000000000000000000000000000000000000;;			if err := p.match(tUnquotedIdentifier); err != nil {
0000000000000000000000000000000000000000;;				if err := p.match(tQuotedIdentifier); err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, p.syntaxError("Expected tQuotedIdentifier or tUnquotedIdentifier")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyName := keyToken.value
0000000000000000000000000000000000000000;;			err := p.match(tColon)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value, err := p.parseExpression(0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			node := ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTKeyValPair,
0000000000000000000000000000000000000000;;				value:    keyName,
0000000000000000000000000000000000000000;;				children: []ASTNode{value},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			children = append(children, node)
0000000000000000000000000000000000000000;;			if p.current() == tComma {
0000000000000000000000000000000000000000;;				err := p.match(tComma)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if p.current() == tRbrace {
0000000000000000000000000000000000000000;;				err := p.match(tRbrace)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return ASTNode{}, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ASTNode{
0000000000000000000000000000000000000000;;			nodeType: ASTMultiSelectHash,
0000000000000000000000000000000000000000;;			children: children,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) projectIfSlice(left ASTNode, right ASTNode) (ASTNode, error) {
0000000000000000000000000000000000000000;;		indexExpr := ASTNode{
0000000000000000000000000000000000000000;;			nodeType: ASTIndexExpression,
0000000000000000000000000000000000000000;;			children: []ASTNode{left, right},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if right.nodeType == ASTSlice {
0000000000000000000000000000000000000000;;			right, err := p.parseProjectionRHS(bindingPowers[tStar])
0000000000000000000000000000000000000000;;			return ASTNode{
0000000000000000000000000000000000000000;;				nodeType: ASTProjection,
0000000000000000000000000000000000000000;;				children: []ASTNode{indexExpr, right},
0000000000000000000000000000000000000000;;			}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return indexExpr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (p *Parser) parseFilter(node ASTNode) (ASTNode, error) {
0000000000000000000000000000000000000000;;		var right, condition ASTNode
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		condition, err = p.parseExpression(0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := p.match(tRbracket); err != nil {
0000000000000000000000000000000000000000;;			return ASTNode{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.current() == tFlatten {
0000000000000000000000000000000000000000;;			right = ASTNode{nodeType: ASTIdentity}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			right, err = p.parseProjectionRHS(bindingPowers[tFilter])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ASTNode{
0000000000000000000000000000000000000000;;			nodeType: ASTFilterProjection,
0000000000000000000000000000000000000000;;			children: []ASTNode{node, right, condition},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseDotRHS(bindingPower int) (ASTNode, error) {
0000000000000000000000000000000000000000;;		lookahead := p.current()
0000000000000000000000000000000000000000;;		if tokensOneOf([]tokType{tQuotedIdentifier, tUnquotedIdentifier, tStar}, lookahead) {
0000000000000000000000000000000000000000;;			return p.parseExpression(bindingPower)
0000000000000000000000000000000000000000;;		} else if lookahead == tLbracket {
0000000000000000000000000000000000000000;;			if err := p.match(tLbracket); err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.parseMultiSelectList()
0000000000000000000000000000000000000000;;		} else if lookahead == tLbrace {
0000000000000000000000000000000000000000;;			if err := p.match(tLbrace); err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.parseMultiSelectHash()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ASTNode{}, p.syntaxError("Expected identifier, lbracket, or lbrace")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseProjectionRHS(bindingPower int) (ASTNode, error) {
0000000000000000000000000000000000000000;;		current := p.current()
0000000000000000000000000000000000000000;;		if bindingPowers[current] < 10 {
0000000000000000000000000000000000000000;;			return ASTNode{nodeType: ASTIdentity}, nil
0000000000000000000000000000000000000000;;		} else if current == tLbracket {
0000000000000000000000000000000000000000;;			return p.parseExpression(bindingPower)
0000000000000000000000000000000000000000;;		} else if current == tFilter {
0000000000000000000000000000000000000000;;			return p.parseExpression(bindingPower)
0000000000000000000000000000000000000000;;		} else if current == tDot {
0000000000000000000000000000000000000000;;			err := p.match(tDot)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ASTNode{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.parseDotRHS(bindingPower)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ASTNode{}, p.syntaxError("Error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) lookahead(number int) tokType {
0000000000000000000000000000000000000000;;		return p.lookaheadToken(number).tokenType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) current() tokType {
0000000000000000000000000000000000000000;;		return p.lookahead(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) lookaheadToken(number int) token {
0000000000000000000000000000000000000000;;		return p.tokens[p.index+number]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) advance() {
0000000000000000000000000000000000000000;;		p.index++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tokensOneOf(elements []tokType, token tokType) bool {
0000000000000000000000000000000000000000;;		for _, elem := range elements {
0000000000000000000000000000000000000000;;			if elem == token {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) syntaxError(msg string) SyntaxError {
0000000000000000000000000000000000000000;;		return SyntaxError{
0000000000000000000000000000000000000000;;			msg:        msg,
0000000000000000000000000000000000000000;;			Expression: p.expression,
0000000000000000000000000000000000000000;;			Offset:     p.lookaheadToken(0).position,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a SyntaxError based on the provided token.
0000000000000000000000000000000000000000;;	// This differs from syntaxError() which creates a SyntaxError
0000000000000000000000000000000000000000;;	// based on the current lookahead token.
0000000000000000000000000000000000000000;;	func (p *Parser) syntaxErrorToken(msg string, t token) SyntaxError {
0000000000000000000000000000000000000000;;		return SyntaxError{
0000000000000000000000000000000000000000;;			msg:        msg,
0000000000000000000000000000000000000000;;			Expression: p.expression,
0000000000000000000000000000000000000000;;			Offset:     t.position,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
