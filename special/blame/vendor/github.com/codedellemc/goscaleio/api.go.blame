0000000000000000000000000000000000000000;;	package goscaleio
035d8c1abe71a2fddb25ce05367578ce9dfeca59;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log "github.com/Sirupsen/logrus"
0000000000000000000000000000000000000000;;		types "github.com/codedellemc/goscaleio/types/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		Token         string
0000000000000000000000000000000000000000;;		SIOEndpoint   url.URL
0000000000000000000000000000000000000000;;		Http          http.Client
0000000000000000000000000000000000000000;;		Insecure      string
0000000000000000000000000000000000000000;;		ShowBody      bool
0000000000000000000000000000000000000000;;		configConnect *ConfigConnect
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Cluster struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConfigConnect struct {
0000000000000000000000000000000000000000;;		Endpoint string
0000000000000000000000000000000000000000;;		Version  string
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;		Password string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientPersistent struct {
0000000000000000000000000000000000000000;;		configConnect *ConfigConnect
0000000000000000000000000000000000000000;;		client        *Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *Client) getVersion() (string, error) {
0000000000000000000000000000000000000000;;		endpoint := client.SIOEndpoint
0000000000000000000000000000000000000000;;		endpoint.Path = "/api/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := client.NewRequest(map[string]string{}, "GET", endpoint, nil)
0000000000000000000000000000000000000000;;		req.SetBasicAuth("", client.Token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.retryCheckResp(&client.Http, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("problem getting response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bs, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", errors.New("error reading body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version := string(bs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client.ShowBody {
0000000000000000000000000000000000000000;;			log.WithField("body", version).Debug(
0000000000000000000000000000000000000000;;				"printing version message body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version = strings.TrimRight(version, `"`)
0000000000000000000000000000000000000000;;		version = strings.TrimLeft(version, `"`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionRX := regexp.MustCompile(`^(\d+?\.\d+?).*$`)
0000000000000000000000000000000000000000;;		if m := versionRX.FindStringSubmatch(version); len(m) > 0 {
0000000000000000000000000000000000000000;;			return m[1], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return version, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *Client) updateVersion() error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version, err := client.getVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client.configConnect.Version = version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *Client) Authenticate(configConnect *ConfigConnect) (Cluster, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configConnect.Version = client.configConnect.Version
0000000000000000000000000000000000000000;;		client.configConnect = configConnect
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint := client.SIOEndpoint
0000000000000000000000000000000000000000;;		endpoint.Path += "/login"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := client.NewRequest(map[string]string{}, "GET", endpoint, nil)
0000000000000000000000000000000000000000;;		req.SetBasicAuth(configConnect.Username, configConnect.Password)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		httpClient := &client.Http
0000000000000000000000000000000000000000;;		resp, errBody, err := client.checkResp(httpClient.Do(req))
0000000000000000000000000000000000000000;;		if errBody == nil && err != nil {
0000000000000000000000000000000000000000;;			return Cluster{}, err
0000000000000000000000000000000000000000;;		} else if errBody != nil && err != nil {
0000000000000000000000000000000000000000;;			if resp == nil {
0000000000000000000000000000000000000000;;				return Cluster{}, errors.New("Problem getting response from endpoint")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Cluster{}, errors.New(errBody.Message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bs, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Cluster{}, errors.New("error reading body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := string(bs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client.ShowBody {
0000000000000000000000000000000000000000;;			log.WithField("body", token).Debug(
0000000000000000000000000000000000000000;;				"printing authentication message body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token = strings.TrimRight(token, `"`)
0000000000000000000000000000000000000000;;		token = strings.TrimLeft(token, `"`)
0000000000000000000000000000000000000000;;		client.Token = token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client.configConnect.Version == "" {
0000000000000000000000000000000000000000;;			err = client.updateVersion()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return Cluster{}, errors.New("error getting version of ScaleIO")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Cluster{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//https://github.com/chrislusf/teeproxy/blob/master/teeproxy.go
0000000000000000000000000000000000000000;;	type nopCloser struct {
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nopCloser) Close() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DuplicateRequest(request *http.Request) (request1 *http.Request, request2 *http.Request) {
0000000000000000000000000000000000000000;;		request1 = &http.Request{
0000000000000000000000000000000000000000;;			Method:        request.Method,
0000000000000000000000000000000000000000;;			URL:           request.URL,
0000000000000000000000000000000000000000;;			Proto:         "HTTP/1.1",
0000000000000000000000000000000000000000;;			ProtoMajor:    1,
0000000000000000000000000000000000000000;;			ProtoMinor:    1,
0000000000000000000000000000000000000000;;			Header:        request.Header,
0000000000000000000000000000000000000000;;			Host:          request.Host,
0000000000000000000000000000000000000000;;			ContentLength: request.ContentLength,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request2 = &http.Request{
0000000000000000000000000000000000000000;;			Method:        request.Method,
0000000000000000000000000000000000000000;;			URL:           request.URL,
0000000000000000000000000000000000000000;;			Proto:         "HTTP/1.1",
0000000000000000000000000000000000000000;;			ProtoMajor:    1,
0000000000000000000000000000000000000000;;			ProtoMinor:    1,
0000000000000000000000000000000000000000;;			Header:        request.Header,
0000000000000000000000000000000000000000;;			Host:          request.Host,
0000000000000000000000000000000000000000;;			ContentLength: request.ContentLength,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if request.Body != nil {
0000000000000000000000000000000000000000;;			b1 := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			b2 := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			w := io.MultiWriter(b1, b2)
0000000000000000000000000000000000000000;;			io.Copy(w, request.Body)
0000000000000000000000000000000000000000;;			request1.Body = nopCloser{b1}
0000000000000000000000000000000000000000;;			request2.Body = nopCloser{b2}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer request.Body.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *Client) retryCheckResp(httpClient *http.Client, req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req1, req2 := DuplicateRequest(req)
0000000000000000000000000000000000000000;;		resp, errBody, err := client.checkResp(httpClient.Do(req1))
0000000000000000000000000000000000000000;;		if errBody == nil && err != nil {
0000000000000000000000000000000000000000;;			return &http.Response{}, err
0000000000000000000000000000000000000000;;		} else if errBody != nil && err != nil {
0000000000000000000000000000000000000000;;			if resp == nil {
0000000000000000000000000000000000000000;;				return nil, errors.New("Problem getting response from endpoint")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if resp.StatusCode == 401 && errBody.MajorErrorCode == 0 {
0000000000000000000000000000000000000000;;				_, err := client.Authenticate(client.configConnect)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Error re-authenticating: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;				resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				req2.SetBasicAuth("", client.Token)
0000000000000000000000000000000000000000;;				resp, errBody, err = client.checkResp(httpClient.Do(req2))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return &http.Response{}, errors.New(errBody.Message)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return &http.Response{}, errors.New(errBody.Message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *Client) checkResp(resp *http.Response, err error) (*http.Response, *types.Error, error) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return resp, &types.Error{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch i := resp.StatusCode; {
0000000000000000000000000000000000000000;;		// Valid request, return the response.
0000000000000000000000000000000000000000;;		case i == 200 || i == 201 || i == 202 || i == 204:
0000000000000000000000000000000000000000;;			return resp, &types.Error{}, nil
0000000000000000000000000000000000000000;;		// Invalid request, parse the XML error returned and return it.
0000000000000000000000000000000000000000;;		case i == 400 || i == 401 || i == 403 || i == 404 || i == 405 || i == 406 || i == 409 || i == 415 || i == 500 || i == 503 || i == 504:
0000000000000000000000000000000000000000;;			errBody, err := client.parseErr(resp)
0000000000000000000000000000000000000000;;			return resp, errBody, err
0000000000000000000000000000000000000000;;		// Unhandled response.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, &types.Error{}, fmt.Errorf("unhandled API response, please report this issue, status code: %s", resp.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *Client) decodeBody(resp *http.Response, out interface{}) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if client.ShowBody {
0000000000000000000000000000000000000000;;			var prettyJSON bytes.Buffer
0000000000000000000000000000000000000000;;			_ = json.Indent(&prettyJSON, body, "", "  ")
0000000000000000000000000000000000000000;;			log.WithField("body", prettyJSON.String()).Debug(
0000000000000000000000000000000000000000;;				"print decoded body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = json.Unmarshal(body, &out); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *Client) parseErr(resp *http.Response) (*types.Error, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errBody := new(types.Error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if there was an error decoding the body, just return that
0000000000000000000000000000000000000000;;		if err := client.decodeBody(resp, errBody); err != nil {
0000000000000000000000000000000000000000;;			return &types.Error{}, fmt.Errorf("error parsing error body for non-200 request: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errBody, fmt.Errorf("API (%d) Error: %d: %s", resp.StatusCode, errBody.MajorErrorCode, errBody.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) NewRequest(params map[string]string, method string, u url.URL, body io.Reader) *http.Request {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if log.GetLevel() == log.DebugLevel && c.ShowBody && body != nil {
0000000000000000000000000000000000000000;;			buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			buf.ReadFrom(body)
0000000000000000000000000000000000000000;;			log.WithField("body", buf.String()).Debug("print new request body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := url.Values{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range params {
0000000000000000000000000000000000000000;;			p.Add(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.RawQuery = p.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest(method, u.String(), body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClient() (client *Client, err error) {
0000000000000000000000000000000000000000;;		return NewClientWithArgs(
0000000000000000000000000000000000000000;;			os.Getenv("GOSCALEIO_ENDPOINT"),
0000000000000000000000000000000000000000;;			os.Getenv("GOSCALEIO_VERSION"),
0000000000000000000000000000000000000000;;			os.Getenv("GOSCALEIO_INSECURE") == "true",
0000000000000000000000000000000000000000;;			os.Getenv("GOSCALEIO_USECERTS") == "true")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClientWithArgs(
0000000000000000000000000000000000000000;;		endpoint string,
0000000000000000000000000000000000000000;;		version string,
0000000000000000000000000000000000000000;;		insecure,
0000000000000000000000000000000000000000;;		useCerts bool) (client *Client, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fields := map[string]interface{}{
0000000000000000000000000000000000000000;;			"endpoint": endpoint,
0000000000000000000000000000000000000000;;			"insecure": insecure,
0000000000000000000000000000000000000000;;			"useCerts": useCerts,
0000000000000000000000000000000000000000;;			"version":  version,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var uri *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if endpoint != "" {
0000000000000000000000000000000000000000;;			uri, err = url.ParseRequestURI(endpoint)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return &Client{},
0000000000000000000000000000000000000000;;					withFieldsE(fields, "error parsing endpoint", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return &Client{},
0000000000000000000000000000000000000000;;				withFields(fields, "endpoint is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client = &Client{
0000000000000000000000000000000000000000;;			SIOEndpoint: *uri,
0000000000000000000000000000000000000000;;			Http: http.Client{
0000000000000000000000000000000000000000;;				Transport: &http.Transport{
0000000000000000000000000000000000000000;;					TLSHandshakeTimeout: 120 * time.Second,
0000000000000000000000000000000000000000;;					TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;						InsecureSkipVerify: insecure,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if useCerts {
0000000000000000000000000000000000000000;;			pool := x509.NewCertPool()
0000000000000000000000000000000000000000;;			pool.AppendCertsFromPEM(pemCerts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			client.Http.Transport = &http.Transport{
0000000000000000000000000000000000000000;;				TLSHandshakeTimeout: 120 * time.Second,
0000000000000000000000000000000000000000;;				TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;					RootCAs:            pool,
0000000000000000000000000000000000000000;;					InsecureSkipVerify: insecure,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.configConnect = &ConfigConnect{
0000000000000000000000000000000000000000;;			Version: version,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetLink(links []*types.Link, rel string) (*types.Link, error) {
0000000000000000000000000000000000000000;;		for _, link := range links {
0000000000000000000000000000000000000000;;			if link.Rel == rel {
0000000000000000000000000000000000000000;;				return link, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &types.Link{}, errors.New("Couldn't find link")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func withFields(fields map[string]interface{}, message string) error {
0000000000000000000000000000000000000000;;		return withFieldsE(fields, message, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func withFieldsE(
0000000000000000000000000000000000000000;;		fields map[string]interface{}, message string, inner error) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fields == nil {
0000000000000000000000000000000000000000;;			fields = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if inner != nil {
0000000000000000000000000000000000000000;;			fields["inner"] = inner
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := 0
0000000000000000000000000000000000000000;;		l := len(fields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		for k, v := range fields {
0000000000000000000000000000000000000000;;			if x < l-1 {
0000000000000000000000000000000000000000;;				b.WriteString(fmt.Sprintf("%s=%v,", k, v))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				b.WriteString(fmt.Sprintf("%s=%v", k, v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x = x + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newf("%s %s", message, b.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newf(format string, a ...interface{}) error {
0000000000000000000000000000000000000000;;		return errors.New(fmt.Sprintf(format, a))
0000000000000000000000000000000000000000;;	}
