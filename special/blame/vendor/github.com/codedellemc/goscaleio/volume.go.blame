0000000000000000000000000000000000000000;;	package goscaleio
035d8c1abe71a2fddb25ce05367578ce9dfeca59;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		types "github.com/codedellemc/goscaleio/types/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SdcMappedVolume struct {
0000000000000000000000000000000000000000;;		MdmID     string
0000000000000000000000000000000000000000;;		VolumeID  string
0000000000000000000000000000000000000000;;		SdcDevice string
0000000000000000000000000000000000000000;;		// Mounted   bool
0000000000000000000000000000000000000000;;		// MountPath bool
0000000000000000000000000000000000000000;;		// Mapped    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Volume struct {
0000000000000000000000000000000000000000;;		Volume *types.Volume
0000000000000000000000000000000000000000;;		client *Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewVolume(client *Client) *Volume {
0000000000000000000000000000000000000000;;		return &Volume{
0000000000000000000000000000000000000000;;			Volume: new(types.Volume),
0000000000000000000000000000000000000000;;			client: client,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storagePool *StoragePool) GetVolume(volumehref, volumeid, ancestorvolumeid, volumename string, getSnapshots bool) (volumes []*types.Volume, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint := storagePool.client.SIOEndpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volumename != "" {
0000000000000000000000000000000000000000;;			volumeid, err = storagePool.FindVolumeID(volumename)
0000000000000000000000000000000000000000;;			if err != nil && err.Error() == "Not found" {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []*types.Volume{}, fmt.Errorf("Error: problem finding volume: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volumeid != "" {
0000000000000000000000000000000000000000;;			endpoint.Path = fmt.Sprintf("/api/instances/Volume::%s", volumeid)
0000000000000000000000000000000000000000;;		} else if volumehref == "" {
0000000000000000000000000000000000000000;;			link, err := GetLink(storagePool.StoragePool.Links, "/api/StoragePool/relationship/Volume")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []*types.Volume{}, errors.New("Error: problem finding link")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			endpoint.Path = link.HREF
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			endpoint.Path = volumehref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := storagePool.client.NewRequest(map[string]string{}, "GET", endpoint, nil)
0000000000000000000000000000000000000000;;		req.SetBasicAuth("", storagePool.client.Token)
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "application/json;version="+storagePool.client.configConnect.Version)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := storagePool.client.retryCheckResp(&storagePool.client.Http, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []*types.Volume{}, fmt.Errorf("problem getting response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if volumehref == "" && volumeid == "" {
0000000000000000000000000000000000000000;;			if err = storagePool.client.decodeBody(resp, &volumes); err != nil {
0000000000000000000000000000000000000000;;				return []*types.Volume{}, fmt.Errorf("error decoding storage pool response: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var volumesNew []*types.Volume
0000000000000000000000000000000000000000;;			for _, volume := range volumes {
0000000000000000000000000000000000000000;;				if (!getSnapshots && volume.AncestorVolumeID == ancestorvolumeid) || (getSnapshots && volume.AncestorVolumeID != "") {
0000000000000000000000000000000000000000;;					volumesNew = append(volumesNew, volume)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumes = volumesNew
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			volume := &types.Volume{}
0000000000000000000000000000000000000000;;			if err = storagePool.client.decodeBody(resp, &volume); err != nil {
0000000000000000000000000000000000000000;;				return []*types.Volume{}, fmt.Errorf("error decoding instances response: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			volumes = append(volumes, volume)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storagePool *StoragePool) FindVolumeID(volumename string) (volumeID string, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint := storagePool.client.SIOEndpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeQeryIdByKeyParam := &types.VolumeQeryIdByKeyParam{}
0000000000000000000000000000000000000000;;		volumeQeryIdByKeyParam.Name = volumename
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonOutput, err := json.Marshal(&volumeQeryIdByKeyParam)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("error marshaling: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoint.Path = fmt.Sprintf("/api/types/Volume/instances/action/queryIdByKey")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := storagePool.client.NewRequest(map[string]string{}, "POST", endpoint, bytes.NewBufferString(string(jsonOutput)))
0000000000000000000000000000000000000000;;		req.SetBasicAuth("", storagePool.client.Token)
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "application/json;version="+storagePool.client.configConnect.Version)
0000000000000000000000000000000000000000;;		req.Header.Add("Content-Type", "application/json;version="+storagePool.client.configConnect.Version)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := storagePool.client.retryCheckResp(&storagePool.client.Http, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bs, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", errors.New("error reading body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID = string(bs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volumeID = strings.TrimRight(volumeID, `"`)
0000000000000000000000000000000000000000;;		volumeID = strings.TrimLeft(volumeID, `"`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetLocalVolumeMap() (mappedVolumes []*SdcMappedVolume, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get sdc kernel guid
0000000000000000000000000000000000000000;;		// /bin/emc/scaleio/drv_cfg --query_guid
0000000000000000000000000000000000000000;;		// sdcKernelGuid := "271bad82-08ee-44f2-a2b1-7e2787c27be1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mappedVolumesMap := make(map[string]*SdcMappedVolume)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := exec.Command("/opt/emc/scaleio/sdc/bin/drv_cfg", "--query_vols").Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []*SdcMappedVolume{}, fmt.Errorf("Error querying volumes: ", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := string(out)
0000000000000000000000000000000000000000;;		lines := strings.Split(result, "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			split := strings.Split(line, " ")
0000000000000000000000000000000000000000;;			if split[0] == "VOL-ID" {
0000000000000000000000000000000000000000;;				mappedVolume := &SdcMappedVolume{MdmID: split[3], VolumeID: split[1]}
0000000000000000000000000000000000000000;;				mdmVolumeID := fmt.Sprintf("%s-%s", mappedVolume.MdmID, mappedVolume.VolumeID)
0000000000000000000000000000000000000000;;				mappedVolumesMap[mdmVolumeID] = mappedVolume
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskIDPath := "/dev/disk/by-id"
0000000000000000000000000000000000000000;;		files, _ := ioutil.ReadDir(diskIDPath)
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile(`^emc-vol-\w*-\w*$`)
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			matched := r.MatchString(f.Name())
0000000000000000000000000000000000000000;;			if matched {
0000000000000000000000000000000000000000;;				mdmVolumeID := strings.Replace(f.Name(), "emc-vol-", "", 1)
0000000000000000000000000000000000000000;;				devPath, _ := filepath.EvalSymlinks(fmt.Sprintf("%s/%s", diskIDPath, f.Name()))
0000000000000000000000000000000000000000;;				if _, ok := mappedVolumesMap[mdmVolumeID]; ok {
0000000000000000000000000000000000000000;;					mappedVolumesMap[mdmVolumeID].SdcDevice = devPath
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(mappedVolumesMap))
0000000000000000000000000000000000000000;;		for key := range mappedVolumesMap {
0000000000000000000000000000000000000000;;			keys = append(keys, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			mappedVolumes = append(mappedVolumes, mappedVolumesMap[key])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mappedVolumes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (storagePool *StoragePool) CreateVolume(volume *types.VolumeParam) (volumeResp *types.VolumeResp, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint := storagePool.client.SIOEndpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint.Path = "/api/types/Volume/instances"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		volume.StoragePoolID = storagePool.StoragePool.ID
0000000000000000000000000000000000000000;;		volume.ProtectionDomainID = storagePool.StoragePool.ProtectionDomainID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonOutput, err := json.Marshal(&volume)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &types.VolumeResp{}, fmt.Errorf("error marshaling: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := storagePool.client.NewRequest(map[string]string{}, "POST", endpoint, bytes.NewBufferString(string(jsonOutput)))
0000000000000000000000000000000000000000;;		req.SetBasicAuth("", storagePool.client.Token)
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "application/json;version="+storagePool.client.configConnect.Version)
0000000000000000000000000000000000000000;;		req.Header.Add("Content-Type", "application/json;version="+storagePool.client.configConnect.Version)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := storagePool.client.retryCheckResp(&storagePool.client.Http, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &types.VolumeResp{}, fmt.Errorf("problem getting response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = storagePool.client.decodeBody(resp, &volumeResp); err != nil {
0000000000000000000000000000000000000000;;			return &types.VolumeResp{}, fmt.Errorf("error decoding volume creation response: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return volumeResp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volume *Volume) GetVTree() (vtree *types.VTree, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint := volume.client.SIOEndpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		link, err := GetLink(volume.Volume.Links, "/api/parent/relationship/vtreeId")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &types.VTree{}, errors.New("Error: problem finding link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoint.Path = link.HREF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := volume.client.NewRequest(map[string]string{}, "GET", endpoint, nil)
0000000000000000000000000000000000000000;;		req.SetBasicAuth("", volume.client.Token)
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "application/json;version="+volume.client.configConnect.Version)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := volume.client.retryCheckResp(&volume.client.Http, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &types.VTree{}, fmt.Errorf("problem getting response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = volume.client.decodeBody(resp, &vtree); err != nil {
0000000000000000000000000000000000000000;;			return &types.VTree{}, fmt.Errorf("error decoding vtree response: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vtree, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (volume *Volume) RemoveVolume(removeMode string) (err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint := volume.client.SIOEndpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		link, err := GetLink(volume.Volume.Links, "self")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return errors.New("Error: problem finding link")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoint.Path = fmt.Sprintf("%v/action/removeVolume", link.HREF)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if removeMode == "" {
0000000000000000000000000000000000000000;;			removeMode = "ONLY_ME"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		removeVolumeParam := &types.RemoveVolumeParam{
0000000000000000000000000000000000000000;;			RemoveMode: removeMode,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonOutput, err := json.Marshal(&removeVolumeParam)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error marshaling: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := volume.client.NewRequest(map[string]string{}, "POST", endpoint, bytes.NewBufferString(string(jsonOutput)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.SetBasicAuth("", volume.client.Token)
0000000000000000000000000000000000000000;;		req.Header.Add("Accept", "application/json;version="+volume.client.configConnect.Version)
0000000000000000000000000000000000000000;;		req.Header.Add("Content-Type", "application/json;version="+volume.client.configConnect.Version)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := volume.client.retryCheckResp(&volume.client.Http, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("problem getting response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
