0000000000000000000000000000000000000000;;	package cron
ea55b7c1ed132cbd99ded4ceb08387d7aff333ea;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Configuration options for creating a parser. Most options specify which
0000000000000000000000000000000000000000;;	// fields should be included, while others enable features. If a field is not
0000000000000000000000000000000000000000;;	// included the parser will assume a default value. These options do not change
0000000000000000000000000000000000000000;;	// the order fields are parse in.
0000000000000000000000000000000000000000;;	type ParseOption int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Second      ParseOption = 1 << iota // Seconds field, default 0
0000000000000000000000000000000000000000;;		Minute                              // Minutes field, default 0
0000000000000000000000000000000000000000;;		Hour                                // Hours field, default 0
0000000000000000000000000000000000000000;;		Dom                                 // Day of month field, default *
0000000000000000000000000000000000000000;;		Month                               // Month field, default *
0000000000000000000000000000000000000000;;		Dow                                 // Day of week field, default *
0000000000000000000000000000000000000000;;		DowOptional                         // Optional day of week field, default *
0000000000000000000000000000000000000000;;		Descriptor                          // Allow descriptors such as @monthly, @weekly, etc.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var places = []ParseOption{
0000000000000000000000000000000000000000;;		Second,
0000000000000000000000000000000000000000;;		Minute,
0000000000000000000000000000000000000000;;		Hour,
0000000000000000000000000000000000000000;;		Dom,
0000000000000000000000000000000000000000;;		Month,
0000000000000000000000000000000000000000;;		Dow,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaults = []string{
0000000000000000000000000000000000000000;;		"0",
0000000000000000000000000000000000000000;;		"0",
0000000000000000000000000000000000000000;;		"0",
0000000000000000000000000000000000000000;;		"*",
0000000000000000000000000000000000000000;;		"*",
0000000000000000000000000000000000000000;;		"*",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A custom Parser that can be configured.
0000000000000000000000000000000000000000;;	type Parser struct {
0000000000000000000000000000000000000000;;		options   ParseOption
0000000000000000000000000000000000000000;;		optionals int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a custom Parser with custom options.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  // Standard parser without descriptors
0000000000000000000000000000000000000000;;	//  specParser := NewParser(Minute | Hour | Dom | Month | Dow)
0000000000000000000000000000000000000000;;	//  sched, err := specParser.Parse("0 0 15 */3 *")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  // Same as above, just excludes time fields
0000000000000000000000000000000000000000;;	//  subsParser := NewParser(Dom | Month | Dow)
0000000000000000000000000000000000000000;;	//  sched, err := specParser.Parse("15 */3 *")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  // Same as above, just makes Dow optional
0000000000000000000000000000000000000000;;	//  subsParser := NewParser(Dom | Month | DowOptional)
0000000000000000000000000000000000000000;;	//  sched, err := specParser.Parse("15 */3")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func NewParser(options ParseOption) Parser {
0000000000000000000000000000000000000000;;		optionals := 0
0000000000000000000000000000000000000000;;		if options&DowOptional > 0 {
0000000000000000000000000000000000000000;;			options |= Dow
0000000000000000000000000000000000000000;;			optionals++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Parser{options, optionals}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse returns a new crontab schedule representing the given spec.
0000000000000000000000000000000000000000;;	// It returns a descriptive error if the spec is not valid.
0000000000000000000000000000000000000000;;	// It accepts crontab specs and features configured by NewParser.
0000000000000000000000000000000000000000;;	func (p Parser) Parse(spec string) (Schedule, error) {
0000000000000000000000000000000000000000;;		if len(spec) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Empty spec string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if spec[0] == '@' && p.options&Descriptor > 0 {
0000000000000000000000000000000000000000;;			return parseDescriptor(spec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Figure out how many fields we need
0000000000000000000000000000000000000000;;		max := 0
0000000000000000000000000000000000000000;;		for _, place := range places {
0000000000000000000000000000000000000000;;			if p.options&place > 0 {
0000000000000000000000000000000000000000;;				max++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		min := max - p.optionals
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split fields on whitespace
0000000000000000000000000000000000000000;;		fields := strings.Fields(spec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate number of fields
0000000000000000000000000000000000000000;;		if count := len(fields); count < min || count > max {
0000000000000000000000000000000000000000;;			if min == max {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Expected exactly %d fields, found %d: %s", min, count, spec)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Expected %d to %d fields, found %d: %s", min, max, count, spec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill in missing fields
0000000000000000000000000000000000000000;;		fields = expandFields(fields, p.options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		field := func(field string, r bounds) uint64 {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var bits uint64
0000000000000000000000000000000000000000;;			bits, err = getField(field, r)
0000000000000000000000000000000000000000;;			return bits
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			second     = field(fields[0], seconds)
0000000000000000000000000000000000000000;;			minute     = field(fields[1], minutes)
0000000000000000000000000000000000000000;;			hour       = field(fields[2], hours)
0000000000000000000000000000000000000000;;			dayofmonth = field(fields[3], dom)
0000000000000000000000000000000000000000;;			month      = field(fields[4], months)
0000000000000000000000000000000000000000;;			dayofweek  = field(fields[5], dow)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &SpecSchedule{
0000000000000000000000000000000000000000;;			Second: second,
0000000000000000000000000000000000000000;;			Minute: minute,
0000000000000000000000000000000000000000;;			Hour:   hour,
0000000000000000000000000000000000000000;;			Dom:    dayofmonth,
0000000000000000000000000000000000000000;;			Month:  month,
0000000000000000000000000000000000000000;;			Dow:    dayofweek,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandFields(fields []string, options ParseOption) []string {
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		count := len(fields)
0000000000000000000000000000000000000000;;		expFields := make([]string, len(places))
0000000000000000000000000000000000000000;;		copy(expFields, defaults)
0000000000000000000000000000000000000000;;		for i, place := range places {
0000000000000000000000000000000000000000;;			if options&place > 0 {
0000000000000000000000000000000000000000;;				expFields[i] = fields[n]
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n == count {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return expFields
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var standardParser = NewParser(
0000000000000000000000000000000000000000;;		Minute | Hour | Dom | Month | Dow | Descriptor,
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseStandard returns a new crontab schedule representing the given standardSpec
0000000000000000000000000000000000000000;;	// (https://en.wikipedia.org/wiki/Cron). It differs from Parse requiring to always
0000000000000000000000000000000000000000;;	// pass 5 entries representing: minute, hour, day of month, month and day of week,
0000000000000000000000000000000000000000;;	// in that order. It returns a descriptive error if the spec is not valid.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It accepts
0000000000000000000000000000000000000000;;	//   - Standard crontab specs, e.g. "* * * * ?"
0000000000000000000000000000000000000000;;	//   - Descriptors, e.g. "@midnight", "@every 1h30m"
0000000000000000000000000000000000000000;;	func ParseStandard(standardSpec string) (Schedule, error) {
0000000000000000000000000000000000000000;;		return standardParser.Parse(standardSpec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultParser = NewParser(
0000000000000000000000000000000000000000;;		Second | Minute | Hour | Dom | Month | DowOptional | Descriptor,
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse returns a new crontab schedule representing the given spec.
0000000000000000000000000000000000000000;;	// It returns a descriptive error if the spec is not valid.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It accepts
0000000000000000000000000000000000000000;;	//   - Full crontab specs, e.g. "* * * * * ?"
0000000000000000000000000000000000000000;;	//   - Descriptors, e.g. "@midnight", "@every 1h30m"
0000000000000000000000000000000000000000;;	func Parse(spec string) (Schedule, error) {
0000000000000000000000000000000000000000;;		return defaultParser.Parse(spec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getField returns an Int with the bits set representing all of the times that
0000000000000000000000000000000000000000;;	// the field represents or error parsing field value.  A "field" is a comma-separated
0000000000000000000000000000000000000000;;	// list of "ranges".
0000000000000000000000000000000000000000;;	func getField(field string, r bounds) (uint64, error) {
0000000000000000000000000000000000000000;;		var bits uint64
0000000000000000000000000000000000000000;;		ranges := strings.FieldsFunc(field, func(r rune) bool { return r == ',' })
0000000000000000000000000000000000000000;;		for _, expr := range ranges {
0000000000000000000000000000000000000000;;			bit, err := getRange(expr, r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return bits, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bits |= bit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bits, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRange returns the bits indicated by the given expression:
0000000000000000000000000000000000000000;;	//   number | number "-" number [ "/" number ]
0000000000000000000000000000000000000000;;	// or error parsing range.
0000000000000000000000000000000000000000;;	func getRange(expr string, r bounds) (uint64, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			start, end, step uint
0000000000000000000000000000000000000000;;			rangeAndStep     = strings.Split(expr, "/")
0000000000000000000000000000000000000000;;			lowAndHigh       = strings.Split(rangeAndStep[0], "-")
0000000000000000000000000000000000000000;;			singleDigit      = len(lowAndHigh) == 1
0000000000000000000000000000000000000000;;			err              error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var extra uint64
0000000000000000000000000000000000000000;;		if lowAndHigh[0] == "*" || lowAndHigh[0] == "?" {
0000000000000000000000000000000000000000;;			start = r.min
0000000000000000000000000000000000000000;;			end = r.max
0000000000000000000000000000000000000000;;			extra = starBit
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			start, err = parseIntOrName(lowAndHigh[0], r.names)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch len(lowAndHigh) {
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				end = start
0000000000000000000000000000000000000000;;			case 2:
0000000000000000000000000000000000000000;;				end, err = parseIntOrName(lowAndHigh[1], r.names)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("Too many hyphens: %s", expr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(rangeAndStep) {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			step = 1
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			step, err = mustParseInt(rangeAndStep[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Special handling: "N/step" means "N-max/step".
0000000000000000000000000000000000000000;;			if singleDigit {
0000000000000000000000000000000000000000;;				end = r.max
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Too many slashes: %s", expr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if start < r.min {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Beginning of range (%d) below minimum (%d): %s", start, r.min, expr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end > r.max {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("End of range (%d) above maximum (%d): %s", end, r.max, expr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start > end {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Beginning of range (%d) beyond end of range (%d): %s", start, end, expr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if step == 0 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Step of range should be a positive number: %s", expr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getBits(start, end, step) | extra, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseIntOrName returns the (possibly-named) integer contained in expr.
0000000000000000000000000000000000000000;;	func parseIntOrName(expr string, names map[string]uint) (uint, error) {
0000000000000000000000000000000000000000;;		if names != nil {
0000000000000000000000000000000000000000;;			if namedInt, ok := names[strings.ToLower(expr)]; ok {
0000000000000000000000000000000000000000;;				return namedInt, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mustParseInt(expr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mustParseInt parses the given expression as an int or returns an error.
0000000000000000000000000000000000000000;;	func mustParseInt(expr string) (uint, error) {
0000000000000000000000000000000000000000;;		num, err := strconv.Atoi(expr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Failed to parse int from %s: %s", expr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if num < 0 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Negative number (%d) not allowed: %s", num, expr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return uint(num), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getBits sets all bits in the range [min, max], modulo the given step size.
0000000000000000000000000000000000000000;;	func getBits(min, max, step uint) uint64 {
0000000000000000000000000000000000000000;;		var bits uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If step is 1, use shifts.
0000000000000000000000000000000000000000;;		if step == 1 {
0000000000000000000000000000000000000000;;			return ^(math.MaxUint64 << (max + 1)) & (math.MaxUint64 << min)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Else, use a simple loop.
0000000000000000000000000000000000000000;;		for i := min; i <= max; i += step {
0000000000000000000000000000000000000000;;			bits |= 1 << i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bits
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// all returns all bits within the given bounds.  (plus the star bit)
0000000000000000000000000000000000000000;;	func all(r bounds) uint64 {
0000000000000000000000000000000000000000;;		return getBits(r.min, r.max, 1) | starBit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseDescriptor returns a predefined schedule for the expression, or error if none matches.
0000000000000000000000000000000000000000;;	func parseDescriptor(descriptor string) (Schedule, error) {
0000000000000000000000000000000000000000;;		switch descriptor {
0000000000000000000000000000000000000000;;		case "@yearly", "@annually":
0000000000000000000000000000000000000000;;			return &SpecSchedule{
0000000000000000000000000000000000000000;;				Second: 1 << seconds.min,
0000000000000000000000000000000000000000;;				Minute: 1 << minutes.min,
0000000000000000000000000000000000000000;;				Hour:   1 << hours.min,
0000000000000000000000000000000000000000;;				Dom:    1 << dom.min,
0000000000000000000000000000000000000000;;				Month:  1 << months.min,
0000000000000000000000000000000000000000;;				Dow:    all(dow),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "@monthly":
0000000000000000000000000000000000000000;;			return &SpecSchedule{
0000000000000000000000000000000000000000;;				Second: 1 << seconds.min,
0000000000000000000000000000000000000000;;				Minute: 1 << minutes.min,
0000000000000000000000000000000000000000;;				Hour:   1 << hours.min,
0000000000000000000000000000000000000000;;				Dom:    1 << dom.min,
0000000000000000000000000000000000000000;;				Month:  all(months),
0000000000000000000000000000000000000000;;				Dow:    all(dow),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "@weekly":
0000000000000000000000000000000000000000;;			return &SpecSchedule{
0000000000000000000000000000000000000000;;				Second: 1 << seconds.min,
0000000000000000000000000000000000000000;;				Minute: 1 << minutes.min,
0000000000000000000000000000000000000000;;				Hour:   1 << hours.min,
0000000000000000000000000000000000000000;;				Dom:    all(dom),
0000000000000000000000000000000000000000;;				Month:  all(months),
0000000000000000000000000000000000000000;;				Dow:    1 << dow.min,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "@daily", "@midnight":
0000000000000000000000000000000000000000;;			return &SpecSchedule{
0000000000000000000000000000000000000000;;				Second: 1 << seconds.min,
0000000000000000000000000000000000000000;;				Minute: 1 << minutes.min,
0000000000000000000000000000000000000000;;				Hour:   1 << hours.min,
0000000000000000000000000000000000000000;;				Dom:    all(dom),
0000000000000000000000000000000000000000;;				Month:  all(months),
0000000000000000000000000000000000000000;;				Dow:    all(dow),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "@hourly":
0000000000000000000000000000000000000000;;			return &SpecSchedule{
0000000000000000000000000000000000000000;;				Second: 1 << seconds.min,
0000000000000000000000000000000000000000;;				Minute: 1 << minutes.min,
0000000000000000000000000000000000000000;;				Hour:   all(hours),
0000000000000000000000000000000000000000;;				Dom:    all(dom),
0000000000000000000000000000000000000000;;				Month:  all(months),
0000000000000000000000000000000000000000;;				Dow:    all(dow),
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const every = "@every "
0000000000000000000000000000000000000000;;		if strings.HasPrefix(descriptor, every) {
0000000000000000000000000000000000000000;;			duration, err := time.ParseDuration(descriptor[len(every):])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to parse duration %s: %s", descriptor, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Every(duration), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Unrecognized descriptor: %s", descriptor)
0000000000000000000000000000000000000000;;	}
