0000000000000000000000000000000000000000;;	package cron
ea55b7c1ed132cbd99ded4ceb08387d7aff333ea;;	
0000000000000000000000000000000000000000;;	import "time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SpecSchedule specifies a duty cycle (to the second granularity), based on a
0000000000000000000000000000000000000000;;	// traditional crontab specification. It is computed initially and stored as bit sets.
0000000000000000000000000000000000000000;;	type SpecSchedule struct {
0000000000000000000000000000000000000000;;		Second, Minute, Hour, Dom, Month, Dow uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bounds provides a range of acceptable values (plus a map of name to value).
0000000000000000000000000000000000000000;;	type bounds struct {
0000000000000000000000000000000000000000;;		min, max uint
0000000000000000000000000000000000000000;;		names    map[string]uint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The bounds for each field.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		seconds = bounds{0, 59, nil}
0000000000000000000000000000000000000000;;		minutes = bounds{0, 59, nil}
0000000000000000000000000000000000000000;;		hours   = bounds{0, 23, nil}
0000000000000000000000000000000000000000;;		dom     = bounds{1, 31, nil}
0000000000000000000000000000000000000000;;		months  = bounds{1, 12, map[string]uint{
0000000000000000000000000000000000000000;;			"jan": 1,
0000000000000000000000000000000000000000;;			"feb": 2,
0000000000000000000000000000000000000000;;			"mar": 3,
0000000000000000000000000000000000000000;;			"apr": 4,
0000000000000000000000000000000000000000;;			"may": 5,
0000000000000000000000000000000000000000;;			"jun": 6,
0000000000000000000000000000000000000000;;			"jul": 7,
0000000000000000000000000000000000000000;;			"aug": 8,
0000000000000000000000000000000000000000;;			"sep": 9,
0000000000000000000000000000000000000000;;			"oct": 10,
0000000000000000000000000000000000000000;;			"nov": 11,
0000000000000000000000000000000000000000;;			"dec": 12,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		dow = bounds{0, 6, map[string]uint{
0000000000000000000000000000000000000000;;			"sun": 0,
0000000000000000000000000000000000000000;;			"mon": 1,
0000000000000000000000000000000000000000;;			"tue": 2,
0000000000000000000000000000000000000000;;			"wed": 3,
0000000000000000000000000000000000000000;;			"thu": 4,
0000000000000000000000000000000000000000;;			"fri": 5,
0000000000000000000000000000000000000000;;			"sat": 6,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Set the top bit if a star was included in the expression.
0000000000000000000000000000000000000000;;		starBit = 1 << 63
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next returns the next time this schedule is activated, greater than the given
0000000000000000000000000000000000000000;;	// time.  If no time can be found to satisfy the schedule, return the zero time.
0000000000000000000000000000000000000000;;	func (s *SpecSchedule) Next(t time.Time) time.Time {
0000000000000000000000000000000000000000;;		// General approach:
0000000000000000000000000000000000000000;;		// For Month, Day, Hour, Minute, Second:
0000000000000000000000000000000000000000;;		// Check if the time value matches.  If yes, continue to the next field.
0000000000000000000000000000000000000000;;		// If the field doesn't match the schedule, then increment the field until it matches.
0000000000000000000000000000000000000000;;		// While incrementing the field, a wrap-around brings it back to the beginning
0000000000000000000000000000000000000000;;		// of the field list (since it is necessary to re-verify previous field
0000000000000000000000000000000000000000;;		// values)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start at the earliest possible time (the upcoming second).
0000000000000000000000000000000000000000;;		t = t.Add(1*time.Second - time.Duration(t.Nanosecond())*time.Nanosecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This flag indicates whether a field has been incremented.
0000000000000000000000000000000000000000;;		added := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If no time is found within five years, return zero.
0000000000000000000000000000000000000000;;		yearLimit := t.Year() + 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	WRAP:
0000000000000000000000000000000000000000;;		if t.Year() > yearLimit {
0000000000000000000000000000000000000000;;			return time.Time{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the first applicable month.
0000000000000000000000000000000000000000;;		// If it's this month, then do nothing.
0000000000000000000000000000000000000000;;		for 1<<uint(t.Month())&s.Month == 0 {
0000000000000000000000000000000000000000;;			// If we have to add a month, reset the other parts to 0.
0000000000000000000000000000000000000000;;			if !added {
0000000000000000000000000000000000000000;;				added = true
0000000000000000000000000000000000000000;;				// Otherwise, set the date at the beginning (since the current time is irrelevant).
0000000000000000000000000000000000000000;;				t = time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, t.Location())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = t.AddDate(0, 1, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wrapped around.
0000000000000000000000000000000000000000;;			if t.Month() == time.January {
0000000000000000000000000000000000000000;;				goto WRAP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now get a day in that month.
0000000000000000000000000000000000000000;;		for !dayMatches(s, t) {
0000000000000000000000000000000000000000;;			if !added {
0000000000000000000000000000000000000000;;				added = true
0000000000000000000000000000000000000000;;				t = time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = t.AddDate(0, 0, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t.Day() == 1 {
0000000000000000000000000000000000000000;;				goto WRAP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for 1<<uint(t.Hour())&s.Hour == 0 {
0000000000000000000000000000000000000000;;			if !added {
0000000000000000000000000000000000000000;;				added = true
0000000000000000000000000000000000000000;;				t = time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), 0, 0, 0, t.Location())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = t.Add(1 * time.Hour)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t.Hour() == 0 {
0000000000000000000000000000000000000000;;				goto WRAP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for 1<<uint(t.Minute())&s.Minute == 0 {
0000000000000000000000000000000000000000;;			if !added {
0000000000000000000000000000000000000000;;				added = true
0000000000000000000000000000000000000000;;				t = t.Truncate(time.Minute)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = t.Add(1 * time.Minute)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t.Minute() == 0 {
0000000000000000000000000000000000000000;;				goto WRAP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for 1<<uint(t.Second())&s.Second == 0 {
0000000000000000000000000000000000000000;;			if !added {
0000000000000000000000000000000000000000;;				added = true
0000000000000000000000000000000000000000;;				t = t.Truncate(time.Second)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = t.Add(1 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t.Second() == 0 {
0000000000000000000000000000000000000000;;				goto WRAP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dayMatches returns true if the schedule's day-of-week and day-of-month
0000000000000000000000000000000000000000;;	// restrictions are satisfied by the given time.
0000000000000000000000000000000000000000;;	func dayMatches(s *SpecSchedule, t time.Time) bool {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			domMatch bool = 1<<uint(t.Day())&s.Dom > 0
0000000000000000000000000000000000000000;;			dowMatch bool = 1<<uint(t.Weekday())&s.Dow > 0
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if s.Dom&starBit > 0 || s.Dow&starBit > 0 {
0000000000000000000000000000000000000000;;			return domMatch && dowMatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return domMatch || dowMatch
0000000000000000000000000000000000000000;;	}
