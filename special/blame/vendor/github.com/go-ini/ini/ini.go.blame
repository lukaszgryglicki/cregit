0000000000000000000000000000000000000000;;	// Copyright 2014 Unknwon
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/go-ini/ini/ini.go[Godeps/_workspace/src/github.com/go-ini/ini/ini.go][vendor/github.com/go-ini/ini/ini.go];	
0000000000000000000000000000000000000000;;	// Package ini provides INI file read and write functionality in Go.
0000000000000000000000000000000000000000;;	package ini
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DEFAULT_SECTION = "DEFAULT"
0000000000000000000000000000000000000000;;		// Maximum allowed depth when recursively substituing variable names.
0000000000000000000000000000000000000000;;		_DEPTH_VALUES = 99
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_VERSION = "1.7.0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Version() string {
0000000000000000000000000000000000000000;;		return _VERSION
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		LineBreak = "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Variable regexp pattern: %(variable)s
0000000000000000000000000000000000000000;;		varPattern = regexp.MustCompile(`%\(([^\)]+)\)s`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write spaces around "=" to look better.
0000000000000000000000000000000000000000;;		PrettyFormat = true
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			LineBreak = "\r\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func inSlice(str string, s []string) bool {
0000000000000000000000000000000000000000;;		for _, v := range s {
0000000000000000000000000000000000000000;;			if str == v {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dataSource is a interface that returns file content.
0000000000000000000000000000000000000000;;	type dataSource interface {
0000000000000000000000000000000000000000;;		ReadCloser() (io.ReadCloser, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sourceFile struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sourceFile) ReadCloser() (_ io.ReadCloser, err error) {
0000000000000000000000000000000000000000;;		return os.Open(s.name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bytesReadCloser struct {
0000000000000000000000000000000000000000;;		reader io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *bytesReadCloser) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return rc.reader.Read(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *bytesReadCloser) Close() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sourceData struct {
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sourceData) ReadCloser() (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		return &bytesReadCloser{bytes.NewReader(s.data)}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//  ____  __.
0000000000000000000000000000000000000000;;	// |    |/ _|____ ___.__.
0000000000000000000000000000000000000000;;	// |      <_/ __ <   |  |
0000000000000000000000000000000000000000;;	// |    |  \  ___/\___  |
0000000000000000000000000000000000000000;;	// |____|__ \___  > ____|
0000000000000000000000000000000000000000;;	//         \/   \/\/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key represents a key under a section.
0000000000000000000000000000000000000000;;	type Key struct {
0000000000000000000000000000000000000000;;		s          *Section
0000000000000000000000000000000000000000;;		Comment    string
0000000000000000000000000000000000000000;;		name       string
0000000000000000000000000000000000000000;;		value      string
0000000000000000000000000000000000000000;;		isAutoIncr bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns name of key.
0000000000000000000000000000000000000000;;	func (k *Key) Name() string {
0000000000000000000000000000000000000000;;		return k.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value returns raw value of key for performance purpose.
0000000000000000000000000000000000000000;;	func (k *Key) Value() string {
0000000000000000000000000000000000000000;;		return k.value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns string representation of value.
0000000000000000000000000000000000000000;;	func (k *Key) String() string {
0000000000000000000000000000000000000000;;		val := k.value
0000000000000000000000000000000000000000;;		if strings.Index(val, "%") == -1 {
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < _DEPTH_VALUES; i++ {
0000000000000000000000000000000000000000;;			vr := varPattern.FindString(val)
0000000000000000000000000000000000000000;;			if len(vr) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Take off leading '%(' and trailing ')s'.
0000000000000000000000000000000000000000;;			noption := strings.TrimLeft(vr, "%(")
0000000000000000000000000000000000000000;;			noption = strings.TrimRight(noption, ")s")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Search in the same section.
0000000000000000000000000000000000000000;;			nk, err := k.s.GetKey(noption)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Search again in default section.
0000000000000000000000000000000000000000;;				nk, _ = k.s.f.Section("").GetKey(noption)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Substitute by new value and take off leading '%(' and trailing ')s'.
0000000000000000000000000000000000000000;;			val = strings.Replace(val, vr, nk.value, -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate accepts a validate function which can
0000000000000000000000000000000000000000;;	// return modifed result as key value.
0000000000000000000000000000000000000000;;	func (k *Key) Validate(fn func(string) string) string {
0000000000000000000000000000000000000000;;		return fn(k.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseBool returns the boolean value represented by the string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It accepts 1, t, T, TRUE, true, True, YES, yes, Yes, ON, on, On,
0000000000000000000000000000000000000000;;	// 0, f, F, FALSE, false, False, NO, no, No, OFF, off, Off.
0000000000000000000000000000000000000000;;	// Any other value returns an error.
0000000000000000000000000000000000000000;;	func parseBool(str string) (value bool, err error) {
0000000000000000000000000000000000000000;;		switch str {
0000000000000000000000000000000000000000;;		case "1", "t", "T", "true", "TRUE", "True", "YES", "yes", "Yes", "ON", "on", "On":
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		case "0", "f", "F", "false", "FALSE", "False", "NO", "no", "No", "OFF", "off", "Off":
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, fmt.Errorf("parsing \"%s\": invalid syntax", str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bool returns bool type value.
0000000000000000000000000000000000000000;;	func (k *Key) Bool() (bool, error) {
0000000000000000000000000000000000000000;;		return parseBool(k.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float64 returns float64 type value.
0000000000000000000000000000000000000000;;	func (k *Key) Float64() (float64, error) {
0000000000000000000000000000000000000000;;		return strconv.ParseFloat(k.String(), 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int returns int type value.
0000000000000000000000000000000000000000;;	func (k *Key) Int() (int, error) {
0000000000000000000000000000000000000000;;		return strconv.Atoi(k.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int64 returns int64 type value.
0000000000000000000000000000000000000000;;	func (k *Key) Int64() (int64, error) {
0000000000000000000000000000000000000000;;		return strconv.ParseInt(k.String(), 10, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint returns uint type valued.
0000000000000000000000000000000000000000;;	func (k *Key) Uint() (uint, error) {
0000000000000000000000000000000000000000;;		u, e := strconv.ParseUint(k.String(), 10, 64)
0000000000000000000000000000000000000000;;		return uint(u), e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint64 returns uint64 type value.
0000000000000000000000000000000000000000;;	func (k *Key) Uint64() (uint64, error) {
0000000000000000000000000000000000000000;;		return strconv.ParseUint(k.String(), 10, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Duration returns time.Duration type value.
0000000000000000000000000000000000000000;;	func (k *Key) Duration() (time.Duration, error) {
0000000000000000000000000000000000000000;;		return time.ParseDuration(k.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeFormat parses with given format and returns time.Time type value.
0000000000000000000000000000000000000000;;	func (k *Key) TimeFormat(format string) (time.Time, error) {
0000000000000000000000000000000000000000;;		return time.Parse(format, k.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time parses with RFC3339 format and returns time.Time type value.
0000000000000000000000000000000000000000;;	func (k *Key) Time() (time.Time, error) {
0000000000000000000000000000000000000000;;		return k.TimeFormat(time.RFC3339)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustString returns default value if key value is empty.
0000000000000000000000000000000000000000;;	func (k *Key) MustString(defaultVal string) string {
0000000000000000000000000000000000000000;;		val := k.String()
0000000000000000000000000000000000000000;;		if len(val) == 0 {
0000000000000000000000000000000000000000;;			return defaultVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustBool always returns value without error,
0000000000000000000000000000000000000000;;	// it returns false if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustBool(defaultVal ...bool) bool {
0000000000000000000000000000000000000000;;		val, err := k.Bool()
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFloat64 always returns value without error,
0000000000000000000000000000000000000000;;	// it returns 0.0 if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustFloat64(defaultVal ...float64) float64 {
0000000000000000000000000000000000000000;;		val, err := k.Float64()
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt always returns value without error,
0000000000000000000000000000000000000000;;	// it returns 0 if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustInt(defaultVal ...int) int {
0000000000000000000000000000000000000000;;		val, err := k.Int()
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt64 always returns value without error,
0000000000000000000000000000000000000000;;	// it returns 0 if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustInt64(defaultVal ...int64) int64 {
0000000000000000000000000000000000000000;;		val, err := k.Int64()
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint always returns value without error,
0000000000000000000000000000000000000000;;	// it returns 0 if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustUint(defaultVal ...uint) uint {
0000000000000000000000000000000000000000;;		val, err := k.Uint()
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint64 always returns value without error,
0000000000000000000000000000000000000000;;	// it returns 0 if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustUint64(defaultVal ...uint64) uint64 {
0000000000000000000000000000000000000000;;		val, err := k.Uint64()
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustDuration always returns value without error,
0000000000000000000000000000000000000000;;	// it returns zero value if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustDuration(defaultVal ...time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		val, err := k.Duration()
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustTimeFormat always parses with given format and returns value without error,
0000000000000000000000000000000000000000;;	// it returns zero value if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustTimeFormat(format string, defaultVal ...time.Time) time.Time {
0000000000000000000000000000000000000000;;		val, err := k.TimeFormat(format)
0000000000000000000000000000000000000000;;		if len(defaultVal) > 0 && err != nil {
0000000000000000000000000000000000000000;;			return defaultVal[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustTime always parses with RFC3339 format and returns value without error,
0000000000000000000000000000000000000000;;	// it returns zero value if error occurs.
0000000000000000000000000000000000000000;;	func (k *Key) MustTime(defaultVal ...time.Time) time.Time {
0000000000000000000000000000000000000000;;		return k.MustTimeFormat(time.RFC3339, defaultVal...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// In always returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) In(defaultVal string, candidates []string) string {
0000000000000000000000000000000000000000;;		val := k.String()
0000000000000000000000000000000000000000;;		for _, cand := range candidates {
0000000000000000000000000000000000000000;;			if val == cand {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultVal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InFloat64 always returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) InFloat64(defaultVal float64, candidates []float64) float64 {
0000000000000000000000000000000000000000;;		val := k.MustFloat64()
0000000000000000000000000000000000000000;;		for _, cand := range candidates {
0000000000000000000000000000000000000000;;			if val == cand {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultVal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InInt always returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) InInt(defaultVal int, candidates []int) int {
0000000000000000000000000000000000000000;;		val := k.MustInt()
0000000000000000000000000000000000000000;;		for _, cand := range candidates {
0000000000000000000000000000000000000000;;			if val == cand {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultVal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InInt64 always returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) InInt64(defaultVal int64, candidates []int64) int64 {
0000000000000000000000000000000000000000;;		val := k.MustInt64()
0000000000000000000000000000000000000000;;		for _, cand := range candidates {
0000000000000000000000000000000000000000;;			if val == cand {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultVal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InUint always returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) InUint(defaultVal uint, candidates []uint) uint {
0000000000000000000000000000000000000000;;		val := k.MustUint()
0000000000000000000000000000000000000000;;		for _, cand := range candidates {
0000000000000000000000000000000000000000;;			if val == cand {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultVal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InUint64 always returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) InUint64(defaultVal uint64, candidates []uint64) uint64 {
0000000000000000000000000000000000000000;;		val := k.MustUint64()
0000000000000000000000000000000000000000;;		for _, cand := range candidates {
0000000000000000000000000000000000000000;;			if val == cand {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultVal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InTimeFormat always parses with given format and returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) InTimeFormat(format string, defaultVal time.Time, candidates []time.Time) time.Time {
0000000000000000000000000000000000000000;;		val := k.MustTimeFormat(format)
0000000000000000000000000000000000000000;;		for _, cand := range candidates {
0000000000000000000000000000000000000000;;			if val == cand {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultVal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InTime always parses with RFC3339 format and returns value without error,
0000000000000000000000000000000000000000;;	// it returns default value if error occurs or doesn't fit into candidates.
0000000000000000000000000000000000000000;;	func (k *Key) InTime(defaultVal time.Time, candidates []time.Time) time.Time {
0000000000000000000000000000000000000000;;		return k.InTimeFormat(time.RFC3339, defaultVal, candidates)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeFloat64 checks if value is in given range inclusively,
0000000000000000000000000000000000000000;;	// and returns default value if it's not.
0000000000000000000000000000000000000000;;	func (k *Key) RangeFloat64(defaultVal, min, max float64) float64 {
0000000000000000000000000000000000000000;;		val := k.MustFloat64()
0000000000000000000000000000000000000000;;		if val < min || val > max {
0000000000000000000000000000000000000000;;			return defaultVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeInt checks if value is in given range inclusively,
0000000000000000000000000000000000000000;;	// and returns default value if it's not.
0000000000000000000000000000000000000000;;	func (k *Key) RangeInt(defaultVal, min, max int) int {
0000000000000000000000000000000000000000;;		val := k.MustInt()
0000000000000000000000000000000000000000;;		if val < min || val > max {
0000000000000000000000000000000000000000;;			return defaultVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeInt64 checks if value is in given range inclusively,
0000000000000000000000000000000000000000;;	// and returns default value if it's not.
0000000000000000000000000000000000000000;;	func (k *Key) RangeInt64(defaultVal, min, max int64) int64 {
0000000000000000000000000000000000000000;;		val := k.MustInt64()
0000000000000000000000000000000000000000;;		if val < min || val > max {
0000000000000000000000000000000000000000;;			return defaultVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeTimeFormat checks if value with given format is in given range inclusively,
0000000000000000000000000000000000000000;;	// and returns default value if it's not.
0000000000000000000000000000000000000000;;	func (k *Key) RangeTimeFormat(format string, defaultVal, min, max time.Time) time.Time {
0000000000000000000000000000000000000000;;		val := k.MustTimeFormat(format)
0000000000000000000000000000000000000000;;		if val.Unix() < min.Unix() || val.Unix() > max.Unix() {
0000000000000000000000000000000000000000;;			return defaultVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeTime checks if value with RFC3339 format is in given range inclusively,
0000000000000000000000000000000000000000;;	// and returns default value if it's not.
0000000000000000000000000000000000000000;;	func (k *Key) RangeTime(defaultVal, min, max time.Time) time.Time {
0000000000000000000000000000000000000000;;		return k.RangeTimeFormat(time.RFC3339, defaultVal, min, max)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Strings returns list of string devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) Strings(delim string) []string {
0000000000000000000000000000000000000000;;		str := k.String()
0000000000000000000000000000000000000000;;		if len(str) == 0 {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vals := strings.Split(str, delim)
0000000000000000000000000000000000000000;;		for i := range vals {
0000000000000000000000000000000000000000;;			vals[i] = strings.TrimSpace(vals[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float64s returns list of float64 devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) Float64s(delim string) []float64 {
0000000000000000000000000000000000000000;;		strs := k.Strings(delim)
0000000000000000000000000000000000000000;;		vals := make([]float64, len(strs))
0000000000000000000000000000000000000000;;		for i := range strs {
0000000000000000000000000000000000000000;;			vals[i], _ = strconv.ParseFloat(strs[i], 64)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ints returns list of int devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) Ints(delim string) []int {
0000000000000000000000000000000000000000;;		strs := k.Strings(delim)
0000000000000000000000000000000000000000;;		vals := make([]int, len(strs))
0000000000000000000000000000000000000000;;		for i := range strs {
0000000000000000000000000000000000000000;;			vals[i], _ = strconv.Atoi(strs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int64s returns list of int64 devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) Int64s(delim string) []int64 {
0000000000000000000000000000000000000000;;		strs := k.Strings(delim)
0000000000000000000000000000000000000000;;		vals := make([]int64, len(strs))
0000000000000000000000000000000000000000;;		for i := range strs {
0000000000000000000000000000000000000000;;			vals[i], _ = strconv.ParseInt(strs[i], 10, 64)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uints returns list of uint devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) Uints(delim string) []uint {
0000000000000000000000000000000000000000;;		strs := k.Strings(delim)
0000000000000000000000000000000000000000;;		vals := make([]uint, len(strs))
0000000000000000000000000000000000000000;;		for i := range strs {
0000000000000000000000000000000000000000;;			u, _ := strconv.ParseUint(strs[i], 10, 64)
0000000000000000000000000000000000000000;;			vals[i] = uint(u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint64s returns list of uint64 devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) Uint64s(delim string) []uint64 {
0000000000000000000000000000000000000000;;		strs := k.Strings(delim)
0000000000000000000000000000000000000000;;		vals := make([]uint64, len(strs))
0000000000000000000000000000000000000000;;		for i := range strs {
0000000000000000000000000000000000000000;;			vals[i], _ = strconv.ParseUint(strs[i], 10, 64)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimesFormat parses with given format and returns list of time.Time devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) TimesFormat(format, delim string) []time.Time {
0000000000000000000000000000000000000000;;		strs := k.Strings(delim)
0000000000000000000000000000000000000000;;		vals := make([]time.Time, len(strs))
0000000000000000000000000000000000000000;;		for i := range strs {
0000000000000000000000000000000000000000;;			vals[i], _ = time.Parse(format, strs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Times parses with RFC3339 format and returns list of time.Time devide by given delimiter.
0000000000000000000000000000000000000000;;	func (k *Key) Times(delim string) []time.Time {
0000000000000000000000000000000000000000;;		return k.TimesFormat(time.RFC3339, delim)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetValue changes key value.
0000000000000000000000000000000000000000;;	func (k *Key) SetValue(v string) {
0000000000000000000000000000000000000000;;		k.value = v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//   _________              __  .__
0000000000000000000000000000000000000000;;	//  /   _____/ ____   _____/  |_|__| ____   ____
0000000000000000000000000000000000000000;;	//  \_____  \_/ __ \_/ ___\   __\  |/  _ \ /    \
0000000000000000000000000000000000000000;;	//  /        \  ___/\  \___|  | |  (  <_> )   |  \
0000000000000000000000000000000000000000;;	// /_______  /\___  >\___  >__| |__|\____/|___|  /
0000000000000000000000000000000000000000;;	//         \/     \/     \/                    \/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section represents a config section.
0000000000000000000000000000000000000000;;	type Section struct {
0000000000000000000000000000000000000000;;		f        *File
0000000000000000000000000000000000000000;;		Comment  string
0000000000000000000000000000000000000000;;		name     string
0000000000000000000000000000000000000000;;		keys     map[string]*Key
0000000000000000000000000000000000000000;;		keyList  []string
0000000000000000000000000000000000000000;;		keysHash map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSection(f *File, name string) *Section {
0000000000000000000000000000000000000000;;		return &Section{f, "", name, make(map[string]*Key), make([]string, 0, 10), make(map[string]string)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns name of Section.
0000000000000000000000000000000000000000;;	func (s *Section) Name() string {
0000000000000000000000000000000000000000;;		return s.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKey creates a new key to given section.
0000000000000000000000000000000000000000;;	func (s *Section) NewKey(name, val string) (*Key, error) {
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("error creating new key: empty key name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.f.BlockMode {
0000000000000000000000000000000000000000;;			s.f.lock.Lock()
0000000000000000000000000000000000000000;;			defer s.f.lock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if inSlice(name, s.keyList) {
0000000000000000000000000000000000000000;;			s.keys[name].value = val
0000000000000000000000000000000000000000;;			return s.keys[name], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.keyList = append(s.keyList, name)
0000000000000000000000000000000000000000;;		s.keys[name] = &Key{s, "", name, val, false}
0000000000000000000000000000000000000000;;		s.keysHash[name] = val
0000000000000000000000000000000000000000;;		return s.keys[name], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetKey returns key in section by given name.
0000000000000000000000000000000000000000;;	func (s *Section) GetKey(name string) (*Key, error) {
0000000000000000000000000000000000000000;;		// FIXME: change to section level lock?
0000000000000000000000000000000000000000;;		if s.f.BlockMode {
0000000000000000000000000000000000000000;;			s.f.lock.RLock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key := s.keys[name]
0000000000000000000000000000000000000000;;		if s.f.BlockMode {
0000000000000000000000000000000000000000;;			s.f.lock.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if key == nil {
0000000000000000000000000000000000000000;;			// Check if it is a child-section.
0000000000000000000000000000000000000000;;			sname := s.name
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if i := strings.LastIndex(sname, "."); i > -1 {
0000000000000000000000000000000000000000;;					sname = sname[:i]
0000000000000000000000000000000000000000;;					sec, err := s.f.GetSection(sname)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return sec.GetKey(name)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error when getting key of section '%s': key '%s' not exists", s.name, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasKey returns true if section contains a key with given name.
0000000000000000000000000000000000000000;;	func (s *Section) Haskey(name string) bool {
0000000000000000000000000000000000000000;;		key, _ := s.GetKey(name)
0000000000000000000000000000000000000000;;		return key != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasKey returns true if section contains given raw value.
0000000000000000000000000000000000000000;;	func (s *Section) HasValue(value string) bool {
0000000000000000000000000000000000000000;;		if s.f.BlockMode {
0000000000000000000000000000000000000000;;			s.f.lock.RLock()
0000000000000000000000000000000000000000;;			defer s.f.lock.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, k := range s.keys {
0000000000000000000000000000000000000000;;			if value == k.value {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key assumes named Key exists in section and returns a zero-value when not.
0000000000000000000000000000000000000000;;	func (s *Section) Key(name string) *Key {
0000000000000000000000000000000000000000;;		key, err := s.GetKey(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// It's OK here because the only possible error is empty key name,
0000000000000000000000000000000000000000;;			// but if it's empty, this piece of code won't be executed.
0000000000000000000000000000000000000000;;			key, _ = s.NewKey(name, "")
0000000000000000000000000000000000000000;;			return key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns list of keys of section.
0000000000000000000000000000000000000000;;	func (s *Section) Keys() []*Key {
0000000000000000000000000000000000000000;;		keys := make([]*Key, len(s.keyList))
0000000000000000000000000000000000000000;;		for i := range s.keyList {
0000000000000000000000000000000000000000;;			keys[i] = s.Key(s.keyList[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyStrings returns list of key names of section.
0000000000000000000000000000000000000000;;	func (s *Section) KeyStrings() []string {
0000000000000000000000000000000000000000;;		list := make([]string, len(s.keyList))
0000000000000000000000000000000000000000;;		copy(list, s.keyList)
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeysHash returns keys hash consisting of names and values.
0000000000000000000000000000000000000000;;	func (s *Section) KeysHash() map[string]string {
0000000000000000000000000000000000000000;;		if s.f.BlockMode {
0000000000000000000000000000000000000000;;			s.f.lock.RLock()
0000000000000000000000000000000000000000;;			defer s.f.lock.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hash := map[string]string{}
0000000000000000000000000000000000000000;;		for key, value := range s.keysHash {
0000000000000000000000000000000000000000;;			hash[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hash
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteKey deletes a key from section.
0000000000000000000000000000000000000000;;	func (s *Section) DeleteKey(name string) {
0000000000000000000000000000000000000000;;		if s.f.BlockMode {
0000000000000000000000000000000000000000;;			s.f.lock.Lock()
0000000000000000000000000000000000000000;;			defer s.f.lock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, k := range s.keyList {
0000000000000000000000000000000000000000;;			if k == name {
0000000000000000000000000000000000000000;;				s.keyList = append(s.keyList[:i], s.keyList[i+1:]...)
0000000000000000000000000000000000000000;;				delete(s.keys, name)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ___________.__.__
0000000000000000000000000000000000000000;;	// \_   _____/|__|  |   ____
0000000000000000000000000000000000000000;;	//  |    __)  |  |  | _/ __ \
0000000000000000000000000000000000000000;;	//  |     \   |  |  |_\  ___/
0000000000000000000000000000000000000000;;	//  \___  /   |__|____/\___  >
0000000000000000000000000000000000000000;;	//      \/                 \/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File represents a combination of a or more INI file(s) in memory.
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		// Should make things safe, but sometimes doesn't matter.
0000000000000000000000000000000000000000;;		BlockMode bool
0000000000000000000000000000000000000000;;		// Make sure data is safe in multiple goroutines.
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow combination of multiple data sources.
0000000000000000000000000000000000000000;;		dataSources []dataSource
0000000000000000000000000000000000000000;;		// Actual data is stored here.
0000000000000000000000000000000000000000;;		sections map[string]*Section
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To keep data in order.
0000000000000000000000000000000000000000;;		sectionList []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		NameMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newFile initializes File object with given data sources.
0000000000000000000000000000000000000000;;	func newFile(dataSources []dataSource) *File {
0000000000000000000000000000000000000000;;		return &File{
0000000000000000000000000000000000000000;;			BlockMode:   true,
0000000000000000000000000000000000000000;;			dataSources: dataSources,
0000000000000000000000000000000000000000;;			sections:    make(map[string]*Section),
0000000000000000000000000000000000000000;;			sectionList: make([]string, 0, 10),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseDataSource(source interface{}) (dataSource, error) {
0000000000000000000000000000000000000000;;		switch s := source.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return sourceFile{s}, nil
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return &sourceData{s}, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing data source: unknown type '%s'", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load loads and parses from INI data sources.
0000000000000000000000000000000000000000;;	// Arguments can be mixed of file name with string type, or raw data in []byte.
0000000000000000000000000000000000000000;;	func Load(source interface{}, others ...interface{}) (_ *File, err error) {
0000000000000000000000000000000000000000;;		sources := make([]dataSource, len(others)+1)
0000000000000000000000000000000000000000;;		sources[0], err = parseDataSource(source)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range others {
0000000000000000000000000000000000000000;;			sources[i+1], err = parseDataSource(others[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f := newFile(sources)
0000000000000000000000000000000000000000;;		return f, f.Reload()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns an empty file object.
0000000000000000000000000000000000000000;;	func Empty() *File {
0000000000000000000000000000000000000000;;		// Ignore error here, we sure our data is good.
0000000000000000000000000000000000000000;;		f, _ := Load([]byte(""))
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSection creates a new section.
0000000000000000000000000000000000000000;;	func (f *File) NewSection(name string) (*Section, error) {
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("error creating new section: empty section name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.BlockMode {
0000000000000000000000000000000000000000;;			f.lock.Lock()
0000000000000000000000000000000000000000;;			defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if inSlice(name, f.sectionList) {
0000000000000000000000000000000000000000;;			return f.sections[name], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.sectionList = append(f.sectionList, name)
0000000000000000000000000000000000000000;;		f.sections[name] = newSection(f, name)
0000000000000000000000000000000000000000;;		return f.sections[name], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSections creates a list of sections.
0000000000000000000000000000000000000000;;	func (f *File) NewSections(names ...string) (err error) {
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			if _, err = f.NewSection(name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSection returns section by given name.
0000000000000000000000000000000000000000;;	func (f *File) GetSection(name string) (*Section, error) {
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			name = DEFAULT_SECTION
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.BlockMode {
0000000000000000000000000000000000000000;;			f.lock.RLock()
0000000000000000000000000000000000000000;;			defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sec := f.sections[name]
0000000000000000000000000000000000000000;;		if sec == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error when getting section: section '%s' not exists", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sec, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section assumes named section exists and returns a zero-value when not.
0000000000000000000000000000000000000000;;	func (f *File) Section(name string) *Section {
0000000000000000000000000000000000000000;;		sec, err := f.GetSection(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Note: It's OK here because the only possible error is empty section name,
0000000000000000000000000000000000000000;;			// but if it's empty, this piece of code won't be executed.
0000000000000000000000000000000000000000;;			sec, _ = f.NewSection(name)
0000000000000000000000000000000000000000;;			return sec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section returns list of Section.
0000000000000000000000000000000000000000;;	func (f *File) Sections() []*Section {
0000000000000000000000000000000000000000;;		sections := make([]*Section, len(f.sectionList))
0000000000000000000000000000000000000000;;		for i := range f.sectionList {
0000000000000000000000000000000000000000;;			sections[i] = f.Section(f.sectionList[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sections
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SectionStrings returns list of section names.
0000000000000000000000000000000000000000;;	func (f *File) SectionStrings() []string {
0000000000000000000000000000000000000000;;		list := make([]string, len(f.sectionList))
0000000000000000000000000000000000000000;;		copy(list, f.sectionList)
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteSection deletes a section.
0000000000000000000000000000000000000000;;	func (f *File) DeleteSection(name string) {
0000000000000000000000000000000000000000;;		if f.BlockMode {
0000000000000000000000000000000000000000;;			f.lock.Lock()
0000000000000000000000000000000000000000;;			defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			name = DEFAULT_SECTION
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, s := range f.sectionList {
0000000000000000000000000000000000000000;;			if s == name {
0000000000000000000000000000000000000000;;				f.sectionList = append(f.sectionList[:i], f.sectionList[i+1:]...)
0000000000000000000000000000000000000000;;				delete(f.sections, name)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cutComment(str string) string {
0000000000000000000000000000000000000000;;		i := strings.Index(str, "#")
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return str
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str[:i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkMultipleLines(buf *bufio.Reader, line, val, valQuote string) (string, error) {
0000000000000000000000000000000000000000;;		isEnd := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			next, err := buf.ReadString('\n')
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				isEnd = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos := strings.LastIndex(next, valQuote)
0000000000000000000000000000000000000000;;			if pos > -1 {
0000000000000000000000000000000000000000;;				val += next[:pos]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val += next
0000000000000000000000000000000000000000;;			if isEnd {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("error parsing line: missing closing key quote from '%s' to '%s'", line, next)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkContinuationLines(buf *bufio.Reader, val string) (string, bool, error) {
0000000000000000000000000000000000000000;;		isEnd := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			valLen := len(val)
0000000000000000000000000000000000000000;;			if valLen == 0 || val[valLen-1] != '\\' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val = val[:valLen-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			next, err := buf.ReadString('\n')
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					return "", isEnd, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				isEnd = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			next = strings.TrimSpace(next)
0000000000000000000000000000000000000000;;			if len(next) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val += next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val, isEnd, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse parses data through an io.Reader.
0000000000000000000000000000000000000000;;	func (f *File) parse(reader io.Reader) error {
0000000000000000000000000000000000000000;;		buf := bufio.NewReader(reader)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle BOM-UTF8.
0000000000000000000000000000000000000000;;		// http://en.wikipedia.org/wiki/Byte_order_mark#Representations_of_byte_order_marks_by_encoding
0000000000000000000000000000000000000000;;		mask, err := buf.Peek(3)
0000000000000000000000000000000000000000;;		if err == nil && len(mask) >= 3 && mask[0] == 239 && mask[1] == 187 && mask[2] == 191 {
0000000000000000000000000000000000000000;;			buf.Read(mask)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 1
0000000000000000000000000000000000000000;;		comments := ""
0000000000000000000000000000000000000000;;		isEnd := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		section, err := f.NewSection(DEFAULT_SECTION)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, err := buf.ReadString('\n')
0000000000000000000000000000000000000000;;			line = strings.TrimSpace(line)
0000000000000000000000000000000000000000;;			length := len(line)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check error and ignore io.EOF just for a moment.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error reading next line: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// The last line of file could be an empty line.
0000000000000000000000000000000000000000;;				if length == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				isEnd = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Skip empty lines.
0000000000000000000000000000000000000000;;			if length == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case line[0] == '#' || line[0] == ';': // Comments.
0000000000000000000000000000000000000000;;				if len(comments) == 0 {
0000000000000000000000000000000000000000;;					comments = line
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					comments += LineBreak + line
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case line[0] == '[' && line[length-1] == ']': // New sction.
0000000000000000000000000000000000000000;;				section, err = f.NewSection(strings.TrimSpace(line[1 : length-1]))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(comments) > 0 {
0000000000000000000000000000000000000000;;					section.Comment = comments
0000000000000000000000000000000000000000;;					comments = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Reset counter.
0000000000000000000000000000000000000000;;				count = 1
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Other possibilities.
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				i        int
0000000000000000000000000000000000000000;;				keyQuote string
0000000000000000000000000000000000000000;;				kname    string
0000000000000000000000000000000000000000;;				valQuote string
0000000000000000000000000000000000000000;;				val      string
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Key name surrounded by quotes.
0000000000000000000000000000000000000000;;			if line[0] == '"' {
0000000000000000000000000000000000000000;;				if length > 6 && line[0:3] == `"""` {
0000000000000000000000000000000000000000;;					keyQuote = `"""`
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					keyQuote = `"`
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if line[0] == '`' {
0000000000000000000000000000000000000000;;				keyQuote = "`"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(keyQuote) > 0 {
0000000000000000000000000000000000000000;;				qLen := len(keyQuote)
0000000000000000000000000000000000000000;;				pos := strings.Index(line[qLen:], keyQuote)
0000000000000000000000000000000000000000;;				if pos == -1 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error parsing line: missing closing key quote: %s", line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pos = pos + qLen
0000000000000000000000000000000000000000;;				i = strings.IndexAny(line[pos:], "=:")
0000000000000000000000000000000000000000;;				if i < 0 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error parsing line: key-value delimiter not found: %s", line)
0000000000000000000000000000000000000000;;				} else if i == pos {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error parsing line: key is empty: %s", line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i = i + pos
0000000000000000000000000000000000000000;;				kname = line[qLen:pos] // Just keep spaces inside quotes.
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				i = strings.IndexAny(line, "=:")
0000000000000000000000000000000000000000;;				if i < 0 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error parsing line: key-value delimiter not found: %s", line)
0000000000000000000000000000000000000000;;				} else if i == 0 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error parsing line: key is empty: %s", line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kname = strings.TrimSpace(line[0:i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isAutoIncr := false
0000000000000000000000000000000000000000;;			// Auto increment.
0000000000000000000000000000000000000000;;			if kname == "-" {
0000000000000000000000000000000000000000;;				isAutoIncr = true
0000000000000000000000000000000000000000;;				kname = "#" + fmt.Sprint(count)
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lineRight := strings.TrimSpace(line[i+1:])
0000000000000000000000000000000000000000;;			lineRightLength := len(lineRight)
0000000000000000000000000000000000000000;;			firstChar := ""
0000000000000000000000000000000000000000;;			if lineRightLength >= 2 {
0000000000000000000000000000000000000000;;				firstChar = lineRight[0:1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if firstChar == "`" {
0000000000000000000000000000000000000000;;				valQuote = "`"
0000000000000000000000000000000000000000;;			} else if firstChar == `"` {
0000000000000000000000000000000000000000;;				if lineRightLength >= 3 && lineRight[0:3] == `"""` {
0000000000000000000000000000000000000000;;					valQuote = `"""`
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					valQuote = `"`
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if firstChar == `'` {
0000000000000000000000000000000000000000;;				valQuote = `'`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(valQuote) > 0 {
0000000000000000000000000000000000000000;;				qLen := len(valQuote)
0000000000000000000000000000000000000000;;				pos := strings.LastIndex(lineRight[qLen:], valQuote)
0000000000000000000000000000000000000000;;				// For multiple-line value check.
0000000000000000000000000000000000000000;;				if pos == -1 {
0000000000000000000000000000000000000000;;					if valQuote == `"` || valQuote == `'` {
0000000000000000000000000000000000000000;;						return fmt.Errorf("error parsing line: single quote does not allow multiple-line value: %s", line)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					val = lineRight[qLen:] + "\n"
0000000000000000000000000000000000000000;;					val, err = checkMultipleLines(buf, line, val, valQuote)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					val = lineRight[qLen : pos+qLen]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				val = strings.TrimSpace(cutComment(lineRight))
0000000000000000000000000000000000000000;;				val, isEnd, err = checkContinuationLines(buf, val)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			k, err := section.NewKey(kname, val)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k.isAutoIncr = isAutoIncr
0000000000000000000000000000000000000000;;			if len(comments) > 0 {
0000000000000000000000000000000000000000;;				k.Comment = comments
0000000000000000000000000000000000000000;;				comments = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isEnd {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) reload(s dataSource) error {
0000000000000000000000000000000000000000;;		r, err := s.ReadCloser()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer r.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.parse(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reload reloads and parses all data sources.
0000000000000000000000000000000000000000;;	func (f *File) Reload() (err error) {
0000000000000000000000000000000000000000;;		for _, s := range f.dataSources {
0000000000000000000000000000000000000000;;			if err = f.reload(s); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Append appends one or more data sources and reloads automatically.
0000000000000000000000000000000000000000;;	func (f *File) Append(source interface{}, others ...interface{}) error {
0000000000000000000000000000000000000000;;		ds, err := parseDataSource(source)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.dataSources = append(f.dataSources, ds)
0000000000000000000000000000000000000000;;		for _, s := range others {
0000000000000000000000000000000000000000;;			ds, err = parseDataSource(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.dataSources = append(f.dataSources, ds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.Reload()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteToIndent writes file content into io.Writer with given value indention.
0000000000000000000000000000000000000000;;	func (f *File) WriteToIndent(w io.Writer, indent string) (n int64, err error) {
0000000000000000000000000000000000000000;;		equalSign := "="
0000000000000000000000000000000000000000;;		if PrettyFormat {
0000000000000000000000000000000000000000;;			equalSign = " = "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use buffer to make sure target is safe until finish encoding.
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		for i, sname := range f.sectionList {
0000000000000000000000000000000000000000;;			sec := f.Section(sname)
0000000000000000000000000000000000000000;;			if len(sec.Comment) > 0 {
0000000000000000000000000000000000000000;;				if sec.Comment[0] != '#' && sec.Comment[0] != ';' {
0000000000000000000000000000000000000000;;					sec.Comment = "; " + sec.Comment
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err = buf.WriteString(sec.Comment + LineBreak); err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				if _, err = buf.WriteString("[" + sname + "]" + LineBreak); err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Write nothing if default section is empty.
0000000000000000000000000000000000000000;;				if len(sec.keyList) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, kname := range sec.keyList {
0000000000000000000000000000000000000000;;				key := sec.Key(kname)
0000000000000000000000000000000000000000;;				if len(key.Comment) > 0 {
0000000000000000000000000000000000000000;;					if len(indent) > 0 && sname != DEFAULT_SECTION {
0000000000000000000000000000000000000000;;						buf.WriteString(indent)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if key.Comment[0] != '#' && key.Comment[0] != ';' {
0000000000000000000000000000000000000000;;						key.Comment = "; " + key.Comment
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if _, err = buf.WriteString(key.Comment + LineBreak); err != nil {
0000000000000000000000000000000000000000;;						return 0, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(indent) > 0 && sname != DEFAULT_SECTION {
0000000000000000000000000000000000000000;;					buf.WriteString(indent)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case key.isAutoIncr:
0000000000000000000000000000000000000000;;					kname = "-"
0000000000000000000000000000000000000000;;				case strings.Contains(kname, "`") || strings.Contains(kname, `"`):
0000000000000000000000000000000000000000;;					kname = `"""` + kname + `"""`
0000000000000000000000000000000000000000;;				case strings.Contains(kname, `=`) || strings.Contains(kname, `:`):
0000000000000000000000000000000000000000;;					kname = "`" + kname + "`"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				val := key.value
0000000000000000000000000000000000000000;;				// In case key value contains "\n", "`" or "\"".
0000000000000000000000000000000000000000;;				if strings.Contains(val, "\n") || strings.Contains(val, "`") || strings.Contains(val, `"`) ||
0000000000000000000000000000000000000000;;					strings.Contains(val, "#") {
0000000000000000000000000000000000000000;;					val = `"""` + val + `"""`
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, err = buf.WriteString(kname + equalSign + val + LineBreak); err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Put a line between sections.
0000000000000000000000000000000000000000;;			if _, err = buf.WriteString(LineBreak); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.WriteTo(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteTo writes file content into io.Writer.
0000000000000000000000000000000000000000;;	func (f *File) WriteTo(w io.Writer) (int64, error) {
0000000000000000000000000000000000000000;;		return f.WriteToIndent(w, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SaveToIndent writes content to file system with given value indention.
0000000000000000000000000000000000000000;;	func (f *File) SaveToIndent(filename, indent string) error {
0000000000000000000000000000000000000000;;		// Note: Because we are truncating with os.Create,
0000000000000000000000000000000000000000;;		// 	so it's safer to save to a temporary file location and rename afte done.
0000000000000000000000000000000000000000;;		tmpPath := filename + "." + strconv.Itoa(time.Now().Nanosecond()) + ".tmp"
0000000000000000000000000000000000000000;;		defer os.Remove(tmpPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fw, err := os.Create(tmpPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err = f.WriteToIndent(fw, indent); err != nil {
0000000000000000000000000000000000000000;;			fw.Close()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fw.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove old file and rename the new one.
0000000000000000000000000000000000000000;;		os.Remove(filename)
0000000000000000000000000000000000000000;;		return os.Rename(tmpPath, filename)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SaveTo writes content to file system.
0000000000000000000000000000000000000000;;	func (f *File) SaveTo(filename string) error {
0000000000000000000000000000000000000000;;		return f.SaveToIndent(filename, "")
0000000000000000000000000000000000000000;;	}
