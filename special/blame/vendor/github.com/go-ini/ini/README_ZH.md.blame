0000000000000000000000000000000000000000;;	本包提供了 Go 语言中读写 INI 文件的功能。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## 功能特性
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- 支持覆盖加载多个数据源（`[]byte` 或文件）
0000000000000000000000000000000000000000;;	- 支持递归读取键值
0000000000000000000000000000000000000000;;	- 支持读取父子分区
0000000000000000000000000000000000000000;;	- 支持读取自增键名
0000000000000000000000000000000000000000;;	- 支持读取多行的键值
0000000000000000000000000000000000000000;;	- 支持大量辅助方法
0000000000000000000000000000000000000000;;	- 支持在读取时直接转换为 Go 语言类型
0000000000000000000000000000000000000000;;	- 支持读取和 **写入** 分区和键的注释
0000000000000000000000000000000000000000;;	- 轻松操作分区、键值和注释
0000000000000000000000000000000000000000;;	- 在保存文件时分区和键值会保持原有的顺序
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## 下载安装
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    go get gopkg.in/ini.v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## 开始使用
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 从数据源加载
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	一个 **数据源** 可以是 `[]byte` 类型的原始数据，或 `string` 类型的文件路径。您可以加载 **任意多个** 数据源。如果您传递其它类型的数据源，则会直接返回错误。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg, err := ini.Load([]byte("raw data"), "filename")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	或者从一个空白的文件开始：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg := ini.Empty()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	当您在一开始无法决定需要加载哪些数据源时，仍可以使用 **Append()** 在需要的时候加载它们。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := cfg.Append("other file", []byte("other raw data"))
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 操作分区（Section）
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取指定分区：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	section, err := cfg.GetSection("section name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	如果您想要获取默认分区，则可以用空字符串代替分区名：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	section, err := cfg.GetSection("")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	当您非常确定某个分区是存在的，可以使用以下简便方法：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	section := cfg.Section("")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	如果不小心判断错了，要获取的分区其实是不存在的，那会发生什么呢？没事的，它会自动创建并返回一个对应的分区对象给您。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	创建一个分区：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := cfg.NewSection("new section")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取所有分区对象或名称：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	sections := cfg.Sections()
0000000000000000000000000000000000000000;;	names := cfg.SectionStrings()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 操作键（Key）
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取某个分区下的键：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	key, err := cfg.Section("").GetKey("key name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	和分区一样，您也可以直接获取键而忽略错误处理：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	key := cfg.Section("").Key("key name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	判断某个键是否存在：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	yes := cfg.Section("").HasKey("key name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	创建一个新的键：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := cfg.Section("").NewKey("name", "value")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取分区下的所有键或键名：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	keys := cfg.Section("").Keys()
0000000000000000000000000000000000000000;;	names := cfg.Section("").KeyStrings()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取分区下的所有键值对的克隆：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	hash := cfg.GetSection("").KeysHash()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 操作键值（Value）
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取一个类型为字符串（string）的值：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	val := cfg.Section("").Key("key name").String()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取值的同时通过自定义函数进行处理验证：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	val := cfg.Section("").Key("key name").Validate(func(in string) string {
0000000000000000000000000000000000000000;;		if len(in) == 0 {
0000000000000000000000000000000000000000;;			return "default"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	如果您不需要任何对值的自动转变功能（例如递归读取），可以直接获取原值（这种方式性能最佳）：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	val := cfg.Section("").Key("key name").Value()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	判断某个原值是否存在：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	yes := cfg.Section("").HasValue("test value")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取其它类型的值：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// 布尔值的规则：
0000000000000000000000000000000000000000;;	// true 当值为：1, t, T, TRUE, true, True, YES, yes, Yes, ON, on, On
0000000000000000000000000000000000000000;;	// false 当值为：0, f, F, FALSE, false, False, NO, no, No, OFF, off, Off
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("BOOL").Bool()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("FLOAT64").Float64()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("INT").Int()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("INT64").Int64()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("UINT").Uint()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("UINT64").Uint64()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("TIME").TimeFormat(time.RFC3339)
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("TIME").Time() // RFC3339
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("BOOL").MustBool()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("FLOAT64").MustFloat64()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT").MustInt()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT64").MustInt64()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT").MustUint()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT64").MustUint64()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTime() // RFC3339
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 由 Must 开头的方法名允许接收一个相同类型的参数来作为默认值，
0000000000000000000000000000000000000000;;	// 当键不存在或者转换失败时，则会直接返回该默认值。
0000000000000000000000000000000000000000;;	// 但是，MustString 方法必须传递一个默认值。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	v = cfg.Seciont("").Key("String").MustString("default")
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("BOOL").MustBool(true)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("FLOAT64").MustFloat64(1.25)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT").MustInt(10)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT64").MustInt64(99)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT").MustUint(3)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT64").MustUint64(6)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339, time.Now())
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTime(time.Now()) // RFC3339
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	如果我的值有好多行怎么办？
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	[advance]
0000000000000000000000000000000000000000;;	ADDRESS = """404 road,
0000000000000000000000000000000000000000;;	NotFound, State, 5000
0000000000000000000000000000000000000000;;	Earth"""
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	嗯哼？小 case！
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("advance").Key("ADDRESS").String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- start ---
0000000000000000000000000000000000000000;;	404 road,
0000000000000000000000000000000000000000;;	NotFound, State, 5000
0000000000000000000000000000000000000000;;	Earth
0000000000000000000000000000000000000000;;	------  end  --- */
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	赞爆了！那要是我属于一行的内容写不下想要写到第二行怎么办？
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	[advance]
0000000000000000000000000000000000000000;;	two_lines = how about \
0000000000000000000000000000000000000000;;		continuation lines?
0000000000000000000000000000000000000000;;	lots_of_lines = 1 \
0000000000000000000000000000000000000000;;		2 \
0000000000000000000000000000000000000000;;		3 \
0000000000000000000000000000000000000000;;		4
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	简直是小菜一碟！
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("advance").Key("two_lines").String() // how about continuation lines?
0000000000000000000000000000000000000000;;	cfg.Section("advance").Key("lots_of_lines").String() // 1 2 3 4
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	需要注意的是，值两侧的单引号会被自动剔除：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	foo = "some value" // foo: some value
0000000000000000000000000000000000000000;;	bar = 'some value' // bar: some value
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	这就是全部了？哈哈，当然不是。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### 操作键值的辅助方法
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	获取键值时设定候选值：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("STRING").In("default", []string{"str", "arr", "types"})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("FLOAT64").InFloat64(1.1, []float64{1.25, 2.5, 3.75})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT").InInt(5, []int{10, 20, 30})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT64").InInt64(10, []int64{10, 20, 30})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT").InUint(4, []int{3, 6, 9})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT64").InUint64(8, []int64{3, 6, 9})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").InTimeFormat(time.RFC3339, time.Now(), []time.Time{time1, time2, time3})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").InTime(time.Now(), []time.Time{time1, time2, time3}) // RFC3339
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	如果获取到的值不是候选值的任意一个，则会返回默认值，而默认值不需要是候选值中的一员。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	验证获取的值是否在指定范围内：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("FLOAT64").RangeFloat64(0.0, 1.1, 2.2)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INT").RangeInt(0, 10, 20)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INT64").RangeInt64(0, 10, 20)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINT").RangeUint(0, 3, 9)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINT64").RangeUint64(0, 3, 9)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("TIME").RangeTimeFormat(time.RFC3339, time.Now(), minTime, maxTime)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("TIME").RangeTime(time.Now(), minTime, maxTime) // RFC3339
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	自动分割键值为切片（slice）：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("STRINGS").Strings(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("FLOAT64S").Float64s(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INTS").Ints(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INT64S").Int64s(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINTS").Uints(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINT64S").Uint64s(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("TIMES").Times(",")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 保存配置
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	终于到了这个时刻，是时候保存一下配置了。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	比较原始的做法是输出配置到某个文件：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	err = cfg.SaveTo("my.ini")
0000000000000000000000000000000000000000;;	err = cfg.SaveToIndent("my.ini", "\t")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	另一个比较高级的做法是写入到任何实现 `io.Writer` 接口的对象中：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	cfg.WriteTo(writer)
0000000000000000000000000000000000000000;;	cfg.WriteToIndent(writer, "\t")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 高级用法
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### 递归读取键值
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	在获取所有键值的过程中，特殊语法 `%(<name>)s` 会被应用，其中 `<name>` 可以是相同分区或者默认分区下的键名。字符串 `%(<name>)s` 会被相应的键值所替代，如果指定的键不存在，则会用空字符串替代。您可以最多使用 99 层的递归嵌套。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	NAME = ini
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[author]
0000000000000000000000000000000000000000;;	NAME = Unknwon
0000000000000000000000000000000000000000;;	GITHUB = https://github.com/%(NAME)s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[package]
0000000000000000000000000000000000000000;;	FULL_NAME = github.com/go-ini/%(NAME)s
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("author").Key("GITHUB").String()		// https://github.com/Unknwon
0000000000000000000000000000000000000000;;	cfg.Section("package").Key("FULL_NAME").String()	// github.com/go-ini/ini
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### 读取父子分区
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	您可以在分区名称中使用 `.` 来表示两个或多个分区之间的父子关系。如果某个键在子分区中不存在，则会去它的父分区中再次寻找，直到没有父分区为止。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	NAME = ini
0000000000000000000000000000000000000000;;	VERSION = v1
0000000000000000000000000000000000000000;;	IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[package]
0000000000000000000000000000000000000000;;	CLONE_URL = https://%(IMPORT_PATH)s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[package.sub]
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("package.sub").Key("CLONE_URL").String()	// https://gopkg.in/ini.v1
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### 读取自增键名
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	如果数据源中的键名为 `-`，则认为该键使用了自增键名的特殊语法。计数器从 1 开始，并且分区之间是相互独立的。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	[features]
0000000000000000000000000000000000000000;;	-: Support read/write comments of keys and sections
0000000000000000000000000000000000000000;;	-: Support auto-increment of key names
0000000000000000000000000000000000000000;;	-: Support load multiple files to overwrite key values
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("features").KeyStrings()	// []{"#1", "#2", "#3"}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 映射到结构
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	想要使用更加面向对象的方式玩转 INI 吗？好主意。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	Name = Unknwon
0000000000000000000000000000000000000000;;	age = 21
0000000000000000000000000000000000000000;;	Male = true
0000000000000000000000000000000000000000;;	Born = 1993-01-01T20:17:05Z
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Note]
0000000000000000000000000000000000000000;;	Content = Hi is a good man!
0000000000000000000000000000000000000000;;	Cities = HangZhou, Boston
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Note struct {
0000000000000000000000000000000000000000;;		Content string
0000000000000000000000000000000000000000;;		Cities  []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Person struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Age  int `ini:"age"`
0000000000000000000000000000000000000000;;		Male bool
0000000000000000000000000000000000000000;;		Born time.Time
0000000000000000000000000000000000000000;;		Note
0000000000000000000000000000000000000000;;		Created time.Time `ini:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		cfg, err := ini.Load("path/to/ini")
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;		p := new(Person)
0000000000000000000000000000000000000000;;		err = cfg.MapTo(p)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 一切竟可以如此的简单。
0000000000000000000000000000000000000000;;		err = ini.MapTo(p, "path/to/ini")
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 嗯哼？只需要映射一个分区吗？
0000000000000000000000000000000000000000;;		n := new(Note)
0000000000000000000000000000000000000000;;		err = cfg.Section("Note").MapTo(n)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	结构的字段怎么设置默认值呢？很简单，只要在映射之前对指定字段进行赋值就可以了。如果键未找到或者类型错误，该值不会发生改变。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	p := &Person{
0000000000000000000000000000000000000000;;		Name: "Joe",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	这样玩 INI 真的好酷啊！然而，如果不能还给我原来的配置文件，有什么卵用？
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 从结构反射
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	可是，我有说不能吗？
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Embeded struct {
0000000000000000000000000000000000000000;;		Dates  []time.Time `delim:"|"`
0000000000000000000000000000000000000000;;		Places []string
0000000000000000000000000000000000000000;;		None   []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Author struct {
0000000000000000000000000000000000000000;;		Name      string `ini:"NAME"`
0000000000000000000000000000000000000000;;		Male      bool
0000000000000000000000000000000000000000;;		Age       int
0000000000000000000000000000000000000000;;		GPA       float64
0000000000000000000000000000000000000000;;		NeverMind string `ini:"-"`
0000000000000000000000000000000000000000;;		*Embeded
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		a := &Author{"Unknwon", true, 21, 2.8, "",
0000000000000000000000000000000000000000;;			&Embeded{
0000000000000000000000000000000000000000;;				[]time.Time{time.Now(), time.Now()},
0000000000000000000000000000000000000000;;				[]string{"HangZhou", "Boston"},
0000000000000000000000000000000000000000;;				[]int{},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		cfg := ini.Empty()
0000000000000000000000000000000000000000;;		err = ini.ReflectFrom(cfg, a)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	瞧瞧，奇迹发生了。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	NAME = Unknwon
0000000000000000000000000000000000000000;;	Male = true
0000000000000000000000000000000000000000;;	Age = 21
0000000000000000000000000000000000000000;;	GPA = 2.8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Embeded]
0000000000000000000000000000000000000000;;	Dates = 2015-08-07T22:14:22+08:00|2015-08-07T22:14:22+08:00
0000000000000000000000000000000000000000;;	Places = HangZhou,Boston
0000000000000000000000000000000000000000;;	None =
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### 名称映射器（Name Mapper）
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	为了节省您的时间并简化代码，本库支持类型为 [`NameMapper`](https://gowalker.org/gopkg.in/ini.v1#NameMapper) 的名称映射器，该映射器负责结构字段名与分区名和键名之间的映射。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	目前有 2 款内置的映射器：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `AllCapsUnderscore`：该映射器将字段名转换至格式 `ALL_CAPS_UNDERSCORE` 后再去匹配分区名和键名。
0000000000000000000000000000000000000000;;	- `TitleUnderscore`：该映射器将字段名转换至格式 `title_underscore` 后再去匹配分区名和键名。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	使用方法：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Info struct{
0000000000000000000000000000000000000000;;		PackageName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		err = ini.MapToWithMapper(&Info{}, ini.TitleUnderscore, []byte("packag_name=ini"))
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg, err := ini.Load([]byte("PACKAGE_NAME=ini"))
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;		info := new(Info)
0000000000000000000000000000000000000000;;		cfg.NameMapper = ini.AllCapsUnderscore
0000000000000000000000000000000000000000;;		err = cfg.MapTo(info)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	使用函数 `ini.ReflectFromWithMapper` 时也可应用相同的规则。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### 映射/反射的其它说明
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	任何嵌入的结构都会被默认认作一个不同的分区，并且不会自动产生所谓的父子分区关联：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Child struct {
0000000000000000000000000000000000000000;;		Age string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parent struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Child
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		City string
0000000000000000000000000000000000000000;;		Parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	示例配置文件：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	City = Boston
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Parent]
0000000000000000000000000000000000000000;;	Name = Unknwon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Child]
0000000000000000000000000000000000000000;;	Age = 21
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	很好，但是，我就是要嵌入结构也在同一个分区。好吧，你爹是李刚！
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Child struct {
0000000000000000000000000000000000000000;;		Age string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parent struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Child `ini:"Parent"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		City string
0000000000000000000000000000000000000000;;		Parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	示例配置文件：
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	City = Boston
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Parent]
0000000000000000000000000000000000000000;;	Name = Unknwon
0000000000000000000000000000000000000000;;	Age = 21
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## 获取帮助
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- [API 文档](https://gowalker.org/gopkg.in/ini.v1)
0000000000000000000000000000000000000000;;	- [创建工单](https://github.com/go-ini/ini/issues/new)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## 常见问题
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 字段 `BlockMode` 是什么？
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	默认情况下，本库会在您进行读写操作时采用锁机制来确保数据时间。但在某些情况下，您非常确定只进行读操作。此时，您可以通过设置 `cfg.BlockMode = false` 来将读操作提升大约 **50-70%** 的性能。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### 为什么要写另一个 INI 解析库？
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	许多人都在使用我的 [goconfig](https://github.com/Unknwon/goconfig) 来完成对 INI 文件的操作，但我希望使用更加 Go 风格的代码。并且当您设置 `cfg.BlockMode = false` 时，会有大约 **10-30%** 的性能提升。
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	为了做出这些改变，我必须对 API 进行破坏，所以新开一个仓库是最安全的做法。除此之外，本库直接使用 `gopkg.in` 来进行版本化发布。（其实真相是导入路径更短了）
