0000000000000000000000000000000000000000;;	ini [![Build Status](https://drone.io/github.com/go-ini/ini/status.png)](https://drone.io/github.com/go-ini/ini/latest) [![](http://gocover.io/_badge/github.com/go-ini/ini)](http://gocover.io/github.com/go-ini/ini)
0000000000000000000000000000000000000000;;	===
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	![](https://avatars0.githubusercontent.com/u/10216035?v=3&s=200)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Package ini provides INI file read and write functionality in Go.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[简体中文](README_ZH.md)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Feature
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- Load multiple data sources(`[]byte` or file) with overwrites.
0000000000000000000000000000000000000000;;	- Read with recursion values.
0000000000000000000000000000000000000000;;	- Read with parent-child sections.
0000000000000000000000000000000000000000;;	- Read with auto-increment key names.
0000000000000000000000000000000000000000;;	- Read with multiple-line values.
0000000000000000000000000000000000000000;;	- Read with tons of helper methods.
0000000000000000000000000000000000000000;;	- Read and convert values to Go types.
0000000000000000000000000000000000000000;;	- Read and **WRITE** comments of sections and keys.
0000000000000000000000000000000000000000;;	- Manipulate sections, keys and comments with ease.
0000000000000000000000000000000000000000;;	- Keep sections and keys in order as you parse and save.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Installation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go get gopkg.in/ini.v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Getting Started
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Loading from data sources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A **Data Source** is either raw data in type `[]byte` or a file name with type `string` and you can load **as many as** data sources you want. Passing other types will simply return an error.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg, err := ini.Load([]byte("raw data"), "filename")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Or start with an empty object:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg := ini.Empty()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When you cannot decide how many data sources to load at the beginning, you still able to **Append()** them later.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := cfg.Append("other file", []byte("other raw data"))
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Working with sections
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get a section, you would need to:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	section, err := cfg.GetSection("section name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For a shortcut for default section, just give an empty string as name:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	section, err := cfg.GetSection("")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When you're pretty sure the section exists, following code could make your life easier:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	section := cfg.Section("")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	What happens when the section somehow does not exist? Don't panic, it automatically creates and returns a new section to you.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To create a new section:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := cfg.NewSection("new section")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get a list of sections or section names:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	sections := cfg.Sections()
0000000000000000000000000000000000000000;;	names := cfg.SectionStrings()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Working with keys
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get a key under a section:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	key, err := cfg.Section("").GetKey("key name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Same rule applies to key operations:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	key := cfg.Section("").Key("key name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To check if a key exists:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	yes := cfg.Section("").HasKey("key name")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To create a new key:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := cfg.Section("").NewKey("name", "value")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get a list of keys or key names:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	keys := cfg.Section("").Keys()
0000000000000000000000000000000000000000;;	names := cfg.Section("").KeyStrings()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get a clone hash of keys and corresponding values:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	hash := cfg.GetSection("").KeysHash()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Working with values
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get a string value:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	val := cfg.Section("").Key("key name").String()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To validate key value on the fly:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	val := cfg.Section("").Key("key name").Validate(func(in string) string {
0000000000000000000000000000000000000000;;		if len(in) == 0 {
0000000000000000000000000000000000000000;;			return "default"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you do not want any auto-transformation (such as recursive read) for the values, you can get raw value directly (this way you get much better performance):
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	val := cfg.Section("").Key("key name").Value()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To check if raw value exists:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	yes := cfg.Section("").HasValue("test value")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get value with types:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// For boolean values:
0000000000000000000000000000000000000000;;	// true when value is: 1, t, T, TRUE, true, True, YES, yes, Yes, ON, on, On
0000000000000000000000000000000000000000;;	// false when value is: 0, f, F, FALSE, false, False, NO, no, No, OFF, off, Off
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("BOOL").Bool()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("FLOAT64").Float64()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("INT").Int()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("INT64").Int64()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("UINT").Uint()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("UINT64").Uint64()
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("TIME").TimeFormat(time.RFC3339)
0000000000000000000000000000000000000000;;	v, err = cfg.Section("").Key("TIME").Time() // RFC3339
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("BOOL").MustBool()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("FLOAT64").MustFloat64()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT").MustInt()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT64").MustInt64()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT").MustUint()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT64").MustUint64()
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTime() // RFC3339
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Methods start with Must also accept one argument for default value
0000000000000000000000000000000000000000;;	// when key not found or fail to parse value to given type.
0000000000000000000000000000000000000000;;	// Except method MustString, which you have to pass a default value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("String").MustString("default")
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("BOOL").MustBool(true)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("FLOAT64").MustFloat64(1.25)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT").MustInt(10)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT64").MustInt64(99)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT").MustUint(3)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT64").MustUint64(6)
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339, time.Now())
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").MustTime(time.Now()) // RFC3339
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	What if my value is three-line long?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	[advance]
0000000000000000000000000000000000000000;;	ADDRESS = """404 road,
0000000000000000000000000000000000000000;;	NotFound, State, 5000
0000000000000000000000000000000000000000;;	Earth"""
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Not a problem!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("advance").Key("ADDRESS").String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- start ---
0000000000000000000000000000000000000000;;	404 road,
0000000000000000000000000000000000000000;;	NotFound, State, 5000
0000000000000000000000000000000000000000;;	Earth
0000000000000000000000000000000000000000;;	------  end  --- */
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	That's cool, how about continuation lines?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	[advance]
0000000000000000000000000000000000000000;;	two_lines = how about \
0000000000000000000000000000000000000000;;		continuation lines?
0000000000000000000000000000000000000000;;	lots_of_lines = 1 \
0000000000000000000000000000000000000000;;		2 \
0000000000000000000000000000000000000000;;		3 \
0000000000000000000000000000000000000000;;		4
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Piece of cake!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("advance").Key("two_lines").String() // how about continuation lines?
0000000000000000000000000000000000000000;;	cfg.Section("advance").Key("lots_of_lines").String() // 1 2 3 4
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note that single quotes around values will be stripped:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	foo = "some value" // foo: some value
0000000000000000000000000000000000000000;;	bar = 'some value' // bar: some value
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	That's all? Hmm, no.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Helper methods of working with values
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get value with given candidates:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("STRING").In("default", []string{"str", "arr", "types"})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("FLOAT64").InFloat64(1.1, []float64{1.25, 2.5, 3.75})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT").InInt(5, []int{10, 20, 30})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("INT64").InInt64(10, []int64{10, 20, 30})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT").InUint(4, []int{3, 6, 9})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("UINT64").InUint64(8, []int64{3, 6, 9})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").InTimeFormat(time.RFC3339, time.Now(), []time.Time{time1, time2, time3})
0000000000000000000000000000000000000000;;	v = cfg.Section("").Key("TIME").InTime(time.Now(), []time.Time{time1, time2, time3}) // RFC3339
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Default value will be presented if value of key is not in candidates you given, and default value does not need be one of candidates.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To validate value in a given range:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("FLOAT64").RangeFloat64(0.0, 1.1, 2.2)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INT").RangeInt(0, 10, 20)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INT64").RangeInt64(0, 10, 20)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINT").RangeUint(0, 3, 9)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINT64").RangeUint64(0, 3, 9)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("TIME").RangeTimeFormat(time.RFC3339, time.Now(), minTime, maxTime)
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("TIME").RangeTime(time.Now(), minTime, maxTime) // RFC3339
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To auto-split value into slice:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("STRINGS").Strings(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("FLOAT64S").Float64s(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INTS").Ints(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("INT64S").Int64s(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINTS").Uints(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("UINT64S").Uint64s(",")
0000000000000000000000000000000000000000;;	vals = cfg.Section("").Key("TIMES").Times(",")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Save your configuration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Finally, it's time to save your configuration to somewhere.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A typical way to save configuration is writing it to a file:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	err = cfg.SaveTo("my.ini")
0000000000000000000000000000000000000000;;	err = cfg.SaveToIndent("my.ini", "\t")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Another way to save is writing to a `io.Writer` interface:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	cfg.WriteTo(writer)
0000000000000000000000000000000000000000;;	cfg.WriteToIndent(writer, "\t")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Advanced Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Recursive Values
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For all value of keys, there is a special syntax `%(<name>)s`, where `<name>` is the key name in same section or default section, and `%(<name>)s` will be replaced by corresponding value(empty string if key not found). You can use this syntax at most 99 level of recursions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	NAME = ini
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[author]
0000000000000000000000000000000000000000;;	NAME = Unknwon
0000000000000000000000000000000000000000;;	GITHUB = https://github.com/%(NAME)s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[package]
0000000000000000000000000000000000000000;;	FULL_NAME = github.com/go-ini/%(NAME)s
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("author").Key("GITHUB").String()		// https://github.com/Unknwon
0000000000000000000000000000000000000000;;	cfg.Section("package").Key("FULL_NAME").String()	// github.com/go-ini/ini
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Parent-child Sections
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can use `.` in section name to indicate parent-child relationship between two or more sections. If the key not found in the child section, library will try again on its parent section until there is no parent section.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	NAME = ini
0000000000000000000000000000000000000000;;	VERSION = v1
0000000000000000000000000000000000000000;;	IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[package]
0000000000000000000000000000000000000000;;	CLONE_URL = https://%(IMPORT_PATH)s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[package.sub]
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("package.sub").Key("CLONE_URL").String()	// https://gopkg.in/ini.v1
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Auto-increment Key Names
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If key name is `-` in data source, then it would be seen as special syntax for auto-increment key name start from 1, and every section is independent on counter.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	[features]
0000000000000000000000000000000000000000;;	-: Support read/write comments of keys and sections
0000000000000000000000000000000000000000;;	-: Support auto-increment of key names
0000000000000000000000000000000000000000;;	-: Support load multiple files to overwrite key values
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg.Section("features").KeyStrings()	// []{"#1", "#2", "#3"}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Map To Struct
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Want more objective way to play with INI? Cool.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	Name = Unknwon
0000000000000000000000000000000000000000;;	age = 21
0000000000000000000000000000000000000000;;	Male = true
0000000000000000000000000000000000000000;;	Born = 1993-01-01T20:17:05Z
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Note]
0000000000000000000000000000000000000000;;	Content = Hi is a good man!
0000000000000000000000000000000000000000;;	Cities = HangZhou, Boston
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Note struct {
0000000000000000000000000000000000000000;;		Content string
0000000000000000000000000000000000000000;;		Cities  []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Person struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Age  int `ini:"age"`
0000000000000000000000000000000000000000;;		Male bool
0000000000000000000000000000000000000000;;		Born time.Time
0000000000000000000000000000000000000000;;		Note
0000000000000000000000000000000000000000;;		Created time.Time `ini:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		cfg, err := ini.Load("path/to/ini")
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;		p := new(Person)
0000000000000000000000000000000000000000;;		err = cfg.MapTo(p)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Things can be simpler.
0000000000000000000000000000000000000000;;		err = ini.MapTo(p, "path/to/ini")
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Just map a section? Fine.
0000000000000000000000000000000000000000;;		n := new(Note)
0000000000000000000000000000000000000000;;		err = cfg.Section("Note").MapTo(n)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Can I have default value for field? Absolutely.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Assign it before you map to struct. It will keep the value as it is if the key is not presented or got wrong type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	p := &Person{
0000000000000000000000000000000000000000;;		Name: "Joe",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It's really cool, but what's the point if you can't give me my file back from struct?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Reflect From Struct
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Why not?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Embeded struct {
0000000000000000000000000000000000000000;;		Dates  []time.Time `delim:"|"`
0000000000000000000000000000000000000000;;		Places []string
0000000000000000000000000000000000000000;;		None   []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Author struct {
0000000000000000000000000000000000000000;;		Name      string `ini:"NAME"`
0000000000000000000000000000000000000000;;		Male      bool
0000000000000000000000000000000000000000;;		Age       int
0000000000000000000000000000000000000000;;		GPA       float64
0000000000000000000000000000000000000000;;		NeverMind string `ini:"-"`
0000000000000000000000000000000000000000;;		*Embeded
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		a := &Author{"Unknwon", true, 21, 2.8, "",
0000000000000000000000000000000000000000;;			&Embeded{
0000000000000000000000000000000000000000;;				[]time.Time{time.Now(), time.Now()},
0000000000000000000000000000000000000000;;				[]string{"HangZhou", "Boston"},
0000000000000000000000000000000000000000;;				[]int{},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		cfg := ini.Empty()
0000000000000000000000000000000000000000;;		err = ini.ReflectFrom(cfg, a)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	So, what do I get?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	NAME = Unknwon
0000000000000000000000000000000000000000;;	Male = true
0000000000000000000000000000000000000000;;	Age = 21
0000000000000000000000000000000000000000;;	GPA = 2.8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Embeded]
0000000000000000000000000000000000000000;;	Dates = 2015-08-07T22:14:22+08:00|2015-08-07T22:14:22+08:00
0000000000000000000000000000000000000000;;	Places = HangZhou,Boston
0000000000000000000000000000000000000000;;	None =
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Name Mapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To save your time and make your code cleaner, this library supports [`NameMapper`](https://gowalker.org/gopkg.in/ini.v1#NameMapper) between struct field and actual section and key name.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are 2 built-in name mappers:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `AllCapsUnderscore`: it converts to format `ALL_CAPS_UNDERSCORE` then match section or key.
0000000000000000000000000000000000000000;;	- `TitleUnderscore`: it converts to format `title_underscore` then match section or key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To use them:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Info struct {
0000000000000000000000000000000000000000;;		PackageName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		err = ini.MapToWithMapper(&Info{}, ini.TitleUnderscore, []byte("packag_name=ini"))
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg, err := ini.Load([]byte("PACKAGE_NAME=ini"))
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;		info := new(Info)
0000000000000000000000000000000000000000;;		cfg.NameMapper = ini.AllCapsUnderscore
0000000000000000000000000000000000000000;;		err = cfg.MapTo(info)
0000000000000000000000000000000000000000;;		// ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Same rules of name mapper apply to `ini.ReflectFromWithMapper` function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Other Notes On Map/Reflect
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Any embedded struct is treated as a section by default, and there is no automatic parent-child relations in map/reflect feature:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Child struct {
0000000000000000000000000000000000000000;;		Age string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parent struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Child
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		City string
0000000000000000000000000000000000000000;;		Parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example configuration:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	City = Boston
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Parent]
0000000000000000000000000000000000000000;;	Name = Unknwon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Child]
0000000000000000000000000000000000000000;;	Age = 21
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	What if, yes, I'm paranoid, I want embedded struct to be in the same section. Well, all roads lead to Rome.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Child struct {
0000000000000000000000000000000000000000;;		Age string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parent struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Child `ini:"Parent"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		City string
0000000000000000000000000000000000000000;;		Parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example configuration:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```ini
0000000000000000000000000000000000000000;;	City = Boston
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Parent]
0000000000000000000000000000000000000000;;	Name = Unknwon
0000000000000000000000000000000000000000;;	Age = 21
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Getting Help
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- [API Documentation](https://gowalker.org/gopkg.in/ini.v1)
0000000000000000000000000000000000000000;;	- [File An Issue](https://github.com/go-ini/ini/issues/new)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## FAQs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### What does `BlockMode` field do?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	By default, library lets you read and write values so we need a locker to make sure your data is safe. But in cases that you are very sure about only reading data through the library, you can set `cfg.BlockMode = false` to speed up read operations about **50-70%** faster.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Why another INI library?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Many people are using my another INI library [goconfig](https://github.com/Unknwon/goconfig), so the reason for this one is I would like to make more Go style code. Also when you set `cfg.BlockMode = false`, this one is about **10-30%** faster.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To make those changes I have to confirm API broken, so it's safer to keep it in another place and start using `gopkg.in` to version my package at this time.(PS: shorter import path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## License
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This project is under Apache v2 License. See the [LICENSE](LICENSE) file for the full license text.
