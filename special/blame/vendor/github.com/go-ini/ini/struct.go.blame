0000000000000000000000000000000000000000;;	// Copyright 2014 Unknwon
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/go-ini/ini/struct.go[Godeps/_workspace/src/github.com/go-ini/ini/struct.go][vendor/github.com/go-ini/ini/struct.go];	
0000000000000000000000000000000000000000;;	package ini
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameMapper represents a ini tag name mapper.
0000000000000000000000000000000000000000;;	type NameMapper func(string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Built-in name getters.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// AllCapsUnderscore converts to format ALL_CAPS_UNDERSCORE.
0000000000000000000000000000000000000000;;		AllCapsUnderscore NameMapper = func(raw string) string {
0000000000000000000000000000000000000000;;			newstr := make([]rune, 0, len(raw))
0000000000000000000000000000000000000000;;			for i, chr := range raw {
0000000000000000000000000000000000000000;;				if isUpper := 'A' <= chr && chr <= 'Z'; isUpper {
0000000000000000000000000000000000000000;;					if i > 0 {
0000000000000000000000000000000000000000;;						newstr = append(newstr, '_')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newstr = append(newstr, unicode.ToUpper(chr))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string(newstr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TitleUnderscore converts to format title_underscore.
0000000000000000000000000000000000000000;;		TitleUnderscore NameMapper = func(raw string) string {
0000000000000000000000000000000000000000;;			newstr := make([]rune, 0, len(raw))
0000000000000000000000000000000000000000;;			for i, chr := range raw {
0000000000000000000000000000000000000000;;				if isUpper := 'A' <= chr && chr <= 'Z'; isUpper {
0000000000000000000000000000000000000000;;					if i > 0 {
0000000000000000000000000000000000000000;;						newstr = append(newstr, '_')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					chr -= ('A' - 'a')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newstr = append(newstr, chr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string(newstr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Section) parseFieldName(raw, actual string) string {
0000000000000000000000000000000000000000;;		if len(actual) > 0 {
0000000000000000000000000000000000000000;;			return actual
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.f.NameMapper != nil {
0000000000000000000000000000000000000000;;			return s.f.NameMapper(raw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return raw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseDelim(actual string) string {
0000000000000000000000000000000000000000;;		if len(actual) > 0 {
0000000000000000000000000000000000000000;;			return actual
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ","
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var reflectTime = reflect.TypeOf(time.Now()).Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setWithProperType sets proper value to field based on its type,
0000000000000000000000000000000000000000;;	// but it does not return error for failing parsing,
0000000000000000000000000000000000000000;;	// because we want to use default value that is already assigned to strcut.
0000000000000000000000000000000000000000;;	func setWithProperType(t reflect.Type, key *Key, field reflect.Value, delim string) error {
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if len(key.String()) == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.SetString(key.String())
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			boolVal, err := key.Bool()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.SetBool(boolVal)
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			durationVal, err := key.Duration()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				field.Set(reflect.ValueOf(durationVal))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			intVal, err := key.Int64()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.SetInt(intVal)
0000000000000000000000000000000000000000;;		//	byte is an alias for uint8, so supporting uint8 breaks support for byte
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			durationVal, err := key.Duration()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				field.Set(reflect.ValueOf(durationVal))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			uintVal, err := key.Uint64()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.SetUint(uintVal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			floatVal, err := key.Float64()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.SetFloat(floatVal)
0000000000000000000000000000000000000000;;		case reflectTime:
0000000000000000000000000000000000000000;;			timeVal, err := key.Time()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.Set(reflect.ValueOf(timeVal))
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			vals := key.Strings(delim)
0000000000000000000000000000000000000000;;			numVals := len(vals)
0000000000000000000000000000000000000000;;			if numVals == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sliceOf := field.Type().Elem().Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var times []time.Time
0000000000000000000000000000000000000000;;			if sliceOf == reflectTime {
0000000000000000000000000000000000000000;;				times = key.Times(delim)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			slice := reflect.MakeSlice(field.Type(), numVals, numVals)
0000000000000000000000000000000000000000;;			for i := 0; i < numVals; i++ {
0000000000000000000000000000000000000000;;				switch sliceOf {
0000000000000000000000000000000000000000;;				case reflectTime:
0000000000000000000000000000000000000000;;					slice.Index(i).Set(reflect.ValueOf(times[i]))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					slice.Index(i).Set(reflect.ValueOf(vals[i]))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			field.Set(slice)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported type '%s'", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Section) mapTo(val reflect.Value) error {
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typ := val.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < typ.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := val.Field(i)
0000000000000000000000000000000000000000;;			tpField := typ.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tag := tpField.Tag.Get("ini")
0000000000000000000000000000000000000000;;			if tag == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fieldName := s.parseFieldName(tpField.Name, tag)
0000000000000000000000000000000000000000;;			if len(fieldName) == 0 || !field.CanSet() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isAnonymous := tpField.Type.Kind() == reflect.Ptr && tpField.Anonymous
0000000000000000000000000000000000000000;;			isStruct := tpField.Type.Kind() == reflect.Struct
0000000000000000000000000000000000000000;;			if isAnonymous {
0000000000000000000000000000000000000000;;				field.Set(reflect.New(tpField.Type.Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isAnonymous || isStruct {
0000000000000000000000000000000000000000;;				if sec, err := s.f.GetSection(fieldName); err == nil {
0000000000000000000000000000000000000000;;					if err = sec.mapTo(field); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("error mapping field(%s): %v", fieldName, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if key, err := s.GetKey(fieldName); err == nil {
0000000000000000000000000000000000000000;;				if err = setWithProperType(tpField.Type, key, field, parseDelim(tpField.Tag.Get("delim"))); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error mapping field(%s): %v", fieldName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapTo maps section to given struct.
0000000000000000000000000000000000000000;;	func (s *Section) MapTo(v interface{}) error {
0000000000000000000000000000000000000000;;		typ := reflect.TypeOf(v)
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(v)
0000000000000000000000000000000000000000;;		if typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			typ = typ.Elem()
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return errors.New("cannot map to non-pointer struct")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.mapTo(val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapTo maps file to given struct.
0000000000000000000000000000000000000000;;	func (f *File) MapTo(v interface{}) error {
0000000000000000000000000000000000000000;;		return f.Section("").MapTo(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapTo maps data sources to given struct with name mapper.
0000000000000000000000000000000000000000;;	func MapToWithMapper(v interface{}, mapper NameMapper, source interface{}, others ...interface{}) error {
0000000000000000000000000000000000000000;;		cfg, err := Load(source, others...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg.NameMapper = mapper
0000000000000000000000000000000000000000;;		return cfg.MapTo(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapTo maps data sources to given struct.
0000000000000000000000000000000000000000;;	func MapTo(v, source interface{}, others ...interface{}) error {
0000000000000000000000000000000000000000;;		return MapToWithMapper(v, nil, source, others...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reflectWithProperType does the opposite thing with setWithProperType.
0000000000000000000000000000000000000000;;	func reflectWithProperType(t reflect.Type, key *Key, field reflect.Value, delim string) error {
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			key.SetValue(field.String())
0000000000000000000000000000000000000000;;		case reflect.Bool,
0000000000000000000000000000000000000000;;			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
0000000000000000000000000000000000000000;;			reflect.Float64,
0000000000000000000000000000000000000000;;			reflectTime:
0000000000000000000000000000000000000000;;			key.SetValue(fmt.Sprint(field))
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			vals := field.Slice(0, field.Len())
0000000000000000000000000000000000000000;;			if field.Len() == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var buf bytes.Buffer
0000000000000000000000000000000000000000;;			isTime := fmt.Sprint(field.Type()) == "[]time.Time"
0000000000000000000000000000000000000000;;			for i := 0; i < field.Len(); i++ {
0000000000000000000000000000000000000000;;				if isTime {
0000000000000000000000000000000000000000;;					buf.WriteString(vals.Index(i).Interface().(time.Time).Format(time.RFC3339))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					buf.WriteString(fmt.Sprint(vals.Index(i)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(delim)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key.SetValue(buf.String()[:buf.Len()-1])
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported type '%s'", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Section) reflectFrom(val reflect.Value) error {
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typ := val.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < typ.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := val.Field(i)
0000000000000000000000000000000000000000;;			tpField := typ.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tag := tpField.Tag.Get("ini")
0000000000000000000000000000000000000000;;			if tag == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fieldName := s.parseFieldName(tpField.Name, tag)
0000000000000000000000000000000000000000;;			if len(fieldName) == 0 || !field.CanSet() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if (tpField.Type.Kind() == reflect.Ptr && tpField.Anonymous) ||
0000000000000000000000000000000000000000;;				(tpField.Type.Kind() == reflect.Struct) {
0000000000000000000000000000000000000000;;				// Note: The only error here is section doesn't exist.
0000000000000000000000000000000000000000;;				sec, err := s.f.GetSection(fieldName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Note: fieldName can never be empty here, ignore error.
0000000000000000000000000000000000000000;;					sec, _ = s.f.NewSection(fieldName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err = sec.reflectFrom(field); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error reflecting field(%s): %v", fieldName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Note: Same reason as secion.
0000000000000000000000000000000000000000;;			key, err := s.GetKey(fieldName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				key, _ = s.NewKey(fieldName, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = reflectWithProperType(tpField.Type, key, field, parseDelim(tpField.Tag.Get("delim"))); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error reflecting field(%s): %v", fieldName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReflectFrom reflects secion from given struct.
0000000000000000000000000000000000000000;;	func (s *Section) ReflectFrom(v interface{}) error {
0000000000000000000000000000000000000000;;		typ := reflect.TypeOf(v)
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(v)
0000000000000000000000000000000000000000;;		if typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			typ = typ.Elem()
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return errors.New("cannot reflect from non-pointer struct")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.reflectFrom(val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReflectFrom reflects file from given struct.
0000000000000000000000000000000000000000;;	func (f *File) ReflectFrom(v interface{}) error {
0000000000000000000000000000000000000000;;		return f.Section("").ReflectFrom(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReflectFrom reflects data sources from given struct with name mapper.
0000000000000000000000000000000000000000;;	func ReflectFromWithMapper(cfg *File, v interface{}, mapper NameMapper) error {
0000000000000000000000000000000000000000;;		cfg.NameMapper = mapper
0000000000000000000000000000000000000000;;		return cfg.ReflectFrom(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReflectFrom reflects data sources from given struct.
0000000000000000000000000000000000000000;;	func ReflectFrom(cfg *File, v interface{}) error {
0000000000000000000000000000000000000000;;		return ReflectFromWithMapper(cfg, v, nil)
0000000000000000000000000000000000000000;;	}
