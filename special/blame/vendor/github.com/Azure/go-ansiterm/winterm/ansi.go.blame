0000000000000000000000000000000000000000;;	// +build windows
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	package winterm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/go-ansiterm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Windows keyboard constants
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		VK_PRIOR    = 0x21 // PAGE UP key
0000000000000000000000000000000000000000;;		VK_NEXT     = 0x22 // PAGE DOWN key
0000000000000000000000000000000000000000;;		VK_END      = 0x23 // END key
0000000000000000000000000000000000000000;;		VK_HOME     = 0x24 // HOME key
0000000000000000000000000000000000000000;;		VK_LEFT     = 0x25 // LEFT ARROW key
0000000000000000000000000000000000000000;;		VK_UP       = 0x26 // UP ARROW key
0000000000000000000000000000000000000000;;		VK_RIGHT    = 0x27 // RIGHT ARROW key
0000000000000000000000000000000000000000;;		VK_DOWN     = 0x28 // DOWN ARROW key
0000000000000000000000000000000000000000;;		VK_SELECT   = 0x29 // SELECT key
0000000000000000000000000000000000000000;;		VK_PRINT    = 0x2A // PRINT key
0000000000000000000000000000000000000000;;		VK_EXECUTE  = 0x2B // EXECUTE key
0000000000000000000000000000000000000000;;		VK_SNAPSHOT = 0x2C // PRINT SCREEN key
0000000000000000000000000000000000000000;;		VK_INSERT   = 0x2D // INS key
0000000000000000000000000000000000000000;;		VK_DELETE   = 0x2E // DEL key
0000000000000000000000000000000000000000;;		VK_HELP     = 0x2F // HELP key
0000000000000000000000000000000000000000;;		VK_F1       = 0x70 // F1 key
0000000000000000000000000000000000000000;;		VK_F2       = 0x71 // F2 key
0000000000000000000000000000000000000000;;		VK_F3       = 0x72 // F3 key
0000000000000000000000000000000000000000;;		VK_F4       = 0x73 // F4 key
0000000000000000000000000000000000000000;;		VK_F5       = 0x74 // F5 key
0000000000000000000000000000000000000000;;		VK_F6       = 0x75 // F6 key
0000000000000000000000000000000000000000;;		VK_F7       = 0x76 // F7 key
0000000000000000000000000000000000000000;;		VK_F8       = 0x77 // F8 key
0000000000000000000000000000000000000000;;		VK_F9       = 0x78 // F9 key
0000000000000000000000000000000000000000;;		VK_F10      = 0x79 // F10 key
0000000000000000000000000000000000000000;;		VK_F11      = 0x7A // F11 key
0000000000000000000000000000000000000000;;		VK_F12      = 0x7B // F12 key
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RIGHT_ALT_PRESSED  = 0x0001
0000000000000000000000000000000000000000;;		LEFT_ALT_PRESSED   = 0x0002
0000000000000000000000000000000000000000;;		RIGHT_CTRL_PRESSED = 0x0004
0000000000000000000000000000000000000000;;		LEFT_CTRL_PRESSED  = 0x0008
0000000000000000000000000000000000000000;;		SHIFT_PRESSED      = 0x0010
0000000000000000000000000000000000000000;;		NUMLOCK_ON         = 0x0020
0000000000000000000000000000000000000000;;		SCROLLLOCK_ON      = 0x0040
0000000000000000000000000000000000000000;;		CAPSLOCK_ON        = 0x0080
0000000000000000000000000000000000000000;;		ENHANCED_KEY       = 0x0100
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ansiCommand struct {
0000000000000000000000000000000000000000;;		CommandBytes []byte
0000000000000000000000000000000000000000;;		Command      string
0000000000000000000000000000000000000000;;		Parameters   []string
0000000000000000000000000000000000000000;;		IsSpecial    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAnsiCommand(command []byte) *ansiCommand {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isCharacterSelectionCmdChar(command[1]) {
0000000000000000000000000000000000000000;;			// Is Character Set Selection commands
0000000000000000000000000000000000000000;;			return &ansiCommand{
0000000000000000000000000000000000000000;;				CommandBytes: command,
0000000000000000000000000000000000000000;;				Command:      string(command),
0000000000000000000000000000000000000000;;				IsSpecial:    true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// last char is command character
0000000000000000000000000000000000000000;;		lastCharIndex := len(command) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ac := &ansiCommand{
0000000000000000000000000000000000000000;;			CommandBytes: command,
0000000000000000000000000000000000000000;;			Command:      string(command[lastCharIndex]),
0000000000000000000000000000000000000000;;			IsSpecial:    false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// more than a single escape
0000000000000000000000000000000000000000;;		if lastCharIndex != 0 {
0000000000000000000000000000000000000000;;			start := 1
0000000000000000000000000000000000000000;;			// skip if double char escape sequence
0000000000000000000000000000000000000000;;			if command[0] == ansiterm.ANSI_ESCAPE_PRIMARY && command[1] == ansiterm.ANSI_ESCAPE_SECONDARY {
0000000000000000000000000000000000000000;;				start++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// convert this to GetNextParam method
0000000000000000000000000000000000000000;;			ac.Parameters = strings.Split(string(command[start:lastCharIndex]), ansiterm.ANSI_PARAMETER_SEP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ac
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ac *ansiCommand) paramAsSHORT(index int, defaultValue int16) int16 {
0000000000000000000000000000000000000000;;		if index < 0 || index >= len(ac.Parameters) {
0000000000000000000000000000000000000000;;			return defaultValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		param, err := strconv.ParseInt(ac.Parameters[index], 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return defaultValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return int16(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ac *ansiCommand) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("0x%v \"%v\" (\"%v\")",
0000000000000000000000000000000000000000;;			bytesToHex(ac.CommandBytes),
0000000000000000000000000000000000000000;;			ac.Command,
0000000000000000000000000000000000000000;;			strings.Join(ac.Parameters, "\",\""))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isAnsiCommandChar returns true if the passed byte falls within the range of ANSI commands.
0000000000000000000000000000000000000000;;	// See http://manpages.ubuntu.com/manpages/intrepid/man4/console_codes.4.html.
0000000000000000000000000000000000000000;;	func isAnsiCommandChar(b byte) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case ansiterm.ANSI_COMMAND_FIRST <= b && b <= ansiterm.ANSI_COMMAND_LAST && b != ansiterm.ANSI_ESCAPE_SECONDARY:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case b == ansiterm.ANSI_CMD_G1 || b == ansiterm.ANSI_CMD_OSC || b == ansiterm.ANSI_CMD_DECPAM || b == ansiterm.ANSI_CMD_DECPNM:
0000000000000000000000000000000000000000;;			// non-CSI escape sequence terminator
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case b == ansiterm.ANSI_CMD_STR_TERM || b == ansiterm.ANSI_BEL:
0000000000000000000000000000000000000000;;			// String escape sequence terminator
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isXtermOscSequence(command []byte, current byte) bool {
0000000000000000000000000000000000000000;;		return (len(command) >= 2 && command[0] == ansiterm.ANSI_ESCAPE_PRIMARY && command[1] == ansiterm.ANSI_CMD_OSC && current != ansiterm.ANSI_BEL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isCharacterSelectionCmdChar(b byte) bool {
0000000000000000000000000000000000000000;;		return (b == ansiterm.ANSI_CMD_G0 || b == ansiterm.ANSI_CMD_G1 || b == ansiterm.ANSI_CMD_G2 || b == ansiterm.ANSI_CMD_G3)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bytesToHex converts a slice of bytes to a human-readable string.
0000000000000000000000000000000000000000;;	func bytesToHex(b []byte) string {
0000000000000000000000000000000000000000;;		hex := make([]string, len(b))
0000000000000000000000000000000000000000;;		for i, ch := range b {
0000000000000000000000000000000000000000;;			hex[i] = fmt.Sprintf("%X", ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(hex, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureInRange adjusts the passed value, if necessary, to ensure it is within
0000000000000000000000000000000000000000;;	// the passed min / max range.
0000000000000000000000000000000000000000;;	func ensureInRange(n int16, min int16, max int16) int16 {
0000000000000000000000000000000000000000;;		if n < min {
0000000000000000000000000000000000000000;;			return min
0000000000000000000000000000000000000000;;		} else if n > max {
0000000000000000000000000000000000000000;;			return max
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetStdFile(nFile int) (*os.File, uintptr) {
0000000000000000000000000000000000000000;;		var file *os.File
0000000000000000000000000000000000000000;;		switch nFile {
0000000000000000000000000000000000000000;;		case syscall.STD_INPUT_HANDLE:
0000000000000000000000000000000000000000;;			file = os.Stdin
0000000000000000000000000000000000000000;;		case syscall.STD_OUTPUT_HANDLE:
0000000000000000000000000000000000000000;;			file = os.Stdout
0000000000000000000000000000000000000000;;		case syscall.STD_ERROR_HANDLE:
0000000000000000000000000000000000000000;;			file = os.Stderr
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("Invalid standard handle identifier: %v", nFile))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fd, err := syscall.GetStdHandle(nFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("Invalid standard handle indentifier: %v -- %v", nFile, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return file, uintptr(fd)
0000000000000000000000000000000000000000;;	}
