0000000000000000000000000000000000000000;;	// +build windows
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	package winterm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//===========================================================================================================
0000000000000000000000000000000000000000;;	// IMPORTANT NOTE:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	The methods below make extensive use of the "unsafe" package to obtain the required pointers.
0000000000000000000000000000000000000000;;	//	Beginning in Go 1.3, the garbage collector may release local variables (e.g., incoming arguments, stack
0000000000000000000000000000000000000000;;	//	variables) the pointers reference *before* the API completes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  As a result, in those cases, the code must hint that the variables remain in active by invoking the
0000000000000000000000000000000000000000;;	//	dummy method "use" (see below). Newer versions of Go are planned to change the mechanism to no longer
0000000000000000000000000000000000000000;;	//	require unsafe pointers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	If you add or modify methods, ENSURE protection of local variables through the "use" builtin to inform
0000000000000000000000000000000000000000;;	//	the garbage collector the variables remain in use if:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	-- The value is not a pointer (e.g., int32, struct)
0000000000000000000000000000000000000000;;	//	-- The value is not referenced by the method after passing the pointer to Windows
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	See http://golang.org/doc/go1.3.
0000000000000000000000000000000000000000;;	//===========================================================================================================
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		kernel32DLL = syscall.NewLazyDLL("kernel32.dll")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getConsoleCursorInfoProc       = kernel32DLL.NewProc("GetConsoleCursorInfo")
0000000000000000000000000000000000000000;;		setConsoleCursorInfoProc       = kernel32DLL.NewProc("SetConsoleCursorInfo")
0000000000000000000000000000000000000000;;		setConsoleCursorPositionProc   = kernel32DLL.NewProc("SetConsoleCursorPosition")
0000000000000000000000000000000000000000;;		setConsoleModeProc             = kernel32DLL.NewProc("SetConsoleMode")
0000000000000000000000000000000000000000;;		getConsoleScreenBufferInfoProc = kernel32DLL.NewProc("GetConsoleScreenBufferInfo")
0000000000000000000000000000000000000000;;		setConsoleScreenBufferSizeProc = kernel32DLL.NewProc("SetConsoleScreenBufferSize")
0000000000000000000000000000000000000000;;		scrollConsoleScreenBufferProc  = kernel32DLL.NewProc("ScrollConsoleScreenBufferA")
0000000000000000000000000000000000000000;;		setConsoleTextAttributeProc    = kernel32DLL.NewProc("SetConsoleTextAttribute")
0000000000000000000000000000000000000000;;		setConsoleWindowInfoProc       = kernel32DLL.NewProc("SetConsoleWindowInfo")
0000000000000000000000000000000000000000;;		writeConsoleOutputProc         = kernel32DLL.NewProc("WriteConsoleOutputW")
0000000000000000000000000000000000000000;;		readConsoleInputProc           = kernel32DLL.NewProc("ReadConsoleInputW")
0000000000000000000000000000000000000000;;		waitForSingleObjectProc        = kernel32DLL.NewProc("WaitForSingleObject")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Windows Console constants
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Console modes
0000000000000000000000000000000000000000;;		// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms686033(v=vs.85).aspx.
0000000000000000000000000000000000000000;;		ENABLE_PROCESSED_INPUT = 0x0001
0000000000000000000000000000000000000000;;		ENABLE_LINE_INPUT      = 0x0002
0000000000000000000000000000000000000000;;		ENABLE_ECHO_INPUT      = 0x0004
0000000000000000000000000000000000000000;;		ENABLE_WINDOW_INPUT    = 0x0008
0000000000000000000000000000000000000000;;		ENABLE_MOUSE_INPUT     = 0x0010
0000000000000000000000000000000000000000;;		ENABLE_INSERT_MODE     = 0x0020
0000000000000000000000000000000000000000;;		ENABLE_QUICK_EDIT_MODE = 0x0040
0000000000000000000000000000000000000000;;		ENABLE_EXTENDED_FLAGS  = 0x0080
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ENABLE_PROCESSED_OUTPUT   = 0x0001
0000000000000000000000000000000000000000;;		ENABLE_WRAP_AT_EOL_OUTPUT = 0x0002
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Character attributes
0000000000000000000000000000000000000000;;		// Note:
0000000000000000000000000000000000000000;;		// -- The attributes are combined to produce various colors (e.g., Blue + Green will create Cyan).
0000000000000000000000000000000000000000;;		//    Clearing all foreground or background colors results in black; setting all creates white.
0000000000000000000000000000000000000000;;		// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms682088(v=vs.85).aspx#_win32_character_attributes.
0000000000000000000000000000000000000000;;		FOREGROUND_BLUE      uint16 = 0x0001
0000000000000000000000000000000000000000;;		FOREGROUND_GREEN     uint16 = 0x0002
0000000000000000000000000000000000000000;;		FOREGROUND_RED       uint16 = 0x0004
0000000000000000000000000000000000000000;;		FOREGROUND_INTENSITY uint16 = 0x0008
0000000000000000000000000000000000000000;;		FOREGROUND_MASK      uint16 = 0x000F
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BACKGROUND_BLUE      uint16 = 0x0010
0000000000000000000000000000000000000000;;		BACKGROUND_GREEN     uint16 = 0x0020
0000000000000000000000000000000000000000;;		BACKGROUND_RED       uint16 = 0x0040
0000000000000000000000000000000000000000;;		BACKGROUND_INTENSITY uint16 = 0x0080
0000000000000000000000000000000000000000;;		BACKGROUND_MASK      uint16 = 0x00F0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		COMMON_LVB_MASK          uint16 = 0xFF00
0000000000000000000000000000000000000000;;		COMMON_LVB_REVERSE_VIDEO uint16 = 0x4000
0000000000000000000000000000000000000000;;		COMMON_LVB_UNDERSCORE    uint16 = 0x8000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Input event types
0000000000000000000000000000000000000000;;		// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms683499(v=vs.85).aspx.
0000000000000000000000000000000000000000;;		KEY_EVENT                = 0x0001
0000000000000000000000000000000000000000;;		MOUSE_EVENT              = 0x0002
0000000000000000000000000000000000000000;;		WINDOW_BUFFER_SIZE_EVENT = 0x0004
0000000000000000000000000000000000000000;;		MENU_EVENT               = 0x0008
0000000000000000000000000000000000000000;;		FOCUS_EVENT              = 0x0010
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WaitForSingleObject return codes
0000000000000000000000000000000000000000;;		WAIT_ABANDONED = 0x00000080
0000000000000000000000000000000000000000;;		WAIT_FAILED    = 0xFFFFFFFF
0000000000000000000000000000000000000000;;		WAIT_SIGNALED  = 0x0000000
0000000000000000000000000000000000000000;;		WAIT_TIMEOUT   = 0x00000102
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WaitForSingleObject wait duration
0000000000000000000000000000000000000000;;		WAIT_INFINITE       = 0xFFFFFFFF
0000000000000000000000000000000000000000;;		WAIT_ONE_SECOND     = 1000
0000000000000000000000000000000000000000;;		WAIT_HALF_SECOND    = 500
0000000000000000000000000000000000000000;;		WAIT_QUARTER_SECOND = 250
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Windows API Console types
0000000000000000000000000000000000000000;;	// -- See https://msdn.microsoft.com/en-us/library/windows/desktop/ms682101(v=vs.85).aspx for Console specific types (e.g., COORD)
0000000000000000000000000000000000000000;;	// -- See https://msdn.microsoft.com/en-us/library/aa296569(v=vs.60).aspx for comments on alignment
0000000000000000000000000000000000000000;;	type (
0000000000000000000000000000000000000000;;		CHAR_INFO struct {
0000000000000000000000000000000000000000;;			UnicodeChar uint16
0000000000000000000000000000000000000000;;			Attributes  uint16
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CONSOLE_CURSOR_INFO struct {
0000000000000000000000000000000000000000;;			Size    uint32
0000000000000000000000000000000000000000;;			Visible int32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CONSOLE_SCREEN_BUFFER_INFO struct {
0000000000000000000000000000000000000000;;			Size              COORD
0000000000000000000000000000000000000000;;			CursorPosition    COORD
0000000000000000000000000000000000000000;;			Attributes        uint16
0000000000000000000000000000000000000000;;			Window            SMALL_RECT
0000000000000000000000000000000000000000;;			MaximumWindowSize COORD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		COORD struct {
0000000000000000000000000000000000000000;;			X int16
0000000000000000000000000000000000000000;;			Y int16
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SMALL_RECT struct {
0000000000000000000000000000000000000000;;			Left   int16
0000000000000000000000000000000000000000;;			Top    int16
0000000000000000000000000000000000000000;;			Right  int16
0000000000000000000000000000000000000000;;			Bottom int16
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// INPUT_RECORD is a C/C++ union of which KEY_EVENT_RECORD is one case, it is also the largest
0000000000000000000000000000000000000000;;		// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms683499(v=vs.85).aspx.
0000000000000000000000000000000000000000;;		INPUT_RECORD struct {
0000000000000000000000000000000000000000;;			EventType uint16
0000000000000000000000000000000000000000;;			KeyEvent  KEY_EVENT_RECORD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		KEY_EVENT_RECORD struct {
0000000000000000000000000000000000000000;;			KeyDown         int32
0000000000000000000000000000000000000000;;			RepeatCount     uint16
0000000000000000000000000000000000000000;;			VirtualKeyCode  uint16
0000000000000000000000000000000000000000;;			VirtualScanCode uint16
0000000000000000000000000000000000000000;;			UnicodeChar     uint16
0000000000000000000000000000000000000000;;			ControlKeyState uint32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		WINDOW_BUFFER_SIZE struct {
0000000000000000000000000000000000000000;;			Size COORD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// boolToBOOL converts a Go bool into a Windows int32.
0000000000000000000000000000000000000000;;	func boolToBOOL(f bool) int32 {
0000000000000000000000000000000000000000;;		if f {
0000000000000000000000000000000000000000;;			return int32(1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return int32(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetConsoleCursorInfo retrieves information about the size and visiblity of the console cursor.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms683163(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func GetConsoleCursorInfo(handle uintptr, cursorInfo *CONSOLE_CURSOR_INFO) error {
0000000000000000000000000000000000000000;;		r1, r2, err := getConsoleCursorInfoProc.Call(handle, uintptr(unsafe.Pointer(cursorInfo)), 0)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetConsoleCursorInfo sets the size and visiblity of the console cursor.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms686019(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func SetConsoleCursorInfo(handle uintptr, cursorInfo *CONSOLE_CURSOR_INFO) error {
0000000000000000000000000000000000000000;;		r1, r2, err := setConsoleCursorInfoProc.Call(handle, uintptr(unsafe.Pointer(cursorInfo)), 0)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetConsoleCursorPosition location of the console cursor.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms686025(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func SetConsoleCursorPosition(handle uintptr, coord COORD) error {
0000000000000000000000000000000000000000;;		r1, r2, err := setConsoleCursorPositionProc.Call(handle, coordToPointer(coord))
0000000000000000000000000000000000000000;;		use(coord)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetConsoleMode gets the console mode for given file descriptor
0000000000000000000000000000000000000000;;	// See http://msdn.microsoft.com/en-us/library/windows/desktop/ms683167(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func GetConsoleMode(handle uintptr) (mode uint32, err error) {
0000000000000000000000000000000000000000;;		err = syscall.GetConsoleMode(syscall.Handle(handle), &mode)
0000000000000000000000000000000000000000;;		return mode, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetConsoleMode sets the console mode for given file descriptor
0000000000000000000000000000000000000000;;	// See http://msdn.microsoft.com/en-us/library/windows/desktop/ms686033(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func SetConsoleMode(handle uintptr, mode uint32) error {
0000000000000000000000000000000000000000;;		r1, r2, err := setConsoleModeProc.Call(handle, uintptr(mode), 0)
0000000000000000000000000000000000000000;;		use(mode)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetConsoleScreenBufferInfo retrieves information about the specified console screen buffer.
0000000000000000000000000000000000000000;;	// See http://msdn.microsoft.com/en-us/library/windows/desktop/ms683171(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func GetConsoleScreenBufferInfo(handle uintptr) (*CONSOLE_SCREEN_BUFFER_INFO, error) {
0000000000000000000000000000000000000000;;		info := CONSOLE_SCREEN_BUFFER_INFO{}
0000000000000000000000000000000000000000;;		err := checkError(getConsoleScreenBufferInfoProc.Call(handle, uintptr(unsafe.Pointer(&info)), 0))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &info, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ScrollConsoleScreenBuffer(handle uintptr, scrollRect SMALL_RECT, clipRect SMALL_RECT, destOrigin COORD, char CHAR_INFO) error {
0000000000000000000000000000000000000000;;		r1, r2, err := scrollConsoleScreenBufferProc.Call(handle, uintptr(unsafe.Pointer(&scrollRect)), uintptr(unsafe.Pointer(&clipRect)), coordToPointer(destOrigin), uintptr(unsafe.Pointer(&char)))
0000000000000000000000000000000000000000;;		use(scrollRect)
0000000000000000000000000000000000000000;;		use(clipRect)
0000000000000000000000000000000000000000;;		use(destOrigin)
0000000000000000000000000000000000000000;;		use(char)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetConsoleScreenBufferSize sets the size of the console screen buffer.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms686044(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func SetConsoleScreenBufferSize(handle uintptr, coord COORD) error {
0000000000000000000000000000000000000000;;		r1, r2, err := setConsoleScreenBufferSizeProc.Call(handle, coordToPointer(coord))
0000000000000000000000000000000000000000;;		use(coord)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetConsoleTextAttribute sets the attributes of characters written to the
0000000000000000000000000000000000000000;;	// console screen buffer by the WriteFile or WriteConsole function.
0000000000000000000000000000000000000000;;	// See http://msdn.microsoft.com/en-us/library/windows/desktop/ms686047(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func SetConsoleTextAttribute(handle uintptr, attribute uint16) error {
0000000000000000000000000000000000000000;;		r1, r2, err := setConsoleTextAttributeProc.Call(handle, uintptr(attribute), 0)
0000000000000000000000000000000000000000;;		use(attribute)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetConsoleWindowInfo sets the size and position of the console screen buffer's window.
0000000000000000000000000000000000000000;;	// Note that the size and location must be within and no larger than the backing console screen buffer.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms686125(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func SetConsoleWindowInfo(handle uintptr, isAbsolute bool, rect SMALL_RECT) error {
0000000000000000000000000000000000000000;;		r1, r2, err := setConsoleWindowInfoProc.Call(handle, uintptr(boolToBOOL(isAbsolute)), uintptr(unsafe.Pointer(&rect)))
0000000000000000000000000000000000000000;;		use(isAbsolute)
0000000000000000000000000000000000000000;;		use(rect)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteConsoleOutput writes the CHAR_INFOs from the provided buffer to the active console buffer.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms687404(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func WriteConsoleOutput(handle uintptr, buffer []CHAR_INFO, bufferSize COORD, bufferCoord COORD, writeRegion *SMALL_RECT) error {
0000000000000000000000000000000000000000;;		r1, r2, err := writeConsoleOutputProc.Call(handle, uintptr(unsafe.Pointer(&buffer[0])), coordToPointer(bufferSize), coordToPointer(bufferCoord), uintptr(unsafe.Pointer(writeRegion)))
0000000000000000000000000000000000000000;;		use(buffer)
0000000000000000000000000000000000000000;;		use(bufferSize)
0000000000000000000000000000000000000000;;		use(bufferCoord)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadConsoleInput reads (and removes) data from the console input buffer.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684961(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func ReadConsoleInput(handle uintptr, buffer []INPUT_RECORD, count *uint32) error {
0000000000000000000000000000000000000000;;		r1, r2, err := readConsoleInputProc.Call(handle, uintptr(unsafe.Pointer(&buffer[0])), uintptr(len(buffer)), uintptr(unsafe.Pointer(count)))
0000000000000000000000000000000000000000;;		use(buffer)
0000000000000000000000000000000000000000;;		return checkError(r1, r2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForSingleObject waits for the passed handle to be signaled.
0000000000000000000000000000000000000000;;	// It returns true if the handle was signaled; false otherwise.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx.
0000000000000000000000000000000000000000;;	func WaitForSingleObject(handle uintptr, msWait uint32) (bool, error) {
0000000000000000000000000000000000000000;;		r1, _, err := waitForSingleObjectProc.Call(handle, uintptr(uint32(msWait)))
0000000000000000000000000000000000000000;;		switch r1 {
0000000000000000000000000000000000000000;;		case WAIT_ABANDONED, WAIT_TIMEOUT:
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		case WAIT_SIGNALED:
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		use(msWait)
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String helpers
0000000000000000000000000000000000000000;;	func (info CONSOLE_SCREEN_BUFFER_INFO) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Size(%v) Cursor(%v) Window(%v) Max(%v)", info.Size, info.CursorPosition, info.Window, info.MaximumWindowSize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (coord COORD) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v,%v", coord.X, coord.Y)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rect SMALL_RECT) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("(%v,%v),(%v,%v)", rect.Left, rect.Top, rect.Right, rect.Bottom)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkError evaluates the results of a Windows API call and returns the error if it failed.
0000000000000000000000000000000000000000;;	func checkError(r1, r2 uintptr, err error) error {
0000000000000000000000000000000000000000;;		// Windows APIs return non-zero to indicate success
0000000000000000000000000000000000000000;;		if r1 != 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return the error if provided, otherwise default to EINVAL
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.EINVAL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// coordToPointer converts a COORD into a uintptr (by fooling the type system).
0000000000000000000000000000000000000000;;	func coordToPointer(c COORD) uintptr {
0000000000000000000000000000000000000000;;		// Note: This code assumes the two SHORTs are correctly laid out; the "cast" to uint32 is just to get a pointer to pass.
0000000000000000000000000000000000000000;;		return uintptr(*((*uint32)(unsafe.Pointer(&c))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// use is a no-op, but the compiler cannot see that it is.
0000000000000000000000000000000000000000;;	// Calling use(p) ensures that p is kept live until that point.
0000000000000000000000000000000000000000;;	func use(p interface{}) {}
