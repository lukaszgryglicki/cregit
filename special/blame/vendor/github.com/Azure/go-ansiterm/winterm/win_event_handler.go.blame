0000000000000000000000000000000000000000;;	// +build windows
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	package winterm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/go-ansiterm"
0000000000000000000000000000000000000000;;		"github.com/Sirupsen/logrus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var logger *logrus.Logger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type windowsAnsiEventHandler struct {
0000000000000000000000000000000000000000;;		fd             uintptr
0000000000000000000000000000000000000000;;		file           *os.File
0000000000000000000000000000000000000000;;		infoReset      *CONSOLE_SCREEN_BUFFER_INFO
0000000000000000000000000000000000000000;;		sr             scrollRegion
0000000000000000000000000000000000000000;;		buffer         bytes.Buffer
0000000000000000000000000000000000000000;;		attributes     uint16
0000000000000000000000000000000000000000;;		inverted       bool
0000000000000000000000000000000000000000;;		wrapNext       bool
0000000000000000000000000000000000000000;;		drewMarginByte bool
0000000000000000000000000000000000000000;;		originMode     bool
0000000000000000000000000000000000000000;;		marginByte     byte
0000000000000000000000000000000000000000;;		curInfo        *CONSOLE_SCREEN_BUFFER_INFO
0000000000000000000000000000000000000000;;		curPos         COORD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateWinEventHandler(fd uintptr, file *os.File) ansiterm.AnsiEventHandler {
0000000000000000000000000000000000000000;;		logFile := ioutil.Discard
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isDebugEnv := os.Getenv(ansiterm.LogEnv); isDebugEnv == "1" {
0000000000000000000000000000000000000000;;			logFile, _ = os.Create("winEventHandler.log")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger = &logrus.Logger{
0000000000000000000000000000000000000000;;			Out:       logFile,
0000000000000000000000000000000000000000;;			Formatter: new(logrus.TextFormatter),
0000000000000000000000000000000000000000;;			Level:     logrus.DebugLevel,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		infoReset, err := GetConsoleScreenBufferInfo(fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &windowsAnsiEventHandler{
0000000000000000000000000000000000000000;;			fd:         fd,
0000000000000000000000000000000000000000;;			file:       file,
0000000000000000000000000000000000000000;;			infoReset:  infoReset,
0000000000000000000000000000000000000000;;			attributes: infoReset.Attributes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scrollRegion struct {
0000000000000000000000000000000000000000;;		top    int16
0000000000000000000000000000000000000000;;		bottom int16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// simulateLF simulates a LF or CR+LF by scrolling if necessary to handle the
0000000000000000000000000000000000000000;;	// current cursor position and scroll region settings, in which case it returns
0000000000000000000000000000000000000000;;	// true. If no special handling is necessary, then it does nothing and returns
0000000000000000000000000000000000000000;;	// false.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In the false case, the caller should ensure that a carriage return
0000000000000000000000000000000000000000;;	// and line feed are inserted or that the text is otherwise wrapped.
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) simulateLF(includeCR bool) (bool, error) {
0000000000000000000000000000000000000000;;		if h.wrapNext {
0000000000000000000000000000000000000000;;			if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.clearWrap()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pos, info, err := h.getCurrentInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sr := h.effectiveSr(info.Window)
0000000000000000000000000000000000000000;;		if pos.Y == sr.bottom {
0000000000000000000000000000000000000000;;			// Scrolling is necessary. Let Windows automatically scroll if the scrolling region
0000000000000000000000000000000000000000;;			// is the full window.
0000000000000000000000000000000000000000;;			if sr.top == info.Window.Top && sr.bottom == info.Window.Bottom {
0000000000000000000000000000000000000000;;				if includeCR {
0000000000000000000000000000000000000000;;					pos.X = 0
0000000000000000000000000000000000000000;;					h.updatePos(pos)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A custom scroll region is active. Scroll the window manually to simulate
0000000000000000000000000000000000000000;;			// the LF.
0000000000000000000000000000000000000000;;			if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			logger.Info("Simulating LF inside scroll region")
0000000000000000000000000000000000000000;;			if err := h.scrollUp(1); err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if includeCR {
0000000000000000000000000000000000000000;;				pos.X = 0
0000000000000000000000000000000000000000;;				if err := SetConsoleCursorPosition(h.fd, pos); err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else if pos.Y < info.Window.Bottom {
0000000000000000000000000000000000000000;;			// Let Windows handle the LF.
0000000000000000000000000000000000000000;;			pos.Y++
0000000000000000000000000000000000000000;;			if includeCR {
0000000000000000000000000000000000000000;;				pos.X = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.updatePos(pos)
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The cursor is at the bottom of the screen but outside the scroll
0000000000000000000000000000000000000000;;			// region. Skip the LF.
0000000000000000000000000000000000000000;;			logger.Info("Simulating LF outside scroll region")
0000000000000000000000000000000000000000;;			if includeCR {
0000000000000000000000000000000000000000;;				if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pos.X = 0
0000000000000000000000000000000000000000;;				if err := SetConsoleCursorPosition(h.fd, pos); err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// executeLF executes a LF without a CR.
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) executeLF() error {
0000000000000000000000000000000000000000;;		handled, err := h.simulateLF(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !handled {
0000000000000000000000000000000000000000;;			// Windows LF will reset the cursor column position. Write the LF
0000000000000000000000000000000000000000;;			// and restore the cursor position.
0000000000000000000000000000000000000000;;			pos, _, err := h.getCurrentInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.buffer.WriteByte(ansiterm.ANSI_LINE_FEED)
0000000000000000000000000000000000000000;;			if pos.X != 0 {
0000000000000000000000000000000000000000;;				if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				logger.Info("Resetting cursor position for LF without CR")
0000000000000000000000000000000000000000;;				if err := SetConsoleCursorPosition(h.fd, pos); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) Print(b byte) error {
0000000000000000000000000000000000000000;;		if h.wrapNext {
0000000000000000000000000000000000000000;;			h.buffer.WriteByte(h.marginByte)
0000000000000000000000000000000000000000;;			h.clearWrap()
0000000000000000000000000000000000000000;;			if _, err := h.simulateLF(true); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pos, info, err := h.getCurrentInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pos.X == info.Size.X-1 {
0000000000000000000000000000000000000000;;			h.wrapNext = true
0000000000000000000000000000000000000000;;			h.marginByte = b
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pos.X++
0000000000000000000000000000000000000000;;			h.updatePos(pos)
0000000000000000000000000000000000000000;;			h.buffer.WriteByte(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) Execute(b byte) error {
0000000000000000000000000000000000000000;;		switch b {
0000000000000000000000000000000000000000;;		case ansiterm.ANSI_TAB:
0000000000000000000000000000000000000000;;			logger.Info("Execute(TAB)")
0000000000000000000000000000000000000000;;			// Move to the next tab stop, but preserve auto-wrap if already set.
0000000000000000000000000000000000000000;;			if !h.wrapNext {
0000000000000000000000000000000000000000;;				pos, info, err := h.getCurrentInfo()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pos.X = (pos.X + 8) - pos.X%8
0000000000000000000000000000000000000000;;				if pos.X >= info.Size.X {
0000000000000000000000000000000000000000;;					pos.X = info.Size.X - 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := SetConsoleCursorPosition(h.fd, pos); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ansiterm.ANSI_BEL:
0000000000000000000000000000000000000000;;			h.buffer.WriteByte(ansiterm.ANSI_BEL)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ansiterm.ANSI_BACKSPACE:
0000000000000000000000000000000000000000;;			if h.wrapNext {
0000000000000000000000000000000000000000;;				if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				h.clearWrap()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos, _, err := h.getCurrentInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pos.X > 0 {
0000000000000000000000000000000000000000;;				pos.X--
0000000000000000000000000000000000000000;;				h.updatePos(pos)
0000000000000000000000000000000000000000;;				h.buffer.WriteByte(ansiterm.ANSI_BACKSPACE)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ansiterm.ANSI_VERTICAL_TAB, ansiterm.ANSI_FORM_FEED:
0000000000000000000000000000000000000000;;			// Treat as true LF.
0000000000000000000000000000000000000000;;			return h.executeLF()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ansiterm.ANSI_LINE_FEED:
0000000000000000000000000000000000000000;;			// Simulate a CR and LF for now since there is no way in go-ansiterm
0000000000000000000000000000000000000000;;			// to tell if the LF should include CR (and more things break when it's
0000000000000000000000000000000000000000;;			// missing than when it's incorrectly added).
0000000000000000000000000000000000000000;;			handled, err := h.simulateLF(true)
0000000000000000000000000000000000000000;;			if handled || err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return h.buffer.WriteByte(ansiterm.ANSI_LINE_FEED)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ansiterm.ANSI_CARRIAGE_RETURN:
0000000000000000000000000000000000000000;;			if h.wrapNext {
0000000000000000000000000000000000000000;;				if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				h.clearWrap()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos, _, err := h.getCurrentInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pos.X != 0 {
0000000000000000000000000000000000000000;;				pos.X = 0
0000000000000000000000000000000000000000;;				h.updatePos(pos)
0000000000000000000000000000000000000000;;				h.buffer.WriteByte(ansiterm.ANSI_CARRIAGE_RETURN)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CUU(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CUU: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.moveCursorVertical(-param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CUD(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CUD: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.moveCursorVertical(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CUF(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CUF: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.moveCursorHorizontal(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CUB(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CUB: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.moveCursorHorizontal(-param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CNL(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CNL: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.moveCursorLine(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CPL(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CPL: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.moveCursorLine(-param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CHA(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CHA: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.moveCursorColumn(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) VPA(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("VPA: [[%d]]", param)
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		window := h.getCursorWindow(info)
0000000000000000000000000000000000000000;;		position := info.CursorPosition
0000000000000000000000000000000000000000;;		position.Y = window.Top + int16(param) - 1
0000000000000000000000000000000000000000;;		return h.setCursorPosition(position, window)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) CUP(row int, col int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("CUP: [[%d %d]]", row, col)
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		window := h.getCursorWindow(info)
0000000000000000000000000000000000000000;;		position := COORD{window.Left + int16(col) - 1, window.Top + int16(row) - 1}
0000000000000000000000000000000000000000;;		return h.setCursorPosition(position, window)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) HVP(row int, col int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("HVP: [[%d %d]]", row, col)
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.CUP(row, col)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) DECTCEM(visible bool) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("DECTCEM: [%v]", []string{strconv.FormatBool(visible)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) DECOM(enable bool) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("DECOM: [%v]", []string{strconv.FormatBool(enable)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		h.originMode = enable
0000000000000000000000000000000000000000;;		return h.CUP(1, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) DECCOLM(use132 bool) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("DECCOLM: [%v]", []string{strconv.FormatBool(use132)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		if err := h.ED(2); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		targetWidth := int16(80)
0000000000000000000000000000000000000000;;		if use132 {
0000000000000000000000000000000000000000;;			targetWidth = 132
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Size.X < targetWidth {
0000000000000000000000000000000000000000;;			if err := SetConsoleScreenBufferSize(h.fd, COORD{targetWidth, info.Size.Y}); err != nil {
0000000000000000000000000000000000000000;;				logger.Info("set buffer failed:", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		window := info.Window
0000000000000000000000000000000000000000;;		window.Left = 0
0000000000000000000000000000000000000000;;		window.Right = targetWidth - 1
0000000000000000000000000000000000000000;;		if err := SetConsoleWindowInfo(h.fd, true, window); err != nil {
0000000000000000000000000000000000000000;;			logger.Info("set window failed:", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.Size.X > targetWidth {
0000000000000000000000000000000000000000;;			if err := SetConsoleScreenBufferSize(h.fd, COORD{targetWidth, info.Size.Y}); err != nil {
0000000000000000000000000000000000000000;;				logger.Info("set buffer failed:", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return SetConsoleCursorPosition(h.fd, COORD{0, 0})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) ED(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("ED: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// [J  -- Erases from the cursor to the end of the screen, including the cursor position.
0000000000000000000000000000000000000000;;		// [1J -- Erases from the beginning of the screen to the cursor, including the cursor position.
0000000000000000000000000000000000000000;;		// [2J -- Erases the complete display. The cursor does not move.
0000000000000000000000000000000000000000;;		// Notes:
0000000000000000000000000000000000000000;;		// -- Clearing the entire buffer, versus just the Window, works best for Windows Consoles
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var start COORD
0000000000000000000000000000000000000000;;		var end COORD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch param {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			start = info.CursorPosition
0000000000000000000000000000000000000000;;			end = COORD{info.Size.X - 1, info.Size.Y - 1}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			start = COORD{0, 0}
0000000000000000000000000000000000000000;;			end = info.CursorPosition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			start = COORD{0, 0}
0000000000000000000000000000000000000000;;			end = COORD{info.Size.X - 1, info.Size.Y - 1}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = h.clearRange(h.attributes, start, end)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the whole buffer was cleared, move the window to the top while preserving
0000000000000000000000000000000000000000;;		// the window-relative cursor position.
0000000000000000000000000000000000000000;;		if param == 2 {
0000000000000000000000000000000000000000;;			pos := info.CursorPosition
0000000000000000000000000000000000000000;;			window := info.Window
0000000000000000000000000000000000000000;;			pos.Y -= window.Top
0000000000000000000000000000000000000000;;			window.Bottom -= window.Top
0000000000000000000000000000000000000000;;			window.Top = 0
0000000000000000000000000000000000000000;;			if err := SetConsoleCursorPosition(h.fd, pos); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := SetConsoleWindowInfo(h.fd, true, window); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) EL(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("EL: [%v]", strconv.Itoa(param))
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// [K  -- Erases from the cursor to the end of the line, including the cursor position.
0000000000000000000000000000000000000000;;		// [1K -- Erases from the beginning of the line to the cursor, including the cursor position.
0000000000000000000000000000000000000000;;		// [2K -- Erases the complete line.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var start COORD
0000000000000000000000000000000000000000;;		var end COORD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch param {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			start = info.CursorPosition
0000000000000000000000000000000000000000;;			end = COORD{info.Size.X, info.CursorPosition.Y}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			start = COORD{0, info.CursorPosition.Y}
0000000000000000000000000000000000000000;;			end = info.CursorPosition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			start = COORD{0, info.CursorPosition.Y}
0000000000000000000000000000000000000000;;			end = COORD{info.Size.X, info.CursorPosition.Y}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = h.clearRange(h.attributes, start, end)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) IL(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("IL: [%v]", strconv.Itoa(param))
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.insertLines(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) DL(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("DL: [%v]", strconv.Itoa(param))
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.deleteLines(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) ICH(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("ICH: [%v]", strconv.Itoa(param))
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.insertCharacters(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) DCH(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("DCH: [%v]", strconv.Itoa(param))
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.deleteCharacters(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) SGR(params []int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		strings := []string{}
0000000000000000000000000000000000000000;;		for _, v := range params {
0000000000000000000000000000000000000000;;			strings = append(strings, strconv.Itoa(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Infof("SGR: [%v]", strings)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(params) <= 0 {
0000000000000000000000000000000000000000;;			h.attributes = h.infoReset.Attributes
0000000000000000000000000000000000000000;;			h.inverted = false
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, attr := range params {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if attr == ansiterm.ANSI_SGR_RESET {
0000000000000000000000000000000000000000;;					h.attributes = h.infoReset.Attributes
0000000000000000000000000000000000000000;;					h.inverted = false
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				h.attributes, h.inverted = collectAnsiIntoWindowsAttributes(h.attributes, h.inverted, h.infoReset.Attributes, int16(attr))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attributes := h.attributes
0000000000000000000000000000000000000000;;		if h.inverted {
0000000000000000000000000000000000000000;;			attributes = invertAttributes(attributes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := SetConsoleTextAttribute(h.fd, attributes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) SU(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("SU: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.scrollUp(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) SD(param int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("SD: [%v]", []string{strconv.Itoa(param)})
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.scrollDown(param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) DA(params []string) error {
0000000000000000000000000000000000000000;;		logger.Infof("DA: [%v]", params)
0000000000000000000000000000000000000000;;		// DA cannot be implemented because it must send data on the VT100 input stream,
0000000000000000000000000000000000000000;;		// which is not available to go-ansiterm.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) DECSTBM(top int, bottom int) error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Infof("DECSTBM: [%d, %d]", top, bottom)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Windows is 0 indexed, Linux is 1 indexed
0000000000000000000000000000000000000000;;		h.sr.top = int16(top - 1)
0000000000000000000000000000000000000000;;		h.sr.bottom = int16(bottom - 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This command also moves the cursor to the origin.
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;		return h.CUP(1, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) RI() error {
0000000000000000000000000000000000000000;;		if err := h.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Info("RI: []")
0000000000000000000000000000000000000000;;		h.clearWrap()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sr := h.effectiveSr(info.Window)
0000000000000000000000000000000000000000;;		if info.CursorPosition.Y == sr.top {
0000000000000000000000000000000000000000;;			return h.scrollDown(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return h.moveCursorVertical(-1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) IND() error {
0000000000000000000000000000000000000000;;		logger.Info("IND: []")
0000000000000000000000000000000000000000;;		return h.executeLF()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) Flush() error {
0000000000000000000000000000000000000000;;		h.curInfo = nil
0000000000000000000000000000000000000000;;		if h.buffer.Len() > 0 {
0000000000000000000000000000000000000000;;			logger.Infof("Flush: [%s]", h.buffer.Bytes())
0000000000000000000000000000000000000000;;			if _, err := h.buffer.WriteTo(h.file); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.wrapNext && !h.drewMarginByte {
0000000000000000000000000000000000000000;;			logger.Infof("Flush: drawing margin byte '%c'", h.marginByte)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			charInfo := []CHAR_INFO{{UnicodeChar: uint16(h.marginByte), Attributes: info.Attributes}}
0000000000000000000000000000000000000000;;			size := COORD{1, 1}
0000000000000000000000000000000000000000;;			position := COORD{0, 0}
0000000000000000000000000000000000000000;;			region := SMALL_RECT{Left: info.CursorPosition.X, Top: info.CursorPosition.Y, Right: info.CursorPosition.X, Bottom: info.CursorPosition.Y}
0000000000000000000000000000000000000000;;			if err := WriteConsoleOutput(h.fd, charInfo, size, position, &region); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.drewMarginByte = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cacheConsoleInfo ensures that the current console screen information has been queried
0000000000000000000000000000000000000000;;	// since the last call to Flush(). It must be called before accessing h.curInfo or h.curPos.
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) getCurrentInfo() (COORD, *CONSOLE_SCREEN_BUFFER_INFO, error) {
0000000000000000000000000000000000000000;;		if h.curInfo == nil {
0000000000000000000000000000000000000000;;			info, err := GetConsoleScreenBufferInfo(h.fd)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return COORD{}, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.curInfo = info
0000000000000000000000000000000000000000;;			h.curPos = info.CursorPosition
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h.curPos, h.curInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) updatePos(pos COORD) {
0000000000000000000000000000000000000000;;		if h.curInfo == nil {
0000000000000000000000000000000000000000;;			panic("failed to call getCurrentInfo before calling updatePos")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.curPos = pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clearWrap clears the state where the cursor is in the margin
0000000000000000000000000000000000000000;;	// waiting for the next character before wrapping the line. This must
0000000000000000000000000000000000000000;;	// be done before most operations that act on the cursor.
0000000000000000000000000000000000000000;;	func (h *windowsAnsiEventHandler) clearWrap() {
0000000000000000000000000000000000000000;;		h.wrapNext = false
0000000000000000000000000000000000000000;;		h.drewMarginByte = false
0000000000000000000000000000000000000000;;	}
