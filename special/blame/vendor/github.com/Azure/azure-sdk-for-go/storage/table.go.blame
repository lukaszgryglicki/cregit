0000000000000000000000000000000000000000;;	package storage
bf119e8337b916a81932389e376d77629c43bfe3;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tablesURIPath                  = "/Tables"
0000000000000000000000000000000000000000;;		nextTableQueryParameter        = "NextTableName"
0000000000000000000000000000000000000000;;		headerNextPartitionKey         = "x-ms-continuation-NextPartitionKey"
0000000000000000000000000000000000000000;;		headerNextRowKey               = "x-ms-continuation-NextRowKey"
0000000000000000000000000000000000000000;;		nextPartitionKeyQueryParameter = "NextPartitionKey"
0000000000000000000000000000000000000000;;		nextRowKeyQueryParameter       = "NextRowKey"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TableAccessPolicy are used for SETTING table policies
0000000000000000000000000000000000000000;;	type TableAccessPolicy struct {
0000000000000000000000000000000000000000;;		ID         string
0000000000000000000000000000000000000000;;		StartTime  time.Time
0000000000000000000000000000000000000000;;		ExpiryTime time.Time
0000000000000000000000000000000000000000;;		CanRead    bool
0000000000000000000000000000000000000000;;		CanAppend  bool
0000000000000000000000000000000000000000;;		CanUpdate  bool
0000000000000000000000000000000000000000;;		CanDelete  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Table represents an Azure table.
0000000000000000000000000000000000000000;;	type Table struct {
0000000000000000000000000000000000000000;;		tsc           *TableServiceClient
0000000000000000000000000000000000000000;;		Name          string `json:"TableName"`
0000000000000000000000000000000000000000;;		OdataEditLink string `json:"odata.editLink"`
0000000000000000000000000000000000000000;;		OdataID       string `json:"odata.id"`
0000000000000000000000000000000000000000;;		OdataMetadata string `json:"odata.metadata"`
0000000000000000000000000000000000000000;;		OdataType     string `json:"odata.type"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EntityQueryResult contains the response from
0000000000000000000000000000000000000000;;	// ExecuteQuery and ExecuteQueryNextResults functions.
0000000000000000000000000000000000000000;;	type EntityQueryResult struct {
0000000000000000000000000000000000000000;;		OdataMetadata string    `json:"odata.metadata"`
0000000000000000000000000000000000000000;;		Entities      []*Entity `json:"value"`
0000000000000000000000000000000000000000;;		QueryNextLink
0000000000000000000000000000000000000000;;		table *Table
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type continuationToken struct {
0000000000000000000000000000000000000000;;		NextPartitionKey string
0000000000000000000000000000000000000000;;		NextRowKey       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Table) buildPath() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/%s", t.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Table) buildSpecificPath() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s('%s')", tablesURIPath, t.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get gets the referenced table.
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/querying-tables-and-entities
0000000000000000000000000000000000000000;;	func (t *Table) Get(timeout uint, ml MetadataLevel) error {
0000000000000000000000000000000000000000;;		if ml == EmptyPayload {
0000000000000000000000000000000000000000;;			return errEmptyPayload
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		query := url.Values{
0000000000000000000000000000000000000000;;			"timeout": {strconv.FormatUint(uint64(timeout), 10)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := t.tsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers[headerAccept] = string(ml)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := t.tsc.client.getEndpoint(tableServiceName, t.buildSpecificPath(), query)
0000000000000000000000000000000000000000;;		resp, err := t.tsc.client.exec(http.MethodGet, uri, headers, nil, t.tsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		respBody, err := ioutil.ReadAll(resp.body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(respBody, t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates the referenced table.
0000000000000000000000000000000000000000;;	// This function fails if the name is not compliant
0000000000000000000000000000000000000000;;	// with the specification or the tables already exists.
0000000000000000000000000000000000000000;;	// ml determines the level of detail of metadata in the operation response,
0000000000000000000000000000000000000000;;	// or no data at all.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/rest/api/storageservices/fileservices/create-table
0000000000000000000000000000000000000000;;	func (t *Table) Create(timeout uint, ml MetadataLevel, options *TableOptions) error {
0000000000000000000000000000000000000000;;		uri := t.tsc.client.getEndpoint(tableServiceName, tablesURIPath, url.Values{
0000000000000000000000000000000000000000;;			"timeout": {strconv.FormatUint(uint64(timeout), 10)},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type createTableRequest struct {
0000000000000000000000000000000000000000;;			TableName string `json:"TableName"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := createTableRequest{TableName: t.Name}
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		if err := json.NewEncoder(buf).Encode(req); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := t.tsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = addReturnContentHeaders(headers, ml)
0000000000000000000000000000000000000000;;		headers = addBodyRelatedHeaders(headers, buf.Len())
0000000000000000000000000000000000000000;;		headers = options.addToHeaders(headers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := t.tsc.client.exec(http.MethodPost, uri, headers, buf, t.tsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ml == EmptyPayload {
0000000000000000000000000000000000000000;;			if err := checkRespCode(resp.statusCode, []int{http.StatusNoContent}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err := checkRespCode(resp.statusCode, []int{http.StatusCreated}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ml != EmptyPayload {
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadAll(resp.body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = json.Unmarshal(data, t)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes the referenced table.
0000000000000000000000000000000000000000;;	// This function fails if the table is not present.
0000000000000000000000000000000000000000;;	// Be advised: Delete deletes all the entries that may be present.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/rest/api/storageservices/fileservices/delete-table
0000000000000000000000000000000000000000;;	func (t *Table) Delete(timeout uint, options *TableOptions) error {
0000000000000000000000000000000000000000;;		uri := t.tsc.client.getEndpoint(tableServiceName, t.buildSpecificPath(), url.Values{
0000000000000000000000000000000000000000;;			"timeout": {strconv.Itoa(int(timeout))},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := t.tsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = addReturnContentHeaders(headers, EmptyPayload)
0000000000000000000000000000000000000000;;		headers = options.addToHeaders(headers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := t.tsc.client.exec(http.MethodDelete, uri, headers, nil, t.tsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusNoContent}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryOptions includes options for a query entities operation.
0000000000000000000000000000000000000000;;	// Top, filter and select are OData query options.
0000000000000000000000000000000000000000;;	type QueryOptions struct {
0000000000000000000000000000000000000000;;		Top       uint
0000000000000000000000000000000000000000;;		Filter    string
0000000000000000000000000000000000000000;;		Select    []string
0000000000000000000000000000000000000000;;		RequestID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *QueryOptions) getParameters() (url.Values, map[string]string) {
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		headers := map[string]string{}
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			if options.Top > 0 {
0000000000000000000000000000000000000000;;				query.Add(OdataTop, strconv.FormatUint(uint64(options.Top), 10))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.Filter != "" {
0000000000000000000000000000000000000000;;				query.Add(OdataFilter, options.Filter)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(options.Select) > 0 {
0000000000000000000000000000000000000000;;				query.Add(OdataSelect, strings.Join(options.Select, ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-client-request-id", options.RequestID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return query, headers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryEntities returns the entities in the table.
0000000000000000000000000000000000000000;;	// You can use query options defined by the OData Protocol specification.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/query-entities
0000000000000000000000000000000000000000;;	func (t *Table) QueryEntities(timeout uint, ml MetadataLevel, options *QueryOptions) (*EntityQueryResult, error) {
0000000000000000000000000000000000000000;;		if ml == EmptyPayload {
0000000000000000000000000000000000000000;;			return nil, errEmptyPayload
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		query, headers := options.getParameters()
0000000000000000000000000000000000000000;;		query = addTimeout(query, timeout)
0000000000000000000000000000000000000000;;		uri := t.tsc.client.getEndpoint(tableServiceName, t.buildPath(), query)
0000000000000000000000000000000000000000;;		return t.queryEntities(uri, headers, ml)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextResults returns the next page of results
0000000000000000000000000000000000000000;;	// from a QueryEntities or NextResults operation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/query-entities
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/rest/api/storageservices/fileservices/query-timeout-and-pagination
0000000000000000000000000000000000000000;;	func (eqr *EntityQueryResult) NextResults(options *TableOptions) (*EntityQueryResult, error) {
0000000000000000000000000000000000000000;;		if eqr == nil {
0000000000000000000000000000000000000000;;			return nil, errNilPreviousResult
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if eqr.NextLink == nil {
0000000000000000000000000000000000000000;;			return nil, errNilNextLink
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := options.addToHeaders(map[string]string{})
0000000000000000000000000000000000000000;;		return eqr.table.queryEntities(*eqr.NextLink, headers, eqr.ml)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPermissions sets up table ACL permissions
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/rest/api/storageservices/fileservices/Set-Table-ACL
0000000000000000000000000000000000000000;;	func (t *Table) SetPermissions(tap []TableAccessPolicy, timeout uint, options *TableOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"acl"},
0000000000000000000000000000000000000000;;			"timeout": {strconv.Itoa(int(timeout))},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := t.tsc.client.getEndpoint(tableServiceName, t.Name, params)
0000000000000000000000000000000000000000;;		headers := t.tsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = options.addToHeaders(headers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, length, err := generateTableACLPayload(tap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers["Content-Length"] = strconv.Itoa(length)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := t.tsc.client.exec(http.MethodPut, uri, headers, body, t.tsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusNoContent}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateTableACLPayload(policies []TableAccessPolicy) (io.Reader, int, error) {
0000000000000000000000000000000000000000;;		sil := SignedIdentifiers{
0000000000000000000000000000000000000000;;			SignedIdentifiers: []SignedIdentifier{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tap := range policies {
0000000000000000000000000000000000000000;;			permission := generateTablePermissions(&tap)
0000000000000000000000000000000000000000;;			signedIdentifier := convertAccessPolicyToXMLStructs(tap.ID, tap.StartTime, tap.ExpiryTime, permission)
0000000000000000000000000000000000000000;;			sil.SignedIdentifiers = append(sil.SignedIdentifiers, signedIdentifier)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return xmlMarshal(sil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPermissions gets the table ACL permissions
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/rest/api/storageservices/fileservices/get-table-acl
0000000000000000000000000000000000000000;;	func (t *Table) GetPermissions(timeout int, options *TableOptions) ([]TableAccessPolicy, error) {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"acl"},
0000000000000000000000000000000000000000;;			"timeout": {strconv.Itoa(int(timeout))},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := t.tsc.client.getEndpoint(tableServiceName, t.Name, params)
0000000000000000000000000000000000000000;;		headers := t.tsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = options.addToHeaders(headers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := t.tsc.client.exec(http.MethodGet, uri, headers, nil, t.tsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ap AccessPolicy
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &ap.SignedIdentifiersList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updateTableAccessPolicy(ap), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Table) queryEntities(uri string, headers map[string]string, ml MetadataLevel) (*EntityQueryResult, error) {
0000000000000000000000000000000000000000;;		headers = mergeHeaders(headers, t.tsc.client.getStandardHeaders())
0000000000000000000000000000000000000000;;		if ml != EmptyPayload {
0000000000000000000000000000000000000000;;			headers[headerAccept] = string(ml)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := t.tsc.client.exec(http.MethodGet, uri, headers, nil, t.tsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(resp.body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var entities EntityQueryResult
0000000000000000000000000000000000000000;;		err = json.Unmarshal(data, &entities)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range entities.Entities {
0000000000000000000000000000000000000000;;			entities.Entities[i].Table = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entities.table = t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contToken := extractContinuationTokenFromHeaders(resp.headers)
0000000000000000000000000000000000000000;;		if contToken == nil {
0000000000000000000000000000000000000000;;			entities.NextLink = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			originalURI, err := url.Parse(uri)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v := originalURI.Query()
0000000000000000000000000000000000000000;;			v.Set(nextPartitionKeyQueryParameter, contToken.NextPartitionKey)
0000000000000000000000000000000000000000;;			v.Set(nextRowKeyQueryParameter, contToken.NextRowKey)
0000000000000000000000000000000000000000;;			newURI := t.tsc.client.getEndpoint(tableServiceName, t.buildPath(), v)
0000000000000000000000000000000000000000;;			entities.NextLink = &newURI
0000000000000000000000000000000000000000;;			entities.ml = ml
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &entities, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractContinuationTokenFromHeaders(h http.Header) *continuationToken {
0000000000000000000000000000000000000000;;		ct := continuationToken{
0000000000000000000000000000000000000000;;			NextPartitionKey: h.Get(headerNextPartitionKey),
0000000000000000000000000000000000000000;;			NextRowKey:       h.Get(headerNextRowKey),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ct.NextPartitionKey != "" && ct.NextRowKey != "" {
0000000000000000000000000000000000000000;;			return &ct
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateTableAccessPolicy(ap AccessPolicy) []TableAccessPolicy {
0000000000000000000000000000000000000000;;		taps := []TableAccessPolicy{}
0000000000000000000000000000000000000000;;		for _, policy := range ap.SignedIdentifiersList.SignedIdentifiers {
0000000000000000000000000000000000000000;;			tap := TableAccessPolicy{
0000000000000000000000000000000000000000;;				ID:         policy.ID,
0000000000000000000000000000000000000000;;				StartTime:  policy.AccessPolicy.StartTime,
0000000000000000000000000000000000000000;;				ExpiryTime: policy.AccessPolicy.ExpiryTime,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tap.CanRead = updatePermissions(policy.AccessPolicy.Permission, "r")
0000000000000000000000000000000000000000;;			tap.CanAppend = updatePermissions(policy.AccessPolicy.Permission, "a")
0000000000000000000000000000000000000000;;			tap.CanUpdate = updatePermissions(policy.AccessPolicy.Permission, "u")
0000000000000000000000000000000000000000;;			tap.CanDelete = updatePermissions(policy.AccessPolicy.Permission, "d")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			taps = append(taps, tap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return taps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateTablePermissions(tap *TableAccessPolicy) (permissions string) {
0000000000000000000000000000000000000000;;		// generate the permissions string (raud).
0000000000000000000000000000000000000000;;		// still want the end user API to have bool flags.
0000000000000000000000000000000000000000;;		permissions = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tap.CanRead {
0000000000000000000000000000000000000000;;			permissions += "r"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tap.CanAppend {
0000000000000000000000000000000000000000;;			permissions += "a"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tap.CanUpdate {
0000000000000000000000000000000000000000;;			permissions += "u"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tap.CanDelete {
0000000000000000000000000000000000000000;;			permissions += "d"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return permissions
0000000000000000000000000000000000000000;;	}
