0000000000000000000000000000000000000000;;	package storage
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Share represents an Azure file share.
0000000000000000000000000000000000000000;;	type Share struct {
0000000000000000000000000000000000000000;;		fsc        *FileServiceClient
0000000000000000000000000000000000000000;;		Name       string          `xml:"Name"`
0000000000000000000000000000000000000000;;		Properties ShareProperties `xml:"Properties"`
0000000000000000000000000000000000000000;;		Metadata   map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShareProperties contains various properties of a share.
0000000000000000000000000000000000000000;;	type ShareProperties struct {
0000000000000000000000000000000000000000;;		LastModified string `xml:"Last-Modified"`
0000000000000000000000000000000000000000;;		Etag         string `xml:"Etag"`
0000000000000000000000000000000000000000;;		Quota        int    `xml:"Quota"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// builds the complete path for this share object.
0000000000000000000000000000000000000000;;	func (s *Share) buildPath() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/%s", s.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create this share under the associated account.
0000000000000000000000000000000000000000;;	// If a share with the same name already exists, the operation fails.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Create-Share
0000000000000000000000000000000000000000;;	func (s *Share) Create(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		extraheaders := map[string]string{}
0000000000000000000000000000000000000000;;		if s.Properties.Quota > 0 {
0000000000000000000000000000000000000000;;			extraheaders["x-ms-share-quota"] = strconv.Itoa(s.Properties.Quota)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := prepareOptions(options)
0000000000000000000000000000000000000000;;		headers, err := s.fsc.createResource(s.buildPath(), resourceShare, params, mergeMDIntoExtraHeaders(s.Metadata, extraheaders), []int{http.StatusCreated})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateIfNotExists creates this share under the associated account if
0000000000000000000000000000000000000000;;	// it does not exist. Returns true if the share is newly created or false if
0000000000000000000000000000000000000000;;	// the share already exists.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Create-Share
0000000000000000000000000000000000000000;;	func (s *Share) CreateIfNotExists(options *FileRequestOptions) (bool, error) {
0000000000000000000000000000000000000000;;		extraheaders := map[string]string{}
0000000000000000000000000000000000000000;;		if s.Properties.Quota > 0 {
0000000000000000000000000000000000000000;;			extraheaders["x-ms-share-quota"] = strconv.Itoa(s.Properties.Quota)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := prepareOptions(options)
0000000000000000000000000000000000000000;;		resp, err := s.fsc.createResourceNoClose(s.buildPath(), resourceShare, params, extraheaders)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusCreated || resp.statusCode == http.StatusConflict {
0000000000000000000000000000000000000000;;				if resp.statusCode == http.StatusCreated {
0000000000000000000000000000000000000000;;					s.updateEtagAndLastModified(resp.headers)
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, s.FetchAttributes(nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete marks this share for deletion. The share along with any files
0000000000000000000000000000000000000000;;	// and directories contained within it are later deleted during garbage
0000000000000000000000000000000000000000;;	// collection.  If the share does not exist the operation fails
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Delete-Share
0000000000000000000000000000000000000000;;	func (s *Share) Delete(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		return s.fsc.deleteResource(s.buildPath(), resourceShare, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteIfExists operation marks this share for deletion if it exists.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Delete-Share
0000000000000000000000000000000000000000;;	func (s *Share) DeleteIfExists(options *FileRequestOptions) (bool, error) {
0000000000000000000000000000000000000000;;		resp, err := s.fsc.deleteResourceNoClose(s.buildPath(), resourceShare, options)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusAccepted || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusAccepted, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exists returns true if this share already exists
0000000000000000000000000000000000000000;;	// on the storage account, otherwise returns false.
0000000000000000000000000000000000000000;;	func (s *Share) Exists() (bool, error) {
0000000000000000000000000000000000000000;;		exists, headers, err := s.fsc.resourceExists(s.buildPath(), resourceShare)
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			s.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;			s.updateQuota(headers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exists, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FetchAttributes retrieves metadata and properties for this share.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-share-properties
0000000000000000000000000000000000000000;;	func (s *Share) FetchAttributes(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		params := prepareOptions(options)
0000000000000000000000000000000000000000;;		headers, err := s.fsc.getResourceHeaders(s.buildPath(), compNone, resourceShare, params, http.MethodHead)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		s.updateQuota(headers)
0000000000000000000000000000000000000000;;		s.Metadata = getMetadataFromHeaders(headers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRootDirectoryReference returns a Directory object at the root of this share.
0000000000000000000000000000000000000000;;	func (s *Share) GetRootDirectoryReference() *Directory {
0000000000000000000000000000000000000000;;		return &Directory{
0000000000000000000000000000000000000000;;			fsc:   s.fsc,
0000000000000000000000000000000000000000;;			share: s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceClient returns the FileServiceClient associated with this share.
0000000000000000000000000000000000000000;;	func (s *Share) ServiceClient() *FileServiceClient {
0000000000000000000000000000000000000000;;		return s.fsc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMetadata replaces the metadata for this share.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some keys may be converted to Camel-Case before sending. All keys
0000000000000000000000000000000000000000;;	// are returned in lower case by GetShareMetadata. HTTP header names
0000000000000000000000000000000000000000;;	// are case-insensitive so case munging should not matter to other
0000000000000000000000000000000000000000;;	// applications either.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/set-share-metadata
0000000000000000000000000000000000000000;;	func (s *Share) SetMetadata(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		headers, err := s.fsc.setResourceHeaders(s.buildPath(), compMetadata, resourceShare, mergeMDIntoExtraHeaders(s.Metadata, nil), options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetProperties sets system properties for this share.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some keys may be converted to Camel-Case before sending. All keys
0000000000000000000000000000000000000000;;	// are returned in lower case by SetShareProperties. HTTP header names
0000000000000000000000000000000000000000;;	// are case-insensitive so case munging should not matter to other
0000000000000000000000000000000000000000;;	// applications either.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Set-Share-Properties
0000000000000000000000000000000000000000;;	func (s *Share) SetProperties(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		extraheaders := map[string]string{}
0000000000000000000000000000000000000000;;		if s.Properties.Quota > 0 {
0000000000000000000000000000000000000000;;			if s.Properties.Quota > 5120 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid value %v for quota, valid values are [1, 5120]", s.Properties.Quota)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			extraheaders["x-ms-share-quota"] = strconv.Itoa(s.Properties.Quota)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers, err := s.fsc.setResourceHeaders(s.buildPath(), compProperties, resourceShare, extraheaders, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updates Etag and last modified date
0000000000000000000000000000000000000000;;	func (s *Share) updateEtagAndLastModified(headers http.Header) {
0000000000000000000000000000000000000000;;		s.Properties.Etag = headers.Get("Etag")
0000000000000000000000000000000000000000;;		s.Properties.LastModified = headers.Get("Last-Modified")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updates quota value
0000000000000000000000000000000000000000;;	func (s *Share) updateQuota(headers http.Header) {
0000000000000000000000000000000000000000;;		quota, err := strconv.Atoi(headers.Get("x-ms-share-quota"))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			s.Properties.Quota = quota
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URL gets the canonical URL to this share. This method does not create a publicly accessible
0000000000000000000000000000000000000000;;	// URL if the share is private and this method does not check if the share exists.
0000000000000000000000000000000000000000;;	func (s *Share) URL() string {
0000000000000000000000000000000000000000;;		return s.fsc.client.getEndpoint(fileServiceName, s.buildPath(), url.Values{})
0000000000000000000000000000000000000000;;	}
