0000000000000000000000000000000000000000;;	package storage
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"mime/multipart"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/textproto"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/satori/uuid"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Operation type. Insert, Delete, Replace etc.
0000000000000000000000000000000000000000;;	type Operation int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consts for batch operations.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		InsertOp          = Operation(1)
0000000000000000000000000000000000000000;;		DeleteOp          = Operation(2)
0000000000000000000000000000000000000000;;		ReplaceOp         = Operation(3)
0000000000000000000000000000000000000000;;		MergeOp           = Operation(4)
0000000000000000000000000000000000000000;;		InsertOrReplaceOp = Operation(5)
0000000000000000000000000000000000000000;;		InsertOrMergeOp   = Operation(6)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BatchEntity used for tracking Entities to operate on and
0000000000000000000000000000000000000000;;	// whether operations (replace/merge etc) should be forced.
0000000000000000000000000000000000000000;;	// Wrapper for regular Entity with additional data specific for the entity.
0000000000000000000000000000000000000000;;	type BatchEntity struct {
0000000000000000000000000000000000000000;;		*Entity
0000000000000000000000000000000000000000;;		Force bool
0000000000000000000000000000000000000000;;		Op    Operation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TableBatch stores all the entities that will be operated on during a batch process.
0000000000000000000000000000000000000000;;	// Entities can be inserted, replaced or deleted.
0000000000000000000000000000000000000000;;	type TableBatch struct {
0000000000000000000000000000000000000000;;		BatchEntitySlice []BatchEntity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reference to table we're operating on.
0000000000000000000000000000000000000000;;		Table *Table
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultChangesetHeaders for changeSets
0000000000000000000000000000000000000000;;	var defaultChangesetHeaders = map[string]string{
0000000000000000000000000000000000000000;;		"Accept":       "application/json;odata=minimalmetadata",
0000000000000000000000000000000000000000;;		"Content-Type": "application/json",
0000000000000000000000000000000000000000;;		"Prefer":       "return-no-content",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBatch return new TableBatch for populating.
0000000000000000000000000000000000000000;;	func (t *Table) NewBatch() *TableBatch {
0000000000000000000000000000000000000000;;		return &TableBatch{
0000000000000000000000000000000000000000;;			Table: t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertEntity adds an entity in preparation for a batch insert.
0000000000000000000000000000000000000000;;	func (t *TableBatch) InsertEntity(entity *Entity) {
0000000000000000000000000000000000000000;;		be := BatchEntity{Entity: entity, Force: false, Op: InsertOp}
0000000000000000000000000000000000000000;;		t.BatchEntitySlice = append(t.BatchEntitySlice, be)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertOrReplaceEntity adds an entity in preparation for a batch insert or replace.
0000000000000000000000000000000000000000;;	func (t *TableBatch) InsertOrReplaceEntity(entity *Entity, force bool) {
0000000000000000000000000000000000000000;;		be := BatchEntity{Entity: entity, Force: false, Op: InsertOrReplaceOp}
0000000000000000000000000000000000000000;;		t.BatchEntitySlice = append(t.BatchEntitySlice, be)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertOrReplaceEntityByForce adds an entity in preparation for a batch insert or replace. Forces regardless of ETag
0000000000000000000000000000000000000000;;	func (t *TableBatch) InsertOrReplaceEntityByForce(entity *Entity) {
0000000000000000000000000000000000000000;;		t.InsertOrReplaceEntity(entity, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertOrMergeEntity adds an entity in preparation for a batch insert or merge.
0000000000000000000000000000000000000000;;	func (t *TableBatch) InsertOrMergeEntity(entity *Entity, force bool) {
0000000000000000000000000000000000000000;;		be := BatchEntity{Entity: entity, Force: false, Op: InsertOrMergeOp}
0000000000000000000000000000000000000000;;		t.BatchEntitySlice = append(t.BatchEntitySlice, be)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertOrMergeEntityByForce adds an entity in preparation for a batch insert or merge. Forces regardless of ETag
0000000000000000000000000000000000000000;;	func (t *TableBatch) InsertOrMergeEntityByForce(entity *Entity) {
0000000000000000000000000000000000000000;;		t.InsertOrMergeEntity(entity, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceEntity adds an entity in preparation for a batch replace.
0000000000000000000000000000000000000000;;	func (t *TableBatch) ReplaceEntity(entity *Entity) {
0000000000000000000000000000000000000000;;		be := BatchEntity{Entity: entity, Force: false, Op: ReplaceOp}
0000000000000000000000000000000000000000;;		t.BatchEntitySlice = append(t.BatchEntitySlice, be)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteEntity adds an entity in preparation for a batch delete
0000000000000000000000000000000000000000;;	func (t *TableBatch) DeleteEntity(entity *Entity, force bool) {
0000000000000000000000000000000000000000;;		be := BatchEntity{Entity: entity, Force: false, Op: DeleteOp}
0000000000000000000000000000000000000000;;		t.BatchEntitySlice = append(t.BatchEntitySlice, be)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteEntityByForce adds an entity in preparation for a batch delete. Forces regardless of ETag
0000000000000000000000000000000000000000;;	func (t *TableBatch) DeleteEntityByForce(entity *Entity, force bool) {
0000000000000000000000000000000000000000;;		t.DeleteEntity(entity, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeEntity adds an entity in preparation for a batch merge
0000000000000000000000000000000000000000;;	func (t *TableBatch) MergeEntity(entity *Entity) {
0000000000000000000000000000000000000000;;		be := BatchEntity{Entity: entity, Force: false, Op: MergeOp}
0000000000000000000000000000000000000000;;		t.BatchEntitySlice = append(t.BatchEntitySlice, be)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecuteBatch executes many table operations in one request to Azure.
0000000000000000000000000000000000000000;;	// The operations can be combinations of Insert, Delete, Replace and Merge
0000000000000000000000000000000000000000;;	// Creates the inner changeset body (various operations, Insert, Delete etc) then creates the outer request packet that encompasses
0000000000000000000000000000000000000000;;	// the changesets.
0000000000000000000000000000000000000000;;	// As per document https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/performing-entity-group-transactions
0000000000000000000000000000000000000000;;	func (t *TableBatch) ExecuteBatch() error {
0000000000000000000000000000000000000000;;		changesetBoundary := fmt.Sprintf("changeset_%s", uuid.NewV1())
0000000000000000000000000000000000000000;;		uri := t.Table.tsc.client.getEndpoint(tableServiceName, "$batch", nil)
0000000000000000000000000000000000000000;;		changesetBody, err := t.generateChangesetBody(changesetBoundary)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boundary := fmt.Sprintf("batch_%s", uuid.NewV1())
0000000000000000000000000000000000000000;;		body, err := generateBody(changesetBody, changesetBoundary, boundary)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := t.Table.tsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers[headerContentType] = fmt.Sprintf("multipart/mixed; boundary=%s", boundary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := t.Table.tsc.client.execBatchOperationJSON(http.MethodPost, uri, headers, bytes.NewReader(body.Bytes()), t.Table.tsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusAccepted}); err != nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check which batch failed.
0000000000000000000000000000000000000000;;			operationFailedMessage := t.getFailedOperation(resp.odata.Err.Message.Value)
0000000000000000000000000000000000000000;;			requestID, date, version := getDebugHeaders(resp.headers)
0000000000000000000000000000000000000000;;			return AzureStorageServiceError{
0000000000000000000000000000000000000000;;				StatusCode: resp.statusCode,
0000000000000000000000000000000000000000;;				Code:       resp.odata.Err.Code,
0000000000000000000000000000000000000000;;				RequestID:  requestID,
0000000000000000000000000000000000000000;;				Date:       date,
0000000000000000000000000000000000000000;;				APIVersion: version,
0000000000000000000000000000000000000000;;				Message:    operationFailedMessage,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getFailedOperation parses the original Azure error string and determines which operation failed
0000000000000000000000000000000000000000;;	// and generates appropriate message.
0000000000000000000000000000000000000000;;	func (t *TableBatch) getFailedOperation(errorMessage string) string {
0000000000000000000000000000000000000000;;		// errorMessage consists of "number:string" we just need the number.
0000000000000000000000000000000000000000;;		sp := strings.Split(errorMessage, ":")
0000000000000000000000000000000000000000;;		if len(sp) > 1 {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("Element %s in the batch returned an unexpected response code.\n%s", sp[0], errorMessage)
0000000000000000000000000000000000000000;;			return msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cant parse the message, just return the original message to client
0000000000000000000000000000000000000000;;		return errorMessage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateBody generates the complete body for the batch request.
0000000000000000000000000000000000000000;;	func generateBody(changeSetBody *bytes.Buffer, changesetBoundary string, boundary string) (*bytes.Buffer, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		writer := multipart.NewWriter(body)
0000000000000000000000000000000000000000;;		writer.SetBoundary(boundary)
0000000000000000000000000000000000000000;;		h := make(textproto.MIMEHeader)
0000000000000000000000000000000000000000;;		h.Set(headerContentType, fmt.Sprintf("multipart/mixed; boundary=%s\r\n", changesetBoundary))
0000000000000000000000000000000000000000;;		batchWriter, err := writer.CreatePart(h)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		batchWriter.Write(changeSetBody.Bytes())
0000000000000000000000000000000000000000;;		writer.Close()
0000000000000000000000000000000000000000;;		return body, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateChangesetBody generates the individual changesets for the various operations within the batch request.
0000000000000000000000000000000000000000;;	// There is a changeset for Insert, Delete, Merge etc.
0000000000000000000000000000000000000000;;	func (t *TableBatch) generateChangesetBody(changesetBoundary string) (*bytes.Buffer, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		writer := multipart.NewWriter(body)
0000000000000000000000000000000000000000;;		writer.SetBoundary(changesetBoundary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, be := range t.BatchEntitySlice {
0000000000000000000000000000000000000000;;			t.generateEntitySubset(&be, writer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writer.Close()
0000000000000000000000000000000000000000;;		return body, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateVerb generates the HTTP request VERB required for each changeset.
0000000000000000000000000000000000000000;;	func generateVerb(op Operation) (string, error) {
0000000000000000000000000000000000000000;;		switch op {
0000000000000000000000000000000000000000;;		case InsertOp:
0000000000000000000000000000000000000000;;			return http.MethodPost, nil
0000000000000000000000000000000000000000;;		case DeleteOp:
0000000000000000000000000000000000000000;;			return http.MethodDelete, nil
0000000000000000000000000000000000000000;;		case ReplaceOp, InsertOrReplaceOp:
0000000000000000000000000000000000000000;;			return http.MethodPut, nil
0000000000000000000000000000000000000000;;		case MergeOp, InsertOrMergeOp:
0000000000000000000000000000000000000000;;			return "MERGE", nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", errors.New("Unable to detect operation")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateQueryPath generates the query path for within the changesets
0000000000000000000000000000000000000000;;	// For inserts it will just be a table query path (table name)
0000000000000000000000000000000000000000;;	// but for other operations (modifying an existing entity) then
0000000000000000000000000000000000000000;;	// the partition/row keys need to be generated.
0000000000000000000000000000000000000000;;	func (t *TableBatch) generateQueryPath(op Operation, entity *Entity) string {
0000000000000000000000000000000000000000;;		if op == InsertOp {
0000000000000000000000000000000000000000;;			return entity.Table.buildPath()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return entity.buildPath()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateGenericOperationHeaders generates common headers for a given operation.
0000000000000000000000000000000000000000;;	func generateGenericOperationHeaders(be *BatchEntity) map[string]string {
0000000000000000000000000000000000000000;;		retval := map[string]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range defaultChangesetHeaders {
0000000000000000000000000000000000000000;;			retval[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if be.Op == DeleteOp || be.Op == ReplaceOp || be.Op == MergeOp {
0000000000000000000000000000000000000000;;			if be.Force || be.Entity.OdataEtag == "" {
0000000000000000000000000000000000000000;;				retval["If-Match"] = "*"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				retval["If-Match"] = be.Entity.OdataEtag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return retval
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateEntitySubset generates body payload for particular batch entity
0000000000000000000000000000000000000000;;	func (t *TableBatch) generateEntitySubset(batchEntity *BatchEntity, writer *multipart.Writer) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := make(textproto.MIMEHeader)
0000000000000000000000000000000000000000;;		h.Set(headerContentType, "application/http")
0000000000000000000000000000000000000000;;		h.Set(headerContentTransferEncoding, "binary")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		verb, err := generateVerb(batchEntity.Op)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genericOpHeadersMap := generateGenericOperationHeaders(batchEntity)
0000000000000000000000000000000000000000;;		queryPath := t.generateQueryPath(batchEntity.Op, batchEntity.Entity)
0000000000000000000000000000000000000000;;		uri := t.Table.tsc.client.getEndpoint(tableServiceName, queryPath, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operationWriter, err := writer.CreatePart(h)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		urlAndVerb := fmt.Sprintf("%s %s HTTP/1.1\r\n", verb, uri)
0000000000000000000000000000000000000000;;		operationWriter.Write([]byte(urlAndVerb))
0000000000000000000000000000000000000000;;		writeHeaders(genericOpHeadersMap, &operationWriter)
0000000000000000000000000000000000000000;;		operationWriter.Write([]byte("\r\n")) // additional \r\n is needed per changeset separating the "headers" and the body.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete operation doesn't need a body.
0000000000000000000000000000000000000000;;		if batchEntity.Op != DeleteOp {
0000000000000000000000000000000000000000;;			//var e Entity = batchEntity.Entity
0000000000000000000000000000000000000000;;			body, err := json.Marshal(batchEntity.Entity)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			operationWriter.Write(body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeHeaders(h map[string]string, writer *io.Writer) {
0000000000000000000000000000000000000000;;		// This way it is guaranteed the headers will be written in a sorted order
0000000000000000000000000000000000000000;;		var keys []string
0000000000000000000000000000000000000000;;		for k := range h {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			(*writer).Write([]byte(fmt.Sprintf("%s: %s\r\n", k, h[k])))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
