0000000000000000000000000000000000000000;;	package storage
bf119e8337b916a81932389e376d77629c43bfe3;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const fourMB = uint64(4194304)
0000000000000000000000000000000000000000;;	const oneTB = uint64(1099511627776)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File represents a file on a share.
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		fsc                *FileServiceClient
0000000000000000000000000000000000000000;;		Metadata           map[string]string
0000000000000000000000000000000000000000;;		Name               string `xml:"Name"`
0000000000000000000000000000000000000000;;		parent             *Directory
0000000000000000000000000000000000000000;;		Properties         FileProperties `xml:"Properties"`
0000000000000000000000000000000000000000;;		share              *Share
0000000000000000000000000000000000000000;;		FileCopyProperties FileCopyState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileProperties contains various properties of a file.
0000000000000000000000000000000000000000;;	type FileProperties struct {
0000000000000000000000000000000000000000;;		CacheControl string `header:"x-ms-cache-control"`
0000000000000000000000000000000000000000;;		Disposition  string `header:"x-ms-content-disposition"`
0000000000000000000000000000000000000000;;		Encoding     string `header:"x-ms-content-encoding"`
0000000000000000000000000000000000000000;;		Etag         string
0000000000000000000000000000000000000000;;		Language     string `header:"x-ms-content-language"`
0000000000000000000000000000000000000000;;		LastModified string
0000000000000000000000000000000000000000;;		Length       uint64 `xml:"Content-Length" header:"x-ms-content-length"`
0000000000000000000000000000000000000000;;		MD5          string `header:"x-ms-content-md5"`
0000000000000000000000000000000000000000;;		Type         string `header:"x-ms-content-type"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileCopyState contains various properties of a file copy operation.
0000000000000000000000000000000000000000;;	type FileCopyState struct {
0000000000000000000000000000000000000000;;		CompletionTime string
0000000000000000000000000000000000000000;;		ID             string `header:"x-ms-copy-id"`
0000000000000000000000000000000000000000;;		Progress       string
0000000000000000000000000000000000000000;;		Source         string
0000000000000000000000000000000000000000;;		Status         string `header:"x-ms-copy-status"`
0000000000000000000000000000000000000000;;		StatusDesc     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileStream contains file data returned from a call to GetFile.
0000000000000000000000000000000000000000;;	type FileStream struct {
0000000000000000000000000000000000000000;;		Body       io.ReadCloser
0000000000000000000000000000000000000000;;		ContentMD5 string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileRequestOptions will be passed to misc file operations.
0000000000000000000000000000000000000000;;	// Currently just Timeout (in seconds) but could expand.
0000000000000000000000000000000000000000;;	type FileRequestOptions struct {
0000000000000000000000000000000000000000;;		Timeout uint // timeout duration in seconds.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prepareOptions(options *FileRequestOptions) url.Values {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return params
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileRanges contains a list of file range information for a file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/List-Ranges
0000000000000000000000000000000000000000;;	type FileRanges struct {
0000000000000000000000000000000000000000;;		ContentLength uint64
0000000000000000000000000000000000000000;;		LastModified  string
0000000000000000000000000000000000000000;;		ETag          string
0000000000000000000000000000000000000000;;		FileRanges    []FileRange `xml:"Range"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileRange contains range information for a file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/List-Ranges
0000000000000000000000000000000000000000;;	type FileRange struct {
0000000000000000000000000000000000000000;;		Start uint64 `xml:"Start"`
0000000000000000000000000000000000000000;;		End   uint64 `xml:"End"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fr FileRange) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("bytes=%d-%d", fr.Start, fr.End)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// builds the complete file path for this file object
0000000000000000000000000000000000000000;;	func (f *File) buildPath() string {
0000000000000000000000000000000000000000;;		return f.parent.buildPath() + "/" + f.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearRange releases the specified range of space in a file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Put-Range
0000000000000000000000000000000000000000;;	func (f *File) ClearRange(fileRange FileRange, options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		var timeout *uint
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			timeout = &options.Timeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers, err := f.modifyRange(nil, fileRange, timeout, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates a new file or replaces an existing one.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Create-File
0000000000000000000000000000000000000000;;	func (f *File) Create(maxSize uint64, options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		if maxSize > oneTB {
0000000000000000000000000000000000000000;;			return fmt.Errorf("max file size is 1TB")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := prepareOptions(options)
0000000000000000000000000000000000000000;;		headers := headersFromStruct(f.Properties)
0000000000000000000000000000000000000000;;		headers["x-ms-content-length"] = strconv.FormatUint(maxSize, 10)
0000000000000000000000000000000000000000;;		headers["x-ms-type"] = "file"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outputHeaders, err := f.fsc.createResource(f.buildPath(), resourceFile, params, mergeMDIntoExtraHeaders(f.Metadata, headers), []int{http.StatusCreated})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Properties.Length = maxSize
0000000000000000000000000000000000000000;;		f.updateEtagAndLastModified(outputHeaders)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyFile operation copied a file/blob from the sourceURL to the path provided.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/copy-file
0000000000000000000000000000000000000000;;	func (f *File) CopyFile(sourceURL string, options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		extraHeaders := map[string]string{
0000000000000000000000000000000000000000;;			"x-ms-type":        "file",
0000000000000000000000000000000000000000;;			"x-ms-copy-source": sourceURL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := prepareOptions(options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers, err := f.fsc.createResource(f.buildPath(), resourceFile, params, mergeMDIntoExtraHeaders(f.Metadata, extraHeaders), []int{http.StatusAccepted})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.updateEtagLastModifiedAndCopyHeaders(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete immediately removes this file from the storage account.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Delete-File2
0000000000000000000000000000000000000000;;	func (f *File) Delete(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		return f.fsc.deleteResource(f.buildPath(), resourceFile, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteIfExists removes this file if it exists.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Delete-File2
0000000000000000000000000000000000000000;;	func (f *File) DeleteIfExists(options *FileRequestOptions) (bool, error) {
0000000000000000000000000000000000000000;;		resp, err := f.fsc.deleteResourceNoClose(f.buildPath(), resourceFile, options)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusAccepted || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusAccepted, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFileOptions includes options for a get file operation
0000000000000000000000000000000000000000;;	type GetFileOptions struct {
0000000000000000000000000000000000000000;;		Timeout       uint
0000000000000000000000000000000000000000;;		GetContentMD5 bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DownloadToStream operation downloads the file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-file
0000000000000000000000000000000000000000;;	func (f *File) DownloadToStream(options *FileRequestOptions) (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		params := prepareOptions(options)
0000000000000000000000000000000000000000;;		resp, err := f.fsc.getResourceNoClose(f.buildPath(), compNone, resourceFile, params, http.MethodGet, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp.body, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DownloadRangeToStream operation downloads the specified range of this file with optional MD5 hash.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-file
0000000000000000000000000000000000000000;;	func (f *File) DownloadRangeToStream(fileRange FileRange, options *GetFileOptions) (fs FileStream, err error) {
0000000000000000000000000000000000000000;;		extraHeaders := map[string]string{
0000000000000000000000000000000000000000;;			"Range": fileRange.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			if options.GetContentMD5 {
0000000000000000000000000000000000000000;;				if isRangeTooBig(fileRange) {
0000000000000000000000000000000000000000;;					return fs, fmt.Errorf("must specify a range less than or equal to 4MB when getContentMD5 is true")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				extraHeaders["x-ms-range-get-content-md5"] = "true"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := f.fsc.getResourceNoClose(f.buildPath(), compNone, resourceFile, params, http.MethodGet, extraHeaders)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fs, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK, http.StatusPartialContent}); err != nil {
0000000000000000000000000000000000000000;;			readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			return fs, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fs.Body = resp.body
0000000000000000000000000000000000000000;;		if options != nil && options.GetContentMD5 {
0000000000000000000000000000000000000000;;			fs.ContentMD5 = resp.headers.Get("Content-MD5")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exists returns true if this file exists.
0000000000000000000000000000000000000000;;	func (f *File) Exists() (bool, error) {
0000000000000000000000000000000000000000;;		exists, headers, err := f.fsc.resourceExists(f.buildPath(), resourceFile)
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			f.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;			f.updateProperties(headers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exists, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FetchAttributes updates metadata and properties for this file.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-file-properties
0000000000000000000000000000000000000000;;	func (f *File) FetchAttributes(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		params := prepareOptions(options)
0000000000000000000000000000000000000000;;		headers, err := f.fsc.getResourceHeaders(f.buildPath(), compNone, resourceFile, params, http.MethodHead)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		f.updateProperties(headers)
0000000000000000000000000000000000000000;;		f.Metadata = getMetadataFromHeaders(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns true if the range is larger than 4MB
0000000000000000000000000000000000000000;;	func isRangeTooBig(fileRange FileRange) bool {
0000000000000000000000000000000000000000;;		if fileRange.End-fileRange.Start > fourMB {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListRangesOptions includes options for a list file ranges operation
0000000000000000000000000000000000000000;;	type ListRangesOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		ListRange *FileRange
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListRanges returns the list of valid ranges for this file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/List-Ranges
0000000000000000000000000000000000000000;;	func (f *File) ListRanges(options *ListRangesOptions) (*FileRanges, error) {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"rangelist"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add optional range to list
0000000000000000000000000000000000000000;;		var headers map[string]string
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			if options.ListRange != nil {
0000000000000000000000000000000000000000;;				headers = make(map[string]string)
0000000000000000000000000000000000000000;;				headers["Range"] = options.ListRange.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := f.fsc.listContent(f.buildPath(), params, headers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;		var cl uint64
0000000000000000000000000000000000000000;;		cl, err = strconv.ParseUint(resp.headers.Get("x-ms-content-length"), 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ioutil.ReadAll(resp.body)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out FileRanges
0000000000000000000000000000000000000000;;		out.ContentLength = cl
0000000000000000000000000000000000000000;;		out.ETag = resp.headers.Get("ETag")
0000000000000000000000000000000000000000;;		out.LastModified = resp.headers.Get("Last-Modified")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &out)
0000000000000000000000000000000000000000;;		return &out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// modifies a range of bytes in this file
0000000000000000000000000000000000000000;;	func (f *File) modifyRange(bytes io.Reader, fileRange FileRange, timeout *uint, contentMD5 *string) (http.Header, error) {
0000000000000000000000000000000000000000;;		if err := f.fsc.checkForStorageEmulator(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fileRange.End < fileRange.Start {
0000000000000000000000000000000000000000;;			return nil, errors.New("the value for rangeEnd must be greater than or equal to rangeStart")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bytes != nil && isRangeTooBig(fileRange) {
0000000000000000000000000000000000000000;;			return nil, errors.New("range cannot exceed 4MB in size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"range"}}
0000000000000000000000000000000000000000;;		if timeout != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, *timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := f.fsc.client.getEndpoint(fileServiceName, f.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// default to clear
0000000000000000000000000000000000000000;;		write := "clear"
0000000000000000000000000000000000000000;;		cl := uint64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if bytes is not nil then this is an update operation
0000000000000000000000000000000000000000;;		if bytes != nil {
0000000000000000000000000000000000000000;;			write = "update"
0000000000000000000000000000000000000000;;			cl = (fileRange.End - fileRange.Start) + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extraHeaders := map[string]string{
0000000000000000000000000000000000000000;;			"Content-Length": strconv.FormatUint(cl, 10),
0000000000000000000000000000000000000000;;			"Range":          fileRange.String(),
0000000000000000000000000000000000000000;;			"x-ms-write":     write,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if contentMD5 != nil {
0000000000000000000000000000000000000000;;			extraHeaders["Content-MD5"] = *contentMD5
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := mergeHeaders(f.fsc.client.getStandardHeaders(), extraHeaders)
0000000000000000000000000000000000000000;;		resp, err := f.fsc.client.exec(http.MethodPut, uri, headers, bytes, f.fsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return resp.headers, checkRespCode(resp.statusCode, []int{http.StatusCreated})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMetadata replaces the metadata for this file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some keys may be converted to Camel-Case before sending. All keys
0000000000000000000000000000000000000000;;	// are returned in lower case by GetFileMetadata. HTTP header names
0000000000000000000000000000000000000000;;	// are case-insensitive so case munging should not matter to other
0000000000000000000000000000000000000000;;	// applications either.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Set-File-Metadata
0000000000000000000000000000000000000000;;	func (f *File) SetMetadata(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		headers, err := f.fsc.setResourceHeaders(f.buildPath(), compMetadata, resourceFile, mergeMDIntoExtraHeaders(f.Metadata, nil), options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetProperties sets system properties on this file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some keys may be converted to Camel-Case before sending. All keys
0000000000000000000000000000000000000000;;	// are returned in lower case by SetFileProperties. HTTP header names
0000000000000000000000000000000000000000;;	// are case-insensitive so case munging should not matter to other
0000000000000000000000000000000000000000;;	// applications either.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Set-File-Properties
0000000000000000000000000000000000000000;;	func (f *File) SetProperties(options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		headers, err := f.fsc.setResourceHeaders(f.buildPath(), compProperties, resourceFile, headersFromStruct(f.Properties), options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updates Etag and last modified date
0000000000000000000000000000000000000000;;	func (f *File) updateEtagAndLastModified(headers http.Header) {
0000000000000000000000000000000000000000;;		f.Properties.Etag = headers.Get("Etag")
0000000000000000000000000000000000000000;;		f.Properties.LastModified = headers.Get("Last-Modified")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updates Etag, last modified date and x-ms-copy-id
0000000000000000000000000000000000000000;;	func (f *File) updateEtagLastModifiedAndCopyHeaders(headers http.Header) {
0000000000000000000000000000000000000000;;		f.Properties.Etag = headers.Get("Etag")
0000000000000000000000000000000000000000;;		f.Properties.LastModified = headers.Get("Last-Modified")
0000000000000000000000000000000000000000;;		f.FileCopyProperties.ID = headers.Get("X-Ms-Copy-Id")
0000000000000000000000000000000000000000;;		f.FileCopyProperties.Status = headers.Get("X-Ms-Copy-Status")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updates file properties from the specified HTTP header
0000000000000000000000000000000000000000;;	func (f *File) updateProperties(header http.Header) {
0000000000000000000000000000000000000000;;		size, err := strconv.ParseUint(header.Get("Content-Length"), 10, 64)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			f.Properties.Length = size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.updateEtagAndLastModified(header)
0000000000000000000000000000000000000000;;		f.Properties.CacheControl = header.Get("Cache-Control")
0000000000000000000000000000000000000000;;		f.Properties.Disposition = header.Get("Content-Disposition")
0000000000000000000000000000000000000000;;		f.Properties.Encoding = header.Get("Content-Encoding")
0000000000000000000000000000000000000000;;		f.Properties.Language = header.Get("Content-Language")
0000000000000000000000000000000000000000;;		f.Properties.MD5 = header.Get("Content-MD5")
0000000000000000000000000000000000000000;;		f.Properties.Type = header.Get("Content-Type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URL gets the canonical URL to this file.
0000000000000000000000000000000000000000;;	// This method does not create a publicly accessible URL if the file
0000000000000000000000000000000000000000;;	// is private and this method does not check if the file exists.
0000000000000000000000000000000000000000;;	func (f *File) URL() string {
0000000000000000000000000000000000000000;;		return f.fsc.client.getEndpoint(fileServiceName, f.buildPath(), nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteRangeOptions includes opptions for a write file range operation
0000000000000000000000000000000000000000;;	type WriteRangeOptions struct {
0000000000000000000000000000000000000000;;		Timeout    uint
0000000000000000000000000000000000000000;;		ContentMD5 string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteRange writes a range of bytes to this file with an optional MD5 hash of the content (inside
0000000000000000000000000000000000000000;;	// options parameter). Note that the length of bytes must match (rangeEnd - rangeStart) + 1 with
0000000000000000000000000000000000000000;;	// a maximum size of 4MB.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Put-Range
0000000000000000000000000000000000000000;;	func (f *File) WriteRange(bytes io.Reader, fileRange FileRange, options *WriteRangeOptions) error {
0000000000000000000000000000000000000000;;		if bytes == nil {
0000000000000000000000000000000000000000;;			return errors.New("bytes cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var timeout *uint
0000000000000000000000000000000000000000;;		var md5 *string
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			timeout = &options.Timeout
0000000000000000000000000000000000000000;;			md5 = &options.ContentMD5
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers, err := f.modifyRange(bytes, fileRange, timeout, md5)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.updateEtagAndLastModified(headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
