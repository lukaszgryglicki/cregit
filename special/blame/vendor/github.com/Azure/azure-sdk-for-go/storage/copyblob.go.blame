0000000000000000000000000000000000000000;;	package storage
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		blobCopyStatusPending = "pending"
0000000000000000000000000000000000000000;;		blobCopyStatusSuccess = "success"
0000000000000000000000000000000000000000;;		blobCopyStatusAborted = "aborted"
0000000000000000000000000000000000000000;;		blobCopyStatusFailed  = "failed"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyOptions includes the options for a copy blob operation
0000000000000000000000000000000000000000;;	type CopyOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		Source    CopyOptionsConditions
0000000000000000000000000000000000000000;;		Destiny   CopyOptionsConditions
0000000000000000000000000000000000000000;;		RequestID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IncrementalCopyOptions includes the options for an incremental copy blob operation
0000000000000000000000000000000000000000;;	type IncrementalCopyOptions struct {
0000000000000000000000000000000000000000;;		Timeout     uint
0000000000000000000000000000000000000000;;		Destination IncrementalCopyOptionsConditions
0000000000000000000000000000000000000000;;		RequestID   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyOptionsConditions includes some conditional options in a copy blob operation
0000000000000000000000000000000000000000;;	type CopyOptionsConditions struct {
0000000000000000000000000000000000000000;;		LeaseID           string
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time
0000000000000000000000000000000000000000;;		IfMatch           string
0000000000000000000000000000000000000000;;		IfNoneMatch       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IncrementalCopyOptionsConditions includes some conditional options in a copy blob operation
0000000000000000000000000000000000000000;;	type IncrementalCopyOptionsConditions struct {
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time
0000000000000000000000000000000000000000;;		IfMatch           string
0000000000000000000000000000000000000000;;		IfNoneMatch       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy starts a blob copy operation and waits for the operation to
0000000000000000000000000000000000000000;;	// complete. sourceBlob parameter must be a canonical URL to the blob (can be
0000000000000000000000000000000000000000;;	// obtained using GetBlobURL method.) There is no SLA on blob copy and therefore
0000000000000000000000000000000000000000;;	// this helper method works faster on smaller files.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Copy-Blob
0000000000000000000000000000000000000000;;	func (b *Blob) Copy(sourceBlob string, options *CopyOptions) error {
0000000000000000000000000000000000000000;;		copyID, err := b.StartCopy(sourceBlob, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b.WaitForCopy(copyID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartCopy starts a blob copy operation.
0000000000000000000000000000000000000000;;	// sourceBlob parameter must be a canonical URL to the blob (can be
0000000000000000000000000000000000000000;;	// obtained using GetBlobURL method.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Copy-Blob
0000000000000000000000000000000000000000;;	func (b *Blob) StartCopy(sourceBlob string, options *CopyOptions) (string, error) {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers["x-ms-copy-source"] = sourceBlob
0000000000000000000000000000000000000000;;		headers = b.Container.bsc.client.addMetadataToHeaders(headers, b.Metadata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-client-request-id", options.RequestID)
0000000000000000000000000000000000000000;;			// source
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-source-lease-id", options.Source.LeaseID)
0000000000000000000000000000000000000000;;			headers = addTimeToHeaders(headers, "x-ms-source-if-modified-since", options.Source.IfModifiedSince)
0000000000000000000000000000000000000000;;			headers = addTimeToHeaders(headers, "x-ms-source-if-unmodified-since", options.Source.IfUnmodifiedSince)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-source-if-match", options.Source.IfMatch)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-source-if-none-match", options.Source.IfNoneMatch)
0000000000000000000000000000000000000000;;			//destiny
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-lease-id", options.Destiny.LeaseID)
0000000000000000000000000000000000000000;;			headers = addTimeToHeaders(headers, "x-ms-if-modified-since", options.Destiny.IfModifiedSince)
0000000000000000000000000000000000000000;;			headers = addTimeToHeaders(headers, "x-ms-if-unmodified-since", options.Destiny.IfUnmodifiedSince)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-if-match", options.Destiny.IfMatch)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-if-none-match", options.Destiny.IfNoneMatch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodPut, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusAccepted, http.StatusCreated}); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copyID := resp.headers.Get("x-ms-copy-id")
0000000000000000000000000000000000000000;;		if copyID == "" {
0000000000000000000000000000000000000000;;			return "", errors.New("Got empty copy id header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copyID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AbortCopyOptions includes the options for an abort blob operation
0000000000000000000000000000000000000000;;	type AbortCopyOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		LeaseID   string `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		RequestID string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AbortCopy aborts a BlobCopy which has already been triggered by the StartBlobCopy function.
0000000000000000000000000000000000000000;;	// copyID is generated from StartBlobCopy function.
0000000000000000000000000000000000000000;;	// currentLeaseID is required IF the destination blob has an active lease on it.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Abort-Copy-Blob
0000000000000000000000000000000000000000;;	func (b *Blob) AbortCopy(copyID string, options *AbortCopyOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{
0000000000000000000000000000000000000000;;			"comp":   {"copy"},
0000000000000000000000000000000000000000;;			"copyid": {copyID},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers["x-ms-copy-action"] = "abort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodPut, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusNoContent})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForCopy loops until a BlobCopy operation is completed (or fails with error)
0000000000000000000000000000000000000000;;	func (b *Blob) WaitForCopy(copyID string) error {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			err := b.GetProperties(nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if b.Properties.CopyID != copyID {
0000000000000000000000000000000000000000;;				return errBlobCopyIDMismatch
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch b.Properties.CopyStatus {
0000000000000000000000000000000000000000;;			case blobCopyStatusSuccess:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case blobCopyStatusPending:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case blobCopyStatusAborted:
0000000000000000000000000000000000000000;;				return errBlobCopyAborted
0000000000000000000000000000000000000000;;			case blobCopyStatusFailed:
0000000000000000000000000000000000000000;;				return fmt.Errorf("storage: blob copy failed. Id=%s Description=%s", b.Properties.CopyID, b.Properties.CopyStatusDescription)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("storage: unhandled blob copy status: '%s'", b.Properties.CopyStatus)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IncrementalCopyBlob copies a snapshot of a source blob and copies to referring blob
0000000000000000000000000000000000000000;;	// sourceBlob parameter must be a valid snapshot URL of the original blob.
0000000000000000000000000000000000000000;;	// THe original blob mut be public, or use a Shared Access Signature.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/incremental-copy-blob .
0000000000000000000000000000000000000000;;	func (b *Blob) IncrementalCopyBlob(sourceBlobURL string, snapshotTime time.Time, options *IncrementalCopyOptions) (string, error) {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"incrementalcopy"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need formatting to 7 decimal places so it's friendly to Windows and *nix
0000000000000000000000000000000000000000;;		snapshotTimeFormatted := snapshotTime.Format("2006-01-02T15:04:05.0000000Z")
0000000000000000000000000000000000000000;;		u, err := url.Parse(sourceBlobURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		query := u.Query()
0000000000000000000000000000000000000000;;		query.Add("snapshot", snapshotTimeFormatted)
0000000000000000000000000000000000000000;;		encodedQuery := query.Encode()
0000000000000000000000000000000000000000;;		encodedQuery = strings.Replace(encodedQuery, "%3A", ":", -1)
0000000000000000000000000000000000000000;;		u.RawQuery = encodedQuery
0000000000000000000000000000000000000000;;		snapshotURL := u.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers["x-ms-copy-source"] = snapshotURL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-client-request-id", options.RequestID)
0000000000000000000000000000000000000000;;			headers = addTimeToHeaders(headers, "x-ms-if-modified-since", options.Destination.IfModifiedSince)
0000000000000000000000000000000000000000;;			headers = addTimeToHeaders(headers, "x-ms-if-unmodified-since", options.Destination.IfUnmodifiedSince)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-if-match", options.Destination.IfMatch)
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-if-none-match", options.Destination.IfNoneMatch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get URI of destination blob
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodPut, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusAccepted}); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copyID := resp.headers.Get("x-ms-copy-id")
0000000000000000000000000000000000000000;;		if copyID == "" {
0000000000000000000000000000000000000000;;			return "", errors.New("Got empty copy id header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copyID, nil
0000000000000000000000000000000000000000;;	}
