0000000000000000000000000000000000000000;;	package storage
bf119e8337b916a81932389e376d77629c43bfe3;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/hmac"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		fixedTime = time.Date(2050, time.December, 20, 21, 55, 0, 0, time.FixedZone("GMT", -6))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) computeHmac256(message string) string {
0000000000000000000000000000000000000000;;		h := hmac.New(sha256.New, c.accountKey)
0000000000000000000000000000000000000000;;		h.Write([]byte(message))
0000000000000000000000000000000000000000;;		return base64.StdEncoding.EncodeToString(h.Sum(nil))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func currentTimeRfc1123Formatted() string {
0000000000000000000000000000000000000000;;		return timeRfc1123Formatted(time.Now().UTC())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func timeRfc1123Formatted(t time.Time) string {
0000000000000000000000000000000000000000;;		return t.Format(http.TimeFormat)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeParams(v1, v2 url.Values) url.Values {
0000000000000000000000000000000000000000;;		out := url.Values{}
0000000000000000000000000000000000000000;;		for k, v := range v1 {
0000000000000000000000000000000000000000;;			out[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range v2 {
0000000000000000000000000000000000000000;;			vals, ok := out[k]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				vals = append(vals, v...)
0000000000000000000000000000000000000000;;				out[k] = vals
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prepareBlockListRequest(blocks []Block) string {
0000000000000000000000000000000000000000;;		s := `<?xml version="1.0" encoding="utf-8"?><BlockList>`
0000000000000000000000000000000000000000;;		for _, v := range blocks {
0000000000000000000000000000000000000000;;			s += fmt.Sprintf("<%s>%s</%s>", v.Status, v.ID, v.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s += `</BlockList>`
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func xmlUnmarshal(body io.Reader, v interface{}) error {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return xml.Unmarshal(data, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func xmlMarshal(v interface{}) (io.Reader, int, error) {
0000000000000000000000000000000000000000;;		b, err := xml.Marshal(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes.NewReader(b), len(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func headersFromStruct(v interface{}) map[string]string {
0000000000000000000000000000000000000000;;		headers := make(map[string]string)
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(v)
0000000000000000000000000000000000000000;;		for i := 0; i < value.NumField(); i++ {
0000000000000000000000000000000000000000;;			key := value.Type().Field(i).Tag.Get("header")
0000000000000000000000000000000000000000;;			if key != "" {
0000000000000000000000000000000000000000;;				reflectedValue := reflect.Indirect(value.Field(i))
0000000000000000000000000000000000000000;;				var val string
0000000000000000000000000000000000000000;;				if reflectedValue.IsValid() {
0000000000000000000000000000000000000000;;					switch reflectedValue.Type() {
0000000000000000000000000000000000000000;;					case reflect.TypeOf(fixedTime):
0000000000000000000000000000000000000000;;						val = timeRfc1123Formatted(reflectedValue.Interface().(time.Time))
0000000000000000000000000000000000000000;;					case reflect.TypeOf(uint64(0)), reflect.TypeOf(uint(0)):
0000000000000000000000000000000000000000;;						val = strconv.FormatUint(reflectedValue.Uint(), 10)
0000000000000000000000000000000000000000;;					case reflect.TypeOf(int(0)):
0000000000000000000000000000000000000000;;						val = strconv.FormatInt(reflectedValue.Int(), 10)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						val = reflectedValue.String()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if val != "" {
0000000000000000000000000000000000000000;;					headers[key] = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return headers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// merges extraHeaders into headers and returns headers
0000000000000000000000000000000000000000;;	func mergeHeaders(headers, extraHeaders map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		for k, v := range extraHeaders {
0000000000000000000000000000000000000000;;			headers[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return headers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addToHeaders(h map[string]string, key, value string) map[string]string {
0000000000000000000000000000000000000000;;		if value != "" {
0000000000000000000000000000000000000000;;			h[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTimeToHeaders(h map[string]string, key string, value *time.Time) map[string]string {
0000000000000000000000000000000000000000;;		if value != nil {
0000000000000000000000000000000000000000;;			h = addToHeaders(h, key, timeRfc1123Formatted(*value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTimeout(params url.Values, timeout uint) url.Values {
0000000000000000000000000000000000000000;;		if timeout > 0 {
0000000000000000000000000000000000000000;;			params.Add("timeout", fmt.Sprintf("%v", timeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return params
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addSnapshot(params url.Values, snapshot *time.Time) url.Values {
0000000000000000000000000000000000000000;;		if snapshot != nil {
0000000000000000000000000000000000000000;;			params.Add("snapshot", timeRfc1123Formatted(*snapshot))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return params
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTimeFromHeaders(h http.Header, key string) (*time.Time, error) {
0000000000000000000000000000000000000000;;		var out time.Time
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		outStr := h.Get(key)
0000000000000000000000000000000000000000;;		if outStr != "" {
0000000000000000000000000000000000000000;;			out, err = time.Parse(time.RFC1123, outStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeRFC1123 is an alias for time.Time needed for custom Unmarshalling
0000000000000000000000000000000000000000;;	type TimeRFC1123 time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalXML is a custom unmarshaller that overrides the default time unmarshal which uses a different time layout.
0000000000000000000000000000000000000000;;	func (t *TimeRFC1123) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
0000000000000000000000000000000000000000;;		var value string
0000000000000000000000000000000000000000;;		d.DecodeElement(&value, &start)
0000000000000000000000000000000000000000;;		parse, err := time.Parse(time.RFC1123, value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*t = TimeRFC1123(parse)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns a map of custom metadata values from the specified HTTP header
0000000000000000000000000000000000000000;;	func getMetadataFromHeaders(header http.Header) map[string]string {
0000000000000000000000000000000000000000;;		metadata := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range header {
0000000000000000000000000000000000000000;;			// Can't trust CanonicalHeaderKey() to munge case
0000000000000000000000000000000000000000;;			// reliably. "_" is allowed in identifiers:
0000000000000000000000000000000000000000;;			// https://msdn.microsoft.com/en-us/library/azure/dd179414.aspx
0000000000000000000000000000000000000000;;			// https://msdn.microsoft.com/library/aa664670(VS.71).aspx
0000000000000000000000000000000000000000;;			// http://tools.ietf.org/html/rfc7230#section-3.2
0000000000000000000000000000000000000000;;			// ...but "_" is considered invalid by
0000000000000000000000000000000000000000;;			// CanonicalMIMEHeaderKey in
0000000000000000000000000000000000000000;;			// https://golang.org/src/net/textproto/reader.go?s=14615:14659#L542
0000000000000000000000000000000000000000;;			// so k can be "X-Ms-Meta-Lol" or "x-ms-meta-lol_rofl".
0000000000000000000000000000000000000000;;			k = strings.ToLower(k)
0000000000000000000000000000000000000000;;			if len(v) == 0 || !strings.HasPrefix(k, strings.ToLower(userDefinedMetadataHeaderPrefix)) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// metadata["lol"] = content of the last X-Ms-Meta-Lol header
0000000000000000000000000000000000000000;;			k = k[len(userDefinedMetadataHeaderPrefix):]
0000000000000000000000000000000000000000;;			metadata[k] = v[len(v)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(metadata) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return metadata
0000000000000000000000000000000000000000;;	}
