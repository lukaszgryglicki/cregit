0000000000000000000000000000000000000000;;	package storage
bf119e8337b916a81932389e376d77629c43bfe3;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Blob is an entry in BlobListResponse.
0000000000000000000000000000000000000000;;	type Blob struct {
0000000000000000000000000000000000000000;;		Container  *Container
0000000000000000000000000000000000000000;;		Name       string         `xml:"Name"`
0000000000000000000000000000000000000000;;		Snapshot   time.Time      `xml:"Snapshot"`
0000000000000000000000000000000000000000;;		Properties BlobProperties `xml:"Properties"`
0000000000000000000000000000000000000000;;		Metadata   BlobMetadata   `xml:"Metadata"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PutBlobOptions includes the options any put blob operation
0000000000000000000000000000000000000000;;	// (page, block, append)
0000000000000000000000000000000000000000;;	type PutBlobOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		Origin            string     `header:"Origin"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch           string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch       string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlobMetadata is a set of custom name/value pairs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd179404.aspx
0000000000000000000000000000000000000000;;	type BlobMetadata map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type blobMetadataEntries struct {
0000000000000000000000000000000000000000;;		Entries []blobMetadataEntry `xml:",any"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type blobMetadataEntry struct {
0000000000000000000000000000000000000000;;		XMLName xml.Name
0000000000000000000000000000000000000000;;		Value   string `xml:",chardata"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalXML converts the xml:Metadata into Metadata map
0000000000000000000000000000000000000000;;	func (bm *BlobMetadata) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
0000000000000000000000000000000000000000;;		var entries blobMetadataEntries
0000000000000000000000000000000000000000;;		if err := d.DecodeElement(&entries, &start); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, entry := range entries.Entries {
0000000000000000000000000000000000000000;;			if *bm == nil {
0000000000000000000000000000000000000000;;				*bm = make(BlobMetadata)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			(*bm)[strings.ToLower(entry.XMLName.Local)] = entry.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalXML implements the xml.Marshaler interface. It encodes
0000000000000000000000000000000000000000;;	// metadata name/value pairs as they would appear in an Azure
0000000000000000000000000000000000000000;;	// ListBlobs response.
0000000000000000000000000000000000000000;;	func (bm BlobMetadata) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
0000000000000000000000000000000000000000;;		entries := make([]blobMetadataEntry, 0, len(bm))
0000000000000000000000000000000000000000;;		for k, v := range bm {
0000000000000000000000000000000000000000;;			entries = append(entries, blobMetadataEntry{
0000000000000000000000000000000000000000;;				XMLName: xml.Name{Local: http.CanonicalHeaderKey(k)},
0000000000000000000000000000000000000000;;				Value:   v,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return enc.EncodeElement(blobMetadataEntries{
0000000000000000000000000000000000000000;;			Entries: entries,
0000000000000000000000000000000000000000;;		}, start)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlobProperties contains various properties of a blob
0000000000000000000000000000000000000000;;	// returned in various endpoints like ListBlobs or GetBlobProperties.
0000000000000000000000000000000000000000;;	type BlobProperties struct {
0000000000000000000000000000000000000000;;		LastModified          TimeRFC1123 `xml:"Last-Modified"`
0000000000000000000000000000000000000000;;		Etag                  string      `xml:"Etag"`
0000000000000000000000000000000000000000;;		ContentMD5            string      `xml:"Content-MD5" header:"x-ms-blob-content-md5"`
0000000000000000000000000000000000000000;;		ContentLength         int64       `xml:"Content-Length"`
0000000000000000000000000000000000000000;;		ContentType           string      `xml:"Content-Type" header:"x-ms-blob-content-type"`
0000000000000000000000000000000000000000;;		ContentEncoding       string      `xml:"Content-Encoding" header:"x-ms-blob-content-encoding"`
0000000000000000000000000000000000000000;;		CacheControl          string      `xml:"Cache-Control" header:"x-ms-blob-cache-control"`
0000000000000000000000000000000000000000;;		ContentLanguage       string      `xml:"Cache-Language" header:"x-ms-blob-content-language"`
0000000000000000000000000000000000000000;;		ContentDisposition    string      `xml:"Content-Disposition" header:"x-ms-blob-content-disposition"`
0000000000000000000000000000000000000000;;		BlobType              BlobType    `xml:"x-ms-blob-blob-type"`
0000000000000000000000000000000000000000;;		SequenceNumber        int64       `xml:"x-ms-blob-sequence-number"`
0000000000000000000000000000000000000000;;		CopyID                string      `xml:"CopyId"`
0000000000000000000000000000000000000000;;		CopyStatus            string      `xml:"CopyStatus"`
0000000000000000000000000000000000000000;;		CopySource            string      `xml:"CopySource"`
0000000000000000000000000000000000000000;;		CopyProgress          string      `xml:"CopyProgress"`
0000000000000000000000000000000000000000;;		CopyCompletionTime    TimeRFC1123 `xml:"CopyCompletionTime"`
0000000000000000000000000000000000000000;;		CopyStatusDescription string      `xml:"CopyStatusDescription"`
0000000000000000000000000000000000000000;;		LeaseStatus           string      `xml:"LeaseStatus"`
0000000000000000000000000000000000000000;;		LeaseState            string      `xml:"LeaseState"`
0000000000000000000000000000000000000000;;		LeaseDuration         string      `xml:"LeaseDuration"`
0000000000000000000000000000000000000000;;		ServerEncrypted       bool        `xml:"ServerEncrypted"`
0000000000000000000000000000000000000000;;		IncrementalCopy       bool        `xml:"IncrementalCopy"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlobType defines the type of the Azure Blob.
0000000000000000000000000000000000000000;;	type BlobType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Types of page blobs
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		BlobTypeBlock  BlobType = "BlockBlob"
0000000000000000000000000000000000000000;;		BlobTypePage   BlobType = "PageBlob"
0000000000000000000000000000000000000000;;		BlobTypeAppend BlobType = "AppendBlob"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Blob) buildPath() string {
0000000000000000000000000000000000000000;;		return b.Container.buildPath() + "/" + b.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exists returns true if a blob with given name exists on the specified
0000000000000000000000000000000000000000;;	// container of the storage account.
0000000000000000000000000000000000000000;;	func (b *Blob) Exists() (bool, error) {
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), nil)
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodHead, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusOK || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusOK, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetURL gets the canonical URL to the blob with the specified name in the
0000000000000000000000000000000000000000;;	// specified container. If name is not specified, the canonical URL for the entire
0000000000000000000000000000000000000000;;	// container is obtained.
0000000000000000000000000000000000000000;;	// This method does not create a publicly accessible URL if the blob or container
0000000000000000000000000000000000000000;;	// is private and this method does not check if the blob exists.
0000000000000000000000000000000000000000;;	func (b *Blob) GetURL() string {
0000000000000000000000000000000000000000;;		container := b.Container.Name
0000000000000000000000000000000000000000;;		if container == "" {
0000000000000000000000000000000000000000;;			container = "$root"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.Container.bsc.client.getEndpoint(blobServiceName, pathForResource(container, b.Name), nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBlobRangeOptions includes the options for a get blob range operation
0000000000000000000000000000000000000000;;	type GetBlobRangeOptions struct {
0000000000000000000000000000000000000000;;		Range              *BlobRange
0000000000000000000000000000000000000000;;		GetRangeContentMD5 bool
0000000000000000000000000000000000000000;;		*GetBlobOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBlobOptions includes the options for a get blob operation
0000000000000000000000000000000000000000;;	type GetBlobOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		Snapshot          *time.Time
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		Origin            string     `header:"Origin"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch           string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch       string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlobRange represents the bytes range to be get
0000000000000000000000000000000000000000;;	type BlobRange struct {
0000000000000000000000000000000000000000;;		Start uint64
0000000000000000000000000000000000000000;;		End   uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (br BlobRange) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("bytes=%d-%d", br.Start, br.End)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns a stream to read the blob. Caller must call both Read and Close()
0000000000000000000000000000000000000000;;	// to correctly close the underlying connection.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Get-Blob
0000000000000000000000000000000000000000;;	func (b *Blob) Get(options *GetBlobOptions) (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		rangeOptions := GetBlobRangeOptions{
0000000000000000000000000000000000000000;;			GetBlobOptions: options,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := b.getRange(&rangeOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := b.writePropoerties(resp.headers); err != nil {
0000000000000000000000000000000000000000;;			return resp.body, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp.body, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRange reads the specified range of a blob to a stream. The bytesRange
0000000000000000000000000000000000000000;;	// string must be in a format like "0-", "10-100" as defined in HTTP 1.1 spec.
0000000000000000000000000000000000000000;;	// Caller must call both Read and Close()// to correctly close the underlying
0000000000000000000000000000000000000000;;	// connection.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Get-Blob
0000000000000000000000000000000000000000;;	func (b *Blob) GetRange(options *GetBlobRangeOptions) (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		resp, err := b.getRange(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusPartialContent}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := b.writePropoerties(resp.headers); err != nil {
0000000000000000000000000000000000000000;;			return resp.body, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp.body, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Blob) getRange(options *GetBlobRangeOptions) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			if options.Range != nil {
0000000000000000000000000000000000000000;;				headers["Range"] = options.Range.String()
0000000000000000000000000000000000000000;;				headers["x-ms-range-get-content-md5"] = fmt.Sprintf("%v", options.GetRangeContentMD5)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.GetBlobOptions != nil {
0000000000000000000000000000000000000000;;				headers = mergeHeaders(headers, headersFromStruct(*options.GetBlobOptions))
0000000000000000000000000000000000000000;;				params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;				params = addSnapshot(params, options.Snapshot)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodGet, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SnapshotOptions includes the options for a snapshot blob operation
0000000000000000000000000000000000000000;;	type SnapshotOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch           string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch       string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSnapshot creates a snapshot for a blob
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/ee691971.aspx
0000000000000000000000000000000000000000;;	func (b *Blob) CreateSnapshot(options *SnapshotOptions) (snapshotTimestamp *time.Time, err error) {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"snapshot"}}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = b.Container.bsc.client.addMetadataToHeaders(headers, b.Metadata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodPut, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil || resp == nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusCreated}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		snapshotResponse := resp.headers.Get(http.CanonicalHeaderKey("x-ms-snapshot"))
0000000000000000000000000000000000000000;;		if snapshotResponse != "" {
0000000000000000000000000000000000000000;;			snapshotTimestamp, err := time.Parse(time.RFC3339, snapshotResponse)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &snapshotTimestamp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, errors.New("Snapshot not created")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBlobPropertiesOptions includes the options for a get blob properties operation
0000000000000000000000000000000000000000;;	type GetBlobPropertiesOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		Snapshot          *time.Time
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch           string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch       string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetProperties provides various information about the specified blob.
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd179394.aspx
0000000000000000000000000000000000000000;;	func (b *Blob) GetProperties(options *GetBlobPropertiesOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			params = addSnapshot(params, options.Snapshot)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodHead, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.writePropoerties(resp.headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Blob) writePropoerties(h http.Header) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var contentLength int64
0000000000000000000000000000000000000000;;		contentLengthStr := h.Get("Content-Length")
0000000000000000000000000000000000000000;;		if contentLengthStr != "" {
0000000000000000000000000000000000000000;;			contentLength, err = strconv.ParseInt(contentLengthStr, 0, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sequenceNum int64
0000000000000000000000000000000000000000;;		sequenceNumStr := h.Get("x-ms-blob-sequence-number")
0000000000000000000000000000000000000000;;		if sequenceNumStr != "" {
0000000000000000000000000000000000000000;;			sequenceNum, err = strconv.ParseInt(sequenceNumStr, 0, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastModified, err := getTimeFromHeaders(h, "Last-Modified")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copyCompletionTime, err := getTimeFromHeaders(h, "x-ms-copy-completion-time")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.Properties = BlobProperties{
0000000000000000000000000000000000000000;;			LastModified:          TimeRFC1123(*lastModified),
0000000000000000000000000000000000000000;;			Etag:                  h.Get("Etag"),
0000000000000000000000000000000000000000;;			ContentMD5:            h.Get("Content-MD5"),
0000000000000000000000000000000000000000;;			ContentLength:         contentLength,
0000000000000000000000000000000000000000;;			ContentEncoding:       h.Get("Content-Encoding"),
0000000000000000000000000000000000000000;;			ContentType:           h.Get("Content-Type"),
0000000000000000000000000000000000000000;;			ContentDisposition:    h.Get("Content-Disposition"),
0000000000000000000000000000000000000000;;			CacheControl:          h.Get("Cache-Control"),
0000000000000000000000000000000000000000;;			ContentLanguage:       h.Get("Content-Language"),
0000000000000000000000000000000000000000;;			SequenceNumber:        sequenceNum,
0000000000000000000000000000000000000000;;			CopyCompletionTime:    TimeRFC1123(*copyCompletionTime),
0000000000000000000000000000000000000000;;			CopyStatusDescription: h.Get("x-ms-copy-status-description"),
0000000000000000000000000000000000000000;;			CopyID:                h.Get("x-ms-copy-id"),
0000000000000000000000000000000000000000;;			CopyProgress:          h.Get("x-ms-copy-progress"),
0000000000000000000000000000000000000000;;			CopySource:            h.Get("x-ms-copy-source"),
0000000000000000000000000000000000000000;;			CopyStatus:            h.Get("x-ms-copy-status"),
0000000000000000000000000000000000000000;;			BlobType:              BlobType(h.Get("x-ms-blob-type")),
0000000000000000000000000000000000000000;;			LeaseStatus:           h.Get("x-ms-lease-status"),
0000000000000000000000000000000000000000;;			LeaseState:            h.Get("x-ms-lease-state"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeMetadata(h)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBlobPropertiesOptions contains various properties of a blob and is an entry
0000000000000000000000000000000000000000;;	// in SetProperties
0000000000000000000000000000000000000000;;	type SetBlobPropertiesOptions struct {
0000000000000000000000000000000000000000;;		Timeout              uint
0000000000000000000000000000000000000000;;		LeaseID              string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		Origin               string     `header:"Origin"`
0000000000000000000000000000000000000000;;		IfModifiedSince      *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince    *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch              string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch          string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		SequenceNumberAction *SequenceNumberAction
0000000000000000000000000000000000000000;;		RequestID            string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SequenceNumberAction defines how the blob's sequence number should be modified
0000000000000000000000000000000000000000;;	type SequenceNumberAction string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options for sequence number action
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SequenceNumberActionMax       SequenceNumberAction = "max"
0000000000000000000000000000000000000000;;		SequenceNumberActionUpdate    SequenceNumberAction = "update"
0000000000000000000000000000000000000000;;		SequenceNumberActionIncrement SequenceNumberAction = "increment"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetProperties replaces the BlobHeaders for the specified blob.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some keys may be converted to Camel-Case before sending. All keys
0000000000000000000000000000000000000000;;	// are returned in lower case by GetBlobProperties. HTTP header names
0000000000000000000000000000000000000000;;	// are case-insensitive so case munging should not matter to other
0000000000000000000000000000000000000000;;	// applications either.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Set-Blob-Properties
0000000000000000000000000000000000000000;;	func (b *Blob) SetProperties(options *SetBlobPropertiesOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"properties"}}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = mergeHeaders(headers, headersFromStruct(b.Properties))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b.Properties.BlobType == BlobTypePage {
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-blob-content-length", fmt.Sprintf("byte %v", b.Properties.ContentLength))
0000000000000000000000000000000000000000;;			if options != nil || options.SequenceNumberAction != nil {
0000000000000000000000000000000000000000;;				headers = addToHeaders(headers, "x-ms-sequence-number-action", string(*options.SequenceNumberAction))
0000000000000000000000000000000000000000;;				if *options.SequenceNumberAction != SequenceNumberActionIncrement {
0000000000000000000000000000000000000000;;					headers = addToHeaders(headers, "x-ms-blob-sequence-number", fmt.Sprintf("%v", b.Properties.SequenceNumber))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodPut, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusOK})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBlobMetadataOptions includes the options for a set blob metadata operation
0000000000000000000000000000000000000000;;	type SetBlobMetadataOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch           string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch       string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMetadata replaces the metadata for the specified blob.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some keys may be converted to Camel-Case before sending. All keys
0000000000000000000000000000000000000000;;	// are returned in lower case by GetBlobMetadata. HTTP header names
0000000000000000000000000000000000000000;;	// are case-insensitive so case munging should not matter to other
0000000000000000000000000000000000000000;;	// applications either.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd179414.aspx
0000000000000000000000000000000000000000;;	func (b *Blob) SetMetadata(options *SetBlobMetadataOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"metadata"}}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = b.Container.bsc.client.addMetadataToHeaders(headers, b.Metadata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodPut, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusOK})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBlobMetadataOptions includes the options for a get blob metadata operation
0000000000000000000000000000000000000000;;	type GetBlobMetadataOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		Snapshot          *time.Time
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch           string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch       string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetadata returns all user-defined metadata for the specified blob.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All metadata keys will be returned in lower case. (HTTP header
0000000000000000000000000000000000000000;;	// names are case-insensitive.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd179414.aspx
0000000000000000000000000000000000000000;;	func (b *Blob) GetMetadata(options *GetBlobMetadataOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"metadata"}}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			params = addSnapshot(params, options.Snapshot)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := b.Container.bsc.client.exec(http.MethodGet, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.writeMetadata(resp.headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Blob) writeMetadata(h http.Header) {
0000000000000000000000000000000000000000;;		metadata := make(map[string]string)
0000000000000000000000000000000000000000;;		for k, v := range h {
0000000000000000000000000000000000000000;;			// Can't trust CanonicalHeaderKey() to munge case
0000000000000000000000000000000000000000;;			// reliably. "_" is allowed in identifiers:
0000000000000000000000000000000000000000;;			// https://msdn.microsoft.com/en-us/library/azure/dd179414.aspx
0000000000000000000000000000000000000000;;			// https://msdn.microsoft.com/library/aa664670(VS.71).aspx
0000000000000000000000000000000000000000;;			// http://tools.ietf.org/html/rfc7230#section-3.2
0000000000000000000000000000000000000000;;			// ...but "_" is considered invalid by
0000000000000000000000000000000000000000;;			// CanonicalMIMEHeaderKey in
0000000000000000000000000000000000000000;;			// https://golang.org/src/net/textproto/reader.go?s=14615:14659#L542
0000000000000000000000000000000000000000;;			// so k can be "X-Ms-Meta-Lol" or "x-ms-meta-lol_rofl".
0000000000000000000000000000000000000000;;			k = strings.ToLower(k)
0000000000000000000000000000000000000000;;			if len(v) == 0 || !strings.HasPrefix(k, strings.ToLower(userDefinedMetadataHeaderPrefix)) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// metadata["lol"] = content of the last X-Ms-Meta-Lol header
0000000000000000000000000000000000000000;;			k = k[len(userDefinedMetadataHeaderPrefix):]
0000000000000000000000000000000000000000;;			metadata[k] = v[len(v)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.Metadata = BlobMetadata(metadata)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteBlobOptions includes the options for a delete blob operation
0000000000000000000000000000000000000000;;	type DeleteBlobOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		Snapshot          *time.Time
0000000000000000000000000000000000000000;;		LeaseID           string `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		DeleteSnapshots   *bool
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		IfMatch           string     `header:"If-Match"`
0000000000000000000000000000000000000000;;		IfNoneMatch       string     `header:"If-None-Match"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes the given blob from the specified container.
0000000000000000000000000000000000000000;;	// If the blob does not exists at the time of the Delete Blob operation, it
0000000000000000000000000000000000000000;;	// returns error.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Delete-Blob
0000000000000000000000000000000000000000;;	func (b *Blob) Delete(options *DeleteBlobOptions) error {
0000000000000000000000000000000000000000;;		resp, err := b.delete(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusAccepted})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteIfExists deletes the given blob from the specified container If the
0000000000000000000000000000000000000000;;	// blob is deleted with this call, returns true. Otherwise returns false.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Delete-Blob
0000000000000000000000000000000000000000;;	func (b *Blob) DeleteIfExists(options *DeleteBlobOptions) (bool, error) {
0000000000000000000000000000000000000000;;		resp, err := b.delete(options)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusAccepted || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusAccepted, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Blob) delete(options *DeleteBlobOptions) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		headers := b.Container.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			params = addSnapshot(params, options.Snapshot)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;			if options.DeleteSnapshots != nil {
0000000000000000000000000000000000000000;;				if *options.DeleteSnapshots {
0000000000000000000000000000000000000000;;					headers["x-ms-delete-snapshots"] = "include"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					headers["x-ms-delete-snapshots"] = "only"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := b.Container.bsc.client.getEndpoint(blobServiceName, b.buildPath(), params)
0000000000000000000000000000000000000000;;		return b.Container.bsc.client.exec(http.MethodDelete, uri, headers, nil, b.Container.bsc.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper method to construct the path to either a blob or container
0000000000000000000000000000000000000000;;	func pathForResource(container, name string) string {
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("/%s/%s", container, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/%s", container)
0000000000000000000000000000000000000000;;	}
