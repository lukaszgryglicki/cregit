0000000000000000000000000000000000000000;;	package storage
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileServiceClient contains operations for Microsoft Azure File Service.
0000000000000000000000000000000000000000;;	type FileServiceClient struct {
0000000000000000000000000000000000000000;;		client Client
0000000000000000000000000000000000000000;;		auth   authentication
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListSharesParameters defines the set of customizable parameters to make a
0000000000000000000000000000000000000000;;	// List Shares call.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/List-Shares
0000000000000000000000000000000000000000;;	type ListSharesParameters struct {
0000000000000000000000000000000000000000;;		Prefix     string
0000000000000000000000000000000000000000;;		Marker     string
0000000000000000000000000000000000000000;;		Include    string
0000000000000000000000000000000000000000;;		MaxResults uint
0000000000000000000000000000000000000000;;		Timeout    uint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShareListResponse contains the response fields from
0000000000000000000000000000000000000000;;	// ListShares call.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/List-Shares
0000000000000000000000000000000000000000;;	type ShareListResponse struct {
0000000000000000000000000000000000000000;;		XMLName    xml.Name `xml:"EnumerationResults"`
0000000000000000000000000000000000000000;;		Xmlns      string   `xml:"xmlns,attr"`
0000000000000000000000000000000000000000;;		Prefix     string   `xml:"Prefix"`
0000000000000000000000000000000000000000;;		Marker     string   `xml:"Marker"`
0000000000000000000000000000000000000000;;		NextMarker string   `xml:"NextMarker"`
0000000000000000000000000000000000000000;;		MaxResults int64    `xml:"MaxResults"`
0000000000000000000000000000000000000000;;		Shares     []Share  `xml:"Shares>Share"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type compType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		compNone       compType = ""
0000000000000000000000000000000000000000;;		compList       compType = "list"
0000000000000000000000000000000000000000;;		compMetadata   compType = "metadata"
0000000000000000000000000000000000000000;;		compProperties compType = "properties"
0000000000000000000000000000000000000000;;		compRangeList  compType = "rangelist"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ct compType) String() string {
0000000000000000000000000000000000000000;;		return string(ct)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resourceType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		resourceDirectory resourceType = "directory"
0000000000000000000000000000000000000000;;		resourceFile      resourceType = ""
0000000000000000000000000000000000000000;;		resourceShare     resourceType = "share"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt resourceType) String() string {
0000000000000000000000000000000000000000;;		return string(rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p ListSharesParameters) getParameters() url.Values {
0000000000000000000000000000000000000000;;		out := url.Values{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Prefix != "" {
0000000000000000000000000000000000000000;;			out.Set("prefix", p.Prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Marker != "" {
0000000000000000000000000000000000000000;;			out.Set("marker", p.Marker)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Include != "" {
0000000000000000000000000000000000000000;;			out.Set("include", p.Include)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.MaxResults != 0 {
0000000000000000000000000000000000000000;;			out.Set("maxresults", strconv.FormatUint(uint64(p.MaxResults), 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Timeout != 0 {
0000000000000000000000000000000000000000;;			out.Set("timeout", strconv.FormatUint(uint64(p.Timeout), 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p ListDirsAndFilesParameters) getParameters() url.Values {
0000000000000000000000000000000000000000;;		out := url.Values{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Prefix != "" {
0000000000000000000000000000000000000000;;			out.Set("prefix", p.Prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Marker != "" {
0000000000000000000000000000000000000000;;			out.Set("marker", p.Marker)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.MaxResults != 0 {
0000000000000000000000000000000000000000;;			out.Set("maxresults", strconv.FormatUint(uint64(p.MaxResults), 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out = addTimeout(out, p.Timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns url.Values for the specified types
0000000000000000000000000000000000000000;;	func getURLInitValues(comp compType, res resourceType) url.Values {
0000000000000000000000000000000000000000;;		values := url.Values{}
0000000000000000000000000000000000000000;;		if comp != compNone {
0000000000000000000000000000000000000000;;			values.Set("comp", comp.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res != resourceFile {
0000000000000000000000000000000000000000;;			values.Set("restype", res.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return values
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetShareReference returns a Share object for the specified share name.
0000000000000000000000000000000000000000;;	func (f *FileServiceClient) GetShareReference(name string) *Share {
0000000000000000000000000000000000000000;;		return &Share{
0000000000000000000000000000000000000000;;			fsc:  f,
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;			Properties: ShareProperties{
0000000000000000000000000000000000000000;;				Quota: -1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListShares returns the list of shares in a storage account along with
0000000000000000000000000000000000000000;;	// pagination token and other response details.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/list-shares
0000000000000000000000000000000000000000;;	func (f FileServiceClient) ListShares(params ListSharesParameters) (*ShareListResponse, error) {
0000000000000000000000000000000000000000;;		q := mergeParams(params.getParameters(), url.Values{"comp": {"list"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out ShareListResponse
0000000000000000000000000000000000000000;;		resp, err := f.listContent("", q, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assign our client to the newly created Share objects
0000000000000000000000000000000000000000;;		for i := range out.Shares {
0000000000000000000000000000000000000000;;			out.Shares[i].fsc = &f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetServiceProperties gets the properties of your storage account's file service.
0000000000000000000000000000000000000000;;	// File service does not support logging
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-file-service-properties
0000000000000000000000000000000000000000;;	func (f *FileServiceClient) GetServiceProperties() (*ServiceProperties, error) {
0000000000000000000000000000000000000000;;		return f.client.getServiceProperties(fileServiceName, f.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetServiceProperties sets the properties of your storage account's file service.
0000000000000000000000000000000000000000;;	// File service does not support logging
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/set-file-service-properties
0000000000000000000000000000000000000000;;	func (f *FileServiceClient) SetServiceProperties(props ServiceProperties) error {
0000000000000000000000000000000000000000;;		return f.client.setServiceProperties(props, fileServiceName, f.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// retrieves directory or share content
0000000000000000000000000000000000000000;;	func (f FileServiceClient) listContent(path string, params url.Values, extraHeaders map[string]string) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		if err := f.checkForStorageEmulator(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := f.client.getEndpoint(fileServiceName, path, params)
0000000000000000000000000000000000000000;;		extraHeaders = f.client.protectUserAgent(extraHeaders)
0000000000000000000000000000000000000000;;		headers := mergeHeaders(f.client.getStandardHeaders(), extraHeaders)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := f.client.exec(http.MethodGet, uri, headers, nil, f.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns true if the specified resource exists
0000000000000000000000000000000000000000;;	func (f FileServiceClient) resourceExists(path string, res resourceType) (bool, http.Header, error) {
0000000000000000000000000000000000000000;;		if err := f.checkForStorageEmulator(); err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := f.client.getEndpoint(fileServiceName, path, getURLInitValues(compNone, res))
0000000000000000000000000000000000000000;;		headers := f.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := f.client.exec(http.MethodHead, uri, headers, nil, f.auth)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusOK || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusOK, resp.headers, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// creates a resource depending on the specified resource type
0000000000000000000000000000000000000000;;	func (f FileServiceClient) createResource(path string, res resourceType, urlParams url.Values, extraHeaders map[string]string, expectedResponseCodes []int) (http.Header, error) {
0000000000000000000000000000000000000000;;		resp, err := f.createResourceNoClose(path, res, urlParams, extraHeaders)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return resp.headers, checkRespCode(resp.statusCode, expectedResponseCodes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// creates a resource depending on the specified resource type, doesn't close the response body
0000000000000000000000000000000000000000;;	func (f FileServiceClient) createResourceNoClose(path string, res resourceType, urlParams url.Values, extraHeaders map[string]string) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		if err := f.checkForStorageEmulator(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		values := getURLInitValues(compNone, res)
0000000000000000000000000000000000000000;;		combinedParams := mergeParams(values, urlParams)
0000000000000000000000000000000000000000;;		uri := f.client.getEndpoint(fileServiceName, path, combinedParams)
0000000000000000000000000000000000000000;;		extraHeaders = f.client.protectUserAgent(extraHeaders)
0000000000000000000000000000000000000000;;		headers := mergeHeaders(f.client.getStandardHeaders(), extraHeaders)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.client.exec(http.MethodPut, uri, headers, nil, f.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns HTTP header data for the specified directory or share
0000000000000000000000000000000000000000;;	func (f FileServiceClient) getResourceHeaders(path string, comp compType, res resourceType, params url.Values, verb string) (http.Header, error) {
0000000000000000000000000000000000000000;;		resp, err := f.getResourceNoClose(path, comp, res, params, verb, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.headers, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gets the specified resource, doesn't close the response body
0000000000000000000000000000000000000000;;	func (f FileServiceClient) getResourceNoClose(path string, comp compType, res resourceType, params url.Values, verb string, extraHeaders map[string]string) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		if err := f.checkForStorageEmulator(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params = mergeParams(params, getURLInitValues(comp, res))
0000000000000000000000000000000000000000;;		uri := f.client.getEndpoint(fileServiceName, path, params)
0000000000000000000000000000000000000000;;		headers := mergeHeaders(f.client.getStandardHeaders(), extraHeaders)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.client.exec(verb, uri, headers, nil, f.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deletes the resource and returns the response
0000000000000000000000000000000000000000;;	func (f FileServiceClient) deleteResource(path string, res resourceType, options *FileRequestOptions) error {
0000000000000000000000000000000000000000;;		resp, err := f.deleteResourceNoClose(path, res, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusAccepted})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deletes the resource and returns the response, doesn't close the response body
0000000000000000000000000000000000000000;;	func (f FileServiceClient) deleteResourceNoClose(path string, res resourceType, options *FileRequestOptions) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		if err := f.checkForStorageEmulator(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		values := mergeParams(getURLInitValues(compNone, res), prepareOptions(options))
0000000000000000000000000000000000000000;;		uri := f.client.getEndpoint(fileServiceName, path, values)
0000000000000000000000000000000000000000;;		return f.client.exec(http.MethodDelete, uri, f.client.getStandardHeaders(), nil, f.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// merges metadata into extraHeaders and returns extraHeaders
0000000000000000000000000000000000000000;;	func mergeMDIntoExtraHeaders(metadata, extraHeaders map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		if metadata == nil && extraHeaders == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraHeaders == nil {
0000000000000000000000000000000000000000;;			extraHeaders = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range metadata {
0000000000000000000000000000000000000000;;			extraHeaders[userDefinedMetadataHeaderPrefix+k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return extraHeaders
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sets extra header data for the specified resource
0000000000000000000000000000000000000000;;	func (f FileServiceClient) setResourceHeaders(path string, comp compType, res resourceType, extraHeaders map[string]string, options *FileRequestOptions) (http.Header, error) {
0000000000000000000000000000000000000000;;		if err := f.checkForStorageEmulator(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := mergeParams(getURLInitValues(comp, res), prepareOptions(options))
0000000000000000000000000000000000000000;;		uri := f.client.getEndpoint(fileServiceName, path, params)
0000000000000000000000000000000000000000;;		extraHeaders = f.client.protectUserAgent(extraHeaders)
0000000000000000000000000000000000000000;;		headers := mergeHeaders(f.client.getStandardHeaders(), extraHeaders)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := f.client.exec(http.MethodPut, uri, headers, nil, f.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.headers, checkRespCode(resp.statusCode, []int{http.StatusOK})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//checkForStorageEmulator determines if the client is setup for use with
0000000000000000000000000000000000000000;;	//Azure Storage Emulator, and returns a relevant error
0000000000000000000000000000000000000000;;	func (f FileServiceClient) checkForStorageEmulator() error {
0000000000000000000000000000000000000000;;		if f.client.accountName == StorageEmulatorAccountName {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Error: File service is not currently supported by Azure Storage Emulator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
