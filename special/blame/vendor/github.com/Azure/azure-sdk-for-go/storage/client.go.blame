0000000000000000000000000000000000000000;;	// Package storage provides clients for Microsoft Azure Storage Services.
0000000000000000000000000000000000000000;;	package storage
bf119e8337b916a81932389e376d77629c43bfe3;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"mime/multipart"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/azure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultBaseURL is the domain name used for storage requests in the
0000000000000000000000000000000000000000;;		// public cloud when a default client is created.
0000000000000000000000000000000000000000;;		DefaultBaseURL = "core.windows.net"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultAPIVersion is the Azure Storage API version string used when a
0000000000000000000000000000000000000000;;		// basic client is created.
0000000000000000000000000000000000000000;;		DefaultAPIVersion = "2016-05-31"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultUseHTTPS = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StorageEmulatorAccountName is the fixed storage account used by Azure Storage Emulator
0000000000000000000000000000000000000000;;		StorageEmulatorAccountName = "devstoreaccount1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StorageEmulatorAccountKey is the the fixed storage account used by Azure Storage Emulator
0000000000000000000000000000000000000000;;		StorageEmulatorAccountKey = "Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw=="
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		blobServiceName  = "blob"
0000000000000000000000000000000000000000;;		tableServiceName = "table"
0000000000000000000000000000000000000000;;		queueServiceName = "queue"
0000000000000000000000000000000000000000;;		fileServiceName  = "file"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageEmulatorBlob  = "127.0.0.1:10000"
0000000000000000000000000000000000000000;;		storageEmulatorTable = "127.0.0.1:10002"
0000000000000000000000000000000000000000;;		storageEmulatorQueue = "127.0.0.1:10001"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		userAgentHeader = "User-Agent"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		userDefinedMetadataHeaderPrefix = "x-ms-meta-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		validStorageAccount = regexp.MustCompile("^[0-9a-z]{3,24}$")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sender sends a request
0000000000000000000000000000000000000000;;	type Sender interface {
0000000000000000000000000000000000000000;;		Send(*Client, *http.Request) (*http.Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultSender is the default sender for the client. It implements
0000000000000000000000000000000000000000;;	// an automatic retry strategy.
0000000000000000000000000000000000000000;;	type DefaultSender struct {
0000000000000000000000000000000000000000;;		RetryAttempts    int
0000000000000000000000000000000000000000;;		RetryDuration    time.Duration
0000000000000000000000000000000000000000;;		ValidStatusCodes []int
0000000000000000000000000000000000000000;;		attempts         int // used for testing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send is the default retry strategy in the client
0000000000000000000000000000000000000000;;	func (ds *DefaultSender) Send(c *Client, req *http.Request) (resp *http.Response, err error) {
0000000000000000000000000000000000000000;;		b := []byte{}
0000000000000000000000000000000000000000;;		if req.Body != nil {
0000000000000000000000000000000000000000;;			b, err = ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for attempts := 0; attempts < ds.RetryAttempts; attempts++ {
0000000000000000000000000000000000000000;;			if len(b) > 0 {
0000000000000000000000000000000000000000;;				req.Body = ioutil.NopCloser(bytes.NewBuffer(b))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp, err = c.HTTPClient.Do(req)
0000000000000000000000000000000000000000;;			if err != nil || !autorest.ResponseHasStatusCode(resp, ds.ValidStatusCodes...) {
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			autorest.DelayForBackoff(ds.RetryDuration, attempts, req.Cancel)
0000000000000000000000000000000000000000;;			ds.attempts = attempts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds.attempts++
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client is the object that needs to be constructed to perform
0000000000000000000000000000000000000000;;	// operations on the storage account.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		// HTTPClient is the http.Client used to initiate API
0000000000000000000000000000000000000000;;		// requests. http.DefaultClient is used when creating a
0000000000000000000000000000000000000000;;		// client.
0000000000000000000000000000000000000000;;		HTTPClient *http.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sender is an interface that sends the request. Clients are
0000000000000000000000000000000000000000;;		// created with a DefaultSender. The DefaultSender has an
0000000000000000000000000000000000000000;;		// automatic retry strategy built in. The Sender can be customized.
0000000000000000000000000000000000000000;;		Sender Sender
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		accountName      string
0000000000000000000000000000000000000000;;		accountKey       []byte
0000000000000000000000000000000000000000;;		useHTTPS         bool
0000000000000000000000000000000000000000;;		UseSharedKeyLite bool
0000000000000000000000000000000000000000;;		baseURL          string
0000000000000000000000000000000000000000;;		apiVersion       string
0000000000000000000000000000000000000000;;		userAgent        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageResponse struct {
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;		headers    http.Header
0000000000000000000000000000000000000000;;		body       io.ReadCloser
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type odataResponse struct {
0000000000000000000000000000000000000000;;		storageResponse
0000000000000000000000000000000000000000;;		odata odataErrorWrapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AzureStorageServiceError contains fields of the error response from
0000000000000000000000000000000000000000;;	// Azure Storage Service REST API. See https://msdn.microsoft.com/en-us/library/azure/dd179382.aspx
0000000000000000000000000000000000000000;;	// Some fields might be specific to certain calls.
0000000000000000000000000000000000000000;;	type AzureStorageServiceError struct {
0000000000000000000000000000000000000000;;		Code                      string `xml:"Code"`
0000000000000000000000000000000000000000;;		Message                   string `xml:"Message"`
0000000000000000000000000000000000000000;;		AuthenticationErrorDetail string `xml:"AuthenticationErrorDetail"`
0000000000000000000000000000000000000000;;		QueryParameterName        string `xml:"QueryParameterName"`
0000000000000000000000000000000000000000;;		QueryParameterValue       string `xml:"QueryParameterValue"`
0000000000000000000000000000000000000000;;		Reason                    string `xml:"Reason"`
0000000000000000000000000000000000000000;;		Lang                      string
0000000000000000000000000000000000000000;;		StatusCode                int
0000000000000000000000000000000000000000;;		RequestID                 string
0000000000000000000000000000000000000000;;		Date                      string
0000000000000000000000000000000000000000;;		APIVersion                string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type odataErrorMessage struct {
0000000000000000000000000000000000000000;;		Lang  string `json:"lang"`
0000000000000000000000000000000000000000;;		Value string `json:"value"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type odataError struct {
0000000000000000000000000000000000000000;;		Code    string            `json:"code"`
0000000000000000000000000000000000000000;;		Message odataErrorMessage `json:"message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type odataErrorWrapper struct {
0000000000000000000000000000000000000000;;		Err odataError `json:"odata.error"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnexpectedStatusCodeError is returned when a storage service responds with neither an error
0000000000000000000000000000000000000000;;	// nor with an HTTP status code indicating success.
0000000000000000000000000000000000000000;;	type UnexpectedStatusCodeError struct {
0000000000000000000000000000000000000000;;		allowed []int
0000000000000000000000000000000000000000;;		got     int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e UnexpectedStatusCodeError) Error() string {
0000000000000000000000000000000000000000;;		s := func(i int) string { return fmt.Sprintf("%d %s", i, http.StatusText(i)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got := s(e.got)
0000000000000000000000000000000000000000;;		expected := []string{}
0000000000000000000000000000000000000000;;		for _, v := range e.allowed {
0000000000000000000000000000000000000000;;			expected = append(expected, s(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("storage: status code from service response is %s; was expecting %s", got, strings.Join(expected, " or "))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Got is the actual status code returned by Azure.
0000000000000000000000000000000000000000;;	func (e UnexpectedStatusCodeError) Got() int {
0000000000000000000000000000000000000000;;		return e.got
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBasicClient constructs a Client with given storage service name and
0000000000000000000000000000000000000000;;	// key.
0000000000000000000000000000000000000000;;	func NewBasicClient(accountName, accountKey string) (Client, error) {
0000000000000000000000000000000000000000;;		if accountName == StorageEmulatorAccountName {
0000000000000000000000000000000000000000;;			return NewEmulatorClient()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewClient(accountName, accountKey, DefaultBaseURL, DefaultAPIVersion, defaultUseHTTPS)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBasicClientOnSovereignCloud constructs a Client with given storage service name and
0000000000000000000000000000000000000000;;	// key in the referenced cloud.
0000000000000000000000000000000000000000;;	func NewBasicClientOnSovereignCloud(accountName, accountKey string, env azure.Environment) (Client, error) {
0000000000000000000000000000000000000000;;		if accountName == StorageEmulatorAccountName {
0000000000000000000000000000000000000000;;			return NewEmulatorClient()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewClient(accountName, accountKey, env.StorageEndpointSuffix, DefaultAPIVersion, defaultUseHTTPS)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//NewEmulatorClient contructs a Client intended to only work with Azure
0000000000000000000000000000000000000000;;	//Storage Emulator
0000000000000000000000000000000000000000;;	func NewEmulatorClient() (Client, error) {
0000000000000000000000000000000000000000;;		return NewClient(StorageEmulatorAccountName, StorageEmulatorAccountKey, DefaultBaseURL, DefaultAPIVersion, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient constructs a Client. This should be used if the caller wants
0000000000000000000000000000000000000000;;	// to specify whether to use HTTPS, a specific REST API version or a custom
0000000000000000000000000000000000000000;;	// storage endpoint than Azure Public Cloud.
0000000000000000000000000000000000000000;;	func NewClient(accountName, accountKey, blobServiceBaseURL, apiVersion string, useHTTPS bool) (Client, error) {
0000000000000000000000000000000000000000;;		var c Client
0000000000000000000000000000000000000000;;		if !IsValidStorageAccount(accountName) {
0000000000000000000000000000000000000000;;			return c, fmt.Errorf("azure: account name is not valid: it must be between 3 and 24 characters, and only may contain numbers and lowercase letters: %v", accountName)
0000000000000000000000000000000000000000;;		} else if accountKey == "" {
0000000000000000000000000000000000000000;;			return c, fmt.Errorf("azure: account key required")
0000000000000000000000000000000000000000;;		} else if blobServiceBaseURL == "" {
0000000000000000000000000000000000000000;;			return c, fmt.Errorf("azure: base storage service url required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, err := base64.StdEncoding.DecodeString(accountKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return c, fmt.Errorf("azure: malformed storage account key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c = Client{
0000000000000000000000000000000000000000;;			HTTPClient:       http.DefaultClient,
0000000000000000000000000000000000000000;;			accountName:      accountName,
0000000000000000000000000000000000000000;;			accountKey:       key,
0000000000000000000000000000000000000000;;			useHTTPS:         useHTTPS,
0000000000000000000000000000000000000000;;			baseURL:          blobServiceBaseURL,
0000000000000000000000000000000000000000;;			apiVersion:       apiVersion,
0000000000000000000000000000000000000000;;			UseSharedKeyLite: false,
0000000000000000000000000000000000000000;;			Sender: &DefaultSender{
0000000000000000000000000000000000000000;;				RetryAttempts: 5,
0000000000000000000000000000000000000000;;				ValidStatusCodes: []int{
0000000000000000000000000000000000000000;;					http.StatusRequestTimeout,      // 408
0000000000000000000000000000000000000000;;					http.StatusInternalServerError, // 500
0000000000000000000000000000000000000000;;					http.StatusBadGateway,          // 502
0000000000000000000000000000000000000000;;					http.StatusServiceUnavailable,  // 503
0000000000000000000000000000000000000000;;					http.StatusGatewayTimeout,      // 504
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				RetryDuration: time.Second * 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.userAgent = c.getDefaultUserAgent()
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidStorageAccount checks if the storage account name is valid.
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/azure/storage/storage-create-storage-account
0000000000000000000000000000000000000000;;	func IsValidStorageAccount(account string) bool {
0000000000000000000000000000000000000000;;		return validStorageAccount.MatchString(account)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) getDefaultUserAgent() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Go/%s (%s-%s) azure-storage-go/%s api-version/%s",
0000000000000000000000000000000000000000;;			runtime.Version(),
0000000000000000000000000000000000000000;;			runtime.GOARCH,
0000000000000000000000000000000000000000;;			runtime.GOOS,
0000000000000000000000000000000000000000;;			sdkVersion,
0000000000000000000000000000000000000000;;			c.apiVersion,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddToUserAgent adds an extension to the current user agent
0000000000000000000000000000000000000000;;	func (c *Client) AddToUserAgent(extension string) error {
0000000000000000000000000000000000000000;;		if extension != "" {
0000000000000000000000000000000000000000;;			c.userAgent = fmt.Sprintf("%s %s", c.userAgent, extension)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Extension was empty, User Agent stayed as %s", c.userAgent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// protectUserAgent is used in funcs that include extraheaders as a parameter.
0000000000000000000000000000000000000000;;	// It prevents the User-Agent header to be overwritten, instead if it happens to
0000000000000000000000000000000000000000;;	// be present, it gets added to the current User-Agent. Use it before getStandardHeaders
0000000000000000000000000000000000000000;;	func (c *Client) protectUserAgent(extraheaders map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		if v, ok := extraheaders[userAgentHeader]; ok {
0000000000000000000000000000000000000000;;			c.AddToUserAgent(v)
0000000000000000000000000000000000000000;;			delete(extraheaders, userAgentHeader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return extraheaders
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) getBaseURL(service string) *url.URL {
0000000000000000000000000000000000000000;;		scheme := "http"
0000000000000000000000000000000000000000;;		if c.useHTTPS {
0000000000000000000000000000000000000000;;			scheme = "https"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		host := ""
0000000000000000000000000000000000000000;;		if c.accountName == StorageEmulatorAccountName {
0000000000000000000000000000000000000000;;			switch service {
0000000000000000000000000000000000000000;;			case blobServiceName:
0000000000000000000000000000000000000000;;				host = storageEmulatorBlob
0000000000000000000000000000000000000000;;			case tableServiceName:
0000000000000000000000000000000000000000;;				host = storageEmulatorTable
0000000000000000000000000000000000000000;;			case queueServiceName:
0000000000000000000000000000000000000000;;				host = storageEmulatorQueue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			host = fmt.Sprintf("%s.%s.%s", c.accountName, service, c.baseURL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &url.URL{
0000000000000000000000000000000000000000;;			Scheme: scheme,
0000000000000000000000000000000000000000;;			Host:   host,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) getEndpoint(service, path string, params url.Values) string {
0000000000000000000000000000000000000000;;		u := c.getBaseURL(service)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// API doesn't accept path segments not starting with '/'
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(path, "/") {
0000000000000000000000000000000000000000;;			path = fmt.Sprintf("/%v", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.accountName == StorageEmulatorAccountName {
0000000000000000000000000000000000000000;;			path = fmt.Sprintf("/%v%v", StorageEmulatorAccountName, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.Path = path
0000000000000000000000000000000000000000;;		u.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;		return u.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBlobService returns a BlobStorageClient which can operate on the blob
0000000000000000000000000000000000000000;;	// service of the storage account.
0000000000000000000000000000000000000000;;	func (c Client) GetBlobService() BlobStorageClient {
0000000000000000000000000000000000000000;;		b := BlobStorageClient{
0000000000000000000000000000000000000000;;			client: c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.client.AddToUserAgent(blobServiceName)
0000000000000000000000000000000000000000;;		b.auth = sharedKey
0000000000000000000000000000000000000000;;		if c.UseSharedKeyLite {
0000000000000000000000000000000000000000;;			b.auth = sharedKeyLite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetQueueService returns a QueueServiceClient which can operate on the queue
0000000000000000000000000000000000000000;;	// service of the storage account.
0000000000000000000000000000000000000000;;	func (c Client) GetQueueService() QueueServiceClient {
0000000000000000000000000000000000000000;;		q := QueueServiceClient{
0000000000000000000000000000000000000000;;			client: c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.client.AddToUserAgent(queueServiceName)
0000000000000000000000000000000000000000;;		q.auth = sharedKey
0000000000000000000000000000000000000000;;		if c.UseSharedKeyLite {
0000000000000000000000000000000000000000;;			q.auth = sharedKeyLite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTableService returns a TableServiceClient which can operate on the table
0000000000000000000000000000000000000000;;	// service of the storage account.
0000000000000000000000000000000000000000;;	func (c Client) GetTableService() TableServiceClient {
0000000000000000000000000000000000000000;;		t := TableServiceClient{
0000000000000000000000000000000000000000;;			client: c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.client.AddToUserAgent(tableServiceName)
0000000000000000000000000000000000000000;;		t.auth = sharedKeyForTable
0000000000000000000000000000000000000000;;		if c.UseSharedKeyLite {
0000000000000000000000000000000000000000;;			t.auth = sharedKeyLiteForTable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFileService returns a FileServiceClient which can operate on the file
0000000000000000000000000000000000000000;;	// service of the storage account.
0000000000000000000000000000000000000000;;	func (c Client) GetFileService() FileServiceClient {
0000000000000000000000000000000000000000;;		f := FileServiceClient{
0000000000000000000000000000000000000000;;			client: c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.client.AddToUserAgent(fileServiceName)
0000000000000000000000000000000000000000;;		f.auth = sharedKey
0000000000000000000000000000000000000000;;		if c.UseSharedKeyLite {
0000000000000000000000000000000000000000;;			f.auth = sharedKeyLite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) getStandardHeaders() map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{
0000000000000000000000000000000000000000;;			userAgentHeader: c.userAgent,
0000000000000000000000000000000000000000;;			"x-ms-version":  c.apiVersion,
0000000000000000000000000000000000000000;;			"x-ms-date":     currentTimeRfc1123Formatted(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) exec(verb, url string, headers map[string]string, body io.Reader, auth authentication) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		headers, err := c.addAuthorizationHeader(verb, url, headers, auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(verb, url, body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("azure/storage: error creating request: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range headers {
0000000000000000000000000000000000000000;;			req.Header.Add(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.Sender.Send(&c, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 400 && resp.StatusCode <= 505 {
0000000000000000000000000000000000000000;;			var respBody []byte
0000000000000000000000000000000000000000;;			respBody, err = readAndCloseBody(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestID, date, version := getDebugHeaders(resp.Header)
0000000000000000000000000000000000000000;;			if len(respBody) == 0 {
0000000000000000000000000000000000000000;;				// no error in response body, might happen in HEAD requests
0000000000000000000000000000000000000000;;				err = serviceErrFromStatusCode(resp.StatusCode, resp.Status, requestID, date, version)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				storageErr := AzureStorageServiceError{
0000000000000000000000000000000000000000;;					StatusCode: resp.StatusCode,
0000000000000000000000000000000000000000;;					RequestID:  requestID,
0000000000000000000000000000000000000000;;					Date:       date,
0000000000000000000000000000000000000000;;					APIVersion: version,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// response contains storage service error object, unmarshal
0000000000000000000000000000000000000000;;				if resp.Header.Get("Content-Type") == "application/xml" {
0000000000000000000000000000000000000000;;					errIn := serviceErrFromXML(respBody, &storageErr)
0000000000000000000000000000000000000000;;					if err != nil { // error unmarshaling the error response
0000000000000000000000000000000000000000;;						err = errIn
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errIn := serviceErrFromJSON(respBody, &storageErr)
0000000000000000000000000000000000000000;;					if err != nil { // error unmarshaling the error response
0000000000000000000000000000000000000000;;						err = errIn
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = storageErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &storageResponse{
0000000000000000000000000000000000000000;;				statusCode: resp.StatusCode,
0000000000000000000000000000000000000000;;				headers:    resp.Header,
0000000000000000000000000000000000000000;;				body:       ioutil.NopCloser(bytes.NewReader(respBody)), /* restore the body */
0000000000000000000000000000000000000000;;			}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &storageResponse{
0000000000000000000000000000000000000000;;			statusCode: resp.StatusCode,
0000000000000000000000000000000000000000;;			headers:    resp.Header,
0000000000000000000000000000000000000000;;			body:       resp.Body}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) execInternalJSONCommon(verb, url string, headers map[string]string, body io.Reader, auth authentication) (*odataResponse, *http.Request, *http.Response, error) {
0000000000000000000000000000000000000000;;		headers, err := c.addAuthorizationHeader(verb, url, headers, auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(verb, url, body)
0000000000000000000000000000000000000000;;		for k, v := range headers {
0000000000000000000000000000000000000000;;			req.Header.Add(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.Sender.Send(&c, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		respToRet := &odataResponse{}
0000000000000000000000000000000000000000;;		respToRet.body = resp.Body
0000000000000000000000000000000000000000;;		respToRet.statusCode = resp.StatusCode
0000000000000000000000000000000000000000;;		respToRet.headers = resp.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		statusCode := resp.StatusCode
0000000000000000000000000000000000000000;;		if statusCode >= 400 && statusCode <= 505 {
0000000000000000000000000000000000000000;;			var respBody []byte
0000000000000000000000000000000000000000;;			respBody, err = readAndCloseBody(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestID, date, version := getDebugHeaders(resp.Header)
0000000000000000000000000000000000000000;;			if len(respBody) == 0 {
0000000000000000000000000000000000000000;;				// no error in response body, might happen in HEAD requests
0000000000000000000000000000000000000000;;				err = serviceErrFromStatusCode(resp.StatusCode, resp.Status, requestID, date, version)
0000000000000000000000000000000000000000;;				return respToRet, req, resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// try unmarshal as odata.error json
0000000000000000000000000000000000000000;;			err = json.Unmarshal(respBody, &respToRet.odata)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return respToRet, req, resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) execInternalJSON(verb, url string, headers map[string]string, body io.Reader, auth authentication) (*odataResponse, error) {
0000000000000000000000000000000000000000;;		respToRet, _, _, err := c.execInternalJSONCommon(verb, url, headers, body, auth)
0000000000000000000000000000000000000000;;		return respToRet, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) execBatchOperationJSON(verb, url string, headers map[string]string, body io.Reader, auth authentication) (*odataResponse, error) {
0000000000000000000000000000000000000000;;		// execute common query, get back generated request, response etc... for more processing.
0000000000000000000000000000000000000000;;		respToRet, req, resp, err := c.execInternalJSONCommon(verb, url, headers, body, auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return the OData in the case of executing batch commands.
0000000000000000000000000000000000000000;;		// In this case we need to read the outer batch boundary and contents.
0000000000000000000000000000000000000000;;		// Then we read the changeset information within the batch
0000000000000000000000000000000000000000;;		var respBody []byte
0000000000000000000000000000000000000000;;		respBody, err = readAndCloseBody(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// outer multipart body
0000000000000000000000000000000000000000;;		_, batchHeader, err := mime.ParseMediaType(resp.Header["Content-Type"][0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// batch details.
0000000000000000000000000000000000000000;;		batchBoundary := batchHeader["boundary"]
0000000000000000000000000000000000000000;;		batchPartBuf, changesetBoundary, err := genBatchReader(batchBoundary, respBody)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// changeset details.
0000000000000000000000000000000000000000;;		err = genChangesetReader(req, respToRet, batchPartBuf, changesetBoundary)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return respToRet, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genChangesetReader(req *http.Request, respToRet *odataResponse, batchPartBuf io.Reader, changesetBoundary string) error {
0000000000000000000000000000000000000000;;		changesetMultiReader := multipart.NewReader(batchPartBuf, changesetBoundary)
0000000000000000000000000000000000000000;;		changesetPart, err := changesetMultiReader.NextPart()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changesetPartBufioReader := bufio.NewReader(changesetPart)
0000000000000000000000000000000000000000;;		changesetResp, err := http.ReadResponse(changesetPartBufioReader, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if changesetResp.StatusCode != http.StatusNoContent {
0000000000000000000000000000000000000000;;			changesetBody, err := readAndCloseBody(changesetResp.Body)
0000000000000000000000000000000000000000;;			err = json.Unmarshal(changesetBody, &respToRet.odata)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			respToRet.statusCode = changesetResp.StatusCode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genBatchReader(batchBoundary string, respBody []byte) (io.Reader, string, error) {
0000000000000000000000000000000000000000;;		respBodyString := string(respBody)
0000000000000000000000000000000000000000;;		respBodyReader := strings.NewReader(respBodyString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reading batchresponse
0000000000000000000000000000000000000000;;		batchMultiReader := multipart.NewReader(respBodyReader, batchBoundary)
0000000000000000000000000000000000000000;;		batchPart, err := batchMultiReader.NextPart()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		batchPartBufioReader := bufio.NewReader(batchPart)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, changesetHeader, err := mime.ParseMediaType(batchPart.Header.Get("Content-Type"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		changesetBoundary := changesetHeader["boundary"]
0000000000000000000000000000000000000000;;		return batchPartBufioReader, changesetBoundary, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readAndCloseBody(body io.ReadCloser) ([]byte, error) {
0000000000000000000000000000000000000000;;		defer body.Close()
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadAll(body)
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceErrFromXML(body []byte, storageErr *AzureStorageServiceError) error {
0000000000000000000000000000000000000000;;		if err := xml.Unmarshal(body, storageErr); err != nil {
0000000000000000000000000000000000000000;;			storageErr.Message = fmt.Sprintf("Response body could no be unmarshaled: %v. Body: %v.", err, string(body))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceErrFromJSON(body []byte, storageErr *AzureStorageServiceError) error {
0000000000000000000000000000000000000000;;		odataError := odataErrorWrapper{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(body, &odataError); err != nil {
0000000000000000000000000000000000000000;;			storageErr.Message = fmt.Sprintf("Response body could no be unmarshaled: %v. Body: %v.", err, string(body))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		storageErr.Code = odataError.Err.Code
0000000000000000000000000000000000000000;;		storageErr.Message = odataError.Err.Message.Value
0000000000000000000000000000000000000000;;		storageErr.Lang = odataError.Err.Message.Lang
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceErrFromStatusCode(code int, status string, requestID, date, version string) AzureStorageServiceError {
0000000000000000000000000000000000000000;;		return AzureStorageServiceError{
0000000000000000000000000000000000000000;;			StatusCode: code,
0000000000000000000000000000000000000000;;			Code:       status,
0000000000000000000000000000000000000000;;			RequestID:  requestID,
0000000000000000000000000000000000000000;;			Date:       date,
0000000000000000000000000000000000000000;;			APIVersion: version,
0000000000000000000000000000000000000000;;			Message:    "no response body was available for error status code",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e AzureStorageServiceError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("storage: service returned error: StatusCode=%d, ErrorCode=%s, ErrorMessage=%s, RequestInitiated=%s, RequestId=%s, API Version=%s, QueryParameterName=%s, QueryParameterValue=%s",
0000000000000000000000000000000000000000;;			e.StatusCode, e.Code, e.Message, e.Date, e.RequestID, e.APIVersion, e.QueryParameterName, e.QueryParameterValue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkRespCode returns UnexpectedStatusError if the given response code is not
0000000000000000000000000000000000000000;;	// one of the allowed status codes; otherwise nil.
0000000000000000000000000000000000000000;;	func checkRespCode(respCode int, allowed []int) error {
0000000000000000000000000000000000000000;;		for _, v := range allowed {
0000000000000000000000000000000000000000;;			if respCode == v {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return UnexpectedStatusCodeError{allowed, respCode}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Client) addMetadataToHeaders(h map[string]string, metadata map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		metadata = c.protectUserAgent(metadata)
0000000000000000000000000000000000000000;;		for k, v := range metadata {
0000000000000000000000000000000000000000;;			h[userDefinedMetadataHeaderPrefix+k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDebugHeaders(h http.Header) (requestID, date, version string) {
0000000000000000000000000000000000000000;;		requestID = h.Get("x-ms-request-id")
0000000000000000000000000000000000000000;;		version = h.Get("x-ms-version")
0000000000000000000000000000000000000000;;		date = h.Get("Date")
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
