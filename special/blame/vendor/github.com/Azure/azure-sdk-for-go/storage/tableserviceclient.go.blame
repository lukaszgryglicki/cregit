0000000000000000000000000000000000000000;;	package storage
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		headerAccept          = "Accept"
0000000000000000000000000000000000000000;;		headerEtag            = "Etag"
0000000000000000000000000000000000000000;;		headerPrefer          = "Prefer"
0000000000000000000000000000000000000000;;		headerXmsContinuation = "x-ms-Continuation-NextTableName"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TableServiceClient contains operations for Microsoft Azure Table Storage
0000000000000000000000000000000000000000;;	// Service.
0000000000000000000000000000000000000000;;	type TableServiceClient struct {
0000000000000000000000000000000000000000;;		client Client
0000000000000000000000000000000000000000;;		auth   authentication
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TableOptions includes options for some table operations
0000000000000000000000000000000000000000;;	type TableOptions struct {
0000000000000000000000000000000000000000;;		RequestID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *TableOptions) addToHeaders(h map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			h = addToHeaders(h, "x-ms-client-request-id", options.RequestID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryNextLink includes information for getting the next page of
0000000000000000000000000000000000000000;;	// results in query operations
0000000000000000000000000000000000000000;;	type QueryNextLink struct {
0000000000000000000000000000000000000000;;		NextLink *string
0000000000000000000000000000000000000000;;		ml       MetadataLevel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetServiceProperties gets the properties of your storage account's table service.
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-table-service-properties
0000000000000000000000000000000000000000;;	func (t *TableServiceClient) GetServiceProperties() (*ServiceProperties, error) {
0000000000000000000000000000000000000000;;		return t.client.getServiceProperties(tableServiceName, t.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetServiceProperties sets the properties of your storage account's table service.
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/set-table-service-properties
0000000000000000000000000000000000000000;;	func (t *TableServiceClient) SetServiceProperties(props ServiceProperties) error {
0000000000000000000000000000000000000000;;		return t.client.setServiceProperties(props, tableServiceName, t.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTableReference returns a Table object for the specified table name.
0000000000000000000000000000000000000000;;	func (t *TableServiceClient) GetTableReference(name string) *Table {
0000000000000000000000000000000000000000;;		return &Table{
0000000000000000000000000000000000000000;;			tsc:  t,
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryTablesOptions includes options for some table operations
0000000000000000000000000000000000000000;;	type QueryTablesOptions struct {
0000000000000000000000000000000000000000;;		Top       uint
0000000000000000000000000000000000000000;;		Filter    string
0000000000000000000000000000000000000000;;		RequestID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *QueryTablesOptions) getParameters() (url.Values, map[string]string) {
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		headers := map[string]string{}
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			if options.Top > 0 {
0000000000000000000000000000000000000000;;				query.Add(OdataTop, strconv.FormatUint(uint64(options.Top), 10))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.Filter != "" {
0000000000000000000000000000000000000000;;				query.Add(OdataFilter, options.Filter)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			headers = addToHeaders(headers, "x-ms-client-request-id", options.RequestID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return query, headers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryTables returns the tables in the storage account.
0000000000000000000000000000000000000000;;	// You can use query options defined by the OData Protocol specification.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/query-tables
0000000000000000000000000000000000000000;;	func (t *TableServiceClient) QueryTables(ml MetadataLevel, options *QueryTablesOptions) (*TableQueryResult, error) {
0000000000000000000000000000000000000000;;		query, headers := options.getParameters()
0000000000000000000000000000000000000000;;		uri := t.client.getEndpoint(tableServiceName, tablesURIPath, query)
0000000000000000000000000000000000000000;;		return t.queryTables(uri, headers, ml)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextResults returns the next page of results
0000000000000000000000000000000000000000;;	// from a QueryTables or a NextResults operation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/rest/api/storageservices/fileservices/query-tables
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/rest/api/storageservices/fileservices/query-timeout-and-pagination
0000000000000000000000000000000000000000;;	func (tqr *TableQueryResult) NextResults(options *TableOptions) (*TableQueryResult, error) {
0000000000000000000000000000000000000000;;		if tqr == nil {
0000000000000000000000000000000000000000;;			return nil, errNilPreviousResult
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tqr.NextLink == nil {
0000000000000000000000000000000000000000;;			return nil, errNilNextLink
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := options.addToHeaders(map[string]string{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tqr.tsc.queryTables(*tqr.NextLink, headers, tqr.ml)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TableQueryResult contains the response from
0000000000000000000000000000000000000000;;	// QueryTables and QueryTablesNextResults functions.
0000000000000000000000000000000000000000;;	type TableQueryResult struct {
0000000000000000000000000000000000000000;;		OdataMetadata string  `json:"odata.metadata"`
0000000000000000000000000000000000000000;;		Tables        []Table `json:"value"`
0000000000000000000000000000000000000000;;		QueryNextLink
0000000000000000000000000000000000000000;;		tsc *TableServiceClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TableServiceClient) queryTables(uri string, headers map[string]string, ml MetadataLevel) (*TableQueryResult, error) {
0000000000000000000000000000000000000000;;		if ml == EmptyPayload {
0000000000000000000000000000000000000000;;			return nil, errEmptyPayload
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers = mergeHeaders(headers, t.client.getStandardHeaders())
0000000000000000000000000000000000000000;;		headers[headerAccept] = string(ml)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := t.client.exec(http.MethodGet, uri, headers, nil, t.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		respBody, err := ioutil.ReadAll(resp.body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var out TableQueryResult
0000000000000000000000000000000000000000;;		err = json.Unmarshal(respBody, &out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range out.Tables {
0000000000000000000000000000000000000000;;			out.Tables[i].tsc = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.tsc = t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nextLink := resp.headers.Get(http.CanonicalHeaderKey(headerXmsContinuation))
0000000000000000000000000000000000000000;;		if nextLink == "" {
0000000000000000000000000000000000000000;;			out.NextLink = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			originalURI, err := url.Parse(uri)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v := originalURI.Query()
0000000000000000000000000000000000000000;;			v.Set(nextTableQueryParameter, nextLink)
0000000000000000000000000000000000000000;;			newURI := t.client.getEndpoint(tableServiceName, tablesURIPath, v)
0000000000000000000000000000000000000000;;			out.NextLink = &newURI
0000000000000000000000000000000000000000;;			out.ml = ml
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addBodyRelatedHeaders(h map[string]string, length int) map[string]string {
0000000000000000000000000000000000000000;;		h[headerContentType] = "application/json"
0000000000000000000000000000000000000000;;		h[headerContentLength] = fmt.Sprintf("%v", length)
0000000000000000000000000000000000000000;;		h[headerAcceptCharset] = "UTF-8"
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addReturnContentHeaders(h map[string]string, ml MetadataLevel) map[string]string {
0000000000000000000000000000000000000000;;		if ml != EmptyPayload {
0000000000000000000000000000000000000000;;			h[headerPrefer] = "return-content"
0000000000000000000000000000000000000000;;			h[headerAccept] = string(ml)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			h[headerPrefer] = "return-no-content"
0000000000000000000000000000000000000000;;			// From API version 2015-12-11 onwards, Accept header is required
0000000000000000000000000000000000000000;;			h[headerAccept] = string(NoMetadata)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
