0000000000000000000000000000000000000000;;	package storage
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container represents an Azure container.
0000000000000000000000000000000000000000;;	type Container struct {
0000000000000000000000000000000000000000;;		bsc        *BlobStorageClient
0000000000000000000000000000000000000000;;		Name       string              `xml:"Name"`
0000000000000000000000000000000000000000;;		Properties ContainerProperties `xml:"Properties"`
0000000000000000000000000000000000000000;;		Metadata   map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Container) buildPath() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/%s", c.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerProperties contains various properties of a container returned from
0000000000000000000000000000000000000000;;	// various endpoints like ListContainers.
0000000000000000000000000000000000000000;;	type ContainerProperties struct {
0000000000000000000000000000000000000000;;		LastModified  string `xml:"Last-Modified"`
0000000000000000000000000000000000000000;;		Etag          string `xml:"Etag"`
0000000000000000000000000000000000000000;;		LeaseStatus   string `xml:"LeaseStatus"`
0000000000000000000000000000000000000000;;		LeaseState    string `xml:"LeaseState"`
0000000000000000000000000000000000000000;;		LeaseDuration string `xml:"LeaseDuration"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerListResponse contains the response fields from
0000000000000000000000000000000000000000;;	// ListContainers call.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd179352.aspx
0000000000000000000000000000000000000000;;	type ContainerListResponse struct {
0000000000000000000000000000000000000000;;		XMLName    xml.Name    `xml:"EnumerationResults"`
0000000000000000000000000000000000000000;;		Xmlns      string      `xml:"xmlns,attr"`
0000000000000000000000000000000000000000;;		Prefix     string      `xml:"Prefix"`
0000000000000000000000000000000000000000;;		Marker     string      `xml:"Marker"`
0000000000000000000000000000000000000000;;		NextMarker string      `xml:"NextMarker"`
0000000000000000000000000000000000000000;;		MaxResults int64       `xml:"MaxResults"`
0000000000000000000000000000000000000000;;		Containers []Container `xml:"Containers>Container"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlobListResponse contains the response fields from ListBlobs call.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd135734.aspx
0000000000000000000000000000000000000000;;	type BlobListResponse struct {
0000000000000000000000000000000000000000;;		XMLName    xml.Name `xml:"EnumerationResults"`
0000000000000000000000000000000000000000;;		Xmlns      string   `xml:"xmlns,attr"`
0000000000000000000000000000000000000000;;		Prefix     string   `xml:"Prefix"`
0000000000000000000000000000000000000000;;		Marker     string   `xml:"Marker"`
0000000000000000000000000000000000000000;;		NextMarker string   `xml:"NextMarker"`
0000000000000000000000000000000000000000;;		MaxResults int64    `xml:"MaxResults"`
0000000000000000000000000000000000000000;;		Blobs      []Blob   `xml:"Blobs>Blob"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BlobPrefix is used to traverse blobs as if it were a file system.
0000000000000000000000000000000000000000;;		// It is returned if ListBlobsParameters.Delimiter is specified.
0000000000000000000000000000000000000000;;		// The list here can be thought of as "folders" that may contain
0000000000000000000000000000000000000000;;		// other folders or blobs.
0000000000000000000000000000000000000000;;		BlobPrefixes []string `xml:"Blobs>BlobPrefix>Name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delimiter is used to traverse blobs as if it were a file system.
0000000000000000000000000000000000000000;;		// It is returned if ListBlobsParameters.Delimiter is specified.
0000000000000000000000000000000000000000;;		Delimiter string `xml:"Delimiter"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IncludeBlobDataset has options to include in a list blobs operation
0000000000000000000000000000000000000000;;	type IncludeBlobDataset struct {
0000000000000000000000000000000000000000;;		Snapshots        bool
0000000000000000000000000000000000000000;;		Metadata         bool
0000000000000000000000000000000000000000;;		UncommittedBlobs bool
0000000000000000000000000000000000000000;;		Copy             bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListBlobsParameters defines the set of customizable
0000000000000000000000000000000000000000;;	// parameters to make a List Blobs call.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd135734.aspx
0000000000000000000000000000000000000000;;	type ListBlobsParameters struct {
0000000000000000000000000000000000000000;;		Prefix     string
0000000000000000000000000000000000000000;;		Delimiter  string
0000000000000000000000000000000000000000;;		Marker     string
0000000000000000000000000000000000000000;;		Include    *IncludeBlobDataset
0000000000000000000000000000000000000000;;		MaxResults uint
0000000000000000000000000000000000000000;;		Timeout    uint
0000000000000000000000000000000000000000;;		RequestID  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p ListBlobsParameters) getParameters() url.Values {
0000000000000000000000000000000000000000;;		out := url.Values{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Prefix != "" {
0000000000000000000000000000000000000000;;			out.Set("prefix", p.Prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Delimiter != "" {
0000000000000000000000000000000000000000;;			out.Set("delimiter", p.Delimiter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Marker != "" {
0000000000000000000000000000000000000000;;			out.Set("marker", p.Marker)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Include != nil {
0000000000000000000000000000000000000000;;			include := []string{}
0000000000000000000000000000000000000000;;			include = addString(include, p.Include.Snapshots, "snapshots")
0000000000000000000000000000000000000000;;			include = addString(include, p.Include.Metadata, "metadata")
0000000000000000000000000000000000000000;;			include = addString(include, p.Include.UncommittedBlobs, "uncommittedblobs")
0000000000000000000000000000000000000000;;			include = addString(include, p.Include.Copy, "copy")
0000000000000000000000000000000000000000;;			fullInclude := strings.Join(include, ",")
0000000000000000000000000000000000000000;;			out.Set("include", fullInclude)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.MaxResults != 0 {
0000000000000000000000000000000000000000;;			out.Set("maxresults", strconv.FormatUint(uint64(p.MaxResults), 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Timeout != 0 {
0000000000000000000000000000000000000000;;			out.Set("timeout", strconv.FormatUint(uint64(p.Timeout), 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addString(datasets []string, include bool, text string) []string {
0000000000000000000000000000000000000000;;		if include {
0000000000000000000000000000000000000000;;			datasets = append(datasets, text)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return datasets
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerAccessType defines the access level to the container from a public
0000000000000000000000000000000000000000;;	// request.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/azure/dd179468.aspx and "x-ms-
0000000000000000000000000000000000000000;;	// blob-public-access" header.
0000000000000000000000000000000000000000;;	type ContainerAccessType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Access options for containers
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ContainerAccessTypePrivate   ContainerAccessType = ""
0000000000000000000000000000000000000000;;		ContainerAccessTypeBlob      ContainerAccessType = "blob"
0000000000000000000000000000000000000000;;		ContainerAccessTypeContainer ContainerAccessType = "container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerAccessPolicy represents each access policy in the container ACL.
0000000000000000000000000000000000000000;;	type ContainerAccessPolicy struct {
0000000000000000000000000000000000000000;;		ID         string
0000000000000000000000000000000000000000;;		StartTime  time.Time
0000000000000000000000000000000000000000;;		ExpiryTime time.Time
0000000000000000000000000000000000000000;;		CanRead    bool
0000000000000000000000000000000000000000;;		CanWrite   bool
0000000000000000000000000000000000000000;;		CanDelete  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerPermissions represents the container ACLs.
0000000000000000000000000000000000000000;;	type ContainerPermissions struct {
0000000000000000000000000000000000000000;;		AccessType     ContainerAccessType
0000000000000000000000000000000000000000;;		AccessPolicies []ContainerAccessPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerAccessHeader references header used when setting/getting container ACL
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ContainerAccessHeader string = "x-ms-blob-public-access"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBlobReference returns a Blob object for the specified blob name.
0000000000000000000000000000000000000000;;	func (c *Container) GetBlobReference(name string) *Blob {
0000000000000000000000000000000000000000;;		return &Blob{
0000000000000000000000000000000000000000;;			Container: c,
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateContainerOptions includes the options for a create container operation
0000000000000000000000000000000000000000;;	type CreateContainerOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		Access    ContainerAccessType `header:"x-ms-blob-public-access"`
0000000000000000000000000000000000000000;;		RequestID string              `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates a blob container within the storage account
0000000000000000000000000000000000000000;;	// with given name and access level. Returns error if container already exists.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Create-Container
0000000000000000000000000000000000000000;;	func (c *Container) Create(options *CreateContainerOptions) error {
0000000000000000000000000000000000000000;;		resp, err := c.create(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusCreated})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateIfNotExists creates a blob container if it does not exist. Returns
0000000000000000000000000000000000000000;;	// true if container is newly created or false if container already exists.
0000000000000000000000000000000000000000;;	func (c *Container) CreateIfNotExists(options *CreateContainerOptions) (bool, error) {
0000000000000000000000000000000000000000;;		resp, err := c.create(options)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusCreated || resp.statusCode == http.StatusConflict {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusCreated, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Container) create(options *CreateContainerOptions) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		query := url.Values{"restype": {"container"}}
0000000000000000000000000000000000000000;;		headers := c.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = c.bsc.client.addMetadataToHeaders(headers, c.Metadata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			query = addTimeout(query, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := c.bsc.client.getEndpoint(blobServiceName, c.buildPath(), query)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.bsc.client.exec(http.MethodPut, uri, headers, nil, c.bsc.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exists returns true if a container with given name exists
0000000000000000000000000000000000000000;;	// on the storage account, otherwise returns false.
0000000000000000000000000000000000000000;;	func (c *Container) Exists() (bool, error) {
0000000000000000000000000000000000000000;;		uri := c.bsc.client.getEndpoint(blobServiceName, c.buildPath(), url.Values{"restype": {"container"}})
0000000000000000000000000000000000000000;;		headers := c.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.bsc.client.exec(http.MethodHead, uri, headers, nil, c.bsc.auth)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusOK || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusOK, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetContainerPermissionOptions includes options for a set container permissions operation
0000000000000000000000000000000000000000;;	type SetContainerPermissionOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPermissions sets up container permissions
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Set-Container-ACL
0000000000000000000000000000000000000000;;	func (c *Container) SetPermissions(permissions ContainerPermissions, options *SetContainerPermissionOptions) error {
0000000000000000000000000000000000000000;;		body, length, err := generateContainerACLpayload(permissions.AccessPolicies)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		params := url.Values{
0000000000000000000000000000000000000000;;			"restype": {"container"},
0000000000000000000000000000000000000000;;			"comp":    {"acl"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := c.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = addToHeaders(headers, ContainerAccessHeader, string(permissions.AccessType))
0000000000000000000000000000000000000000;;		headers["Content-Length"] = strconv.Itoa(length)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := c.bsc.client.getEndpoint(blobServiceName, c.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.bsc.client.exec(http.MethodPut, uri, headers, body, c.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return errors.New("Unable to set permissions")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetContainerPermissionOptions includes options for a get container permissions operation
0000000000000000000000000000000000000000;;	type GetContainerPermissionOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		LeaseID   string `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		RequestID string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPermissions gets the container permissions as per https://msdn.microsoft.com/en-us/library/azure/dd179469.aspx
0000000000000000000000000000000000000000;;	// If timeout is 0 then it will not be passed to Azure
0000000000000000000000000000000000000000;;	// leaseID will only be passed to Azure if populated
0000000000000000000000000000000000000000;;	func (c *Container) GetPermissions(options *GetContainerPermissionOptions) (*ContainerPermissions, error) {
0000000000000000000000000000000000000000;;		params := url.Values{
0000000000000000000000000000000000000000;;			"restype": {"container"},
0000000000000000000000000000000000000000;;			"comp":    {"acl"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := c.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := c.bsc.client.getEndpoint(blobServiceName, c.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.bsc.client.exec(http.MethodGet, uri, headers, nil, c.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ap AccessPolicy
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &ap.SignedIdentifiersList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buildAccessPolicy(ap, &resp.headers), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildAccessPolicy(ap AccessPolicy, headers *http.Header) *ContainerPermissions {
0000000000000000000000000000000000000000;;		// containerAccess. Blob, Container, empty
0000000000000000000000000000000000000000;;		containerAccess := headers.Get(http.CanonicalHeaderKey(ContainerAccessHeader))
0000000000000000000000000000000000000000;;		permissions := ContainerPermissions{
0000000000000000000000000000000000000000;;			AccessType:     ContainerAccessType(containerAccess),
0000000000000000000000000000000000000000;;			AccessPolicies: []ContainerAccessPolicy{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, policy := range ap.SignedIdentifiersList.SignedIdentifiers {
0000000000000000000000000000000000000000;;			capd := ContainerAccessPolicy{
0000000000000000000000000000000000000000;;				ID:         policy.ID,
0000000000000000000000000000000000000000;;				StartTime:  policy.AccessPolicy.StartTime,
0000000000000000000000000000000000000000;;				ExpiryTime: policy.AccessPolicy.ExpiryTime,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			capd.CanRead = updatePermissions(policy.AccessPolicy.Permission, "r")
0000000000000000000000000000000000000000;;			capd.CanWrite = updatePermissions(policy.AccessPolicy.Permission, "w")
0000000000000000000000000000000000000000;;			capd.CanDelete = updatePermissions(policy.AccessPolicy.Permission, "d")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			permissions.AccessPolicies = append(permissions.AccessPolicies, capd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &permissions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteContainerOptions includes options for a delete container operation
0000000000000000000000000000000000000000;;	type DeleteContainerOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		LeaseID           string     `header:"x-ms-lease-id"`
0000000000000000000000000000000000000000;;		IfModifiedSince   *time.Time `header:"If-Modified-Since"`
0000000000000000000000000000000000000000;;		IfUnmodifiedSince *time.Time `header:"If-Unmodified-Since"`
0000000000000000000000000000000000000000;;		RequestID         string     `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes the container with given name on the storage
0000000000000000000000000000000000000000;;	// account. If the container does not exist returns error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/delete-container
0000000000000000000000000000000000000000;;	func (c *Container) Delete(options *DeleteContainerOptions) error {
0000000000000000000000000000000000000000;;		resp, err := c.delete(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusAccepted})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteIfExists deletes the container with given name on the storage
0000000000000000000000000000000000000000;;	// account if it exists. Returns true if container is deleted with this call, or
0000000000000000000000000000000000000000;;	// false if the container did not exist at the time of the Delete Container
0000000000000000000000000000000000000000;;	// operation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/delete-container
0000000000000000000000000000000000000000;;	func (c *Container) DeleteIfExists(options *DeleteContainerOptions) (bool, error) {
0000000000000000000000000000000000000000;;		resp, err := c.delete(options)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusAccepted || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusAccepted, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Container) delete(options *DeleteContainerOptions) (*storageResponse, error) {
0000000000000000000000000000000000000000;;		query := url.Values{"restype": {"container"}}
0000000000000000000000000000000000000000;;		headers := c.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			query = addTimeout(query, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := c.bsc.client.getEndpoint(blobServiceName, c.buildPath(), query)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.bsc.client.exec(http.MethodDelete, uri, headers, nil, c.bsc.auth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListBlobs returns an object that contains list of blobs in the container,
0000000000000000000000000000000000000000;;	// pagination token and other information in the response of List Blobs call.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/List-Blobs
0000000000000000000000000000000000000000;;	func (c *Container) ListBlobs(params ListBlobsParameters) (BlobListResponse, error) {
0000000000000000000000000000000000000000;;		q := mergeParams(params.getParameters(), url.Values{
0000000000000000000000000000000000000000;;			"restype": {"container"},
0000000000000000000000000000000000000000;;			"comp":    {"list"}},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		uri := c.bsc.client.getEndpoint(blobServiceName, c.buildPath(), q)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := c.bsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = addToHeaders(headers, "x-ms-client-request-id", params.RequestID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out BlobListResponse
0000000000000000000000000000000000000000;;		resp, err := c.bsc.client.exec(http.MethodGet, uri, headers, nil, c.bsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return out, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &out)
0000000000000000000000000000000000000000;;		for i := range out.Blobs {
0000000000000000000000000000000000000000;;			out.Blobs[i].Container = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateContainerACLpayload(policies []ContainerAccessPolicy) (io.Reader, int, error) {
0000000000000000000000000000000000000000;;		sil := SignedIdentifiers{
0000000000000000000000000000000000000000;;			SignedIdentifiers: []SignedIdentifier{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, capd := range policies {
0000000000000000000000000000000000000000;;			permission := capd.generateContainerPermissions()
0000000000000000000000000000000000000000;;			signedIdentifier := convertAccessPolicyToXMLStructs(capd.ID, capd.StartTime, capd.ExpiryTime, permission)
0000000000000000000000000000000000000000;;			sil.SignedIdentifiers = append(sil.SignedIdentifiers, signedIdentifier)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return xmlMarshal(sil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (capd *ContainerAccessPolicy) generateContainerPermissions() (permissions string) {
0000000000000000000000000000000000000000;;		// generate the permissions string (rwd).
0000000000000000000000000000000000000000;;		// still want the end user API to have bool flags.
0000000000000000000000000000000000000000;;		permissions = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if capd.CanRead {
0000000000000000000000000000000000000000;;			permissions += "r"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if capd.CanWrite {
0000000000000000000000000000000000000000;;			permissions += "w"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if capd.CanDelete {
0000000000000000000000000000000000000000;;			permissions += "d"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return permissions
0000000000000000000000000000000000000000;;	}
