0000000000000000000000000000000000000000;;	package storage
bf119e8337b916a81932389e376d77629c43bfe3;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// casing is per Golang's http.Header canonicalizing the header names.
0000000000000000000000000000000000000000;;		approximateMessagesCountHeader = "X-Ms-Approximate-Messages-Count"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueueAccessPolicy represents each access policy in the queue ACL.
0000000000000000000000000000000000000000;;	type QueueAccessPolicy struct {
0000000000000000000000000000000000000000;;		ID         string
0000000000000000000000000000000000000000;;		StartTime  time.Time
0000000000000000000000000000000000000000;;		ExpiryTime time.Time
0000000000000000000000000000000000000000;;		CanRead    bool
0000000000000000000000000000000000000000;;		CanAdd     bool
0000000000000000000000000000000000000000;;		CanUpdate  bool
0000000000000000000000000000000000000000;;		CanProcess bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueuePermissions represents the queue ACLs.
0000000000000000000000000000000000000000;;	type QueuePermissions struct {
0000000000000000000000000000000000000000;;		AccessPolicies []QueueAccessPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetQueuePermissionOptions includes options for a set queue permissions operation
0000000000000000000000000000000000000000;;	type SetQueuePermissionOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		RequestID string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Queue represents an Azure queue.
0000000000000000000000000000000000000000;;	type Queue struct {
0000000000000000000000000000000000000000;;		qsc               *QueueServiceClient
0000000000000000000000000000000000000000;;		Name              string
0000000000000000000000000000000000000000;;		Metadata          map[string]string
0000000000000000000000000000000000000000;;		AproxMessageCount uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *Queue) buildPath() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/%s", q.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *Queue) buildPathMessages() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/messages", q.buildPath())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueueServiceOptions includes options for some queue service operations
0000000000000000000000000000000000000000;;	type QueueServiceOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		RequestID string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create operation creates a queue under the given account.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Create-Queue4
0000000000000000000000000000000000000000;;	func (q *Queue) Create(options *QueueServiceOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = q.qsc.client.addMetadataToHeaders(headers, q.Metadata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodPut, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusCreated})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete operation permanently deletes the specified queue.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Delete-Queue3
0000000000000000000000000000000000000000;;	func (q *Queue) Delete(options *QueueServiceOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPath(), params)
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodDelete, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusNoContent})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exists returns true if a queue with given name exists.
0000000000000000000000000000000000000000;;	func (q *Queue) Exists() (bool, error) {
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPath(), url.Values{"comp": {"metadata"}})
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodGet, uri, q.qsc.client.getStandardHeaders(), nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;			if resp.statusCode == http.StatusOK || resp.statusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return resp.statusCode == http.StatusOK, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMetadata operation sets user-defined metadata on the specified queue.
0000000000000000000000000000000000000000;;	// Metadata is associated with the queue as name-value pairs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Set-Queue-Metadata
0000000000000000000000000000000000000000;;	func (q *Queue) SetMetadata(options *QueueServiceOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"metadata"}}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers = q.qsc.client.addMetadataToHeaders(headers, q.Metadata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPath(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodPut, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusNoContent})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetadata operation retrieves user-defined metadata and queue
0000000000000000000000000000000000000000;;	// properties on the specified queue. Metadata is associated with
0000000000000000000000000000000000000000;;	// the queue as name-values pairs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Set-Queue-Metadata
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Because the way Golang's http client (and http.Header in particular)
0000000000000000000000000000000000000000;;	// canonicalize header names, the returned metadata names would always
0000000000000000000000000000000000000000;;	// be all lower case.
0000000000000000000000000000000000000000;;	func (q *Queue) GetMetadata(options *QueueServiceOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{"comp": {"metadata"}}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPath(), url.Values{"comp": {"metadata"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodGet, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusOK}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aproxMessagesStr := resp.headers.Get(http.CanonicalHeaderKey(approximateMessagesCountHeader))
0000000000000000000000000000000000000000;;		if aproxMessagesStr != "" {
0000000000000000000000000000000000000000;;			aproxMessages, err := strconv.ParseUint(aproxMessagesStr, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q.AproxMessageCount = aproxMessages
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.Metadata = getMetadataFromHeaders(resp.headers)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMessageReference returns a message object with the specified text.
0000000000000000000000000000000000000000;;	func (q *Queue) GetMessageReference(text string) *Message {
0000000000000000000000000000000000000000;;		return &Message{
0000000000000000000000000000000000000000;;			Queue: q,
0000000000000000000000000000000000000000;;			Text:  text,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMessagesOptions is the set of options can be specified for Get
0000000000000000000000000000000000000000;;	// Messsages operation. A zero struct does not use any preferences for the
0000000000000000000000000000000000000000;;	// request.
0000000000000000000000000000000000000000;;	type GetMessagesOptions struct {
0000000000000000000000000000000000000000;;		Timeout           uint
0000000000000000000000000000000000000000;;		NumOfMessages     int
0000000000000000000000000000000000000000;;		VisibilityTimeout int
0000000000000000000000000000000000000000;;		RequestID         string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type messages struct {
0000000000000000000000000000000000000000;;		XMLName  xml.Name  `xml:"QueueMessagesList"`
0000000000000000000000000000000000000000;;		Messages []Message `xml:"QueueMessage"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMessages operation retrieves one or more messages from the front of the
0000000000000000000000000000000000000000;;	// queue.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Get-Messages
0000000000000000000000000000000000000000;;	func (q *Queue) GetMessages(options *GetMessagesOptions) ([]Message, error) {
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			if options.NumOfMessages != 0 {
0000000000000000000000000000000000000000;;				query.Set("numofmessages", strconv.Itoa(options.NumOfMessages))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.VisibilityTimeout != 0 {
0000000000000000000000000000000000000000;;				query.Set("visibilitytimeout", strconv.Itoa(options.VisibilityTimeout))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			query = addTimeout(query, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPathMessages(), query)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodGet, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []Message{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out messages
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []Message{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range out.Messages {
0000000000000000000000000000000000000000;;			out.Messages[i].Queue = q
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out.Messages, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PeekMessagesOptions is the set of options can be specified for Peek
0000000000000000000000000000000000000000;;	// Messsage operation. A zero struct does not use any preferences for the
0000000000000000000000000000000000000000;;	// request.
0000000000000000000000000000000000000000;;	type PeekMessagesOptions struct {
0000000000000000000000000000000000000000;;		Timeout       uint
0000000000000000000000000000000000000000;;		NumOfMessages int
0000000000000000000000000000000000000000;;		RequestID     string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PeekMessages retrieves one or more messages from the front of the queue, but
0000000000000000000000000000000000000000;;	// does not alter the visibility of the message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Peek-Messages
0000000000000000000000000000000000000000;;	func (q *Queue) PeekMessages(options *PeekMessagesOptions) ([]Message, error) {
0000000000000000000000000000000000000000;;		query := url.Values{"peekonly": {"true"}} // Required for peek operation
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			if options.NumOfMessages != 0 {
0000000000000000000000000000000000000000;;				query.Set("numofmessages", strconv.Itoa(options.NumOfMessages))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			query = addTimeout(query, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPathMessages(), query)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodGet, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []Message{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out messages
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []Message{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range out.Messages {
0000000000000000000000000000000000000000;;			out.Messages[i].Queue = q
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out.Messages, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearMessages operation deletes all messages from the specified queue.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/Clear-Messages
0000000000000000000000000000000000000000;;	func (q *Queue) ClearMessages(options *QueueServiceOptions) error {
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPathMessages(), params)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodDelete, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;		return checkRespCode(resp.statusCode, []int{http.StatusNoContent})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPermissions sets up queue permissions
0000000000000000000000000000000000000000;;	// See https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/set-queue-acl
0000000000000000000000000000000000000000;;	func (q *Queue) SetPermissions(permissions QueuePermissions, options *SetQueuePermissionOptions) error {
0000000000000000000000000000000000000000;;		body, length, err := generateQueueACLpayload(permissions.AccessPolicies)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := url.Values{
0000000000000000000000000000000000000000;;			"comp": {"acl"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;		headers["Content-Length"] = strconv.Itoa(length)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPath(), params)
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodPut, uri, headers, body, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer readAndCloseBody(resp.body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkRespCode(resp.statusCode, []int{http.StatusNoContent}); err != nil {
0000000000000000000000000000000000000000;;			return errors.New("Unable to set permissions")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateQueueACLpayload(policies []QueueAccessPolicy) (io.Reader, int, error) {
0000000000000000000000000000000000000000;;		sil := SignedIdentifiers{
0000000000000000000000000000000000000000;;			SignedIdentifiers: []SignedIdentifier{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, qapd := range policies {
0000000000000000000000000000000000000000;;			permission := qapd.generateQueuePermissions()
0000000000000000000000000000000000000000;;			signedIdentifier := convertAccessPolicyToXMLStructs(qapd.ID, qapd.StartTime, qapd.ExpiryTime, permission)
0000000000000000000000000000000000000000;;			sil.SignedIdentifiers = append(sil.SignedIdentifiers, signedIdentifier)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return xmlMarshal(sil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (qapd *QueueAccessPolicy) generateQueuePermissions() (permissions string) {
0000000000000000000000000000000000000000;;		// generate the permissions string (raup).
0000000000000000000000000000000000000000;;		// still want the end user API to have bool flags.
0000000000000000000000000000000000000000;;		permissions = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if qapd.CanRead {
0000000000000000000000000000000000000000;;			permissions += "r"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if qapd.CanAdd {
0000000000000000000000000000000000000000;;			permissions += "a"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if qapd.CanUpdate {
0000000000000000000000000000000000000000;;			permissions += "u"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if qapd.CanProcess {
0000000000000000000000000000000000000000;;			permissions += "p"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return permissions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetQueuePermissionOptions includes options for a get queue permissions operation
0000000000000000000000000000000000000000;;	type GetQueuePermissionOptions struct {
0000000000000000000000000000000000000000;;		Timeout   uint
0000000000000000000000000000000000000000;;		RequestID string `header:"x-ms-client-request-id"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPermissions gets the queue permissions as per https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-queue-acl
0000000000000000000000000000000000000000;;	// If timeout is 0 then it will not be passed to Azure
0000000000000000000000000000000000000000;;	func (q *Queue) GetPermissions(options *GetQueuePermissionOptions) (*QueuePermissions, error) {
0000000000000000000000000000000000000000;;		params := url.Values{
0000000000000000000000000000000000000000;;			"comp": {"acl"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers := q.qsc.client.getStandardHeaders()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			params = addTimeout(params, options.Timeout)
0000000000000000000000000000000000000000;;			headers = mergeHeaders(headers, headersFromStruct(*options))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := q.qsc.client.getEndpoint(queueServiceName, q.buildPath(), params)
0000000000000000000000000000000000000000;;		resp, err := q.qsc.client.exec(http.MethodGet, uri, headers, nil, q.qsc.auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ap AccessPolicy
0000000000000000000000000000000000000000;;		err = xmlUnmarshal(resp.body, &ap.SignedIdentifiersList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buildQueueAccessPolicy(ap, &resp.headers), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildQueueAccessPolicy(ap AccessPolicy, headers *http.Header) *QueuePermissions {
0000000000000000000000000000000000000000;;		permissions := QueuePermissions{
0000000000000000000000000000000000000000;;			AccessPolicies: []QueueAccessPolicy{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, policy := range ap.SignedIdentifiersList.SignedIdentifiers {
0000000000000000000000000000000000000000;;			qapd := QueueAccessPolicy{
0000000000000000000000000000000000000000;;				ID:         policy.ID,
0000000000000000000000000000000000000000;;				StartTime:  policy.AccessPolicy.StartTime,
0000000000000000000000000000000000000000;;				ExpiryTime: policy.AccessPolicy.ExpiryTime,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			qapd.CanRead = updatePermissions(policy.AccessPolicy.Permission, "r")
0000000000000000000000000000000000000000;;			qapd.CanAdd = updatePermissions(policy.AccessPolicy.Permission, "a")
0000000000000000000000000000000000000000;;			qapd.CanUpdate = updatePermissions(policy.AccessPolicy.Permission, "u")
0000000000000000000000000000000000000000;;			qapd.CanProcess = updatePermissions(policy.AccessPolicy.Permission, "p")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			permissions.AccessPolicies = append(permissions.AccessPolicies, qapd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &permissions
0000000000000000000000000000000000000000;;	}
