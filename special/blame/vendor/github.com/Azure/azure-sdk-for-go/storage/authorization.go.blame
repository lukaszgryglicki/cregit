0000000000000000000000000000000000000000;;	// Package storage provides clients for Microsoft Azure Storage Services.
0000000000000000000000000000000000000000;;	package storage
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See: https://docs.microsoft.com/rest/api/storageservices/fileservices/authentication-for-the-azure-storage-services
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authentication string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		sharedKey             authentication = "sharedKey"
0000000000000000000000000000000000000000;;		sharedKeyForTable     authentication = "sharedKeyTable"
0000000000000000000000000000000000000000;;		sharedKeyLite         authentication = "sharedKeyLite"
0000000000000000000000000000000000000000;;		sharedKeyLiteForTable authentication = "sharedKeyLiteTable"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// headers
0000000000000000000000000000000000000000;;		headerAcceptCharset           = "Accept-Charset"
0000000000000000000000000000000000000000;;		headerAuthorization           = "Authorization"
0000000000000000000000000000000000000000;;		headerContentLength           = "Content-Length"
0000000000000000000000000000000000000000;;		headerDate                    = "Date"
0000000000000000000000000000000000000000;;		headerXmsDate                 = "x-ms-date"
0000000000000000000000000000000000000000;;		headerXmsVersion              = "x-ms-version"
0000000000000000000000000000000000000000;;		headerContentEncoding         = "Content-Encoding"
0000000000000000000000000000000000000000;;		headerContentLanguage         = "Content-Language"
0000000000000000000000000000000000000000;;		headerContentType             = "Content-Type"
0000000000000000000000000000000000000000;;		headerContentMD5              = "Content-MD5"
0000000000000000000000000000000000000000;;		headerIfModifiedSince         = "If-Modified-Since"
0000000000000000000000000000000000000000;;		headerIfMatch                 = "If-Match"
0000000000000000000000000000000000000000;;		headerIfNoneMatch             = "If-None-Match"
0000000000000000000000000000000000000000;;		headerIfUnmodifiedSince       = "If-Unmodified-Since"
0000000000000000000000000000000000000000;;		headerRange                   = "Range"
0000000000000000000000000000000000000000;;		headerDataServiceVersion      = "DataServiceVersion"
0000000000000000000000000000000000000000;;		headerMaxDataServiceVersion   = "MaxDataServiceVersion"
0000000000000000000000000000000000000000;;		headerContentTransferEncoding = "Content-Transfer-Encoding"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) addAuthorizationHeader(verb, url string, headers map[string]string, auth authentication) (map[string]string, error) {
0000000000000000000000000000000000000000;;		authHeader, err := c.getSharedKey(verb, url, headers, auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers[headerAuthorization] = authHeader
0000000000000000000000000000000000000000;;		return headers, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) getSharedKey(verb, url string, headers map[string]string, auth authentication) (string, error) {
0000000000000000000000000000000000000000;;		canRes, err := c.buildCanonicalizedResource(url, auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		canString, err := buildCanonicalizedString(verb, headers, canRes, auth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.createAuthorizationHeader(canString, auth), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) buildCanonicalizedResource(uri string, auth authentication) (string, error) {
0000000000000000000000000000000000000000;;		errMsg := "buildCanonicalizedResource error: %s"
0000000000000000000000000000000000000000;;		u, err := url.Parse(uri)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(errMsg, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cr := bytes.NewBufferString("/")
0000000000000000000000000000000000000000;;		cr.WriteString(c.getCanonicalizedAccountName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(u.Path) > 0 {
0000000000000000000000000000000000000000;;			// Any portion of the CanonicalizedResource string that is derived from
0000000000000000000000000000000000000000;;			// the resource's URI should be encoded exactly as it is in the URI.
0000000000000000000000000000000000000000;;			// -- https://msdn.microsoft.com/en-gb/library/azure/dd179428.aspx
0000000000000000000000000000000000000000;;			cr.WriteString(u.EscapedPath())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params, err := url.ParseQuery(u.RawQuery)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf(errMsg, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See https://github.com/Azure/azure-storage-net/blob/master/Lib/Common/Core/Util/AuthenticationUtility.cs#L277
0000000000000000000000000000000000000000;;		if auth == sharedKey {
0000000000000000000000000000000000000000;;			if len(params) > 0 {
0000000000000000000000000000000000000000;;				cr.WriteString("\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				keys := []string{}
0000000000000000000000000000000000000000;;				for key := range params {
0000000000000000000000000000000000000000;;					keys = append(keys, key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				completeParams := []string{}
0000000000000000000000000000000000000000;;				for _, key := range keys {
0000000000000000000000000000000000000000;;					if len(params[key]) > 1 {
0000000000000000000000000000000000000000;;						sort.Strings(params[key])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					completeParams = append(completeParams, fmt.Sprintf("%s:%s", key, strings.Join(params[key], ",")))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cr.WriteString(strings.Join(completeParams, "\n"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// search for "comp" parameter, if exists then add it to canonicalizedresource
0000000000000000000000000000000000000000;;			if v, ok := params["comp"]; ok {
0000000000000000000000000000000000000000;;				cr.WriteString("?comp=" + v[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(cr.Bytes()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) getCanonicalizedAccountName() string {
0000000000000000000000000000000000000000;;		// since we may be trying to access a secondary storage account, we need to
0000000000000000000000000000000000000000;;		// remove the -secondary part of the storage name
0000000000000000000000000000000000000000;;		return strings.TrimSuffix(c.accountName, "-secondary")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildCanonicalizedString(verb string, headers map[string]string, canonicalizedResource string, auth authentication) (string, error) {
0000000000000000000000000000000000000000;;		contentLength := headers[headerContentLength]
0000000000000000000000000000000000000000;;		if contentLength == "0" {
0000000000000000000000000000000000000000;;			contentLength = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		date := headers[headerDate]
0000000000000000000000000000000000000000;;		if v, ok := headers[headerXmsDate]; ok {
0000000000000000000000000000000000000000;;			if auth == sharedKey || auth == sharedKeyLite {
0000000000000000000000000000000000000000;;				date = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				date = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var canString string
0000000000000000000000000000000000000000;;		switch auth {
0000000000000000000000000000000000000000;;		case sharedKey:
0000000000000000000000000000000000000000;;			canString = strings.Join([]string{
0000000000000000000000000000000000000000;;				verb,
0000000000000000000000000000000000000000;;				headers[headerContentEncoding],
0000000000000000000000000000000000000000;;				headers[headerContentLanguage],
0000000000000000000000000000000000000000;;				contentLength,
0000000000000000000000000000000000000000;;				headers[headerContentMD5],
0000000000000000000000000000000000000000;;				headers[headerContentType],
0000000000000000000000000000000000000000;;				date,
0000000000000000000000000000000000000000;;				headers[headerIfModifiedSince],
0000000000000000000000000000000000000000;;				headers[headerIfMatch],
0000000000000000000000000000000000000000;;				headers[headerIfNoneMatch],
0000000000000000000000000000000000000000;;				headers[headerIfUnmodifiedSince],
0000000000000000000000000000000000000000;;				headers[headerRange],
0000000000000000000000000000000000000000;;				buildCanonicalizedHeader(headers),
0000000000000000000000000000000000000000;;				canonicalizedResource,
0000000000000000000000000000000000000000;;			}, "\n")
0000000000000000000000000000000000000000;;		case sharedKeyForTable:
0000000000000000000000000000000000000000;;			canString = strings.Join([]string{
0000000000000000000000000000000000000000;;				verb,
0000000000000000000000000000000000000000;;				headers[headerContentMD5],
0000000000000000000000000000000000000000;;				headers[headerContentType],
0000000000000000000000000000000000000000;;				date,
0000000000000000000000000000000000000000;;				canonicalizedResource,
0000000000000000000000000000000000000000;;			}, "\n")
0000000000000000000000000000000000000000;;		case sharedKeyLite:
0000000000000000000000000000000000000000;;			canString = strings.Join([]string{
0000000000000000000000000000000000000000;;				verb,
0000000000000000000000000000000000000000;;				headers[headerContentMD5],
0000000000000000000000000000000000000000;;				headers[headerContentType],
0000000000000000000000000000000000000000;;				date,
0000000000000000000000000000000000000000;;				buildCanonicalizedHeader(headers),
0000000000000000000000000000000000000000;;				canonicalizedResource,
0000000000000000000000000000000000000000;;			}, "\n")
0000000000000000000000000000000000000000;;		case sharedKeyLiteForTable:
0000000000000000000000000000000000000000;;			canString = strings.Join([]string{
0000000000000000000000000000000000000000;;				date,
0000000000000000000000000000000000000000;;				canonicalizedResource,
0000000000000000000000000000000000000000;;			}, "\n")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("%s authentication is not supported yet", auth)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return canString, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildCanonicalizedHeader(headers map[string]string) string {
0000000000000000000000000000000000000000;;		cm := make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range headers {
0000000000000000000000000000000000000000;;			headerName := strings.TrimSpace(strings.ToLower(k))
0000000000000000000000000000000000000000;;			if strings.HasPrefix(headerName, "x-ms-") {
0000000000000000000000000000000000000000;;				cm[headerName] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cm) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys := []string{}
0000000000000000000000000000000000000000;;		for key := range cm {
0000000000000000000000000000000000000000;;			keys = append(keys, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := bytes.NewBufferString("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			ch.WriteString(key)
0000000000000000000000000000000000000000;;			ch.WriteRune(':')
0000000000000000000000000000000000000000;;			ch.WriteString(cm[key])
0000000000000000000000000000000000000000;;			ch.WriteRune('\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.TrimSuffix(string(ch.Bytes()), "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) createAuthorizationHeader(canonicalizedString string, auth authentication) string {
0000000000000000000000000000000000000000;;		signature := c.computeHmac256(canonicalizedString)
0000000000000000000000000000000000000000;;		var key string
0000000000000000000000000000000000000000;;		switch auth {
0000000000000000000000000000000000000000;;		case sharedKey, sharedKeyForTable:
0000000000000000000000000000000000000000;;			key = "SharedKey"
0000000000000000000000000000000000000000;;		case sharedKeyLite, sharedKeyLiteForTable:
0000000000000000000000000000000000000000;;			key = "SharedKeyLite"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s %s:%s", key, c.getCanonicalizedAccountName(), signature)
0000000000000000000000000000000000000000;;	}
