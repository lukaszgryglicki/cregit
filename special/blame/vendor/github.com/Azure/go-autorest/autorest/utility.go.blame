0000000000000000000000000000000000000000;;	package autorest
6d6afa491b422a1e9d1fe39b10df70e4bf5254bf;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodedAs is a series of constants specifying various data encodings
0000000000000000000000000000000000000000;;	type EncodedAs string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// EncodedAsJSON states that data is encoded as JSON
0000000000000000000000000000000000000000;;		EncodedAsJSON EncodedAs = "JSON"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EncodedAsXML states that data is encoded as Xml
0000000000000000000000000000000000000000;;		EncodedAsXML EncodedAs = "XML"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decoder defines the decoding method json.Decoder and xml.Decoder share
0000000000000000000000000000000000000000;;	type Decoder interface {
0000000000000000000000000000000000000000;;		Decode(v interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder creates a new decoder appropriate to the passed encoding.
0000000000000000000000000000000000000000;;	// encodedAs specifies the type of encoding and r supplies the io.Reader containing the
0000000000000000000000000000000000000000;;	// encoded data.
0000000000000000000000000000000000000000;;	func NewDecoder(encodedAs EncodedAs, r io.Reader) Decoder {
0000000000000000000000000000000000000000;;		if encodedAs == EncodedAsJSON {
0000000000000000000000000000000000000000;;			return json.NewDecoder(r)
0000000000000000000000000000000000000000;;		} else if encodedAs == EncodedAsXML {
0000000000000000000000000000000000000000;;			return xml.NewDecoder(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyAndDecode decodes the data from the passed io.Reader while making a copy. Having a copy
0000000000000000000000000000000000000000;;	// is especially useful if there is a chance the data will fail to decode.
0000000000000000000000000000000000000000;;	// encodedAs specifies the expected encoding, r provides the io.Reader to the data, and v
0000000000000000000000000000000000000000;;	// is the decoding destination.
0000000000000000000000000000000000000000;;	func CopyAndDecode(encodedAs EncodedAs, r io.Reader, v interface{}) (bytes.Buffer, error) {
0000000000000000000000000000000000000000;;		b := bytes.Buffer{}
0000000000000000000000000000000000000000;;		return b, NewDecoder(encodedAs, io.TeeReader(r, &b)).Decode(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TeeReadCloser returns a ReadCloser that writes to w what it reads from rc.
0000000000000000000000000000000000000000;;	// It utilizes io.TeeReader to copy the data read and has the same behavior when reading.
0000000000000000000000000000000000000000;;	// Further, when it is closed, it ensures that rc is closed as well.
0000000000000000000000000000000000000000;;	func TeeReadCloser(rc io.ReadCloser, w io.Writer) io.ReadCloser {
0000000000000000000000000000000000000000;;		return &teeReadCloser{rc, io.TeeReader(rc, w)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type teeReadCloser struct {
0000000000000000000000000000000000000000;;		rc io.ReadCloser
0000000000000000000000000000000000000000;;		r  io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *teeReadCloser) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		return t.r.Read(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *teeReadCloser) Close() error {
0000000000000000000000000000000000000000;;		return t.rc.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containsInt(ints []int, n int) bool {
0000000000000000000000000000000000000000;;		for _, i := range ints {
0000000000000000000000000000000000000000;;			if i == n {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escapeValueStrings(m map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		for key, value := range m {
0000000000000000000000000000000000000000;;			m[key] = url.QueryEscape(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureValueStrings(mapOfInterface map[string]interface{}) map[string]string {
0000000000000000000000000000000000000000;;		mapOfStrings := make(map[string]string)
0000000000000000000000000000000000000000;;		for key, value := range mapOfInterface {
0000000000000000000000000000000000000000;;			mapOfStrings[key] = ensureValueString(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mapOfStrings
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureValueString(value interface{}) string {
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch v := value.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return string(v)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v", v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapToValues method converts map[string]interface{} to url.Values.
0000000000000000000000000000000000000000;;	func MapToValues(m map[string]interface{}) url.Values {
0000000000000000000000000000000000000000;;		v := url.Values{}
0000000000000000000000000000000000000000;;		for key, value := range m {
0000000000000000000000000000000000000000;;			x := reflect.ValueOf(value)
0000000000000000000000000000000000000000;;			if x.Kind() == reflect.Array || x.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;				for i := 0; i < x.Len(); i++ {
0000000000000000000000000000000000000000;;					v.Add(key, ensureValueString(x.Index(i)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				v.Add(key, ensureValueString(value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String method converts interface v to string. If interface is a list, it
0000000000000000000000000000000000000000;;	// joins list elements using separator.
0000000000000000000000000000000000000000;;	func String(v interface{}, sep ...string) string {
0000000000000000000000000000000000000000;;		if len(sep) > 0 {
0000000000000000000000000000000000000000;;			return ensureValueString(strings.Join(v.([]string), sep[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ensureValueString(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode method encodes url path and query parameters.
0000000000000000000000000000000000000000;;	func Encode(location string, v interface{}, sep ...string) string {
0000000000000000000000000000000000000000;;		s := String(v, sep...)
0000000000000000000000000000000000000000;;		switch strings.ToLower(location) {
0000000000000000000000000000000000000000;;		case "path":
0000000000000000000000000000000000000000;;			return pathEscape(s)
0000000000000000000000000000000000000000;;		case "query":
0000000000000000000000000000000000000000;;			return queryEscape(s)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pathEscape(s string) string {
0000000000000000000000000000000000000000;;		return strings.Replace(url.QueryEscape(s), "+", "%20", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func queryEscape(s string) string {
0000000000000000000000000000000000000000;;		return url.QueryEscape(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This method is same as Encode() method of "net/url" go package,
0000000000000000000000000000000000000000;;	// except it does not encode the query parameters because they
0000000000000000000000000000000000000000;;	// already come encoded. It formats values map in query format (bar=foo&a=b).
0000000000000000000000000000000000000000;;	func createQuery(v url.Values) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(v))
0000000000000000000000000000000000000000;;		for k := range v {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			vs := v[k]
0000000000000000000000000000000000000000;;			prefix := url.QueryEscape(k) + "="
0000000000000000000000000000000000000000;;			for _, v := range vs {
0000000000000000000000000000000000000000;;				if buf.Len() > 0 {
0000000000000000000000000000000000000000;;					buf.WriteByte('&')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(prefix)
0000000000000000000000000000000000000000;;				buf.WriteString(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
