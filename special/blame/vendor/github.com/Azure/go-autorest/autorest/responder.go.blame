0000000000000000000000000000000000000000;;	package autorest
6d6afa491b422a1e9d1fe39b10df70e4bf5254bf;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Responder is the interface that wraps the Respond method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Respond accepts and reacts to an http.Response. Implementations must ensure to not share or hold
0000000000000000000000000000000000000000;;	// state since Responders may be shared and re-used.
0000000000000000000000000000000000000000;;	type Responder interface {
0000000000000000000000000000000000000000;;		Respond(*http.Response) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResponderFunc is a method that implements the Responder interface.
0000000000000000000000000000000000000000;;	type ResponderFunc func(*http.Response) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Respond implements the Responder interface on ResponderFunc.
0000000000000000000000000000000000000000;;	func (rf ResponderFunc) Respond(r *http.Response) error {
0000000000000000000000000000000000000000;;		return rf(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RespondDecorator takes and possibly decorates, by wrapping, a Responder. Decorators may react to
0000000000000000000000000000000000000000;;	// the http.Response and pass it along or, first, pass the http.Response along then react.
0000000000000000000000000000000000000000;;	type RespondDecorator func(Responder) Responder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateResponder creates, decorates, and returns a Responder. Without decorators, the returned
0000000000000000000000000000000000000000;;	// Responder returns the passed http.Response unmodified. Responders may or may not be safe to share
0000000000000000000000000000000000000000;;	// and re-used: It depends on the applied decorators. For example, a standard decorator that closes
0000000000000000000000000000000000000000;;	// the response body is fine to share whereas a decorator that reads the body into a passed struct
0000000000000000000000000000000000000000;;	// is not.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To prevent memory leaks, ensure that at least one Responder closes the response body.
0000000000000000000000000000000000000000;;	func CreateResponder(decorators ...RespondDecorator) Responder {
0000000000000000000000000000000000000000;;		return DecorateResponder(
0000000000000000000000000000000000000000;;			Responder(ResponderFunc(func(r *http.Response) error { return nil })),
0000000000000000000000000000000000000000;;			decorators...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecorateResponder accepts a Responder and a, possibly empty, set of RespondDecorators, which it
0000000000000000000000000000000000000000;;	// applies to the Responder. Decorators are applied in the order received, but their affect upon the
0000000000000000000000000000000000000000;;	// request depends on whether they are a pre-decorator (react to the http.Response and then pass it
0000000000000000000000000000000000000000;;	// along) or a post-decorator (pass the http.Response along and then react).
0000000000000000000000000000000000000000;;	func DecorateResponder(r Responder, decorators ...RespondDecorator) Responder {
0000000000000000000000000000000000000000;;		for _, decorate := range decorators {
0000000000000000000000000000000000000000;;			r = decorate(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Respond accepts an http.Response and a, possibly empty, set of RespondDecorators.
0000000000000000000000000000000000000000;;	// It creates a Responder from the decorators it then applies to the passed http.Response.
0000000000000000000000000000000000000000;;	func Respond(r *http.Response, decorators ...RespondDecorator) error {
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return CreateResponder(decorators...).Respond(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByIgnoring returns a RespondDecorator that ignores the passed http.Response passing it unexamined
0000000000000000000000000000000000000000;;	// to the next RespondDecorator.
0000000000000000000000000000000000000000;;	func ByIgnoring() RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				return r.Respond(resp)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByCopying copies the contents of the http.Response Body into the passed bytes.Buffer as
0000000000000000000000000000000000000000;;	// the Body is read.
0000000000000000000000000000000000000000;;	func ByCopying(b *bytes.Buffer) RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				err := r.Respond(resp)
0000000000000000000000000000000000000000;;				if err == nil && resp != nil && resp.Body != nil {
0000000000000000000000000000000000000000;;					resp.Body = TeeReadCloser(resp.Body, b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByDiscardingBody returns a RespondDecorator that first invokes the passed Responder after which
0000000000000000000000000000000000000000;;	// it copies the remaining bytes (if any) in the response body to ioutil.Discard. Since the passed
0000000000000000000000000000000000000000;;	// Responder is invoked prior to discarding the response body, the decorator may occur anywhere
0000000000000000000000000000000000000000;;	// within the set.
0000000000000000000000000000000000000000;;	func ByDiscardingBody() RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				err := r.Respond(resp)
0000000000000000000000000000000000000000;;				if err == nil && resp != nil && resp.Body != nil {
0000000000000000000000000000000000000000;;					if _, err := io.Copy(ioutil.Discard, resp.Body); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Error discarding the response body: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByClosing returns a RespondDecorator that first invokes the passed Responder after which it
0000000000000000000000000000000000000000;;	// closes the response body. Since the passed Responder is invoked prior to closing the response
0000000000000000000000000000000000000000;;	// body, the decorator may occur anywhere within the set.
0000000000000000000000000000000000000000;;	func ByClosing() RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				err := r.Respond(resp)
0000000000000000000000000000000000000000;;				if resp != nil && resp.Body != nil {
0000000000000000000000000000000000000000;;					if err := resp.Body.Close(); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Error closing the response body: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByClosingIfError returns a RespondDecorator that first invokes the passed Responder after which
0000000000000000000000000000000000000000;;	// it closes the response if the passed Responder returns an error and the response body exists.
0000000000000000000000000000000000000000;;	func ByClosingIfError() RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				err := r.Respond(resp)
0000000000000000000000000000000000000000;;				if err != nil && resp != nil && resp.Body != nil {
0000000000000000000000000000000000000000;;					if err := resp.Body.Close(); err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Error closing the response body: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByUnmarshallingJSON returns a RespondDecorator that decodes a JSON document returned in the
0000000000000000000000000000000000000000;;	// response Body into the value pointed to by v.
0000000000000000000000000000000000000000;;	func ByUnmarshallingJSON(v interface{}) RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				err := r.Respond(resp)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					b, errInner := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;					// Some responses might include a BOM, remove for successful unmarshalling
0000000000000000000000000000000000000000;;					b = bytes.TrimPrefix(b, []byte("\xef\xbb\xbf"))
0000000000000000000000000000000000000000;;					if errInner != nil {
0000000000000000000000000000000000000000;;						err = fmt.Errorf("Error occurred reading http.Response#Body - Error = '%v'", errInner)
0000000000000000000000000000000000000000;;					} else if len(strings.Trim(string(b), " ")) > 0 {
0000000000000000000000000000000000000000;;						errInner = json.Unmarshal(b, v)
0000000000000000000000000000000000000000;;						if errInner != nil {
0000000000000000000000000000000000000000;;							err = fmt.Errorf("Error occurred unmarshalling JSON - Error = '%v' JSON = '%s'", errInner, string(b))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByUnmarshallingXML returns a RespondDecorator that decodes a XML document returned in the
0000000000000000000000000000000000000000;;	// response Body into the value pointed to by v.
0000000000000000000000000000000000000000;;	func ByUnmarshallingXML(v interface{}) RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				err := r.Respond(resp)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					b, errInner := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;					if errInner != nil {
0000000000000000000000000000000000000000;;						err = fmt.Errorf("Error occurred reading http.Response#Body - Error = '%v'", errInner)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						errInner = xml.Unmarshal(b, v)
0000000000000000000000000000000000000000;;						if errInner != nil {
0000000000000000000000000000000000000000;;							err = fmt.Errorf("Error occurred unmarshalling Xml - Error = '%v' Xml = '%s'", errInner, string(b))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithErrorUnlessStatusCode returns a RespondDecorator that emits an error unless the response
0000000000000000000000000000000000000000;;	// StatusCode is among the set passed. On error, response body is fully read into a buffer and
0000000000000000000000000000000000000000;;	// presented in the returned error, as well as in the response body.
0000000000000000000000000000000000000000;;	func WithErrorUnlessStatusCode(codes ...int) RespondDecorator {
0000000000000000000000000000000000000000;;		return func(r Responder) Responder {
0000000000000000000000000000000000000000;;			return ResponderFunc(func(resp *http.Response) error {
0000000000000000000000000000000000000000;;				err := r.Respond(resp)
0000000000000000000000000000000000000000;;				if err == nil && !ResponseHasStatusCode(resp, codes...) {
0000000000000000000000000000000000000000;;					derr := NewErrorWithResponse("autorest", "WithErrorUnlessStatusCode", resp, "%v %v failed with %s",
0000000000000000000000000000000000000000;;						resp.Request.Method,
0000000000000000000000000000000000000000;;						resp.Request.URL,
0000000000000000000000000000000000000000;;						resp.Status)
0000000000000000000000000000000000000000;;					if resp.Body != nil {
0000000000000000000000000000000000000000;;						defer resp.Body.Close()
0000000000000000000000000000000000000000;;						b, _ := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;						derr.ServiceError = b
0000000000000000000000000000000000000000;;						resp.Body = ioutil.NopCloser(bytes.NewReader(b))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					err = derr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithErrorUnlessOK returns a RespondDecorator that emits an error if the response StatusCode is
0000000000000000000000000000000000000000;;	// anything other than HTTP 200.
0000000000000000000000000000000000000000;;	func WithErrorUnlessOK() RespondDecorator {
0000000000000000000000000000000000000000;;		return WithErrorUnlessStatusCode(http.StatusOK)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractHeader extracts all values of the specified header from the http.Response. It returns an
0000000000000000000000000000000000000000;;	// empty string slice if the passed http.Response is nil or the header does not exist.
0000000000000000000000000000000000000000;;	func ExtractHeader(header string, resp *http.Response) []string {
0000000000000000000000000000000000000000;;		if resp != nil && resp.Header != nil {
0000000000000000000000000000000000000000;;			return resp.Header[http.CanonicalHeaderKey(header)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractHeaderValue extracts the first value of the specified header from the http.Response. It
0000000000000000000000000000000000000000;;	// returns an empty string if the passed http.Response is nil or the header does not exist.
0000000000000000000000000000000000000000;;	func ExtractHeaderValue(header string, resp *http.Response) string {
0000000000000000000000000000000000000000;;		h := ExtractHeader(header, resp)
0000000000000000000000000000000000000000;;		if len(h) > 0 {
0000000000000000000000000000000000000000;;			return h[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
