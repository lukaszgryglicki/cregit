0000000000000000000000000000000000000000;;	package adal
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadToken restores a Token object from a file located at 'path'.
0000000000000000000000000000000000000000;;	func LoadToken(path string) (*Token, error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to open file (%s) while loading token: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var token Token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(file)
0000000000000000000000000000000000000000;;		if err = dec.Decode(&token); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to decode contents of file (%s) into Token representation: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &token, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SaveToken persists an oauth token at the given location on disk.
0000000000000000000000000000000000000000;;	// It moves the new file into place so it can safely be used to replace an existing file
0000000000000000000000000000000000000000;;	// that maybe accessed by multiple processes.
0000000000000000000000000000000000000000;;	func SaveToken(path string, mode os.FileMode, token Token) error {
0000000000000000000000000000000000000000;;		dir := filepath.Dir(path)
0000000000000000000000000000000000000000;;		err := os.MkdirAll(dir, os.ModePerm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create directory (%s) to store token in: %v", dir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newFile, err := ioutil.TempFile(dir, "token")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to create the temp file to write the token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tempPath := newFile.Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.NewEncoder(newFile).Encode(token); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to encode token to file (%s) while saving token: %v", tempPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := newFile.Close(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to close temp file %s: %v", tempPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Atomic replace to avoid multi-writer file corruptions
0000000000000000000000000000000000000000;;		if err := os.Rename(tempPath, path); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to move temporary token to desired output location. src=%s dst=%s: %v", tempPath, path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.Chmod(path, mode); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to chmod the token file %s: %v", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
