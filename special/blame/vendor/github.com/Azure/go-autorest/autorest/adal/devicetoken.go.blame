0000000000000000000000000000000000000000;;	package adal
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	  This file is largely based on rjw57/oauth2device's code, with the follow differences:
0000000000000000000000000000000000000000;;	   * scope -> resource, and only allow a single one
0000000000000000000000000000000000000000;;	   * receive "Message" in the DeviceCode struct and show it to users as the prompt
0000000000000000000000000000000000000000;;	   * azure-xplat-cli has the following behavior that this emulates:
0000000000000000000000000000000000000000;;	     - does not send client_secret during the token exchange
0000000000000000000000000000000000000000;;	     - sends resource again in the token exchange request
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		logPrefix = "autorest/adal/devicetoken:"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrDeviceGeneric represents an unknown error from the token endpoint when using device flow
0000000000000000000000000000000000000000;;		ErrDeviceGeneric = fmt.Errorf("%s Error while retrieving OAuth token: Unknown Error", logPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDeviceAccessDenied represents an access denied error from the token endpoint when using device flow
0000000000000000000000000000000000000000;;		ErrDeviceAccessDenied = fmt.Errorf("%s Error while retrieving OAuth token: Access Denied", logPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDeviceAuthorizationPending represents the server waiting on the user to complete the device flow
0000000000000000000000000000000000000000;;		ErrDeviceAuthorizationPending = fmt.Errorf("%s Error while retrieving OAuth token: Authorization Pending", logPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDeviceCodeExpired represents the server timing out and expiring the code during device flow
0000000000000000000000000000000000000000;;		ErrDeviceCodeExpired = fmt.Errorf("%s Error while retrieving OAuth token: Code Expired", logPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDeviceSlowDown represents the service telling us we're polling too often during device flow
0000000000000000000000000000000000000000;;		ErrDeviceSlowDown = fmt.Errorf("%s Error while retrieving OAuth token: Slow Down", logPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDeviceCodeEmpty represents an empty device code from the device endpoint while using device flow
0000000000000000000000000000000000000000;;		ErrDeviceCodeEmpty = fmt.Errorf("%s Error while retrieving device code: Device Code Empty", logPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrOAuthTokenEmpty represents an empty OAuth token from the token endpoint when using device flow
0000000000000000000000000000000000000000;;		ErrOAuthTokenEmpty = fmt.Errorf("%s Error while retrieving OAuth token: Token Empty", logPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errCodeSendingFails   = "Error occurred while sending request for Device Authorization Code"
0000000000000000000000000000000000000000;;		errCodeHandlingFails  = "Error occurred while handling response from the Device Endpoint"
0000000000000000000000000000000000000000;;		errTokenSendingFails  = "Error occurred while sending request with device code for a token"
0000000000000000000000000000000000000000;;		errTokenHandlingFails = "Error occurred while handling response from the Token Endpoint (during device flow)"
0000000000000000000000000000000000000000;;		errStatusNotOK        = "Error HTTP status != 200"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeviceCode is the object returned by the device auth endpoint
0000000000000000000000000000000000000000;;	// It contains information to instruct the user to complete the auth flow
0000000000000000000000000000000000000000;;	type DeviceCode struct {
0000000000000000000000000000000000000000;;		DeviceCode      *string `json:"device_code,omitempty"`
0000000000000000000000000000000000000000;;		UserCode        *string `json:"user_code,omitempty"`
0000000000000000000000000000000000000000;;		VerificationURL *string `json:"verification_url,omitempty"`
0000000000000000000000000000000000000000;;		ExpiresIn       *int64  `json:"expires_in,string,omitempty"`
0000000000000000000000000000000000000000;;		Interval        *int64  `json:"interval,string,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Message     *string `json:"message"` // Azure specific
0000000000000000000000000000000000000000;;		Resource    string  // store the following, stored when initiating, used when exchanging
0000000000000000000000000000000000000000;;		OAuthConfig OAuthConfig
0000000000000000000000000000000000000000;;		ClientID    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TokenError is the object returned by the token exchange endpoint
0000000000000000000000000000000000000000;;	// when something is amiss
0000000000000000000000000000000000000000;;	type TokenError struct {
0000000000000000000000000000000000000000;;		Error            *string `json:"error,omitempty"`
0000000000000000000000000000000000000000;;		ErrorCodes       []int   `json:"error_codes,omitempty"`
0000000000000000000000000000000000000000;;		ErrorDescription *string `json:"error_description,omitempty"`
0000000000000000000000000000000000000000;;		Timestamp        *string `json:"timestamp,omitempty"`
0000000000000000000000000000000000000000;;		TraceID          *string `json:"trace_id,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeviceToken is the object return by the token exchange endpoint
0000000000000000000000000000000000000000;;	// It can either look like a Token or an ErrorToken, so put both here
0000000000000000000000000000000000000000;;	// and check for presence of "Error" to know if we are in error state
0000000000000000000000000000000000000000;;	type deviceToken struct {
0000000000000000000000000000000000000000;;		Token
0000000000000000000000000000000000000000;;		TokenError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitiateDeviceAuth initiates a device auth flow. It returns a DeviceCode
0000000000000000000000000000000000000000;;	// that can be used with CheckForUserCompletion or WaitForUserCompletion.
0000000000000000000000000000000000000000;;	func InitiateDeviceAuth(sender Sender, oauthConfig OAuthConfig, clientID, resource string) (*DeviceCode, error) {
0000000000000000000000000000000000000000;;		v := url.Values{
0000000000000000000000000000000000000000;;			"client_id": []string{clientID},
0000000000000000000000000000000000000000;;			"resource":  []string{resource},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := v.Encode()
0000000000000000000000000000000000000000;;		body := ioutil.NopCloser(strings.NewReader(s))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(http.MethodPost, oauthConfig.DeviceCodeEndpoint.String(), body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errCodeSendingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.ContentLength = int64(len(s))
0000000000000000000000000000000000000000;;		req.Header.Set(contentType, mimeTypeFormPost)
0000000000000000000000000000000000000000;;		resp, err := sender.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errCodeSendingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rb, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errCodeHandlingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errCodeHandlingFails, errStatusNotOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(strings.Trim(string(rb), " ")) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrDeviceCodeEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var code DeviceCode
0000000000000000000000000000000000000000;;		err = json.Unmarshal(rb, &code)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errCodeHandlingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		code.ClientID = clientID
0000000000000000000000000000000000000000;;		code.Resource = resource
0000000000000000000000000000000000000000;;		code.OAuthConfig = oauthConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &code, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckForUserCompletion takes a DeviceCode and checks with the Azure AD OAuth endpoint
0000000000000000000000000000000000000000;;	// to see if the device flow has: been completed, timed out, or otherwise failed
0000000000000000000000000000000000000000;;	func CheckForUserCompletion(sender Sender, code *DeviceCode) (*Token, error) {
0000000000000000000000000000000000000000;;		v := url.Values{
0000000000000000000000000000000000000000;;			"client_id":  []string{code.ClientID},
0000000000000000000000000000000000000000;;			"code":       []string{*code.DeviceCode},
0000000000000000000000000000000000000000;;			"grant_type": []string{OAuthGrantTypeDeviceCode},
0000000000000000000000000000000000000000;;			"resource":   []string{code.Resource},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := v.Encode()
0000000000000000000000000000000000000000;;		body := ioutil.NopCloser(strings.NewReader(s))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(http.MethodPost, code.OAuthConfig.TokenEndpoint.String(), body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errTokenSendingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.ContentLength = int64(len(s))
0000000000000000000000000000000000000000;;		req.Header.Set(contentType, mimeTypeFormPost)
0000000000000000000000000000000000000000;;		resp, err := sender.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errTokenSendingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rb, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errTokenHandlingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK && len(strings.Trim(string(rb), " ")) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errTokenHandlingFails, errStatusNotOK)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(strings.Trim(string(rb), " ")) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrOAuthTokenEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var token deviceToken
0000000000000000000000000000000000000000;;		err = json.Unmarshal(rb, &token)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s %s: %s", logPrefix, errTokenHandlingFails, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.Error == nil {
0000000000000000000000000000000000000000;;			return &token.Token, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch *token.Error {
0000000000000000000000000000000000000000;;		case "authorization_pending":
0000000000000000000000000000000000000000;;			return nil, ErrDeviceAuthorizationPending
0000000000000000000000000000000000000000;;		case "slow_down":
0000000000000000000000000000000000000000;;			return nil, ErrDeviceSlowDown
0000000000000000000000000000000000000000;;		case "access_denied":
0000000000000000000000000000000000000000;;			return nil, ErrDeviceAccessDenied
0000000000000000000000000000000000000000;;		case "code_expired":
0000000000000000000000000000000000000000;;			return nil, ErrDeviceCodeExpired
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrDeviceGeneric
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForUserCompletion calls CheckForUserCompletion repeatedly until a token is granted or an error state occurs.
0000000000000000000000000000000000000000;;	// This prevents the user from looping and checking against 'ErrDeviceAuthorizationPending'.
0000000000000000000000000000000000000000;;	func WaitForUserCompletion(sender Sender, code *DeviceCode) (*Token, error) {
0000000000000000000000000000000000000000;;		intervalDuration := time.Duration(*code.Interval) * time.Second
0000000000000000000000000000000000000000;;		waitDuration := intervalDuration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			token, err := CheckForUserCompletion(sender, code)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return token, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch err {
0000000000000000000000000000000000000000;;			case ErrDeviceSlowDown:
0000000000000000000000000000000000000000;;				waitDuration += waitDuration
0000000000000000000000000000000000000000;;			case ErrDeviceAuthorizationPending:
0000000000000000000000000000000000000000;;				// noop
0000000000000000000000000000000000000000;;			default: // everything else is "fatal" to us
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if waitDuration > (intervalDuration * 3) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%s Error waiting for user to complete device flow. Server told us to slow_down too much", logPrefix)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			time.Sleep(waitDuration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
