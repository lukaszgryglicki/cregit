0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package validation provides methods for validating parameter value using reflection.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package validation
d847c78ae1f722cdc1b2b0be7f75237cf70584c4;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constraint stores constraint name, target field name
0000000000000000000000000000000000000000;;	// Rule and chain validations.
0000000000000000000000000000000000000000;;	type Constraint struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Target field name for validation.
0000000000000000000000000000000000000000;;		Target string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Constraint name e.g. minLength, MaxLength, Pattern, etc.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule for constraint e.g. greater than 10, less than 5 etc.
0000000000000000000000000000000000000000;;		Rule interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Chain Validations for struct type
0000000000000000000000000000000000000000;;		Chain []Constraint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validation stores parameter-wise validation.
0000000000000000000000000000000000000000;;	type Validation struct {
0000000000000000000000000000000000000000;;		TargetValue interface{}
0000000000000000000000000000000000000000;;		Constraints []Constraint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constraint list
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Empty            = "Empty"
0000000000000000000000000000000000000000;;		Null             = "Null"
0000000000000000000000000000000000000000;;		ReadOnly         = "ReadOnly"
0000000000000000000000000000000000000000;;		Pattern          = "Pattern"
0000000000000000000000000000000000000000;;		MaxLength        = "MaxLength"
0000000000000000000000000000000000000000;;		MinLength        = "MinLength"
0000000000000000000000000000000000000000;;		MaxItems         = "MaxItems"
0000000000000000000000000000000000000000;;		MinItems         = "MinItems"
0000000000000000000000000000000000000000;;		MultipleOf       = "MultipleOf"
0000000000000000000000000000000000000000;;		UniqueItems      = "UniqueItems"
0000000000000000000000000000000000000000;;		InclusiveMaximum = "InclusiveMaximum"
0000000000000000000000000000000000000000;;		ExclusiveMaximum = "ExclusiveMaximum"
0000000000000000000000000000000000000000;;		ExclusiveMinimum = "ExclusiveMinimum"
0000000000000000000000000000000000000000;;		InclusiveMinimum = "InclusiveMinimum"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate method validates constraints on parameter
0000000000000000000000000000000000000000;;	// passed in validation array.
0000000000000000000000000000000000000000;;	func Validate(m []Validation) error {
0000000000000000000000000000000000000000;;		for _, item := range m {
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(item.TargetValue)
0000000000000000000000000000000000000000;;			for _, constraint := range item.Constraints {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				switch v.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Ptr:
0000000000000000000000000000000000000000;;					err = validatePtr(v, constraint)
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					err = validateString(v, constraint)
0000000000000000000000000000000000000000;;				case reflect.Struct:
0000000000000000000000000000000000000000;;					err = validateStruct(v, constraint)
0000000000000000000000000000000000000000;;				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;					err = validateInt(v, constraint)
0000000000000000000000000000000000000000;;				case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;					err = validateFloat(v, constraint)
0000000000000000000000000000000000000000;;				case reflect.Array, reflect.Slice, reflect.Map:
0000000000000000000000000000000000000000;;					err = validateArrayMap(v, constraint)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					err = createError(v, constraint, fmt.Sprintf("unknown type %v", v.Kind()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateStruct(x reflect.Value, v Constraint, name ...string) error {
0000000000000000000000000000000000000000;;		//Get field name from target name which is in format a.b.c
0000000000000000000000000000000000000000;;		s := strings.Split(v.Target, ".")
0000000000000000000000000000000000000000;;		f := x.FieldByName(s[len(s)-1])
0000000000000000000000000000000000000000;;		if isZero(f) {
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("field %q doesn't exist", v.Target))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Validate([]Validation{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				TargetValue: getInterfaceValue(f),
0000000000000000000000000000000000000000;;				Constraints: []Constraint{v},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePtr(x reflect.Value, v Constraint) error {
0000000000000000000000000000000000000000;;		if v.Name == ReadOnly {
0000000000000000000000000000000000000000;;			if !x.IsNil() {
0000000000000000000000000000000000000000;;				return createError(x.Elem(), v, "readonly parameter; must send as nil or empty in request")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x.IsNil() {
0000000000000000000000000000000000000000;;			return checkNil(x, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Chain != nil {
0000000000000000000000000000000000000000;;			return Validate([]Validation{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					TargetValue: getInterfaceValue(x.Elem()),
0000000000000000000000000000000000000000;;					Constraints: v.Chain,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateInt(x reflect.Value, v Constraint) error {
0000000000000000000000000000000000000000;;		i := x.Int()
0000000000000000000000000000000000000000;;		r, ok := v.Rule.(int)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("rule must be integer value for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch v.Name {
0000000000000000000000000000000000000000;;		case MultipleOf:
0000000000000000000000000000000000000000;;			if i%int64(r) != 0 {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be a multiple of %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ExclusiveMinimum:
0000000000000000000000000000000000000000;;			if i <= int64(r) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be greater than %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ExclusiveMaximum:
0000000000000000000000000000000000000000;;			if i >= int64(r) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be less than %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case InclusiveMinimum:
0000000000000000000000000000000000000000;;			if i < int64(r) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be greater than or equal to %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case InclusiveMaximum:
0000000000000000000000000000000000000000;;			if i > int64(r) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be less than or equal to %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("constraint %v is not applicable for type integer", v.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateFloat(x reflect.Value, v Constraint) error {
0000000000000000000000000000000000000000;;		f := x.Float()
0000000000000000000000000000000000000000;;		r, ok := v.Rule.(float64)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("rule must be float value for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch v.Name {
0000000000000000000000000000000000000000;;		case ExclusiveMinimum:
0000000000000000000000000000000000000000;;			if f <= r {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be greater than %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ExclusiveMaximum:
0000000000000000000000000000000000000000;;			if f >= r {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be less than %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case InclusiveMinimum:
0000000000000000000000000000000000000000;;			if f < r {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be greater than or equal to %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case InclusiveMaximum:
0000000000000000000000000000000000000000;;			if f > r {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value must be less than or equal to %v", r))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("constraint %s is not applicable for type float", v.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateString(x reflect.Value, v Constraint) error {
0000000000000000000000000000000000000000;;		s := x.String()
0000000000000000000000000000000000000000;;		switch v.Name {
0000000000000000000000000000000000000000;;		case Empty:
0000000000000000000000000000000000000000;;			if len(s) == 0 {
0000000000000000000000000000000000000000;;				return checkEmpty(x, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Pattern:
0000000000000000000000000000000000000000;;			reg, err := regexp.Compile(v.Rule.(string))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return createError(x, v, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reg.MatchString(s) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value doesn't match pattern %v", v.Rule))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case MaxLength:
0000000000000000000000000000000000000000;;			if _, ok := v.Rule.(int); !ok {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("rule must be integer value for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) > v.Rule.(int) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value length must be less than %v", v.Rule))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case MinLength:
0000000000000000000000000000000000000000;;			if _, ok := v.Rule.(int); !ok {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("rule must be integer value for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) < v.Rule.(int) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("value length must be greater than %v", v.Rule))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ReadOnly:
0000000000000000000000000000000000000000;;			if len(s) > 0 {
0000000000000000000000000000000000000000;;				return createError(reflect.ValueOf(s), v, "readonly parameter; must send as nil or empty in request")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("constraint %s is not applicable to string type", v.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v.Chain != nil {
0000000000000000000000000000000000000000;;			return Validate([]Validation{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					TargetValue: getInterfaceValue(x),
0000000000000000000000000000000000000000;;					Constraints: v.Chain,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateArrayMap(x reflect.Value, v Constraint) error {
0000000000000000000000000000000000000000;;		switch v.Name {
0000000000000000000000000000000000000000;;		case Null:
0000000000000000000000000000000000000000;;			if x.IsNil() {
0000000000000000000000000000000000000000;;				return checkNil(x, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Empty:
0000000000000000000000000000000000000000;;			if x.IsNil() || x.Len() == 0 {
0000000000000000000000000000000000000000;;				return checkEmpty(x, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case MaxItems:
0000000000000000000000000000000000000000;;			if _, ok := v.Rule.(int); !ok {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("rule must be integer for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.Len() > v.Rule.(int) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("maximum item limit is %v; got: %v", v.Rule, x.Len()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case MinItems:
0000000000000000000000000000000000000000;;			if _, ok := v.Rule.(int); !ok {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("rule must be integer for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.Len() < v.Rule.(int) {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("minimum item limit is %v; got: %v", v.Rule, x.Len()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case UniqueItems:
0000000000000000000000000000000000000000;;			if x.Kind() == reflect.Array || x.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;				if !checkForUniqueInArray(x) {
0000000000000000000000000000000000000000;;					return createError(x, v, fmt.Sprintf("all items in parameter %q must be unique; got:%v", v.Target, x))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if x.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;				if !checkForUniqueInMap(x) {
0000000000000000000000000000000000000000;;					return createError(x, v, fmt.Sprintf("all items in parameter %q must be unique; got:%v", v.Target, x))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return createError(x, v, fmt.Sprintf("type must be array, slice or map for constraint %v; got: %v", v.Name, x.Kind()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ReadOnly:
0000000000000000000000000000000000000000;;			if x.Len() != 0 {
0000000000000000000000000000000000000000;;				return createError(x, v, "readonly parameter; must send as nil or empty in request")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("constraint %v is not applicable to array, slice and map type", v.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v.Chain != nil {
0000000000000000000000000000000000000000;;			return Validate([]Validation{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					TargetValue: getInterfaceValue(x),
0000000000000000000000000000000000000000;;					Constraints: v.Chain,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkNil(x reflect.Value, v Constraint) error {
0000000000000000000000000000000000000000;;		if _, ok := v.Rule.(bool); !ok {
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("rule must be bool value for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Rule.(bool) {
0000000000000000000000000000000000000000;;			return createError(x, v, "value can not be null; required parameter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkEmpty(x reflect.Value, v Constraint) error {
0000000000000000000000000000000000000000;;		if _, ok := v.Rule.(bool); !ok {
0000000000000000000000000000000000000000;;			return createError(x, v, fmt.Sprintf("rule must be bool value for %v constraint; got: %v", v.Name, v.Rule))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v.Rule.(bool) {
0000000000000000000000000000000000000000;;			return createError(x, v, "value can not be null or empty; required parameter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkForUniqueInArray(x reflect.Value) bool {
0000000000000000000000000000000000000000;;		if x == reflect.Zero(reflect.TypeOf(x)) || x.Len() == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		arrOfInterface := make([]interface{}, x.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < x.Len(); i++ {
0000000000000000000000000000000000000000;;			arrOfInterface[i] = x.Index(i).Interface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(map[interface{}]bool)
0000000000000000000000000000000000000000;;		for _, val := range arrOfInterface {
0000000000000000000000000000000000000000;;			if m[val] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m[val] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkForUniqueInMap(x reflect.Value) bool {
0000000000000000000000000000000000000000;;		if x == reflect.Zero(reflect.TypeOf(x)) || x.Len() == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapOfInterface := make(map[interface{}]interface{}, x.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys := x.MapKeys()
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			mapOfInterface[k.Interface()] = x.MapIndex(k).Interface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(map[interface{}]bool)
0000000000000000000000000000000000000000;;		for _, val := range mapOfInterface {
0000000000000000000000000000000000000000;;			if m[val] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m[val] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInterfaceValue(x reflect.Value) interface{} {
0000000000000000000000000000000000000000;;		if x.Kind() == reflect.Invalid {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x.Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isZero(x interface{}) bool {
0000000000000000000000000000000000000000;;		return x == reflect.Zero(reflect.TypeOf(x)).Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createError(x reflect.Value, v Constraint, err string) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("autorest/validation: validation failed: parameter=%s constraint=%s value=%#v details: %s",
0000000000000000000000000000000000000000;;			v.Target, v.Name, getInterfaceValue(x), err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewErrorWithValidationError appends package type and method name in
0000000000000000000000000000000000000000;;	// validation error.
0000000000000000000000000000000000000000;;	func NewErrorWithValidationError(err error, packageType, method string) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("%s#%s: Invalid input: %v", packageType, method, err)
0000000000000000000000000000000000000000;;	}
