0000000000000000000000000000000000000000;;	package autorest
6d6afa491b422a1e9d1fe39b10df70e4bf5254bf;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sender is the interface that wraps the Do method to send HTTP requests.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The standard http.Client conforms to this interface.
0000000000000000000000000000000000000000;;	type Sender interface {
0000000000000000000000000000000000000000;;		Do(*http.Request) (*http.Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SenderFunc is a method that implements the Sender interface.
0000000000000000000000000000000000000000;;	type SenderFunc func(*http.Request) (*http.Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do implements the Sender interface on SenderFunc.
0000000000000000000000000000000000000000;;	func (sf SenderFunc) Do(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return sf(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendDecorator takes and possibily decorates, by wrapping, a Sender. Decorators may affect the
0000000000000000000000000000000000000000;;	// http.Request and pass it along or, first, pass the http.Request along then react to the
0000000000000000000000000000000000000000;;	// http.Response result.
0000000000000000000000000000000000000000;;	type SendDecorator func(Sender) Sender
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSender creates, decorates, and returns, as a Sender, the default http.Client.
0000000000000000000000000000000000000000;;	func CreateSender(decorators ...SendDecorator) Sender {
0000000000000000000000000000000000000000;;		return DecorateSender(&http.Client{}, decorators...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecorateSender accepts a Sender and a, possibly empty, set of SendDecorators, which is applies to
0000000000000000000000000000000000000000;;	// the Sender. Decorators are applied in the order received, but their affect upon the request
0000000000000000000000000000000000000000;;	// depends on whether they are a pre-decorator (change the http.Request and then pass it along) or a
0000000000000000000000000000000000000000;;	// post-decorator (pass the http.Request along and react to the results in http.Response).
0000000000000000000000000000000000000000;;	func DecorateSender(s Sender, decorators ...SendDecorator) Sender {
0000000000000000000000000000000000000000;;		for _, decorate := range decorators {
0000000000000000000000000000000000000000;;			s = decorate(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send sends, by means of the default http.Client, the passed http.Request, returning the
0000000000000000000000000000000000000000;;	// http.Response and possible error. It also accepts a, possibly empty, set of SendDecorators which
0000000000000000000000000000000000000000;;	// it will apply the http.Client before invoking the Do method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Send is a convenience method and not recommended for production. Advanced users should use
0000000000000000000000000000000000000000;;	// SendWithSender, passing and sharing their own Sender (e.g., instance of http.Client).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Send will not poll or retry requests.
0000000000000000000000000000000000000000;;	func Send(r *http.Request, decorators ...SendDecorator) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return SendWithSender(&http.Client{}, r, decorators...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendWithSender sends the passed http.Request, through the provided Sender, returning the
0000000000000000000000000000000000000000;;	// http.Response and possible error. It also accepts a, possibly empty, set of SendDecorators which
0000000000000000000000000000000000000000;;	// it will apply the http.Client before invoking the Do method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// SendWithSender will not poll or retry requests.
0000000000000000000000000000000000000000;;	func SendWithSender(s Sender, r *http.Request, decorators ...SendDecorator) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return DecorateSender(s, decorators...).Do(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AfterDelay returns a SendDecorator that delays for the passed time.Duration before
0000000000000000000000000000000000000000;;	// invoking the Sender. The delay may be terminated by closing the optional channel on the
0000000000000000000000000000000000000000;;	// http.Request. If canceled, no further Senders are invoked.
0000000000000000000000000000000000000000;;	func AfterDelay(d time.Duration) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				if !DelayForBackoff(d, 0, r.Cancel) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("autorest: AfterDelay canceled before full delay")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return s.Do(r)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsIs returns a SendDecorator that invokes the passed Sender without modifying the http.Request.
0000000000000000000000000000000000000000;;	func AsIs() SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				return s.Do(r)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoCloseIfError returns a SendDecorator that first invokes the passed Sender after which
0000000000000000000000000000000000000000;;	// it closes the response if the passed Sender returns an error and the response body exists.
0000000000000000000000000000000000000000;;	func DoCloseIfError() SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				resp, err := s.Do(r)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					Respond(resp, ByDiscardingBody(), ByClosing())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoErrorIfStatusCode returns a SendDecorator that emits an error if the response StatusCode is
0000000000000000000000000000000000000000;;	// among the set passed. Since these are artificial errors, the response body may still require
0000000000000000000000000000000000000000;;	// closing.
0000000000000000000000000000000000000000;;	func DoErrorIfStatusCode(codes ...int) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				resp, err := s.Do(r)
0000000000000000000000000000000000000000;;				if err == nil && ResponseHasStatusCode(resp, codes...) {
0000000000000000000000000000000000000000;;					err = NewErrorWithResponse("autorest", "DoErrorIfStatusCode", resp, "%v %v failed with %s",
0000000000000000000000000000000000000000;;						resp.Request.Method,
0000000000000000000000000000000000000000;;						resp.Request.URL,
0000000000000000000000000000000000000000;;						resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoErrorUnlessStatusCode returns a SendDecorator that emits an error unless the response
0000000000000000000000000000000000000000;;	// StatusCode is among the set passed. Since these are artificial errors, the response body
0000000000000000000000000000000000000000;;	// may still require closing.
0000000000000000000000000000000000000000;;	func DoErrorUnlessStatusCode(codes ...int) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				resp, err := s.Do(r)
0000000000000000000000000000000000000000;;				if err == nil && !ResponseHasStatusCode(resp, codes...) {
0000000000000000000000000000000000000000;;					err = NewErrorWithResponse("autorest", "DoErrorUnlessStatusCode", resp, "%v %v failed with %s",
0000000000000000000000000000000000000000;;						resp.Request.Method,
0000000000000000000000000000000000000000;;						resp.Request.URL,
0000000000000000000000000000000000000000;;						resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoPollForStatusCodes returns a SendDecorator that polls if the http.Response contains one of the
0000000000000000000000000000000000000000;;	// passed status codes. It expects the http.Response to contain a Location header providing the
0000000000000000000000000000000000000000;;	// URL at which to poll (using GET) and will poll until the time passed is equal to or greater than
0000000000000000000000000000000000000000;;	// the supplied duration. It will delay between requests for the duration specified in the
0000000000000000000000000000000000000000;;	// RetryAfter header or, if the header is absent, the passed delay. Polling may be canceled by
0000000000000000000000000000000000000000;;	// closing the optional channel on the http.Request.
0000000000000000000000000000000000000000;;	func DoPollForStatusCodes(duration time.Duration, delay time.Duration, codes ...int) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (resp *http.Response, err error) {
0000000000000000000000000000000000000000;;				resp, err = s.Do(r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err == nil && ResponseHasStatusCode(resp, codes...) {
0000000000000000000000000000000000000000;;					r, err = NewPollingRequest(resp, r.Cancel)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for err == nil && ResponseHasStatusCode(resp, codes...) {
0000000000000000000000000000000000000000;;						Respond(resp,
0000000000000000000000000000000000000000;;							ByDiscardingBody(),
0000000000000000000000000000000000000000;;							ByClosing())
0000000000000000000000000000000000000000;;						resp, err = SendWithSender(s, r,
0000000000000000000000000000000000000000;;							AfterDelay(GetRetryAfter(resp, delay)))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoRetryForAttempts returns a SendDecorator that retries a failed request for up to the specified
0000000000000000000000000000000000000000;;	// number of attempts, exponentially backing off between requests using the supplied backoff
0000000000000000000000000000000000000000;;	// time.Duration (which may be zero). Retrying may be canceled by closing the optional channel on
0000000000000000000000000000000000000000;;	// the http.Request.
0000000000000000000000000000000000000000;;	func DoRetryForAttempts(attempts int, backoff time.Duration) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (resp *http.Response, err error) {
0000000000000000000000000000000000000000;;				for attempt := 0; attempt < attempts; attempt++ {
0000000000000000000000000000000000000000;;					resp, err = s.Do(r)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						return resp, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					DelayForBackoff(backoff, attempt, r.Cancel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoRetryForStatusCodes returns a SendDecorator that retries for specified statusCodes for up to the specified
0000000000000000000000000000000000000000;;	// number of attempts, exponentially backing off between requests using the supplied backoff
0000000000000000000000000000000000000000;;	// time.Duration (which may be zero). Retrying may be canceled by closing the optional channel on
0000000000000000000000000000000000000000;;	// the http.Request.
0000000000000000000000000000000000000000;;	func DoRetryForStatusCodes(attempts int, backoff time.Duration, codes ...int) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (resp *http.Response, err error) {
0000000000000000000000000000000000000000;;				b := []byte{}
0000000000000000000000000000000000000000;;				if r.Body != nil {
0000000000000000000000000000000000000000;;					b, err = ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return resp, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Increment to add the first call (attempts denotes number of retries)
0000000000000000000000000000000000000000;;				attempts++
0000000000000000000000000000000000000000;;				for attempt := 0; attempt < attempts; attempt++ {
0000000000000000000000000000000000000000;;					r.Body = ioutil.NopCloser(bytes.NewBuffer(b))
0000000000000000000000000000000000000000;;					resp, err = s.Do(r)
0000000000000000000000000000000000000000;;					if err != nil || !ResponseHasStatusCode(resp, codes...) {
0000000000000000000000000000000000000000;;						return resp, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					DelayForBackoff(backoff, attempt, r.Cancel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoRetryForDuration returns a SendDecorator that retries the request until the total time is equal
0000000000000000000000000000000000000000;;	// to or greater than the specified duration, exponentially backing off between requests using the
0000000000000000000000000000000000000000;;	// supplied backoff time.Duration (which may be zero). Retrying may be canceled by closing the
0000000000000000000000000000000000000000;;	// optional channel on the http.Request.
0000000000000000000000000000000000000000;;	func DoRetryForDuration(d time.Duration, backoff time.Duration) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (resp *http.Response, err error) {
0000000000000000000000000000000000000000;;				end := time.Now().Add(d)
0000000000000000000000000000000000000000;;				for attempt := 0; time.Now().Before(end); attempt++ {
0000000000000000000000000000000000000000;;					resp, err = s.Do(r)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						return resp, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					DelayForBackoff(backoff, attempt, r.Cancel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithLogging returns a SendDecorator that implements simple before and after logging of the
0000000000000000000000000000000000000000;;	// request.
0000000000000000000000000000000000000000;;	func WithLogging(logger *log.Logger) SendDecorator {
0000000000000000000000000000000000000000;;		return func(s Sender) Sender {
0000000000000000000000000000000000000000;;			return SenderFunc(func(r *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;				logger.Printf("Sending %s %s", r.Method, r.URL)
0000000000000000000000000000000000000000;;				resp, err := s.Do(r)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					logger.Printf("%s %s received error '%v'", r.Method, r.URL, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					logger.Printf("%s %s received %s", r.Method, r.URL, resp.Status)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelayForBackoff invokes time.After for the supplied backoff duration raised to the power of
0000000000000000000000000000000000000000;;	// passed attempt (i.e., an exponential backoff delay). Backoff duration is in seconds and can set
0000000000000000000000000000000000000000;;	// to zero for no delay. The delay may be canceled by closing the passed channel. If terminated early,
0000000000000000000000000000000000000000;;	// returns false.
0000000000000000000000000000000000000000;;	// Note: Passing attempt 1 will result in doubling "backoff" duration. Treat this as a zero-based attempt
0000000000000000000000000000000000000000;;	// count.
0000000000000000000000000000000000000000;;	func DelayForBackoff(backoff time.Duration, attempt int, cancel <-chan struct{}) bool {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(time.Duration(backoff.Seconds()*math.Pow(2, float64(attempt))) * time.Second):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case <-cancel:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
