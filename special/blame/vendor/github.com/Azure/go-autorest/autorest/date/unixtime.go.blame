0000000000000000000000000000000000000000;;	package date
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unixEpoch is the moment in time that should be treated as timestamp 0.
0000000000000000000000000000000000000000;;	var unixEpoch = time.Date(1970, time.January, 1, 0, 0, 0, 0, time.UTC)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnixTime marshals and unmarshals a time that is represented as the number
0000000000000000000000000000000000000000;;	// of seconds (ignoring skip-seconds) since the Unix Epoch.
0000000000000000000000000000000000000000;;	type UnixTime time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Duration returns the time as a Duration since the UnixEpoch.
0000000000000000000000000000000000000000;;	func (t UnixTime) Duration() time.Duration {
0000000000000000000000000000000000000000;;		return time.Time(t).Sub(unixEpoch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnixTimeFromSeconds creates a UnixTime as a number of seconds from the UnixEpoch.
0000000000000000000000000000000000000000;;	func NewUnixTimeFromSeconds(seconds float64) UnixTime {
0000000000000000000000000000000000000000;;		return NewUnixTimeFromDuration(time.Duration(seconds * float64(time.Second)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnixTimeFromNanoseconds creates a UnixTime as a number of nanoseconds from the UnixEpoch.
0000000000000000000000000000000000000000;;	func NewUnixTimeFromNanoseconds(nanoseconds int64) UnixTime {
0000000000000000000000000000000000000000;;		return NewUnixTimeFromDuration(time.Duration(nanoseconds))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnixTimeFromDuration creates a UnixTime as a duration of time since the UnixEpoch.
0000000000000000000000000000000000000000;;	func NewUnixTimeFromDuration(dur time.Duration) UnixTime {
0000000000000000000000000000000000000000;;		return UnixTime(unixEpoch.Add(dur))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnixEpoch retreives the moment considered the Unix Epoch. I.e. The time represented by '0'
0000000000000000000000000000000000000000;;	func UnixEpoch() time.Time {
0000000000000000000000000000000000000000;;		return unixEpoch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON preserves the UnixTime as a JSON number conforming to Unix Timestamp requirements.
0000000000000000000000000000000000000000;;	// (i.e. the number of seconds since midnight January 1st, 1970 not considering leap seconds.)
0000000000000000000000000000000000000000;;	func (t UnixTime) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		buffer := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		enc := json.NewEncoder(buffer)
0000000000000000000000000000000000000000;;		err := enc.Encode(float64(time.Time(t).UnixNano()) / 1e9)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buffer.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON reconstitures a UnixTime saved as a JSON number of the number of seconds since
0000000000000000000000000000000000000000;;	// midnight January 1st, 1970.
0000000000000000000000000000000000000000;;	func (t *UnixTime) UnmarshalJSON(text []byte) error {
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(bytes.NewReader(text))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var secondsSinceEpoch float64
0000000000000000000000000000000000000000;;		if err := dec.Decode(&secondsSinceEpoch); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*t = NewUnixTimeFromSeconds(secondsSinceEpoch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalText stores the number of seconds since the Unix Epoch as a textual floating point number.
0000000000000000000000000000000000000000;;	func (t UnixTime) MarshalText() ([]byte, error) {
0000000000000000000000000000000000000000;;		cast := time.Time(t)
0000000000000000000000000000000000000000;;		return cast.MarshalText()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText populates a UnixTime with a value stored textually as a floating point number of seconds since the Unix Epoch.
0000000000000000000000000000000000000000;;	func (t *UnixTime) UnmarshalText(raw []byte) error {
0000000000000000000000000000000000000000;;		var unmarshaled time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := unmarshaled.UnmarshalText(raw); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*t = UnixTime(unmarshaled)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalBinary converts a UnixTime into a binary.LittleEndian float64 of nanoseconds since the epoch.
0000000000000000000000000000000000000000;;	func (t UnixTime) MarshalBinary() ([]byte, error) {
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload := int64(t.Duration())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := binary.Write(buf, binary.LittleEndian, &payload); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalBinary converts a from a binary.LittleEndian float64 of nanoseconds since the epoch into a UnixTime.
0000000000000000000000000000000000000000;;	func (t *UnixTime) UnmarshalBinary(raw []byte) error {
0000000000000000000000000000000000000000;;		var nanosecondsSinceEpoch int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := binary.Read(bytes.NewReader(raw), binary.LittleEndian, &nanosecondsSinceEpoch); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*t = NewUnixTimeFromNanoseconds(nanosecondsSinceEpoch)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
