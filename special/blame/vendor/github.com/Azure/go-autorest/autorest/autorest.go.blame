0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package autorest implements an HTTP request pipeline suitable for use across multiple go-routines
0000000000000000000000000000000000000000;;	and provides the shared routines relied on by AutoRest (see https://github.com/Azure/autorest/)
0000000000000000000000000000000000000000;;	generated Go code.
6d6afa491b422a1e9d1fe39b10df70e4bf5254bf;;	
0000000000000000000000000000000000000000;;	The package breaks sending and responding to HTTP requests into three phases: Preparing, Sending,
0000000000000000000000000000000000000000;;	and Responding. A typical pattern is:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  req, err := Prepare(&http.Request{},
0000000000000000000000000000000000000000;;	    token.WithAuthorization())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  resp, err := Send(req,
0000000000000000000000000000000000000000;;	    WithLogging(logger),
0000000000000000000000000000000000000000;;	    DoErrorIfStatusCode(http.StatusInternalServerError),
0000000000000000000000000000000000000000;;	    DoCloseIfError(),
0000000000000000000000000000000000000000;;	    DoRetryForAttempts(5, time.Second))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  err = Respond(resp,
0000000000000000000000000000000000000000;;	    ByDiscardingBody(),
0000000000000000000000000000000000000000;;	    ByClosing())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Each phase relies on decorators to modify and / or manage processing. Decorators may first modify
0000000000000000000000000000000000000000;;	and then pass the data along, pass the data first and then modify the result, or wrap themselves
0000000000000000000000000000000000000000;;	around passing the data (such as a logger might do). Decorators run in the order provided. For
0000000000000000000000000000000000000000;;	example, the following:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  req, err := Prepare(&http.Request{},
0000000000000000000000000000000000000000;;	    WithBaseURL("https://microsoft.com/"),
0000000000000000000000000000000000000000;;	    WithPath("a"),
0000000000000000000000000000000000000000;;	    WithPath("b"),
0000000000000000000000000000000000000000;;	    WithPath("c"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	will set the URL to:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  https://microsoft.com/a/b/c
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Preparers and Responders may be shared and re-used (assuming the underlying decorators support
0000000000000000000000000000000000000000;;	sharing and re-use). Performant use is obtained by creating one or more Preparers and Responders
0000000000000000000000000000000000000000;;	shared among multiple go-routines, and a single Sender shared among multiple sending go-routines,
0000000000000000000000000000000000000000;;	all bound together by means of input / output channels.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Decorators hold their passed state within a closure (such as the path components in the example
0000000000000000000000000000000000000000;;	above). Be careful to share Preparers and Responders only in a context where such held state
0000000000000000000000000000000000000000;;	applies. For example, it may not make sense to share a Preparer that applies a query string from a
0000000000000000000000000000000000000000;;	fixed set of values. Similarly, sharing a Responder that reads the response body into a passed
0000000000000000000000000000000000000000;;	struct (e.g., ByUnmarshallingJson) is likely incorrect.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Lastly, the Swagger specification (https://swagger.io) that drives AutoRest
0000000000000000000000000000000000000000;;	(https://github.com/Azure/autorest/) precisely defines two date forms: date and date-time. The
0000000000000000000000000000000000000000;;	github.com/Azure/go-autorest/autorest/date package provides time.Time derivations to ensure
0000000000000000000000000000000000000000;;	correct parsing and formatting.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Errors raised by autorest objects and methods will conform to the autorest.Error interface.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the included examples for more detail. For details on the suggested use of this package by
0000000000000000000000000000000000000000;;	generated clients, see the Client described below.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package autorest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// HeaderLocation specifies the HTTP Location header.
0000000000000000000000000000000000000000;;		HeaderLocation = "Location"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HeaderRetryAfter specifies the HTTP Retry-After header.
0000000000000000000000000000000000000000;;		HeaderRetryAfter = "Retry-After"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResponseHasStatusCode returns true if the status code in the HTTP Response is in the passed set
0000000000000000000000000000000000000000;;	// and false otherwise.
0000000000000000000000000000000000000000;;	func ResponseHasStatusCode(resp *http.Response, codes ...int) bool {
0000000000000000000000000000000000000000;;		return containsInt(codes, resp.StatusCode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLocation retrieves the URL from the Location header of the passed response.
0000000000000000000000000000000000000000;;	func GetLocation(resp *http.Response) string {
0000000000000000000000000000000000000000;;		return resp.Header.Get(HeaderLocation)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRetryAfter extracts the retry delay from the Retry-After header of the passed response. If
0000000000000000000000000000000000000000;;	// the header is absent or is malformed, it will return the supplied default delay time.Duration.
0000000000000000000000000000000000000000;;	func GetRetryAfter(resp *http.Response, defaultDelay time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		retry := resp.Header.Get(HeaderRetryAfter)
0000000000000000000000000000000000000000;;		if retry == "" {
0000000000000000000000000000000000000000;;			return defaultDelay
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d, err := time.ParseDuration(retry + "s")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return defaultDelay
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPollingRequest allocates and returns a new http.Request to poll for the passed response.
0000000000000000000000000000000000000000;;	func NewPollingRequest(resp *http.Response, cancel <-chan struct{}) (*http.Request, error) {
0000000000000000000000000000000000000000;;		location := GetLocation(resp)
0000000000000000000000000000000000000000;;		if location == "" {
0000000000000000000000000000000000000000;;			return nil, NewErrorWithResponse("autorest", "NewPollingRequest", resp, "Location header missing from response that requires polling")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := Prepare(&http.Request{Cancel: cancel},
0000000000000000000000000000000000000000;;			AsGet(),
0000000000000000000000000000000000000000;;			WithBaseURL(location))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, NewErrorWithError(err, "autorest", "NewPollingRequest", nil, "Failure creating poll request to %s", location)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return req, nil
0000000000000000000000000000000000000000;;	}
