0000000000000000000000000000000000000000;;	// +build linux
7705525676c084977ab2c91c258d64e7a74b651a;Godeps/_workspace/src/github.com/seccomp/libseccomp-golang/seccomp.go[Godeps/_workspace/src/github.com/seccomp/libseccomp-golang/seccomp.go][vendor/github.com/seccomp/libseccomp-golang/seccomp.go];	
0000000000000000000000000000000000000000;;	// Public API specification for libseccomp Go bindings
0000000000000000000000000000000000000000;;	// Contains public API for the bindings
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package seccomp rovides bindings for libseccomp, a library wrapping the Linux
0000000000000000000000000000000000000000;;	// seccomp syscall. Seccomp enables an application to restrict system call use
0000000000000000000000000000000000000000;;	// for itself and its children.
0000000000000000000000000000000000000000;;	package seccomp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// C wrapping code
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// #cgo LDFLAGS: -lseccomp
0000000000000000000000000000000000000000;;	// #include <stdlib.h>
0000000000000000000000000000000000000000;;	// #include <seccomp.h>
0000000000000000000000000000000000000000;;	import "C"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exported types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScmpArch represents a CPU architecture. Seccomp can restrict syscalls on a
0000000000000000000000000000000000000000;;	// per-architecture basis.
0000000000000000000000000000000000000000;;	type ScmpArch uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScmpAction represents an action to be taken on a filter rule match in
0000000000000000000000000000000000000000;;	// libseccomp
0000000000000000000000000000000000000000;;	type ScmpAction uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScmpCompareOp represents a comparison operator which can be used in a filter
0000000000000000000000000000000000000000;;	// rule
0000000000000000000000000000000000000000;;	type ScmpCompareOp uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScmpCondition represents a rule in a libseccomp filter context
0000000000000000000000000000000000000000;;	type ScmpCondition struct {
0000000000000000000000000000000000000000;;		Argument uint          `json:"argument,omitempty"`
0000000000000000000000000000000000000000;;		Op       ScmpCompareOp `json:"operator,omitempty"`
0000000000000000000000000000000000000000;;		Operand1 uint64        `json:"operand_one,omitempty"`
0000000000000000000000000000000000000000;;		Operand2 uint64        `json:"operand_two,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScmpSyscall represents a Linux System Call
0000000000000000000000000000000000000000;;	type ScmpSyscall int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exported Constants
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Valid architectures recognized by libseccomp
0000000000000000000000000000000000000000;;		// ARM64 and all MIPS architectures are unsupported by versions of the
0000000000000000000000000000000000000000;;		// library before v2.2 and will return errors if used
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ArchInvalid is a placeholder to ensure uninitialized ScmpArch
0000000000000000000000000000000000000000;;		// variables are invalid
0000000000000000000000000000000000000000;;		ArchInvalid ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchNative is the native architecture of the kernel
0000000000000000000000000000000000000000;;		ArchNative ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchX86 represents 32-bit x86 syscalls
0000000000000000000000000000000000000000;;		ArchX86 ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchAMD64 represents 64-bit x86-64 syscalls
0000000000000000000000000000000000000000;;		ArchAMD64 ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchX32 represents 64-bit x86-64 syscalls (32-bit pointers)
0000000000000000000000000000000000000000;;		ArchX32 ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchARM represents 32-bit ARM syscalls
0000000000000000000000000000000000000000;;		ArchARM ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchARM64 represents 64-bit ARM syscalls
0000000000000000000000000000000000000000;;		ArchARM64 ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchMIPS represents 32-bit MIPS syscalls
0000000000000000000000000000000000000000;;		ArchMIPS ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchMIPS64 represents 64-bit MIPS syscalls
0000000000000000000000000000000000000000;;		ArchMIPS64 ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchMIPS64N32 represents 64-bit MIPS syscalls (32-bit pointers)
0000000000000000000000000000000000000000;;		ArchMIPS64N32 ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchMIPSEL represents 32-bit MIPS syscalls (little endian)
0000000000000000000000000000000000000000;;		ArchMIPSEL ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchMIPSEL64 represents 64-bit MIPS syscalls (little endian)
0000000000000000000000000000000000000000;;		ArchMIPSEL64 ScmpArch = iota
0000000000000000000000000000000000000000;;		// ArchMIPSEL64N32 represents 64-bit MIPS syscalls (little endian,
0000000000000000000000000000000000000000;;		// 32-bit pointers)
0000000000000000000000000000000000000000;;		ArchMIPSEL64N32 ScmpArch = iota
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Supported actions on filter match
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ActInvalid is a placeholder to ensure uninitialized ScmpAction
0000000000000000000000000000000000000000;;		// variables are invalid
0000000000000000000000000000000000000000;;		ActInvalid ScmpAction = iota
0000000000000000000000000000000000000000;;		// ActKill kills the process
0000000000000000000000000000000000000000;;		ActKill ScmpAction = iota
0000000000000000000000000000000000000000;;		// ActTrap throws SIGSYS
0000000000000000000000000000000000000000;;		ActTrap ScmpAction = iota
0000000000000000000000000000000000000000;;		// ActErrno causes the syscall to return a negative error code. This
0000000000000000000000000000000000000000;;		// code can be set with the SetReturnCode method
0000000000000000000000000000000000000000;;		ActErrno ScmpAction = iota
0000000000000000000000000000000000000000;;		// ActTrace causes the syscall to notify tracing processes with the
0000000000000000000000000000000000000000;;		// given error code. This code can be set with the SetReturnCode method
0000000000000000000000000000000000000000;;		ActTrace ScmpAction = iota
0000000000000000000000000000000000000000;;		// ActAllow permits the syscall to continue execution
0000000000000000000000000000000000000000;;		ActAllow ScmpAction = iota
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// These are comparison operators used in conditional seccomp rules
0000000000000000000000000000000000000000;;		// They are used to compare the value of a single argument of a syscall
0000000000000000000000000000000000000000;;		// against a user-defined constant
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CompareInvalid is a placeholder to ensure uninitialized ScmpCompareOp
0000000000000000000000000000000000000000;;		// variables are invalid
0000000000000000000000000000000000000000;;		CompareInvalid ScmpCompareOp = iota
0000000000000000000000000000000000000000;;		// CompareNotEqual returns true if the argument is not equal to the
0000000000000000000000000000000000000000;;		// given value
0000000000000000000000000000000000000000;;		CompareNotEqual ScmpCompareOp = iota
0000000000000000000000000000000000000000;;		// CompareLess returns true if the argument is less than the given value
0000000000000000000000000000000000000000;;		CompareLess ScmpCompareOp = iota
0000000000000000000000000000000000000000;;		// CompareLessOrEqual returns true if the argument is less than or equal
0000000000000000000000000000000000000000;;		// to the given value
0000000000000000000000000000000000000000;;		CompareLessOrEqual ScmpCompareOp = iota
0000000000000000000000000000000000000000;;		// CompareEqual returns true if the argument is equal to the given value
0000000000000000000000000000000000000000;;		CompareEqual ScmpCompareOp = iota
0000000000000000000000000000000000000000;;		// CompareGreaterEqual returns true if the argument is greater than or
0000000000000000000000000000000000000000;;		// equal to the given value
0000000000000000000000000000000000000000;;		CompareGreaterEqual ScmpCompareOp = iota
0000000000000000000000000000000000000000;;		// CompareGreater returns true if the argument is greater than the given
0000000000000000000000000000000000000000;;		// value
0000000000000000000000000000000000000000;;		CompareGreater ScmpCompareOp = iota
0000000000000000000000000000000000000000;;		// CompareMaskedEqual returns true if the argument is equal to the given
0000000000000000000000000000000000000000;;		// value, when masked (bitwise &) against the second given value
0000000000000000000000000000000000000000;;		CompareMaskedEqual ScmpCompareOp = iota
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helpers for types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetArchFromString returns an ScmpArch constant from a string representing an
0000000000000000000000000000000000000000;;	// architecture
0000000000000000000000000000000000000000;;	func GetArchFromString(arch string) (ScmpArch, error) {
0000000000000000000000000000000000000000;;		switch strings.ToLower(arch) {
0000000000000000000000000000000000000000;;		case "x86":
0000000000000000000000000000000000000000;;			return ArchX86, nil
0000000000000000000000000000000000000000;;		case "amd64", "x86-64", "x86_64", "x64":
0000000000000000000000000000000000000000;;			return ArchAMD64, nil
0000000000000000000000000000000000000000;;		case "x32":
0000000000000000000000000000000000000000;;			return ArchX32, nil
0000000000000000000000000000000000000000;;		case "arm":
0000000000000000000000000000000000000000;;			return ArchARM, nil
0000000000000000000000000000000000000000;;		case "arm64", "aarch64":
0000000000000000000000000000000000000000;;			return ArchARM64, nil
0000000000000000000000000000000000000000;;		case "mips":
0000000000000000000000000000000000000000;;			return ArchMIPS, nil
0000000000000000000000000000000000000000;;		case "mips64":
0000000000000000000000000000000000000000;;			return ArchMIPS64, nil
0000000000000000000000000000000000000000;;		case "mips64n32":
0000000000000000000000000000000000000000;;			return ArchMIPS64N32, nil
0000000000000000000000000000000000000000;;		case "mipsel":
0000000000000000000000000000000000000000;;			return ArchMIPSEL, nil
0000000000000000000000000000000000000000;;		case "mipsel64":
0000000000000000000000000000000000000000;;			return ArchMIPSEL64, nil
0000000000000000000000000000000000000000;;		case "mipsel64n32":
0000000000000000000000000000000000000000;;			return ArchMIPSEL64N32, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ArchInvalid, fmt.Errorf("cannot convert unrecognized string %s", arch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of an architecture constant
0000000000000000000000000000000000000000;;	func (a ScmpArch) String() string {
0000000000000000000000000000000000000000;;		switch a {
0000000000000000000000000000000000000000;;		case ArchX86:
0000000000000000000000000000000000000000;;			return "x86"
0000000000000000000000000000000000000000;;		case ArchAMD64:
0000000000000000000000000000000000000000;;			return "amd64"
0000000000000000000000000000000000000000;;		case ArchX32:
0000000000000000000000000000000000000000;;			return "x32"
0000000000000000000000000000000000000000;;		case ArchARM:
0000000000000000000000000000000000000000;;			return "arm"
0000000000000000000000000000000000000000;;		case ArchARM64:
0000000000000000000000000000000000000000;;			return "arm64"
0000000000000000000000000000000000000000;;		case ArchMIPS:
0000000000000000000000000000000000000000;;			return "mips"
0000000000000000000000000000000000000000;;		case ArchMIPS64:
0000000000000000000000000000000000000000;;			return "mips64"
0000000000000000000000000000000000000000;;		case ArchMIPS64N32:
0000000000000000000000000000000000000000;;			return "mips64n32"
0000000000000000000000000000000000000000;;		case ArchMIPSEL:
0000000000000000000000000000000000000000;;			return "mipsel"
0000000000000000000000000000000000000000;;		case ArchMIPSEL64:
0000000000000000000000000000000000000000;;			return "mipsel64"
0000000000000000000000000000000000000000;;		case ArchMIPSEL64N32:
0000000000000000000000000000000000000000;;			return "mipsel64n32"
0000000000000000000000000000000000000000;;		case ArchNative:
0000000000000000000000000000000000000000;;			return "native"
0000000000000000000000000000000000000000;;		case ArchInvalid:
0000000000000000000000000000000000000000;;			return "Invalid architecture"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "Unknown architecture"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of a comparison operator constant
0000000000000000000000000000000000000000;;	func (a ScmpCompareOp) String() string {
0000000000000000000000000000000000000000;;		switch a {
0000000000000000000000000000000000000000;;		case CompareNotEqual:
0000000000000000000000000000000000000000;;			return "Not equal"
0000000000000000000000000000000000000000;;		case CompareLess:
0000000000000000000000000000000000000000;;			return "Less than"
0000000000000000000000000000000000000000;;		case CompareLessOrEqual:
0000000000000000000000000000000000000000;;			return "Less than or equal to"
0000000000000000000000000000000000000000;;		case CompareEqual:
0000000000000000000000000000000000000000;;			return "Equal"
0000000000000000000000000000000000000000;;		case CompareGreaterEqual:
0000000000000000000000000000000000000000;;			return "Greater than or equal to"
0000000000000000000000000000000000000000;;		case CompareGreater:
0000000000000000000000000000000000000000;;			return "Greater than"
0000000000000000000000000000000000000000;;		case CompareMaskedEqual:
0000000000000000000000000000000000000000;;			return "Masked equality"
0000000000000000000000000000000000000000;;		case CompareInvalid:
0000000000000000000000000000000000000000;;			return "Invalid comparison operator"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "Unrecognized comparison operator"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of a seccomp match action
0000000000000000000000000000000000000000;;	func (a ScmpAction) String() string {
0000000000000000000000000000000000000000;;		switch a & 0xFFFF {
0000000000000000000000000000000000000000;;		case ActKill:
0000000000000000000000000000000000000000;;			return "Action: Kill Process"
0000000000000000000000000000000000000000;;		case ActTrap:
0000000000000000000000000000000000000000;;			return "Action: Send SIGSYS"
0000000000000000000000000000000000000000;;		case ActErrno:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Action: Return error code %d", (a >> 16))
0000000000000000000000000000000000000000;;		case ActTrace:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Action: Notify tracing processes with code %d",
0000000000000000000000000000000000000000;;				(a >> 16))
0000000000000000000000000000000000000000;;		case ActAllow:
0000000000000000000000000000000000000000;;			return "Action: Allow system call"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "Unrecognized Action"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReturnCode adds a return code to a supporting ScmpAction, clearing any
0000000000000000000000000000000000000000;;	// existing code Only valid on ActErrno and ActTrace. Takes no action otherwise.
0000000000000000000000000000000000000000;;	// Accepts 16-bit return code as argument.
0000000000000000000000000000000000000000;;	// Returns a valid ScmpAction of the original type with the new error code set.
0000000000000000000000000000000000000000;;	func (a ScmpAction) SetReturnCode(code int16) ScmpAction {
0000000000000000000000000000000000000000;;		aTmp := a & 0x0000FFFF
0000000000000000000000000000000000000000;;		if aTmp == ActErrno || aTmp == ActTrace {
0000000000000000000000000000000000000000;;			return (aTmp | (ScmpAction(code)&0xFFFF)<<16)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetReturnCode returns the return code of an ScmpAction
0000000000000000000000000000000000000000;;	func (a ScmpAction) GetReturnCode() int16 {
0000000000000000000000000000000000000000;;		return int16(a >> 16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// General utility functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLibraryVersion returns the version of the library the bindings are built
0000000000000000000000000000000000000000;;	// against.
0000000000000000000000000000000000000000;;	// The version is formatted as follows: Major.Minor.Micro
0000000000000000000000000000000000000000;;	func GetLibraryVersion() (major, minor, micro int) {
0000000000000000000000000000000000000000;;		return verMajor, verMinor, verMicro
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Syscall functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetName retrieves the name of a syscall from its number.
0000000000000000000000000000000000000000;;	// Acts on any syscall number.
0000000000000000000000000000000000000000;;	// Returns either a string containing the name of the syscall, or an error.
0000000000000000000000000000000000000000;;	func (s ScmpSyscall) GetName() (string, error) {
0000000000000000000000000000000000000000;;		return s.GetNameByArch(ArchNative)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNameByArch retrieves the name of a syscall from its number for a given
0000000000000000000000000000000000000000;;	// architecture.
0000000000000000000000000000000000000000;;	// Acts on any syscall number.
0000000000000000000000000000000000000000;;	// Accepts a valid architecture constant.
0000000000000000000000000000000000000000;;	// Returns either a string containing the name of the syscall, or an error.
0000000000000000000000000000000000000000;;	// if the syscall is unrecognized or an issue occurred.
0000000000000000000000000000000000000000;;	func (s ScmpSyscall) GetNameByArch(arch ScmpArch) (string, error) {
0000000000000000000000000000000000000000;;		if err := sanitizeArch(arch); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cString := C.seccomp_syscall_resolve_num_arch(arch.toNative(), C.int(s))
0000000000000000000000000000000000000000;;		if cString == nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("could not resolve syscall name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer C.free(unsafe.Pointer(cString))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		finalStr := C.GoString(cString)
0000000000000000000000000000000000000000;;		return finalStr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSyscallFromName returns the number of a syscall by name on the kernel's
0000000000000000000000000000000000000000;;	// native architecture.
0000000000000000000000000000000000000000;;	// Accepts a string containing the name of a syscall.
0000000000000000000000000000000000000000;;	// Returns the number of the syscall, or an error if no syscall with that name
0000000000000000000000000000000000000000;;	// was found.
0000000000000000000000000000000000000000;;	func GetSyscallFromName(name string) (ScmpSyscall, error) {
0000000000000000000000000000000000000000;;		cString := C.CString(name)
0000000000000000000000000000000000000000;;		defer C.free(unsafe.Pointer(cString))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := C.seccomp_syscall_resolve_name(cString)
0000000000000000000000000000000000000000;;		if result == scmpError {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("could not resolve name to syscall")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ScmpSyscall(result), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSyscallFromNameByArch returns the number of a syscall by name for a given
0000000000000000000000000000000000000000;;	// architecture's ABI.
0000000000000000000000000000000000000000;;	// Accepts the name of a syscall and an architecture constant.
0000000000000000000000000000000000000000;;	// Returns the number of the syscall, or an error if an invalid architecture is
0000000000000000000000000000000000000000;;	// passed or a syscall with that name was not found.
0000000000000000000000000000000000000000;;	func GetSyscallFromNameByArch(name string, arch ScmpArch) (ScmpSyscall, error) {
0000000000000000000000000000000000000000;;		if err := sanitizeArch(arch); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cString := C.CString(name)
0000000000000000000000000000000000000000;;		defer C.free(unsafe.Pointer(cString))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := C.seccomp_syscall_resolve_name_arch(arch.toNative(), cString)
0000000000000000000000000000000000000000;;		if result == scmpError {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("could not resolve name to syscall")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ScmpSyscall(result), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeCondition creates and returns a new condition to attach to a filter rule.
0000000000000000000000000000000000000000;;	// Associated rules will only match if this condition is true.
0000000000000000000000000000000000000000;;	// Accepts the number the argument we are checking, and a comparison operator
0000000000000000000000000000000000000000;;	// and value to compare to.
0000000000000000000000000000000000000000;;	// The rule will match if argument $arg (zero-indexed) of the syscall is
0000000000000000000000000000000000000000;;	// $COMPARE_OP the provided comparison value.
0000000000000000000000000000000000000000;;	// Some comparison operators accept two values. Masked equals, for example,
0000000000000000000000000000000000000000;;	// will mask $arg of the syscall with the second value provided (via bitwise
0000000000000000000000000000000000000000;;	// AND) and then compare against the first value provided.
0000000000000000000000000000000000000000;;	// For example, in the less than or equal case, if the syscall argument was
0000000000000000000000000000000000000000;;	// 0 and the value provided was 1, the condition would match, as 0 is less
0000000000000000000000000000000000000000;;	// than or equal to 1.
0000000000000000000000000000000000000000;;	// Return either an error on bad argument or a valid ScmpCondition struct.
0000000000000000000000000000000000000000;;	func MakeCondition(arg uint, comparison ScmpCompareOp, values ...uint64) (ScmpCondition, error) {
0000000000000000000000000000000000000000;;		var condStruct ScmpCondition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if comparison == CompareInvalid {
0000000000000000000000000000000000000000;;			return condStruct, fmt.Errorf("invalid comparison operator")
0000000000000000000000000000000000000000;;		} else if arg > 5 {
0000000000000000000000000000000000000000;;			return condStruct, fmt.Errorf("syscalls only have up to 6 arguments")
0000000000000000000000000000000000000000;;		} else if len(values) > 2 {
0000000000000000000000000000000000000000;;			return condStruct, fmt.Errorf("conditions can have at most 2 arguments")
0000000000000000000000000000000000000000;;		} else if len(values) == 0 {
0000000000000000000000000000000000000000;;			return condStruct, fmt.Errorf("must provide at least one value to compare against")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		condStruct.Argument = arg
0000000000000000000000000000000000000000;;		condStruct.Op = comparison
0000000000000000000000000000000000000000;;		condStruct.Operand1 = values[0]
0000000000000000000000000000000000000000;;		if len(values) == 2 {
0000000000000000000000000000000000000000;;			condStruct.Operand2 = values[1]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			condStruct.Operand2 = 0 // Unused
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return condStruct, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Utility Functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNativeArch returns architecture token representing the native kernel
0000000000000000000000000000000000000000;;	// architecture
0000000000000000000000000000000000000000;;	func GetNativeArch() (ScmpArch, error) {
0000000000000000000000000000000000000000;;		arch := C.seccomp_arch_native()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return archFromNative(arch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Public Filter API
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScmpFilter represents a filter context in libseccomp.
0000000000000000000000000000000000000000;;	// A filter context is initially empty. Rules can be added to it, and it can
0000000000000000000000000000000000000000;;	// then be loaded into the kernel.
0000000000000000000000000000000000000000;;	type ScmpFilter struct {
0000000000000000000000000000000000000000;;		filterCtx C.scmp_filter_ctx
0000000000000000000000000000000000000000;;		valid     bool
0000000000000000000000000000000000000000;;		lock      sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFilter creates and returns a new filter context.
0000000000000000000000000000000000000000;;	// Accepts a default action to be taken for syscalls which match no rules in
0000000000000000000000000000000000000000;;	// the filter.
0000000000000000000000000000000000000000;;	// Returns a reference to a valid filter context, or nil and an error if the
0000000000000000000000000000000000000000;;	// filter context could not be created or an invalid default action was given.
0000000000000000000000000000000000000000;;	func NewFilter(defaultAction ScmpAction) (*ScmpFilter, error) {
0000000000000000000000000000000000000000;;		if err := sanitizeAction(defaultAction); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fPtr := C.seccomp_init(defaultAction.toNative())
0000000000000000000000000000000000000000;;		if fPtr == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("could not create filter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filter := new(ScmpFilter)
0000000000000000000000000000000000000000;;		filter.filterCtx = fPtr
0000000000000000000000000000000000000000;;		filter.valid = true
0000000000000000000000000000000000000000;;		runtime.SetFinalizer(filter, filterFinalizer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filter, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid determines whether a filter context is valid to use.
0000000000000000000000000000000000000000;;	// Some operations (Release and Merge) render filter contexts invalid and
0000000000000000000000000000000000000000;;	// consequently prevent further use.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) IsValid() bool {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.valid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets a filter context, removing all its existing state.
0000000000000000000000000000000000000000;;	// Accepts a new default action to be taken for syscalls which do not match.
0000000000000000000000000000000000000000;;	// Returns an error if the filter or action provided are invalid.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) Reset(defaultAction ScmpAction) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := sanitizeAction(defaultAction); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retCode := C.seccomp_reset(f.filterCtx, defaultAction.toNative())
0000000000000000000000000000000000000000;;		if retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release releases a filter context, freeing its memory. Should be called after
0000000000000000000000000000000000000000;;	// loading into the kernel, when the filter is no longer needed.
0000000000000000000000000000000000000000;;	// After calling this function, the given filter is no longer valid and cannot
0000000000000000000000000000000000000000;;	// be used.
0000000000000000000000000000000000000000;;	// Release() will be invoked automatically when a filter context is garbage
0000000000000000000000000000000000000000;;	// collected, but can also be called manually to free memory.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) Release() {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.valid = false
0000000000000000000000000000000000000000;;		C.seccomp_release(f.filterCtx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge merges two filter contexts.
0000000000000000000000000000000000000000;;	// The source filter src will be released as part of the process, and will no
0000000000000000000000000000000000000000;;	// longer be usable or valid after this call.
0000000000000000000000000000000000000000;;	// To be merged, filters must NOT share any architectures, and all their
0000000000000000000000000000000000000000;;	// attributes (Default Action, Bad Arch Action, No New Privs and TSync bools)
0000000000000000000000000000000000000000;;	// must match.
0000000000000000000000000000000000000000;;	// The filter src will be merged into the filter this is called on.
0000000000000000000000000000000000000000;;	// The architectures of the src filter not present in the destination, and all
0000000000000000000000000000000000000000;;	// associated rules, will be added to the destination.
0000000000000000000000000000000000000000;;	// Returns an error if merging the filters failed.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) Merge(src *ScmpFilter) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src.lock.Lock()
0000000000000000000000000000000000000000;;		defer src.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !src.valid || !f.valid {
0000000000000000000000000000000000000000;;			return fmt.Errorf("one or more of the filter contexts is invalid or uninitialized")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Merge the filters
0000000000000000000000000000000000000000;;		retCode := C.seccomp_merge(f.filterCtx, src.filterCtx)
0000000000000000000000000000000000000000;;		if syscall.Errno(-1*retCode) == syscall.EINVAL {
0000000000000000000000000000000000000000;;			return fmt.Errorf("filters could not be merged due to a mismatch in attributes or invalid filter")
0000000000000000000000000000000000000000;;		} else if retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src.valid = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsArchPresent checks if an architecture is present in a filter.
0000000000000000000000000000000000000000;;	// If a filter contains an architecture, it uses its default action for
0000000000000000000000000000000000000000;;	// syscalls which do not match rules in it, and its rules can match syscalls
0000000000000000000000000000000000000000;;	// for that ABI.
0000000000000000000000000000000000000000;;	// If a filter does not contain an architecture, all syscalls made to that
0000000000000000000000000000000000000000;;	// kernel ABI will fail with the filter's default Bad Architecture Action
0000000000000000000000000000000000000000;;	// (by default, killing the process).
0000000000000000000000000000000000000000;;	// Accepts an architecture constant.
0000000000000000000000000000000000000000;;	// Returns true if the architecture is present in the filter, false otherwise,
0000000000000000000000000000000000000000;;	// and an error on an invalid filter context, architecture constant, or an
0000000000000000000000000000000000000000;;	// issue with the call to libseccomp.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) IsArchPresent(arch ScmpArch) (bool, error) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := sanitizeArch(arch); err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		} else if !f.valid {
0000000000000000000000000000000000000000;;			return false, errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retCode := C.seccomp_arch_exist(f.filterCtx, arch.toNative())
0000000000000000000000000000000000000000;;		if syscall.Errno(-1*retCode) == syscall.EEXIST {
0000000000000000000000000000000000000000;;			// -EEXIST is "arch not present"
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		} else if retCode != 0 {
0000000000000000000000000000000000000000;;			return false, syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddArch adds an architecture to the filter.
0000000000000000000000000000000000000000;;	// Accepts an architecture constant.
0000000000000000000000000000000000000000;;	// Returns an error on invalid filter context or architecture token, or an
0000000000000000000000000000000000000000;;	// issue with the call to libseccomp.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) AddArch(arch ScmpArch) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := sanitizeArch(arch); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Libseccomp returns -EEXIST if the specified architecture is already
0000000000000000000000000000000000000000;;		// present. Succeed silently in this case, as it's not fatal, and the
0000000000000000000000000000000000000000;;		// architecture is present already.
0000000000000000000000000000000000000000;;		retCode := C.seccomp_arch_add(f.filterCtx, arch.toNative())
0000000000000000000000000000000000000000;;		if retCode != 0 && syscall.Errno(-1*retCode) != syscall.EEXIST {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveArch removes an architecture from the filter.
0000000000000000000000000000000000000000;;	// Accepts an architecture constant.
0000000000000000000000000000000000000000;;	// Returns an error on invalid filter context or architecture token, or an
0000000000000000000000000000000000000000;;	// issue with the call to libseccomp.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) RemoveArch(arch ScmpArch) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := sanitizeArch(arch); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Similar to AddArch, -EEXIST is returned if the arch is not present
0000000000000000000000000000000000000000;;		// Succeed silently in that case, this is not fatal and the architecture
0000000000000000000000000000000000000000;;		// is not present in the filter after RemoveArch
0000000000000000000000000000000000000000;;		retCode := C.seccomp_arch_remove(f.filterCtx, arch.toNative())
0000000000000000000000000000000000000000;;		if retCode != 0 && syscall.Errno(-1*retCode) != syscall.EEXIST {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load loads a filter context into the kernel.
0000000000000000000000000000000000000000;;	// Returns an error if the filter context is invalid or the syscall failed.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) Load() error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if retCode := C.seccomp_load(f.filterCtx); retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDefaultAction returns the default action taken on a syscall which does not
0000000000000000000000000000000000000000;;	// match a rule in the filter, or an error if an issue was encountered
0000000000000000000000000000000000000000;;	// retrieving the value.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) GetDefaultAction() (ScmpAction, error) {
0000000000000000000000000000000000000000;;		action, err := f.getFilterAttr(filterAttrActDefault)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0x0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return actionFromNative(action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBadArchAction returns the default action taken on a syscall for an
0000000000000000000000000000000000000000;;	// architecture not in the filter, or an error if an issue was encountered
0000000000000000000000000000000000000000;;	// retrieving the value.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) GetBadArchAction() (ScmpAction, error) {
0000000000000000000000000000000000000000;;		action, err := f.getFilterAttr(filterAttrActBadArch)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0x0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return actionFromNative(action)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNoNewPrivsBit returns the current state the No New Privileges bit will be set
0000000000000000000000000000000000000000;;	// to on the filter being loaded, or an error if an issue was encountered
0000000000000000000000000000000000000000;;	// retrieving the value.
0000000000000000000000000000000000000000;;	// The No New Privileges bit tells the kernel that new processes run with exec()
0000000000000000000000000000000000000000;;	// cannot gain more privileges than the process that ran exec().
0000000000000000000000000000000000000000;;	// For example, a process with No New Privileges set would be unable to exec
0000000000000000000000000000000000000000;;	// setuid/setgid executables.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) GetNoNewPrivsBit() (bool, error) {
0000000000000000000000000000000000000000;;		noNewPrivs, err := f.getFilterAttr(filterAttrNNP)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if noNewPrivs == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTsyncBit returns whether Thread Synchronization will be enabled on the
0000000000000000000000000000000000000000;;	// filter being loaded, or an error if an issue was encountered retrieving the
0000000000000000000000000000000000000000;;	// value.
0000000000000000000000000000000000000000;;	// Thread Sync ensures that all members of the thread group of the calling
0000000000000000000000000000000000000000;;	// process will share the same Seccomp filter set.
0000000000000000000000000000000000000000;;	// Tsync is a fairly recent addition to the Linux kernel and older kernels
0000000000000000000000000000000000000000;;	// lack support. If the running kernel does not support Tsync and it is
0000000000000000000000000000000000000000;;	// requested in a filter, Libseccomp will not enable TSync support and will
0000000000000000000000000000000000000000;;	// proceed as normal.
0000000000000000000000000000000000000000;;	// This function is unavailable before v2.2 of libseccomp and will return an
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) GetTsyncBit() (bool, error) {
0000000000000000000000000000000000000000;;		tSync, err := f.getFilterAttr(filterAttrTsync)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tSync == 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBadArchAction sets the default action taken on a syscall for an
0000000000000000000000000000000000000000;;	// architecture not in the filter, or an error if an issue was encountered
0000000000000000000000000000000000000000;;	// setting the value.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) SetBadArchAction(action ScmpAction) error {
0000000000000000000000000000000000000000;;		if err := sanitizeAction(action); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.setFilterAttr(filterAttrActBadArch, action.toNative())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetNoNewPrivsBit sets the state of the No New Privileges bit, which will be
0000000000000000000000000000000000000000;;	// applied on filter load, or an error if an issue was encountered setting the
0000000000000000000000000000000000000000;;	// value.
0000000000000000000000000000000000000000;;	// Filters with No New Privileges set to 0 can only be loaded if the process
0000000000000000000000000000000000000000;;	// has the CAP_SYS_ADMIN capability.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) SetNoNewPrivsBit(state bool) error {
0000000000000000000000000000000000000000;;		var toSet C.uint32_t = 0x0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if state {
0000000000000000000000000000000000000000;;			toSet = 0x1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.setFilterAttr(filterAttrNNP, toSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTsync sets whether Thread Synchronization will be enabled on the filter
0000000000000000000000000000000000000000;;	// being loaded. Returns an error if setting Tsync failed, or the filter is
0000000000000000000000000000000000000000;;	// invalid.
0000000000000000000000000000000000000000;;	// Thread Sync ensures that all members of the thread group of the calling
0000000000000000000000000000000000000000;;	// process will share the same Seccomp filter set.
0000000000000000000000000000000000000000;;	// Tsync is a fairly recent addition to the Linux kernel and older kernels
0000000000000000000000000000000000000000;;	// lack support. If the running kernel does not support Tsync and it is
0000000000000000000000000000000000000000;;	// requested in a filter, Libseccomp will not enable TSync support and will
0000000000000000000000000000000000000000;;	// proceed as normal.
0000000000000000000000000000000000000000;;	// This function is unavailable before v2.2 of libseccomp and will return an
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) SetTsync(enable bool) error {
0000000000000000000000000000000000000000;;		var toSet C.uint32_t = 0x0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if enable {
0000000000000000000000000000000000000000;;			toSet = 0x1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.setFilterAttr(filterAttrTsync, toSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetSyscallPriority sets a syscall's priority.
0000000000000000000000000000000000000000;;	// This provides a hint to the filter generator in libseccomp about the
0000000000000000000000000000000000000000;;	// importance of this syscall. High-priority syscalls are placed
0000000000000000000000000000000000000000;;	// first in the filter code, and incur less overhead (at the expense of
0000000000000000000000000000000000000000;;	// lower-priority syscalls).
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) SetSyscallPriority(call ScmpSyscall, priority uint8) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if retCode := C.seccomp_syscall_priority(f.filterCtx, C.int(call),
0000000000000000000000000000000000000000;;			C.uint8_t(priority)); retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddRule adds a single rule for an unconditional action on a syscall.
0000000000000000000000000000000000000000;;	// Accepts the number of the syscall and the action to be taken on the call
0000000000000000000000000000000000000000;;	// being made.
0000000000000000000000000000000000000000;;	// Returns an error if an issue was encountered adding the rule.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) AddRule(call ScmpSyscall, action ScmpAction) error {
0000000000000000000000000000000000000000;;		return f.addRuleGeneric(call, action, false, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddRuleExact adds a single rule for an unconditional action on a syscall.
0000000000000000000000000000000000000000;;	// Accepts the number of the syscall and the action to be taken on the call
0000000000000000000000000000000000000000;;	// being made.
0000000000000000000000000000000000000000;;	// No modifications will be made to the rule, and it will fail to add if it
0000000000000000000000000000000000000000;;	// cannot be applied to the current architecture without modification.
0000000000000000000000000000000000000000;;	// The rule will function exactly as described, but it may not function identically
0000000000000000000000000000000000000000;;	// (or be able to be applied to) all architectures.
0000000000000000000000000000000000000000;;	// Returns an error if an issue was encountered adding the rule.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) AddRuleExact(call ScmpSyscall, action ScmpAction) error {
0000000000000000000000000000000000000000;;		return f.addRuleGeneric(call, action, true, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddRuleConditional adds a single rule for a conditional action on a syscall.
0000000000000000000000000000000000000000;;	// Returns an error if an issue was encountered adding the rule.
0000000000000000000000000000000000000000;;	// All conditions must match for the rule to match.
0000000000000000000000000000000000000000;;	// There is a bug in library versions below v2.2.1 which can, in some cases,
0000000000000000000000000000000000000000;;	// cause conditions to be lost when more than one are used. Consequently,
0000000000000000000000000000000000000000;;	// AddRuleConditional is disabled on library versions lower than v2.2.1
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) AddRuleConditional(call ScmpSyscall, action ScmpAction, conds []ScmpCondition) error {
0000000000000000000000000000000000000000;;		return f.addRuleGeneric(call, action, false, conds)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddRuleConditionalExact adds a single rule for a conditional action on a
0000000000000000000000000000000000000000;;	// syscall.
0000000000000000000000000000000000000000;;	// No modifications will be made to the rule, and it will fail to add if it
0000000000000000000000000000000000000000;;	// cannot be applied to the current architecture without modification.
0000000000000000000000000000000000000000;;	// The rule will function exactly as described, but it may not function identically
0000000000000000000000000000000000000000;;	// (or be able to be applied to) all architectures.
0000000000000000000000000000000000000000;;	// Returns an error if an issue was encountered adding the rule.
0000000000000000000000000000000000000000;;	// There is a bug in library versions below v2.2.1 which can, in some cases,
0000000000000000000000000000000000000000;;	// cause conditions to be lost when more than one are used. Consequently,
0000000000000000000000000000000000000000;;	// AddRuleConditionalExact is disabled on library versions lower than v2.2.1
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) AddRuleConditionalExact(call ScmpSyscall, action ScmpAction, conds []ScmpCondition) error {
0000000000000000000000000000000000000000;;		return f.addRuleGeneric(call, action, true, conds)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExportPFC output PFC-formatted, human-readable dump of a filter context's
0000000000000000000000000000000000000000;;	// rules to a file.
0000000000000000000000000000000000000000;;	// Accepts file to write to (must be open for writing).
0000000000000000000000000000000000000000;;	// Returns an error if writing to the file fails.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) ExportPFC(file *os.File) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fd := file.Fd()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if retCode := C.seccomp_export_pfc(f.filterCtx, C.int(fd)); retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExportBPF outputs Berkeley Packet Filter-formatted, kernel-readable dump of a
0000000000000000000000000000000000000000;;	// filter context's rules to a file.
0000000000000000000000000000000000000000;;	// Accepts file to write to (must be open for writing).
0000000000000000000000000000000000000000;;	// Returns an error if writing to the file fails.
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) ExportBPF(file *os.File) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fd := file.Fd()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if retCode := C.seccomp_export_bpf(f.filterCtx, C.int(fd)); retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
