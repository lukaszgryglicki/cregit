0000000000000000000000000000000000000000;;	// +build linux
7705525676c084977ab2c91c258d64e7a74b651a;Godeps/_workspace/src/github.com/seccomp/libseccomp-golang/seccomp_internal.go[Godeps/_workspace/src/github.com/seccomp/libseccomp-golang/seccomp_internal.go][vendor/github.com/seccomp/libseccomp-golang/seccomp_internal.go];	
0000000000000000000000000000000000000000;;	// Internal functions for libseccomp Go bindings
0000000000000000000000000000000000000000;;	// No exported functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package seccomp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unexported C wrapping code - provides the C-Golang interface
0000000000000000000000000000000000000000;;	// Get the seccomp header in scope
0000000000000000000000000000000000000000;;	// Need stdlib.h for free() on cstrings
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// #cgo LDFLAGS: -lseccomp
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	#include <stdlib.h>
0000000000000000000000000000000000000000;;	#include <seccomp.h>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#if SCMP_VER_MAJOR < 2
0000000000000000000000000000000000000000;;	#error Minimum supported version of Libseccomp is v2.1.0
0000000000000000000000000000000000000000;;	#elif SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 1
0000000000000000000000000000000000000000;;	#error Minimum supported version of Libseccomp is v2.1.0
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#define ARCH_BAD ~0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_BAD = ARCH_BAD;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#ifndef SCMP_ARCH_AARCH64
0000000000000000000000000000000000000000;;	#define SCMP_ARCH_AARCH64 ARCH_BAD
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#ifndef SCMP_ARCH_MIPS
0000000000000000000000000000000000000000;;	#define SCMP_ARCH_MIPS ARCH_BAD
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#ifndef SCMP_ARCH_MIPS64
0000000000000000000000000000000000000000;;	#define SCMP_ARCH_MIPS64 ARCH_BAD
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#ifndef SCMP_ARCH_MIPS64N32
0000000000000000000000000000000000000000;;	#define SCMP_ARCH_MIPS64N32 ARCH_BAD
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#ifndef SCMP_ARCH_MIPSEL
0000000000000000000000000000000000000000;;	#define SCMP_ARCH_MIPSEL ARCH_BAD
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#ifndef SCMP_ARCH_MIPSEL64
0000000000000000000000000000000000000000;;	#define SCMP_ARCH_MIPSEL64 ARCH_BAD
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#ifndef SCMP_ARCH_MIPSEL64N32
0000000000000000000000000000000000000000;;	#define SCMP_ARCH_MIPSEL64N32 ARCH_BAD
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_NATIVE       = SCMP_ARCH_NATIVE;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_X86          = SCMP_ARCH_X86;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_X86_64       = SCMP_ARCH_X86_64;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_X32          = SCMP_ARCH_X32;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_ARM          = SCMP_ARCH_ARM;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_AARCH64      = SCMP_ARCH_AARCH64;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_MIPS         = SCMP_ARCH_MIPS;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_MIPS64       = SCMP_ARCH_MIPS64;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_MIPS64N32    = SCMP_ARCH_MIPS64N32;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_MIPSEL       = SCMP_ARCH_MIPSEL;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_MIPSEL64     = SCMP_ARCH_MIPSEL64;
0000000000000000000000000000000000000000;;	const uint32_t C_ARCH_MIPSEL64N32  = SCMP_ARCH_MIPSEL64N32;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const uint32_t C_ACT_KILL          = SCMP_ACT_KILL;
0000000000000000000000000000000000000000;;	const uint32_t C_ACT_TRAP          = SCMP_ACT_TRAP;
0000000000000000000000000000000000000000;;	const uint32_t C_ACT_ERRNO         = SCMP_ACT_ERRNO(0);
0000000000000000000000000000000000000000;;	const uint32_t C_ACT_TRACE         = SCMP_ACT_TRACE(0);
0000000000000000000000000000000000000000;;	const uint32_t C_ACT_ALLOW         = SCMP_ACT_ALLOW;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If TSync is not supported, make sure it doesn't map to a supported filter attribute
0000000000000000000000000000000000000000;;	// Don't worry about major version < 2, the minimum version checks should catch that case
0000000000000000000000000000000000000000;;	#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 2
0000000000000000000000000000000000000000;;	#define SCMP_FLTATR_CTL_TSYNC _SCMP_CMP_MIN
0000000000000000000000000000000000000000;;	#endif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const uint32_t C_ATTRIBUTE_DEFAULT = (uint32_t)SCMP_FLTATR_ACT_DEFAULT;
0000000000000000000000000000000000000000;;	const uint32_t C_ATTRIBUTE_BADARCH = (uint32_t)SCMP_FLTATR_ACT_BADARCH;
0000000000000000000000000000000000000000;;	const uint32_t C_ATTRIBUTE_NNP     = (uint32_t)SCMP_FLTATR_CTL_NNP;
0000000000000000000000000000000000000000;;	const uint32_t C_ATTRIBUTE_TSYNC   = (uint32_t)SCMP_FLTATR_CTL_TSYNC;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const int      C_CMP_NE            = (int)SCMP_CMP_NE;
0000000000000000000000000000000000000000;;	const int      C_CMP_LT            = (int)SCMP_CMP_LT;
0000000000000000000000000000000000000000;;	const int      C_CMP_LE            = (int)SCMP_CMP_LE;
0000000000000000000000000000000000000000;;	const int      C_CMP_EQ            = (int)SCMP_CMP_EQ;
0000000000000000000000000000000000000000;;	const int      C_CMP_GE            = (int)SCMP_CMP_GE;
0000000000000000000000000000000000000000;;	const int      C_CMP_GT            = (int)SCMP_CMP_GT;
0000000000000000000000000000000000000000;;	const int      C_CMP_MASKED_EQ     = (int)SCMP_CMP_MASKED_EQ;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const int      C_VERSION_MAJOR     = SCMP_VER_MAJOR;
0000000000000000000000000000000000000000;;	const int      C_VERSION_MINOR     = SCMP_VER_MINOR;
0000000000000000000000000000000000000000;;	const int      C_VERSION_MICRO     = SCMP_VER_MICRO;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	typedef struct scmp_arg_cmp* scmp_cast_t;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wrapper to create an scmp_arg_cmp struct
0000000000000000000000000000000000000000;;	void*
0000000000000000000000000000000000000000;;	make_struct_arg_cmp(
0000000000000000000000000000000000000000;;	                    unsigned int arg,
0000000000000000000000000000000000000000;;	                    int compare,
0000000000000000000000000000000000000000;;	                    uint64_t a,
0000000000000000000000000000000000000000;;	                    uint64_t b
0000000000000000000000000000000000000000;;	                   )
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;		struct scmp_arg_cmp *s = malloc(sizeof(struct scmp_arg_cmp));
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s->arg = arg;
0000000000000000000000000000000000000000;;		s->op = compare;
0000000000000000000000000000000000000000;;		s->datum_a = a;
0000000000000000000000000000000000000000;;		s->datum_b = b;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s;
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	import "C"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nonexported types
0000000000000000000000000000000000000000;;	type scmpFilterAttr uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nonexported constants
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		filterAttrActDefault scmpFilterAttr = iota
0000000000000000000000000000000000000000;;		filterAttrActBadArch scmpFilterAttr = iota
0000000000000000000000000000000000000000;;		filterAttrNNP        scmpFilterAttr = iota
0000000000000000000000000000000000000000;;		filterAttrTsync      scmpFilterAttr = iota
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// An error return from certain libseccomp functions
0000000000000000000000000000000000000000;;		scmpError C.int = -1
0000000000000000000000000000000000000000;;		// Comparison boundaries to check for architecture validity
0000000000000000000000000000000000000000;;		archStart ScmpArch = ArchNative
0000000000000000000000000000000000000000;;		archEnd   ScmpArch = ArchMIPSEL64N32
0000000000000000000000000000000000000000;;		// Comparison boundaries to check for action validity
0000000000000000000000000000000000000000;;		actionStart ScmpAction = ActKill
0000000000000000000000000000000000000000;;		actionEnd   ScmpAction = ActAllow
0000000000000000000000000000000000000000;;		// Comparison boundaries to check for comparison operator validity
0000000000000000000000000000000000000000;;		compareOpStart ScmpCompareOp = CompareNotEqual
0000000000000000000000000000000000000000;;		compareOpEnd   ScmpCompareOp = CompareMaskedEqual
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Error thrown on bad filter context
0000000000000000000000000000000000000000;;		errBadFilter = fmt.Errorf("filter is invalid or uninitialized")
0000000000000000000000000000000000000000;;		// Constants representing library major, minor, and micro versions
0000000000000000000000000000000000000000;;		verMajor = int(C.C_VERSION_MAJOR)
0000000000000000000000000000000000000000;;		verMinor = int(C.C_VERSION_MINOR)
0000000000000000000000000000000000000000;;		verMicro = int(C.C_VERSION_MICRO)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nonexported functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if library version is greater than or equal to the given one
0000000000000000000000000000000000000000;;	func checkVersionAbove(major, minor, micro int) bool {
0000000000000000000000000000000000000000;;		return (verMajor > major) ||
0000000000000000000000000000000000000000;;			(verMajor == major && verMinor > minor) ||
0000000000000000000000000000000000000000;;			(verMajor == major && verMinor == minor && verMicro >= micro)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init function: Verify library version is appropriate
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if !checkVersionAbove(2, 1, 0) {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Libseccomp version too low: minimum supported is 2.1.0, detected %d.%d.%d", C.C_VERSION_MAJOR, C.C_VERSION_MINOR, C.C_VERSION_MICRO)
0000000000000000000000000000000000000000;;			os.Exit(-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter helpers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter finalizer - ensure that kernel context for filters is freed
0000000000000000000000000000000000000000;;	func filterFinalizer(f *ScmpFilter) {
0000000000000000000000000000000000000000;;		f.Release()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a raw filter attribute
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) getFilterAttr(attr scmpFilterAttr) (C.uint32_t, error) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return 0x0, errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !checkVersionAbove(2, 2, 0) && attr == filterAttrTsync {
0000000000000000000000000000000000000000;;			return 0x0, fmt.Errorf("the thread synchronization attribute is not supported in this version of the library")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var attribute C.uint32_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retCode := C.seccomp_attr_get(f.filterCtx, attr.toNative(), &attribute)
0000000000000000000000000000000000000000;;		if retCode != 0 {
0000000000000000000000000000000000000000;;			return 0x0, syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return attribute, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set a raw filter attribute
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) setFilterAttr(attr scmpFilterAttr, value C.uint32_t) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !checkVersionAbove(2, 2, 0) && attr == filterAttrTsync {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the thread synchronization attribute is not supported in this version of the library")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retCode := C.seccomp_attr_set(f.filterCtx, attr.toNative(), value)
0000000000000000000000000000000000000000;;		if retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DOES NOT LOCK OR CHECK VALIDITY
0000000000000000000000000000000000000000;;	// Assumes caller has already done this
0000000000000000000000000000000000000000;;	// Wrapper for seccomp_rule_add_... functions
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, cond C.scmp_cast_t) error {
0000000000000000000000000000000000000000;;		var length C.uint
0000000000000000000000000000000000000000;;		if cond != nil {
0000000000000000000000000000000000000000;;			length = 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			length = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var retCode C.int
0000000000000000000000000000000000000000;;		if exact {
0000000000000000000000000000000000000000;;			retCode = C.seccomp_rule_add_exact_array(f.filterCtx, action.toNative(), C.int(call), length, cond)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			retCode = C.seccomp_rule_add_array(f.filterCtx, action.toNative(), C.int(call), length, cond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if syscall.Errno(-1*retCode) == syscall.EFAULT {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unrecognized syscall")
0000000000000000000000000000000000000000;;		} else if syscall.Errno(-1*retCode) == syscall.EPERM {
0000000000000000000000000000000000000000;;			return fmt.Errorf("requested action matches default action of filter")
0000000000000000000000000000000000000000;;		} else if retCode != 0 {
0000000000000000000000000000000000000000;;			return syscall.Errno(-1 * retCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generic add function for filter rules
0000000000000000000000000000000000000000;;	func (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact bool, conds []ScmpCondition) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.valid {
0000000000000000000000000000000000000000;;			return errBadFilter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(conds) == 0 {
0000000000000000000000000000000000000000;;			if err := f.addRuleWrapper(call, action, exact, nil); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We don't support conditional filtering in library version v2.1
0000000000000000000000000000000000000000;;			if !checkVersionAbove(2, 2, 1) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("conditional filtering requires libseccomp version >= 2.2.1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, cond := range conds {
0000000000000000000000000000000000000000;;				cmpStruct := C.make_struct_arg_cmp(C.uint(cond.Argument), cond.Op.toNative(), C.uint64_t(cond.Operand1), C.uint64_t(cond.Operand2))
0000000000000000000000000000000000000000;;				defer C.free(cmpStruct)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := f.addRuleWrapper(call, action, exact, C.scmp_cast_t(cmpStruct)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generic Helpers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper - Sanitize Arch token input
0000000000000000000000000000000000000000;;	func sanitizeArch(in ScmpArch) error {
0000000000000000000000000000000000000000;;		if in < archStart || in > archEnd {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unrecognized architecture")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if in.toNative() == C.C_ARCH_BAD {
0000000000000000000000000000000000000000;;			return fmt.Errorf("architecture is not supported on this version of the library")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sanitizeAction(in ScmpAction) error {
0000000000000000000000000000000000000000;;		inTmp := in & 0x0000FFFF
0000000000000000000000000000000000000000;;		if inTmp < actionStart || inTmp > actionEnd {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unrecognized action")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if inTmp != ActTrace && inTmp != ActErrno && (in&0xFFFF0000) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("highest 16 bits must be zeroed except for Trace and Errno")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sanitizeCompareOp(in ScmpCompareOp) error {
0000000000000000000000000000000000000000;;		if in < compareOpStart || in > compareOpEnd {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unrecognized comparison operator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func archFromNative(a C.uint32_t) (ScmpArch, error) {
0000000000000000000000000000000000000000;;		switch a {
0000000000000000000000000000000000000000;;		case C.C_ARCH_X86:
0000000000000000000000000000000000000000;;			return ArchX86, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_X86_64:
0000000000000000000000000000000000000000;;			return ArchAMD64, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_X32:
0000000000000000000000000000000000000000;;			return ArchX32, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_ARM:
0000000000000000000000000000000000000000;;			return ArchARM, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_NATIVE:
0000000000000000000000000000000000000000;;			return ArchNative, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_AARCH64:
0000000000000000000000000000000000000000;;			return ArchARM64, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_MIPS:
0000000000000000000000000000000000000000;;			return ArchMIPS, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_MIPS64:
0000000000000000000000000000000000000000;;			return ArchMIPS64, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_MIPS64N32:
0000000000000000000000000000000000000000;;			return ArchMIPS64N32, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_MIPSEL:
0000000000000000000000000000000000000000;;			return ArchMIPSEL, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_MIPSEL64:
0000000000000000000000000000000000000000;;			return ArchMIPSEL64, nil
0000000000000000000000000000000000000000;;		case C.C_ARCH_MIPSEL64N32:
0000000000000000000000000000000000000000;;			return ArchMIPSEL64N32, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0x0, fmt.Errorf("unrecognized architecture")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Only use with sanitized arches, no error handling
0000000000000000000000000000000000000000;;	func (a ScmpArch) toNative() C.uint32_t {
0000000000000000000000000000000000000000;;		switch a {
0000000000000000000000000000000000000000;;		case ArchX86:
0000000000000000000000000000000000000000;;			return C.C_ARCH_X86
0000000000000000000000000000000000000000;;		case ArchAMD64:
0000000000000000000000000000000000000000;;			return C.C_ARCH_X86_64
0000000000000000000000000000000000000000;;		case ArchX32:
0000000000000000000000000000000000000000;;			return C.C_ARCH_X32
0000000000000000000000000000000000000000;;		case ArchARM:
0000000000000000000000000000000000000000;;			return C.C_ARCH_ARM
0000000000000000000000000000000000000000;;		case ArchARM64:
0000000000000000000000000000000000000000;;			return C.C_ARCH_AARCH64
0000000000000000000000000000000000000000;;		case ArchMIPS:
0000000000000000000000000000000000000000;;			return C.C_ARCH_MIPS
0000000000000000000000000000000000000000;;		case ArchMIPS64:
0000000000000000000000000000000000000000;;			return C.C_ARCH_MIPS64
0000000000000000000000000000000000000000;;		case ArchMIPS64N32:
0000000000000000000000000000000000000000;;			return C.C_ARCH_MIPS64N32
0000000000000000000000000000000000000000;;		case ArchMIPSEL:
0000000000000000000000000000000000000000;;			return C.C_ARCH_MIPSEL
0000000000000000000000000000000000000000;;		case ArchMIPSEL64:
0000000000000000000000000000000000000000;;			return C.C_ARCH_MIPSEL64
0000000000000000000000000000000000000000;;		case ArchMIPSEL64N32:
0000000000000000000000000000000000000000;;			return C.C_ARCH_MIPSEL64N32
0000000000000000000000000000000000000000;;		case ArchNative:
0000000000000000000000000000000000000000;;			return C.C_ARCH_NATIVE
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0x0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Only use with sanitized ops, no error handling
0000000000000000000000000000000000000000;;	func (a ScmpCompareOp) toNative() C.int {
0000000000000000000000000000000000000000;;		switch a {
0000000000000000000000000000000000000000;;		case CompareNotEqual:
0000000000000000000000000000000000000000;;			return C.C_CMP_NE
0000000000000000000000000000000000000000;;		case CompareLess:
0000000000000000000000000000000000000000;;			return C.C_CMP_LT
0000000000000000000000000000000000000000;;		case CompareLessOrEqual:
0000000000000000000000000000000000000000;;			return C.C_CMP_LE
0000000000000000000000000000000000000000;;		case CompareEqual:
0000000000000000000000000000000000000000;;			return C.C_CMP_EQ
0000000000000000000000000000000000000000;;		case CompareGreaterEqual:
0000000000000000000000000000000000000000;;			return C.C_CMP_GE
0000000000000000000000000000000000000000;;		case CompareGreater:
0000000000000000000000000000000000000000;;			return C.C_CMP_GT
0000000000000000000000000000000000000000;;		case CompareMaskedEqual:
0000000000000000000000000000000000000000;;			return C.C_CMP_MASKED_EQ
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0x0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func actionFromNative(a C.uint32_t) (ScmpAction, error) {
0000000000000000000000000000000000000000;;		aTmp := a & 0xFFFF
0000000000000000000000000000000000000000;;		switch a & 0xFFFF0000 {
0000000000000000000000000000000000000000;;		case C.C_ACT_KILL:
0000000000000000000000000000000000000000;;			return ActKill, nil
0000000000000000000000000000000000000000;;		case C.C_ACT_TRAP:
0000000000000000000000000000000000000000;;			return ActTrap, nil
0000000000000000000000000000000000000000;;		case C.C_ACT_ERRNO:
0000000000000000000000000000000000000000;;			return ActErrno.SetReturnCode(int16(aTmp)), nil
0000000000000000000000000000000000000000;;		case C.C_ACT_TRACE:
0000000000000000000000000000000000000000;;			return ActTrace.SetReturnCode(int16(aTmp)), nil
0000000000000000000000000000000000000000;;		case C.C_ACT_ALLOW:
0000000000000000000000000000000000000000;;			return ActAllow, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0x0, fmt.Errorf("unrecognized action")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Only use with sanitized actions, no error handling
0000000000000000000000000000000000000000;;	func (a ScmpAction) toNative() C.uint32_t {
0000000000000000000000000000000000000000;;		switch a & 0xFFFF {
0000000000000000000000000000000000000000;;		case ActKill:
0000000000000000000000000000000000000000;;			return C.C_ACT_KILL
0000000000000000000000000000000000000000;;		case ActTrap:
0000000000000000000000000000000000000000;;			return C.C_ACT_TRAP
0000000000000000000000000000000000000000;;		case ActErrno:
0000000000000000000000000000000000000000;;			return C.C_ACT_ERRNO | (C.uint32_t(a) >> 16)
0000000000000000000000000000000000000000;;		case ActTrace:
0000000000000000000000000000000000000000;;			return C.C_ACT_TRACE | (C.uint32_t(a) >> 16)
0000000000000000000000000000000000000000;;		case ActAllow:
0000000000000000000000000000000000000000;;			return C.C_ACT_ALLOW
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0x0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Internal only, assumes safe attribute
0000000000000000000000000000000000000000;;	func (a scmpFilterAttr) toNative() uint32 {
0000000000000000000000000000000000000000;;		switch a {
0000000000000000000000000000000000000000;;		case filterAttrActDefault:
0000000000000000000000000000000000000000;;			return uint32(C.C_ATTRIBUTE_DEFAULT)
0000000000000000000000000000000000000000;;		case filterAttrActBadArch:
0000000000000000000000000000000000000000;;			return uint32(C.C_ATTRIBUTE_BADARCH)
0000000000000000000000000000000000000000;;		case filterAttrNNP:
0000000000000000000000000000000000000000;;			return uint32(C.C_ATTRIBUTE_NNP)
0000000000000000000000000000000000000000;;		case filterAttrTsync:
0000000000000000000000000000000000000000;;			return uint32(C.C_ATTRIBUTE_TSYNC)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0x0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
