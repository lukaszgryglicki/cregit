0000000000000000000000000000000000000000;;	// Package camelcase is a micro package to split the words of a camelcase type
0000000000000000000000000000000000000000;;	// string into a slice of words.
0000000000000000000000000000000000000000;;	package camelcase
7ca5965d89d26a4824efae9fd17825b82ef5d2e1;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Split splits the camelcase word and returns a list of words. It also
0000000000000000000000000000000000000000;;	// supports digits. Both lower camel case and upper camel case are supported.
0000000000000000000000000000000000000000;;	// For more info please check: http://en.wikipedia.org/wiki/CamelCase
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   "" =>                     [""]
0000000000000000000000000000000000000000;;	//   "lowercase" =>            ["lowercase"]
0000000000000000000000000000000000000000;;	//   "Class" =>                ["Class"]
0000000000000000000000000000000000000000;;	//   "MyClass" =>              ["My", "Class"]
0000000000000000000000000000000000000000;;	//   "MyC" =>                  ["My", "C"]
0000000000000000000000000000000000000000;;	//   "HTML" =>                 ["HTML"]
0000000000000000000000000000000000000000;;	//   "PDFLoader" =>            ["PDF", "Loader"]
0000000000000000000000000000000000000000;;	//   "AString" =>              ["A", "String"]
0000000000000000000000000000000000000000;;	//   "SimpleXMLParser" =>      ["Simple", "XML", "Parser"]
0000000000000000000000000000000000000000;;	//   "vimRPCPlugin" =>         ["vim", "RPC", "Plugin"]
0000000000000000000000000000000000000000;;	//   "GL11Version" =>          ["GL", "11", "Version"]
0000000000000000000000000000000000000000;;	//   "99Bottles" =>            ["99", "Bottles"]
0000000000000000000000000000000000000000;;	//   "May5" =>                 ["May", "5"]
0000000000000000000000000000000000000000;;	//   "BFG9000" =>              ["BFG", "9000"]
0000000000000000000000000000000000000000;;	//   "BöseÜberraschung" =>     ["Böse", "Überraschung"]
0000000000000000000000000000000000000000;;	//   "Two  spaces" =>          ["Two", "  ", "spaces"]
0000000000000000000000000000000000000000;;	//   "BadUTF8\xe2\xe2\xa1" =>  ["BadUTF8\xe2\xe2\xa1"]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Splitting rules
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  1) If string is not valid UTF-8, return it without splitting as
0000000000000000000000000000000000000000;;	//     single item array.
0000000000000000000000000000000000000000;;	//  2) Assign all unicode characters into one of 4 sets: lower case
0000000000000000000000000000000000000000;;	//     letters, upper case letters, numbers, and all other characters.
0000000000000000000000000000000000000000;;	//  3) Iterate through characters of string, introducing splits
0000000000000000000000000000000000000000;;	//     between adjacent characters that belong to different sets.
0000000000000000000000000000000000000000;;	//  4) Iterate through array of split strings, and if a given string
0000000000000000000000000000000000000000;;	//     is upper case:
0000000000000000000000000000000000000000;;	//       if subsequent string is lower case:
0000000000000000000000000000000000000000;;	//         move last character of upper case string to beginning of
0000000000000000000000000000000000000000;;	//         lower case string
0000000000000000000000000000000000000000;;	func Split(src string) (entries []string) {
0000000000000000000000000000000000000000;;		// don't split invalid utf8
0000000000000000000000000000000000000000;;		if !utf8.ValidString(src) {
0000000000000000000000000000000000000000;;			return []string{src}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entries = []string{}
0000000000000000000000000000000000000000;;		var runes [][]rune
0000000000000000000000000000000000000000;;		lastClass := 0
0000000000000000000000000000000000000000;;		class := 0
0000000000000000000000000000000000000000;;		// split into fields based on class of unicode character
0000000000000000000000000000000000000000;;		for _, r := range src {
0000000000000000000000000000000000000000;;			switch true {
0000000000000000000000000000000000000000;;			case unicode.IsLower(r):
0000000000000000000000000000000000000000;;				class = 1
0000000000000000000000000000000000000000;;			case unicode.IsUpper(r):
0000000000000000000000000000000000000000;;				class = 2
0000000000000000000000000000000000000000;;			case unicode.IsDigit(r):
0000000000000000000000000000000000000000;;				class = 3
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				class = 4
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if class == lastClass {
0000000000000000000000000000000000000000;;				runes[len(runes)-1] = append(runes[len(runes)-1], r)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				runes = append(runes, []rune{r})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastClass = class
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// handle upper case -> lower case sequences, e.g.
0000000000000000000000000000000000000000;;		// "PDFL", "oader" -> "PDF", "Loader"
0000000000000000000000000000000000000000;;		for i := 0; i < len(runes)-1; i++ {
0000000000000000000000000000000000000000;;			if unicode.IsUpper(runes[i][0]) && unicode.IsLower(runes[i+1][0]) {
0000000000000000000000000000000000000000;;				runes[i+1] = append([]rune{runes[i][len(runes[i])-1]}, runes[i+1]...)
0000000000000000000000000000000000000000;;				runes[i] = runes[i][:len(runes[i])-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// construct []string from results
0000000000000000000000000000000000000000;;		for _, s := range runes {
0000000000000000000000000000000000000000;;			if len(s) > 0 {
0000000000000000000000000000000000000000;;				entries = append(entries, string(s))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
