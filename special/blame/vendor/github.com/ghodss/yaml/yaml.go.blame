0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/github.com/ghodss/yaml/yaml.go[Godeps/_workspace/src/github.com/ghodss/yaml/yaml.go][vendor/github.com/ghodss/yaml/yaml.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshals the object into JSON then converts JSON to YAML and returns the
0000000000000000000000000000000000000000;;	// YAML.
0000000000000000000000000000000000000000;;	func Marshal(o interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		j, err := json.Marshal(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error marshaling into JSON: ", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		y, err := JSONToYAML(j)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error converting JSON to YAML: ", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return y, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts YAML to JSON then uses JSON to unmarshal into an object.
0000000000000000000000000000000000000000;;	func Unmarshal(y []byte, o interface{}) error {
0000000000000000000000000000000000000000;;		vo := reflect.ValueOf(o)
0000000000000000000000000000000000000000;;		j, err := yamlToJSON(y, &vo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error converting YAML to JSON: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = json.Unmarshal(j, o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error unmarshaling JSON: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert JSON to YAML.
0000000000000000000000000000000000000000;;	func JSONToYAML(j []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		// Convert the JSON to an object.
0000000000000000000000000000000000000000;;		var jsonObj interface{}
0000000000000000000000000000000000000000;;		// We are using yaml.Unmarshal here (instead of json.Unmarshal) because the
0000000000000000000000000000000000000000;;		// Go JSON library doesn't try to pick the right number type (int, float,
0000000000000000000000000000000000000000;;		// etc.) when unmarshling to interface{}, it just picks float64
0000000000000000000000000000000000000000;;		// universally. go-yaml does go through the effort of picking the right
0000000000000000000000000000000000000000;;		// number type, so we can preserve number type throughout this process.
0000000000000000000000000000000000000000;;		err := yaml.Unmarshal(j, &jsonObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Marshal this object into YAML.
0000000000000000000000000000000000000000;;		return yaml.Marshal(jsonObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert YAML to JSON. Since JSON is a subset of YAML, passing JSON through
0000000000000000000000000000000000000000;;	// this method should be a no-op.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Things YAML can do that are not supported by JSON:
0000000000000000000000000000000000000000;;	// * In YAML you can have binary and null keys in your maps. These are invalid
0000000000000000000000000000000000000000;;	//   in JSON. (int and float keys are converted to strings.)
0000000000000000000000000000000000000000;;	// * Binary data in YAML with the !!binary tag is not supported. If you want to
0000000000000000000000000000000000000000;;	//   use binary data with this library, encode the data as base64 as usual but do
0000000000000000000000000000000000000000;;	//   not use the !!binary tag in your YAML. This will ensure the original base64
0000000000000000000000000000000000000000;;	//   encoded data makes it all the way through to the JSON.
0000000000000000000000000000000000000000;;	func YAMLToJSON(y []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		return yamlToJSON(y, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func yamlToJSON(y []byte, jsonTarget *reflect.Value) ([]byte, error) {
0000000000000000000000000000000000000000;;		// Convert the YAML to an object.
0000000000000000000000000000000000000000;;		var yamlObj interface{}
0000000000000000000000000000000000000000;;		err := yaml.Unmarshal(y, &yamlObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// YAML objects are not completely compatible with JSON objects (e.g. you
0000000000000000000000000000000000000000;;		// can have non-string keys in YAML). So, convert the YAML-compatible object
0000000000000000000000000000000000000000;;		// to a JSON-compatible object, failing with an error if irrecoverable
0000000000000000000000000000000000000000;;		// incompatibilties happen along the way.
0000000000000000000000000000000000000000;;		jsonObj, err := convertToJSONableObject(yamlObj, jsonTarget)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert this object to JSON and return the data.
0000000000000000000000000000000000000000;;		return json.Marshal(jsonObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertToJSONableObject(yamlObj interface{}, jsonTarget *reflect.Value) (interface{}, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Resolve jsonTarget to a concrete value (i.e. not a pointer or an
0000000000000000000000000000000000000000;;		// interface). We pass decodingNull as false because we're not actually
0000000000000000000000000000000000000000;;		// decoding into the value, we're just checking if the ultimate target is a
0000000000000000000000000000000000000000;;		// string.
0000000000000000000000000000000000000000;;		if jsonTarget != nil {
0000000000000000000000000000000000000000;;			ju, tu, pv := indirect(*jsonTarget, false)
0000000000000000000000000000000000000000;;			// We have a JSON or Text Umarshaler at this level, so we can't be trying
0000000000000000000000000000000000000000;;			// to decode into a string.
0000000000000000000000000000000000000000;;			if ju != nil || tu != nil {
0000000000000000000000000000000000000000;;				jsonTarget = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				jsonTarget = &pv
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If yamlObj is a number or a boolean, check if jsonTarget is a string -
0000000000000000000000000000000000000000;;		// if so, coerce.  Else return normal.
0000000000000000000000000000000000000000;;		// If yamlObj is a map or array, find the field that each key is
0000000000000000000000000000000000000000;;		// unmarshaling to, and when you recurse pass the reflect.Value for that
0000000000000000000000000000000000000000;;		// field back into this function.
0000000000000000000000000000000000000000;;		switch typedYAMLObj := yamlObj.(type) {
0000000000000000000000000000000000000000;;		case map[interface{}]interface{}:
0000000000000000000000000000000000000000;;			// JSON does not support arbitrary keys in a map, so we must convert
0000000000000000000000000000000000000000;;			// these keys to strings.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// From my reading of go-yaml v2 (specifically the resolve function),
0000000000000000000000000000000000000000;;			// keys can only have the types string, int, int64, float64, binary
0000000000000000000000000000000000000000;;			// (unsupported), or null (unsupported).
0000000000000000000000000000000000000000;;			strMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;			for k, v := range typedYAMLObj {
0000000000000000000000000000000000000000;;				// Resolve the key to a string first.
0000000000000000000000000000000000000000;;				var keyString string
0000000000000000000000000000000000000000;;				switch typedKey := k.(type) {
0000000000000000000000000000000000000000;;				case string:
0000000000000000000000000000000000000000;;					keyString = typedKey
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					keyString = strconv.Itoa(typedKey)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					// go-yaml will only return an int64 as a key if the system
0000000000000000000000000000000000000000;;					// architecture is 32-bit and the key's value is between 32-bit
0000000000000000000000000000000000000000;;					// and 64-bit. Otherwise the key type will simply be int.
0000000000000000000000000000000000000000;;					keyString = strconv.FormatInt(typedKey, 10)
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					// Stolen from go-yaml to use the same conversion to string as
0000000000000000000000000000000000000000;;					// the go-yaml library uses to convert float to string when
0000000000000000000000000000000000000000;;					// Marshaling.
0000000000000000000000000000000000000000;;					s := strconv.FormatFloat(typedKey, 'g', -1, 32)
0000000000000000000000000000000000000000;;					switch s {
0000000000000000000000000000000000000000;;					case "+Inf":
0000000000000000000000000000000000000000;;						s = ".inf"
0000000000000000000000000000000000000000;;					case "-Inf":
0000000000000000000000000000000000000000;;						s = "-.inf"
0000000000000000000000000000000000000000;;					case "NaN":
0000000000000000000000000000000000000000;;						s = ".nan"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					keyString = s
0000000000000000000000000000000000000000;;				case bool:
0000000000000000000000000000000000000000;;					if typedKey {
0000000000000000000000000000000000000000;;						keyString = "true"
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						keyString = "false"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Unsupported map key of type: %s, key: %+#v, value: %+#v",
0000000000000000000000000000000000000000;;						reflect.TypeOf(k), k, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// jsonTarget should be a struct or a map. If it's a struct, find
0000000000000000000000000000000000000000;;				// the field it's going to map to and pass its reflect.Value. If
0000000000000000000000000000000000000000;;				// it's a map, find the element type of the map and pass the
0000000000000000000000000000000000000000;;				// reflect.Value created from that type. If it's neither, just pass
0000000000000000000000000000000000000000;;				// nil - JSON conversion will error for us if it's a real issue.
0000000000000000000000000000000000000000;;				if jsonTarget != nil {
0000000000000000000000000000000000000000;;					t := *jsonTarget
0000000000000000000000000000000000000000;;					if t.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;						keyBytes := []byte(keyString)
0000000000000000000000000000000000000000;;						// Find the field that the JSON library would use.
0000000000000000000000000000000000000000;;						var f *field
0000000000000000000000000000000000000000;;						fields := cachedTypeFields(t.Type())
0000000000000000000000000000000000000000;;						for i := range fields {
0000000000000000000000000000000000000000;;							ff := &fields[i]
0000000000000000000000000000000000000000;;							if bytes.Equal(ff.nameBytes, keyBytes) {
0000000000000000000000000000000000000000;;								f = ff
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							// Do case-insensitive comparison.
0000000000000000000000000000000000000000;;							if f == nil && ff.equalFold(ff.nameBytes, keyBytes) {
0000000000000000000000000000000000000000;;								f = ff
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if f != nil {
0000000000000000000000000000000000000000;;							// Find the reflect.Value of the most preferential
0000000000000000000000000000000000000000;;							// struct field.
0000000000000000000000000000000000000000;;							jtf := t.Field(f.index[0])
0000000000000000000000000000000000000000;;							strMap[keyString], err = convertToJSONableObject(v, &jtf)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return nil, err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if t.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;						// Create a zero value of the map's element type to use as
0000000000000000000000000000000000000000;;						// the JSON target.
0000000000000000000000000000000000000000;;						jtv := reflect.Zero(t.Type().Elem())
0000000000000000000000000000000000000000;;						strMap[keyString], err = convertToJSONableObject(v, &jtv)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				strMap[keyString], err = convertToJSONableObject(v, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strMap, nil
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			// We need to recurse into arrays in case there are any
0000000000000000000000000000000000000000;;			// map[interface{}]interface{}'s inside and to convert any
0000000000000000000000000000000000000000;;			// numbers to strings.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If jsonTarget is a slice (which it really should be), find the
0000000000000000000000000000000000000000;;			// thing it's going to map to. If it's not a slice, just pass nil
0000000000000000000000000000000000000000;;			// - JSON conversion will error for us if it's a real issue.
0000000000000000000000000000000000000000;;			var jsonSliceElemValue *reflect.Value
0000000000000000000000000000000000000000;;			if jsonTarget != nil {
0000000000000000000000000000000000000000;;				t := *jsonTarget
0000000000000000000000000000000000000000;;				if t.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;					// By default slices point to nil, but we need a reflect.Value
0000000000000000000000000000000000000000;;					// pointing to a value of the slice type, so we create one here.
0000000000000000000000000000000000000000;;					ev := reflect.Indirect(reflect.New(t.Type().Elem()))
0000000000000000000000000000000000000000;;					jsonSliceElemValue = &ev
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make and use a new array.
0000000000000000000000000000000000000000;;			arr := make([]interface{}, len(typedYAMLObj))
0000000000000000000000000000000000000000;;			for i, v := range typedYAMLObj {
0000000000000000000000000000000000000000;;				arr[i], err = convertToJSONableObject(v, jsonSliceElemValue)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return arr, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// If the target type is a string and the YAML type is a number,
0000000000000000000000000000000000000000;;			// convert the YAML type to a string.
0000000000000000000000000000000000000000;;			if jsonTarget != nil && (*jsonTarget).Kind() == reflect.String {
0000000000000000000000000000000000000000;;				// Based on my reading of go-yaml, it may return int, int64,
0000000000000000000000000000000000000000;;				// float64, or uint64.
0000000000000000000000000000000000000000;;				var s string
0000000000000000000000000000000000000000;;				switch typedVal := typedYAMLObj.(type) {
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					s = strconv.FormatInt(int64(typedVal), 10)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					s = strconv.FormatInt(typedVal, 10)
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					s = strconv.FormatFloat(typedVal, 'g', -1, 32)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					s = strconv.FormatUint(typedVal, 10)
0000000000000000000000000000000000000000;;				case bool:
0000000000000000000000000000000000000000;;					if typedVal {
0000000000000000000000000000000000000000;;						s = "true"
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						s = "false"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(s) > 0 {
0000000000000000000000000000000000000000;;					yamlObj = interface{}(s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return yamlObj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
