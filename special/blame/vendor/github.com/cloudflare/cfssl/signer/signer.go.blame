0000000000000000000000000000000000000000;;	// Package signer implements certificate signature functionality for CFSSL.
0000000000000000000000000000000000000000;;	package signer
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/certdb"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/config"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/csr"
0000000000000000000000000000000000000000;;		cferr "github.com/cloudflare/cfssl/errors"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/helpers"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/info"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxPathLen is the default path length for a new CA certificate.
0000000000000000000000000000000000000000;;	var MaxPathLen = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subject contains the information that should be used to override the
0000000000000000000000000000000000000000;;	// subject information when signing a certificate.
0000000000000000000000000000000000000000;;	type Subject struct {
0000000000000000000000000000000000000000;;		CN           string
0000000000000000000000000000000000000000;;		Names        []csr.Name `json:"names"`
0000000000000000000000000000000000000000;;		SerialNumber string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extension represents a raw extension to be included in the certificate.  The
0000000000000000000000000000000000000000;;	// "value" field must be hex encoded.
0000000000000000000000000000000000000000;;	type Extension struct {
0000000000000000000000000000000000000000;;		ID       config.OID `json:"id"`
0000000000000000000000000000000000000000;;		Critical bool       `json:"critical"`
0000000000000000000000000000000000000000;;		Value    string     `json:"value"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignRequest stores a signature request, which contains the hostname,
0000000000000000000000000000000000000000;;	// the CSR, optional subject information, and the signature profile.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Extensions provided in the signRequest are copied into the certificate, as
0000000000000000000000000000000000000000;;	// long as they are in the ExtensionWhitelist for the signer's policy.
0000000000000000000000000000000000000000;;	// Extensions requested in the CSR are ignored, except for those processed by
0000000000000000000000000000000000000000;;	// ParseCertificateRequest (mainly subjectAltName).
0000000000000000000000000000000000000000;;	type SignRequest struct {
0000000000000000000000000000000000000000;;		Hosts      []string    `json:"hosts"`
0000000000000000000000000000000000000000;;		Request    string      `json:"certificate_request"`
0000000000000000000000000000000000000000;;		Subject    *Subject    `json:"subject,omitempty"`
0000000000000000000000000000000000000000;;		Profile    string      `json:"profile"`
0000000000000000000000000000000000000000;;		Label      string      `json:"label"`
0000000000000000000000000000000000000000;;		Serial     *big.Int    `json:"serial,omitempty"`
0000000000000000000000000000000000000000;;		Extensions []Extension `json:"extensions,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendIf appends to a if s is not an empty string.
0000000000000000000000000000000000000000;;	func appendIf(s string, a *[]string) {
0000000000000000000000000000000000000000;;		if s != "" {
0000000000000000000000000000000000000000;;			*a = append(*a, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the PKIX name for the subject.
0000000000000000000000000000000000000000;;	func (s *Subject) Name() pkix.Name {
0000000000000000000000000000000000000000;;		var name pkix.Name
0000000000000000000000000000000000000000;;		name.CommonName = s.CN
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range s.Names {
0000000000000000000000000000000000000000;;			appendIf(n.C, &name.Country)
0000000000000000000000000000000000000000;;			appendIf(n.ST, &name.Province)
0000000000000000000000000000000000000000;;			appendIf(n.L, &name.Locality)
0000000000000000000000000000000000000000;;			appendIf(n.O, &name.Organization)
0000000000000000000000000000000000000000;;			appendIf(n.OU, &name.OrganizationalUnit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name.SerialNumber = s.SerialNumber
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitHosts takes a comma-spearated list of hosts and returns a slice
0000000000000000000000000000000000000000;;	// with the hosts split
0000000000000000000000000000000000000000;;	func SplitHosts(hostList string) []string {
0000000000000000000000000000000000000000;;		if hostList == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Split(hostList, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Signer contains a CA's certificate and private key for signing
0000000000000000000000000000000000000000;;	// certificates, a Signing policy to refer to and a SignatureAlgorithm.
0000000000000000000000000000000000000000;;	type Signer interface {
0000000000000000000000000000000000000000;;		Info(info.Req) (*info.Resp, error)
0000000000000000000000000000000000000000;;		Policy() *config.Signing
0000000000000000000000000000000000000000;;		SetDBAccessor(certdb.Accessor)
0000000000000000000000000000000000000000;;		SetPolicy(*config.Signing)
0000000000000000000000000000000000000000;;		SigAlgo() x509.SignatureAlgorithm
0000000000000000000000000000000000000000;;		Sign(req SignRequest) (cert []byte, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Profile gets the specific profile from the signer
0000000000000000000000000000000000000000;;	func Profile(s Signer, profile string) (*config.SigningProfile, error) {
0000000000000000000000000000000000000000;;		var p *config.SigningProfile
0000000000000000000000000000000000000000;;		policy := s.Policy()
0000000000000000000000000000000000000000;;		if policy != nil && policy.Profiles != nil && profile != "" {
0000000000000000000000000000000000000000;;			p = policy.Profiles[profile]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p == nil && policy != nil {
0000000000000000000000000000000000000000;;			p = policy.Default
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.APIClientError, cferr.ClientHTTPError, errors.New("profile must not be nil"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultSigAlgo returns an appropriate X.509 signature algorithm given
0000000000000000000000000000000000000000;;	// the CA's private key.
0000000000000000000000000000000000000000;;	func DefaultSigAlgo(priv crypto.Signer) x509.SignatureAlgorithm {
0000000000000000000000000000000000000000;;		pub := priv.Public()
0000000000000000000000000000000000000000;;		switch pub := pub.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			keySize := pub.N.BitLen()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case keySize >= 4096:
0000000000000000000000000000000000000000;;				return x509.SHA512WithRSA
0000000000000000000000000000000000000000;;			case keySize >= 3072:
0000000000000000000000000000000000000000;;				return x509.SHA384WithRSA
0000000000000000000000000000000000000000;;			case keySize >= 2048:
0000000000000000000000000000000000000000;;				return x509.SHA256WithRSA
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return x509.SHA1WithRSA
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			switch pub.Curve {
0000000000000000000000000000000000000000;;			case elliptic.P256():
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA256
0000000000000000000000000000000000000000;;			case elliptic.P384():
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA384
0000000000000000000000000000000000000000;;			case elliptic.P521():
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA512
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return x509.UnknownSignatureAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCertificateRequest takes an incoming certificate request and
0000000000000000000000000000000000000000;;	// builds a certificate template from it.
0000000000000000000000000000000000000000;;	func ParseCertificateRequest(s Signer, csrBytes []byte) (template *x509.Certificate, err error) {
0000000000000000000000000000000000000000;;		csr, err := x509.ParseCertificateRequest(csrBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = cferr.Wrap(cferr.CSRError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = helpers.CheckSignature(csr, csr.SignatureAlgorithm, csr.RawTBSCertificateRequest, csr.Signature)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = cferr.Wrap(cferr.CSRError, cferr.KeyMismatch, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template = &x509.Certificate{
0000000000000000000000000000000000000000;;			Subject:            csr.Subject,
0000000000000000000000000000000000000000;;			PublicKeyAlgorithm: csr.PublicKeyAlgorithm,
0000000000000000000000000000000000000000;;			PublicKey:          csr.PublicKey,
0000000000000000000000000000000000000000;;			SignatureAlgorithm: s.SigAlgo(),
0000000000000000000000000000000000000000;;			DNSNames:           csr.DNSNames,
0000000000000000000000000000000000000000;;			IPAddresses:        csr.IPAddresses,
0000000000000000000000000000000000000000;;			EmailAddresses:     csr.EmailAddresses,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subjectPublicKeyInfo struct {
0000000000000000000000000000000000000000;;		Algorithm        pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		SubjectPublicKey asn1.BitString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComputeSKI derives an SKI from the certificate's public key in a
0000000000000000000000000000000000000000;;	// standard manner. This is done by computing the SHA-1 digest of the
0000000000000000000000000000000000000000;;	// SubjectPublicKeyInfo component of the certificate.
0000000000000000000000000000000000000000;;	func ComputeSKI(template *x509.Certificate) ([]byte, error) {
0000000000000000000000000000000000000000;;		pub := template.PublicKey
0000000000000000000000000000000000000000;;		encodedPub, err := x509.MarshalPKIXPublicKey(pub)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var subPKI subjectPublicKeyInfo
0000000000000000000000000000000000000000;;		_, err = asn1.Unmarshal(encodedPub, &subPKI)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pubHash := sha1.Sum(subPKI.SubjectPublicKey.Bytes)
0000000000000000000000000000000000000000;;		return pubHash[:], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FillTemplate is a utility function that tries to load as much of
0000000000000000000000000000000000000000;;	// the certificate template as possible from the profiles and current
0000000000000000000000000000000000000000;;	// template. It fills in the key uses, expiration, revocation URLs
0000000000000000000000000000000000000000;;	// and SKI.
0000000000000000000000000000000000000000;;	func FillTemplate(template *x509.Certificate, defaultProfile, profile *config.SigningProfile) error {
0000000000000000000000000000000000000000;;		ski, err := ComputeSKI(template)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			eku             []x509.ExtKeyUsage
0000000000000000000000000000000000000000;;			ku              x509.KeyUsage
0000000000000000000000000000000000000000;;			backdate        time.Duration
0000000000000000000000000000000000000000;;			expiry          time.Duration
0000000000000000000000000000000000000000;;			notBefore       time.Time
0000000000000000000000000000000000000000;;			notAfter        time.Time
0000000000000000000000000000000000000000;;			crlURL, ocspURL string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The third value returned from Usages is a list of unknown key usages.
0000000000000000000000000000000000000000;;		// This should be used when validating the profile at load, and isn't used
0000000000000000000000000000000000000000;;		// here.
0000000000000000000000000000000000000000;;		ku, eku, _ = profile.Usages()
0000000000000000000000000000000000000000;;		if profile.IssuerURL == nil {
0000000000000000000000000000000000000000;;			profile.IssuerURL = defaultProfile.IssuerURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ku == 0 && len(eku) == 0 {
0000000000000000000000000000000000000000;;			return cferr.New(cferr.PolicyError, cferr.NoKeyUsages)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expiry = profile.Expiry; expiry == 0 {
0000000000000000000000000000000000000000;;			expiry = defaultProfile.Expiry
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if crlURL = profile.CRL; crlURL == "" {
0000000000000000000000000000000000000000;;			crlURL = defaultProfile.CRL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ocspURL = profile.OCSP; ocspURL == "" {
0000000000000000000000000000000000000000;;			ocspURL = defaultProfile.OCSP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if backdate = profile.Backdate; backdate == 0 {
0000000000000000000000000000000000000000;;			backdate = -5 * time.Minute
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			backdate = -1 * profile.Backdate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !profile.NotBefore.IsZero() {
0000000000000000000000000000000000000000;;			notBefore = profile.NotBefore.UTC()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			notBefore = time.Now().Round(time.Minute).Add(backdate).UTC()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !profile.NotAfter.IsZero() {
0000000000000000000000000000000000000000;;			notAfter = profile.NotAfter.UTC()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			notAfter = notBefore.Add(expiry).UTC()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template.NotBefore = notBefore
0000000000000000000000000000000000000000;;		template.NotAfter = notAfter
0000000000000000000000000000000000000000;;		template.KeyUsage = ku
0000000000000000000000000000000000000000;;		template.ExtKeyUsage = eku
0000000000000000000000000000000000000000;;		template.BasicConstraintsValid = true
0000000000000000000000000000000000000000;;		template.IsCA = profile.CA
0000000000000000000000000000000000000000;;		template.SubjectKeyId = ski
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ocspURL != "" {
0000000000000000000000000000000000000000;;			template.OCSPServer = []string{ocspURL}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if crlURL != "" {
0000000000000000000000000000000000000000;;			template.CRLDistributionPoints = []string{crlURL}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(profile.IssuerURL) != 0 {
0000000000000000000000000000000000000000;;			template.IssuingCertificateURL = profile.IssuerURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(profile.Policies) != 0 {
0000000000000000000000000000000000000000;;			err = addPolicies(template, profile.Policies)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if profile.OCSPNoCheck {
0000000000000000000000000000000000000000;;			ocspNoCheckExtension := pkix.Extension{
0000000000000000000000000000000000000000;;				Id:       asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 48, 1, 5},
0000000000000000000000000000000000000000;;				Critical: false,
0000000000000000000000000000000000000000;;				Value:    []byte{0x05, 0x00},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			template.ExtraExtensions = append(template.ExtraExtensions, ocspNoCheckExtension)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type policyInformation struct {
0000000000000000000000000000000000000000;;		PolicyIdentifier asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Qualifiers       []interface{} `asn1:"tag:optional,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cpsPolicyQualifier struct {
0000000000000000000000000000000000000000;;		PolicyQualifierID asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Qualifier         string `asn1:"tag:optional,ia5"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userNotice struct {
0000000000000000000000000000000000000000;;		ExplicitText string `asn1:"tag:optional,utf8"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type userNoticePolicyQualifier struct {
0000000000000000000000000000000000000000;;		PolicyQualifierID asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Qualifier         userNotice
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Per https://tools.ietf.org/html/rfc3280.html#page-106, this represents:
0000000000000000000000000000000000000000;;		// iso(1) identified-organization(3) dod(6) internet(1) security(5)
0000000000000000000000000000000000000000;;		//   mechanisms(5) pkix(7) id-qt(2) id-qt-cps(1)
0000000000000000000000000000000000000000;;		iDQTCertificationPracticeStatement = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 2, 1}
0000000000000000000000000000000000000000;;		// iso(1) identified-organization(3) dod(6) internet(1) security(5)
0000000000000000000000000000000000000000;;		//   mechanisms(5) pkix(7) id-qt(2) id-qt-unotice(2)
0000000000000000000000000000000000000000;;		iDQTUserNotice = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 2, 2}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CTPoisonOID is the object ID of the critical poison extension for precertificates
0000000000000000000000000000000000000000;;		// https://tools.ietf.org/html/rfc6962#page-9
0000000000000000000000000000000000000000;;		CTPoisonOID = asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 11129, 2, 4, 3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SCTListOID is the object ID for the Signed Certificate Timestamp certificate extension
0000000000000000000000000000000000000000;;		// https://tools.ietf.org/html/rfc6962#page-14
0000000000000000000000000000000000000000;;		SCTListOID = asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 11129, 2, 4, 2}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addPolicies adds Certificate Policies and optional Policy Qualifiers to a
0000000000000000000000000000000000000000;;	// certificate, based on the input config. Go's x509 library allows setting
0000000000000000000000000000000000000000;;	// Certificate Policies easily, but does not support nested Policy Qualifiers
0000000000000000000000000000000000000000;;	// under those policies. So we need to construct the ASN.1 structure ourselves.
0000000000000000000000000000000000000000;;	func addPolicies(template *x509.Certificate, policies []config.CertificatePolicy) error {
0000000000000000000000000000000000000000;;		asn1PolicyList := []policyInformation{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, policy := range policies {
0000000000000000000000000000000000000000;;			pi := policyInformation{
0000000000000000000000000000000000000000;;				// The PolicyIdentifier is an OID assigned to a given issuer.
0000000000000000000000000000000000000000;;				PolicyIdentifier: asn1.ObjectIdentifier(policy.ID),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, qualifier := range policy.Qualifiers {
0000000000000000000000000000000000000000;;				switch qualifier.Type {
0000000000000000000000000000000000000000;;				case "id-qt-unotice":
0000000000000000000000000000000000000000;;					pi.Qualifiers = append(pi.Qualifiers,
0000000000000000000000000000000000000000;;						userNoticePolicyQualifier{
0000000000000000000000000000000000000000;;							PolicyQualifierID: iDQTUserNotice,
0000000000000000000000000000000000000000;;							Qualifier: userNotice{
0000000000000000000000000000000000000000;;								ExplicitText: qualifier.Value,
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;				case "id-qt-cps":
0000000000000000000000000000000000000000;;					pi.Qualifiers = append(pi.Qualifiers,
0000000000000000000000000000000000000000;;						cpsPolicyQualifier{
0000000000000000000000000000000000000000;;							PolicyQualifierID: iDQTCertificationPracticeStatement,
0000000000000000000000000000000000000000;;							Qualifier:         qualifier.Value,
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return errors.New("Invalid qualifier type in Policies " + qualifier.Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			asn1PolicyList = append(asn1PolicyList, pi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asn1Bytes, err := asn1.Marshal(asn1PolicyList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		template.ExtraExtensions = append(template.ExtraExtensions, pkix.Extension{
0000000000000000000000000000000000000000;;			Id:       asn1.ObjectIdentifier{2, 5, 29, 32},
0000000000000000000000000000000000000000;;			Critical: false,
0000000000000000000000000000000000000000;;			Value:    asn1Bytes,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
