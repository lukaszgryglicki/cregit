0000000000000000000000000000000000000000;;	// Package local implements certificate signature functionality for CFSSL.
0000000000000000000000000000000000000000;;	package local
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/mail"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/certdb"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/config"
0000000000000000000000000000000000000000;;		cferr "github.com/cloudflare/cfssl/errors"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/helpers"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/info"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/log"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/signer"
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go"
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go/client"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signer contains a signer that uses the standard library to
0000000000000000000000000000000000000000;;	// support both ECDSA and RSA CA keys.
0000000000000000000000000000000000000000;;	type Signer struct {
0000000000000000000000000000000000000000;;		ca         *x509.Certificate
0000000000000000000000000000000000000000;;		priv       crypto.Signer
0000000000000000000000000000000000000000;;		policy     *config.Signing
0000000000000000000000000000000000000000;;		sigAlgo    x509.SignatureAlgorithm
0000000000000000000000000000000000000000;;		dbAccessor certdb.Accessor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSigner creates a new Signer directly from a
0000000000000000000000000000000000000000;;	// private key and certificate, with optional policy.
0000000000000000000000000000000000000000;;	func NewSigner(priv crypto.Signer, cert *x509.Certificate, sigAlgo x509.SignatureAlgorithm, policy *config.Signing) (*Signer, error) {
0000000000000000000000000000000000000000;;		if policy == nil {
0000000000000000000000000000000000000000;;			policy = &config.Signing{
0000000000000000000000000000000000000000;;				Profiles: map[string]*config.SigningProfile{},
0000000000000000000000000000000000000000;;				Default:  config.DefaultConfig()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !policy.Valid() {
0000000000000000000000000000000000000000;;			return nil, cferr.New(cferr.PolicyError, cferr.InvalidPolicy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Signer{
0000000000000000000000000000000000000000;;			ca:      cert,
0000000000000000000000000000000000000000;;			priv:    priv,
0000000000000000000000000000000000000000;;			sigAlgo: sigAlgo,
0000000000000000000000000000000000000000;;			policy:  policy,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSignerFromFile generates a new local signer from a caFile
0000000000000000000000000000000000000000;;	// and a caKey file, both PEM encoded.
0000000000000000000000000000000000000000;;	func NewSignerFromFile(caFile, caKeyFile string, policy *config.Signing) (*Signer, error) {
0000000000000000000000000000000000000000;;		log.Debug("Loading CA: ", caFile)
0000000000000000000000000000000000000000;;		ca, err := ioutil.ReadFile(caFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Debug("Loading CA key: ", caKeyFile)
0000000000000000000000000000000000000000;;		cakey, err := ioutil.ReadFile(caKeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CertificateError, cferr.ReadFailed, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parsedCa, err := helpers.ParseCertificatePEM(ca)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strPassword := os.Getenv("CFSSL_CA_PK_PASSWORD")
0000000000000000000000000000000000000000;;		password := []byte(strPassword)
0000000000000000000000000000000000000000;;		if strPassword == "" {
0000000000000000000000000000000000000000;;			password = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priv, err := helpers.ParsePrivateKeyPEMWithPassword(cakey, password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Debug("Malformed private key %v", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewSigner(priv, parsedCa, signer.DefaultSigAlgo(priv), policy)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Signer) sign(template *x509.Certificate, profile *config.SigningProfile) (cert []byte, err error) {
0000000000000000000000000000000000000000;;		err = signer.FillTemplate(template, s.policy.Default, profile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var initRoot bool
0000000000000000000000000000000000000000;;		if s.ca == nil {
0000000000000000000000000000000000000000;;			if !template.IsCA {
0000000000000000000000000000000000000000;;				err = cferr.New(cferr.PolicyError, cferr.InvalidRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			template.DNSNames = nil
0000000000000000000000000000000000000000;;			template.EmailAddresses = nil
0000000000000000000000000000000000000000;;			s.ca = template
0000000000000000000000000000000000000000;;			initRoot = true
0000000000000000000000000000000000000000;;			template.MaxPathLen = signer.MaxPathLen
0000000000000000000000000000000000000000;;		} else if template.IsCA {
0000000000000000000000000000000000000000;;			template.MaxPathLen = 1
0000000000000000000000000000000000000000;;			template.DNSNames = nil
0000000000000000000000000000000000000000;;			template.EmailAddresses = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		derBytes, err := x509.CreateCertificate(rand.Reader, template, s.ca, template.PublicKey, s.priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if initRoot {
0000000000000000000000000000000000000000;;			s.ca, err = x509.ParseCertificate(derBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert = pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
0000000000000000000000000000000000000000;;		log.Infof("signed certificate with serial number %d", template.SerialNumber)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// replaceSliceIfEmpty replaces the contents of replaced with newContents if
0000000000000000000000000000000000000000;;	// the slice referenced by replaced is empty
0000000000000000000000000000000000000000;;	func replaceSliceIfEmpty(replaced, newContents *[]string) {
0000000000000000000000000000000000000000;;		if len(*replaced) == 0 {
0000000000000000000000000000000000000000;;			*replaced = *newContents
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PopulateSubjectFromCSR has functionality similar to Name, except
0000000000000000000000000000000000000000;;	// it fills the fields of the resulting pkix.Name with req's if the
0000000000000000000000000000000000000000;;	// subject's corresponding fields are empty
0000000000000000000000000000000000000000;;	func PopulateSubjectFromCSR(s *signer.Subject, req pkix.Name) pkix.Name {
0000000000000000000000000000000000000000;;		// if no subject, use req
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return req
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := s.Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name.CommonName == "" {
0000000000000000000000000000000000000000;;			name.CommonName = req.CommonName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replaceSliceIfEmpty(&name.Country, &req.Country)
0000000000000000000000000000000000000000;;		replaceSliceIfEmpty(&name.Province, &req.Province)
0000000000000000000000000000000000000000;;		replaceSliceIfEmpty(&name.Locality, &req.Locality)
0000000000000000000000000000000000000000;;		replaceSliceIfEmpty(&name.Organization, &req.Organization)
0000000000000000000000000000000000000000;;		replaceSliceIfEmpty(&name.OrganizationalUnit, &req.OrganizationalUnit)
0000000000000000000000000000000000000000;;		if name.SerialNumber == "" {
0000000000000000000000000000000000000000;;			name.SerialNumber = req.SerialNumber
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OverrideHosts fills template's IPAddresses, EmailAddresses, and DNSNames with the
0000000000000000000000000000000000000000;;	// content of hosts, if it is not nil.
0000000000000000000000000000000000000000;;	func OverrideHosts(template *x509.Certificate, hosts []string) {
0000000000000000000000000000000000000000;;		if hosts != nil {
0000000000000000000000000000000000000000;;			template.IPAddresses = []net.IP{}
0000000000000000000000000000000000000000;;			template.EmailAddresses = []string{}
0000000000000000000000000000000000000000;;			template.DNSNames = []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range hosts {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(hosts[i]); ip != nil {
0000000000000000000000000000000000000000;;				template.IPAddresses = append(template.IPAddresses, ip)
0000000000000000000000000000000000000000;;			} else if email, err := mail.ParseAddress(hosts[i]); err == nil && email != nil {
0000000000000000000000000000000000000000;;				template.EmailAddresses = append(template.EmailAddresses, email.Address)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				template.DNSNames = append(template.DNSNames, hosts[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign signs a new certificate based on the PEM-encoded client
0000000000000000000000000000000000000000;;	// certificate or certificate request with the signing profile,
0000000000000000000000000000000000000000;;	// specified by profileName.
0000000000000000000000000000000000000000;;	func (s *Signer) Sign(req signer.SignRequest) (cert []byte, err error) {
0000000000000000000000000000000000000000;;		profile, err := signer.Profile(s, req.Profile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		block, _ := pem.Decode([]byte(req.Request))
0000000000000000000000000000000000000000;;		if block == nil {
0000000000000000000000000000000000000000;;			return nil, cferr.New(cferr.CSRError, cferr.DecodeFailed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if block.Type != "CERTIFICATE REQUEST" {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CSRError,
0000000000000000000000000000000000000000;;				cferr.BadRequest, errors.New("not a certificate or csr"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csrTemplate, err := signer.ParseCertificateRequest(s, block.Bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy out only the fields from the CSR authorized by policy.
0000000000000000000000000000000000000000;;		safeTemplate := x509.Certificate{}
0000000000000000000000000000000000000000;;		// If the profile contains no explicit whitelist, assume that all fields
0000000000000000000000000000000000000000;;		// should be copied from the CSR.
0000000000000000000000000000000000000000;;		if profile.CSRWhitelist == nil {
0000000000000000000000000000000000000000;;			safeTemplate = *csrTemplate
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if profile.CSRWhitelist.Subject {
0000000000000000000000000000000000000000;;				safeTemplate.Subject = csrTemplate.Subject
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if profile.CSRWhitelist.PublicKeyAlgorithm {
0000000000000000000000000000000000000000;;				safeTemplate.PublicKeyAlgorithm = csrTemplate.PublicKeyAlgorithm
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if profile.CSRWhitelist.PublicKey {
0000000000000000000000000000000000000000;;				safeTemplate.PublicKey = csrTemplate.PublicKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if profile.CSRWhitelist.SignatureAlgorithm {
0000000000000000000000000000000000000000;;				safeTemplate.SignatureAlgorithm = csrTemplate.SignatureAlgorithm
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if profile.CSRWhitelist.DNSNames {
0000000000000000000000000000000000000000;;				safeTemplate.DNSNames = csrTemplate.DNSNames
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if profile.CSRWhitelist.IPAddresses {
0000000000000000000000000000000000000000;;				safeTemplate.IPAddresses = csrTemplate.IPAddresses
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if profile.CSRWhitelist.EmailAddresses {
0000000000000000000000000000000000000000;;				safeTemplate.EmailAddresses = csrTemplate.EmailAddresses
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		OverrideHosts(&safeTemplate, req.Hosts)
0000000000000000000000000000000000000000;;		safeTemplate.Subject = PopulateSubjectFromCSR(req.Subject, safeTemplate.Subject)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there is a whitelist, ensure that both the Common Name and SAN DNSNames match
0000000000000000000000000000000000000000;;		if profile.NameWhitelist != nil {
0000000000000000000000000000000000000000;;			if safeTemplate.Subject.CommonName != "" {
0000000000000000000000000000000000000000;;				if profile.NameWhitelist.Find([]byte(safeTemplate.Subject.CommonName)) == nil {
0000000000000000000000000000000000000000;;					return nil, cferr.New(cferr.PolicyError, cferr.InvalidPolicy)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, name := range safeTemplate.DNSNames {
0000000000000000000000000000000000000000;;				if profile.NameWhitelist.Find([]byte(name)) == nil {
0000000000000000000000000000000000000000;;					return nil, cferr.New(cferr.PolicyError, cferr.InvalidPolicy)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, name := range safeTemplate.EmailAddresses {
0000000000000000000000000000000000000000;;				if profile.NameWhitelist.Find([]byte(name)) == nil {
0000000000000000000000000000000000000000;;					return nil, cferr.New(cferr.PolicyError, cferr.InvalidPolicy)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if profile.ClientProvidesSerialNumbers {
0000000000000000000000000000000000000000;;			if req.Serial == nil {
0000000000000000000000000000000000000000;;				return nil, cferr.New(cferr.CertificateError, cferr.MissingSerial)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			safeTemplate.SerialNumber = req.Serial
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// RFC 5280 4.1.2.2:
0000000000000000000000000000000000000000;;			// Certificate users MUST be able to handle serialNumber
0000000000000000000000000000000000000000;;			// values up to 20 octets.  Conforming CAs MUST NOT use
0000000000000000000000000000000000000000;;			// serialNumber values longer than 20 octets.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// If CFSSL is providing the serial numbers, it makes
0000000000000000000000000000000000000000;;			// sense to use the max supported size.
0000000000000000000000000000000000000000;;			serialNumber := make([]byte, 20)
0000000000000000000000000000000000000000;;			_, err = io.ReadFull(rand.Reader, serialNumber)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CertificateError, cferr.Unknown, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// SetBytes interprets buf as the bytes of a big-endian
0000000000000000000000000000000000000000;;			// unsigned integer. The leading byte should be masked
0000000000000000000000000000000000000000;;			// off to ensure it isn't negative.
0000000000000000000000000000000000000000;;			serialNumber[0] &= 0x7F
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			safeTemplate.SerialNumber = new(big.Int).SetBytes(serialNumber)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(req.Extensions) > 0 {
0000000000000000000000000000000000000000;;			for _, ext := range req.Extensions {
0000000000000000000000000000000000000000;;				oid := asn1.ObjectIdentifier(ext.ID)
0000000000000000000000000000000000000000;;				if !profile.ExtensionWhitelist[oid.String()] {
0000000000000000000000000000000000000000;;					return nil, cferr.New(cferr.CertificateError, cferr.InvalidRequest)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rawValue, err := hex.DecodeString(ext.Value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, cferr.Wrap(cferr.CertificateError, cferr.InvalidRequest, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				safeTemplate.ExtraExtensions = append(safeTemplate.ExtraExtensions, pkix.Extension{
0000000000000000000000000000000000000000;;					Id:       oid,
0000000000000000000000000000000000000000;;					Critical: ext.Critical,
0000000000000000000000000000000000000000;;					Value:    rawValue,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var certTBS = safeTemplate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(profile.CTLogServers) > 0 {
0000000000000000000000000000000000000000;;			// Add a poison extension which prevents validation
0000000000000000000000000000000000000000;;			var poisonExtension = pkix.Extension{Id: signer.CTPoisonOID, Critical: true, Value: []byte{0x05, 0x00}}
0000000000000000000000000000000000000000;;			var poisonedPreCert = certTBS
0000000000000000000000000000000000000000;;			poisonedPreCert.ExtraExtensions = append(safeTemplate.ExtraExtensions, poisonExtension)
0000000000000000000000000000000000000000;;			cert, err = s.sign(&poisonedPreCert, profile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			derCert, _ := pem.Decode(cert)
0000000000000000000000000000000000000000;;			prechain := []ct.ASN1Cert{derCert.Bytes, s.ca.Raw}
0000000000000000000000000000000000000000;;			var sctList []ct.SignedCertificateTimestamp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, server := range profile.CTLogServers {
0000000000000000000000000000000000000000;;				log.Infof("submitting poisoned precertificate to %s", server)
0000000000000000000000000000000000000000;;				var ctclient = client.New(server)
0000000000000000000000000000000000000000;;				var resp *ct.SignedCertificateTimestamp
0000000000000000000000000000000000000000;;				resp, err = ctclient.AddPreChain(prechain)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, cferr.Wrap(cferr.CTError, cferr.PrecertSubmissionFailed, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sctList = append(sctList, *resp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var serializedSCTList []byte
0000000000000000000000000000000000000000;;			serializedSCTList, err = serializeSCTList(sctList)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CTError, cferr.Unknown, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Serialize again as an octet string before embedding
0000000000000000000000000000000000000000;;			serializedSCTList, err = asn1.Marshal(serializedSCTList)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CTError, cferr.Unknown, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var SCTListExtension = pkix.Extension{Id: signer.SCTListOID, Critical: false, Value: serializedSCTList}
0000000000000000000000000000000000000000;;			certTBS.ExtraExtensions = append(certTBS.ExtraExtensions, SCTListExtension)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var signedCert []byte
0000000000000000000000000000000000000000;;		signedCert, err = s.sign(&certTBS, profile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.dbAccessor != nil {
0000000000000000000000000000000000000000;;			var certRecord = certdb.CertificateRecord{
0000000000000000000000000000000000000000;;				Serial: certTBS.SerialNumber.String(),
0000000000000000000000000000000000000000;;				// this relies on the specific behavior of x509.CreateCertificate
0000000000000000000000000000000000000000;;				// which updates certTBS AuthorityKeyId from the signer's SubjectKeyId
0000000000000000000000000000000000000000;;				AKI:     hex.EncodeToString(certTBS.AuthorityKeyId),
0000000000000000000000000000000000000000;;				CALabel: req.Label,
0000000000000000000000000000000000000000;;				Status:  "good",
0000000000000000000000000000000000000000;;				Expiry:  certTBS.NotAfter,
0000000000000000000000000000000000000000;;				PEM:     string(signedCert),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = s.dbAccessor.InsertCertificate(certRecord)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			log.Debug("saved certificate with serial number ", certTBS.SerialNumber)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return signedCert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serializeSCTList(sctList []ct.SignedCertificateTimestamp) ([]byte, error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		for _, sct := range sctList {
0000000000000000000000000000000000000000;;			sct, err := ct.SerializeSCT(sct)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			binary.Write(&buf, binary.BigEndian, uint16(len(sct)))
0000000000000000000000000000000000000000;;			buf.Write(sct)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sctListLengthField = make([]byte, 2)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(sctListLengthField, uint16(buf.Len()))
0000000000000000000000000000000000000000;;		return bytes.Join([][]byte{sctListLengthField, buf.Bytes()}, nil), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Info return a populated info.Resp struct or an error.
0000000000000000000000000000000000000000;;	func (s *Signer) Info(req info.Req) (resp *info.Resp, err error) {
0000000000000000000000000000000000000000;;		cert, err := s.Certificate(req.Label, req.Profile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		profile, err := signer.Profile(s, req.Profile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp = new(info.Resp)
0000000000000000000000000000000000000000;;		if cert.Raw != nil {
0000000000000000000000000000000000000000;;			resp.Certificate = string(bytes.TrimSpace(pem.EncodeToMemory(&pem.Block{Type: "CERTIFICATE", Bytes: cert.Raw})))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Usage = profile.Usage
0000000000000000000000000000000000000000;;		resp.ExpiryString = profile.ExpiryString
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SigAlgo returns the RSA signer's signature algorithm.
0000000000000000000000000000000000000000;;	func (s *Signer) SigAlgo() x509.SignatureAlgorithm {
0000000000000000000000000000000000000000;;		return s.sigAlgo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Certificate returns the signer's certificate.
0000000000000000000000000000000000000000;;	func (s *Signer) Certificate(label, profile string) (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		cert := *s.ca
0000000000000000000000000000000000000000;;		return &cert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPolicy sets the signer's signature policy.
0000000000000000000000000000000000000000;;	func (s *Signer) SetPolicy(policy *config.Signing) {
0000000000000000000000000000000000000000;;		s.policy = policy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDBAccessor sets the signers' cert db accessor
0000000000000000000000000000000000000000;;	func (s *Signer) SetDBAccessor(dba certdb.Accessor) {
0000000000000000000000000000000000000000;;		s.dbAccessor = dba
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Policy returns the signer's policy.
0000000000000000000000000000000000000000;;	func (s *Signer) Policy() *config.Signing {
0000000000000000000000000000000000000000;;		return s.policy
0000000000000000000000000000000000000000;;	}
