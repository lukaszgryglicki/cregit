0000000000000000000000000000000000000000;;	package errors
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error is the error type usually returned by functions in CF SSL package.
0000000000000000000000000000000000000000;;	// It contains a 4-digit error code where the most significant digit
0000000000000000000000000000000000000000;;	// describes the category where the error occurred and the rest 3 digits
0000000000000000000000000000000000000000;;	// describe the specific error reason.
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		ErrorCode int    `json:"code"`
0000000000000000000000000000000000000000;;		Message   string `json:"message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Category is the most significant digit of the error code.
0000000000000000000000000000000000000000;;	type Category int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reason is the last 3 digits of the error code.
0000000000000000000000000000000000000000;;	type Reason int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Success indicates no error occurred.
0000000000000000000000000000000000000000;;		Success Category = 1000 * iota // 0XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CertificateError indicates a fault in a certificate.
0000000000000000000000000000000000000000;;		CertificateError // 1XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrivateKeyError indicates a fault in a private key.
0000000000000000000000000000000000000000;;		PrivateKeyError // 2XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IntermediatesError indicates a fault in an intermediate.
0000000000000000000000000000000000000000;;		IntermediatesError // 3XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RootError indicates a fault in a root.
0000000000000000000000000000000000000000;;		RootError // 4XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PolicyError indicates an error arising from a malformed or
0000000000000000000000000000000000000000;;		// non-existent policy, or a breach of policy.
0000000000000000000000000000000000000000;;		PolicyError // 5XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DialError indicates a network fault.
0000000000000000000000000000000000000000;;		DialError // 6XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// APIClientError indicates a problem with the API client.
0000000000000000000000000000000000000000;;		APIClientError // 7XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OCSPError indicates a problem with OCSP signing
0000000000000000000000000000000000000000;;		OCSPError // 8XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CSRError indicates a problem with CSR parsing
0000000000000000000000000000000000000000;;		CSRError // 9XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CTError indicates a problem with the certificate transparency process
0000000000000000000000000000000000000000;;		CTError // 10XXX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CertStoreError indicates a problem with the certificate store
0000000000000000000000000000000000000000;;		CertStoreError // 11XXX
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// None is a non-specified error.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		None Reason = iota
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Warning code for a success
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		BundleExpiringBit      int = 1 << iota // 0x01
0000000000000000000000000000000000000000;;		BundleNotUbiquitousBit                 // 0x02
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parsing errors
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Unknown      Reason = iota // X000
0000000000000000000000000000000000000000;;		ReadFailed                 // X001
0000000000000000000000000000000000000000;;		DecodeFailed               // X002
0000000000000000000000000000000000000000;;		ParseFailed                // X003
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following represent certificate non-parsing errors, and must be
0000000000000000000000000000000000000000;;	// specified along with CertificateError.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// SelfSigned indicates that a certificate is self-signed and
0000000000000000000000000000000000000000;;		// cannot be used in the manner being attempted.
0000000000000000000000000000000000000000;;		SelfSigned Reason = 100 * (iota + 1) // Code 11XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VerifyFailed is an X.509 verification failure. The least two
0000000000000000000000000000000000000000;;		// significant digits of 12XX is determined as the actual x509
0000000000000000000000000000000000000000;;		// error is examined.
0000000000000000000000000000000000000000;;		VerifyFailed // Code 12XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BadRequest indicates that the certificate request is invalid.
0000000000000000000000000000000000000000;;		BadRequest // Code 13XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MissingSerial indicates that the profile specified
0000000000000000000000000000000000000000;;		// 'ClientProvidesSerialNumbers', but the SignRequest did not include a serial
0000000000000000000000000000000000000000;;		// number.
0000000000000000000000000000000000000000;;		MissingSerial // Code 14XX
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		certificateInvalid = 10 * (iota + 1) //121X
0000000000000000000000000000000000000000;;		unknownAuthority                     //122x
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following represent private-key non-parsing errors, and must be
0000000000000000000000000000000000000000;;	// specified with PrivateKeyError.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Encrypted indicates that the private key is a PKCS #8 encrypted
0000000000000000000000000000000000000000;;		// private key. At this time, CFSSL does not support decrypting
0000000000000000000000000000000000000000;;		// these keys.
0000000000000000000000000000000000000000;;		Encrypted Reason = 100 * (iota + 1) //21XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NotRSAOrECC indicates that they key is not an RSA or ECC
0000000000000000000000000000000000000000;;		// private key; these are the only two private key types supported
0000000000000000000000000000000000000000;;		// at this time by CFSSL.
0000000000000000000000000000000000000000;;		NotRSAOrECC //22XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyMismatch indicates that the private key does not match
0000000000000000000000000000000000000000;;		// the public key or certificate being presented with the key.
0000000000000000000000000000000000000000;;		KeyMismatch //23XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GenerationFailed indicates that a private key could not
0000000000000000000000000000000000000000;;		// be generated.
0000000000000000000000000000000000000000;;		GenerationFailed //24XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unavailable indicates that a private key mechanism (such as
0000000000000000000000000000000000000000;;		// PKCS #11) was requested but support for that mechanism is
0000000000000000000000000000000000000000;;		// not available.
0000000000000000000000000000000000000000;;		Unavailable
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following are policy-related non-parsing errors, and must be
0000000000000000000000000000000000000000;;	// specified along with PolicyError.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NoKeyUsages indicates that the profile does not permit any
0000000000000000000000000000000000000000;;		// key usages for the certificate.
0000000000000000000000000000000000000000;;		NoKeyUsages Reason = 100 * (iota + 1) // 51XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InvalidPolicy indicates that policy being requested is not
0000000000000000000000000000000000000000;;		// a valid policy or does not exist.
0000000000000000000000000000000000000000;;		InvalidPolicy // 52XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InvalidRequest indicates a certificate request violated the
0000000000000000000000000000000000000000;;		// constraints of the policy being applied to the request.
0000000000000000000000000000000000000000;;		InvalidRequest // 53XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UnknownProfile indicates that the profile does not exist.
0000000000000000000000000000000000000000;;		UnknownProfile // 54XX
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following are API client related errors, and should be
0000000000000000000000000000000000000000;;	// specified with APIClientError.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// AuthenticationFailure occurs when the client is unable
0000000000000000000000000000000000000000;;		// to obtain an authentication token for the request.
0000000000000000000000000000000000000000;;		AuthenticationFailure Reason = 100 * (iota + 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// JSONError wraps an encoding/json error.
0000000000000000000000000000000000000000;;		JSONError
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IOError wraps an io/ioutil error.
0000000000000000000000000000000000000000;;		IOError
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClientHTTPError wraps a net/http error.
0000000000000000000000000000000000000000;;		ClientHTTPError
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServerRequestFailed covers any other failures from the API
0000000000000000000000000000000000000000;;		// client.
0000000000000000000000000000000000000000;;		ServerRequestFailed
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following are OCSP related errors, and should be
0000000000000000000000000000000000000000;;	// specified with OCSPError
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// IssuerMismatch ocurs when the certificate in the OCSP signing
0000000000000000000000000000000000000000;;		// request was not issued by the CA that this responder responds for.
0000000000000000000000000000000000000000;;		IssuerMismatch Reason = 100 * (iota + 1) // 81XX
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InvalidStatus occurs when the OCSP signing requests includes an
0000000000000000000000000000000000000000;;		// invalid value for the certificate status.
0000000000000000000000000000000000000000;;		InvalidStatus
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Certificate transparency related errors specified with CTError
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PrecertSubmissionFailed occurs when submitting a precertificate to
0000000000000000000000000000000000000000;;		// a log server fails
0000000000000000000000000000000000000000;;		PrecertSubmissionFailed = 100 * (iota + 1)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Certificate persistence related errors specified with CertStoreError
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// InsertionFailed occurs when a SQL insert query failes to complete.
0000000000000000000000000000000000000000;;		InsertionFailed = 100 * (iota + 1)
0000000000000000000000000000000000000000;;		// RecordNotFound occurs when a SQL query targeting on one unique
0000000000000000000000000000000000000000;;		// record failes to update the specified row in the table.
0000000000000000000000000000000000000000;;		RecordNotFound
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The error interface implementation, which formats to a JSON object string.
0000000000000000000000000000000000000000;;	func (e *Error) Error() string {
0000000000000000000000000000000000000000;;		marshaled, err := json.Marshal(e)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(marshaled)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns an error that contains  an error code and message derived from
0000000000000000000000000000000000000000;;	// the given category, reason. Currently, to avoid confusion, it is not
0000000000000000000000000000000000000000;;	// allowed to create an error of category Success
0000000000000000000000000000000000000000;;	func New(category Category, reason Reason) *Error {
0000000000000000000000000000000000000000;;		errorCode := int(category) + int(reason)
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		switch category {
0000000000000000000000000000000000000000;;		case OCSPError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case ReadFailed:
0000000000000000000000000000000000000000;;				msg = "No certificate provided"
0000000000000000000000000000000000000000;;			case IssuerMismatch:
0000000000000000000000000000000000000000;;				msg = "Certificate not issued by this issuer"
0000000000000000000000000000000000000000;;			case InvalidStatus:
0000000000000000000000000000000000000000;;				msg = "Invalid revocation status"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CertificateError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Unknown certificate error"
0000000000000000000000000000000000000000;;			case ReadFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to read certificate"
0000000000000000000000000000000000000000;;			case DecodeFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to decode certificate"
0000000000000000000000000000000000000000;;			case ParseFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to parse certificate"
0000000000000000000000000000000000000000;;			case SelfSigned:
0000000000000000000000000000000000000000;;				msg = "Certificate is self signed"
0000000000000000000000000000000000000000;;			case VerifyFailed:
0000000000000000000000000000000000000000;;				msg = "Unable to verify certificate"
0000000000000000000000000000000000000000;;			case BadRequest:
0000000000000000000000000000000000000000;;				msg = "Invalid certificate request"
0000000000000000000000000000000000000000;;			case MissingSerial:
0000000000000000000000000000000000000000;;				msg = "Missing serial number in request"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CFSSL error reason %d under category CertificateError.",
0000000000000000000000000000000000000000;;					reason))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case PrivateKeyError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Unknown private key error"
0000000000000000000000000000000000000000;;			case ReadFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to read private key"
0000000000000000000000000000000000000000;;			case DecodeFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to decode private key"
0000000000000000000000000000000000000000;;			case ParseFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to parse private key"
0000000000000000000000000000000000000000;;			case Encrypted:
0000000000000000000000000000000000000000;;				msg = "Private key is encrypted."
0000000000000000000000000000000000000000;;			case NotRSAOrECC:
0000000000000000000000000000000000000000;;				msg = "Private key algorithm is not RSA or ECC"
0000000000000000000000000000000000000000;;			case KeyMismatch:
0000000000000000000000000000000000000000;;				msg = "Private key does not match public key"
0000000000000000000000000000000000000000;;			case GenerationFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to new private key"
0000000000000000000000000000000000000000;;			case Unavailable:
0000000000000000000000000000000000000000;;				msg = "Private key is unavailable"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CFSSL error reason %d under category PrivateKeyError.",
0000000000000000000000000000000000000000;;					reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case IntermediatesError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Unknown intermediate certificate error"
0000000000000000000000000000000000000000;;			case ReadFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to read intermediate certificate"
0000000000000000000000000000000000000000;;			case DecodeFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to decode intermediate certificate"
0000000000000000000000000000000000000000;;			case ParseFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to parse intermediate certificate"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CFSSL error reason %d under category IntermediatesError.",
0000000000000000000000000000000000000000;;					reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case RootError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Unknown root certificate error"
0000000000000000000000000000000000000000;;			case ReadFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to read root certificate"
0000000000000000000000000000000000000000;;			case DecodeFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to decode root certificate"
0000000000000000000000000000000000000000;;			case ParseFailed:
0000000000000000000000000000000000000000;;				msg = "Failed to parse root certificate"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CFSSL error reason %d under category RootError.",
0000000000000000000000000000000000000000;;					reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case PolicyError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Unknown policy error"
0000000000000000000000000000000000000000;;			case NoKeyUsages:
0000000000000000000000000000000000000000;;				msg = "Invalid policy: no key usage available"
0000000000000000000000000000000000000000;;			case InvalidPolicy:
0000000000000000000000000000000000000000;;				msg = "Invalid or unknown policy"
0000000000000000000000000000000000000000;;			case InvalidRequest:
0000000000000000000000000000000000000000;;				msg = "Policy violation request"
0000000000000000000000000000000000000000;;			case UnknownProfile:
0000000000000000000000000000000000000000;;				msg = "Unknown policy profile"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CFSSL error reason %d under category PolicyError.",
0000000000000000000000000000000000000000;;					reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case DialError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Failed to dial remote server"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CFSSL error reason %d under category DialError.",
0000000000000000000000000000000000000000;;					reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case APIClientError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case AuthenticationFailure:
0000000000000000000000000000000000000000;;				msg = "API client authentication failure"
0000000000000000000000000000000000000000;;			case JSONError:
0000000000000000000000000000000000000000;;				msg = "API client JSON config error"
0000000000000000000000000000000000000000;;			case ClientHTTPError:
0000000000000000000000000000000000000000;;				msg = "API client HTTP error"
0000000000000000000000000000000000000000;;			case IOError:
0000000000000000000000000000000000000000;;				msg = "API client IO error"
0000000000000000000000000000000000000000;;			case ServerRequestFailed:
0000000000000000000000000000000000000000;;				msg = "API client error: Server request failed"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CFSSL error reason %d under category APIClientError.",
0000000000000000000000000000000000000000;;					reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CSRError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "CSR parsing failed due to unknown error"
0000000000000000000000000000000000000000;;			case ReadFailed:
0000000000000000000000000000000000000000;;				msg = "CSR file read failed"
0000000000000000000000000000000000000000;;			case ParseFailed:
0000000000000000000000000000000000000000;;				msg = "CSR Parsing failed"
0000000000000000000000000000000000000000;;			case DecodeFailed:
0000000000000000000000000000000000000000;;				msg = "CSR Decode failed"
0000000000000000000000000000000000000000;;			case BadRequest:
0000000000000000000000000000000000000000;;				msg = "CSR Bad request"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CF-SSL error reason %d under category APIClientError.", reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CTError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Certificate transparency parsing failed due to unknown error"
0000000000000000000000000000000000000000;;			case PrecertSubmissionFailed:
0000000000000000000000000000000000000000;;				msg = "Certificate transparency precertificate submission failed"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CF-SSL error reason %d under category CTError.", reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CertStoreError:
0000000000000000000000000000000000000000;;			switch reason {
0000000000000000000000000000000000000000;;			case Unknown:
0000000000000000000000000000000000000000;;				msg = "Certificate store action failed due to unknown error"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unsupported CF-SSL error reason %d under category CertStoreError.", reason))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Unsupported CFSSL error type: %d.",
0000000000000000000000000000000000000000;;				category))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Error{ErrorCode: errorCode, Message: msg}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wrap returns an error that contains the given error and an error code derived from
0000000000000000000000000000000000000000;;	// the given category, reason and the error. Currently, to avoid confusion, it is not
0000000000000000000000000000000000000000;;	// allowed to create an error of category Success
0000000000000000000000000000000000000000;;	func Wrap(category Category, reason Reason, err error) *Error {
0000000000000000000000000000000000000000;;		errorCode := int(category) + int(reason)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			panic("Wrap needs a supplied error to initialize.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do not double wrap a error
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case *Error:
0000000000000000000000000000000000000000;;			panic("Unable to wrap a wrapped error.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch category {
0000000000000000000000000000000000000000;;		case CertificateError:
0000000000000000000000000000000000000000;;			// given VerifyFailed , report the status with more detailed status code
0000000000000000000000000000000000000000;;			// for some certificate errors we care.
0000000000000000000000000000000000000000;;			if reason == VerifyFailed {
0000000000000000000000000000000000000000;;				switch errorType := err.(type) {
0000000000000000000000000000000000000000;;				case x509.CertificateInvalidError:
0000000000000000000000000000000000000000;;					errorCode += certificateInvalid + int(errorType.Reason)
0000000000000000000000000000000000000000;;				case x509.UnknownAuthorityError:
0000000000000000000000000000000000000000;;					errorCode += unknownAuthority
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case PrivateKeyError, IntermediatesError, RootError, PolicyError, DialError,
0000000000000000000000000000000000000000;;			APIClientError, CSRError, CTError, CertStoreError:
0000000000000000000000000000000000000000;;		// no-op, just use the error
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Unsupported CFSSL error type: %d.",
0000000000000000000000000000000000000000;;				category))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Error{ErrorCode: errorCode, Message: err.Error()}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
