0000000000000000000000000000000000000000;;	// Package pkcs7 implements the subset of the CMS PKCS #7 datatype that is typically
0000000000000000000000000000000000000000;;	// used to package certificates and CRLs.  Using openssl, every certificate converted
0000000000000000000000000000000000000000;;	// to PKCS #7 format from another encoding such as PEM conforms to this implementation.
0000000000000000000000000000000000000000;;	// reference: https://www.openssl.org/docs/apps/crl2pkcs7.html
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//			PKCS #7 Data type, reference: https://tools.ietf.org/html/rfc2315
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The full pkcs#7 cryptographic message syntax allows for cryptographic enhancements,
0000000000000000000000000000000000000000;;	// for example data can be encrypted and signed and then packaged through pkcs#7 to be
0000000000000000000000000000000000000000;;	// sent over a network and then verified and decrypted.  It is asn1, and the type of
0000000000000000000000000000000000000000;;	// PKCS #7 ContentInfo, which comprises the PKCS #7 structure, is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//			ContentInfo ::= SEQUENCE {
0000000000000000000000000000000000000000;;	//				contentType ContentType,
0000000000000000000000000000000000000000;;	//				content [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL
0000000000000000000000000000000000000000;;	//			}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There are 6 possible ContentTypes, data, signedData, envelopedData,
0000000000000000000000000000000000000000;;	// signedAndEnvelopedData, digestedData, and encryptedData.  Here signedData, Data, and encrypted
0000000000000000000000000000000000000000;;	// Data are implemented, as the degenerate case of signedData without a signature is the typical
0000000000000000000000000000000000000000;;	// format for transferring certificates and CRLS, and Data and encryptedData are used in PKCS #12
0000000000000000000000000000000000000000;;	// formats.
0000000000000000000000000000000000000000;;	// The ContentType signedData has the form:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//			signedData ::= SEQUENCE {
0000000000000000000000000000000000000000;;	//				version Version,
0000000000000000000000000000000000000000;;	//				digestAlgorithms DigestAlgorithmIdentifiers,
0000000000000000000000000000000000000000;;	//				contentInfo ContentInfo,
0000000000000000000000000000000000000000;;	//				certificates [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
0000000000000000000000000000000000000000;;	//				crls [1] IMPLICIT CertificateRevocationLists OPTIONAL,
0000000000000000000000000000000000000000;;	//				signerInfos SignerInfos
0000000000000000000000000000000000000000;;	//			}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As of yet signerInfos and digestAlgorithms are not parsed, as they are not relevant to
0000000000000000000000000000000000000000;;	// this system's use of PKCS #7 data.  Version is an integer type, note that PKCS #7 is
0000000000000000000000000000000000000000;;	// recursive, this second layer of ContentInfo is similar ignored for our degenerate
0000000000000000000000000000000000000000;;	// usage.  The ExtendedCertificatesAndCertificates type consists of a sequence of choices
0000000000000000000000000000000000000000;;	// between PKCS #6 extended certificates and x509 certificates.  Any sequence consisting
0000000000000000000000000000000000000000;;	// of any number of extended certificates is not yet supported in this implementation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The ContentType Data is simply a raw octet string and is parsed directly into a Go []byte slice.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The ContentType encryptedData is the most complicated and its form can be gathered by
0000000000000000000000000000000000000000;;	// the go type below.  It essentially contains a raw octet string of encrypted data and an
0000000000000000000000000000000000000000;;	// algorithm identifier for use in decrypting this data.
0000000000000000000000000000000000000000;;	package pkcs7
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cferr "github.com/cloudflare/cfssl/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Types used for asn1 Unmarshaling.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type signedData struct {
0000000000000000000000000000000000000000;;		Version          int
0000000000000000000000000000000000000000;;		DigestAlgorithms asn1.RawValue
0000000000000000000000000000000000000000;;		ContentInfo      asn1.RawValue
0000000000000000000000000000000000000000;;		Certificates     asn1.RawValue `asn1:"optional" asn1:"tag:0"`
0000000000000000000000000000000000000000;;		Crls             asn1.RawValue `asn1:"optional"`
0000000000000000000000000000000000000000;;		SignerInfos      asn1.RawValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initPKCS7 struct {
0000000000000000000000000000000000000000;;		Raw         asn1.RawContent
0000000000000000000000000000000000000000;;		ContentType asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Content     asn1.RawValue `asn1:"tag:0,explicit,optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Object identifier strings of the three implemented PKCS7 types.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ObjIDData          = "1.2.840.113549.1.7.1"
0000000000000000000000000000000000000000;;		ObjIDSignedData    = "1.2.840.113549.1.7.2"
0000000000000000000000000000000000000000;;		ObjIDEncryptedData = "1.2.840.113549.1.7.6"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PKCS7 represents the ASN1 PKCS #7 Content type.  It contains one of three
0000000000000000000000000000000000000000;;	// possible types of Content objects, as denoted by the object identifier in
0000000000000000000000000000000000000000;;	// the ContentInfo field, the other two being nil.  SignedData
0000000000000000000000000000000000000000;;	// is the degenerate SignedData Content info without signature used
0000000000000000000000000000000000000000;;	// to hold certificates and crls.  Data is raw bytes, and EncryptedData
0000000000000000000000000000000000000000;;	// is as defined in PKCS #7 standard.
0000000000000000000000000000000000000000;;	type PKCS7 struct {
0000000000000000000000000000000000000000;;		Raw         asn1.RawContent
0000000000000000000000000000000000000000;;		ContentInfo string
0000000000000000000000000000000000000000;;		Content     Content
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Content implements three of the six possible PKCS7 data types.  Only one is non-nil.
0000000000000000000000000000000000000000;;	type Content struct {
0000000000000000000000000000000000000000;;		Data          []byte
0000000000000000000000000000000000000000;;		SignedData    SignedData
0000000000000000000000000000000000000000;;		EncryptedData EncryptedData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignedData defines the typical carrier of certificates and crls.
0000000000000000000000000000000000000000;;	type SignedData struct {
0000000000000000000000000000000000000000;;		Raw          asn1.RawContent
0000000000000000000000000000000000000000;;		Version      int
0000000000000000000000000000000000000000;;		Certificates []*x509.Certificate
0000000000000000000000000000000000000000;;		Crl          *pkix.CertificateList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Data contains raw bytes.  Used as a subtype in PKCS12.
0000000000000000000000000000000000000000;;	type Data struct {
0000000000000000000000000000000000000000;;		Bytes []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncryptedData contains encrypted data.  Used as a subtype in PKCS12.
0000000000000000000000000000000000000000;;	type EncryptedData struct {
0000000000000000000000000000000000000000;;		Raw                  asn1.RawContent
0000000000000000000000000000000000000000;;		Version              int
0000000000000000000000000000000000000000;;		EncryptedContentInfo EncryptedContentInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncryptedContentInfo is a subtype of PKCS7EncryptedData.
0000000000000000000000000000000000000000;;	type EncryptedContentInfo struct {
0000000000000000000000000000000000000000;;		Raw                        asn1.RawContent
0000000000000000000000000000000000000000;;		ContentType                asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		ContentEncryptionAlgorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		EncryptedContent           []byte `asn1:"tag:0,optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePKCS7 attempts to parse the DER encoded bytes of a
0000000000000000000000000000000000000000;;	// PKCS7 structure.
0000000000000000000000000000000000000000;;	func ParsePKCS7(raw []byte) (msg *PKCS7, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pkcs7 initPKCS7
0000000000000000000000000000000000000000;;		_, err = asn1.Unmarshal(raw, &pkcs7)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg = new(PKCS7)
0000000000000000000000000000000000000000;;		msg.Raw = pkcs7.Raw
0000000000000000000000000000000000000000;;		msg.ContentInfo = pkcs7.ContentType.String()
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case msg.ContentInfo == ObjIDData:
0000000000000000000000000000000000000000;;			msg.ContentInfo = "Data"
0000000000000000000000000000000000000000;;			_, err = asn1.Unmarshal(pkcs7.Content.Bytes, &msg.Content.Data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case msg.ContentInfo == ObjIDSignedData:
0000000000000000000000000000000000000000;;			msg.ContentInfo = "SignedData"
0000000000000000000000000000000000000000;;			var signedData signedData
0000000000000000000000000000000000000000;;			_, err = asn1.Unmarshal(pkcs7.Content.Bytes, &signedData)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(signedData.Certificates.Bytes) != 0 {
0000000000000000000000000000000000000000;;				msg.Content.SignedData.Certificates, err = x509.ParseCertificates(signedData.Certificates.Bytes)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(signedData.Crls.Bytes) != 0 {
0000000000000000000000000000000000000000;;				msg.Content.SignedData.Crl, err = x509.ParseDERCRL(signedData.Crls.Bytes)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Content.SignedData.Version = signedData.Version
0000000000000000000000000000000000000000;;			msg.Content.SignedData.Raw = pkcs7.Content.Bytes
0000000000000000000000000000000000000000;;		case msg.ContentInfo == ObjIDEncryptedData:
0000000000000000000000000000000000000000;;			msg.ContentInfo = "EncryptedData"
0000000000000000000000000000000000000000;;			var encryptedData EncryptedData
0000000000000000000000000000000000000000;;			_, err = asn1.Unmarshal(pkcs7.Content.Bytes, &encryptedData)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if encryptedData.Version != 0 {
0000000000000000000000000000000000000000;;				return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, errors.New("Only support for PKCS #7 encryptedData version 0"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Content.EncryptedData = encryptedData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, errors.New("Attempt to parse PKCS# 7 Content not of type data, signed data or encrypted data"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return msg, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
