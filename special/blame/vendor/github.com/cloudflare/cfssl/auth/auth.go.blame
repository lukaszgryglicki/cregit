0000000000000000000000000000000000000000;;	// Package auth implements an interface for providing CFSSL
0000000000000000000000000000000000000000;;	// authentication. This is meant to authenticate a client CFSSL to a
0000000000000000000000000000000000000000;;	// remote CFSSL in order to prevent unauthorised use of the signature
0000000000000000000000000000000000000000;;	// capabilities. This package provides both the interface and a
0000000000000000000000000000000000000000;;	// standard HMAC-based implementation.
0000000000000000000000000000000000000000;;	package auth
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/hmac"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An AuthenticatedRequest contains a request and authentication
0000000000000000000000000000000000000000;;	// token. The Provider may determine whether to validate the timestamp
0000000000000000000000000000000000000000;;	// and remote address.
0000000000000000000000000000000000000000;;	type AuthenticatedRequest struct {
0000000000000000000000000000000000000000;;		// An Authenticator decides whether to use this field.
0000000000000000000000000000000000000000;;		Timestamp     int64  `json:"timestamp,omitempty"`
0000000000000000000000000000000000000000;;		RemoteAddress []byte `json:"remote_address,omitempty"`
0000000000000000000000000000000000000000;;		Token         []byte `json:"token"`
0000000000000000000000000000000000000000;;		Request       []byte `json:"request"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Provider can generate tokens from a request and verify a
0000000000000000000000000000000000000000;;	// request. The handling of additional authentication data (such as
0000000000000000000000000000000000000000;;	// the IP address) is handled by the concrete type, as is any
0000000000000000000000000000000000000000;;	// serialisation and state-keeping.
0000000000000000000000000000000000000000;;	type Provider interface {
0000000000000000000000000000000000000000;;		Token(req []byte) (token []byte, err error)
0000000000000000000000000000000000000000;;		Verify(aReq *AuthenticatedRequest) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Standard implements an HMAC-SHA-256 authentication provider. It may
0000000000000000000000000000000000000000;;	// be supplied additional data at creation time that will be used as
0000000000000000000000000000000000000000;;	// request || additional-data with the HMAC.
0000000000000000000000000000000000000000;;	type Standard struct {
0000000000000000000000000000000000000000;;		key []byte
0000000000000000000000000000000000000000;;		ad  []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New generates a new standard authentication provider from the key
0000000000000000000000000000000000000000;;	// and additional data. The additional data will be used when
0000000000000000000000000000000000000000;;	// generating a new token.
0000000000000000000000000000000000000000;;	func New(key string, ad []byte) (*Standard, error) {
0000000000000000000000000000000000000000;;		if splitKey := strings.SplitN(key, ":", 2); len(splitKey) == 2 {
0000000000000000000000000000000000000000;;			switch splitKey[0] {
0000000000000000000000000000000000000000;;			case "env":
0000000000000000000000000000000000000000;;				key = os.Getenv(splitKey[1])
0000000000000000000000000000000000000000;;			case "file":
0000000000000000000000000000000000000000;;				data, err := ioutil.ReadFile(splitKey[1])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				key = string(data)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unknown key prefix: %s", splitKey[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyBytes, err := hex.DecodeString(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Standard{keyBytes, ad}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token generates a new authentication token from the request.
0000000000000000000000000000000000000000;;	func (p Standard) Token(req []byte) (token []byte, err error) {
0000000000000000000000000000000000000000;;		h := hmac.New(sha256.New, p.key)
0000000000000000000000000000000000000000;;		h.Write(req)
0000000000000000000000000000000000000000;;		h.Write(p.ad)
0000000000000000000000000000000000000000;;		return h.Sum(nil), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify determines whether an authenticated request is valid.
0000000000000000000000000000000000000000;;	func (p Standard) Verify(ad *AuthenticatedRequest) bool {
0000000000000000000000000000000000000000;;		if ad == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Standard token generation returns no error.
0000000000000000000000000000000000000000;;		token, _ := p.Token(ad.Request)
0000000000000000000000000000000000000000;;		if len(ad.Token) != len(token) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hmac.Equal(token, ad.Token)
0000000000000000000000000000000000000000;;	}
