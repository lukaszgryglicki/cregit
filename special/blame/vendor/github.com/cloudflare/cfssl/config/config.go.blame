0000000000000000000000000000000000000000;;	// Package config contains the configuration logic for CFSSL.
0000000000000000000000000000000000000000;;	package config
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/auth"
0000000000000000000000000000000000000000;;		cferr "github.com/cloudflare/cfssl/errors"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/helpers"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/log"
0000000000000000000000000000000000000000;;		ocspConfig "github.com/cloudflare/cfssl/ocsp/config"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A CSRWhitelist stores booleans for fields in the CSR. If a CSRWhitelist is
0000000000000000000000000000000000000000;;	// not present in a SigningProfile, all of these fields may be copied from the
0000000000000000000000000000000000000000;;	// CSR into the signed certificate. If a CSRWhitelist *is* present in a
0000000000000000000000000000000000000000;;	// SigningProfile, only those fields with a `true` value in the CSRWhitelist may
0000000000000000000000000000000000000000;;	// be copied from the CSR to the signed certificate. Note that some of these
0000000000000000000000000000000000000000;;	// fields, like Subject, can be provided or partially provided through the API.
0000000000000000000000000000000000000000;;	// Since API clients are expected to be trusted, but CSRs are not, fields
0000000000000000000000000000000000000000;;	// provided through the API are not subject to whitelisting through this
0000000000000000000000000000000000000000;;	// mechanism.
0000000000000000000000000000000000000000;;	type CSRWhitelist struct {
0000000000000000000000000000000000000000;;		Subject, PublicKeyAlgorithm, PublicKey, SignatureAlgorithm bool
0000000000000000000000000000000000000000;;		DNSNames, IPAddresses, EmailAddresses                      bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OID is our own version of asn1's ObjectIdentifier, so we can define a custom
0000000000000000000000000000000000000000;;	// JSON marshal / unmarshal.
0000000000000000000000000000000000000000;;	type OID asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertificatePolicy represents the ASN.1 PolicyInformation structure from
0000000000000000000000000000000000000000;;	// https://tools.ietf.org/html/rfc3280.html#page-106.
0000000000000000000000000000000000000000;;	// Valid values of Type are "id-qt-unotice" and "id-qt-cps"
0000000000000000000000000000000000000000;;	type CertificatePolicy struct {
0000000000000000000000000000000000000000;;		ID         OID
0000000000000000000000000000000000000000;;		Qualifiers []CertificatePolicyQualifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertificatePolicyQualifier represents a single qualifier from an ASN.1
0000000000000000000000000000000000000000;;	// PolicyInformation structure.
0000000000000000000000000000000000000000;;	type CertificatePolicyQualifier struct {
0000000000000000000000000000000000000000;;		Type  string
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthRemote is an authenticated remote signer.
0000000000000000000000000000000000000000;;	type AuthRemote struct {
0000000000000000000000000000000000000000;;		RemoteName  string `json:"remote"`
0000000000000000000000000000000000000000;;		AuthKeyName string `json:"auth_key"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SigningProfile stores information that the CA needs to store
0000000000000000000000000000000000000000;;	// signature policy.
0000000000000000000000000000000000000000;;	type SigningProfile struct {
0000000000000000000000000000000000000000;;		Usage               []string   `json:"usages"`
0000000000000000000000000000000000000000;;		IssuerURL           []string   `json:"issuer_urls"`
0000000000000000000000000000000000000000;;		OCSP                string     `json:"ocsp_url"`
0000000000000000000000000000000000000000;;		CRL                 string     `json:"crl_url"`
0000000000000000000000000000000000000000;;		CA                  bool       `json:"is_ca"`
0000000000000000000000000000000000000000;;		OCSPNoCheck         bool       `json:"ocsp_no_check"`
0000000000000000000000000000000000000000;;		ExpiryString        string     `json:"expiry"`
0000000000000000000000000000000000000000;;		BackdateString      string     `json:"backdate"`
0000000000000000000000000000000000000000;;		AuthKeyName         string     `json:"auth_key"`
0000000000000000000000000000000000000000;;		RemoteName          string     `json:"remote"`
0000000000000000000000000000000000000000;;		NotBefore           time.Time  `json:"not_before"`
0000000000000000000000000000000000000000;;		NotAfter            time.Time  `json:"not_after"`
0000000000000000000000000000000000000000;;		NameWhitelistString string     `json:"name_whitelist"`
0000000000000000000000000000000000000000;;		AuthRemote          AuthRemote `json:"auth_remote"`
0000000000000000000000000000000000000000;;		CTLogServers        []string   `json:"ct_log_servers"`
0000000000000000000000000000000000000000;;		AllowedExtensions   []OID      `json:"allowed_extensions"`
0000000000000000000000000000000000000000;;		CertStore           string     `json:"cert_store"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Policies                    []CertificatePolicy
0000000000000000000000000000000000000000;;		Expiry                      time.Duration
0000000000000000000000000000000000000000;;		Backdate                    time.Duration
0000000000000000000000000000000000000000;;		Provider                    auth.Provider
0000000000000000000000000000000000000000;;		RemoteProvider              auth.Provider
0000000000000000000000000000000000000000;;		RemoteServer                string
0000000000000000000000000000000000000000;;		CSRWhitelist                *CSRWhitelist
0000000000000000000000000000000000000000;;		NameWhitelist               *regexp.Regexp
0000000000000000000000000000000000000000;;		ExtensionWhitelist          map[string]bool
0000000000000000000000000000000000000000;;		ClientProvidesSerialNumbers bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON unmarshals a JSON string into an OID.
0000000000000000000000000000000000000000;;	func (oid *OID) UnmarshalJSON(data []byte) (err error) {
0000000000000000000000000000000000000000;;		if data[0] != '"' || data[len(data)-1] != '"' {
0000000000000000000000000000000000000000;;			return errors.New("OID JSON string not wrapped in quotes." + string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data = data[1 : len(data)-1]
0000000000000000000000000000000000000000;;		parsedOid, err := parseObjectIdentifier(string(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*oid = OID(parsedOid)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshals an oid into a JSON string.
0000000000000000000000000000000000000000;;	func (oid OID) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return []byte(fmt.Sprintf(`"%v"`, asn1.ObjectIdentifier(oid))), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseObjectIdentifier(oidString string) (oid asn1.ObjectIdentifier, err error) {
0000000000000000000000000000000000000000;;		validOID, err := regexp.MatchString("\\d(\\.\\d+)*", oidString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !validOID {
0000000000000000000000000000000000000000;;			err = errors.New("Invalid OID")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		segments := strings.Split(oidString, ".")
0000000000000000000000000000000000000000;;		oid = make(asn1.ObjectIdentifier, len(segments))
0000000000000000000000000000000000000000;;		for i, intString := range segments {
0000000000000000000000000000000000000000;;			oid[i], err = strconv.Atoi(intString)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const timeFormat = "2006-01-02T15:04:05"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// populate is used to fill in the fields that are not in JSON
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// First, the ExpiryString parameter is needed to parse
0000000000000000000000000000000000000000;;	// expiration timestamps from JSON. The JSON decoder is not able to
0000000000000000000000000000000000000000;;	// decode a string time duration to a time.Duration, so this is called
0000000000000000000000000000000000000000;;	// when loading the configuration to properly parse and fill out the
0000000000000000000000000000000000000000;;	// Expiry parameter.
0000000000000000000000000000000000000000;;	// This function is also used to create references to the auth key
0000000000000000000000000000000000000000;;	// and default remote for the profile.
0000000000000000000000000000000000000000;;	// It returns true if ExpiryString is a valid representation of a
0000000000000000000000000000000000000000;;	// time.Duration, and the AuthKeyString and RemoteName point to
0000000000000000000000000000000000000000;;	// valid objects. It returns false otherwise.
0000000000000000000000000000000000000000;;	func (p *SigningProfile) populate(cfg *Config) error {
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, errors.New("can't parse nil profile"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if p.RemoteName == "" && p.AuthRemote.RemoteName == "" {
0000000000000000000000000000000000000000;;			log.Debugf("parse expiry in profile")
0000000000000000000000000000000000000000;;			if p.ExpiryString == "" {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, errors.New("empty expiry string"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dur, err := time.ParseDuration(p.ExpiryString)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			log.Debugf("expiry is valid")
0000000000000000000000000000000000000000;;			p.Expiry = dur
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.BackdateString != "" {
0000000000000000000000000000000000000000;;				dur, err = time.ParseDuration(p.BackdateString)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p.Backdate = dur
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !p.NotBefore.IsZero() && !p.NotAfter.IsZero() && p.NotAfter.Before(p.NotBefore) {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(p.Policies) > 0 {
0000000000000000000000000000000000000000;;				for _, policy := range p.Policies {
0000000000000000000000000000000000000000;;					for _, qualifier := range policy.Qualifiers {
0000000000000000000000000000000000000000;;						if qualifier.Type != "" && qualifier.Type != "id-qt-unotice" && qualifier.Type != "id-qt-cps" {
0000000000000000000000000000000000000000;;							return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;								errors.New("invalid policy qualifier type"))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if p.RemoteName != "" {
0000000000000000000000000000000000000000;;			log.Debug("match remote in profile to remotes section")
0000000000000000000000000000000000000000;;			if p.AuthRemote.RemoteName != "" {
0000000000000000000000000000000000000000;;				log.Error("profile has both a remote and an auth remote specified")
0000000000000000000000000000000000000000;;				return cferr.New(cferr.PolicyError, cferr.InvalidPolicy)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if remote := cfg.Remotes[p.RemoteName]; remote != "" {
0000000000000000000000000000000000000000;;				if err := p.updateRemote(remote); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;					errors.New("failed to find remote in remotes section"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			log.Debug("match auth remote in profile to remotes section")
0000000000000000000000000000000000000000;;			if remote := cfg.Remotes[p.AuthRemote.RemoteName]; remote != "" {
0000000000000000000000000000000000000000;;				if err := p.updateRemote(remote); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;					errors.New("failed to find remote in remotes section"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.AuthKeyName != "" {
0000000000000000000000000000000000000000;;			log.Debug("match auth key in profile to auth_keys section")
0000000000000000000000000000000000000000;;			if key, ok := cfg.AuthKeys[p.AuthKeyName]; ok == true {
0000000000000000000000000000000000000000;;				if key.Type == "standard" {
0000000000000000000000000000000000000000;;					p.Provider, err = auth.New(key.Key, nil)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						log.Debugf("failed to create new standard auth provider: %v", err)
0000000000000000000000000000000000000000;;						return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;							errors.New("failed to create new standard auth provider"))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					log.Debugf("unknown authentication type %v", key.Type)
0000000000000000000000000000000000000000;;					return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;						errors.New("unknown authentication type"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;					errors.New("failed to find auth_key in auth_keys section"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.AuthRemote.AuthKeyName != "" {
0000000000000000000000000000000000000000;;			log.Debug("match auth remote key in profile to auth_keys section")
0000000000000000000000000000000000000000;;			if key, ok := cfg.AuthKeys[p.AuthRemote.AuthKeyName]; ok == true {
0000000000000000000000000000000000000000;;				if key.Type == "standard" {
0000000000000000000000000000000000000000;;					p.RemoteProvider, err = auth.New(key.Key, nil)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						log.Debugf("failed to create new standard auth provider: %v", err)
0000000000000000000000000000000000000000;;						return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;							errors.New("failed to create new standard auth provider"))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					log.Debugf("unknown authentication type %v", key.Type)
0000000000000000000000000000000000000000;;					return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;						errors.New("unknown authentication type"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;					errors.New("failed to find auth_remote's auth_key in auth_keys section"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.NameWhitelistString != "" {
0000000000000000000000000000000000000000;;			log.Debug("compiling whitelist regular expression")
0000000000000000000000000000000000000000;;			rule, err := regexp.Compile(p.NameWhitelistString)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;					errors.New("failed to compile name whitelist section"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.NameWhitelist = rule
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.ExtensionWhitelist = map[string]bool{}
0000000000000000000000000000000000000000;;		for _, oid := range p.AllowedExtensions {
0000000000000000000000000000000000000000;;			p.ExtensionWhitelist[asn1.ObjectIdentifier(oid).String()] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateRemote takes a signing profile and initializes the remote server object
0000000000000000000000000000000000000000;;	// to the hostname:port combination sent by remote.
0000000000000000000000000000000000000000;;	func (p *SigningProfile) updateRemote(remote string) error {
0000000000000000000000000000000000000000;;		if remote != "" {
0000000000000000000000000000000000000000;;			p.RemoteServer = remote
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OverrideRemotes takes a signing configuration and updates the remote server object
0000000000000000000000000000000000000000;;	// to the hostname:port combination sent by remote
0000000000000000000000000000000000000000;;	func (p *Signing) OverrideRemotes(remote string) error {
0000000000000000000000000000000000000000;;		if remote != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			for _, profile := range p.Profiles {
0000000000000000000000000000000000000000;;				err = profile.updateRemote(remote)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = p.Default.updateRemote(remote)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeedsRemoteSigner returns true if one of the profiles has a remote set
0000000000000000000000000000000000000000;;	func (p *Signing) NeedsRemoteSigner() bool {
0000000000000000000000000000000000000000;;		for _, profile := range p.Profiles {
0000000000000000000000000000000000000000;;			if profile.RemoteServer != "" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Default.RemoteServer != "" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeedsLocalSigner returns true if one of the profiles doe not have a remote set
0000000000000000000000000000000000000000;;	func (p *Signing) NeedsLocalSigner() bool {
0000000000000000000000000000000000000000;;		for _, profile := range p.Profiles {
0000000000000000000000000000000000000000;;			if profile.RemoteServer == "" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Default.RemoteServer == "" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usages parses the list of key uses in the profile, translating them
0000000000000000000000000000000000000000;;	// to a list of X.509 key usages and extended key usages.  The unknown
0000000000000000000000000000000000000000;;	// uses are collected into a slice that is also returned.
0000000000000000000000000000000000000000;;	func (p *SigningProfile) Usages() (ku x509.KeyUsage, eku []x509.ExtKeyUsage, unk []string) {
0000000000000000000000000000000000000000;;		for _, keyUse := range p.Usage {
0000000000000000000000000000000000000000;;			if kuse, ok := KeyUsage[keyUse]; ok {
0000000000000000000000000000000000000000;;				ku |= kuse
0000000000000000000000000000000000000000;;			} else if ekuse, ok := ExtKeyUsage[keyUse]; ok {
0000000000000000000000000000000000000000;;				eku = append(eku, ekuse)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				unk = append(unk, keyUse)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A valid profile must be a valid local profile or a valid remote profile.
0000000000000000000000000000000000000000;;	// A valid local profile has defined at least key usages to be used, and a
0000000000000000000000000000000000000000;;	// valid local default profile has defined at least a default expiration.
0000000000000000000000000000000000000000;;	// A valid remote profile (default or not) has remote signer initialized.
0000000000000000000000000000000000000000;;	// In addition, a remote profile must has a valid auth provider if auth
0000000000000000000000000000000000000000;;	// key defined.
0000000000000000000000000000000000000000;;	func (p *SigningProfile) validProfile(isDefault bool) bool {
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.RemoteName != "" {
0000000000000000000000000000000000000000;;			log.Debugf("validate remote profile")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.RemoteServer == "" {
0000000000000000000000000000000000000000;;				log.Debugf("invalid remote profile: no remote signer specified")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.AuthKeyName != "" && p.Provider == nil {
0000000000000000000000000000000000000000;;				log.Debugf("invalid remote profile: auth key name is defined but no auth provider is set")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.AuthRemote.RemoteName != "" {
0000000000000000000000000000000000000000;;				log.Debugf("invalid remote profile: auth remote is also specified")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if p.AuthRemote.RemoteName != "" {
0000000000000000000000000000000000000000;;			log.Debugf("validate auth remote profile")
0000000000000000000000000000000000000000;;			if p.RemoteServer == "" {
0000000000000000000000000000000000000000;;				log.Debugf("invalid auth remote profile: no remote signer specified")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.AuthRemote.AuthKeyName == "" || p.RemoteProvider == nil {
0000000000000000000000000000000000000000;;				log.Debugf("invalid auth remote profile: no auth key is defined")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			log.Debugf("validate local profile")
0000000000000000000000000000000000000000;;			if !isDefault {
0000000000000000000000000000000000000000;;				if len(p.Usage) == 0 {
0000000000000000000000000000000000000000;;					log.Debugf("invalid local profile: no usages specified")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				} else if _, _, unk := p.Usages(); len(unk) == len(p.Usage) {
0000000000000000000000000000000000000000;;					log.Debugf("invalid local profile: no valid usages")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if p.Expiry == 0 {
0000000000000000000000000000000000000000;;					log.Debugf("invalid local profile: no expiry set")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Debugf("profile is valid")
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signing codifies the signature configuration policy for a CA.
0000000000000000000000000000000000000000;;	type Signing struct {
0000000000000000000000000000000000000000;;		Profiles map[string]*SigningProfile `json:"profiles"`
0000000000000000000000000000000000000000;;		Default  *SigningProfile            `json:"default"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config stores configuration information for the CA.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		Signing  *Signing           `json:"signing"`
0000000000000000000000000000000000000000;;		OCSP     *ocspConfig.Config `json:"ocsp"`
0000000000000000000000000000000000000000;;		AuthKeys map[string]AuthKey `json:"auth_keys,omitempty"`
0000000000000000000000000000000000000000;;		Remotes  map[string]string  `json:"remotes,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid ensures that Config is a valid configuration. It should be
0000000000000000000000000000000000000000;;	// called immediately after parsing a configuration file.
0000000000000000000000000000000000000000;;	func (c *Config) Valid() bool {
0000000000000000000000000000000000000000;;		return c.Signing.Valid()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid checks the signature policies, ensuring they are valid
0000000000000000000000000000000000000000;;	// policies. A policy is valid if it has defined at least key usages
0000000000000000000000000000000000000000;;	// to be used, and a valid default profile has defined at least a
0000000000000000000000000000000000000000;;	// default expiration.
0000000000000000000000000000000000000000;;	func (p *Signing) Valid() bool {
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Debugf("validating configuration")
0000000000000000000000000000000000000000;;		if !p.Default.validProfile(true) {
0000000000000000000000000000000000000000;;			log.Debugf("default profile is invalid")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sp := range p.Profiles {
0000000000000000000000000000000000000000;;			if !sp.validProfile(false) {
0000000000000000000000000000000000000000;;				log.Debugf("invalid profile")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyUsage contains a mapping of string names to key usages.
0000000000000000000000000000000000000000;;	var KeyUsage = map[string]x509.KeyUsage{
0000000000000000000000000000000000000000;;		"signing":             x509.KeyUsageDigitalSignature,
0000000000000000000000000000000000000000;;		"digital signature":   x509.KeyUsageDigitalSignature,
0000000000000000000000000000000000000000;;		"content committment": x509.KeyUsageContentCommitment,
0000000000000000000000000000000000000000;;		"key encipherment":    x509.KeyUsageKeyEncipherment,
0000000000000000000000000000000000000000;;		"key agreement":       x509.KeyUsageKeyAgreement,
0000000000000000000000000000000000000000;;		"data encipherment":   x509.KeyUsageDataEncipherment,
0000000000000000000000000000000000000000;;		"cert sign":           x509.KeyUsageCertSign,
0000000000000000000000000000000000000000;;		"crl sign":            x509.KeyUsageCRLSign,
0000000000000000000000000000000000000000;;		"encipher only":       x509.KeyUsageEncipherOnly,
0000000000000000000000000000000000000000;;		"decipher only":       x509.KeyUsageDecipherOnly,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtKeyUsage contains a mapping of string names to extended key
0000000000000000000000000000000000000000;;	// usages.
0000000000000000000000000000000000000000;;	var ExtKeyUsage = map[string]x509.ExtKeyUsage{
0000000000000000000000000000000000000000;;		"any":              x509.ExtKeyUsageAny,
0000000000000000000000000000000000000000;;		"server auth":      x509.ExtKeyUsageServerAuth,
0000000000000000000000000000000000000000;;		"client auth":      x509.ExtKeyUsageClientAuth,
0000000000000000000000000000000000000000;;		"code signing":     x509.ExtKeyUsageCodeSigning,
0000000000000000000000000000000000000000;;		"email protection": x509.ExtKeyUsageEmailProtection,
0000000000000000000000000000000000000000;;		"s/mime":           x509.ExtKeyUsageEmailProtection,
0000000000000000000000000000000000000000;;		"ipsec end system": x509.ExtKeyUsageIPSECEndSystem,
0000000000000000000000000000000000000000;;		"ipsec tunnel":     x509.ExtKeyUsageIPSECTunnel,
0000000000000000000000000000000000000000;;		"ipsec user":       x509.ExtKeyUsageIPSECUser,
0000000000000000000000000000000000000000;;		"timestamping":     x509.ExtKeyUsageTimeStamping,
0000000000000000000000000000000000000000;;		"ocsp signing":     x509.ExtKeyUsageOCSPSigning,
0000000000000000000000000000000000000000;;		"microsoft sgc":    x509.ExtKeyUsageMicrosoftServerGatedCrypto,
0000000000000000000000000000000000000000;;		"netscape sgc":     x509.ExtKeyUsageNetscapeServerGatedCrypto,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An AuthKey contains an entry for a key used for authentication.
0000000000000000000000000000000000000000;;	type AuthKey struct {
0000000000000000000000000000000000000000;;		// Type contains information needed to select the appropriate
0000000000000000000000000000000000000000;;		// constructor. For example, "standard" for HMAC-SHA-256,
0000000000000000000000000000000000000000;;		// "standard-ip" for HMAC-SHA-256 incorporating the client's
0000000000000000000000000000000000000000;;		// IP.
0000000000000000000000000000000000000000;;		Type string `json:"type"`
0000000000000000000000000000000000000000;;		// Key contains the key information, such as a hex-encoded
0000000000000000000000000000000000000000;;		// HMAC key.
0000000000000000000000000000000000000000;;		Key string `json:"key"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultConfig returns a default configuration specifying basic key
0000000000000000000000000000000000000000;;	// usage and a 1 year expiration time. The key usages chosen are
0000000000000000000000000000000000000000;;	// signing, key encipherment, client auth and server auth.
0000000000000000000000000000000000000000;;	func DefaultConfig() *SigningProfile {
0000000000000000000000000000000000000000;;		d := helpers.OneYear
0000000000000000000000000000000000000000;;		return &SigningProfile{
0000000000000000000000000000000000000000;;			Usage:        []string{"signing", "key encipherment", "server auth", "client auth"},
0000000000000000000000000000000000000000;;			Expiry:       d,
0000000000000000000000000000000000000000;;			ExpiryString: "8760h",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadFile attempts to load the configuration file stored at the path
0000000000000000000000000000000000000000;;	// and returns the configuration. On error, it returns nil.
0000000000000000000000000000000000000000;;	func LoadFile(path string) (*Config, error) {
0000000000000000000000000000000000000000;;		log.Debugf("loading configuration file from %s", path)
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, errors.New("invalid path"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, errors.New("could not read configuration file"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return LoadConfig(body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadConfig attempts to load the configuration from a byte slice.
0000000000000000000000000000000000000000;;	// On error, it returns nil.
0000000000000000000000000000000000000000;;	func LoadConfig(config []byte) (*Config, error) {
0000000000000000000000000000000000000000;;		var cfg = &Config{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(config, &cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy,
0000000000000000000000000000000000000000;;				errors.New("failed to unmarshal configuration: "+err.Error()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Signing == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("No \"signing\" field present")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Signing.Default == nil {
0000000000000000000000000000000000000000;;			log.Debugf("no default given: using default config")
0000000000000000000000000000000000000000;;			cfg.Signing.Default = DefaultConfig()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err := cfg.Signing.Default.populate(cfg); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := range cfg.Signing.Profiles {
0000000000000000000000000000000000000000;;			if err := cfg.Signing.Profiles[k].populate(cfg); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cfg.Valid() {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.PolicyError, cferr.InvalidPolicy, errors.New("invalid configuration"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Debugf("configuration ok")
0000000000000000000000000000000000000000;;		return cfg, nil
0000000000000000000000000000000000000000;;	}
