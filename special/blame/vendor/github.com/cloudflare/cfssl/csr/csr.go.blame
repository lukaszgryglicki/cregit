0000000000000000000000000000000000000000;;	// Package csr implements certificate requests for CFSSL.
0000000000000000000000000000000000000000;;	package csr
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/mail"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cferr "github.com/cloudflare/cfssl/errors"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/helpers"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/log"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		curveP256 = 256
0000000000000000000000000000000000000000;;		curveP384 = 384
0000000000000000000000000000000000000000;;		curveP521 = 521
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Name contains the SubjectInfo fields.
0000000000000000000000000000000000000000;;	type Name struct {
0000000000000000000000000000000000000000;;		C            string // Country
0000000000000000000000000000000000000000;;		ST           string // State
0000000000000000000000000000000000000000;;		L            string // Locality
0000000000000000000000000000000000000000;;		O            string // OrganisationName
0000000000000000000000000000000000000000;;		OU           string // OrganisationalUnitName
0000000000000000000000000000000000000000;;		SerialNumber string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A KeyRequest is a generic request for a new key.
0000000000000000000000000000000000000000;;	type KeyRequest interface {
0000000000000000000000000000000000000000;;		Algo() string
0000000000000000000000000000000000000000;;		Size() int
0000000000000000000000000000000000000000;;		Generate() (crypto.PrivateKey, error)
0000000000000000000000000000000000000000;;		SigAlgo() x509.SignatureAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A BasicKeyRequest contains the algorithm and key size for a new private key.
0000000000000000000000000000000000000000;;	type BasicKeyRequest struct {
0000000000000000000000000000000000000000;;		A string `json:"algo"`
0000000000000000000000000000000000000000;;		S int    `json:"size"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBasicKeyRequest returns a default BasicKeyRequest.
0000000000000000000000000000000000000000;;	func NewBasicKeyRequest() *BasicKeyRequest {
0000000000000000000000000000000000000000;;		return &BasicKeyRequest{"ecdsa", curveP256}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Algo returns the requested key algorithm represented as a string.
0000000000000000000000000000000000000000;;	func (kr *BasicKeyRequest) Algo() string {
0000000000000000000000000000000000000000;;		return kr.A
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns the requested key size.
0000000000000000000000000000000000000000;;	func (kr *BasicKeyRequest) Size() int {
0000000000000000000000000000000000000000;;		return kr.S
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate generates a key as specified in the request. Currently,
0000000000000000000000000000000000000000;;	// only ECDSA and RSA are supported.
0000000000000000000000000000000000000000;;	func (kr *BasicKeyRequest) Generate() (crypto.PrivateKey, error) {
0000000000000000000000000000000000000000;;		log.Debugf("generate key from request: algo=%s, size=%d", kr.Algo(), kr.Size())
0000000000000000000000000000000000000000;;		switch kr.Algo() {
0000000000000000000000000000000000000000;;		case "rsa":
0000000000000000000000000000000000000000;;			if kr.Size() < 2048 {
0000000000000000000000000000000000000000;;				return nil, errors.New("RSA key is too weak")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if kr.Size() > 8192 {
0000000000000000000000000000000000000000;;				return nil, errors.New("RSA key size too large")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rsa.GenerateKey(rand.Reader, kr.Size())
0000000000000000000000000000000000000000;;		case "ecdsa":
0000000000000000000000000000000000000000;;			var curve elliptic.Curve
0000000000000000000000000000000000000000;;			switch kr.Size() {
0000000000000000000000000000000000000000;;			case curveP256:
0000000000000000000000000000000000000000;;				curve = elliptic.P256()
0000000000000000000000000000000000000000;;			case curveP384:
0000000000000000000000000000000000000000;;				curve = elliptic.P384()
0000000000000000000000000000000000000000;;			case curveP521:
0000000000000000000000000000000000000000;;				curve = elliptic.P521()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, errors.New("invalid curve")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ecdsa.GenerateKey(curve, rand.Reader)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid algorithm")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SigAlgo returns an appropriate X.509 signature algorithm given the
0000000000000000000000000000000000000000;;	// key request's type and size.
0000000000000000000000000000000000000000;;	func (kr *BasicKeyRequest) SigAlgo() x509.SignatureAlgorithm {
0000000000000000000000000000000000000000;;		switch kr.Algo() {
0000000000000000000000000000000000000000;;		case "rsa":
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case kr.Size() >= 4096:
0000000000000000000000000000000000000000;;				return x509.SHA512WithRSA
0000000000000000000000000000000000000000;;			case kr.Size() >= 3072:
0000000000000000000000000000000000000000;;				return x509.SHA384WithRSA
0000000000000000000000000000000000000000;;			case kr.Size() >= 2048:
0000000000000000000000000000000000000000;;				return x509.SHA256WithRSA
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return x509.SHA1WithRSA
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "ecdsa":
0000000000000000000000000000000000000000;;			switch kr.Size() {
0000000000000000000000000000000000000000;;			case curveP521:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA512
0000000000000000000000000000000000000000;;			case curveP384:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA384
0000000000000000000000000000000000000000;;			case curveP256:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA256
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return x509.UnknownSignatureAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CAConfig is a section used in the requests initialising a new CA.
0000000000000000000000000000000000000000;;	type CAConfig struct {
0000000000000000000000000000000000000000;;		PathLength int    `json:"pathlen"`
0000000000000000000000000000000000000000;;		Expiry     string `json:"expiry"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A CertificateRequest encapsulates the API interface to the
0000000000000000000000000000000000000000;;	// certificate request functionality.
0000000000000000000000000000000000000000;;	type CertificateRequest struct {
0000000000000000000000000000000000000000;;		CN           string
0000000000000000000000000000000000000000;;		Names        []Name     `json:"names"`
0000000000000000000000000000000000000000;;		Hosts        []string   `json:"hosts"`
0000000000000000000000000000000000000000;;		KeyRequest   KeyRequest `json:"key,omitempty"`
0000000000000000000000000000000000000000;;		CA           *CAConfig  `json:"ca,omitempty"`
0000000000000000000000000000000000000000;;		SerialNumber string     `json:"serialnumber,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new, empty CertificateRequest with a
0000000000000000000000000000000000000000;;	// BasicKeyRequest.
0000000000000000000000000000000000000000;;	func New() *CertificateRequest {
0000000000000000000000000000000000000000;;		return &CertificateRequest{
0000000000000000000000000000000000000000;;			KeyRequest: NewBasicKeyRequest(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendIf appends to a if s is not an empty string.
0000000000000000000000000000000000000000;;	func appendIf(s string, a *[]string) {
0000000000000000000000000000000000000000;;		if s != "" {
0000000000000000000000000000000000000000;;			*a = append(*a, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the PKIX name for the request.
0000000000000000000000000000000000000000;;	func (cr *CertificateRequest) Name() pkix.Name {
0000000000000000000000000000000000000000;;		var name pkix.Name
0000000000000000000000000000000000000000;;		name.CommonName = cr.CN
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range cr.Names {
0000000000000000000000000000000000000000;;			appendIf(n.C, &name.Country)
0000000000000000000000000000000000000000;;			appendIf(n.ST, &name.Province)
0000000000000000000000000000000000000000;;			appendIf(n.L, &name.Locality)
0000000000000000000000000000000000000000;;			appendIf(n.O, &name.Organization)
0000000000000000000000000000000000000000;;			appendIf(n.OU, &name.OrganizationalUnit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name.SerialNumber = cr.SerialNumber
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseRequest takes a certificate request and generates a key and
0000000000000000000000000000000000000000;;	// CSR from it. It does no validation -- caveat emptor. It will,
0000000000000000000000000000000000000000;;	// however, fail if the key request is not valid (i.e., an unsupported
0000000000000000000000000000000000000000;;	// curve or RSA key size). The lack of validation was specifically
0000000000000000000000000000000000000000;;	// chosen to allow the end user to define a policy and validate the
0000000000000000000000000000000000000000;;	// request appropriately before calling this function.
0000000000000000000000000000000000000000;;	func ParseRequest(req *CertificateRequest) (csr, key []byte, err error) {
0000000000000000000000000000000000000000;;		log.Info("received CSR")
0000000000000000000000000000000000000000;;		if req.KeyRequest == nil {
0000000000000000000000000000000000000000;;			req.KeyRequest = NewBasicKeyRequest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Infof("generating key: %s-%d", req.KeyRequest.Algo(), req.KeyRequest.Size())
0000000000000000000000000000000000000000;;		priv, err := req.KeyRequest.Generate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = cferr.Wrap(cferr.PrivateKeyError, cferr.GenerationFailed, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch priv := priv.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			key = x509.MarshalPKCS1PrivateKey(priv)
0000000000000000000000000000000000000000;;			block := pem.Block{
0000000000000000000000000000000000000000;;				Type:  "RSA PRIVATE KEY",
0000000000000000000000000000000000000000;;				Bytes: key,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key = pem.EncodeToMemory(&block)
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			key, err = x509.MarshalECPrivateKey(priv)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = cferr.Wrap(cferr.PrivateKeyError, cferr.Unknown, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			block := pem.Block{
0000000000000000000000000000000000000000;;				Type:  "EC PRIVATE KEY",
0000000000000000000000000000000000000000;;				Bytes: key,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key = pem.EncodeToMemory(&block)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("Generate should have failed to produce a valid key.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tpl = x509.CertificateRequest{
0000000000000000000000000000000000000000;;			Subject:            req.Name(),
0000000000000000000000000000000000000000;;			SignatureAlgorithm: req.KeyRequest.SigAlgo(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range req.Hosts {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(req.Hosts[i]); ip != nil {
0000000000000000000000000000000000000000;;				tpl.IPAddresses = append(tpl.IPAddresses, ip)
0000000000000000000000000000000000000000;;			} else if email, err := mail.ParseAddress(req.Hosts[i]); err == nil && email != nil {
0000000000000000000000000000000000000000;;				tpl.EmailAddresses = append(tpl.EmailAddresses, req.Hosts[i])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tpl.DNSNames = append(tpl.DNSNames, req.Hosts[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr, err = x509.CreateCertificateRequest(rand.Reader, &tpl, priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Errorf("failed to generate a CSR: %v", err)
0000000000000000000000000000000000000000;;			err = cferr.Wrap(cferr.CSRError, cferr.BadRequest, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block := pem.Block{
0000000000000000000000000000000000000000;;			Type:  "CERTIFICATE REQUEST",
0000000000000000000000000000000000000000;;			Bytes: csr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Info("encoded CSR")
0000000000000000000000000000000000000000;;		csr = pem.EncodeToMemory(&block)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractCertificateRequest extracts a CertificateRequest from
0000000000000000000000000000000000000000;;	// x509.Certificate. It is aimed to used for generating a new certificate
0000000000000000000000000000000000000000;;	// from an existing certificate. For a root certificate, the CA expiry
0000000000000000000000000000000000000000;;	// length is calculated as the duration between cert.NotAfter and cert.NotBefore.
0000000000000000000000000000000000000000;;	func ExtractCertificateRequest(cert *x509.Certificate) *CertificateRequest {
0000000000000000000000000000000000000000;;		req := New()
0000000000000000000000000000000000000000;;		req.CN = cert.Subject.CommonName
0000000000000000000000000000000000000000;;		req.Names = getNames(cert.Subject)
0000000000000000000000000000000000000000;;		req.Hosts = getHosts(cert)
0000000000000000000000000000000000000000;;		req.SerialNumber = cert.Subject.SerialNumber
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cert.IsCA {
0000000000000000000000000000000000000000;;			req.CA = new(CAConfig)
0000000000000000000000000000000000000000;;			// CA expiry length is calculated based on the input cert
0000000000000000000000000000000000000000;;			// issue date and expiry date.
0000000000000000000000000000000000000000;;			req.CA.Expiry = cert.NotAfter.Sub(cert.NotBefore).String()
0000000000000000000000000000000000000000;;			req.CA.PathLength = cert.MaxPathLen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getHosts(cert *x509.Certificate) []string {
0000000000000000000000000000000000000000;;		var hosts []string
0000000000000000000000000000000000000000;;		for _, ip := range cert.IPAddresses {
0000000000000000000000000000000000000000;;			hosts = append(hosts, ip.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, dns := range cert.DNSNames {
0000000000000000000000000000000000000000;;			hosts = append(hosts, dns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, email := range cert.EmailAddresses {
0000000000000000000000000000000000000000;;			hosts = append(hosts, email)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hosts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNames returns an array of Names from the certificate
0000000000000000000000000000000000000000;;	// It onnly cares about Country, Organization, OrganizationalUnit, Locality, Province
0000000000000000000000000000000000000000;;	func getNames(sub pkix.Name) []Name {
0000000000000000000000000000000000000000;;		// anonymous func for finding the max of a list of interger
0000000000000000000000000000000000000000;;		max := func(v1 int, vn ...int) (max int) {
0000000000000000000000000000000000000000;;			max = v1
0000000000000000000000000000000000000000;;			for i := 0; i < len(vn); i++ {
0000000000000000000000000000000000000000;;				if vn[i] > max {
0000000000000000000000000000000000000000;;					max = vn[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nc := len(sub.Country)
0000000000000000000000000000000000000000;;		norg := len(sub.Organization)
0000000000000000000000000000000000000000;;		nou := len(sub.OrganizationalUnit)
0000000000000000000000000000000000000000;;		nl := len(sub.Locality)
0000000000000000000000000000000000000000;;		np := len(sub.Province)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := max(nc, norg, nou, nl, np)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names := make([]Name, n)
0000000000000000000000000000000000000000;;		for i := range names {
0000000000000000000000000000000000000000;;			if i < nc {
0000000000000000000000000000000000000000;;				names[i].C = sub.Country[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i < norg {
0000000000000000000000000000000000000000;;				names[i].O = sub.Organization[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i < nou {
0000000000000000000000000000000000000000;;				names[i].OU = sub.OrganizationalUnit[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i < nl {
0000000000000000000000000000000000000000;;				names[i].L = sub.Locality[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i < np {
0000000000000000000000000000000000000000;;				names[i].ST = sub.Province[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Generator is responsible for validating certificate requests.
0000000000000000000000000000000000000000;;	type Generator struct {
0000000000000000000000000000000000000000;;		Validator func(*CertificateRequest) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProcessRequest validates and processes the incoming request. It is
0000000000000000000000000000000000000000;;	// a wrapper around a validator and the ParseRequest function.
0000000000000000000000000000000000000000;;	func (g *Generator) ProcessRequest(req *CertificateRequest) (csr, key []byte, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Info("generate received request")
0000000000000000000000000000000000000000;;		err = g.Validator(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Warningf("invalid request: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr, key, err = ParseRequest(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNameEmpty returns true if the name has no identifying information in it.
0000000000000000000000000000000000000000;;	func IsNameEmpty(n Name) bool {
0000000000000000000000000000000000000000;;		empty := func(s string) bool { return strings.TrimSpace(s) == "" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if empty(n.C) && empty(n.ST) && empty(n.L) && empty(n.O) && empty(n.OU) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Regenerate uses the provided CSR as a template for signing a new
0000000000000000000000000000000000000000;;	// CSR using priv.
0000000000000000000000000000000000000000;;	func Regenerate(priv crypto.Signer, csr []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		req, extra, err := helpers.ParseCSR(csr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if len(extra) > 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("csr: trailing data in certificate request")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return x509.CreateCertificateRequest(rand.Reader, req, priv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate creates a new CSR from a CertificateRequest structure and
0000000000000000000000000000000000000000;;	// an existing key. The KeyRequest field is ignored.
0000000000000000000000000000000000000000;;	func Generate(priv crypto.Signer, req *CertificateRequest) (csr []byte, err error) {
0000000000000000000000000000000000000000;;		sigAlgo := helpers.SignerAlgo(priv, crypto.SHA256)
0000000000000000000000000000000000000000;;		if sigAlgo == x509.UnknownSignatureAlgorithm {
0000000000000000000000000000000000000000;;			return nil, cferr.New(cferr.PrivateKeyError, cferr.Unavailable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tpl = x509.CertificateRequest{
0000000000000000000000000000000000000000;;			Subject:            req.Name(),
0000000000000000000000000000000000000000;;			SignatureAlgorithm: sigAlgo,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range req.Hosts {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(req.Hosts[i]); ip != nil {
0000000000000000000000000000000000000000;;				tpl.IPAddresses = append(tpl.IPAddresses, ip)
0000000000000000000000000000000000000000;;			} else if email, err := mail.ParseAddress(req.Hosts[i]); err == nil && email != nil {
0000000000000000000000000000000000000000;;				tpl.EmailAddresses = append(tpl.EmailAddresses, email.Address)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tpl.DNSNames = append(tpl.DNSNames, req.Hosts[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csr, err = x509.CreateCertificateRequest(rand.Reader, &tpl, priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Errorf("failed to generate a CSR: %v", err)
0000000000000000000000000000000000000000;;			err = cferr.Wrap(cferr.CSRError, cferr.BadRequest, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		block := pem.Block{
0000000000000000000000000000000000000000;;			Type:  "CERTIFICATE REQUEST",
0000000000000000000000000000000000000000;;			Bytes: csr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		log.Info("encoded CSR")
0000000000000000000000000000000000000000;;		csr = pem.EncodeToMemory(&block)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
