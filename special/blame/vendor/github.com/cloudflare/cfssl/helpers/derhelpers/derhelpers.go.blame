0000000000000000000000000000000000000000;;	// Package derhelpers implements common functionality
0000000000000000000000000000000000000000;;	// on DER encoded data
0000000000000000000000000000000000000000;;	package derhelpers
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cferr "github.com/cloudflare/cfssl/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePrivateKeyDER parses a PKCS #1, PKCS #8, or elliptic curve
0000000000000000000000000000000000000000;;	// DER-encoded private key. The key must not be in PEM format.
0000000000000000000000000000000000000000;;	func ParsePrivateKeyDER(keyDER []byte) (key crypto.Signer, err error) {
0000000000000000000000000000000000000000;;		generalKey, err := x509.ParsePKCS8PrivateKey(keyDER)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			generalKey, err = x509.ParsePKCS1PrivateKey(keyDER)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				generalKey, err = x509.ParseECPrivateKey(keyDER)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// We don't include the actual error into
0000000000000000000000000000000000000000;;					// the final error. The reason might be
0000000000000000000000000000000000000000;;					// we don't want to leak any info about
0000000000000000000000000000000000000000;;					// the private key.
0000000000000000000000000000000000000000;;					return nil, cferr.New(cferr.PrivateKeyError,
0000000000000000000000000000000000000000;;						cferr.ParseFailed)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch generalKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			return generalKey.(*rsa.PrivateKey), nil
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			return generalKey.(*ecdsa.PrivateKey), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should never reach here
0000000000000000000000000000000000000000;;		return nil, cferr.New(cferr.PrivateKeyError, cferr.ParseFailed)
0000000000000000000000000000000000000000;;	}
