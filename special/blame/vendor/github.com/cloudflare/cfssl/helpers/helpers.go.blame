0000000000000000000000000000000000000000;;	// Package helpers implements utility functionality common to many
0000000000000000000000000000000000000000;;	// CFSSL packages.
0000000000000000000000000000000000000000;;	package helpers
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/crypto/pkcs7"
0000000000000000000000000000000000000000;;		cferr "github.com/cloudflare/cfssl/errors"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/helpers/derhelpers"
0000000000000000000000000000000000000000;;		"github.com/cloudflare/cfssl/log"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/pkcs12"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OneYear is a time.Duration representing a year's worth of seconds.
0000000000000000000000000000000000000000;;	const OneYear = 8760 * time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OneDay is a time.Duration representing a day's worth of seconds.
0000000000000000000000000000000000000000;;	const OneDay = 24 * time.Hour
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InclusiveDate returns the time.Time representation of a date - 1
0000000000000000000000000000000000000000;;	// nanosecond. This allows time.After to be used inclusively.
0000000000000000000000000000000000000000;;	func InclusiveDate(year int, month time.Month, day int) time.Time {
0000000000000000000000000000000000000000;;		return time.Date(year, month, day, 0, 0, 0, 0, time.UTC).Add(-1 * time.Nanosecond)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Jul2012 is the July 2012 CAB Forum deadline for when CAs must stop
0000000000000000000000000000000000000000;;	// issuing certificates valid for more than 5 years.
0000000000000000000000000000000000000000;;	var Jul2012 = InclusiveDate(2012, time.July, 01)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Apr2015 is the April 2015 CAB Forum deadline for when CAs must stop
0000000000000000000000000000000000000000;;	// issuing certificates valid for more than 39 months.
0000000000000000000000000000000000000000;;	var Apr2015 = InclusiveDate(2015, time.April, 01)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyLength returns the bit size of ECDSA or RSA PublicKey
0000000000000000000000000000000000000000;;	func KeyLength(key interface{}) int {
0000000000000000000000000000000000000000;;		if key == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ecdsaKey, ok := key.(*ecdsa.PublicKey); ok {
0000000000000000000000000000000000000000;;			return ecdsaKey.Curve.Params().BitSize
0000000000000000000000000000000000000000;;		} else if rsaKey, ok := key.(*rsa.PublicKey); ok {
0000000000000000000000000000000000000000;;			return rsaKey.N.BitLen()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpiryTime returns the time when the certificate chain is expired.
0000000000000000000000000000000000000000;;	func ExpiryTime(chain []*x509.Certificate) (notAfter time.Time) {
0000000000000000000000000000000000000000;;		if len(chain) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		notAfter = chain[0].NotAfter
0000000000000000000000000000000000000000;;		for _, cert := range chain {
0000000000000000000000000000000000000000;;			if notAfter.After(cert.NotAfter) {
0000000000000000000000000000000000000000;;				notAfter = cert.NotAfter
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MonthsValid returns the number of months for which a certificate is valid.
0000000000000000000000000000000000000000;;	func MonthsValid(c *x509.Certificate) int {
0000000000000000000000000000000000000000;;		issued := c.NotBefore
0000000000000000000000000000000000000000;;		expiry := c.NotAfter
0000000000000000000000000000000000000000;;		years := (expiry.Year() - issued.Year())
0000000000000000000000000000000000000000;;		months := years*12 + int(expiry.Month()) - int(issued.Month())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Round up if valid for less than a full month
0000000000000000000000000000000000000000;;		if expiry.Day() > issued.Day() {
0000000000000000000000000000000000000000;;			months++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return months
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidExpiry determines if a certificate is valid for an acceptable
0000000000000000000000000000000000000000;;	// length of time per the CA/Browser Forum baseline requirements.
0000000000000000000000000000000000000000;;	// See https://cabforum.org/wp-content/uploads/CAB-Forum-BR-1.3.0.pdf
0000000000000000000000000000000000000000;;	func ValidExpiry(c *x509.Certificate) bool {
0000000000000000000000000000000000000000;;		issued := c.NotBefore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var maxMonths int
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case issued.After(Apr2015):
0000000000000000000000000000000000000000;;			maxMonths = 39
0000000000000000000000000000000000000000;;		case issued.After(Jul2012):
0000000000000000000000000000000000000000;;			maxMonths = 60
0000000000000000000000000000000000000000;;		case issued.Before(Jul2012):
0000000000000000000000000000000000000000;;			maxMonths = 120
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if MonthsValid(c) > maxMonths {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureString returns the TLS signature string corresponding to
0000000000000000000000000000000000000000;;	// an X509 signature algorithm.
0000000000000000000000000000000000000000;;	func SignatureString(alg x509.SignatureAlgorithm) string {
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case x509.MD2WithRSA:
0000000000000000000000000000000000000000;;			return "MD2WithRSA"
0000000000000000000000000000000000000000;;		case x509.MD5WithRSA:
0000000000000000000000000000000000000000;;			return "MD5WithRSA"
0000000000000000000000000000000000000000;;		case x509.SHA1WithRSA:
0000000000000000000000000000000000000000;;			return "SHA1WithRSA"
0000000000000000000000000000000000000000;;		case x509.SHA256WithRSA:
0000000000000000000000000000000000000000;;			return "SHA256WithRSA"
0000000000000000000000000000000000000000;;		case x509.SHA384WithRSA:
0000000000000000000000000000000000000000;;			return "SHA384WithRSA"
0000000000000000000000000000000000000000;;		case x509.SHA512WithRSA:
0000000000000000000000000000000000000000;;			return "SHA512WithRSA"
0000000000000000000000000000000000000000;;		case x509.DSAWithSHA1:
0000000000000000000000000000000000000000;;			return "DSAWithSHA1"
0000000000000000000000000000000000000000;;		case x509.DSAWithSHA256:
0000000000000000000000000000000000000000;;			return "DSAWithSHA256"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA1:
0000000000000000000000000000000000000000;;			return "ECDSAWithSHA1"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA256:
0000000000000000000000000000000000000000;;			return "ECDSAWithSHA256"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA384:
0000000000000000000000000000000000000000;;			return "ECDSAWithSHA384"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA512:
0000000000000000000000000000000000000000;;			return "ECDSAWithSHA512"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "Unknown Signature"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashAlgoString returns the hash algorithm name contains in the signature
0000000000000000000000000000000000000000;;	// method.
0000000000000000000000000000000000000000;;	func HashAlgoString(alg x509.SignatureAlgorithm) string {
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case x509.MD2WithRSA:
0000000000000000000000000000000000000000;;			return "MD2"
0000000000000000000000000000000000000000;;		case x509.MD5WithRSA:
0000000000000000000000000000000000000000;;			return "MD5"
0000000000000000000000000000000000000000;;		case x509.SHA1WithRSA:
0000000000000000000000000000000000000000;;			return "SHA1"
0000000000000000000000000000000000000000;;		case x509.SHA256WithRSA:
0000000000000000000000000000000000000000;;			return "SHA256"
0000000000000000000000000000000000000000;;		case x509.SHA384WithRSA:
0000000000000000000000000000000000000000;;			return "SHA384"
0000000000000000000000000000000000000000;;		case x509.SHA512WithRSA:
0000000000000000000000000000000000000000;;			return "SHA512"
0000000000000000000000000000000000000000;;		case x509.DSAWithSHA1:
0000000000000000000000000000000000000000;;			return "SHA1"
0000000000000000000000000000000000000000;;		case x509.DSAWithSHA256:
0000000000000000000000000000000000000000;;			return "SHA256"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA1:
0000000000000000000000000000000000000000;;			return "SHA1"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA256:
0000000000000000000000000000000000000000;;			return "SHA256"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA384:
0000000000000000000000000000000000000000;;			return "SHA384"
0000000000000000000000000000000000000000;;		case x509.ECDSAWithSHA512:
0000000000000000000000000000000000000000;;			return "SHA512"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "Unknown Hash Algorithm"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeCertificatesPEM encodes a number of x509 certficates to PEM
0000000000000000000000000000000000000000;;	func EncodeCertificatesPEM(certs []*x509.Certificate) []byte {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		for _, cert := range certs {
0000000000000000000000000000000000000000;;			pem.Encode(&buffer, &pem.Block{
0000000000000000000000000000000000000000;;				Type:  "CERTIFICATE",
0000000000000000000000000000000000000000;;				Bytes: cert.Raw,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buffer.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeCertificatePEM encodes a single x509 certficates to PEM
0000000000000000000000000000000000000000;;	func EncodeCertificatePEM(cert *x509.Certificate) []byte {
0000000000000000000000000000000000000000;;		return EncodeCertificatesPEM([]*x509.Certificate{cert})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCertificatesPEM parses a sequence of PEM-encoded certificate and returns them,
0000000000000000000000000000000000000000;;	// can handle PEM encoded PKCS #7 structures.
0000000000000000000000000000000000000000;;	func ParseCertificatesPEM(certsPEM []byte) ([]*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		var certs []*x509.Certificate
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		certsPEM = bytes.TrimSpace(certsPEM)
0000000000000000000000000000000000000000;;		for len(certsPEM) > 0 {
0000000000000000000000000000000000000000;;			var cert []*x509.Certificate
0000000000000000000000000000000000000000;;			cert, certsPEM, err = ParseOneCertificateFromPEM(certsPEM)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil, cferr.New(cferr.CertificateError, cferr.ParseFailed)
0000000000000000000000000000000000000000;;			} else if cert == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			certs = append(certs, cert...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(certsPEM) > 0 {
0000000000000000000000000000000000000000;;			return nil, cferr.New(cferr.CertificateError, cferr.DecodeFailed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCertificatesDER parses a DER encoding of a certificate object and possibly private key,
0000000000000000000000000000000000000000;;	// either PKCS #7, PKCS #12, or raw x509.
0000000000000000000000000000000000000000;;	func ParseCertificatesDER(certsDER []byte, password string) (certs []*x509.Certificate, key crypto.Signer, err error) {
0000000000000000000000000000000000000000;;		certsDER = bytes.TrimSpace(certsDER)
0000000000000000000000000000000000000000;;		pkcs7data, err := pkcs7.ParsePKCS7(certsDER)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			var pkcs12data interface{}
0000000000000000000000000000000000000000;;			certs = make([]*x509.Certificate, 1)
0000000000000000000000000000000000000000;;			pkcs12data, certs[0], err = pkcs12.Decode(certsDER, password)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				certs, err = x509.ParseCertificates(certsDER)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, cferr.New(cferr.CertificateError, cferr.DecodeFailed)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				key = pkcs12data.(crypto.Signer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if pkcs7data.ContentInfo != "SignedData" {
0000000000000000000000000000000000000000;;				return nil, nil, cferr.Wrap(cferr.CertificateError, cferr.DecodeFailed, errors.New("can only extract certificates from signed data content info"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			certs = pkcs7data.Content.SignedData.Certificates
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if certs == nil {
0000000000000000000000000000000000000000;;			return nil, key, cferr.New(cferr.CertificateError, cferr.DecodeFailed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return certs, key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSelfSignedCertificatePEM parses a PEM-encoded certificate and check if it is self-signed.
0000000000000000000000000000000000000000;;	func ParseSelfSignedCertificatePEM(certPEM []byte) (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		cert, err := ParseCertificatePEM(certPEM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := cert.CheckSignature(cert.SignatureAlgorithm, cert.RawTBSCertificate, cert.Signature); err != nil {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CertificateError, cferr.VerifyFailed, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cert, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCertificatePEM parses and returns a PEM-encoded certificate,
0000000000000000000000000000000000000000;;	// can handle PEM encoded PKCS #7 structures.
0000000000000000000000000000000000000000;;	func ParseCertificatePEM(certPEM []byte) (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		certPEM = bytes.TrimSpace(certPEM)
0000000000000000000000000000000000000000;;		cert, rest, err := ParseOneCertificateFromPEM(certPEM)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Log the actual parsing error but throw a default parse error message.
0000000000000000000000000000000000000000;;			log.Debugf("Certificate parsing error: %v", err)
0000000000000000000000000000000000000000;;			return nil, cferr.New(cferr.CertificateError, cferr.ParseFailed)
0000000000000000000000000000000000000000;;		} else if cert == nil {
0000000000000000000000000000000000000000;;			return nil, cferr.New(cferr.CertificateError, cferr.DecodeFailed)
0000000000000000000000000000000000000000;;		} else if len(rest) > 0 {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, errors.New("the PEM file should contain only one object"))
0000000000000000000000000000000000000000;;		} else if len(cert) > 1 {
0000000000000000000000000000000000000000;;			return nil, cferr.Wrap(cferr.CertificateError, cferr.ParseFailed, errors.New("the PKCS7 object in the PEM file should contain only one certificate"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cert[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseOneCertificateFromPEM attempts to parse one PEM encoded certificate object,
0000000000000000000000000000000000000000;;	// either a raw x509 certificate or a PKCS #7 structure possibly containing
0000000000000000000000000000000000000000;;	// multiple certificates, from the top of certsPEM, which itself may
0000000000000000000000000000000000000000;;	// contain multiple PEM encoded certificate objects.
0000000000000000000000000000000000000000;;	func ParseOneCertificateFromPEM(certsPEM []byte) ([]*x509.Certificate, []byte, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		block, rest := pem.Decode(certsPEM)
0000000000000000000000000000000000000000;;		if block == nil {
0000000000000000000000000000000000000000;;			return nil, rest, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert, err := x509.ParseCertificate(block.Bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			pkcs7data, err := pkcs7.ParsePKCS7(block.Bytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, rest, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pkcs7data.ContentInfo != "SignedData" {
0000000000000000000000000000000000000000;;				return nil, rest, errors.New("only PKCS #7 Signed Data Content Info supported for certificate parsing")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			certs := pkcs7data.Content.SignedData.Certificates
0000000000000000000000000000000000000000;;			if certs == nil {
0000000000000000000000000000000000000000;;				return nil, rest, errors.New("PKCS #7 structure contains no certificates")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return certs, rest, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var certs = []*x509.Certificate{cert}
0000000000000000000000000000000000000000;;		return certs, rest, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadPEMCertPool loads a pool of PEM certificates from file.
0000000000000000000000000000000000000000;;	func LoadPEMCertPool(certsFile string) (*x509.CertPool, error) {
0000000000000000000000000000000000000000;;		pemCerts, err := ioutil.ReadFile(certsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;		if !certPool.AppendCertsFromPEM(pemCerts) {
0000000000000000000000000000000000000000;;			return nil, errors.New("failed to load cert pool")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return certPool, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePrivateKeyPEM parses and returns a PEM-encoded private
0000000000000000000000000000000000000000;;	// key. The private key may be either an unencrypted PKCS#8, PKCS#1,
0000000000000000000000000000000000000000;;	// or elliptic private key.
0000000000000000000000000000000000000000;;	func ParsePrivateKeyPEM(keyPEM []byte) (key crypto.Signer, err error) {
0000000000000000000000000000000000000000;;		return ParsePrivateKeyPEMWithPassword(keyPEM, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePrivateKeyPEMWithPassword parses and returns a PEM-encoded private
0000000000000000000000000000000000000000;;	// key. The private key may be a potentially encrypted PKCS#8, PKCS#1,
0000000000000000000000000000000000000000;;	// or elliptic private key.
0000000000000000000000000000000000000000;;	func ParsePrivateKeyPEMWithPassword(keyPEM []byte, password []byte) (key crypto.Signer, err error) {
0000000000000000000000000000000000000000;;		keyDER, err := GetKeyDERFromPEM(keyPEM, password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return derhelpers.ParsePrivateKeyDER(keyDER)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetKeyDERFromPEM parses a PEM-encoded private key and returns DER-format key bytes.
0000000000000000000000000000000000000000;;	func GetKeyDERFromPEM(in []byte, password []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		keyDER, _ := pem.Decode(in)
0000000000000000000000000000000000000000;;		if keyDER != nil {
0000000000000000000000000000000000000000;;			if procType, ok := keyDER.Headers["Proc-Type"]; ok {
0000000000000000000000000000000000000000;;				if strings.Contains(procType, "ENCRYPTED") {
0000000000000000000000000000000000000000;;					if password != nil {
0000000000000000000000000000000000000000;;						return x509.DecryptPEMBlock(keyDER, password)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, cferr.New(cferr.PrivateKeyError, cferr.Encrypted)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return keyDER.Bytes, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, cferr.New(cferr.PrivateKeyError, cferr.DecodeFailed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckSignature verifies a signature made by the key on a CSR, such
0000000000000000000000000000000000000000;;	// as on the CSR itself.
0000000000000000000000000000000000000000;;	func CheckSignature(csr *x509.CertificateRequest, algo x509.SignatureAlgorithm, signed, signature []byte) error {
0000000000000000000000000000000000000000;;		var hashType crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch algo {
0000000000000000000000000000000000000000;;		case x509.SHA1WithRSA, x509.ECDSAWithSHA1:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA1
0000000000000000000000000000000000000000;;		case x509.SHA256WithRSA, x509.ECDSAWithSHA256:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA256
0000000000000000000000000000000000000000;;		case x509.SHA384WithRSA, x509.ECDSAWithSHA384:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA384
0000000000000000000000000000000000000000;;		case x509.SHA512WithRSA, x509.ECDSAWithSHA512:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA512
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return x509.ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !hashType.Available() {
0000000000000000000000000000000000000000;;			return x509.ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := hashType.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.Write(signed)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch pub := csr.PublicKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			return rsa.VerifyPKCS1v15(pub, hashType, digest, signature)
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			ecdsaSig := new(struct{ R, S *big.Int })
0000000000000000000000000000000000000000;;			if _, err := asn1.Unmarshal(signature, ecdsaSig); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {
0000000000000000000000000000000000000000;;				return errors.New("x509: ECDSA signature contained zero or negative values")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ecdsa.Verify(pub, digest, ecdsaSig.R, ecdsaSig.S) {
0000000000000000000000000000000000000000;;				return errors.New("x509: ECDSA verification failure")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x509.ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCSR parses a PEM- or DER-encoded PKCS #10 certificate signing request.
0000000000000000000000000000000000000000;;	func ParseCSR(in []byte) (csr *x509.CertificateRequest, rest []byte, err error) {
0000000000000000000000000000000000000000;;		in = bytes.TrimSpace(in)
0000000000000000000000000000000000000000;;		p, rest := pem.Decode(in)
0000000000000000000000000000000000000000;;		if p != nil {
0000000000000000000000000000000000000000;;			if p.Type != "CERTIFICATE REQUEST" {
0000000000000000000000000000000000000000;;				return nil, rest, cferr.New(cferr.CSRError, cferr.BadRequest)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			csr, err = x509.ParseCertificateRequest(p.Bytes)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			csr, err = x509.ParseCertificateRequest(in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, rest, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = CheckSignature(csr, csr.SignatureAlgorithm, csr.RawTBSCertificateRequest, csr.Signature)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, rest, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return csr, rest, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCSRPEM parses a PEM-encoded certificiate signing request.
0000000000000000000000000000000000000000;;	// It does not check the signature. This is useful for dumping data from a CSR
0000000000000000000000000000000000000000;;	// locally.
0000000000000000000000000000000000000000;;	func ParseCSRPEM(csrPEM []byte) (*x509.CertificateRequest, error) {
0000000000000000000000000000000000000000;;		block, _ := pem.Decode([]byte(csrPEM))
0000000000000000000000000000000000000000;;		der := block.Bytes
0000000000000000000000000000000000000000;;		csrObject, err := x509.ParseCertificateRequest(der)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return csrObject, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignerAlgo returns an X.509 signature algorithm corresponding to
0000000000000000000000000000000000000000;;	// the crypto.Hash provided from a crypto.Signer.
0000000000000000000000000000000000000000;;	func SignerAlgo(priv crypto.Signer, h crypto.Hash) x509.SignatureAlgorithm {
0000000000000000000000000000000000000000;;		switch priv.Public().(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			switch h {
0000000000000000000000000000000000000000;;			case crypto.SHA512:
0000000000000000000000000000000000000000;;				return x509.SHA512WithRSA
0000000000000000000000000000000000000000;;			case crypto.SHA384:
0000000000000000000000000000000000000000;;				return x509.SHA384WithRSA
0000000000000000000000000000000000000000;;			case crypto.SHA256:
0000000000000000000000000000000000000000;;				return x509.SHA256WithRSA
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return x509.SHA1WithRSA
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			switch h {
0000000000000000000000000000000000000000;;			case crypto.SHA512:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA512
0000000000000000000000000000000000000000;;			case crypto.SHA384:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA384
0000000000000000000000000000000000000000;;			case crypto.SHA256:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA256
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return x509.ECDSAWithSHA1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return x509.UnknownSignatureAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
