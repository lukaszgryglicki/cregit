0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/auth.go[Godeps/_workspace/src/github.com/godbus/dbus/auth.go][vendor/github.com/godbus/dbus/auth.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthStatus represents the Status of an authentication mechanism.
0000000000000000000000000000000000000000;;	type AuthStatus byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// AuthOk signals that authentication is finished; the next command
0000000000000000000000000000000000000000;;		// from the server should be an OK.
0000000000000000000000000000000000000000;;		AuthOk AuthStatus = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuthContinue signals that additional data is needed; the next command
0000000000000000000000000000000000000000;;		// from the server should be a DATA.
0000000000000000000000000000000000000000;;		AuthContinue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuthError signals an error; the server sent invalid data or some
0000000000000000000000000000000000000000;;		// other unexpected thing happened and the current authentication
0000000000000000000000000000000000000000;;		// process should be aborted.
0000000000000000000000000000000000000000;;		AuthError
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authState byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		waitingForData authState = iota
0000000000000000000000000000000000000000;;		waitingForOk
0000000000000000000000000000000000000000;;		waitingForReject
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Auth defines the behaviour of an authentication mechanism.
0000000000000000000000000000000000000000;;	type Auth interface {
0000000000000000000000000000000000000000;;		// Return the name of the mechnism, the argument to the first AUTH command
0000000000000000000000000000000000000000;;		// and the next status.
0000000000000000000000000000000000000000;;		FirstData() (name, resp []byte, status AuthStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Process the given DATA command, and return the argument to the DATA
0000000000000000000000000000000000000000;;		// command and the next status. If len(resp) == 0, no DATA command is sent.
0000000000000000000000000000000000000000;;		HandleData(data []byte) (resp []byte, status AuthStatus)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Auth authenticates the connection, trying the given list of authentication
0000000000000000000000000000000000000000;;	// mechanisms (in that order). If nil is passed, the EXTERNAL and
0000000000000000000000000000000000000000;;	// DBUS_COOKIE_SHA1 mechanisms are tried for the current user. For private
0000000000000000000000000000000000000000;;	// connections, this method must be called before sending any messages to the
0000000000000000000000000000000000000000;;	// bus. Auth must not be called on shared connections.
0000000000000000000000000000000000000000;;	func (conn *Conn) Auth(methods []Auth) error {
0000000000000000000000000000000000000000;;		if methods == nil {
0000000000000000000000000000000000000000;;			uid := strconv.Itoa(os.Getuid())
0000000000000000000000000000000000000000;;			methods = []Auth{AuthExternal(uid), AuthCookieSha1(uid, getHomeDir())}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		in := bufio.NewReader(conn.transport)
0000000000000000000000000000000000000000;;		err := conn.transport.SendNullByte()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = authWriteLine(conn.transport, []byte("AUTH"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s, err := authReadLine(in)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) < 2 || !bytes.Equal(s[0], []byte("REJECTED")) {
0000000000000000000000000000000000000000;;			return errors.New("dbus: authentication protocol error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = s[1:]
0000000000000000000000000000000000000000;;		for _, v := range s {
0000000000000000000000000000000000000000;;			for _, m := range methods {
0000000000000000000000000000000000000000;;				if name, data, status := m.FirstData(); bytes.Equal(v, name) {
0000000000000000000000000000000000000000;;					var ok bool
0000000000000000000000000000000000000000;;					err = authWriteLine(conn.transport, []byte("AUTH"), []byte(v), data)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					switch status {
0000000000000000000000000000000000000000;;					case AuthOk:
0000000000000000000000000000000000000000;;						err, ok = conn.tryAuth(m, waitingForOk, in)
0000000000000000000000000000000000000000;;					case AuthContinue:
0000000000000000000000000000000000000000;;						err, ok = conn.tryAuth(m, waitingForData, in)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						panic("dbus: invalid authentication status")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						if conn.transport.SupportsUnixFDs() {
0000000000000000000000000000000000000000;;							err = authWriteLine(conn, []byte("NEGOTIATE_UNIX_FD"))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							line, err := authReadLine(in)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							switch {
0000000000000000000000000000000000000000;;							case bytes.Equal(line[0], []byte("AGREE_UNIX_FD")):
0000000000000000000000000000000000000000;;								conn.EnableUnixFDs()
0000000000000000000000000000000000000000;;								conn.unixFD = true
0000000000000000000000000000000000000000;;							case bytes.Equal(line[0], []byte("ERROR")):
0000000000000000000000000000000000000000;;							default:
0000000000000000000000000000000000000000;;								return errors.New("dbus: authentication protocol error")
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						err = authWriteLine(conn.transport, []byte("BEGIN"))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						go conn.inWorker()
0000000000000000000000000000000000000000;;						go conn.outWorker()
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.New("dbus: authentication failed")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryAuth tries to authenticate with m as the mechanism, using state as the
0000000000000000000000000000000000000000;;	// initial authState and in for reading input. It returns (nil, true) on
0000000000000000000000000000000000000000;;	// success, (nil, false) on a REJECTED and (someErr, false) if some other
0000000000000000000000000000000000000000;;	// error occured.
0000000000000000000000000000000000000000;;	func (conn *Conn) tryAuth(m Auth, state authState, in *bufio.Reader) (error, bool) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			s, err := authReadLine(in)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case state == waitingForData && string(s[0]) == "DATA":
0000000000000000000000000000000000000000;;				if len(s) != 2 {
0000000000000000000000000000000000000000;;					err = authWriteLine(conn.transport, []byte("ERROR"))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err, false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				data, status := m.HandleData(s[1])
0000000000000000000000000000000000000000;;				switch status {
0000000000000000000000000000000000000000;;				case AuthOk, AuthContinue:
0000000000000000000000000000000000000000;;					if len(data) != 0 {
0000000000000000000000000000000000000000;;						err = authWriteLine(conn.transport, []byte("DATA"), data)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return err, false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if status == AuthOk {
0000000000000000000000000000000000000000;;						state = waitingForOk
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case AuthError:
0000000000000000000000000000000000000000;;					err = authWriteLine(conn.transport, []byte("ERROR"))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err, false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case state == waitingForData && string(s[0]) == "REJECTED":
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			case state == waitingForData && string(s[0]) == "ERROR":
0000000000000000000000000000000000000000;;				err = authWriteLine(conn.transport, []byte("CANCEL"))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				state = waitingForReject
0000000000000000000000000000000000000000;;			case state == waitingForData && string(s[0]) == "OK":
0000000000000000000000000000000000000000;;				if len(s) != 2 {
0000000000000000000000000000000000000000;;					err = authWriteLine(conn.transport, []byte("CANCEL"))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err, false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					state = waitingForReject
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				conn.uuid = string(s[1])
0000000000000000000000000000000000000000;;				return nil, true
0000000000000000000000000000000000000000;;			case state == waitingForData:
0000000000000000000000000000000000000000;;				err = authWriteLine(conn.transport, []byte("ERROR"))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case state == waitingForOk && string(s[0]) == "OK":
0000000000000000000000000000000000000000;;				if len(s) != 2 {
0000000000000000000000000000000000000000;;					err = authWriteLine(conn.transport, []byte("CANCEL"))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err, false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					state = waitingForReject
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				conn.uuid = string(s[1])
0000000000000000000000000000000000000000;;				return nil, true
0000000000000000000000000000000000000000;;			case state == waitingForOk && string(s[0]) == "REJECTED":
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			case state == waitingForOk && (string(s[0]) == "DATA" ||
0000000000000000000000000000000000000000;;				string(s[0]) == "ERROR"):
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = authWriteLine(conn.transport, []byte("CANCEL"))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				state = waitingForReject
0000000000000000000000000000000000000000;;			case state == waitingForOk:
0000000000000000000000000000000000000000;;				err = authWriteLine(conn.transport, []byte("ERROR"))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case state == waitingForReject && string(s[0]) == "REJECTED":
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			case state == waitingForReject:
0000000000000000000000000000000000000000;;				return errors.New("dbus: authentication protocol error"), false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("dbus: invalid auth state")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authReadLine reads a line and separates it into its fields.
0000000000000000000000000000000000000000;;	func authReadLine(in *bufio.Reader) ([][]byte, error) {
0000000000000000000000000000000000000000;;		data, err := in.ReadBytes('\n')
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data = bytes.TrimSuffix(data, []byte("\r\n"))
0000000000000000000000000000000000000000;;		return bytes.Split(data, []byte{' '}), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authWriteLine writes the given line in the authentication protocol format
0000000000000000000000000000000000000000;;	// (elements of data separated by a " " and terminated by "\r\n").
0000000000000000000000000000000000000000;;	func authWriteLine(out io.Writer, data ...[]byte) error {
0000000000000000000000000000000000000000;;		buf := make([]byte, 0)
0000000000000000000000000000000000000000;;		for i, v := range data {
0000000000000000000000000000000000000000;;			buf = append(buf, v...)
0000000000000000000000000000000000000000;;			if i != len(data)-1 {
0000000000000000000000000000000000000000;;				buf = append(buf, ' ')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf = append(buf, '\r')
0000000000000000000000000000000000000000;;		buf = append(buf, '\n')
0000000000000000000000000000000000000000;;		n, err := out.Write(buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != len(buf) {
0000000000000000000000000000000000000000;;			return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
