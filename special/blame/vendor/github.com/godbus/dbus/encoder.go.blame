0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/encoder.go[Godeps/_workspace/src/github.com/godbus/dbus/encoder.go][vendor/github.com/godbus/dbus/encoder.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An encoder encodes values to the D-Bus wire format.
0000000000000000000000000000000000000000;;	type encoder struct {
0000000000000000000000000000000000000000;;		out   io.Writer
0000000000000000000000000000000000000000;;		order binary.ByteOrder
0000000000000000000000000000000000000000;;		pos   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder returns a new encoder that writes to out in the given byte order.
0000000000000000000000000000000000000000;;	func newEncoder(out io.Writer, order binary.ByteOrder) *encoder {
0000000000000000000000000000000000000000;;		return newEncoderAtOffset(out, 0, order)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newEncoderAtOffset returns a new encoder that writes to out in the given
0000000000000000000000000000000000000000;;	// byte order. Specify the offset to initialize pos for proper alignment
0000000000000000000000000000000000000000;;	// computation.
0000000000000000000000000000000000000000;;	func newEncoderAtOffset(out io.Writer, offset int, order binary.ByteOrder) *encoder {
0000000000000000000000000000000000000000;;		enc := new(encoder)
0000000000000000000000000000000000000000;;		enc.out = out
0000000000000000000000000000000000000000;;		enc.order = order
0000000000000000000000000000000000000000;;		enc.pos = offset
0000000000000000000000000000000000000000;;		return enc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Aligns the next output to be on a multiple of n. Panics on write errors.
0000000000000000000000000000000000000000;;	func (enc *encoder) align(n int) {
0000000000000000000000000000000000000000;;		pad := enc.padding(0, n)
0000000000000000000000000000000000000000;;		if pad > 0 {
0000000000000000000000000000000000000000;;			empty := make([]byte, pad)
0000000000000000000000000000000000000000;;			if _, err := enc.out.Write(empty); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.pos += pad
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pad returns the number of bytes of padding, based on current position and additional offset.
0000000000000000000000000000000000000000;;	// and alignment.
0000000000000000000000000000000000000000;;	func (enc *encoder) padding(offset, algn int) int {
0000000000000000000000000000000000000000;;		abs := enc.pos + offset
0000000000000000000000000000000000000000;;		if abs%algn != 0 {
0000000000000000000000000000000000000000;;			newabs := (abs + algn - 1) & ^(algn - 1)
0000000000000000000000000000000000000000;;			return newabs - abs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls binary.Write(enc.out, enc.order, v) and panics on write errors.
0000000000000000000000000000000000000000;;	func (enc *encoder) binwrite(v interface{}) {
0000000000000000000000000000000000000000;;		if err := binary.Write(enc.out, enc.order, v); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode encodes the given values to the underyling reader. All written values
0000000000000000000000000000000000000000;;	// are aligned properly as required by the D-Bus spec.
0000000000000000000000000000000000000000;;	func (enc *encoder) Encode(vs ...interface{}) (err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			err, _ = recover().(error)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		for _, v := range vs {
0000000000000000000000000000000000000000;;			enc.encode(reflect.ValueOf(v), 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encode encodes the given value to the writer and panics on error. depth holds
0000000000000000000000000000000000000000;;	// the depth of the container nesting.
0000000000000000000000000000000000000000;;	func (enc *encoder) encode(v reflect.Value, depth int) {
0000000000000000000000000000000000000000;;		enc.align(alignment(v.Type()))
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Uint8:
0000000000000000000000000000000000000000;;			var b [1]byte
0000000000000000000000000000000000000000;;			b[0] = byte(v.Uint())
0000000000000000000000000000000000000000;;			if _, err := enc.out.Write(b[:]); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.pos++
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			if v.Bool() {
0000000000000000000000000000000000000000;;				enc.encode(reflect.ValueOf(uint32(1)), depth)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				enc.encode(reflect.ValueOf(uint32(0)), depth)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Int16:
0000000000000000000000000000000000000000;;			enc.binwrite(int16(v.Int()))
0000000000000000000000000000000000000000;;			enc.pos += 2
0000000000000000000000000000000000000000;;		case reflect.Uint16:
0000000000000000000000000000000000000000;;			enc.binwrite(uint16(v.Uint()))
0000000000000000000000000000000000000000;;			enc.pos += 2
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			enc.binwrite(int32(v.Int()))
0000000000000000000000000000000000000000;;			enc.pos += 4
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			enc.binwrite(uint32(v.Uint()))
0000000000000000000000000000000000000000;;			enc.pos += 4
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			enc.binwrite(v.Int())
0000000000000000000000000000000000000000;;			enc.pos += 8
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			enc.binwrite(v.Uint())
0000000000000000000000000000000000000000;;			enc.pos += 8
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			enc.binwrite(v.Float())
0000000000000000000000000000000000000000;;			enc.pos += 8
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			enc.encode(reflect.ValueOf(uint32(len(v.String()))), depth)
0000000000000000000000000000000000000000;;			b := make([]byte, v.Len()+1)
0000000000000000000000000000000000000000;;			copy(b, v.String())
0000000000000000000000000000000000000000;;			b[len(b)-1] = 0
0000000000000000000000000000000000000000;;			n, err := enc.out.Write(b)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.pos += n
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			enc.encode(v.Elem(), depth)
0000000000000000000000000000000000000000;;		case reflect.Slice, reflect.Array:
0000000000000000000000000000000000000000;;			if depth >= 64 {
0000000000000000000000000000000000000000;;				panic(FormatError("input exceeds container depth limit"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Lookahead offset: 4 bytes for uint32 length (with alignment),
0000000000000000000000000000000000000000;;			// plus alignment for elements.
0000000000000000000000000000000000000000;;			n := enc.padding(0, 4) + 4
0000000000000000000000000000000000000000;;			offset := enc.pos + n + enc.padding(n, alignment(v.Type().Elem()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var buf bytes.Buffer
0000000000000000000000000000000000000000;;			bufenc := newEncoderAtOffset(&buf, offset, enc.order)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;				bufenc.encode(v.Index(i), depth+1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.encode(reflect.ValueOf(uint32(buf.Len())), depth)
0000000000000000000000000000000000000000;;			length := buf.Len()
0000000000000000000000000000000000000000;;			enc.align(alignment(v.Type().Elem()))
0000000000000000000000000000000000000000;;			if _, err := buf.WriteTo(enc.out); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.pos += length
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if depth >= 64 && v.Type() != signatureType {
0000000000000000000000000000000000000000;;				panic(FormatError("input exceeds container depth limit"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := v.Type(); t {
0000000000000000000000000000000000000000;;			case signatureType:
0000000000000000000000000000000000000000;;				str := v.Field(0)
0000000000000000000000000000000000000000;;				enc.encode(reflect.ValueOf(byte(str.Len())), depth+1)
0000000000000000000000000000000000000000;;				b := make([]byte, str.Len()+1)
0000000000000000000000000000000000000000;;				copy(b, str.String())
0000000000000000000000000000000000000000;;				b[len(b)-1] = 0
0000000000000000000000000000000000000000;;				n, err := enc.out.Write(b)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				enc.pos += n
0000000000000000000000000000000000000000;;			case variantType:
0000000000000000000000000000000000000000;;				variant := v.Interface().(Variant)
0000000000000000000000000000000000000000;;				enc.encode(reflect.ValueOf(variant.sig), depth+1)
0000000000000000000000000000000000000000;;				enc.encode(reflect.ValueOf(variant.value), depth+1)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				for i := 0; i < v.Type().NumField(); i++ {
0000000000000000000000000000000000000000;;					field := t.Field(i)
0000000000000000000000000000000000000000;;					if field.PkgPath == "" && field.Tag.Get("dbus") != "-" {
0000000000000000000000000000000000000000;;						enc.encode(v.Field(i), depth+1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			// Maps are arrays of structures, so they actually increase the depth by
0000000000000000000000000000000000000000;;			// 2.
0000000000000000000000000000000000000000;;			if depth >= 63 {
0000000000000000000000000000000000000000;;				panic(FormatError("input exceeds container depth limit"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isKeyType(v.Type().Key()) {
0000000000000000000000000000000000000000;;				panic(InvalidTypeError{v.Type()})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keys := v.MapKeys()
0000000000000000000000000000000000000000;;			// Lookahead offset: 4 bytes for uint32 length (with alignment),
0000000000000000000000000000000000000000;;			// plus 8-byte alignment
0000000000000000000000000000000000000000;;			n := enc.padding(0, 4) + 4
0000000000000000000000000000000000000000;;			offset := enc.pos + n + enc.padding(n, 8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var buf bytes.Buffer
0000000000000000000000000000000000000000;;			bufenc := newEncoderAtOffset(&buf, offset, enc.order)
0000000000000000000000000000000000000000;;			for _, k := range keys {
0000000000000000000000000000000000000000;;				bufenc.align(8)
0000000000000000000000000000000000000000;;				bufenc.encode(k, depth+2)
0000000000000000000000000000000000000000;;				bufenc.encode(v.MapIndex(k), depth+2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.encode(reflect.ValueOf(uint32(buf.Len())), depth)
0000000000000000000000000000000000000000;;			length := buf.Len()
0000000000000000000000000000000000000000;;			enc.align(8)
0000000000000000000000000000000000000000;;			if _, err := buf.WriteTo(enc.out); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.pos += length
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(InvalidTypeError{v.Type()})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
