0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/variant_parser.go[Godeps/_workspace/src/github.com/godbus/dbus/variant_parser.go][vendor/github.com/godbus/dbus/variant_parser.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type varParser struct {
0000000000000000000000000000000000000000;;		tokens []varToken
0000000000000000000000000000000000000000;;		i      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *varParser) backup() {
0000000000000000000000000000000000000000;;		p.i--
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *varParser) next() varToken {
0000000000000000000000000000000000000000;;		if p.i < len(p.tokens) {
0000000000000000000000000000000000000000;;			t := p.tokens[p.i]
0000000000000000000000000000000000000000;;			p.i++
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return varToken{typ: tokEOF}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type varNode interface {
0000000000000000000000000000000000000000;;		Infer() (Signature, error)
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;		Sigs() sigSet
0000000000000000000000000000000000000000;;		Value(Signature) (interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varMakeNode(p *varParser) (varNode, error) {
0000000000000000000000000000000000000000;;		var sig Signature
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			t := p.next()
0000000000000000000000000000000000000000;;			switch t.typ {
0000000000000000000000000000000000000000;;			case tokEOF:
0000000000000000000000000000000000000000;;				return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			case tokError:
0000000000000000000000000000000000000000;;				return nil, errors.New(t.val)
0000000000000000000000000000000000000000;;			case tokNumber:
0000000000000000000000000000000000000000;;				return varMakeNumNode(t, sig)
0000000000000000000000000000000000000000;;			case tokString:
0000000000000000000000000000000000000000;;				return varMakeStringNode(t, sig)
0000000000000000000000000000000000000000;;			case tokBool:
0000000000000000000000000000000000000000;;				if sig.str != "" && sig.str != "b" {
0000000000000000000000000000000000000000;;					return nil, varTypeError{t.val, sig}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b, err := strconv.ParseBool(t.val)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return boolNode(b), nil
0000000000000000000000000000000000000000;;			case tokArrayStart:
0000000000000000000000000000000000000000;;				return varMakeArrayNode(p, sig)
0000000000000000000000000000000000000000;;			case tokVariantStart:
0000000000000000000000000000000000000000;;				return varMakeVariantNode(p, sig)
0000000000000000000000000000000000000000;;			case tokDictStart:
0000000000000000000000000000000000000000;;				return varMakeDictNode(p, sig)
0000000000000000000000000000000000000000;;			case tokType:
0000000000000000000000000000000000000000;;				if sig.str != "" {
0000000000000000000000000000000000000000;;					return nil, errors.New("unexpected type annotation")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if t.val[0] == '@' {
0000000000000000000000000000000000000000;;					sig.str = t.val[1:]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sig.str = varTypeMap[t.val]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case tokByteString:
0000000000000000000000000000000000000000;;				if sig.str != "" && sig.str != "ay" {
0000000000000000000000000000000000000000;;					return nil, varTypeError{t.val, sig}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b, err := varParseByteString(t.val)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return byteStringNode(b), nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected %q", t.val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type varTypeError struct {
0000000000000000000000000000000000000000;;		val string
0000000000000000000000000000000000000000;;		sig Signature
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e varTypeError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("dbus: can't parse %q as type %q", e.val, e.sig.str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sigSet map[Signature]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sigSet) Empty() bool {
0000000000000000000000000000000000000000;;		return len(s) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sigSet) Intersect(s2 sigSet) sigSet {
0000000000000000000000000000000000000000;;		r := make(sigSet)
0000000000000000000000000000000000000000;;		for k := range s {
0000000000000000000000000000000000000000;;			if s2[k] {
0000000000000000000000000000000000000000;;				r[k] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sigSet) Single() (Signature, bool) {
0000000000000000000000000000000000000000;;		if len(s) == 1 {
0000000000000000000000000000000000000000;;			for k := range s {
0000000000000000000000000000000000000000;;				return k, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Signature{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sigSet) ToArray() sigSet {
0000000000000000000000000000000000000000;;		r := make(sigSet, len(s))
0000000000000000000000000000000000000000;;		for k := range s {
0000000000000000000000000000000000000000;;			r[Signature{"a" + k.str}] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type numNode struct {
0000000000000000000000000000000000000000;;		sig Signature
0000000000000000000000000000000000000000;;		str string
0000000000000000000000000000000000000000;;		val interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var numSigSet = sigSet{
0000000000000000000000000000000000000000;;		Signature{"y"}: true,
0000000000000000000000000000000000000000;;		Signature{"n"}: true,
0000000000000000000000000000000000000000;;		Signature{"q"}: true,
0000000000000000000000000000000000000000;;		Signature{"i"}: true,
0000000000000000000000000000000000000000;;		Signature{"u"}: true,
0000000000000000000000000000000000000000;;		Signature{"x"}: true,
0000000000000000000000000000000000000000;;		Signature{"t"}: true,
0000000000000000000000000000000000000000;;		Signature{"d"}: true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n numNode) Infer() (Signature, error) {
0000000000000000000000000000000000000000;;		if strings.ContainsAny(n.str, ".e") {
0000000000000000000000000000000000000000;;			return Signature{"d"}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Signature{"i"}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n numNode) String() string {
0000000000000000000000000000000000000000;;		return n.str
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n numNode) Sigs() sigSet {
0000000000000000000000000000000000000000;;		if n.sig.str != "" {
0000000000000000000000000000000000000000;;			return sigSet{n.sig: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.ContainsAny(n.str, ".e") {
0000000000000000000000000000000000000000;;			return sigSet{Signature{"d"}: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return numSigSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n numNode) Value(sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		if n.sig.str != "" && n.sig != sig {
0000000000000000000000000000000000000000;;			return nil, varTypeError{n.str, sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.val != nil {
0000000000000000000000000000000000000000;;			return n.val, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return varNumAs(n.str, sig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varMakeNumNode(tok varToken, sig Signature) (varNode, error) {
0000000000000000000000000000000000000000;;		if sig.str == "" {
0000000000000000000000000000000000000000;;			return numNode{str: tok.val}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		num, err := varNumAs(tok.val, sig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return numNode{sig: sig, val: num}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varNumAs(s string, sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		isUnsigned := false
0000000000000000000000000000000000000000;;		size := 32
0000000000000000000000000000000000000000;;		switch sig.str {
0000000000000000000000000000000000000000;;		case "n":
0000000000000000000000000000000000000000;;			size = 16
0000000000000000000000000000000000000000;;		case "i":
0000000000000000000000000000000000000000;;		case "x":
0000000000000000000000000000000000000000;;			size = 64
0000000000000000000000000000000000000000;;		case "y":
0000000000000000000000000000000000000000;;			size = 8
0000000000000000000000000000000000000000;;			isUnsigned = true
0000000000000000000000000000000000000000;;		case "q":
0000000000000000000000000000000000000000;;			size = 16
0000000000000000000000000000000000000000;;			isUnsigned = true
0000000000000000000000000000000000000000;;		case "u":
0000000000000000000000000000000000000000;;			isUnsigned = true
0000000000000000000000000000000000000000;;		case "t":
0000000000000000000000000000000000000000;;			size = 64
0000000000000000000000000000000000000000;;			isUnsigned = true
0000000000000000000000000000000000000000;;		case "d":
0000000000000000000000000000000000000000;;			d, err := strconv.ParseFloat(s, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return d, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, varTypeError{s, sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		base := 10
0000000000000000000000000000000000000000;;		if strings.HasPrefix(s, "0x") {
0000000000000000000000000000000000000000;;			base = 16
0000000000000000000000000000000000000000;;			s = s[2:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(s, "0") && len(s) != 1 {
0000000000000000000000000000000000000000;;			base = 8
0000000000000000000000000000000000000000;;			s = s[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isUnsigned {
0000000000000000000000000000000000000000;;			i, err := strconv.ParseUint(s, base, size)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var v interface{} = i
0000000000000000000000000000000000000000;;			switch sig.str {
0000000000000000000000000000000000000000;;			case "y":
0000000000000000000000000000000000000000;;				v = byte(i)
0000000000000000000000000000000000000000;;			case "q":
0000000000000000000000000000000000000000;;				v = uint16(i)
0000000000000000000000000000000000000000;;			case "u":
0000000000000000000000000000000000000000;;				v = uint32(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, err := strconv.ParseInt(s, base, size)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var v interface{} = i
0000000000000000000000000000000000000000;;		switch sig.str {
0000000000000000000000000000000000000000;;		case "n":
0000000000000000000000000000000000000000;;			v = int16(i)
0000000000000000000000000000000000000000;;		case "i":
0000000000000000000000000000000000000000;;			v = int32(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stringNode struct {
0000000000000000000000000000000000000000;;		sig Signature
0000000000000000000000000000000000000000;;		str string      // parsed
0000000000000000000000000000000000000000;;		val interface{} // has correct type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var stringSigSet = sigSet{
0000000000000000000000000000000000000000;;		Signature{"s"}: true,
0000000000000000000000000000000000000000;;		Signature{"g"}: true,
0000000000000000000000000000000000000000;;		Signature{"o"}: true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n stringNode) Infer() (Signature, error) {
0000000000000000000000000000000000000000;;		return Signature{"s"}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n stringNode) String() string {
0000000000000000000000000000000000000000;;		return n.str
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n stringNode) Sigs() sigSet {
0000000000000000000000000000000000000000;;		if n.sig.str != "" {
0000000000000000000000000000000000000000;;			return sigSet{n.sig: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stringSigSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n stringNode) Value(sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		if n.sig.str != "" && n.sig != sig {
0000000000000000000000000000000000000000;;			return nil, varTypeError{n.str, sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.val != nil {
0000000000000000000000000000000000000000;;			return n.val, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case sig.str == "g":
0000000000000000000000000000000000000000;;			return Signature{n.str}, nil
0000000000000000000000000000000000000000;;		case sig.str == "o":
0000000000000000000000000000000000000000;;			return ObjectPath(n.str), nil
0000000000000000000000000000000000000000;;		case sig.str == "s":
0000000000000000000000000000000000000000;;			return n.str, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, varTypeError{n.str, sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varMakeStringNode(tok varToken, sig Signature) (varNode, error) {
0000000000000000000000000000000000000000;;		if sig.str != "" && sig.str != "s" && sig.str != "g" && sig.str != "o" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid type %q for string", sig.str)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s, err := varParseString(tok.val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := stringNode{str: s}
0000000000000000000000000000000000000000;;		if sig.str == "" {
0000000000000000000000000000000000000000;;			return stringNode{str: s}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.sig = sig
0000000000000000000000000000000000000000;;		switch sig.str {
0000000000000000000000000000000000000000;;		case "o":
0000000000000000000000000000000000000000;;			n.val = ObjectPath(s)
0000000000000000000000000000000000000000;;		case "g":
0000000000000000000000000000000000000000;;			n.val = Signature{s}
0000000000000000000000000000000000000000;;		case "s":
0000000000000000000000000000000000000000;;			n.val = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varParseString(s string) (string, error) {
0000000000000000000000000000000000000000;;		// quotes are guaranteed to be there
0000000000000000000000000000000000000000;;		s = s[1 : len(s)-1]
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		for len(s) != 0 {
0000000000000000000000000000000000000000;;			r, size := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;			if r == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;				return "", errors.New("invalid UTF-8")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = s[size:]
0000000000000000000000000000000000000000;;			if r != '\\' {
0000000000000000000000000000000000000000;;				buf.WriteRune(r)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, size = utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;			if r == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;				return "", errors.New("invalid UTF-8")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = s[size:]
0000000000000000000000000000000000000000;;			switch r {
0000000000000000000000000000000000000000;;			case 'a':
0000000000000000000000000000000000000000;;				buf.WriteRune(0x7)
0000000000000000000000000000000000000000;;			case 'b':
0000000000000000000000000000000000000000;;				buf.WriteRune(0x8)
0000000000000000000000000000000000000000;;			case 'f':
0000000000000000000000000000000000000000;;				buf.WriteRune(0xc)
0000000000000000000000000000000000000000;;			case 'n':
0000000000000000000000000000000000000000;;				buf.WriteRune('\n')
0000000000000000000000000000000000000000;;			case 'r':
0000000000000000000000000000000000000000;;				buf.WriteRune('\r')
0000000000000000000000000000000000000000;;			case 't':
0000000000000000000000000000000000000000;;				buf.WriteRune('\t')
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;			case 'u':
0000000000000000000000000000000000000000;;				if len(s) < 4 {
0000000000000000000000000000000000000000;;					return "", errors.New("short unicode escape")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r, err := strconv.ParseUint(s[:4], 16, 32)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteRune(rune(r))
0000000000000000000000000000000000000000;;				s = s[4:]
0000000000000000000000000000000000000000;;			case 'U':
0000000000000000000000000000000000000000;;				if len(s) < 8 {
0000000000000000000000000000000000000000;;					return "", errors.New("short unicode escape")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r, err := strconv.ParseUint(s[:8], 16, 32)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteRune(rune(r))
0000000000000000000000000000000000000000;;				s = s[8:]
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				buf.WriteRune(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var boolSigSet = sigSet{Signature{"b"}: true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type boolNode bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (boolNode) Infer() (Signature, error) {
0000000000000000000000000000000000000000;;		return Signature{"b"}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b boolNode) String() string {
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			return "true"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "false"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (boolNode) Sigs() sigSet {
0000000000000000000000000000000000000000;;		return boolSigSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b boolNode) Value(sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		if sig.str != "b" {
0000000000000000000000000000000000000000;;			return nil, varTypeError{b.String(), sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bool(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type arrayNode struct {
0000000000000000000000000000000000000000;;		set      sigSet
0000000000000000000000000000000000000000;;		children []varNode
0000000000000000000000000000000000000000;;		val      interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n arrayNode) Infer() (Signature, error) {
0000000000000000000000000000000000000000;;		for _, v := range n.children {
0000000000000000000000000000000000000000;;			csig, err := varInfer(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Signature{"a" + csig.str}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Signature{}, fmt.Errorf("can't infer type for %q", n.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n arrayNode) String() string {
0000000000000000000000000000000000000000;;		s := "["
0000000000000000000000000000000000000000;;		for i, v := range n.children {
0000000000000000000000000000000000000000;;			s += v.String()
0000000000000000000000000000000000000000;;			if i != len(n.children)-1 {
0000000000000000000000000000000000000000;;				s += ", "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s + "]"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n arrayNode) Sigs() sigSet {
0000000000000000000000000000000000000000;;		return n.set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n arrayNode) Value(sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		if n.set.Empty() {
0000000000000000000000000000000000000000;;			// no type information whatsoever, so this must be an empty slice
0000000000000000000000000000000000000000;;			return reflect.MakeSlice(typeFor(sig.str), 0, 0).Interface(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !n.set[sig] {
0000000000000000000000000000000000000000;;			return nil, varTypeError{n.String(), sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := reflect.MakeSlice(typeFor(sig.str), len(n.children), len(n.children))
0000000000000000000000000000000000000000;;		for i, v := range n.children {
0000000000000000000000000000000000000000;;			rv, err := v.Value(Signature{sig.str[1:]})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.Index(i).Set(reflect.ValueOf(rv))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varMakeArrayNode(p *varParser, sig Signature) (varNode, error) {
0000000000000000000000000000000000000000;;		var n arrayNode
0000000000000000000000000000000000000000;;		if sig.str != "" {
0000000000000000000000000000000000000000;;			n.set = sigSet{sig: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t := p.next(); t.typ == tokArrayEnd {
0000000000000000000000000000000000000000;;			return n, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			t := p.next()
0000000000000000000000000000000000000000;;			switch t.typ {
0000000000000000000000000000000000000000;;			case tokEOF:
0000000000000000000000000000000000000000;;				return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			case tokError:
0000000000000000000000000000000000000000;;				return nil, errors.New(t.val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;			cn, err := varMakeNode(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cset := cn.Sigs(); !cset.Empty() {
0000000000000000000000000000000000000000;;				if n.set.Empty() {
0000000000000000000000000000000000000000;;					n.set = cset.ToArray()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					nset := cset.ToArray().Intersect(n.set)
0000000000000000000000000000000000000000;;					if nset.Empty() {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("can't parse %q with given type information", cn.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					n.set = nset
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n.children = append(n.children, cn)
0000000000000000000000000000000000000000;;			switch t := p.next(); t.typ {
0000000000000000000000000000000000000000;;			case tokEOF:
0000000000000000000000000000000000000000;;				return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			case tokError:
0000000000000000000000000000000000000000;;				return nil, errors.New(t.val)
0000000000000000000000000000000000000000;;			case tokArrayEnd:
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			case tokComma:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected %q", t.val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type variantNode struct {
0000000000000000000000000000000000000000;;		n varNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var variantSet = sigSet{
0000000000000000000000000000000000000000;;		Signature{"v"}: true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (variantNode) Infer() (Signature, error) {
0000000000000000000000000000000000000000;;		return Signature{"v"}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n variantNode) String() string {
0000000000000000000000000000000000000000;;		return "<" + n.n.String() + ">"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (variantNode) Sigs() sigSet {
0000000000000000000000000000000000000000;;		return variantSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n variantNode) Value(sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		if sig.str != "v" {
0000000000000000000000000000000000000000;;			return nil, varTypeError{n.String(), sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sig, err := varInfer(n.n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := n.n.Value(sig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return MakeVariant(v), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varMakeVariantNode(p *varParser, sig Signature) (varNode, error) {
0000000000000000000000000000000000000000;;		n, err := varMakeNode(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t := p.next(); t.typ != tokVariantEnd {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected %q", t.val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vn := variantNode{n}
0000000000000000000000000000000000000000;;		if sig.str != "" && sig.str != "v" {
0000000000000000000000000000000000000000;;			return nil, varTypeError{vn.String(), sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return variantNode{n}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dictEntry struct {
0000000000000000000000000000000000000000;;		key, val varNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dictNode struct {
0000000000000000000000000000000000000000;;		kset, vset sigSet
0000000000000000000000000000000000000000;;		children   []dictEntry
0000000000000000000000000000000000000000;;		val        interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n dictNode) Infer() (Signature, error) {
0000000000000000000000000000000000000000;;		for _, v := range n.children {
0000000000000000000000000000000000000000;;			ksig, err := varInfer(v.key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vsig, err := varInfer(v.val)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Signature{"a{" + ksig.str + vsig.str + "}"}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Signature{}, fmt.Errorf("can't infer type for %q", n.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n dictNode) String() string {
0000000000000000000000000000000000000000;;		s := "{"
0000000000000000000000000000000000000000;;		for i, v := range n.children {
0000000000000000000000000000000000000000;;			s += v.key.String() + ": " + v.val.String()
0000000000000000000000000000000000000000;;			if i != len(n.children)-1 {
0000000000000000000000000000000000000000;;				s += ", "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s + "}"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n dictNode) Sigs() sigSet {
0000000000000000000000000000000000000000;;		r := sigSet{}
0000000000000000000000000000000000000000;;		for k := range n.kset {
0000000000000000000000000000000000000000;;			for v := range n.vset {
0000000000000000000000000000000000000000;;				sig := "a{" + k.str + v.str + "}"
0000000000000000000000000000000000000000;;				r[Signature{sig}] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n dictNode) Value(sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		set := n.Sigs()
0000000000000000000000000000000000000000;;		if set.Empty() {
0000000000000000000000000000000000000000;;			// no type information -> empty dict
0000000000000000000000000000000000000000;;			return reflect.MakeMap(typeFor(sig.str)).Interface(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !set[sig] {
0000000000000000000000000000000000000000;;			return nil, varTypeError{n.String(), sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := reflect.MakeMap(typeFor(sig.str))
0000000000000000000000000000000000000000;;		ksig := Signature{sig.str[2:3]}
0000000000000000000000000000000000000000;;		vsig := Signature{sig.str[3 : len(sig.str)-1]}
0000000000000000000000000000000000000000;;		for _, v := range n.children {
0000000000000000000000000000000000000000;;			kv, err := v.key.Value(ksig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vv, err := v.val.Value(vsig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.SetMapIndex(reflect.ValueOf(kv), reflect.ValueOf(vv))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varMakeDictNode(p *varParser, sig Signature) (varNode, error) {
0000000000000000000000000000000000000000;;		var n dictNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sig.str != "" {
0000000000000000000000000000000000000000;;			if len(sig.str) < 5 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid signature %q for dict type", sig)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ksig := Signature{string(sig.str[2])}
0000000000000000000000000000000000000000;;			vsig := Signature{sig.str[3 : len(sig.str)-1]}
0000000000000000000000000000000000000000;;			n.kset = sigSet{ksig: true}
0000000000000000000000000000000000000000;;			n.vset = sigSet{vsig: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t := p.next(); t.typ == tokDictEnd {
0000000000000000000000000000000000000000;;			return n, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			t := p.next()
0000000000000000000000000000000000000000;;			switch t.typ {
0000000000000000000000000000000000000000;;			case tokEOF:
0000000000000000000000000000000000000000;;				return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			case tokError:
0000000000000000000000000000000000000000;;				return nil, errors.New(t.val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;			kn, err := varMakeNode(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if kset := kn.Sigs(); !kset.Empty() {
0000000000000000000000000000000000000000;;				if n.kset.Empty() {
0000000000000000000000000000000000000000;;					n.kset = kset
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					n.kset = kset.Intersect(n.kset)
0000000000000000000000000000000000000000;;					if n.kset.Empty() {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("can't parse %q with given type information", kn.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = p.next()
0000000000000000000000000000000000000000;;			switch t.typ {
0000000000000000000000000000000000000000;;			case tokEOF:
0000000000000000000000000000000000000000;;				return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			case tokError:
0000000000000000000000000000000000000000;;				return nil, errors.New(t.val)
0000000000000000000000000000000000000000;;			case tokColon:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected %q", t.val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = p.next()
0000000000000000000000000000000000000000;;			switch t.typ {
0000000000000000000000000000000000000000;;			case tokEOF:
0000000000000000000000000000000000000000;;				return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			case tokError:
0000000000000000000000000000000000000000;;				return nil, errors.New(t.val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.backup()
0000000000000000000000000000000000000000;;			vn, err := varMakeNode(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if vset := vn.Sigs(); !vset.Empty() {
0000000000000000000000000000000000000000;;				if n.vset.Empty() {
0000000000000000000000000000000000000000;;					n.vset = vset
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					n.vset = n.vset.Intersect(vset)
0000000000000000000000000000000000000000;;					if n.vset.Empty() {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("can't parse %q with given type information", vn.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n.children = append(n.children, dictEntry{kn, vn})
0000000000000000000000000000000000000000;;			t = p.next()
0000000000000000000000000000000000000000;;			switch t.typ {
0000000000000000000000000000000000000000;;			case tokEOF:
0000000000000000000000000000000000000000;;				return nil, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			case tokError:
0000000000000000000000000000000000000000;;				return nil, errors.New(t.val)
0000000000000000000000000000000000000000;;			case tokDictEnd:
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			case tokComma:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected %q", t.val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byteStringNode []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var byteStringSet = sigSet{
0000000000000000000000000000000000000000;;		Signature{"ay"}: true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (byteStringNode) Infer() (Signature, error) {
0000000000000000000000000000000000000000;;		return Signature{"ay"}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byteStringNode) String() string {
0000000000000000000000000000000000000000;;		return string(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byteStringNode) Sigs() sigSet {
0000000000000000000000000000000000000000;;		return byteStringSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byteStringNode) Value(sig Signature) (interface{}, error) {
0000000000000000000000000000000000000000;;		if sig.str != "ay" {
0000000000000000000000000000000000000000;;			return nil, varTypeError{b.String(), sig}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []byte(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varParseByteString(s string) ([]byte, error) {
0000000000000000000000000000000000000000;;		// quotes and b at start are guaranteed to be there
0000000000000000000000000000000000000000;;		b := make([]byte, 0, 1)
0000000000000000000000000000000000000000;;		s = s[2 : len(s)-1]
0000000000000000000000000000000000000000;;		for len(s) != 0 {
0000000000000000000000000000000000000000;;			c := s[0]
0000000000000000000000000000000000000000;;			s = s[1:]
0000000000000000000000000000000000000000;;			if c != '\\' {
0000000000000000000000000000000000000000;;				b = append(b, c)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c = s[0]
0000000000000000000000000000000000000000;;			s = s[1:]
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case 'a':
0000000000000000000000000000000000000000;;				b = append(b, 0x7)
0000000000000000000000000000000000000000;;			case 'b':
0000000000000000000000000000000000000000;;				b = append(b, 0x8)
0000000000000000000000000000000000000000;;			case 'f':
0000000000000000000000000000000000000000;;				b = append(b, 0xc)
0000000000000000000000000000000000000000;;			case 'n':
0000000000000000000000000000000000000000;;				b = append(b, '\n')
0000000000000000000000000000000000000000;;			case 'r':
0000000000000000000000000000000000000000;;				b = append(b, '\r')
0000000000000000000000000000000000000000;;			case 't':
0000000000000000000000000000000000000000;;				b = append(b, '\t')
0000000000000000000000000000000000000000;;			case 'x':
0000000000000000000000000000000000000000;;				if len(s) < 2 {
0000000000000000000000000000000000000000;;					return nil, errors.New("short escape")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err := strconv.ParseUint(s[:2], 16, 8)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b = append(b, byte(n))
0000000000000000000000000000000000000000;;				s = s[2:]
0000000000000000000000000000000000000000;;			case '0':
0000000000000000000000000000000000000000;;				if len(s) < 3 {
0000000000000000000000000000000000000000;;					return nil, errors.New("short escape")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err := strconv.ParseUint(s[:3], 8, 8)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b = append(b, byte(n))
0000000000000000000000000000000000000000;;				s = s[3:]
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				b = append(b, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(b, 0), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varInfer(n varNode) (Signature, error) {
0000000000000000000000000000000000000000;;		if sig, ok := n.Sigs().Single(); ok {
0000000000000000000000000000000000000000;;			return sig, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.Infer()
0000000000000000000000000000000000000000;;	}
