0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/decoder.go[Godeps/_workspace/src/github.com/godbus/dbus/decoder.go][vendor/github.com/godbus/dbus/decoder.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decoder struct {
0000000000000000000000000000000000000000;;		in    io.Reader
0000000000000000000000000000000000000000;;		order binary.ByteOrder
0000000000000000000000000000000000000000;;		pos   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newDecoder returns a new decoder that reads values from in. The input is
0000000000000000000000000000000000000000;;	// expected to be in the given byte order.
0000000000000000000000000000000000000000;;	func newDecoder(in io.Reader, order binary.ByteOrder) *decoder {
0000000000000000000000000000000000000000;;		dec := new(decoder)
0000000000000000000000000000000000000000;;		dec.in = in
0000000000000000000000000000000000000000;;		dec.order = order
0000000000000000000000000000000000000000;;		return dec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// align aligns the input to the given boundary and panics on error.
0000000000000000000000000000000000000000;;	func (dec *decoder) align(n int) {
0000000000000000000000000000000000000000;;		if dec.pos%n != 0 {
0000000000000000000000000000000000000000;;			newpos := (dec.pos + n - 1) & ^(n - 1)
0000000000000000000000000000000000000000;;			empty := make([]byte, newpos-dec.pos)
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(dec.in, empty); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec.pos = newpos
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls binary.Read(dec.in, dec.order, v) and panics on read errors.
0000000000000000000000000000000000000000;;	func (dec *decoder) binread(v interface{}) {
0000000000000000000000000000000000000000;;		if err := binary.Read(dec.in, dec.order, v); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *decoder) Decode(sig Signature) (vs []interface{}, err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			v := recover()
0000000000000000000000000000000000000000;;			if err, ok = v.(error); ok {
0000000000000000000000000000000000000000;;				if err == io.EOF || err == io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;					err = FormatError("unexpected EOF")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		vs = make([]interface{}, 0)
0000000000000000000000000000000000000000;;		s := sig.str
0000000000000000000000000000000000000000;;		for s != "" {
0000000000000000000000000000000000000000;;			err, rem := validSingle(s, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v := dec.decode(s[:len(s)-len(rem)], 0)
0000000000000000000000000000000000000000;;			vs = append(vs, v)
0000000000000000000000000000000000000000;;			s = rem
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *decoder) decode(s string, depth int) interface{} {
0000000000000000000000000000000000000000;;		dec.align(alignment(typeFor(s)))
0000000000000000000000000000000000000000;;		switch s[0] {
0000000000000000000000000000000000000000;;		case 'y':
0000000000000000000000000000000000000000;;			var b [1]byte
0000000000000000000000000000000000000000;;			if _, err := dec.in.Read(b[:]); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec.pos++
0000000000000000000000000000000000000000;;			return b[0]
0000000000000000000000000000000000000000;;		case 'b':
0000000000000000000000000000000000000000;;			i := dec.decode("u", depth).(uint32)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case i == 0:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case i == 1:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(FormatError("invalid value for boolean"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			var i int16
0000000000000000000000000000000000000000;;			dec.binread(&i)
0000000000000000000000000000000000000000;;			dec.pos += 2
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		case 'i':
0000000000000000000000000000000000000000;;			var i int32
0000000000000000000000000000000000000000;;			dec.binread(&i)
0000000000000000000000000000000000000000;;			dec.pos += 4
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		case 'x':
0000000000000000000000000000000000000000;;			var i int64
0000000000000000000000000000000000000000;;			dec.binread(&i)
0000000000000000000000000000000000000000;;			dec.pos += 8
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		case 'q':
0000000000000000000000000000000000000000;;			var i uint16
0000000000000000000000000000000000000000;;			dec.binread(&i)
0000000000000000000000000000000000000000;;			dec.pos += 2
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		case 'u':
0000000000000000000000000000000000000000;;			var i uint32
0000000000000000000000000000000000000000;;			dec.binread(&i)
0000000000000000000000000000000000000000;;			dec.pos += 4
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			var i uint64
0000000000000000000000000000000000000000;;			dec.binread(&i)
0000000000000000000000000000000000000000;;			dec.pos += 8
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		case 'd':
0000000000000000000000000000000000000000;;			var f float64
0000000000000000000000000000000000000000;;			dec.binread(&f)
0000000000000000000000000000000000000000;;			dec.pos += 8
0000000000000000000000000000000000000000;;			return f
0000000000000000000000000000000000000000;;		case 's':
0000000000000000000000000000000000000000;;			length := dec.decode("u", depth).(uint32)
0000000000000000000000000000000000000000;;			b := make([]byte, int(length)+1)
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(dec.in, b); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec.pos += int(length) + 1
0000000000000000000000000000000000000000;;			return string(b[:len(b)-1])
0000000000000000000000000000000000000000;;		case 'o':
0000000000000000000000000000000000000000;;			return ObjectPath(dec.decode("s", depth).(string))
0000000000000000000000000000000000000000;;		case 'g':
0000000000000000000000000000000000000000;;			length := dec.decode("y", depth).(byte)
0000000000000000000000000000000000000000;;			b := make([]byte, int(length)+1)
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(dec.in, b); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec.pos += int(length) + 1
0000000000000000000000000000000000000000;;			sig, err := ParseSignature(string(b[:len(b)-1]))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sig
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			if depth >= 64 {
0000000000000000000000000000000000000000;;				panic(FormatError("input exceeds container depth limit"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var variant Variant
0000000000000000000000000000000000000000;;			sig := dec.decode("g", depth).(Signature)
0000000000000000000000000000000000000000;;			if len(sig.str) == 0 {
0000000000000000000000000000000000000000;;				panic(FormatError("variant signature is empty"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err, rem := validSingle(sig.str, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rem != "" {
0000000000000000000000000000000000000000;;				panic(FormatError("variant signature has multiple types"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			variant.sig = sig
0000000000000000000000000000000000000000;;			variant.value = dec.decode(sig.str, depth+1)
0000000000000000000000000000000000000000;;			return variant
0000000000000000000000000000000000000000;;		case 'h':
0000000000000000000000000000000000000000;;			return UnixFDIndex(dec.decode("u", depth).(uint32))
0000000000000000000000000000000000000000;;		case 'a':
0000000000000000000000000000000000000000;;			if len(s) > 1 && s[1] == '{' {
0000000000000000000000000000000000000000;;				ksig := s[2:3]
0000000000000000000000000000000000000000;;				vsig := s[3 : len(s)-1]
0000000000000000000000000000000000000000;;				v := reflect.MakeMap(reflect.MapOf(typeFor(ksig), typeFor(vsig)))
0000000000000000000000000000000000000000;;				if depth >= 63 {
0000000000000000000000000000000000000000;;					panic(FormatError("input exceeds container depth limit"))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				length := dec.decode("u", depth).(uint32)
0000000000000000000000000000000000000000;;				// Even for empty maps, the correct padding must be included
0000000000000000000000000000000000000000;;				dec.align(8)
0000000000000000000000000000000000000000;;				spos := dec.pos
0000000000000000000000000000000000000000;;				for dec.pos < spos+int(length) {
0000000000000000000000000000000000000000;;					dec.align(8)
0000000000000000000000000000000000000000;;					if !isKeyType(v.Type().Key()) {
0000000000000000000000000000000000000000;;						panic(InvalidTypeError{v.Type()})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					kv := dec.decode(ksig, depth+2)
0000000000000000000000000000000000000000;;					vv := dec.decode(vsig, depth+2)
0000000000000000000000000000000000000000;;					v.SetMapIndex(reflect.ValueOf(kv), reflect.ValueOf(vv))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return v.Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if depth >= 64 {
0000000000000000000000000000000000000000;;				panic(FormatError("input exceeds container depth limit"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			length := dec.decode("u", depth).(uint32)
0000000000000000000000000000000000000000;;			v := reflect.MakeSlice(reflect.SliceOf(typeFor(s[1:])), 0, int(length))
0000000000000000000000000000000000000000;;			// Even for empty arrays, the correct padding must be included
0000000000000000000000000000000000000000;;			dec.align(alignment(typeFor(s[1:])))
0000000000000000000000000000000000000000;;			spos := dec.pos
0000000000000000000000000000000000000000;;			for dec.pos < spos+int(length) {
0000000000000000000000000000000000000000;;				ev := dec.decode(s[1:], depth+1)
0000000000000000000000000000000000000000;;				v = reflect.Append(v, reflect.ValueOf(ev))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v.Interface()
0000000000000000000000000000000000000000;;		case '(':
0000000000000000000000000000000000000000;;			if depth >= 64 {
0000000000000000000000000000000000000000;;				panic(FormatError("input exceeds container depth limit"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec.align(8)
0000000000000000000000000000000000000000;;			v := make([]interface{}, 0)
0000000000000000000000000000000000000000;;			s = s[1 : len(s)-1]
0000000000000000000000000000000000000000;;			for s != "" {
0000000000000000000000000000000000000000;;				err, rem := validSingle(s, 0)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ev := dec.decode(s[:len(s)-len(rem)], depth+1)
0000000000000000000000000000000000000000;;				v = append(v, ev)
0000000000000000000000000000000000000000;;				s = rem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(SignatureError{Sig: s})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A FormatError is an error in the wire format.
0000000000000000000000000000000000000000;;	type FormatError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e FormatError) Error() string {
0000000000000000000000000000000000000000;;		return "dbus: wire format error: " + string(e)
0000000000000000000000000000000000000000;;	}
