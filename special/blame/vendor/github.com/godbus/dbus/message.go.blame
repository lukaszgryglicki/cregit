0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/message.go[Godeps/_workspace/src/github.com/godbus/dbus/message.go][vendor/github.com/godbus/dbus/message.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const protoVersion byte = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flags represents the possible flags of a D-Bus message.
0000000000000000000000000000000000000000;;	type Flags byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// FlagNoReplyExpected signals that the message is not expected to generate
0000000000000000000000000000000000000000;;		// a reply. If this flag is set on outgoing messages, any possible reply
0000000000000000000000000000000000000000;;		// will be discarded.
0000000000000000000000000000000000000000;;		FlagNoReplyExpected Flags = 1 << iota
0000000000000000000000000000000000000000;;		// FlagNoAutoStart signals that the message bus should not automatically
0000000000000000000000000000000000000000;;		// start an application when handling this message.
0000000000000000000000000000000000000000;;		FlagNoAutoStart
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type represents the possible types of a D-Bus message.
0000000000000000000000000000000000000000;;	type Type byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TypeMethodCall Type = 1 + iota
0000000000000000000000000000000000000000;;		TypeMethodReply
0000000000000000000000000000000000000000;;		TypeError
0000000000000000000000000000000000000000;;		TypeSignal
0000000000000000000000000000000000000000;;		typeMax
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t Type) String() string {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case TypeMethodCall:
0000000000000000000000000000000000000000;;			return "method call"
0000000000000000000000000000000000000000;;		case TypeMethodReply:
0000000000000000000000000000000000000000;;			return "reply"
0000000000000000000000000000000000000000;;		case TypeError:
0000000000000000000000000000000000000000;;			return "error"
0000000000000000000000000000000000000000;;		case TypeSignal:
0000000000000000000000000000000000000000;;			return "signal"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "invalid"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HeaderField represents the possible byte codes for the headers
0000000000000000000000000000000000000000;;	// of a D-Bus message.
0000000000000000000000000000000000000000;;	type HeaderField byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FieldPath HeaderField = 1 + iota
0000000000000000000000000000000000000000;;		FieldInterface
0000000000000000000000000000000000000000;;		FieldMember
0000000000000000000000000000000000000000;;		FieldErrorName
0000000000000000000000000000000000000000;;		FieldReplySerial
0000000000000000000000000000000000000000;;		FieldDestination
0000000000000000000000000000000000000000;;		FieldSender
0000000000000000000000000000000000000000;;		FieldSignature
0000000000000000000000000000000000000000;;		FieldUnixFDs
0000000000000000000000000000000000000000;;		fieldMax
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An InvalidMessageError describes the reason why a D-Bus message is regarded as
0000000000000000000000000000000000000000;;	// invalid.
0000000000000000000000000000000000000000;;	type InvalidMessageError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e InvalidMessageError) Error() string {
0000000000000000000000000000000000000000;;		return "dbus: invalid message: " + string(e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fieldType are the types of the various header fields.
0000000000000000000000000000000000000000;;	var fieldTypes = [fieldMax]reflect.Type{
0000000000000000000000000000000000000000;;		FieldPath:        objectPathType,
0000000000000000000000000000000000000000;;		FieldInterface:   stringType,
0000000000000000000000000000000000000000;;		FieldMember:      stringType,
0000000000000000000000000000000000000000;;		FieldErrorName:   stringType,
0000000000000000000000000000000000000000;;		FieldReplySerial: uint32Type,
0000000000000000000000000000000000000000;;		FieldDestination: stringType,
0000000000000000000000000000000000000000;;		FieldSender:      stringType,
0000000000000000000000000000000000000000;;		FieldSignature:   signatureType,
0000000000000000000000000000000000000000;;		FieldUnixFDs:     uint32Type,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requiredFields lists the header fields that are required by the different
0000000000000000000000000000000000000000;;	// message types.
0000000000000000000000000000000000000000;;	var requiredFields = [typeMax][]HeaderField{
0000000000000000000000000000000000000000;;		TypeMethodCall:  {FieldPath, FieldMember},
0000000000000000000000000000000000000000;;		TypeMethodReply: {FieldReplySerial},
0000000000000000000000000000000000000000;;		TypeError:       {FieldErrorName, FieldReplySerial},
0000000000000000000000000000000000000000;;		TypeSignal:      {FieldPath, FieldInterface, FieldMember},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Message represents a single D-Bus message.
0000000000000000000000000000000000000000;;	type Message struct {
0000000000000000000000000000000000000000;;		Type
0000000000000000000000000000000000000000;;		Flags
0000000000000000000000000000000000000000;;		Headers map[HeaderField]Variant
0000000000000000000000000000000000000000;;		Body    []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serial uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type header struct {
0000000000000000000000000000000000000000;;		Field byte
0000000000000000000000000000000000000000;;		Variant
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeMessage tries to decode a single message in the D-Bus wire format
0000000000000000000000000000000000000000;;	// from the given reader. The byte order is figured out from the first byte.
0000000000000000000000000000000000000000;;	// The possibly returned error can be an error of the underlying reader, an
0000000000000000000000000000000000000000;;	// InvalidMessageError or a FormatError.
0000000000000000000000000000000000000000;;	func DecodeMessage(rd io.Reader) (msg *Message, err error) {
0000000000000000000000000000000000000000;;		var order binary.ByteOrder
0000000000000000000000000000000000000000;;		var hlength, length uint32
0000000000000000000000000000000000000000;;		var typ, flags, proto byte
0000000000000000000000000000000000000000;;		var headers []header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, 1)
0000000000000000000000000000000000000000;;		_, err = rd.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch b[0] {
0000000000000000000000000000000000000000;;		case 'l':
0000000000000000000000000000000000000000;;			order = binary.LittleEndian
0000000000000000000000000000000000000000;;		case 'B':
0000000000000000000000000000000000000000;;			order = binary.BigEndian
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, InvalidMessageError("invalid byte order")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := newDecoder(rd, order)
0000000000000000000000000000000000000000;;		dec.pos = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg = new(Message)
0000000000000000000000000000000000000000;;		vs, err := dec.Decode(Signature{"yyyuu"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = Store(vs, &typ, &flags, &proto, &length, &msg.serial); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Type = Type(typ)
0000000000000000000000000000000000000000;;		msg.Flags = Flags(flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the header length separately because we need it later
0000000000000000000000000000000000000000;;		b = make([]byte, 4)
0000000000000000000000000000000000000000;;		_, err = io.ReadFull(rd, b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		binary.Read(bytes.NewBuffer(b), order, &hlength)
0000000000000000000000000000000000000000;;		if hlength+length+16 > 1<<27 {
0000000000000000000000000000000000000000;;			return nil, InvalidMessageError("message is too long")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dec = newDecoder(io.MultiReader(bytes.NewBuffer(b), rd), order)
0000000000000000000000000000000000000000;;		dec.pos = 12
0000000000000000000000000000000000000000;;		vs, err = dec.Decode(Signature{"a(yv)"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = Store(vs, &headers); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg.Headers = make(map[HeaderField]Variant)
0000000000000000000000000000000000000000;;		for _, v := range headers {
0000000000000000000000000000000000000000;;			msg.Headers[HeaderField(v.Field)] = v.Variant
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec.align(8)
0000000000000000000000000000000000000000;;		body := make([]byte, int(length))
0000000000000000000000000000000000000000;;		if length != 0 {
0000000000000000000000000000000000000000;;			_, err := io.ReadFull(rd, body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = msg.IsValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sig, _ := msg.Headers[FieldSignature].value.(Signature)
0000000000000000000000000000000000000000;;		if sig.str != "" {
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer(body)
0000000000000000000000000000000000000000;;			dec = newDecoder(buf, order)
0000000000000000000000000000000000000000;;			vs, err := dec.Decode(sig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Body = vs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeTo encodes and sends a message to the given writer. The byte order must
0000000000000000000000000000000000000000;;	// be either binary.LittleEndian or binary.BigEndian. If the message is not
0000000000000000000000000000000000000000;;	// valid or an error occurs when writing, an error is returned.
0000000000000000000000000000000000000000;;	func (msg *Message) EncodeTo(out io.Writer, order binary.ByteOrder) error {
0000000000000000000000000000000000000000;;		if err := msg.IsValid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var vs [7]interface{}
0000000000000000000000000000000000000000;;		switch order {
0000000000000000000000000000000000000000;;		case binary.LittleEndian:
0000000000000000000000000000000000000000;;			vs[0] = byte('l')
0000000000000000000000000000000000000000;;		case binary.BigEndian:
0000000000000000000000000000000000000000;;			vs[0] = byte('B')
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New("dbus: invalid byte order")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		enc := newEncoder(body, order)
0000000000000000000000000000000000000000;;		if len(msg.Body) != 0 {
0000000000000000000000000000000000000000;;			enc.Encode(msg.Body...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vs[1] = msg.Type
0000000000000000000000000000000000000000;;		vs[2] = msg.Flags
0000000000000000000000000000000000000000;;		vs[3] = protoVersion
0000000000000000000000000000000000000000;;		vs[4] = uint32(len(body.Bytes()))
0000000000000000000000000000000000000000;;		vs[5] = msg.serial
0000000000000000000000000000000000000000;;		headers := make([]header, 0, len(msg.Headers))
0000000000000000000000000000000000000000;;		for k, v := range msg.Headers {
0000000000000000000000000000000000000000;;			headers = append(headers, header{byte(k), v})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vs[6] = headers
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		enc = newEncoder(&buf, order)
0000000000000000000000000000000000000000;;		enc.Encode(vs[:]...)
0000000000000000000000000000000000000000;;		enc.align(8)
0000000000000000000000000000000000000000;;		body.WriteTo(&buf)
0000000000000000000000000000000000000000;;		if buf.Len() > 1<<27 {
0000000000000000000000000000000000000000;;			return InvalidMessageError("message is too long")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := buf.WriteTo(out); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid checks whether msg is a valid message and returns an
0000000000000000000000000000000000000000;;	// InvalidMessageError if it is not.
0000000000000000000000000000000000000000;;	func (msg *Message) IsValid() error {
0000000000000000000000000000000000000000;;		if msg.Flags & ^(FlagNoAutoStart|FlagNoReplyExpected) != 0 {
0000000000000000000000000000000000000000;;			return InvalidMessageError("invalid flags")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msg.Type == 0 || msg.Type >= typeMax {
0000000000000000000000000000000000000000;;			return InvalidMessageError("invalid message type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range msg.Headers {
0000000000000000000000000000000000000000;;			if k == 0 || k >= fieldMax {
0000000000000000000000000000000000000000;;				return InvalidMessageError("invalid header")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if reflect.TypeOf(v.value) != fieldTypes[k] {
0000000000000000000000000000000000000000;;				return InvalidMessageError("invalid type of header field")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range requiredFields[msg.Type] {
0000000000000000000000000000000000000000;;			if _, ok := msg.Headers[v]; !ok {
0000000000000000000000000000000000000000;;				return InvalidMessageError("missing required header")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if path, ok := msg.Headers[FieldPath]; ok {
0000000000000000000000000000000000000000;;			if !path.value.(ObjectPath).IsValid() {
0000000000000000000000000000000000000000;;				return InvalidMessageError("invalid path name")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if iface, ok := msg.Headers[FieldInterface]; ok {
0000000000000000000000000000000000000000;;			if !isValidInterface(iface.value.(string)) {
0000000000000000000000000000000000000000;;				return InvalidMessageError("invalid interface name")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if member, ok := msg.Headers[FieldMember]; ok {
0000000000000000000000000000000000000000;;			if !isValidMember(member.value.(string)) {
0000000000000000000000000000000000000000;;				return InvalidMessageError("invalid member name")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errname, ok := msg.Headers[FieldErrorName]; ok {
0000000000000000000000000000000000000000;;			if !isValidInterface(errname.value.(string)) {
0000000000000000000000000000000000000000;;				return InvalidMessageError("invalid error name")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(msg.Body) != 0 {
0000000000000000000000000000000000000000;;			if _, ok := msg.Headers[FieldSignature]; !ok {
0000000000000000000000000000000000000000;;				return InvalidMessageError("missing signature")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serial returns the message's serial number. The returned value is only valid
0000000000000000000000000000000000000000;;	// for messages received by eavesdropping.
0000000000000000000000000000000000000000;;	func (msg *Message) Serial() uint32 {
0000000000000000000000000000000000000000;;		return msg.serial
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of a message similar to the format of
0000000000000000000000000000000000000000;;	// dbus-monitor.
0000000000000000000000000000000000000000;;	func (msg *Message) String() string {
0000000000000000000000000000000000000000;;		if err := msg.IsValid(); err != nil {
0000000000000000000000000000000000000000;;			return "<invalid>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := msg.Type.String()
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldSender]; ok {
0000000000000000000000000000000000000000;;			s += " from " + v.value.(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldDestination]; ok {
0000000000000000000000000000000000000000;;			s += " to " + v.value.(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s += " serial " + strconv.FormatUint(uint64(msg.serial), 10)
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldReplySerial]; ok {
0000000000000000000000000000000000000000;;			s += " reply_serial " + strconv.FormatUint(uint64(v.value.(uint32)), 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldUnixFDs]; ok {
0000000000000000000000000000000000000000;;			s += " unixfds " + strconv.FormatUint(uint64(v.value.(uint32)), 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldPath]; ok {
0000000000000000000000000000000000000000;;			s += " path " + string(v.value.(ObjectPath))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldInterface]; ok {
0000000000000000000000000000000000000000;;			s += " interface " + v.value.(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldErrorName]; ok {
0000000000000000000000000000000000000000;;			s += " error " + v.value.(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := msg.Headers[FieldMember]; ok {
0000000000000000000000000000000000000000;;			s += " member " + v.value.(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(msg.Body) != 0 {
0000000000000000000000000000000000000000;;			s += "\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range msg.Body {
0000000000000000000000000000000000000000;;			s += "  " + MakeVariant(v).String()
0000000000000000000000000000000000000000;;			if i != len(msg.Body)-1 {
0000000000000000000000000000000000000000;;				s += "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
