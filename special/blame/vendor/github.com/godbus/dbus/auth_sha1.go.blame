0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/auth_sha1.go[Godeps/_workspace/src/github.com/godbus/dbus/auth_sha1.go][vendor/github.com/godbus/dbus/auth_sha1.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthCookieSha1 returns an Auth that authenticates as the given user with the
0000000000000000000000000000000000000000;;	// DBUS_COOKIE_SHA1 mechanism. The home parameter should specify the home
0000000000000000000000000000000000000000;;	// directory of the user.
0000000000000000000000000000000000000000;;	func AuthCookieSha1(user, home string) Auth {
0000000000000000000000000000000000000000;;		return authCookieSha1{user, home}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authCookieSha1 struct {
0000000000000000000000000000000000000000;;		user, home string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a authCookieSha1) FirstData() ([]byte, []byte, AuthStatus) {
0000000000000000000000000000000000000000;;		b := make([]byte, 2*len(a.user))
0000000000000000000000000000000000000000;;		hex.Encode(b, []byte(a.user))
0000000000000000000000000000000000000000;;		return []byte("DBUS_COOKIE_SHA1"), b, AuthContinue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a authCookieSha1) HandleData(data []byte) ([]byte, AuthStatus) {
0000000000000000000000000000000000000000;;		challenge := make([]byte, len(data)/2)
0000000000000000000000000000000000000000;;		_, err := hex.Decode(challenge, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, AuthError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := bytes.Split(challenge, []byte{' '})
0000000000000000000000000000000000000000;;		if len(b) != 3 {
0000000000000000000000000000000000000000;;			return nil, AuthError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		context := b[0]
0000000000000000000000000000000000000000;;		id := b[1]
0000000000000000000000000000000000000000;;		svchallenge := b[2]
0000000000000000000000000000000000000000;;		cookie := a.getCookie(context, id)
0000000000000000000000000000000000000000;;		if cookie == nil {
0000000000000000000000000000000000000000;;			return nil, AuthError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clchallenge := a.generateChallenge()
0000000000000000000000000000000000000000;;		if clchallenge == nil {
0000000000000000000000000000000000000000;;			return nil, AuthError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := sha1.New()
0000000000000000000000000000000000000000;;		hash.Write(bytes.Join([][]byte{svchallenge, clchallenge, cookie}, []byte{':'}))
0000000000000000000000000000000000000000;;		hexhash := make([]byte, 2*hash.Size())
0000000000000000000000000000000000000000;;		hex.Encode(hexhash, hash.Sum(nil))
0000000000000000000000000000000000000000;;		data = append(clchallenge, ' ')
0000000000000000000000000000000000000000;;		data = append(data, hexhash...)
0000000000000000000000000000000000000000;;		resp := make([]byte, 2*len(data))
0000000000000000000000000000000000000000;;		hex.Encode(resp, data)
0000000000000000000000000000000000000000;;		return resp, AuthOk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCookie searches for the cookie identified by id in context and returns
0000000000000000000000000000000000000000;;	// the cookie content or nil. (Since HandleData can't return a specific error,
0000000000000000000000000000000000000000;;	// but only whether an error occured, this function also doesn't bother to
0000000000000000000000000000000000000000;;	// return an error.)
0000000000000000000000000000000000000000;;	func (a authCookieSha1) getCookie(context, id []byte) []byte {
0000000000000000000000000000000000000000;;		file, err := os.Open(a.home + "/.dbus-keyrings/" + string(context))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		rd := bufio.NewReader(file)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, err := rd.ReadBytes('\n')
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line = line[:len(line)-1]
0000000000000000000000000000000000000000;;			b := bytes.Split(line, []byte{' '})
0000000000000000000000000000000000000000;;			if len(b) != 3 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bytes.Equal(b[0], id) {
0000000000000000000000000000000000000000;;				return b[2]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateChallenge returns a random, hex-encoded challenge, or nil on error
0000000000000000000000000000000000000000;;	// (see above).
0000000000000000000000000000000000000000;;	func (a authCookieSha1) generateChallenge() []byte {
0000000000000000000000000000000000000000;;		b := make([]byte, 16)
0000000000000000000000000000000000000000;;		n, err := rand.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != 16 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enc := make([]byte, 32)
0000000000000000000000000000000000000000;;		hex.Encode(enc, b)
0000000000000000000000000000000000000000;;		return enc
0000000000000000000000000000000000000000;;	}
