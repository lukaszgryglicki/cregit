0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/dbus.go[Godeps/_workspace/src/github.com/godbus/dbus/dbus.go][vendor/github.com/godbus/dbus/dbus.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		byteType        = reflect.TypeOf(byte(0))
0000000000000000000000000000000000000000;;		boolType        = reflect.TypeOf(false)
0000000000000000000000000000000000000000;;		uint8Type       = reflect.TypeOf(uint8(0))
0000000000000000000000000000000000000000;;		int16Type       = reflect.TypeOf(int16(0))
0000000000000000000000000000000000000000;;		uint16Type      = reflect.TypeOf(uint16(0))
0000000000000000000000000000000000000000;;		int32Type       = reflect.TypeOf(int32(0))
0000000000000000000000000000000000000000;;		uint32Type      = reflect.TypeOf(uint32(0))
0000000000000000000000000000000000000000;;		int64Type       = reflect.TypeOf(int64(0))
0000000000000000000000000000000000000000;;		uint64Type      = reflect.TypeOf(uint64(0))
0000000000000000000000000000000000000000;;		float64Type     = reflect.TypeOf(float64(0))
0000000000000000000000000000000000000000;;		stringType      = reflect.TypeOf("")
0000000000000000000000000000000000000000;;		signatureType   = reflect.TypeOf(Signature{""})
0000000000000000000000000000000000000000;;		objectPathType  = reflect.TypeOf(ObjectPath(""))
0000000000000000000000000000000000000000;;		variantType     = reflect.TypeOf(Variant{Signature{""}, nil})
0000000000000000000000000000000000000000;;		interfacesType  = reflect.TypeOf([]interface{}{})
0000000000000000000000000000000000000000;;		unixFDType      = reflect.TypeOf(UnixFD(0))
0000000000000000000000000000000000000000;;		unixFDIndexType = reflect.TypeOf(UnixFDIndex(0))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An InvalidTypeError signals that a value which cannot be represented in the
0000000000000000000000000000000000000000;;	// D-Bus wire format was passed to a function.
0000000000000000000000000000000000000000;;	type InvalidTypeError struct {
0000000000000000000000000000000000000000;;		Type reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e InvalidTypeError) Error() string {
0000000000000000000000000000000000000000;;		return "dbus: invalid type " + e.Type.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Store copies the values contained in src to dest, which must be a slice of
0000000000000000000000000000000000000000;;	// pointers. It converts slices of interfaces from src to corresponding structs
0000000000000000000000000000000000000000;;	// in dest. An error is returned if the lengths of src and dest or the types of
0000000000000000000000000000000000000000;;	// their elements don't match.
0000000000000000000000000000000000000000;;	func Store(src []interface{}, dest ...interface{}) error {
0000000000000000000000000000000000000000;;		if len(src) != len(dest) {
0000000000000000000000000000000000000000;;			return errors.New("dbus.Store: length mismatch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range src {
0000000000000000000000000000000000000000;;			if err := store(src[i], dest[i]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func store(src, dest interface{}) error {
0000000000000000000000000000000000000000;;		if reflect.TypeOf(dest).Elem() == reflect.TypeOf(src) {
0000000000000000000000000000000000000000;;			reflect.ValueOf(dest).Elem().Set(reflect.ValueOf(src))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if hasStruct(dest) {
0000000000000000000000000000000000000000;;			rv := reflect.ValueOf(dest).Elem()
0000000000000000000000000000000000000000;;			switch rv.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				vs, ok := src.([]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return errors.New("dbus.Store: type mismatch")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t := rv.Type()
0000000000000000000000000000000000000000;;				ndest := make([]interface{}, 0, rv.NumField())
0000000000000000000000000000000000000000;;				for i := 0; i < rv.NumField(); i++ {
0000000000000000000000000000000000000000;;					field := t.Field(i)
0000000000000000000000000000000000000000;;					if field.PkgPath == "" && field.Tag.Get("dbus") != "-" {
0000000000000000000000000000000000000000;;						ndest = append(ndest, rv.Field(i).Addr().Interface())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(vs) != len(ndest) {
0000000000000000000000000000000000000000;;					return errors.New("dbus.Store: type mismatch")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := Store(vs, ndest...)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return errors.New("dbus.Store: type mismatch")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				sv := reflect.ValueOf(src)
0000000000000000000000000000000000000000;;				if sv.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;					return errors.New("dbus.Store: type mismatch")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rv.Set(reflect.MakeSlice(rv.Type(), sv.Len(), sv.Len()))
0000000000000000000000000000000000000000;;				for i := 0; i < sv.Len(); i++ {
0000000000000000000000000000000000000000;;					if err := store(sv.Index(i).Interface(), rv.Index(i).Addr().Interface()); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				sv := reflect.ValueOf(src)
0000000000000000000000000000000000000000;;				if sv.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;					return errors.New("dbus.Store: type mismatch")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				keys := sv.MapKeys()
0000000000000000000000000000000000000000;;				rv.Set(reflect.MakeMap(sv.Type()))
0000000000000000000000000000000000000000;;				for _, key := range keys {
0000000000000000000000000000000000000000;;					v := reflect.New(sv.Type().Elem())
0000000000000000000000000000000000000000;;					if err := store(v, sv.MapIndex(key).Interface()); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rv.SetMapIndex(key, v.Elem())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return errors.New("dbus.Store: type mismatch")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return errors.New("dbus.Store: type mismatch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasStruct(v interface{}) bool {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(v)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch t.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case reflect.Slice, reflect.Ptr, reflect.Map:
0000000000000000000000000000000000000000;;				t = t.Elem()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An ObjectPath is an object path as defined by the D-Bus spec.
0000000000000000000000000000000000000000;;	type ObjectPath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid returns whether the object path is valid.
0000000000000000000000000000000000000000;;	func (o ObjectPath) IsValid() bool {
0000000000000000000000000000000000000000;;		s := string(o)
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s[0] != '/' {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s[len(s)-1] == '/' && len(s) != 1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// probably not used, but technically possible
0000000000000000000000000000000000000000;;		if s == "/" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		split := strings.Split(s[1:], "/")
0000000000000000000000000000000000000000;;		for _, v := range split {
0000000000000000000000000000000000000000;;			if len(v) == 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range v {
0000000000000000000000000000000000000000;;				if !isMemberChar(c) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A UnixFD is a Unix file descriptor sent over the wire. See the package-level
0000000000000000000000000000000000000000;;	// documentation for more information about Unix file descriptor passsing.
0000000000000000000000000000000000000000;;	type UnixFD int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A UnixFDIndex is the representation of a Unix file descriptor in a message.
0000000000000000000000000000000000000000;;	type UnixFDIndex uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alignment returns the alignment of values of type t.
0000000000000000000000000000000000000000;;	func alignment(t reflect.Type) int {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case variantType:
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		case objectPathType:
0000000000000000000000000000000000000000;;			return 4
0000000000000000000000000000000000000000;;		case signatureType:
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		case interfacesType: // sometimes used for structs
0000000000000000000000000000000000000000;;			return 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Uint8:
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		case reflect.Uint16, reflect.Int16:
0000000000000000000000000000000000000000;;			return 2
0000000000000000000000000000000000000000;;		case reflect.Uint32, reflect.Int32, reflect.String, reflect.Array, reflect.Slice, reflect.Map:
0000000000000000000000000000000000000000;;			return 4
0000000000000000000000000000000000000000;;		case reflect.Uint64, reflect.Int64, reflect.Float64, reflect.Struct:
0000000000000000000000000000000000000000;;			return 8
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return alignment(t.Elem())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isKeyType returns whether t is a valid type for a D-Bus dict.
0000000000000000000000000000000000000000;;	func isKeyType(t reflect.Type) bool {
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
0000000000000000000000000000000000000000;;			reflect.Int16, reflect.Int32, reflect.Int64, reflect.Float64,
0000000000000000000000000000000000000000;;			reflect.String:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isValidInterface returns whether s is a valid name for an interface.
0000000000000000000000000000000000000000;;	func isValidInterface(s string) bool {
0000000000000000000000000000000000000000;;		if len(s) == 0 || len(s) > 255 || s[0] == '.' {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		elem := strings.Split(s, ".")
0000000000000000000000000000000000000000;;		if len(elem) < 2 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range elem {
0000000000000000000000000000000000000000;;			if len(v) == 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v[0] >= '0' && v[0] <= '9' {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range v {
0000000000000000000000000000000000000000;;				if !isMemberChar(c) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isValidMember returns whether s is a valid name for a member.
0000000000000000000000000000000000000000;;	func isValidMember(s string) bool {
0000000000000000000000000000000000000000;;		if len(s) == 0 || len(s) > 255 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := strings.Index(s, ".")
0000000000000000000000000000000000000000;;		if i != -1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s[0] >= '0' && s[0] <= '9' {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range s {
0000000000000000000000000000000000000000;;			if !isMemberChar(c) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isMemberChar(c rune) bool {
0000000000000000000000000000000000000000;;		return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') ||
0000000000000000000000000000000000000000;;			(c >= 'a' && c <= 'z') || c == '_'
0000000000000000000000000000000000000000;;	}
