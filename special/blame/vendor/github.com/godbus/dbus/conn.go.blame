0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/conn.go[Godeps/_workspace/src/github.com/godbus/dbus/conn.go][vendor/github.com/godbus/dbus/conn.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultSystemBusAddress = "unix:path=/var/run/dbus/system_bus_socket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		systemBus     *Conn
0000000000000000000000000000000000000000;;		systemBusLck  sync.Mutex
0000000000000000000000000000000000000000;;		sessionBus    *Conn
0000000000000000000000000000000000000000;;		sessionBusLck sync.Mutex
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrClosed is the error returned by calls on a closed connection.
0000000000000000000000000000000000000000;;	var ErrClosed = errors.New("dbus: connection closed by user")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conn represents a connection to a message bus (usually, the system or
0000000000000000000000000000000000000000;;	// session bus).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Connections are either shared or private. Shared connections
0000000000000000000000000000000000000000;;	// are shared between calls to the functions that return them. As a result,
0000000000000000000000000000000000000000;;	// the methods Close, Auth and Hello must not be called on them.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Multiple goroutines may invoke methods on a connection simultaneously.
0000000000000000000000000000000000000000;;	type Conn struct {
0000000000000000000000000000000000000000;;		transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		busObj BusObject
0000000000000000000000000000000000000000;;		unixFD bool
0000000000000000000000000000000000000000;;		uuid   string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names    []string
0000000000000000000000000000000000000000;;		namesLck sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serialLck  sync.Mutex
0000000000000000000000000000000000000000;;		nextSerial uint32
0000000000000000000000000000000000000000;;		serialUsed map[uint32]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		calls    map[uint32]*Call
0000000000000000000000000000000000000000;;		callsLck sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handlers    map[ObjectPath]map[string]exportWithMapping
0000000000000000000000000000000000000000;;		handlersLck sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out    chan *Message
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;		outLck sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signals    []chan<- *Signal
0000000000000000000000000000000000000000;;		signalsLck sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eavesdropped    chan<- *Message
0000000000000000000000000000000000000000;;		eavesdroppedLck sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SessionBus returns a shared connection to the session bus, connecting to it
0000000000000000000000000000000000000000;;	// if not already done.
0000000000000000000000000000000000000000;;	func SessionBus() (conn *Conn, err error) {
0000000000000000000000000000000000000000;;		sessionBusLck.Lock()
0000000000000000000000000000000000000000;;		defer sessionBusLck.Unlock()
0000000000000000000000000000000000000000;;		if sessionBus != nil {
0000000000000000000000000000000000000000;;			return sessionBus, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if conn != nil {
0000000000000000000000000000000000000000;;				sessionBus = conn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		conn, err = SessionBusPrivate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = conn.Auth(nil); err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			conn = nil
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = conn.Hello(); err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			conn = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SessionBusPrivate returns a new private connection to the session bus.
0000000000000000000000000000000000000000;;	func SessionBusPrivate() (*Conn, error) {
0000000000000000000000000000000000000000;;		address := os.Getenv("DBUS_SESSION_BUS_ADDRESS")
0000000000000000000000000000000000000000;;		if address != "" && address != "autolaunch:" {
0000000000000000000000000000000000000000;;			return Dial(address)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sessionBusPlatform()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SystemBus returns a shared connection to the system bus, connecting to it if
0000000000000000000000000000000000000000;;	// not already done.
0000000000000000000000000000000000000000;;	func SystemBus() (conn *Conn, err error) {
0000000000000000000000000000000000000000;;		systemBusLck.Lock()
0000000000000000000000000000000000000000;;		defer systemBusLck.Unlock()
0000000000000000000000000000000000000000;;		if systemBus != nil {
0000000000000000000000000000000000000000;;			return systemBus, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if conn != nil {
0000000000000000000000000000000000000000;;				systemBus = conn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		conn, err = SystemBusPrivate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = conn.Auth(nil); err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			conn = nil
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = conn.Hello(); err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			conn = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SystemBusPrivate returns a new private connection to the system bus.
0000000000000000000000000000000000000000;;	func SystemBusPrivate() (*Conn, error) {
0000000000000000000000000000000000000000;;		address := os.Getenv("DBUS_SYSTEM_BUS_ADDRESS")
0000000000000000000000000000000000000000;;		if address != "" {
0000000000000000000000000000000000000000;;			return Dial(address)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Dial(defaultSystemBusAddress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial establishes a new private connection to the message bus specified by address.
0000000000000000000000000000000000000000;;	func Dial(address string) (*Conn, error) {
0000000000000000000000000000000000000000;;		tr, err := getTransport(address)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newConn(tr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConn creates a new private *Conn from an already established connection.
0000000000000000000000000000000000000000;;	func NewConn(conn io.ReadWriteCloser) (*Conn, error) {
0000000000000000000000000000000000000000;;		return newConn(genericTransport{conn})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newConn creates a new *Conn from a transport.
0000000000000000000000000000000000000000;;	func newConn(tr transport) (*Conn, error) {
0000000000000000000000000000000000000000;;		conn := new(Conn)
0000000000000000000000000000000000000000;;		conn.transport = tr
0000000000000000000000000000000000000000;;		conn.calls = make(map[uint32]*Call)
0000000000000000000000000000000000000000;;		conn.out = make(chan *Message, 10)
0000000000000000000000000000000000000000;;		conn.handlers = make(map[ObjectPath]map[string]exportWithMapping)
0000000000000000000000000000000000000000;;		conn.nextSerial = 1
0000000000000000000000000000000000000000;;		conn.serialUsed = map[uint32]bool{0: true}
0000000000000000000000000000000000000000;;		conn.busObj = conn.Object("org.freedesktop.DBus", "/org/freedesktop/DBus")
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BusObject returns the object owned by the bus daemon which handles
0000000000000000000000000000000000000000;;	// administrative requests.
0000000000000000000000000000000000000000;;	func (conn *Conn) BusObject() BusObject {
0000000000000000000000000000000000000000;;		return conn.busObj
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the connection. Any blocked operations will return with errors
0000000000000000000000000000000000000000;;	// and the channels passed to Eavesdrop and Signal are closed. This method must
0000000000000000000000000000000000000000;;	// not be called on shared connections.
0000000000000000000000000000000000000000;;	func (conn *Conn) Close() error {
0000000000000000000000000000000000000000;;		conn.outLck.Lock()
0000000000000000000000000000000000000000;;		if conn.closed {
0000000000000000000000000000000000000000;;			// inWorker calls Close on read error, the read error may
0000000000000000000000000000000000000000;;			// be caused by another caller calling Close to shutdown the
0000000000000000000000000000000000000000;;			// dbus connection, a double-close scenario we prevent here.
0000000000000000000000000000000000000000;;			conn.outLck.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(conn.out)
0000000000000000000000000000000000000000;;		conn.closed = true
0000000000000000000000000000000000000000;;		conn.outLck.Unlock()
0000000000000000000000000000000000000000;;		conn.signalsLck.Lock()
0000000000000000000000000000000000000000;;		for _, ch := range conn.signals {
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.signalsLck.Unlock()
0000000000000000000000000000000000000000;;		conn.eavesdroppedLck.Lock()
0000000000000000000000000000000000000000;;		if conn.eavesdropped != nil {
0000000000000000000000000000000000000000;;			close(conn.eavesdropped)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.eavesdroppedLck.Unlock()
0000000000000000000000000000000000000000;;		return conn.transport.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Eavesdrop causes conn to send all incoming messages to the given channel
0000000000000000000000000000000000000000;;	// without further processing. Method replies, errors and signals will not be
0000000000000000000000000000000000000000;;	// sent to the appropiate channels and method calls will not be handled. If nil
0000000000000000000000000000000000000000;;	// is passed, the normal behaviour is restored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The caller has to make sure that ch is sufficiently buffered;
0000000000000000000000000000000000000000;;	// if a message arrives when a write to ch is not possible, the message is
0000000000000000000000000000000000000000;;	// discarded.
0000000000000000000000000000000000000000;;	func (conn *Conn) Eavesdrop(ch chan<- *Message) {
0000000000000000000000000000000000000000;;		conn.eavesdroppedLck.Lock()
0000000000000000000000000000000000000000;;		conn.eavesdropped = ch
0000000000000000000000000000000000000000;;		conn.eavesdroppedLck.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSerial returns an unused serial.
0000000000000000000000000000000000000000;;	func (conn *Conn) getSerial() uint32 {
0000000000000000000000000000000000000000;;		conn.serialLck.Lock()
0000000000000000000000000000000000000000;;		defer conn.serialLck.Unlock()
0000000000000000000000000000000000000000;;		n := conn.nextSerial
0000000000000000000000000000000000000000;;		for conn.serialUsed[n] {
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.serialUsed[n] = true
0000000000000000000000000000000000000000;;		conn.nextSerial = n + 1
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hello sends the initial org.freedesktop.DBus.Hello call. This method must be
0000000000000000000000000000000000000000;;	// called after authentication, but before sending any other messages to the
0000000000000000000000000000000000000000;;	// bus. Hello must not be called for shared connections.
0000000000000000000000000000000000000000;;	func (conn *Conn) Hello() error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		err := conn.busObj.Call("org.freedesktop.DBus.Hello", 0).Store(&s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.namesLck.Lock()
0000000000000000000000000000000000000000;;		conn.names = make([]string, 1)
0000000000000000000000000000000000000000;;		conn.names[0] = s
0000000000000000000000000000000000000000;;		conn.namesLck.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inWorker runs in an own goroutine, reading incoming messages from the
0000000000000000000000000000000000000000;;	// transport and dispatching them appropiately.
0000000000000000000000000000000000000000;;	func (conn *Conn) inWorker() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			msg, err := conn.ReadMessage()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				conn.eavesdroppedLck.Lock()
0000000000000000000000000000000000000000;;				if conn.eavesdropped != nil {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case conn.eavesdropped <- msg:
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					conn.eavesdroppedLck.Unlock()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				conn.eavesdroppedLck.Unlock()
0000000000000000000000000000000000000000;;				dest, _ := msg.Headers[FieldDestination].value.(string)
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				if dest == "" {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					conn.namesLck.RLock()
0000000000000000000000000000000000000000;;					if len(conn.names) == 0 {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, v := range conn.names {
0000000000000000000000000000000000000000;;						if dest == v {
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					conn.namesLck.RUnlock()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					// Eavesdropped a message, but no channel for it is registered.
0000000000000000000000000000000000000000;;					// Ignore it.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch msg.Type {
0000000000000000000000000000000000000000;;				case TypeMethodReply, TypeError:
0000000000000000000000000000000000000000;;					serial := msg.Headers[FieldReplySerial].value.(uint32)
0000000000000000000000000000000000000000;;					conn.callsLck.Lock()
0000000000000000000000000000000000000000;;					if c, ok := conn.calls[serial]; ok {
0000000000000000000000000000000000000000;;						if msg.Type == TypeError {
0000000000000000000000000000000000000000;;							name, _ := msg.Headers[FieldErrorName].value.(string)
0000000000000000000000000000000000000000;;							c.Err = Error{name, msg.Body}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							c.Body = msg.Body
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						c.Done <- c
0000000000000000000000000000000000000000;;						conn.serialLck.Lock()
0000000000000000000000000000000000000000;;						delete(conn.serialUsed, serial)
0000000000000000000000000000000000000000;;						conn.serialLck.Unlock()
0000000000000000000000000000000000000000;;						delete(conn.calls, serial)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					conn.callsLck.Unlock()
0000000000000000000000000000000000000000;;				case TypeSignal:
0000000000000000000000000000000000000000;;					iface := msg.Headers[FieldInterface].value.(string)
0000000000000000000000000000000000000000;;					member := msg.Headers[FieldMember].value.(string)
0000000000000000000000000000000000000000;;					// as per http://dbus.freedesktop.org/doc/dbus-specification.html ,
0000000000000000000000000000000000000000;;					// sender is optional for signals.
0000000000000000000000000000000000000000;;					sender, _ := msg.Headers[FieldSender].value.(string)
0000000000000000000000000000000000000000;;					if iface == "org.freedesktop.DBus" && sender == "org.freedesktop.DBus" {
0000000000000000000000000000000000000000;;						if member == "NameLost" {
0000000000000000000000000000000000000000;;							// If we lost the name on the bus, remove it from our
0000000000000000000000000000000000000000;;							// tracking list.
0000000000000000000000000000000000000000;;							name, ok := msg.Body[0].(string)
0000000000000000000000000000000000000000;;							if !ok {
0000000000000000000000000000000000000000;;								panic("Unable to read the lost name")
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							conn.namesLck.Lock()
0000000000000000000000000000000000000000;;							for i, v := range conn.names {
0000000000000000000000000000000000000000;;								if v == name {
0000000000000000000000000000000000000000;;									conn.names = append(conn.names[:i],
0000000000000000000000000000000000000000;;										conn.names[i+1:]...)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							conn.namesLck.Unlock()
0000000000000000000000000000000000000000;;						} else if member == "NameAcquired" {
0000000000000000000000000000000000000000;;							// If we acquired the name on the bus, add it to our
0000000000000000000000000000000000000000;;							// tracking list.
0000000000000000000000000000000000000000;;							name, ok := msg.Body[0].(string)
0000000000000000000000000000000000000000;;							if !ok {
0000000000000000000000000000000000000000;;								panic("Unable to read the acquired name")
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							conn.namesLck.Lock()
0000000000000000000000000000000000000000;;							conn.names = append(conn.names, name)
0000000000000000000000000000000000000000;;							conn.namesLck.Unlock()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					signal := &Signal{
0000000000000000000000000000000000000000;;						Sender: sender,
0000000000000000000000000000000000000000;;						Path:   msg.Headers[FieldPath].value.(ObjectPath),
0000000000000000000000000000000000000000;;						Name:   iface + "." + member,
0000000000000000000000000000000000000000;;						Body:   msg.Body,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					conn.signalsLck.Lock()
0000000000000000000000000000000000000000;;					for _, ch := range conn.signals {
0000000000000000000000000000000000000000;;						ch <- signal
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					conn.signalsLck.Unlock()
0000000000000000000000000000000000000000;;				case TypeMethodCall:
0000000000000000000000000000000000000000;;					go conn.handleCall(msg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if _, ok := err.(InvalidMessageError); !ok {
0000000000000000000000000000000000000000;;				// Some read error occured (usually EOF); we can't really do
0000000000000000000000000000000000000000;;				// anything but to shut down all stuff and returns errors to all
0000000000000000000000000000000000000000;;				// pending replies.
0000000000000000000000000000000000000000;;				conn.Close()
0000000000000000000000000000000000000000;;				conn.callsLck.RLock()
0000000000000000000000000000000000000000;;				for _, v := range conn.calls {
0000000000000000000000000000000000000000;;					v.Err = err
0000000000000000000000000000000000000000;;					v.Done <- v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				conn.callsLck.RUnlock()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// invalid messages are ignored
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Names returns the list of all names that are currently owned by this
0000000000000000000000000000000000000000;;	// connection. The slice is always at least one element long, the first element
0000000000000000000000000000000000000000;;	// being the unique name of the connection.
0000000000000000000000000000000000000000;;	func (conn *Conn) Names() []string {
0000000000000000000000000000000000000000;;		conn.namesLck.RLock()
0000000000000000000000000000000000000000;;		// copy the slice so it can't be modified
0000000000000000000000000000000000000000;;		s := make([]string, len(conn.names))
0000000000000000000000000000000000000000;;		copy(s, conn.names)
0000000000000000000000000000000000000000;;		conn.namesLck.RUnlock()
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Object returns the object identified by the given destination name and path.
0000000000000000000000000000000000000000;;	func (conn *Conn) Object(dest string, path ObjectPath) BusObject {
0000000000000000000000000000000000000000;;		return &Object{conn, dest, path}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// outWorker runs in an own goroutine, encoding and sending messages that are
0000000000000000000000000000000000000000;;	// sent to conn.out.
0000000000000000000000000000000000000000;;	func (conn *Conn) outWorker() {
0000000000000000000000000000000000000000;;		for msg := range conn.out {
0000000000000000000000000000000000000000;;			err := conn.SendMessage(msg)
0000000000000000000000000000000000000000;;			conn.callsLck.RLock()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if c := conn.calls[msg.serial]; c != nil {
0000000000000000000000000000000000000000;;					c.Err = err
0000000000000000000000000000000000000000;;					c.Done <- c
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				conn.serialLck.Lock()
0000000000000000000000000000000000000000;;				delete(conn.serialUsed, msg.serial)
0000000000000000000000000000000000000000;;				conn.serialLck.Unlock()
0000000000000000000000000000000000000000;;			} else if msg.Type != TypeMethodCall {
0000000000000000000000000000000000000000;;				conn.serialLck.Lock()
0000000000000000000000000000000000000000;;				delete(conn.serialUsed, msg.serial)
0000000000000000000000000000000000000000;;				conn.serialLck.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.callsLck.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send sends the given message to the message bus. You usually don't need to
0000000000000000000000000000000000000000;;	// use this; use the higher-level equivalents (Call / Go, Emit and Export)
0000000000000000000000000000000000000000;;	// instead. If msg is a method call and NoReplyExpected is not set, a non-nil
0000000000000000000000000000000000000000;;	// call is returned and the same value is sent to ch (which must be buffered)
0000000000000000000000000000000000000000;;	// once the call is complete. Otherwise, ch is ignored and a Call structure is
0000000000000000000000000000000000000000;;	// returned of which only the Err member is valid.
0000000000000000000000000000000000000000;;	func (conn *Conn) Send(msg *Message, ch chan *Call) *Call {
0000000000000000000000000000000000000000;;		var call *Call
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg.serial = conn.getSerial()
0000000000000000000000000000000000000000;;		if msg.Type == TypeMethodCall && msg.Flags&FlagNoReplyExpected == 0 {
0000000000000000000000000000000000000000;;			if ch == nil {
0000000000000000000000000000000000000000;;				ch = make(chan *Call, 5)
0000000000000000000000000000000000000000;;			} else if cap(ch) == 0 {
0000000000000000000000000000000000000000;;				panic("dbus: unbuffered channel passed to (*Conn).Send")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			call = new(Call)
0000000000000000000000000000000000000000;;			call.Destination, _ = msg.Headers[FieldDestination].value.(string)
0000000000000000000000000000000000000000;;			call.Path, _ = msg.Headers[FieldPath].value.(ObjectPath)
0000000000000000000000000000000000000000;;			iface, _ := msg.Headers[FieldInterface].value.(string)
0000000000000000000000000000000000000000;;			member, _ := msg.Headers[FieldMember].value.(string)
0000000000000000000000000000000000000000;;			call.Method = iface + "." + member
0000000000000000000000000000000000000000;;			call.Args = msg.Body
0000000000000000000000000000000000000000;;			call.Done = ch
0000000000000000000000000000000000000000;;			conn.callsLck.Lock()
0000000000000000000000000000000000000000;;			conn.calls[msg.serial] = call
0000000000000000000000000000000000000000;;			conn.callsLck.Unlock()
0000000000000000000000000000000000000000;;			conn.outLck.RLock()
0000000000000000000000000000000000000000;;			if conn.closed {
0000000000000000000000000000000000000000;;				call.Err = ErrClosed
0000000000000000000000000000000000000000;;				call.Done <- call
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				conn.out <- msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			conn.outLck.RLock()
0000000000000000000000000000000000000000;;			if conn.closed {
0000000000000000000000000000000000000000;;				call = &Call{Err: ErrClosed}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				conn.out <- msg
0000000000000000000000000000000000000000;;				call = &Call{Err: nil}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return call
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendError creates an error message corresponding to the parameters and sends
0000000000000000000000000000000000000000;;	// it to conn.out.
0000000000000000000000000000000000000000;;	func (conn *Conn) sendError(e Error, dest string, serial uint32) {
0000000000000000000000000000000000000000;;		msg := new(Message)
0000000000000000000000000000000000000000;;		msg.Type = TypeError
0000000000000000000000000000000000000000;;		msg.serial = conn.getSerial()
0000000000000000000000000000000000000000;;		msg.Headers = make(map[HeaderField]Variant)
0000000000000000000000000000000000000000;;		if dest != "" {
0000000000000000000000000000000000000000;;			msg.Headers[FieldDestination] = MakeVariant(dest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Headers[FieldErrorName] = MakeVariant(e.Name)
0000000000000000000000000000000000000000;;		msg.Headers[FieldReplySerial] = MakeVariant(serial)
0000000000000000000000000000000000000000;;		msg.Body = e.Body
0000000000000000000000000000000000000000;;		if len(e.Body) > 0 {
0000000000000000000000000000000000000000;;			msg.Headers[FieldSignature] = MakeVariant(SignatureOf(e.Body...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.outLck.RLock()
0000000000000000000000000000000000000000;;		if !conn.closed {
0000000000000000000000000000000000000000;;			conn.out <- msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendReply creates a method reply message corresponding to the parameters and
0000000000000000000000000000000000000000;;	// sends it to conn.out.
0000000000000000000000000000000000000000;;	func (conn *Conn) sendReply(dest string, serial uint32, values ...interface{}) {
0000000000000000000000000000000000000000;;		msg := new(Message)
0000000000000000000000000000000000000000;;		msg.Type = TypeMethodReply
0000000000000000000000000000000000000000;;		msg.serial = conn.getSerial()
0000000000000000000000000000000000000000;;		msg.Headers = make(map[HeaderField]Variant)
0000000000000000000000000000000000000000;;		if dest != "" {
0000000000000000000000000000000000000000;;			msg.Headers[FieldDestination] = MakeVariant(dest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Headers[FieldReplySerial] = MakeVariant(serial)
0000000000000000000000000000000000000000;;		msg.Body = values
0000000000000000000000000000000000000000;;		if len(values) > 0 {
0000000000000000000000000000000000000000;;			msg.Headers[FieldSignature] = MakeVariant(SignatureOf(values...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.outLck.RLock()
0000000000000000000000000000000000000000;;		if !conn.closed {
0000000000000000000000000000000000000000;;			conn.out <- msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signal registers the given channel to be passed all received signal messages.
0000000000000000000000000000000000000000;;	// The caller has to make sure that ch is sufficiently buffered; if a message
0000000000000000000000000000000000000000;;	// arrives when a write to c is not possible, it is discarded.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Multiple of these channels can be registered at the same time. Passing a
0000000000000000000000000000000000000000;;	// channel that already is registered will remove it from the list of the
0000000000000000000000000000000000000000;;	// registered channels.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// These channels are "overwritten" by Eavesdrop; i.e., if there currently is a
0000000000000000000000000000000000000000;;	// channel for eavesdropped messages, this channel receives all signals, and
0000000000000000000000000000000000000000;;	// none of the channels passed to Signal will receive any signals.
0000000000000000000000000000000000000000;;	func (conn *Conn) Signal(ch chan<- *Signal) {
0000000000000000000000000000000000000000;;		conn.signalsLck.Lock()
0000000000000000000000000000000000000000;;		conn.signals = append(conn.signals, ch)
0000000000000000000000000000000000000000;;		conn.signalsLck.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportsUnixFDs returns whether the underlying transport supports passing of
0000000000000000000000000000000000000000;;	// unix file descriptors. If this is false, method calls containing unix file
0000000000000000000000000000000000000000;;	// descriptors will return an error and emitted signals containing them will
0000000000000000000000000000000000000000;;	// not be sent.
0000000000000000000000000000000000000000;;	func (conn *Conn) SupportsUnixFDs() bool {
0000000000000000000000000000000000000000;;		return conn.unixFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error represents a D-Bus message of type Error.
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Body []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewError(name string, body []interface{}) *Error {
0000000000000000000000000000000000000000;;		return &Error{name, body}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e Error) Error() string {
0000000000000000000000000000000000000000;;		if len(e.Body) >= 1 {
0000000000000000000000000000000000000000;;			s, ok := e.Body[0].(string)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				return s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signal represents a D-Bus message of type Signal. The name member is given in
0000000000000000000000000000000000000000;;	// "interface.member" notation, e.g. org.freedesktop.D-Bus.NameLost.
0000000000000000000000000000000000000000;;	type Signal struct {
0000000000000000000000000000000000000000;;		Sender string
0000000000000000000000000000000000000000;;		Path   ObjectPath
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Body   []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transport is a D-Bus transport.
0000000000000000000000000000000000000000;;	type transport interface {
0000000000000000000000000000000000000000;;		// Read and Write raw data (for example, for the authentication protocol).
0000000000000000000000000000000000000000;;		io.ReadWriteCloser
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send the initial null byte used for the EXTERNAL mechanism.
0000000000000000000000000000000000000000;;		SendNullByte() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns whether this transport supports passing Unix FDs.
0000000000000000000000000000000000000000;;		SupportsUnixFDs() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Signal the transport that Unix FD passing is enabled for this connection.
0000000000000000000000000000000000000000;;		EnableUnixFDs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read / send a message, handling things like Unix FDs.
0000000000000000000000000000000000000000;;		ReadMessage() (*Message, error)
0000000000000000000000000000000000000000;;		SendMessage(*Message) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		transports = make(map[string]func(string) (transport, error))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTransport(address string) (transport, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var t transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addresses := strings.Split(address, ";")
0000000000000000000000000000000000000000;;		for _, v := range addresses {
0000000000000000000000000000000000000000;;			i := strings.IndexRune(v, ':')
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				err = errors.New("dbus: invalid bus address (no transport)")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f := transports[v[:i]]
0000000000000000000000000000000000000000;;			if f == nil {
0000000000000000000000000000000000000000;;				err = errors.New("dbus: invalid bus address (invalid or unsupported transport)")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t, err = f(v[i+1:])
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return t, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dereferenceAll returns a slice that, assuming that vs is a slice of pointers
0000000000000000000000000000000000000000;;	// of arbitrary types, containes the values that are obtained from dereferencing
0000000000000000000000000000000000000000;;	// all elements in vs.
0000000000000000000000000000000000000000;;	func dereferenceAll(vs []interface{}) []interface{} {
0000000000000000000000000000000000000000;;		for i := range vs {
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(vs[i])
0000000000000000000000000000000000000000;;			v = v.Elem()
0000000000000000000000000000000000000000;;			vs[i] = v.Interface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getKey gets a key from a the list of keys. Returns "" on error / not found...
0000000000000000000000000000000000000000;;	func getKey(s, key string) string {
0000000000000000000000000000000000000000;;		i := strings.Index(s, key)
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i+len(key)+1 >= len(s) || s[i+len(key)] != '=' {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j := strings.Index(s, ",")
0000000000000000000000000000000000000000;;		if j == -1 {
0000000000000000000000000000000000000000;;			j = len(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s[i+len(key)+1 : j]
0000000000000000000000000000000000000000;;	}
