0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/variant_lexer.go[Godeps/_workspace/src/github.com/godbus/dbus/variant_lexer.go][vendor/github.com/godbus/dbus/variant_lexer.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Heavily inspired by the lexer from text/template.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type varToken struct {
0000000000000000000000000000000000000000;;		typ varTokenType
0000000000000000000000000000000000000000;;		val string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type varTokenType byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tokEOF varTokenType = iota
0000000000000000000000000000000000000000;;		tokError
0000000000000000000000000000000000000000;;		tokNumber
0000000000000000000000000000000000000000;;		tokString
0000000000000000000000000000000000000000;;		tokBool
0000000000000000000000000000000000000000;;		tokArrayStart
0000000000000000000000000000000000000000;;		tokArrayEnd
0000000000000000000000000000000000000000;;		tokDictStart
0000000000000000000000000000000000000000;;		tokDictEnd
0000000000000000000000000000000000000000;;		tokVariantStart
0000000000000000000000000000000000000000;;		tokVariantEnd
0000000000000000000000000000000000000000;;		tokComma
0000000000000000000000000000000000000000;;		tokColon
0000000000000000000000000000000000000000;;		tokType
0000000000000000000000000000000000000000;;		tokByteString
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type varLexer struct {
0000000000000000000000000000000000000000;;		input  string
0000000000000000000000000000000000000000;;		start  int
0000000000000000000000000000000000000000;;		pos    int
0000000000000000000000000000000000000000;;		width  int
0000000000000000000000000000000000000000;;		tokens []varToken
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lexState func(*varLexer) lexState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varLex(s string) []varToken {
0000000000000000000000000000000000000000;;		l := &varLexer{input: s}
0000000000000000000000000000000000000000;;		l.run()
0000000000000000000000000000000000000000;;		return l.tokens
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) accept(valid string) bool {
0000000000000000000000000000000000000000;;		if strings.IndexRune(valid, l.next()) >= 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.backup()
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) backup() {
0000000000000000000000000000000000000000;;		l.pos -= l.width
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) emit(t varTokenType) {
0000000000000000000000000000000000000000;;		l.tokens = append(l.tokens, varToken{t, l.input[l.start:l.pos]})
0000000000000000000000000000000000000000;;		l.start = l.pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) errorf(format string, v ...interface{}) lexState {
0000000000000000000000000000000000000000;;		l.tokens = append(l.tokens, varToken{
0000000000000000000000000000000000000000;;			tokError,
0000000000000000000000000000000000000000;;			fmt.Sprintf(format, v...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) ignore() {
0000000000000000000000000000000000000000;;		l.start = l.pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) next() rune {
0000000000000000000000000000000000000000;;		var r rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.pos >= len(l.input) {
0000000000000000000000000000000000000000;;			l.width = 0
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, l.width = utf8.DecodeRuneInString(l.input[l.pos:])
0000000000000000000000000000000000000000;;		l.pos += l.width
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) run() {
0000000000000000000000000000000000000000;;		for state := varLexNormal; state != nil; {
0000000000000000000000000000000000000000;;			state = state(l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *varLexer) peek() rune {
0000000000000000000000000000000000000000;;		r := l.next()
0000000000000000000000000000000000000000;;		l.backup()
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varLexNormal(l *varLexer) lexState {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r := l.next()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case r == -1:
0000000000000000000000000000000000000000;;				l.emit(tokEOF)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case r == '[':
0000000000000000000000000000000000000000;;				l.emit(tokArrayStart)
0000000000000000000000000000000000000000;;			case r == ']':
0000000000000000000000000000000000000000;;				l.emit(tokArrayEnd)
0000000000000000000000000000000000000000;;			case r == '{':
0000000000000000000000000000000000000000;;				l.emit(tokDictStart)
0000000000000000000000000000000000000000;;			case r == '}':
0000000000000000000000000000000000000000;;				l.emit(tokDictEnd)
0000000000000000000000000000000000000000;;			case r == '<':
0000000000000000000000000000000000000000;;				l.emit(tokVariantStart)
0000000000000000000000000000000000000000;;			case r == '>':
0000000000000000000000000000000000000000;;				l.emit(tokVariantEnd)
0000000000000000000000000000000000000000;;			case r == ':':
0000000000000000000000000000000000000000;;				l.emit(tokColon)
0000000000000000000000000000000000000000;;			case r == ',':
0000000000000000000000000000000000000000;;				l.emit(tokComma)
0000000000000000000000000000000000000000;;			case r == '\'' || r == '"':
0000000000000000000000000000000000000000;;				l.backup()
0000000000000000000000000000000000000000;;				return varLexString
0000000000000000000000000000000000000000;;			case r == '@':
0000000000000000000000000000000000000000;;				l.backup()
0000000000000000000000000000000000000000;;				return varLexType
0000000000000000000000000000000000000000;;			case unicode.IsSpace(r):
0000000000000000000000000000000000000000;;				l.ignore()
0000000000000000000000000000000000000000;;			case unicode.IsNumber(r) || r == '+' || r == '-':
0000000000000000000000000000000000000000;;				l.backup()
0000000000000000000000000000000000000000;;				return varLexNumber
0000000000000000000000000000000000000000;;			case r == 'b':
0000000000000000000000000000000000000000;;				pos := l.start
0000000000000000000000000000000000000000;;				if n := l.peek(); n == '"' || n == '\'' {
0000000000000000000000000000000000000000;;					return varLexByteString
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// not a byte string; try to parse it as a type or bool below
0000000000000000000000000000000000000000;;				l.pos = pos + 1
0000000000000000000000000000000000000000;;				l.width = 1
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// either a bool or a type. Try bools first.
0000000000000000000000000000000000000000;;				l.backup()
0000000000000000000000000000000000000000;;				if l.pos+4 <= len(l.input) {
0000000000000000000000000000000000000000;;					if l.input[l.pos:l.pos+4] == "true" {
0000000000000000000000000000000000000000;;						l.pos += 4
0000000000000000000000000000000000000000;;						l.emit(tokBool)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if l.pos+5 <= len(l.input) {
0000000000000000000000000000000000000000;;					if l.input[l.pos:l.pos+5] == "false" {
0000000000000000000000000000000000000000;;						l.pos += 5
0000000000000000000000000000000000000000;;						l.emit(tokBool)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// must be a type.
0000000000000000000000000000000000000000;;				return varLexType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var varTypeMap = map[string]string{
0000000000000000000000000000000000000000;;		"boolean":    "b",
0000000000000000000000000000000000000000;;		"byte":       "y",
0000000000000000000000000000000000000000;;		"int16":      "n",
0000000000000000000000000000000000000000;;		"uint16":     "q",
0000000000000000000000000000000000000000;;		"int32":      "i",
0000000000000000000000000000000000000000;;		"uint32":     "u",
0000000000000000000000000000000000000000;;		"int64":      "x",
0000000000000000000000000000000000000000;;		"uint64":     "t",
0000000000000000000000000000000000000000;;		"double":     "f",
0000000000000000000000000000000000000000;;		"string":     "s",
0000000000000000000000000000000000000000;;		"objectpath": "o",
0000000000000000000000000000000000000000;;		"signature":  "g",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varLexByteString(l *varLexer) lexState {
0000000000000000000000000000000000000000;;		q := l.next()
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch l.next() {
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				if r := l.next(); r != -1 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case -1:
0000000000000000000000000000000000000000;;				return l.errorf("unterminated bytestring")
0000000000000000000000000000000000000000;;			case q:
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.emit(tokByteString)
0000000000000000000000000000000000000000;;		return varLexNormal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varLexNumber(l *varLexer) lexState {
0000000000000000000000000000000000000000;;		l.accept("+-")
0000000000000000000000000000000000000000;;		digits := "0123456789"
0000000000000000000000000000000000000000;;		if l.accept("0") {
0000000000000000000000000000000000000000;;			if l.accept("x") {
0000000000000000000000000000000000000000;;				digits = "0123456789abcdefABCDEF"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				digits = "01234567"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for strings.IndexRune(digits, l.next()) >= 0 {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.backup()
0000000000000000000000000000000000000000;;		if l.accept(".") {
0000000000000000000000000000000000000000;;			for strings.IndexRune(digits, l.next()) >= 0 {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.backup()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.accept("eE") {
0000000000000000000000000000000000000000;;			l.accept("+-")
0000000000000000000000000000000000000000;;			for strings.IndexRune("0123456789", l.next()) >= 0 {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.backup()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r := l.peek(); unicode.IsLetter(r) {
0000000000000000000000000000000000000000;;			l.next()
0000000000000000000000000000000000000000;;			return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.emit(tokNumber)
0000000000000000000000000000000000000000;;		return varLexNormal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varLexString(l *varLexer) lexState {
0000000000000000000000000000000000000000;;		q := l.next()
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch l.next() {
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				if r := l.next(); r != -1 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case -1:
0000000000000000000000000000000000000000;;				return l.errorf("unterminated string")
0000000000000000000000000000000000000000;;			case q:
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.emit(tokString)
0000000000000000000000000000000000000000;;		return varLexNormal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func varLexType(l *varLexer) lexState {
0000000000000000000000000000000000000000;;		at := l.accept("@")
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r := l.next()
0000000000000000000000000000000000000000;;			if r == -1 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if unicode.IsSpace(r) {
0000000000000000000000000000000000000000;;				l.backup()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if at {
0000000000000000000000000000000000000000;;			if _, err := ParseSignature(l.input[l.start+1 : l.pos]); err != nil {
0000000000000000000000000000000000000000;;				return l.errorf("%s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if _, ok := varTypeMap[l.input[l.start:l.pos]]; ok {
0000000000000000000000000000000000000000;;				l.emit(tokType)
0000000000000000000000000000000000000000;;				return varLexNormal
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return l.errorf("unrecognized type %q", l.input[l.start:l.pos])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.emit(tokType)
0000000000000000000000000000000000000000;;		return varLexNormal
0000000000000000000000000000000000000000;;	}
