0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/sig.go[Godeps/_workspace/src/github.com/godbus/dbus/sig.go][vendor/github.com/godbus/dbus/sig.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sigToType = map[byte]reflect.Type{
0000000000000000000000000000000000000000;;		'y': byteType,
0000000000000000000000000000000000000000;;		'b': boolType,
0000000000000000000000000000000000000000;;		'n': int16Type,
0000000000000000000000000000000000000000;;		'q': uint16Type,
0000000000000000000000000000000000000000;;		'i': int32Type,
0000000000000000000000000000000000000000;;		'u': uint32Type,
0000000000000000000000000000000000000000;;		'x': int64Type,
0000000000000000000000000000000000000000;;		't': uint64Type,
0000000000000000000000000000000000000000;;		'd': float64Type,
0000000000000000000000000000000000000000;;		's': stringType,
0000000000000000000000000000000000000000;;		'g': signatureType,
0000000000000000000000000000000000000000;;		'o': objectPathType,
0000000000000000000000000000000000000000;;		'v': variantType,
0000000000000000000000000000000000000000;;		'h': unixFDIndexType,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signature represents a correct type signature as specified by the D-Bus
0000000000000000000000000000000000000000;;	// specification. The zero value represents the empty signature, "".
0000000000000000000000000000000000000000;;	type Signature struct {
0000000000000000000000000000000000000000;;		str string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureOf returns the concatenation of all the signatures of the given
0000000000000000000000000000000000000000;;	// values. It panics if one of them is not representable in D-Bus.
0000000000000000000000000000000000000000;;	func SignatureOf(vs ...interface{}) Signature {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for _, v := range vs {
0000000000000000000000000000000000000000;;			s += getSignature(reflect.TypeOf(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Signature{s}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureOfType returns the signature of the given type. It panics if the
0000000000000000000000000000000000000000;;	// type is not representable in D-Bus.
0000000000000000000000000000000000000000;;	func SignatureOfType(t reflect.Type) Signature {
0000000000000000000000000000000000000000;;		return Signature{getSignature(t)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSignature returns the signature of the given type and panics on unknown types.
0000000000000000000000000000000000000000;;	func getSignature(t reflect.Type) string {
0000000000000000000000000000000000000000;;		// handle simple types first
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Uint8:
0000000000000000000000000000000000000000;;			return "y"
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return "b"
0000000000000000000000000000000000000000;;		case reflect.Int16:
0000000000000000000000000000000000000000;;			return "n"
0000000000000000000000000000000000000000;;		case reflect.Uint16:
0000000000000000000000000000000000000000;;			return "q"
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			if t == unixFDType {
0000000000000000000000000000000000000000;;				return "h"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "i"
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			if t == unixFDIndexType {
0000000000000000000000000000000000000000;;				return "h"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "u"
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			return "x"
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			return "t"
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			return "d"
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return getSignature(t.Elem())
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if t == objectPathType {
0000000000000000000000000000000000000000;;				return "o"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "s"
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if t == variantType {
0000000000000000000000000000000000000000;;				return "v"
0000000000000000000000000000000000000000;;			} else if t == signatureType {
0000000000000000000000000000000000000000;;				return "g"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var s string
0000000000000000000000000000000000000000;;			for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;				field := t.Field(i)
0000000000000000000000000000000000000000;;				if field.PkgPath == "" && field.Tag.Get("dbus") != "-" {
0000000000000000000000000000000000000000;;					s += getSignature(t.Field(i).Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "(" + s + ")"
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Slice:
0000000000000000000000000000000000000000;;			return "a" + getSignature(t.Elem())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if !isKeyType(t.Key()) {
0000000000000000000000000000000000000000;;				panic(InvalidTypeError{t})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "a{" + getSignature(t.Key()) + getSignature(t.Elem()) + "}"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(InvalidTypeError{t})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSignature returns the signature represented by this string, or a
0000000000000000000000000000000000000000;;	// SignatureError if the string is not a valid signature.
0000000000000000000000000000000000000000;;	func ParseSignature(s string) (sig Signature, err error) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) > 255 {
0000000000000000000000000000000000000000;;			return Signature{""}, SignatureError{s, "too long"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sig.str = s
0000000000000000000000000000000000000000;;		for err == nil && len(s) != 0 {
0000000000000000000000000000000000000000;;			err, s = validSingle(s, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			sig = Signature{""}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSignatureMust behaves like ParseSignature, except that it panics if s
0000000000000000000000000000000000000000;;	// is not valid.
0000000000000000000000000000000000000000;;	func ParseSignatureMust(s string) Signature {
0000000000000000000000000000000000000000;;		sig, err := ParseSignature(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty retruns whether the signature is the empty signature.
0000000000000000000000000000000000000000;;	func (s Signature) Empty() bool {
0000000000000000000000000000000000000000;;		return s.str == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Single returns whether the signature represents a single, complete type.
0000000000000000000000000000000000000000;;	func (s Signature) Single() bool {
0000000000000000000000000000000000000000;;		err, r := validSingle(s.str, 0)
0000000000000000000000000000000000000000;;		return err != nil && r == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the signature's string representation.
0000000000000000000000000000000000000000;;	func (s Signature) String() string {
0000000000000000000000000000000000000000;;		return s.str
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SignatureError indicates that a signature passed to a function or received
0000000000000000000000000000000000000000;;	// on a connection is not a valid signature.
0000000000000000000000000000000000000000;;	type SignatureError struct {
0000000000000000000000000000000000000000;;		Sig    string
0000000000000000000000000000000000000000;;		Reason string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e SignatureError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("dbus: invalid signature: %q (%s)", e.Sig, e.Reason)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Try to read a single type from this string. If it was successfull, err is nil
0000000000000000000000000000000000000000;;	// and rem is the remaining unparsed part. Otherwise, err is a non-nil
0000000000000000000000000000000000000000;;	// SignatureError and rem is "". depth is the current recursion depth which may
0000000000000000000000000000000000000000;;	// not be greater than 64 and should be given as 0 on the first call.
0000000000000000000000000000000000000000;;	func validSingle(s string, depth int) (err error, rem string) {
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return SignatureError{Sig: s, Reason: "empty signature"}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if depth > 64 {
0000000000000000000000000000000000000000;;			return SignatureError{Sig: s, Reason: "container nesting too deep"}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch s[0] {
0000000000000000000000000000000000000000;;		case 'y', 'b', 'n', 'q', 'i', 'u', 'x', 't', 'd', 's', 'g', 'o', 'v', 'h':
0000000000000000000000000000000000000000;;			return nil, s[1:]
0000000000000000000000000000000000000000;;		case 'a':
0000000000000000000000000000000000000000;;			if len(s) > 1 && s[1] == '{' {
0000000000000000000000000000000000000000;;				i := findMatching(s[1:], '{', '}')
0000000000000000000000000000000000000000;;				if i == -1 {
0000000000000000000000000000000000000000;;					return SignatureError{Sig: s, Reason: "unmatched '{'"}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				rem = s[i+1:]
0000000000000000000000000000000000000000;;				s = s[2:i]
0000000000000000000000000000000000000000;;				if err, _ = validSingle(s[:1], depth+1); err != nil {
0000000000000000000000000000000000000000;;					return err, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err, nr := validSingle(s[1:], depth+1)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if nr != "" {
0000000000000000000000000000000000000000;;					return SignatureError{Sig: s, Reason: "too many types in dict"}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, rem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return validSingle(s[1:], depth+1)
0000000000000000000000000000000000000000;;		case '(':
0000000000000000000000000000000000000000;;			i := findMatching(s, '(', ')')
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				return SignatureError{Sig: s, Reason: "unmatched ')'"}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rem = s[i+1:]
0000000000000000000000000000000000000000;;			s = s[1:i]
0000000000000000000000000000000000000000;;			for err == nil && s != "" {
0000000000000000000000000000000000000000;;				err, s = validSingle(s, depth+1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				rem = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return SignatureError{Sig: s, Reason: "invalid type character"}, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findMatching(s string, left, right rune) int {
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		for i, v := range s {
0000000000000000000000000000000000000000;;			if v == left {
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			} else if v == right {
0000000000000000000000000000000000000000;;				n--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeFor returns the type of the given signature. It ignores any left over
0000000000000000000000000000000000000000;;	// characters and panics if s doesn't start with a valid type signature.
0000000000000000000000000000000000000000;;	func typeFor(s string) (t reflect.Type) {
0000000000000000000000000000000000000000;;		err, _ := validSingle(s, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t, ok := sigToType[s[0]]; ok {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch s[0] {
0000000000000000000000000000000000000000;;		case 'a':
0000000000000000000000000000000000000000;;			if s[1] == '{' {
0000000000000000000000000000000000000000;;				i := strings.LastIndex(s, "}")
0000000000000000000000000000000000000000;;				t = reflect.MapOf(sigToType[s[2]], typeFor(s[3:i]))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t = reflect.SliceOf(typeFor(s[1:]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case '(':
0000000000000000000000000000000000000000;;			t = interfacesType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
