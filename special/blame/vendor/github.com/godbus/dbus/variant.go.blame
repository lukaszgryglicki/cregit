0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/variant.go[Godeps/_workspace/src/github.com/godbus/dbus/variant.go][vendor/github.com/godbus/dbus/variant.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variant represents the D-Bus variant type.
0000000000000000000000000000000000000000;;	type Variant struct {
0000000000000000000000000000000000000000;;		sig   Signature
0000000000000000000000000000000000000000;;		value interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeVariant converts the given value to a Variant. It panics if v cannot be
0000000000000000000000000000000000000000;;	// represented as a D-Bus type.
0000000000000000000000000000000000000000;;	func MakeVariant(v interface{}) Variant {
0000000000000000000000000000000000000000;;		return Variant{SignatureOf(v), v}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseVariant parses the given string as a variant as described at
0000000000000000000000000000000000000000;;	// https://developer.gnome.org/glib/unstable/gvariant-text.html. If sig is not
0000000000000000000000000000000000000000;;	// empty, it is taken to be the expected signature for the variant.
0000000000000000000000000000000000000000;;	func ParseVariant(s string, sig Signature) (Variant, error) {
0000000000000000000000000000000000000000;;		tokens := varLex(s)
0000000000000000000000000000000000000000;;		p := &varParser{tokens: tokens}
0000000000000000000000000000000000000000;;		n, err := varMakeNode(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Variant{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sig.str == "" {
0000000000000000000000000000000000000000;;			sig, err = varInfer(n)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return Variant{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := n.Value(sig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Variant{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return MakeVariant(v), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// format returns a formatted version of v and whether this string can be parsed
0000000000000000000000000000000000000000;;	// unambigously.
0000000000000000000000000000000000000000;;	func (v Variant) format() (string, bool) {
0000000000000000000000000000000000000000;;		switch v.sig.str[0] {
0000000000000000000000000000000000000000;;		case 'b', 'i':
0000000000000000000000000000000000000000;;			return fmt.Sprint(v.value), true
0000000000000000000000000000000000000000;;		case 'n', 'q', 'u', 'x', 't', 'd', 'h':
0000000000000000000000000000000000000000;;			return fmt.Sprint(v.value), false
0000000000000000000000000000000000000000;;		case 's':
0000000000000000000000000000000000000000;;			return strconv.Quote(v.value.(string)), true
0000000000000000000000000000000000000000;;		case 'o':
0000000000000000000000000000000000000000;;			return strconv.Quote(string(v.value.(ObjectPath))), false
0000000000000000000000000000000000000000;;		case 'g':
0000000000000000000000000000000000000000;;			return strconv.Quote(v.value.(Signature).str), false
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			s, unamb := v.value.(Variant).format()
0000000000000000000000000000000000000000;;			if !unamb {
0000000000000000000000000000000000000000;;				return "<@" + v.value.(Variant).sig.str + " " + s + ">", true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "<" + s + ">", true
0000000000000000000000000000000000000000;;		case 'y':
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%#x", v.value.(byte)), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(v.value)
0000000000000000000000000000000000000000;;		switch rv.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if rv.Len() == 0 {
0000000000000000000000000000000000000000;;				return "[]", false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unamb := true
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer([]byte("["))
0000000000000000000000000000000000000000;;			for i := 0; i < rv.Len(); i++ {
0000000000000000000000000000000000000000;;				// TODO: slooow
0000000000000000000000000000000000000000;;				s, b := MakeVariant(rv.Index(i).Interface()).format()
0000000000000000000000000000000000000000;;				unamb = unamb && b
0000000000000000000000000000000000000000;;				buf.WriteString(s)
0000000000000000000000000000000000000000;;				if i != rv.Len()-1 {
0000000000000000000000000000000000000000;;					buf.WriteString(", ")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteByte(']')
0000000000000000000000000000000000000000;;			return buf.String(), unamb
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if rv.Len() == 0 {
0000000000000000000000000000000000000000;;				return "{}", false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unamb := true
0000000000000000000000000000000000000000;;			var buf bytes.Buffer
0000000000000000000000000000000000000000;;			kvs := make([]string, rv.Len())
0000000000000000000000000000000000000000;;			for i, k := range rv.MapKeys() {
0000000000000000000000000000000000000000;;				s, b := MakeVariant(k.Interface()).format()
0000000000000000000000000000000000000000;;				unamb = unamb && b
0000000000000000000000000000000000000000;;				buf.Reset()
0000000000000000000000000000000000000000;;				buf.WriteString(s)
0000000000000000000000000000000000000000;;				buf.WriteString(": ")
0000000000000000000000000000000000000000;;				s, b = MakeVariant(rv.MapIndex(k).Interface()).format()
0000000000000000000000000000000000000000;;				unamb = unamb && b
0000000000000000000000000000000000000000;;				buf.WriteString(s)
0000000000000000000000000000000000000000;;				kvs[i] = buf.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.Reset()
0000000000000000000000000000000000000000;;			buf.WriteByte('{')
0000000000000000000000000000000000000000;;			sort.Strings(kvs)
0000000000000000000000000000000000000000;;			for i, kv := range kvs {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					buf.WriteString(", ")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(kv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteByte('}')
0000000000000000000000000000000000000000;;			return buf.String(), unamb
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return `"INVALID"`, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signature returns the D-Bus signature of the underlying value of v.
0000000000000000000000000000000000000000;;	func (v Variant) Signature() Signature {
0000000000000000000000000000000000000000;;		return v.sig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the underlying value of v as
0000000000000000000000000000000000000000;;	// described at https://developer.gnome.org/glib/unstable/gvariant-text.html.
0000000000000000000000000000000000000000;;	func (v Variant) String() string {
0000000000000000000000000000000000000000;;		s, unamb := v.format()
0000000000000000000000000000000000000000;;		if !unamb {
0000000000000000000000000000000000000000;;			return "@" + v.sig.str + " " + s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value returns the underlying value of v.
0000000000000000000000000000000000000000;;	func (v Variant) Value() interface{} {
0000000000000000000000000000000000000000;;		return v.value
0000000000000000000000000000000000000000;;	}
