0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/vendor/src/github.com/godbus/dbus/call.go[Godeps/_workspace/src/github.com/docker/libcontainer/vendor/src/github.com/godbus/dbus/call.go][vendor/github.com/godbus/dbus/object.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BusObject is the interface of a remote object on which methods can be
0000000000000000000000000000000000000000;;	// invoked.
0000000000000000000000000000000000000000;;	type BusObject interface {
0000000000000000000000000000000000000000;;		Call(method string, flags Flags, args ...interface{}) *Call
0000000000000000000000000000000000000000;;		Go(method string, flags Flags, ch chan *Call, args ...interface{}) *Call
0000000000000000000000000000000000000000;;		GetProperty(p string) (Variant, error)
0000000000000000000000000000000000000000;;		Destination() string
0000000000000000000000000000000000000000;;		Path() ObjectPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Object represents a remote object on which methods can be invoked.
0000000000000000000000000000000000000000;;	type Object struct {
0000000000000000000000000000000000000000;;		conn *Conn
0000000000000000000000000000000000000000;;		dest string
0000000000000000000000000000000000000000;;		path ObjectPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call calls a method with (*Object).Go and waits for its reply.
0000000000000000000000000000000000000000;;	func (o *Object) Call(method string, flags Flags, args ...interface{}) *Call {
0000000000000000000000000000000000000000;;		return <-o.Go(method, flags, make(chan *Call, 1), args...).Done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Go calls a method with the given arguments asynchronously. It returns a
0000000000000000000000000000000000000000;;	// Call structure representing this method call. The passed channel will
0000000000000000000000000000000000000000;;	// return the same value once the call is done. If ch is nil, a new channel
0000000000000000000000000000000000000000;;	// will be allocated. Otherwise, ch has to be buffered or Go will panic.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the flags include FlagNoReplyExpected, ch is ignored and a Call structure
0000000000000000000000000000000000000000;;	// is returned of which only the Err member is valid.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the method parameter contains a dot ('.'), the part before the last dot
0000000000000000000000000000000000000000;;	// specifies the interface on which the method is called.
0000000000000000000000000000000000000000;;	func (o *Object) Go(method string, flags Flags, ch chan *Call, args ...interface{}) *Call {
0000000000000000000000000000000000000000;;		iface := ""
0000000000000000000000000000000000000000;;		i := strings.LastIndex(method, ".")
0000000000000000000000000000000000000000;;		if i != -1 {
0000000000000000000000000000000000000000;;			iface = method[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		method = method[i+1:]
0000000000000000000000000000000000000000;;		msg := new(Message)
0000000000000000000000000000000000000000;;		msg.Type = TypeMethodCall
0000000000000000000000000000000000000000;;		msg.serial = o.conn.getSerial()
0000000000000000000000000000000000000000;;		msg.Flags = flags & (FlagNoAutoStart | FlagNoReplyExpected)
0000000000000000000000000000000000000000;;		msg.Headers = make(map[HeaderField]Variant)
0000000000000000000000000000000000000000;;		msg.Headers[FieldPath] = MakeVariant(o.path)
0000000000000000000000000000000000000000;;		msg.Headers[FieldDestination] = MakeVariant(o.dest)
0000000000000000000000000000000000000000;;		msg.Headers[FieldMember] = MakeVariant(method)
0000000000000000000000000000000000000000;;		if iface != "" {
0000000000000000000000000000000000000000;;			msg.Headers[FieldInterface] = MakeVariant(iface)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Body = args
0000000000000000000000000000000000000000;;		if len(args) > 0 {
0000000000000000000000000000000000000000;;			msg.Headers[FieldSignature] = MakeVariant(SignatureOf(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msg.Flags&FlagNoReplyExpected == 0 {
0000000000000000000000000000000000000000;;			if ch == nil {
0000000000000000000000000000000000000000;;				ch = make(chan *Call, 10)
0000000000000000000000000000000000000000;;			} else if cap(ch) == 0 {
0000000000000000000000000000000000000000;;				panic("dbus: unbuffered channel passed to (*Object).Go")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			call := &Call{
0000000000000000000000000000000000000000;;				Destination: o.dest,
0000000000000000000000000000000000000000;;				Path:        o.path,
0000000000000000000000000000000000000000;;				Method:      method,
0000000000000000000000000000000000000000;;				Args:        args,
0000000000000000000000000000000000000000;;				Done:        ch,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.conn.callsLck.Lock()
0000000000000000000000000000000000000000;;			o.conn.calls[msg.serial] = call
0000000000000000000000000000000000000000;;			o.conn.callsLck.Unlock()
0000000000000000000000000000000000000000;;			o.conn.outLck.RLock()
0000000000000000000000000000000000000000;;			if o.conn.closed {
0000000000000000000000000000000000000000;;				call.Err = ErrClosed
0000000000000000000000000000000000000000;;				call.Done <- call
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				o.conn.out <- msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;			return call
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.conn.outLck.RLock()
0000000000000000000000000000000000000000;;		defer o.conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;		if o.conn.closed {
0000000000000000000000000000000000000000;;			return &Call{Err: ErrClosed}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.conn.out <- msg
0000000000000000000000000000000000000000;;		return &Call{Err: nil}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetProperty calls org.freedesktop.DBus.Properties.GetProperty on the given
0000000000000000000000000000000000000000;;	// object. The property name must be given in interface.member notation.
0000000000000000000000000000000000000000;;	func (o *Object) GetProperty(p string) (Variant, error) {
0000000000000000000000000000000000000000;;		idx := strings.LastIndex(p, ".")
0000000000000000000000000000000000000000;;		if idx == -1 || idx+1 == len(p) {
0000000000000000000000000000000000000000;;			return Variant{}, errors.New("dbus: invalid property " + p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iface := p[:idx]
0000000000000000000000000000000000000000;;		prop := p[idx+1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := Variant{}
0000000000000000000000000000000000000000;;		err := o.Call("org.freedesktop.DBus.Properties.Get", 0, iface, prop).Store(&result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Variant{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Destination returns the destination that calls on o are sent to.
0000000000000000000000000000000000000000;;	func (o *Object) Destination() string {
0000000000000000000000000000000000000000;;		return o.dest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path returns the path that calls on o are sent to.
0000000000000000000000000000000000000000;;	func (o *Object) Path() ObjectPath {
0000000000000000000000000000000000000000;;		return o.path
0000000000000000000000000000000000000000;;	}
