0000000000000000000000000000000000000000;;	package dbus
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/export.go[Godeps/_workspace/src/github.com/godbus/dbus/export.go][vendor/github.com/godbus/dbus/export.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errmsgInvalidArg = Error{
0000000000000000000000000000000000000000;;			"org.freedesktop.DBus.Error.InvalidArgs",
0000000000000000000000000000000000000000;;			[]interface{}{"Invalid type / number of args"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errmsgNoObject = Error{
0000000000000000000000000000000000000000;;			"org.freedesktop.DBus.Error.NoSuchObject",
0000000000000000000000000000000000000000;;			[]interface{}{"No such object"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errmsgUnknownMethod = Error{
0000000000000000000000000000000000000000;;			"org.freedesktop.DBus.Error.UnknownMethod",
0000000000000000000000000000000000000000;;			[]interface{}{"Unknown / invalid method"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exportWithMapping represents an exported struct along with a method name
0000000000000000000000000000000000000000;;	// mapping to allow for exporting lower-case methods, etc.
0000000000000000000000000000000000000000;;	type exportWithMapping struct {
0000000000000000000000000000000000000000;;		export interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Method name mapping; key -> struct method, value -> dbus method.
0000000000000000000000000000000000000000;;		mapping map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether or not this export is for the entire subtree
0000000000000000000000000000000000000000;;		includeSubtree bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sender is a type which can be used in exported methods to receive the message
0000000000000000000000000000000000000000;;	// sender.
0000000000000000000000000000000000000000;;	type Sender string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func exportedMethod(export exportWithMapping, name string) reflect.Value {
0000000000000000000000000000000000000000;;		if export.export == nil {
0000000000000000000000000000000000000000;;			return reflect.Value{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If a mapping was included in the export, check the map to see if we
0000000000000000000000000000000000000000;;		// should be looking for a different method in the export.
0000000000000000000000000000000000000000;;		if export.mapping != nil {
0000000000000000000000000000000000000000;;			for key, value := range export.mapping {
0000000000000000000000000000000000000000;;				if value == name {
0000000000000000000000000000000000000000;;					name = key
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Catch the case where a method is aliased but the client is calling
0000000000000000000000000000000000000000;;				// the original, e.g. the "Foo" method was exported mapped to
0000000000000000000000000000000000000000;;				// "foo," and dbus client called the original "Foo."
0000000000000000000000000000000000000000;;				if key == name {
0000000000000000000000000000000000000000;;					return reflect.Value{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(export.export)
0000000000000000000000000000000000000000;;		m := value.MethodByName(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Catch the case of attempting to call an unexported method
0000000000000000000000000000000000000000;;		method, ok := value.Type().MethodByName(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !m.IsValid() || !ok || method.PkgPath != "" {
0000000000000000000000000000000000000000;;			return reflect.Value{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := m.Type()
0000000000000000000000000000000000000000;;		if t.NumOut() == 0 ||
0000000000000000000000000000000000000000;;			t.Out(t.NumOut()-1) != reflect.TypeOf(&errmsgInvalidArg) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return reflect.Value{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// searchHandlers will look through all registered handlers looking for one
0000000000000000000000000000000000000000;;	// to handle the given path. If a verbatim one isn't found, it will check for
0000000000000000000000000000000000000000;;	// a subtree registration for the path as well.
0000000000000000000000000000000000000000;;	func (conn *Conn) searchHandlers(path ObjectPath) (map[string]exportWithMapping, bool) {
0000000000000000000000000000000000000000;;		conn.handlersLck.RLock()
0000000000000000000000000000000000000000;;		defer conn.handlersLck.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handlers, ok := conn.handlers[path]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return handlers, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If handlers weren't found for this exact path, look for a matching subtree
0000000000000000000000000000000000000000;;		// registration
0000000000000000000000000000000000000000;;		handlers = make(map[string]exportWithMapping)
0000000000000000000000000000000000000000;;		path = path[:strings.LastIndex(string(path), "/")]
0000000000000000000000000000000000000000;;		for len(path) > 0 {
0000000000000000000000000000000000000000;;			var subtreeHandlers map[string]exportWithMapping
0000000000000000000000000000000000000000;;			subtreeHandlers, ok = conn.handlers[path]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				for iface, handler := range subtreeHandlers {
0000000000000000000000000000000000000000;;					// Only include this handler if it registered for the subtree
0000000000000000000000000000000000000000;;					if handler.includeSubtree {
0000000000000000000000000000000000000000;;						handlers[iface] = handler
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			path = path[:strings.LastIndex(string(path), "/")]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handlers, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleCall handles the given method call (i.e. looks if it's one of the
0000000000000000000000000000000000000000;;	// pre-implemented ones and searches for a corresponding handler if not).
0000000000000000000000000000000000000000;;	func (conn *Conn) handleCall(msg *Message) {
0000000000000000000000000000000000000000;;		name := msg.Headers[FieldMember].value.(string)
0000000000000000000000000000000000000000;;		path := msg.Headers[FieldPath].value.(ObjectPath)
0000000000000000000000000000000000000000;;		ifaceName, hasIface := msg.Headers[FieldInterface].value.(string)
0000000000000000000000000000000000000000;;		sender, hasSender := msg.Headers[FieldSender].value.(string)
0000000000000000000000000000000000000000;;		serial := msg.serial
0000000000000000000000000000000000000000;;		if ifaceName == "org.freedesktop.DBus.Peer" {
0000000000000000000000000000000000000000;;			switch name {
0000000000000000000000000000000000000000;;			case "Ping":
0000000000000000000000000000000000000000;;				conn.sendReply(sender, serial)
0000000000000000000000000000000000000000;;			case "GetMachineId":
0000000000000000000000000000000000000000;;				conn.sendReply(sender, serial, conn.uuid)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				conn.sendError(errmsgUnknownMethod, sender, serial)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			conn.sendError(errmsgUnknownMethod, sender, serial)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the exported handler (if any) for this path
0000000000000000000000000000000000000000;;		handlers, ok := conn.searchHandlers(path)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			conn.sendError(errmsgNoObject, sender, serial)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var m reflect.Value
0000000000000000000000000000000000000000;;		if hasIface {
0000000000000000000000000000000000000000;;			iface := handlers[ifaceName]
0000000000000000000000000000000000000000;;			m = exportedMethod(iface, name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, v := range handlers {
0000000000000000000000000000000000000000;;				m = exportedMethod(v, name)
0000000000000000000000000000000000000000;;				if m.IsValid() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !m.IsValid() {
0000000000000000000000000000000000000000;;			conn.sendError(errmsgUnknownMethod, sender, serial)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := m.Type()
0000000000000000000000000000000000000000;;		vs := msg.Body
0000000000000000000000000000000000000000;;		pointers := make([]interface{}, t.NumIn())
0000000000000000000000000000000000000000;;		decode := make([]interface{}, 0, len(vs))
0000000000000000000000000000000000000000;;		for i := 0; i < t.NumIn(); i++ {
0000000000000000000000000000000000000000;;			tp := t.In(i)
0000000000000000000000000000000000000000;;			val := reflect.New(tp)
0000000000000000000000000000000000000000;;			pointers[i] = val.Interface()
0000000000000000000000000000000000000000;;			if tp == reflect.TypeOf((*Sender)(nil)).Elem() {
0000000000000000000000000000000000000000;;				val.Elem().SetString(sender)
0000000000000000000000000000000000000000;;			} else if tp == reflect.TypeOf((*Message)(nil)).Elem() {
0000000000000000000000000000000000000000;;				val.Elem().Set(reflect.ValueOf(*msg))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				decode = append(decode, pointers[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(decode) != len(vs) {
0000000000000000000000000000000000000000;;			conn.sendError(errmsgInvalidArg, sender, serial)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Store(vs, decode...); err != nil {
0000000000000000000000000000000000000000;;			conn.sendError(errmsgInvalidArg, sender, serial)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extract parameters
0000000000000000000000000000000000000000;;		params := make([]reflect.Value, len(pointers))
0000000000000000000000000000000000000000;;		for i := 0; i < len(pointers); i++ {
0000000000000000000000000000000000000000;;			params[i] = reflect.ValueOf(pointers[i]).Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call method
0000000000000000000000000000000000000000;;		ret := m.Call(params)
0000000000000000000000000000000000000000;;		if em := ret[t.NumOut()-1].Interface().(*Error); em != nil {
0000000000000000000000000000000000000000;;			conn.sendError(*em, sender, serial)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if msg.Flags&FlagNoReplyExpected == 0 {
0000000000000000000000000000000000000000;;			reply := new(Message)
0000000000000000000000000000000000000000;;			reply.Type = TypeMethodReply
0000000000000000000000000000000000000000;;			reply.serial = conn.getSerial()
0000000000000000000000000000000000000000;;			reply.Headers = make(map[HeaderField]Variant)
0000000000000000000000000000000000000000;;			if hasSender {
0000000000000000000000000000000000000000;;				reply.Headers[FieldDestination] = msg.Headers[FieldSender]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reply.Headers[FieldReplySerial] = MakeVariant(msg.serial)
0000000000000000000000000000000000000000;;			reply.Body = make([]interface{}, len(ret)-1)
0000000000000000000000000000000000000000;;			for i := 0; i < len(ret)-1; i++ {
0000000000000000000000000000000000000000;;				reply.Body[i] = ret[i].Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ret) != 1 {
0000000000000000000000000000000000000000;;				reply.Headers[FieldSignature] = MakeVariant(SignatureOf(reply.Body...))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.outLck.RLock()
0000000000000000000000000000000000000000;;			if !conn.closed {
0000000000000000000000000000000000000000;;				conn.out <- reply
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Emit emits the given signal on the message bus. The name parameter must be
0000000000000000000000000000000000000000;;	// formatted as "interface.member", e.g., "org.freedesktop.DBus.NameLost".
0000000000000000000000000000000000000000;;	func (conn *Conn) Emit(path ObjectPath, name string, values ...interface{}) error {
0000000000000000000000000000000000000000;;		if !path.IsValid() {
0000000000000000000000000000000000000000;;			return errors.New("dbus: invalid object path")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := strings.LastIndex(name, ".")
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return errors.New("dbus: invalid method name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iface := name[:i]
0000000000000000000000000000000000000000;;		member := name[i+1:]
0000000000000000000000000000000000000000;;		if !isValidMember(member) {
0000000000000000000000000000000000000000;;			return errors.New("dbus: invalid method name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isValidInterface(iface) {
0000000000000000000000000000000000000000;;			return errors.New("dbus: invalid interface name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg := new(Message)
0000000000000000000000000000000000000000;;		msg.Type = TypeSignal
0000000000000000000000000000000000000000;;		msg.serial = conn.getSerial()
0000000000000000000000000000000000000000;;		msg.Headers = make(map[HeaderField]Variant)
0000000000000000000000000000000000000000;;		msg.Headers[FieldInterface] = MakeVariant(iface)
0000000000000000000000000000000000000000;;		msg.Headers[FieldMember] = MakeVariant(member)
0000000000000000000000000000000000000000;;		msg.Headers[FieldPath] = MakeVariant(path)
0000000000000000000000000000000000000000;;		msg.Body = values
0000000000000000000000000000000000000000;;		if len(values) > 0 {
0000000000000000000000000000000000000000;;			msg.Headers[FieldSignature] = MakeVariant(SignatureOf(values...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.outLck.RLock()
0000000000000000000000000000000000000000;;		defer conn.outLck.RUnlock()
0000000000000000000000000000000000000000;;		if conn.closed {
0000000000000000000000000000000000000000;;			return ErrClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.out <- msg
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Export registers the given value to be exported as an object on the
0000000000000000000000000000000000000000;;	// message bus.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a method call on the given path and interface is received, an exported
0000000000000000000000000000000000000000;;	// method with the same name is called with v as the receiver if the
0000000000000000000000000000000000000000;;	// parameters match and the last return value is of type *Error. If this
0000000000000000000000000000000000000000;;	// *Error is not nil, it is sent back to the caller as an error.
0000000000000000000000000000000000000000;;	// Otherwise, a method reply is sent with the other return values as its body.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Any parameters with the special type Sender are set to the sender of the
0000000000000000000000000000000000000000;;	// dbus message when the method is called. Parameters of this type do not
0000000000000000000000000000000000000000;;	// contribute to the dbus signature of the method (i.e. the method is exposed
0000000000000000000000000000000000000000;;	// as if the parameters of type Sender were not there).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Similarly, any parameters with the type Message are set to the raw message
0000000000000000000000000000000000000000;;	// received on the bus. Again, parameters of this type do not contribute to the
0000000000000000000000000000000000000000;;	// dbus signature of the method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Every method call is executed in a new goroutine, so the method may be called
0000000000000000000000000000000000000000;;	// in multiple goroutines at once.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Method calls on the interface org.freedesktop.DBus.Peer will be automatically
0000000000000000000000000000000000000000;;	// handled for every object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Passing nil as the first parameter will cause conn to cease handling calls on
0000000000000000000000000000000000000000;;	// the given combination of path and interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Export returns an error if path is not a valid path name.
0000000000000000000000000000000000000000;;	func (conn *Conn) Export(v interface{}, path ObjectPath, iface string) error {
0000000000000000000000000000000000000000;;		return conn.ExportWithMap(v, nil, path, iface)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExportWithMap works exactly like Export but provides the ability to remap
0000000000000000000000000000000000000000;;	// method names (e.g. export a lower-case method).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The keys in the map are the real method names (exported on the struct), and
0000000000000000000000000000000000000000;;	// the values are the method names to be exported on DBus.
0000000000000000000000000000000000000000;;	func (conn *Conn) ExportWithMap(v interface{}, mapping map[string]string, path ObjectPath, iface string) error {
0000000000000000000000000000000000000000;;		return conn.exportWithMap(v, mapping, path, iface, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExportSubtree works exactly like Export but registers the given value for
0000000000000000000000000000000000000000;;	// an entire subtree rather under the root path provided.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In order to make this useful, one parameter in each of the value's exported
0000000000000000000000000000000000000000;;	// methods should be a Message, in which case it will contain the raw message
0000000000000000000000000000000000000000;;	// (allowing one to get access to the path that caused the method to be called).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that more specific export paths take precedence over less specific. For
0000000000000000000000000000000000000000;;	// example, a method call using the ObjectPath /foo/bar/baz will call a method
0000000000000000000000000000000000000000;;	// exported on /foo/bar before a method exported on /foo.
0000000000000000000000000000000000000000;;	func (conn *Conn) ExportSubtree(v interface{}, path ObjectPath, iface string) error {
0000000000000000000000000000000000000000;;		return conn.ExportSubtreeWithMap(v, nil, path, iface)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExportSubtreeWithMap works exactly like ExportSubtree but provides the
0000000000000000000000000000000000000000;;	// ability to remap method names (e.g. export a lower-case method).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The keys in the map are the real method names (exported on the struct), and
0000000000000000000000000000000000000000;;	// the values are the method names to be exported on DBus.
0000000000000000000000000000000000000000;;	func (conn *Conn) ExportSubtreeWithMap(v interface{}, mapping map[string]string, path ObjectPath, iface string) error {
0000000000000000000000000000000000000000;;		return conn.exportWithMap(v, mapping, path, iface, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exportWithMap is the worker function for all exports/registrations.
0000000000000000000000000000000000000000;;	func (conn *Conn) exportWithMap(v interface{}, mapping map[string]string, path ObjectPath, iface string, includeSubtree bool) error {
0000000000000000000000000000000000000000;;		if !path.IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf(`dbus: Invalid path name: "%s"`, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn.handlersLck.Lock()
0000000000000000000000000000000000000000;;		defer conn.handlersLck.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove a previous export if the interface is nil
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			if _, ok := conn.handlers[path]; ok {
0000000000000000000000000000000000000000;;				delete(conn.handlers[path], iface)
0000000000000000000000000000000000000000;;				if len(conn.handlers[path]) == 0 {
0000000000000000000000000000000000000000;;					delete(conn.handlers, path)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If this is the first handler for this path, make a new map to hold all
0000000000000000000000000000000000000000;;		// handlers for this path.
0000000000000000000000000000000000000000;;		if _, ok := conn.handlers[path]; !ok {
0000000000000000000000000000000000000000;;			conn.handlers[path] = make(map[string]exportWithMapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finally, save this handler
0000000000000000000000000000000000000000;;		conn.handlers[path][iface] = exportWithMapping{export: v, mapping: mapping, includeSubtree: includeSubtree}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseName calls org.freedesktop.DBus.ReleaseName and awaits a response.
0000000000000000000000000000000000000000;;	func (conn *Conn) ReleaseName(name string) (ReleaseNameReply, error) {
0000000000000000000000000000000000000000;;		var r uint32
0000000000000000000000000000000000000000;;		err := conn.busObj.Call("org.freedesktop.DBus.ReleaseName", 0, name).Store(&r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ReleaseNameReply(r), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestName calls org.freedesktop.DBus.RequestName and awaits a response.
0000000000000000000000000000000000000000;;	func (conn *Conn) RequestName(name string, flags RequestNameFlags) (RequestNameReply, error) {
0000000000000000000000000000000000000000;;		var r uint32
0000000000000000000000000000000000000000;;		err := conn.busObj.Call("org.freedesktop.DBus.RequestName", 0, name, flags).Store(&r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RequestNameReply(r), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseNameReply is the reply to a ReleaseName call.
0000000000000000000000000000000000000000;;	type ReleaseNameReply uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ReleaseNameReplyReleased ReleaseNameReply = 1 + iota
0000000000000000000000000000000000000000;;		ReleaseNameReplyNonExistent
0000000000000000000000000000000000000000;;		ReleaseNameReplyNotOwner
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestNameFlags represents the possible flags for a RequestName call.
0000000000000000000000000000000000000000;;	type RequestNameFlags uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NameFlagAllowReplacement RequestNameFlags = 1 << iota
0000000000000000000000000000000000000000;;		NameFlagReplaceExisting
0000000000000000000000000000000000000000;;		NameFlagDoNotQueue
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestNameReply is the reply to a RequestName call.
0000000000000000000000000000000000000000;;	type RequestNameReply uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		RequestNameReplyPrimaryOwner RequestNameReply = 1 + iota
0000000000000000000000000000000000000000;;		RequestNameReplyInQueue
0000000000000000000000000000000000000000;;		RequestNameReplyExists
0000000000000000000000000000000000000000;;		RequestNameReplyAlreadyOwner
0000000000000000000000000000000000000000;;	)
