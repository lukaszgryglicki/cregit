0000000000000000000000000000000000000000;;	//+build !windows
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/godbus/dbus/transport_unix.go[Godeps/_workspace/src/github.com/godbus/dbus/transport_unix.go][vendor/github.com/godbus/dbus/transport_unix.go];	
0000000000000000000000000000000000000000;;	package dbus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type oobReader struct {
0000000000000000000000000000000000000000;;		conn *net.UnixConn
0000000000000000000000000000000000000000;;		oob  []byte
0000000000000000000000000000000000000000;;		buf  [4096]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *oobReader) Read(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, oobn, flags, _, err := o.conn.ReadMsgUnix(b, o.buf[:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flags&syscall.MSG_CTRUNC != 0 {
0000000000000000000000000000000000000000;;			return n, errors.New("dbus: control data truncated (too many fds received)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.oob = append(o.oob, o.buf[:oobn]...)
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unixTransport struct {
0000000000000000000000000000000000000000;;		*net.UnixConn
0000000000000000000000000000000000000000;;		hasUnixFDs bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newUnixTransport(keys string) (transport, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := new(unixTransport)
0000000000000000000000000000000000000000;;		abstract := getKey(keys, "abstract")
0000000000000000000000000000000000000000;;		path := getKey(keys, "path")
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case abstract == "" && path == "":
0000000000000000000000000000000000000000;;			return nil, errors.New("dbus: invalid address (neither path nor abstract set)")
0000000000000000000000000000000000000000;;		case abstract != "" && path == "":
0000000000000000000000000000000000000000;;			t.UnixConn, err = net.DialUnix("unix", nil, &net.UnixAddr{Name: "@" + abstract, Net: "unix"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		case abstract == "" && path != "":
0000000000000000000000000000000000000000;;			t.UnixConn, err = net.DialUnix("unix", nil, &net.UnixAddr{Name: path, Net: "unix"})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("dbus: invalid address (both path and abstract set)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		transports["unix"] = newUnixTransport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *unixTransport) EnableUnixFDs() {
0000000000000000000000000000000000000000;;		t.hasUnixFDs = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *unixTransport) ReadMessage() (*Message, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			blen, hlen uint32
0000000000000000000000000000000000000000;;			csheader   [16]byte
0000000000000000000000000000000000000000;;			headers    []header
0000000000000000000000000000000000000000;;			order      binary.ByteOrder
0000000000000000000000000000000000000000;;			unixfds    uint32
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// To be sure that all bytes of out-of-band data are read, we use a special
0000000000000000000000000000000000000000;;		// reader that uses ReadUnix on the underlying connection instead of Read
0000000000000000000000000000000000000000;;		// and gathers the out-of-band data in a buffer.
0000000000000000000000000000000000000000;;		rd := &oobReader{conn: t.UnixConn}
0000000000000000000000000000000000000000;;		// read the first 16 bytes (the part of the header that has a constant size),
0000000000000000000000000000000000000000;;		// from which we can figure out the length of the rest of the message
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rd, csheader[:]); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch csheader[0] {
0000000000000000000000000000000000000000;;		case 'l':
0000000000000000000000000000000000000000;;			order = binary.LittleEndian
0000000000000000000000000000000000000000;;		case 'B':
0000000000000000000000000000000000000000;;			order = binary.BigEndian
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, InvalidMessageError("invalid byte order")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// csheader[4:8] -> length of message body, csheader[12:16] -> length of
0000000000000000000000000000000000000000;;		// header fields (without alignment)
0000000000000000000000000000000000000000;;		binary.Read(bytes.NewBuffer(csheader[4:8]), order, &blen)
0000000000000000000000000000000000000000;;		binary.Read(bytes.NewBuffer(csheader[12:]), order, &hlen)
0000000000000000000000000000000000000000;;		if hlen%8 != 0 {
0000000000000000000000000000000000000000;;			hlen += 8 - (hlen % 8)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// decode headers and look for unix fds
0000000000000000000000000000000000000000;;		headerdata := make([]byte, hlen+4)
0000000000000000000000000000000000000000;;		copy(headerdata, csheader[12:])
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(t, headerdata[4:]); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dec := newDecoder(bytes.NewBuffer(headerdata), order)
0000000000000000000000000000000000000000;;		dec.pos = 12
0000000000000000000000000000000000000000;;		vs, err := dec.Decode(Signature{"a(yv)"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Store(vs, &headers)
0000000000000000000000000000000000000000;;		for _, v := range headers {
0000000000000000000000000000000000000000;;			if v.Field == byte(FieldUnixFDs) {
0000000000000000000000000000000000000000;;				unixfds, _ = v.Variant.value.(uint32)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		all := make([]byte, 16+hlen+blen)
0000000000000000000000000000000000000000;;		copy(all, csheader[:])
0000000000000000000000000000000000000000;;		copy(all[16:], headerdata[4:])
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rd, all[16+hlen:]); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unixfds != 0 {
0000000000000000000000000000000000000000;;			if !t.hasUnixFDs {
0000000000000000000000000000000000000000;;				return nil, errors.New("dbus: got unix fds on unsupported transport")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// read the fds from the OOB data
0000000000000000000000000000000000000000;;			scms, err := syscall.ParseSocketControlMessage(rd.oob)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(scms) != 1 {
0000000000000000000000000000000000000000;;				return nil, errors.New("dbus: received more than one socket control message")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fds, err := syscall.ParseUnixRights(&scms[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg, err := DecodeMessage(bytes.NewBuffer(all))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// substitute the values in the message body (which are indices for the
0000000000000000000000000000000000000000;;			// array receiver via OOB) with the actual values
0000000000000000000000000000000000000000;;			for i, v := range msg.Body {
0000000000000000000000000000000000000000;;				if j, ok := v.(UnixFDIndex); ok {
0000000000000000000000000000000000000000;;					if uint32(j) >= unixfds {
0000000000000000000000000000000000000000;;						return nil, InvalidMessageError("invalid index for unix fd")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					msg.Body[i] = UnixFD(fds[j])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return msg, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return DecodeMessage(bytes.NewBuffer(all))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *unixTransport) SendMessage(msg *Message) error {
0000000000000000000000000000000000000000;;		fds := make([]int, 0)
0000000000000000000000000000000000000000;;		for i, v := range msg.Body {
0000000000000000000000000000000000000000;;			if fd, ok := v.(UnixFD); ok {
0000000000000000000000000000000000000000;;				msg.Body[i] = UnixFDIndex(len(fds))
0000000000000000000000000000000000000000;;				fds = append(fds, int(fd))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(fds) != 0 {
0000000000000000000000000000000000000000;;			if !t.hasUnixFDs {
0000000000000000000000000000000000000000;;				return errors.New("dbus: unix fd passing not enabled")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Headers[FieldUnixFDs] = MakeVariant(uint32(len(fds)))
0000000000000000000000000000000000000000;;			oob := syscall.UnixRights(fds...)
0000000000000000000000000000000000000000;;			buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			msg.EncodeTo(buf, binary.LittleEndian)
0000000000000000000000000000000000000000;;			n, oobn, err := t.UnixConn.WriteMsgUnix(buf.Bytes(), oob, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n != buf.Len() || oobn != len(oob) {
0000000000000000000000000000000000000000;;				return io.ErrShortWrite
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err := msg.EncodeTo(t, binary.LittleEndian); err != nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *unixTransport) SupportsUnixFDs() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
