0000000000000000000000000000000000000000;;	// Copyright (C) 2013-2015 by Maxim Bublis <b@codemonkey.ru>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Permission is hereby granted, free of charge, to any person obtaining
0000000000000000000000000000000000000000;;	// a copy of this software and associated documentation files (the
0000000000000000000000000000000000000000;;	// "Software"), to deal in the Software without restriction, including
0000000000000000000000000000000000000000;;	// without limitation the rights to use, copy, modify, merge, publish,
0000000000000000000000000000000000000000;;	// distribute, sublicense, and/or sell copies of the Software, and to
0000000000000000000000000000000000000000;;	// permit persons to whom the Software is furnished to do so, subject to
0000000000000000000000000000000000000000;;	// the following conditions:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The above copyright notice and this permission notice shall be
0000000000000000000000000000000000000000;;	// included in all copies or substantial portions of the Software.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
0000000000000000000000000000000000000000;;	// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
0000000000000000000000000000000000000000;;	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
0000000000000000000000000000000000000000;;	// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
0000000000000000000000000000000000000000;;	// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
0000000000000000000000000000000000000000;;	// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
0000000000000000000000000000000000000000;;	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
91454efdcfe2d233cf3f75fc014b3bb9ac6e5ae7;;	
0000000000000000000000000000000000000000;;	// Package uuid provides implementation of Universally Unique Identifier (UUID).
0000000000000000000000000000000000000000;;	// Supported versions are 1, 3, 4 and 5 (as specified in RFC 4122) and
0000000000000000000000000000000000000000;;	// version 2 (as specified in DCE 1.1).
0000000000000000000000000000000000000000;;	package uuid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/md5"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"database/sql/driver"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UUID layout variants.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		VariantNCS = iota
0000000000000000000000000000000000000000;;		VariantRFC4122
0000000000000000000000000000000000000000;;		VariantMicrosoft
0000000000000000000000000000000000000000;;		VariantFuture
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UUID DCE domains.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DomainPerson = iota
0000000000000000000000000000000000000000;;		DomainGroup
0000000000000000000000000000000000000000;;		DomainOrg
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Difference in 100-nanosecond intervals between
0000000000000000000000000000000000000000;;	// UUID epoch (October 15, 1582) and Unix epoch (January 1, 1970).
0000000000000000000000000000000000000000;;	const epochStart = 122192928000000000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used in string method conversion
0000000000000000000000000000000000000000;;	const dash byte = '-'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UUID v1/v2 storage.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		storageMutex  sync.Mutex
0000000000000000000000000000000000000000;;		storageOnce   sync.Once
0000000000000000000000000000000000000000;;		epochFunc     = unixTimeFunc
0000000000000000000000000000000000000000;;		clockSequence uint16
0000000000000000000000000000000000000000;;		lastTime      uint64
0000000000000000000000000000000000000000;;		hardwareAddr  [6]byte
0000000000000000000000000000000000000000;;		posixUID      = uint32(os.Getuid())
0000000000000000000000000000000000000000;;		posixGID      = uint32(os.Getgid())
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String parse helpers.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		urnPrefix  = []byte("urn:uuid:")
0000000000000000000000000000000000000000;;		byteGroups = []int{8, 4, 4, 4, 12}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initClockSequence() {
0000000000000000000000000000000000000000;;		buf := make([]byte, 2)
0000000000000000000000000000000000000000;;		safeRandom(buf)
0000000000000000000000000000000000000000;;		clockSequence = binary.BigEndian.Uint16(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initHardwareAddr() {
0000000000000000000000000000000000000000;;		interfaces, err := net.Interfaces()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			for _, iface := range interfaces {
0000000000000000000000000000000000000000;;				if len(iface.HardwareAddr) >= 6 {
0000000000000000000000000000000000000000;;					copy(hardwareAddr[:], iface.HardwareAddr)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize hardwareAddr randomly in case
0000000000000000000000000000000000000000;;		// of real network interfaces absence
0000000000000000000000000000000000000000;;		safeRandom(hardwareAddr[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set multicast bit as recommended in RFC 4122
0000000000000000000000000000000000000000;;		hardwareAddr[0] |= 0x01
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initStorage() {
0000000000000000000000000000000000000000;;		initClockSequence()
0000000000000000000000000000000000000000;;		initHardwareAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func safeRandom(dest []byte) {
0000000000000000000000000000000000000000;;		if _, err := rand.Read(dest); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns difference in 100-nanosecond intervals between
0000000000000000000000000000000000000000;;	// UUID epoch (October 15, 1582) and current time.
0000000000000000000000000000000000000000;;	// This is default epoch calculation function.
0000000000000000000000000000000000000000;;	func unixTimeFunc() uint64 {
0000000000000000000000000000000000000000;;		return epochStart + uint64(time.Now().UnixNano()/100)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UUID representation compliant with specification
0000000000000000000000000000000000000000;;	// described in RFC 4122.
0000000000000000000000000000000000000000;;	type UUID [16]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NullUUID can be used with the standard sql package to represent a
0000000000000000000000000000000000000000;;	// UUID value that can be NULL in the database
0000000000000000000000000000000000000000;;	type NullUUID struct {
0000000000000000000000000000000000000000;;		UUID  UUID
0000000000000000000000000000000000000000;;		Valid bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The nil UUID is special form of UUID that is specified to have all
0000000000000000000000000000000000000000;;	// 128 bits set to zero.
0000000000000000000000000000000000000000;;	var Nil = UUID{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Predefined namespace UUIDs.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		NamespaceDNS, _  = FromString("6ba7b810-9dad-11d1-80b4-00c04fd430c8")
0000000000000000000000000000000000000000;;		NamespaceURL, _  = FromString("6ba7b811-9dad-11d1-80b4-00c04fd430c8")
0000000000000000000000000000000000000000;;		NamespaceOID, _  = FromString("6ba7b812-9dad-11d1-80b4-00c04fd430c8")
0000000000000000000000000000000000000000;;		NamespaceX500, _ = FromString("6ba7b814-9dad-11d1-80b4-00c04fd430c8")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// And returns result of binary AND of two UUIDs.
0000000000000000000000000000000000000000;;	func And(u1 UUID, u2 UUID) UUID {
0000000000000000000000000000000000000000;;		u := UUID{}
0000000000000000000000000000000000000000;;		for i := 0; i < 16; i++ {
0000000000000000000000000000000000000000;;			u[i] = u1[i] & u2[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Or returns result of binary OR of two UUIDs.
0000000000000000000000000000000000000000;;	func Or(u1 UUID, u2 UUID) UUID {
0000000000000000000000000000000000000000;;		u := UUID{}
0000000000000000000000000000000000000000;;		for i := 0; i < 16; i++ {
0000000000000000000000000000000000000000;;			u[i] = u1[i] | u2[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if u1 and u2 equals, otherwise returns false.
0000000000000000000000000000000000000000;;	func Equal(u1 UUID, u2 UUID) bool {
0000000000000000000000000000000000000000;;		return bytes.Equal(u1[:], u2[:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version returns algorithm version used to generate UUID.
0000000000000000000000000000000000000000;;	func (u UUID) Version() uint {
0000000000000000000000000000000000000000;;		return uint(u[6] >> 4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variant returns UUID layout variant.
0000000000000000000000000000000000000000;;	func (u UUID) Variant() uint {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case (u[8] & 0x80) == 0x00:
0000000000000000000000000000000000000000;;			return VariantNCS
0000000000000000000000000000000000000000;;		case (u[8]&0xc0)|0x80 == 0x80:
0000000000000000000000000000000000000000;;			return VariantRFC4122
0000000000000000000000000000000000000000;;		case (u[8]&0xe0)|0xc0 == 0xc0:
0000000000000000000000000000000000000000;;			return VariantMicrosoft
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return VariantFuture
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns bytes slice representation of UUID.
0000000000000000000000000000000000000000;;	func (u UUID) Bytes() []byte {
0000000000000000000000000000000000000000;;		return u[:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns canonical string representation of UUID:
0000000000000000000000000000000000000000;;	// xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
0000000000000000000000000000000000000000;;	func (u UUID) String() string {
0000000000000000000000000000000000000000;;		buf := make([]byte, 36)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hex.Encode(buf[0:8], u[0:4])
0000000000000000000000000000000000000000;;		buf[8] = dash
0000000000000000000000000000000000000000;;		hex.Encode(buf[9:13], u[4:6])
0000000000000000000000000000000000000000;;		buf[13] = dash
0000000000000000000000000000000000000000;;		hex.Encode(buf[14:18], u[6:8])
0000000000000000000000000000000000000000;;		buf[18] = dash
0000000000000000000000000000000000000000;;		hex.Encode(buf[19:23], u[8:10])
0000000000000000000000000000000000000000;;		buf[23] = dash
0000000000000000000000000000000000000000;;		hex.Encode(buf[24:], u[10:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetVersion sets version bits.
0000000000000000000000000000000000000000;;	func (u *UUID) SetVersion(v byte) {
0000000000000000000000000000000000000000;;		u[6] = (u[6] & 0x0f) | (v << 4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetVariant sets variant bits as described in RFC 4122.
0000000000000000000000000000000000000000;;	func (u *UUID) SetVariant() {
0000000000000000000000000000000000000000;;		u[8] = (u[8] & 0xbf) | 0x80
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalText implements the encoding.TextMarshaler interface.
0000000000000000000000000000000000000000;;	// The encoding is the same as returned by String.
0000000000000000000000000000000000000000;;	func (u UUID) MarshalText() (text []byte, err error) {
0000000000000000000000000000000000000000;;		text = []byte(u.String())
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText implements the encoding.TextUnmarshaler interface.
0000000000000000000000000000000000000000;;	// Following formats are supported:
0000000000000000000000000000000000000000;;	// "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
0000000000000000000000000000000000000000;;	// "{6ba7b810-9dad-11d1-80b4-00c04fd430c8}",
0000000000000000000000000000000000000000;;	// "urn:uuid:6ba7b810-9dad-11d1-80b4-00c04fd430c8"
0000000000000000000000000000000000000000;;	func (u *UUID) UnmarshalText(text []byte) (err error) {
0000000000000000000000000000000000000000;;		if len(text) < 32 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("uuid: UUID string too short: %s", text)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := text[:]
0000000000000000000000000000000000000000;;		braced := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bytes.Equal(t[:9], urnPrefix) {
0000000000000000000000000000000000000000;;			t = t[9:]
0000000000000000000000000000000000000000;;		} else if t[0] == '{' {
0000000000000000000000000000000000000000;;			braced = true
0000000000000000000000000000000000000000;;			t = t[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := u[:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, byteGroup := range byteGroups {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				if t[0] != '-' {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("uuid: invalid string format")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t = t[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(t) < byteGroup {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("uuid: UUID string too short: %s", text)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i == 4 && len(t) > byteGroup &&
0000000000000000000000000000000000000000;;				((braced && t[byteGroup] != '}') || len(t[byteGroup:]) > 1 || !braced) {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("uuid: UUID string too long: %s", text)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = hex.Decode(b[:byteGroup/2], t[:byteGroup])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t = t[byteGroup:]
0000000000000000000000000000000000000000;;			b = b[byteGroup/2:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalBinary implements the encoding.BinaryMarshaler interface.
0000000000000000000000000000000000000000;;	func (u UUID) MarshalBinary() (data []byte, err error) {
0000000000000000000000000000000000000000;;		data = u.Bytes()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.
0000000000000000000000000000000000000000;;	// It will return error if the slice isn't 16 bytes long.
0000000000000000000000000000000000000000;;	func (u *UUID) UnmarshalBinary(data []byte) (err error) {
0000000000000000000000000000000000000000;;		if len(data) != 16 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("uuid: UUID must be exactly 16 bytes long, got %d bytes", len(data))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(u[:], data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value implements the driver.Valuer interface.
0000000000000000000000000000000000000000;;	func (u UUID) Value() (driver.Value, error) {
0000000000000000000000000000000000000000;;		return u.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan implements the sql.Scanner interface.
0000000000000000000000000000000000000000;;	// A 16-byte slice is handled by UnmarshalBinary, while
0000000000000000000000000000000000000000;;	// a longer byte slice or a string is handled by UnmarshalText.
0000000000000000000000000000000000000000;;	func (u *UUID) Scan(src interface{}) error {
0000000000000000000000000000000000000000;;		switch src := src.(type) {
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			if len(src) == 16 {
0000000000000000000000000000000000000000;;				return u.UnmarshalBinary(src)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return u.UnmarshalText(src)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return u.UnmarshalText([]byte(src))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("uuid: cannot convert %T to UUID", src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value implements the driver.Valuer interface.
0000000000000000000000000000000000000000;;	func (u NullUUID) Value() (driver.Value, error) {
0000000000000000000000000000000000000000;;		if !u.Valid {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Delegate to UUID Value function
0000000000000000000000000000000000000000;;		return u.UUID.Value()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan implements the sql.Scanner interface.
0000000000000000000000000000000000000000;;	func (u *NullUUID) Scan(src interface{}) error {
0000000000000000000000000000000000000000;;		if src == nil {
0000000000000000000000000000000000000000;;			u.UUID, u.Valid = Nil, false
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delegate to UUID Scan function
0000000000000000000000000000000000000000;;		u.Valid = true
0000000000000000000000000000000000000000;;		return u.UUID.Scan(src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromBytes returns UUID converted from raw byte slice input.
0000000000000000000000000000000000000000;;	// It will return error if the slice isn't 16 bytes long.
0000000000000000000000000000000000000000;;	func FromBytes(input []byte) (u UUID, err error) {
0000000000000000000000000000000000000000;;		err = u.UnmarshalBinary(input)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromBytesOrNil returns UUID converted from raw byte slice input.
0000000000000000000000000000000000000000;;	// Same behavior as FromBytes, but returns a Nil UUID on error.
0000000000000000000000000000000000000000;;	func FromBytesOrNil(input []byte) UUID {
0000000000000000000000000000000000000000;;		uuid, err := FromBytes(input)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uuid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromString returns UUID parsed from string input.
0000000000000000000000000000000000000000;;	// Input is expected in a form accepted by UnmarshalText.
0000000000000000000000000000000000000000;;	func FromString(input string) (u UUID, err error) {
0000000000000000000000000000000000000000;;		err = u.UnmarshalText([]byte(input))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromStringOrNil returns UUID parsed from string input.
0000000000000000000000000000000000000000;;	// Same behavior as FromString, but returns a Nil UUID on error.
0000000000000000000000000000000000000000;;	func FromStringOrNil(input string) UUID {
0000000000000000000000000000000000000000;;		uuid, err := FromString(input)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uuid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns UUID v1/v2 storage state.
0000000000000000000000000000000000000000;;	// Returns epoch timestamp, clock sequence, and hardware address.
0000000000000000000000000000000000000000;;	func getStorage() (uint64, uint16, []byte) {
0000000000000000000000000000000000000000;;		storageOnce.Do(initStorage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageMutex.Lock()
0000000000000000000000000000000000000000;;		defer storageMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeNow := epochFunc()
0000000000000000000000000000000000000000;;		// Clock changed backwards since last UUID generation.
0000000000000000000000000000000000000000;;		// Should increase clock sequence.
0000000000000000000000000000000000000000;;		if timeNow <= lastTime {
0000000000000000000000000000000000000000;;			clockSequence++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lastTime = timeNow
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return timeNow, clockSequence, hardwareAddr[:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewV1 returns UUID based on current timestamp and MAC address.
0000000000000000000000000000000000000000;;	func NewV1() UUID {
0000000000000000000000000000000000000000;;		u := UUID{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeNow, clockSeq, hardwareAddr := getStorage()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(u[0:], uint32(timeNow))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(u[4:], uint16(timeNow>>32))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(u[6:], uint16(timeNow>>48))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(u[8:], clockSeq)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(u[10:], hardwareAddr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.SetVersion(1)
0000000000000000000000000000000000000000;;		u.SetVariant()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewV2 returns DCE Security UUID based on POSIX UID/GID.
0000000000000000000000000000000000000000;;	func NewV2(domain byte) UUID {
0000000000000000000000000000000000000000;;		u := UUID{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeNow, clockSeq, hardwareAddr := getStorage()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch domain {
0000000000000000000000000000000000000000;;		case DomainPerson:
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(u[0:], posixUID)
0000000000000000000000000000000000000000;;		case DomainGroup:
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(u[0:], posixGID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(u[4:], uint16(timeNow>>32))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(u[6:], uint16(timeNow>>48))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(u[8:], clockSeq)
0000000000000000000000000000000000000000;;		u[9] = domain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(u[10:], hardwareAddr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.SetVersion(2)
0000000000000000000000000000000000000000;;		u.SetVariant()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewV3 returns UUID based on MD5 hash of namespace UUID and name.
0000000000000000000000000000000000000000;;	func NewV3(ns UUID, name string) UUID {
0000000000000000000000000000000000000000;;		u := newFromHash(md5.New(), ns, name)
0000000000000000000000000000000000000000;;		u.SetVersion(3)
0000000000000000000000000000000000000000;;		u.SetVariant()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewV4 returns random generated UUID.
0000000000000000000000000000000000000000;;	func NewV4() UUID {
0000000000000000000000000000000000000000;;		u := UUID{}
0000000000000000000000000000000000000000;;		safeRandom(u[:])
0000000000000000000000000000000000000000;;		u.SetVersion(4)
0000000000000000000000000000000000000000;;		u.SetVariant()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewV5 returns UUID based on SHA-1 hash of namespace UUID and name.
0000000000000000000000000000000000000000;;	func NewV5(ns UUID, name string) UUID {
0000000000000000000000000000000000000000;;		u := newFromHash(sha1.New(), ns, name)
0000000000000000000000000000000000000000;;		u.SetVersion(5)
0000000000000000000000000000000000000000;;		u.SetVariant()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns UUID based on hashing of namespace UUID and name.
0000000000000000000000000000000000000000;;	func newFromHash(h hash.Hash, ns UUID, name string) UUID {
0000000000000000000000000000000000000000;;		u := UUID{}
0000000000000000000000000000000000000000;;		h.Write(ns[:])
0000000000000000000000000000000000000000;;		h.Write([]byte(name))
0000000000000000000000000000000000000000;;		copy(u[:], h.Sum(nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
