0000000000000000000000000000000000000000;;	package netlink
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/vishvananda/netlink/xfrm_state_linux.go[Godeps/_workspace/src/github.com/vishvananda/netlink/xfrm_state_linux.go][vendor/github.com/vishvananda/netlink/xfrm_state_linux.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink/nl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeStateAlgo(a *XfrmStateAlgo) []byte {
0000000000000000000000000000000000000000;;		algo := nl.XfrmAlgo{
0000000000000000000000000000000000000000;;			AlgKeyLen: uint32(len(a.Key) * 8),
0000000000000000000000000000000000000000;;			AlgKey:    a.Key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end := len(a.Name)
0000000000000000000000000000000000000000;;		if end > 64 {
0000000000000000000000000000000000000000;;			end = 64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(algo.AlgName[:end], a.Name)
0000000000000000000000000000000000000000;;		return algo.Serialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeStateAlgoAuth(a *XfrmStateAlgo) []byte {
0000000000000000000000000000000000000000;;		algo := nl.XfrmAlgoAuth{
0000000000000000000000000000000000000000;;			AlgKeyLen:   uint32(len(a.Key) * 8),
0000000000000000000000000000000000000000;;			AlgTruncLen: uint32(a.TruncateLen),
0000000000000000000000000000000000000000;;			AlgKey:      a.Key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end := len(a.Name)
0000000000000000000000000000000000000000;;		if end > 64 {
0000000000000000000000000000000000000000;;			end = 64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(algo.AlgName[:end], a.Name)
0000000000000000000000000000000000000000;;		return algo.Serialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// XfrmStateAdd will add an xfrm state to the system.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip xfrm state add $state`
0000000000000000000000000000000000000000;;	func XfrmStateAdd(state *XfrmState) error {
0000000000000000000000000000000000000000;;		// A state with spi 0 can't be deleted so don't allow it to be set
0000000000000000000000000000000000000000;;		if state.Spi == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Spi must be set when adding xfrm state.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(nl.XFRM_MSG_NEWSA, syscall.NLM_F_CREATE|syscall.NLM_F_EXCL|syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := &nl.XfrmUsersaInfo{}
0000000000000000000000000000000000000000;;		msg.Family = uint16(nl.GetIPFamily(state.Dst))
0000000000000000000000000000000000000000;;		msg.Id.Daddr.FromIP(state.Dst)
0000000000000000000000000000000000000000;;		msg.Saddr.FromIP(state.Src)
0000000000000000000000000000000000000000;;		msg.Id.Proto = uint8(state.Proto)
0000000000000000000000000000000000000000;;		msg.Mode = uint8(state.Mode)
0000000000000000000000000000000000000000;;		msg.Id.Spi = nl.Swap32(uint32(state.Spi))
0000000000000000000000000000000000000000;;		msg.Reqid = uint32(state.Reqid)
0000000000000000000000000000000000000000;;		msg.ReplayWindow = uint8(state.ReplayWindow)
0000000000000000000000000000000000000000;;		msg.Lft.SoftByteLimit = nl.XFRM_INF
0000000000000000000000000000000000000000;;		msg.Lft.HardByteLimit = nl.XFRM_INF
0000000000000000000000000000000000000000;;		msg.Lft.SoftPacketLimit = nl.XFRM_INF
0000000000000000000000000000000000000000;;		msg.Lft.HardPacketLimit = nl.XFRM_INF
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if state.Auth != nil {
0000000000000000000000000000000000000000;;			out := nl.NewRtAttr(nl.XFRMA_ALG_AUTH_TRUNC, writeStateAlgoAuth(state.Auth))
0000000000000000000000000000000000000000;;			req.AddData(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if state.Crypt != nil {
0000000000000000000000000000000000000000;;			out := nl.NewRtAttr(nl.XFRMA_ALG_CRYPT, writeStateAlgo(state.Crypt))
0000000000000000000000000000000000000000;;			req.AddData(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if state.Encap != nil {
0000000000000000000000000000000000000000;;			encapData := make([]byte, nl.SizeofXfrmEncapTmpl)
0000000000000000000000000000000000000000;;			encap := nl.DeserializeXfrmEncapTmpl(encapData)
0000000000000000000000000000000000000000;;			encap.EncapType = uint16(state.Encap.Type)
0000000000000000000000000000000000000000;;			encap.EncapSport = nl.Swap16(uint16(state.Encap.SrcPort))
0000000000000000000000000000000000000000;;			encap.EncapDport = nl.Swap16(uint16(state.Encap.DstPort))
0000000000000000000000000000000000000000;;			encap.EncapOa.FromIP(state.Encap.OriginalAddress)
0000000000000000000000000000000000000000;;			out := nl.NewRtAttr(nl.XFRMA_ENCAP, encapData)
0000000000000000000000000000000000000000;;			req.AddData(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_XFRM, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// XfrmStateDel will delete an xfrm state from the system. Note that
0000000000000000000000000000000000000000;;	// the Algos are ignored when matching the state to delete.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip xfrm state del $state`
0000000000000000000000000000000000000000;;	func XfrmStateDel(state *XfrmState) error {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(nl.XFRM_MSG_DELSA, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := &nl.XfrmUsersaId{}
0000000000000000000000000000000000000000;;		msg.Daddr.FromIP(state.Dst)
0000000000000000000000000000000000000000;;		msg.Family = uint16(nl.GetIPFamily(state.Dst))
0000000000000000000000000000000000000000;;		msg.Proto = uint8(state.Proto)
0000000000000000000000000000000000000000;;		msg.Spi = nl.Swap32(uint32(state.Spi))
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		saddr := nl.XfrmAddress{}
0000000000000000000000000000000000000000;;		saddr.FromIP(state.Src)
0000000000000000000000000000000000000000;;		srcdata := nl.NewRtAttr(nl.XFRMA_SRCADDR, saddr.Serialize())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.AddData(srcdata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_XFRM, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// XfrmStateList gets a list of xfrm states in the system.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip xfrm state show`.
0000000000000000000000000000000000000000;;	// The list can be filtered by ip family.
0000000000000000000000000000000000000000;;	func XfrmStateList(family int) ([]XfrmState, error) {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(nl.XFRM_MSG_GETSA, syscall.NLM_F_DUMP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(family)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs, err := req.Execute(syscall.NETLINK_XFRM, nl.XFRM_MSG_NEWSA)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res []XfrmState
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			msg := nl.DeserializeXfrmUsersaInfo(m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if family != FAMILY_ALL && family != int(msg.Family) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var state XfrmState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			state.Dst = msg.Id.Daddr.ToIP()
0000000000000000000000000000000000000000;;			state.Src = msg.Saddr.ToIP()
0000000000000000000000000000000000000000;;			state.Proto = Proto(msg.Id.Proto)
0000000000000000000000000000000000000000;;			state.Mode = Mode(msg.Mode)
0000000000000000000000000000000000000000;;			state.Spi = int(nl.Swap32(msg.Id.Spi))
0000000000000000000000000000000000000000;;			state.Reqid = int(msg.Reqid)
0000000000000000000000000000000000000000;;			state.ReplayWindow = int(msg.ReplayWindow)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attrs, err := nl.ParseRouteAttr(m[msg.Len():])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, attr := range attrs {
0000000000000000000000000000000000000000;;				switch attr.Attr.Type {
0000000000000000000000000000000000000000;;				case nl.XFRMA_ALG_AUTH, nl.XFRMA_ALG_CRYPT:
0000000000000000000000000000000000000000;;					var resAlgo *XfrmStateAlgo
0000000000000000000000000000000000000000;;					if attr.Attr.Type == nl.XFRMA_ALG_AUTH {
0000000000000000000000000000000000000000;;						if state.Auth == nil {
0000000000000000000000000000000000000000;;							state.Auth = new(XfrmStateAlgo)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						resAlgo = state.Auth
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						state.Crypt = new(XfrmStateAlgo)
0000000000000000000000000000000000000000;;						resAlgo = state.Crypt
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					algo := nl.DeserializeXfrmAlgo(attr.Value[:])
0000000000000000000000000000000000000000;;					(*resAlgo).Name = nl.BytesToString(algo.AlgName[:])
0000000000000000000000000000000000000000;;					(*resAlgo).Key = algo.AlgKey
0000000000000000000000000000000000000000;;				case nl.XFRMA_ALG_AUTH_TRUNC:
0000000000000000000000000000000000000000;;					if state.Auth == nil {
0000000000000000000000000000000000000000;;						state.Auth = new(XfrmStateAlgo)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					algo := nl.DeserializeXfrmAlgoAuth(attr.Value[:])
0000000000000000000000000000000000000000;;					state.Auth.Name = nl.BytesToString(algo.AlgName[:])
0000000000000000000000000000000000000000;;					state.Auth.Key = algo.AlgKey
0000000000000000000000000000000000000000;;					state.Auth.TruncateLen = int(algo.AlgTruncLen)
0000000000000000000000000000000000000000;;				case nl.XFRMA_ENCAP:
0000000000000000000000000000000000000000;;					encap := nl.DeserializeXfrmEncapTmpl(attr.Value[:])
0000000000000000000000000000000000000000;;					state.Encap = new(XfrmStateEncap)
0000000000000000000000000000000000000000;;					state.Encap.Type = EncapType(encap.EncapType)
0000000000000000000000000000000000000000;;					state.Encap.SrcPort = int(nl.Swap16(encap.EncapSport))
0000000000000000000000000000000000000000;;					state.Encap.DstPort = int(nl.Swap16(encap.EncapDport))
0000000000000000000000000000000000000000;;					state.Encap.OriginalAddress = encap.EncapOa.ToIP()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res = append(res, state)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
