0000000000000000000000000000000000000000;;	package netlink
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/vishvananda/netlink/qdisc_linux.go[Godeps/_workspace/src/github.com/vishvananda/netlink/qdisc_linux.go][vendor/github.com/vishvananda/netlink/qdisc_linux.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink/nl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QdiscDel will delete a qdisc from the system.
0000000000000000000000000000000000000000;;	// Equivalent to: `tc qdisc del $qdisc`
0000000000000000000000000000000000000000;;	func QdiscDel(qdisc Qdisc) error {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_DELQDISC, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;		base := qdisc.Attrs()
0000000000000000000000000000000000000000;;		msg := &nl.TcMsg{
0000000000000000000000000000000000000000;;			Family:  nl.FAMILY_ALL,
0000000000000000000000000000000000000000;;			Ifindex: int32(base.LinkIndex),
0000000000000000000000000000000000000000;;			Handle:  base.Handle,
0000000000000000000000000000000000000000;;			Parent:  base.Parent,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QdiscAdd will add a qdisc to the system.
0000000000000000000000000000000000000000;;	// Equivalent to: `tc qdisc add $qdisc`
0000000000000000000000000000000000000000;;	func QdiscAdd(qdisc Qdisc) error {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_NEWQDISC, syscall.NLM_F_CREATE|syscall.NLM_F_EXCL|syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;		base := qdisc.Attrs()
0000000000000000000000000000000000000000;;		msg := &nl.TcMsg{
0000000000000000000000000000000000000000;;			Family:  nl.FAMILY_ALL,
0000000000000000000000000000000000000000;;			Ifindex: int32(base.LinkIndex),
0000000000000000000000000000000000000000;;			Handle:  base.Handle,
0000000000000000000000000000000000000000;;			Parent:  base.Parent,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;		req.AddData(nl.NewRtAttr(nl.TCA_KIND, nl.ZeroTerminated(qdisc.Type())))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := nl.NewRtAttr(nl.TCA_OPTIONS, nil)
0000000000000000000000000000000000000000;;		if prio, ok := qdisc.(*Prio); ok {
0000000000000000000000000000000000000000;;			tcmap := nl.TcPrioMap{
0000000000000000000000000000000000000000;;				Bands:   int32(prio.Bands),
0000000000000000000000000000000000000000;;				Priomap: prio.PriorityMap,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options = nl.NewRtAttr(nl.TCA_OPTIONS, tcmap.Serialize())
0000000000000000000000000000000000000000;;		} else if tbf, ok := qdisc.(*Tbf); ok {
0000000000000000000000000000000000000000;;			opt := nl.TcTbfQopt{}
0000000000000000000000000000000000000000;;			// TODO: handle rate > uint32
0000000000000000000000000000000000000000;;			opt.Rate.Rate = uint32(tbf.Rate)
0000000000000000000000000000000000000000;;			opt.Limit = tbf.Limit
0000000000000000000000000000000000000000;;			opt.Buffer = tbf.Buffer
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(options, nl.TCA_TBF_PARMS, opt.Serialize())
0000000000000000000000000000000000000000;;		} else if _, ok := qdisc.(*Ingress); ok {
0000000000000000000000000000000000000000;;			// ingress filters must use the proper handle
0000000000000000000000000000000000000000;;			if msg.Parent != HANDLE_INGRESS {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Ingress filters must set Parent to HANDLE_INGRESS")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.AddData(options)
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QdiscList gets a list of qdiscs in the system.
0000000000000000000000000000000000000000;;	// Equivalent to: `tc qdisc show`.
0000000000000000000000000000000000000000;;	// The list can be filtered by link.
0000000000000000000000000000000000000000;;	func QdiscList(link Link) ([]Qdisc, error) {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_GETQDISC, syscall.NLM_F_DUMP)
0000000000000000000000000000000000000000;;		index := int32(0)
0000000000000000000000000000000000000000;;		if link != nil {
0000000000000000000000000000000000000000;;			base := link.Attrs()
0000000000000000000000000000000000000000;;			ensureIndex(base)
0000000000000000000000000000000000000000;;			index = int32(base.Index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg := &nl.TcMsg{
0000000000000000000000000000000000000000;;			Family:  nl.FAMILY_ALL,
0000000000000000000000000000000000000000;;			Ifindex: index,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs, err := req.Execute(syscall.NETLINK_ROUTE, syscall.RTM_NEWQDISC)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res []Qdisc
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			msg := nl.DeserializeTcMsg(m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attrs, err := nl.ParseRouteAttr(m[msg.Len():])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// skip qdiscs from other interfaces
0000000000000000000000000000000000000000;;			if link != nil && msg.Ifindex != index {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			base := QdiscAttrs{
0000000000000000000000000000000000000000;;				LinkIndex: int(msg.Ifindex),
0000000000000000000000000000000000000000;;				Handle:    msg.Handle,
0000000000000000000000000000000000000000;;				Parent:    msg.Parent,
0000000000000000000000000000000000000000;;				Refcnt:    msg.Info,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var qdisc Qdisc
0000000000000000000000000000000000000000;;			qdiscType := ""
0000000000000000000000000000000000000000;;			for _, attr := range attrs {
0000000000000000000000000000000000000000;;				switch attr.Attr.Type {
0000000000000000000000000000000000000000;;				case nl.TCA_KIND:
0000000000000000000000000000000000000000;;					qdiscType = string(attr.Value[:len(attr.Value)-1])
0000000000000000000000000000000000000000;;					switch qdiscType {
0000000000000000000000000000000000000000;;					case "pfifo_fast":
0000000000000000000000000000000000000000;;						qdisc = &PfifoFast{}
0000000000000000000000000000000000000000;;					case "prio":
0000000000000000000000000000000000000000;;						qdisc = &Prio{}
0000000000000000000000000000000000000000;;					case "tbf":
0000000000000000000000000000000000000000;;						qdisc = &Tbf{}
0000000000000000000000000000000000000000;;					case "ingress":
0000000000000000000000000000000000000000;;						qdisc = &Ingress{}
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						qdisc = &GenericQdisc{QdiscType: qdiscType}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case nl.TCA_OPTIONS:
0000000000000000000000000000000000000000;;					switch qdiscType {
0000000000000000000000000000000000000000;;					case "pfifo_fast":
0000000000000000000000000000000000000000;;						// pfifo returns TcPrioMap directly without wrapping it in rtattr
0000000000000000000000000000000000000000;;						if err := parsePfifoFastData(qdisc, attr.Value); err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case "prio":
0000000000000000000000000000000000000000;;						// prio returns TcPrioMap directly without wrapping it in rtattr
0000000000000000000000000000000000000000;;						if err := parsePrioData(qdisc, attr.Value); err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case "tbf":
0000000000000000000000000000000000000000;;						data, err := nl.ParseRouteAttr(attr.Value)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := parseTbfData(qdisc, data); err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// no options for ingress
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*qdisc.Attrs() = base
0000000000000000000000000000000000000000;;			res = append(res, qdisc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePfifoFastData(qdisc Qdisc, value []byte) error {
0000000000000000000000000000000000000000;;		pfifo := qdisc.(*PfifoFast)
0000000000000000000000000000000000000000;;		tcmap := nl.DeserializeTcPrioMap(value)
0000000000000000000000000000000000000000;;		pfifo.PriorityMap = tcmap.Priomap
0000000000000000000000000000000000000000;;		pfifo.Bands = uint8(tcmap.Bands)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePrioData(qdisc Qdisc, value []byte) error {
0000000000000000000000000000000000000000;;		prio := qdisc.(*Prio)
0000000000000000000000000000000000000000;;		tcmap := nl.DeserializeTcPrioMap(value)
0000000000000000000000000000000000000000;;		prio.PriorityMap = tcmap.Priomap
0000000000000000000000000000000000000000;;		prio.Bands = uint8(tcmap.Bands)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseTbfData(qdisc Qdisc, data []syscall.NetlinkRouteAttr) error {
0000000000000000000000000000000000000000;;		native = nl.NativeEndian()
0000000000000000000000000000000000000000;;		tbf := qdisc.(*Tbf)
0000000000000000000000000000000000000000;;		for _, datum := range data {
0000000000000000000000000000000000000000;;			switch datum.Attr.Type {
0000000000000000000000000000000000000000;;			case nl.TCA_TBF_PARMS:
0000000000000000000000000000000000000000;;				opt := nl.DeserializeTcTbfQopt(datum.Value)
0000000000000000000000000000000000000000;;				tbf.Rate = uint64(opt.Rate.Rate)
0000000000000000000000000000000000000000;;				tbf.Limit = opt.Limit
0000000000000000000000000000000000000000;;				tbf.Buffer = opt.Buffer
0000000000000000000000000000000000000000;;			case nl.TCA_TBF_RATE64:
0000000000000000000000000000000000000000;;				tbf.Rate = native.Uint64(datum.Value[0:4])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TIME_UNITS_PER_SEC = 1000000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		tickInUsec  float64 = 0.0
0000000000000000000000000000000000000000;;		clockFactor float64 = 0.0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initClock() {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile("/proc/net/psched")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.Split(strings.TrimSpace(string(data)), " ")
0000000000000000000000000000000000000000;;		if len(parts) < 3 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var vals [3]uint64
0000000000000000000000000000000000000000;;		for i := range vals {
0000000000000000000000000000000000000000;;			val, err := strconv.ParseUint(parts[i], 16, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vals[i] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// compatibility
0000000000000000000000000000000000000000;;		if vals[2] == 1000000000 {
0000000000000000000000000000000000000000;;			vals[0] = vals[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clockFactor = float64(vals[2]) / TIME_UNITS_PER_SEC
0000000000000000000000000000000000000000;;		tickInUsec = float64(vals[0]) / float64(vals[1]) * clockFactor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TickInUsec() float64 {
0000000000000000000000000000000000000000;;		if tickInUsec == 0.0 {
0000000000000000000000000000000000000000;;			initClock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tickInUsec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ClockFactor() float64 {
0000000000000000000000000000000000000000;;		if clockFactor == 0.0 {
0000000000000000000000000000000000000000;;			initClock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clockFactor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func time2Tick(time uint32) uint32 {
0000000000000000000000000000000000000000;;		return uint32(float64(time) * TickInUsec())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tick2Time(tick uint32) uint32 {
0000000000000000000000000000000000000000;;		return uint32(float64(tick) / TickInUsec())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func time2Ktime(time uint32) uint32 {
0000000000000000000000000000000000000000;;		return uint32(float64(time) * ClockFactor())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ktime2Time(ktime uint32) uint32 {
0000000000000000000000000000000000000000;;		return uint32(float64(ktime) / ClockFactor())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func burst(rate uint64, buffer uint32) uint32 {
0000000000000000000000000000000000000000;;		return uint32(float64(rate) * float64(tick2Time(buffer)) / TIME_UNITS_PER_SEC)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func latency(rate uint64, limit, buffer uint32) float64 {
0000000000000000000000000000000000000000;;		return TIME_UNITS_PER_SEC*(float64(limit)/float64(rate)) - float64(tick2Time(buffer))
0000000000000000000000000000000000000000;;	}
