0000000000000000000000000000000000000000;;	// Package nl has low level primitives for making Netlink calls.
0000000000000000000000000000000000000000;;	package nl
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/vishvananda/netlink/nl/nl_linux.go[Godeps/_workspace/src/github.com/vishvananda/netlink/nl/nl_linux.go][vendor/github.com/vishvananda/netlink/nl/nl_linux.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Family type definitions
0000000000000000000000000000000000000000;;		FAMILY_ALL = syscall.AF_UNSPEC
0000000000000000000000000000000000000000;;		FAMILY_V4  = syscall.AF_INET
0000000000000000000000000000000000000000;;		FAMILY_V6  = syscall.AF_INET6
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nextSeqNr uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetIPFamily returns the family type of a net.IP.
0000000000000000000000000000000000000000;;	func GetIPFamily(ip net.IP) int {
0000000000000000000000000000000000000000;;		if len(ip) <= net.IPv4len {
0000000000000000000000000000000000000000;;			return FAMILY_V4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip.To4() != nil {
0000000000000000000000000000000000000000;;			return FAMILY_V4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FAMILY_V6
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nativeEndian binary.ByteOrder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get native endianness for the system
0000000000000000000000000000000000000000;;	func NativeEndian() binary.ByteOrder {
0000000000000000000000000000000000000000;;		if nativeEndian == nil {
0000000000000000000000000000000000000000;;			var x uint32 = 0x01020304
0000000000000000000000000000000000000000;;			if *(*byte)(unsafe.Pointer(&x)) == 0x01 {
0000000000000000000000000000000000000000;;				nativeEndian = binary.BigEndian
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				nativeEndian = binary.LittleEndian
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nativeEndian
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Byte swap a 16 bit value if we aren't big endian
0000000000000000000000000000000000000000;;	func Swap16(i uint16) uint16 {
0000000000000000000000000000000000000000;;		if NativeEndian() == binary.BigEndian {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (i&0xff00)>>8 | (i&0xff)<<8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Byte swap a 32 bit value if aren't big endian
0000000000000000000000000000000000000000;;	func Swap32(i uint32) uint32 {
0000000000000000000000000000000000000000;;		if NativeEndian() == binary.BigEndian {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (i&0xff000000)>>24 | (i&0xff0000)>>8 | (i&0xff00)<<8 | (i&0xff)<<24
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetlinkRequestData interface {
0000000000000000000000000000000000000000;;		Len() int
0000000000000000000000000000000000000000;;		Serialize() []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IfInfomsg is related to links, but it is used for list requests as well
0000000000000000000000000000000000000000;;	type IfInfomsg struct {
0000000000000000000000000000000000000000;;		syscall.IfInfomsg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create an IfInfomsg with family specified
0000000000000000000000000000000000000000;;	func NewIfInfomsg(family int) *IfInfomsg {
0000000000000000000000000000000000000000;;		return &IfInfomsg{
0000000000000000000000000000000000000000;;			IfInfomsg: syscall.IfInfomsg{
0000000000000000000000000000000000000000;;				Family: uint8(family),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeserializeIfInfomsg(b []byte) *IfInfomsg {
0000000000000000000000000000000000000000;;		return (*IfInfomsg)(unsafe.Pointer(&b[0:syscall.SizeofIfInfomsg][0]))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (msg *IfInfomsg) Serialize() []byte {
0000000000000000000000000000000000000000;;		return (*(*[syscall.SizeofIfInfomsg]byte)(unsafe.Pointer(msg)))[:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (msg *IfInfomsg) Len() int {
0000000000000000000000000000000000000000;;		return syscall.SizeofIfInfomsg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rtaAlignOf(attrlen int) int {
0000000000000000000000000000000000000000;;		return (attrlen + syscall.RTA_ALIGNTO - 1) & ^(syscall.RTA_ALIGNTO - 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewIfInfomsgChild(parent *RtAttr, family int) *IfInfomsg {
0000000000000000000000000000000000000000;;		msg := NewIfInfomsg(family)
0000000000000000000000000000000000000000;;		parent.children = append(parent.children, msg)
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extend RtAttr to handle data and children
0000000000000000000000000000000000000000;;	type RtAttr struct {
0000000000000000000000000000000000000000;;		syscall.RtAttr
0000000000000000000000000000000000000000;;		Data     []byte
0000000000000000000000000000000000000000;;		children []NetlinkRequestData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new Extended RtAttr object
0000000000000000000000000000000000000000;;	func NewRtAttr(attrType int, data []byte) *RtAttr {
0000000000000000000000000000000000000000;;		return &RtAttr{
0000000000000000000000000000000000000000;;			RtAttr: syscall.RtAttr{
0000000000000000000000000000000000000000;;				Type: uint16(attrType),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			children: []NetlinkRequestData{},
0000000000000000000000000000000000000000;;			Data:     data,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new RtAttr obj anc add it as a child of an existing object
0000000000000000000000000000000000000000;;	func NewRtAttrChild(parent *RtAttr, attrType int, data []byte) *RtAttr {
0000000000000000000000000000000000000000;;		attr := NewRtAttr(attrType, data)
0000000000000000000000000000000000000000;;		parent.children = append(parent.children, attr)
0000000000000000000000000000000000000000;;		return attr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *RtAttr) Len() int {
0000000000000000000000000000000000000000;;		if len(a.children) == 0 {
0000000000000000000000000000000000000000;;			return (syscall.SizeofRtAttr + len(a.Data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := 0
0000000000000000000000000000000000000000;;		for _, child := range a.children {
0000000000000000000000000000000000000000;;			l += rtaAlignOf(child.Len())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l += syscall.SizeofRtAttr
0000000000000000000000000000000000000000;;		return rtaAlignOf(l + len(a.Data))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serialize the RtAttr into a byte array
0000000000000000000000000000000000000000;;	// This can't just unsafe.cast because it must iterate through children.
0000000000000000000000000000000000000000;;	func (a *RtAttr) Serialize() []byte {
0000000000000000000000000000000000000000;;		native := NativeEndian()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		length := a.Len()
0000000000000000000000000000000000000000;;		buf := make([]byte, rtaAlignOf(length))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.Data != nil {
0000000000000000000000000000000000000000;;			copy(buf[4:], a.Data)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			next := 4
0000000000000000000000000000000000000000;;			for _, child := range a.children {
0000000000000000000000000000000000000000;;				childBuf := child.Serialize()
0000000000000000000000000000000000000000;;				copy(buf[next:], childBuf)
0000000000000000000000000000000000000000;;				next += rtaAlignOf(len(childBuf))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l := uint16(length); l != 0 {
0000000000000000000000000000000000000000;;			native.PutUint16(buf[0:2], l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		native.PutUint16(buf[2:4], a.Type)
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetlinkRequest struct {
0000000000000000000000000000000000000000;;		syscall.NlMsghdr
0000000000000000000000000000000000000000;;		Data []NetlinkRequestData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serialize the Netlink Request into a byte array
0000000000000000000000000000000000000000;;	func (req *NetlinkRequest) Serialize() []byte {
0000000000000000000000000000000000000000;;		length := syscall.SizeofNlMsghdr
0000000000000000000000000000000000000000;;		dataBytes := make([][]byte, len(req.Data))
0000000000000000000000000000000000000000;;		for i, data := range req.Data {
0000000000000000000000000000000000000000;;			dataBytes[i] = data.Serialize()
0000000000000000000000000000000000000000;;			length = length + len(dataBytes[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Len = uint32(length)
0000000000000000000000000000000000000000;;		b := make([]byte, length)
0000000000000000000000000000000000000000;;		hdr := (*(*[syscall.SizeofNlMsghdr]byte)(unsafe.Pointer(req)))[:]
0000000000000000000000000000000000000000;;		next := syscall.SizeofNlMsghdr
0000000000000000000000000000000000000000;;		copy(b[0:next], hdr)
0000000000000000000000000000000000000000;;		for _, data := range dataBytes {
0000000000000000000000000000000000000000;;			for _, dataByte := range data {
0000000000000000000000000000000000000000;;				b[next] = dataByte
0000000000000000000000000000000000000000;;				next = next + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (req *NetlinkRequest) AddData(data NetlinkRequestData) {
0000000000000000000000000000000000000000;;		if data != nil {
0000000000000000000000000000000000000000;;			req.Data = append(req.Data, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Execute the request against a the given sockType.
0000000000000000000000000000000000000000;;	// Returns a list of netlink messages in seriaized format, optionally filtered
0000000000000000000000000000000000000000;;	// by resType.
0000000000000000000000000000000000000000;;	func (req *NetlinkRequest) Execute(sockType int, resType uint16) ([][]byte, error) {
0000000000000000000000000000000000000000;;		s, err := getNetlinkSocket(sockType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.Send(req); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pid, err := s.GetPid()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res [][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	done:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			msgs, err := s.Receive()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, m := range msgs {
0000000000000000000000000000000000000000;;				if m.Header.Seq != req.Seq {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Wrong Seq nr %d, expected 1", m.Header.Seq)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if m.Header.Pid != pid {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Wrong pid %d, expected %d", m.Header.Pid, pid)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if m.Header.Type == syscall.NLMSG_DONE {
0000000000000000000000000000000000000000;;					break done
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if m.Header.Type == syscall.NLMSG_ERROR {
0000000000000000000000000000000000000000;;					native := NativeEndian()
0000000000000000000000000000000000000000;;					error := int32(native.Uint32(m.Data[0:4]))
0000000000000000000000000000000000000000;;					if error == 0 {
0000000000000000000000000000000000000000;;						break done
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil, syscall.Errno(-error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if resType != 0 && m.Header.Type != resType {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				res = append(res, m.Data)
0000000000000000000000000000000000000000;;				if m.Header.Flags&syscall.NLM_F_MULTI == 0 {
0000000000000000000000000000000000000000;;					break done
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new netlink request from proto and flags
0000000000000000000000000000000000000000;;	// Note the Len value will be inaccurate once data is added until
0000000000000000000000000000000000000000;;	// the message is serialized
0000000000000000000000000000000000000000;;	func NewNetlinkRequest(proto, flags int) *NetlinkRequest {
0000000000000000000000000000000000000000;;		return &NetlinkRequest{
0000000000000000000000000000000000000000;;			NlMsghdr: syscall.NlMsghdr{
0000000000000000000000000000000000000000;;				Len:   uint32(syscall.SizeofNlMsghdr),
0000000000000000000000000000000000000000;;				Type:  uint16(proto),
0000000000000000000000000000000000000000;;				Flags: syscall.NLM_F_REQUEST | uint16(flags),
0000000000000000000000000000000000000000;;				Seq:   atomic.AddUint32(&nextSeqNr, 1),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetlinkSocket struct {
0000000000000000000000000000000000000000;;		fd  int
0000000000000000000000000000000000000000;;		lsa syscall.SockaddrNetlink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNetlinkSocket(protocol int) (*NetlinkSocket, error) {
0000000000000000000000000000000000000000;;		fd, err := syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_RAW, protocol)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := &NetlinkSocket{
0000000000000000000000000000000000000000;;			fd: fd,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.lsa.Family = syscall.AF_NETLINK
0000000000000000000000000000000000000000;;		if err := syscall.Bind(fd, &s.lsa); err != nil {
0000000000000000000000000000000000000000;;			syscall.Close(fd)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a netlink socket with a given protocol (e.g. NETLINK_ROUTE)
0000000000000000000000000000000000000000;;	// and subscribe it to multicast groups passed in variable argument list.
0000000000000000000000000000000000000000;;	// Returns the netlink socket on which Receive() method can be called
0000000000000000000000000000000000000000;;	// to retrieve the messages from the kernel.
0000000000000000000000000000000000000000;;	func Subscribe(protocol int, groups ...uint) (*NetlinkSocket, error) {
0000000000000000000000000000000000000000;;		fd, err := syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_RAW, protocol)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := &NetlinkSocket{
0000000000000000000000000000000000000000;;			fd: fd,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.lsa.Family = syscall.AF_NETLINK
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, g := range groups {
0000000000000000000000000000000000000000;;			s.lsa.Groups |= (1 << (g - 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := syscall.Bind(fd, &s.lsa); err != nil {
0000000000000000000000000000000000000000;;			syscall.Close(fd)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *NetlinkSocket) Close() {
0000000000000000000000000000000000000000;;		syscall.Close(s.fd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *NetlinkSocket) Send(request *NetlinkRequest) error {
0000000000000000000000000000000000000000;;		if err := syscall.Sendto(s.fd, request.Serialize(), 0, &s.lsa); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *NetlinkSocket) Receive() ([]syscall.NetlinkMessage, error) {
0000000000000000000000000000000000000000;;		rb := make([]byte, syscall.Getpagesize())
0000000000000000000000000000000000000000;;		nr, _, err := syscall.Recvfrom(s.fd, rb, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nr < syscall.NLMSG_HDRLEN {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Got short response from netlink")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb = rb[:nr]
0000000000000000000000000000000000000000;;		return syscall.ParseNetlinkMessage(rb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *NetlinkSocket) GetPid() (uint32, error) {
0000000000000000000000000000000000000000;;		lsa, err := syscall.Getsockname(s.fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch v := lsa.(type) {
0000000000000000000000000000000000000000;;		case *syscall.SockaddrNetlink:
0000000000000000000000000000000000000000;;			return v.Pid, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("Wrong socket type")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ZeroTerminated(s string) []byte {
0000000000000000000000000000000000000000;;		bytes := make([]byte, len(s)+1)
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			bytes[i] = s[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bytes[len(s)] = 0
0000000000000000000000000000000000000000;;		return bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NonZeroTerminated(s string) []byte {
0000000000000000000000000000000000000000;;		bytes := make([]byte, len(s))
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			bytes[i] = s[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BytesToString(b []byte) string {
0000000000000000000000000000000000000000;;		n := bytes.Index(b, []byte{0})
0000000000000000000000000000000000000000;;		return string(b[:n])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Uint8Attr(v uint8) []byte {
0000000000000000000000000000000000000000;;		return []byte{byte(v)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Uint16Attr(v uint16) []byte {
0000000000000000000000000000000000000000;;		native := NativeEndian()
0000000000000000000000000000000000000000;;		bytes := make([]byte, 2)
0000000000000000000000000000000000000000;;		native.PutUint16(bytes, v)
0000000000000000000000000000000000000000;;		return bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Uint32Attr(v uint32) []byte {
0000000000000000000000000000000000000000;;		native := NativeEndian()
0000000000000000000000000000000000000000;;		bytes := make([]byte, 4)
0000000000000000000000000000000000000000;;		native.PutUint32(bytes, v)
0000000000000000000000000000000000000000;;		return bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseRouteAttr(b []byte) ([]syscall.NetlinkRouteAttr, error) {
0000000000000000000000000000000000000000;;		var attrs []syscall.NetlinkRouteAttr
0000000000000000000000000000000000000000;;		for len(b) >= syscall.SizeofRtAttr {
0000000000000000000000000000000000000000;;			a, vbuf, alen, err := netlinkRouteAttrAndValue(b)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ra := syscall.NetlinkRouteAttr{Attr: *a, Value: vbuf[:int(a.Len)-syscall.SizeofRtAttr]}
0000000000000000000000000000000000000000;;			attrs = append(attrs, ra)
0000000000000000000000000000000000000000;;			b = b[alen:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return attrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func netlinkRouteAttrAndValue(b []byte) (*syscall.RtAttr, []byte, int, error) {
0000000000000000000000000000000000000000;;		a := (*syscall.RtAttr)(unsafe.Pointer(&b[0]))
0000000000000000000000000000000000000000;;		if int(a.Len) < syscall.SizeofRtAttr || int(a.Len) > len(b) {
0000000000000000000000000000000000000000;;			return nil, nil, 0, syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a, b[syscall.SizeofRtAttr:], rtaAlignOf(int(a.Len)), nil
0000000000000000000000000000000000000000;;	}
