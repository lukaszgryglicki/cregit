0000000000000000000000000000000000000000;;	package netlink
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/vishvananda/netlink/link_linux.go[Godeps/_workspace/src/github.com/vishvananda/netlink/link_linux.go][vendor/github.com/vishvananda/netlink/link_linux.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink/nl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var native = nl.NativeEndian()
0000000000000000000000000000000000000000;;	var lookupByDump = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var macvlanModes = [...]uint32{
0000000000000000000000000000000000000000;;		0,
0000000000000000000000000000000000000000;;		nl.MACVLAN_MODE_PRIVATE,
0000000000000000000000000000000000000000;;		nl.MACVLAN_MODE_VEPA,
0000000000000000000000000000000000000000;;		nl.MACVLAN_MODE_BRIDGE,
0000000000000000000000000000000000000000;;		nl.MACVLAN_MODE_PASSTHRU,
0000000000000000000000000000000000000000;;		nl.MACVLAN_MODE_SOURCE,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureIndex(link *LinkAttrs) {
0000000000000000000000000000000000000000;;		if link != nil && link.Index == 0 {
0000000000000000000000000000000000000000;;			newlink, _ := LinkByName(link.Name)
0000000000000000000000000000000000000000;;			if newlink != nil {
0000000000000000000000000000000000000000;;				link.Index = newlink.Attrs().Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetUp enables the link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link up`
0000000000000000000000000000000000000000;;	func LinkSetUp(link Link) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_NEWLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Change = syscall.IFF_UP
0000000000000000000000000000000000000000;;		msg.Flags = syscall.IFF_UP
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetDown disables link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link down`
0000000000000000000000000000000000000000;;	func LinkSetDown(link Link) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_NEWLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Change = syscall.IFF_UP
0000000000000000000000000000000000000000;;		msg.Flags = 0 & ^syscall.IFF_UP
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetMTU sets the mtu of the link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link mtu $mtu`
0000000000000000000000000000000000000000;;	func LinkSetMTU(link Link, mtu int) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_SETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		native.PutUint32(b, uint32(mtu))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := nl.NewRtAttr(syscall.IFLA_MTU, b)
0000000000000000000000000000000000000000;;		req.AddData(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetName sets the name of the link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link name $name`
0000000000000000000000000000000000000000;;	func LinkSetName(link Link, name string) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_SETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := nl.NewRtAttr(syscall.IFLA_IFNAME, []byte(name))
0000000000000000000000000000000000000000;;		req.AddData(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetHardwareAddr sets the hardware address of the link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link address $hwaddr`
0000000000000000000000000000000000000000;;	func LinkSetHardwareAddr(link Link, hwaddr net.HardwareAddr) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_SETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := nl.NewRtAttr(syscall.IFLA_ADDRESS, []byte(hwaddr))
0000000000000000000000000000000000000000;;		req.AddData(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetMaster sets the master of the link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link master $master`
0000000000000000000000000000000000000000;;	func LinkSetMaster(link Link, master *Bridge) error {
0000000000000000000000000000000000000000;;		index := 0
0000000000000000000000000000000000000000;;		if master != nil {
0000000000000000000000000000000000000000;;			masterBase := master.Attrs()
0000000000000000000000000000000000000000;;			ensureIndex(masterBase)
0000000000000000000000000000000000000000;;			index = masterBase.Index
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return LinkSetMasterByIndex(link, index)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetMasterByIndex sets the master of the link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link master $master`
0000000000000000000000000000000000000000;;	func LinkSetMasterByIndex(link Link, masterIndex int) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_SETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		native.PutUint32(b, uint32(masterIndex))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := nl.NewRtAttr(syscall.IFLA_MASTER, b)
0000000000000000000000000000000000000000;;		req.AddData(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetNsPid puts the device into a new network namespace. The
0000000000000000000000000000000000000000;;	// pid must be a pid of a running process.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link set $link netns $pid`
0000000000000000000000000000000000000000;;	func LinkSetNsPid(link Link, nspid int) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_SETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		native.PutUint32(b, uint32(nspid))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := nl.NewRtAttr(syscall.IFLA_NET_NS_PID, b)
0000000000000000000000000000000000000000;;		req.AddData(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkSetNsFd puts the device into a new network namespace. The
0000000000000000000000000000000000000000;;	// fd must be an open file descriptor to a network namespace.
0000000000000000000000000000000000000000;;	// Similar to: `ip link set $link netns $ns`
0000000000000000000000000000000000000000;;	func LinkSetNsFd(link Link, fd int) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_SETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		native.PutUint32(b, uint32(fd))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := nl.NewRtAttr(nl.IFLA_NET_NS_FD, b)
0000000000000000000000000000000000000000;;		req.AddData(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func boolAttr(val bool) []byte {
0000000000000000000000000000000000000000;;		var v uint8
0000000000000000000000000000000000000000;;		if val {
0000000000000000000000000000000000000000;;			v = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nl.Uint8Attr(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type vxlanPortRange struct {
0000000000000000000000000000000000000000;;		Lo, Hi uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addVxlanAttrs(vxlan *Vxlan, linkInfo *nl.RtAttr) {
0000000000000000000000000000000000000000;;		data := nl.NewRtAttrChild(linkInfo, nl.IFLA_INFO_DATA, nil)
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_ID, nl.Uint32Attr(uint32(vxlan.VxlanId)))
0000000000000000000000000000000000000000;;		if vxlan.VtepDevIndex != 0 {
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VXLAN_LINK, nl.Uint32Attr(uint32(vxlan.VtepDevIndex)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vxlan.SrcAddr != nil {
0000000000000000000000000000000000000000;;			ip := vxlan.SrcAddr.To4()
0000000000000000000000000000000000000000;;			if ip != nil {
0000000000000000000000000000000000000000;;				nl.NewRtAttrChild(data, nl.IFLA_VXLAN_LOCAL, []byte(ip))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ip = vxlan.SrcAddr.To16()
0000000000000000000000000000000000000000;;				if ip != nil {
0000000000000000000000000000000000000000;;					nl.NewRtAttrChild(data, nl.IFLA_VXLAN_LOCAL6, []byte(ip))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vxlan.Group != nil {
0000000000000000000000000000000000000000;;			group := vxlan.Group.To4()
0000000000000000000000000000000000000000;;			if group != nil {
0000000000000000000000000000000000000000;;				nl.NewRtAttrChild(data, nl.IFLA_VXLAN_GROUP, []byte(group))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				group = vxlan.Group.To16()
0000000000000000000000000000000000000000;;				if group != nil {
0000000000000000000000000000000000000000;;					nl.NewRtAttrChild(data, nl.IFLA_VXLAN_GROUP6, []byte(group))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_TTL, nl.Uint8Attr(uint8(vxlan.TTL)))
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_TOS, nl.Uint8Attr(uint8(vxlan.TOS)))
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_LEARNING, boolAttr(vxlan.Learning))
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_PROXY, boolAttr(vxlan.Proxy))
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_RSC, boolAttr(vxlan.RSC))
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_L2MISS, boolAttr(vxlan.L2miss))
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(data, nl.IFLA_VXLAN_L3MISS, boolAttr(vxlan.L3miss))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vxlan.GBP {
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VXLAN_GBP, boolAttr(vxlan.GBP))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vxlan.NoAge {
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VXLAN_AGEING, nl.Uint32Attr(0))
0000000000000000000000000000000000000000;;		} else if vxlan.Age > 0 {
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VXLAN_AGEING, nl.Uint32Attr(uint32(vxlan.Age)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vxlan.Limit > 0 {
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VXLAN_LIMIT, nl.Uint32Attr(uint32(vxlan.Limit)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vxlan.Port > 0 {
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VXLAN_PORT, nl.Uint16Attr(uint16(vxlan.Port)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vxlan.PortLow > 0 || vxlan.PortHigh > 0 {
0000000000000000000000000000000000000000;;			pr := vxlanPortRange{uint16(vxlan.PortLow), uint16(vxlan.PortHigh)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			binary.Write(buf, binary.BigEndian, &pr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VXLAN_PORT_RANGE, buf.Bytes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkAdd adds a new link device. The type and features of the device
0000000000000000000000000000000000000000;;	// are taken fromt the parameters in the link object.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link add $link`
0000000000000000000000000000000000000000;;	func LinkAdd(link Link) error {
0000000000000000000000000000000000000000;;		// TODO: set mtu and hardware address
0000000000000000000000000000000000000000;;		// TODO: support extra data for macvlan
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if base.Name == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("LinkAttrs.Name cannot be empty!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_NEWLINK, syscall.NLM_F_CREATE|syscall.NLM_F_EXCL|syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if base.ParentIndex != 0 {
0000000000000000000000000000000000000000;;			b := make([]byte, 4)
0000000000000000000000000000000000000000;;			native.PutUint32(b, uint32(base.ParentIndex))
0000000000000000000000000000000000000000;;			data := nl.NewRtAttr(syscall.IFLA_LINK, b)
0000000000000000000000000000000000000000;;			req.AddData(data)
0000000000000000000000000000000000000000;;		} else if link.Type() == "ipvlan" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Can't create ipvlan link without ParentIndex")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameData := nl.NewRtAttr(syscall.IFLA_IFNAME, nl.ZeroTerminated(base.Name))
0000000000000000000000000000000000000000;;		req.AddData(nameData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if base.MTU > 0 {
0000000000000000000000000000000000000000;;			mtu := nl.NewRtAttr(syscall.IFLA_MTU, nl.Uint32Attr(uint32(base.MTU)))
0000000000000000000000000000000000000000;;			req.AddData(mtu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if base.TxQLen >= 0 {
0000000000000000000000000000000000000000;;			qlen := nl.NewRtAttr(syscall.IFLA_TXQLEN, nl.Uint32Attr(uint32(base.TxQLen)))
0000000000000000000000000000000000000000;;			req.AddData(qlen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if base.Namespace != nil {
0000000000000000000000000000000000000000;;			var attr *nl.RtAttr
0000000000000000000000000000000000000000;;			switch base.Namespace.(type) {
0000000000000000000000000000000000000000;;			case NsPid:
0000000000000000000000000000000000000000;;				val := nl.Uint32Attr(uint32(base.Namespace.(NsPid)))
0000000000000000000000000000000000000000;;				attr = nl.NewRtAttr(syscall.IFLA_NET_NS_PID, val)
0000000000000000000000000000000000000000;;			case NsFd:
0000000000000000000000000000000000000000;;				val := nl.Uint32Attr(uint32(base.Namespace.(NsFd)))
0000000000000000000000000000000000000000;;				attr = nl.NewRtAttr(nl.IFLA_NET_NS_FD, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			req.AddData(attr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		linkInfo := nl.NewRtAttr(syscall.IFLA_LINKINFO, nil)
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(linkInfo, nl.IFLA_INFO_KIND, nl.NonZeroTerminated(link.Type()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vlan, ok := link.(*Vlan); ok {
0000000000000000000000000000000000000000;;			b := make([]byte, 2)
0000000000000000000000000000000000000000;;			native.PutUint16(b, uint16(vlan.VlanId))
0000000000000000000000000000000000000000;;			data := nl.NewRtAttrChild(linkInfo, nl.IFLA_INFO_DATA, nil)
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_VLAN_ID, b)
0000000000000000000000000000000000000000;;		} else if veth, ok := link.(*Veth); ok {
0000000000000000000000000000000000000000;;			data := nl.NewRtAttrChild(linkInfo, nl.IFLA_INFO_DATA, nil)
0000000000000000000000000000000000000000;;			peer := nl.NewRtAttrChild(data, nl.VETH_INFO_PEER, nil)
0000000000000000000000000000000000000000;;			nl.NewIfInfomsgChild(peer, syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(peer, syscall.IFLA_IFNAME, nl.ZeroTerminated(veth.PeerName))
0000000000000000000000000000000000000000;;			if base.TxQLen >= 0 {
0000000000000000000000000000000000000000;;				nl.NewRtAttrChild(peer, syscall.IFLA_TXQLEN, nl.Uint32Attr(uint32(base.TxQLen)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if base.MTU > 0 {
0000000000000000000000000000000000000000;;				nl.NewRtAttrChild(peer, syscall.IFLA_MTU, nl.Uint32Attr(uint32(base.MTU)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else if vxlan, ok := link.(*Vxlan); ok {
0000000000000000000000000000000000000000;;			addVxlanAttrs(vxlan, linkInfo)
0000000000000000000000000000000000000000;;		} else if ipv, ok := link.(*IPVlan); ok {
0000000000000000000000000000000000000000;;			data := nl.NewRtAttrChild(linkInfo, nl.IFLA_INFO_DATA, nil)
0000000000000000000000000000000000000000;;			nl.NewRtAttrChild(data, nl.IFLA_IPVLAN_MODE, nl.Uint16Attr(uint16(ipv.Mode)))
0000000000000000000000000000000000000000;;		} else if macv, ok := link.(*Macvlan); ok {
0000000000000000000000000000000000000000;;			if macv.Mode != MACVLAN_MODE_DEFAULT {
0000000000000000000000000000000000000000;;				data := nl.NewRtAttrChild(linkInfo, nl.IFLA_INFO_DATA, nil)
0000000000000000000000000000000000000000;;				nl.NewRtAttrChild(data, nl.IFLA_MACVLAN_MODE, nl.Uint32Attr(macvlanModes[macv.Mode]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.AddData(linkInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// can't set master during create, so set it afterwards
0000000000000000000000000000000000000000;;		if base.MasterIndex != 0 {
0000000000000000000000000000000000000000;;			// TODO: verify MasterIndex is actually a bridge?
0000000000000000000000000000000000000000;;			return LinkSetMasterByIndex(link, base.MasterIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkDel deletes link device. Either Index or Name must be set in
0000000000000000000000000000000000000000;;	// the link object for it to be deleted. The other values are ignored.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link del $link`
0000000000000000000000000000000000000000;;	func LinkDel(link Link) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_DELLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func linkByNameDump(name string) (Link, error) {
0000000000000000000000000000000000000000;;		links, err := LinkList()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, link := range links {
0000000000000000000000000000000000000000;;			if link.Attrs().Name == name {
0000000000000000000000000000000000000000;;				return link, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Link %s not found", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkByName finds a link by name and returns a pointer to the object.
0000000000000000000000000000000000000000;;	func LinkByName(name string) (Link, error) {
0000000000000000000000000000000000000000;;		if lookupByDump {
0000000000000000000000000000000000000000;;			return linkByNameDump(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_GETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameData := nl.NewRtAttr(syscall.IFLA_IFNAME, nl.ZeroTerminated(name))
0000000000000000000000000000000000000000;;		req.AddData(nameData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		link, err := execGetLink(req)
0000000000000000000000000000000000000000;;		if err == syscall.EINVAL {
0000000000000000000000000000000000000000;;			// older kernels don't support looking up via IFLA_IFNAME
0000000000000000000000000000000000000000;;			// so fall back to dumping all links
0000000000000000000000000000000000000000;;			lookupByDump = true
0000000000000000000000000000000000000000;;			return linkByNameDump(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return link, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkByIndex finds a link by index and returns a pointer to the object.
0000000000000000000000000000000000000000;;	func LinkByIndex(index int) (Link, error) {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_GETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		msg.Index = int32(index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return execGetLink(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func execGetLink(req *nl.NetlinkRequest) (Link, error) {
0000000000000000000000000000000000000000;;		msgs, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if errno, ok := err.(syscall.Errno); ok {
0000000000000000000000000000000000000000;;				if errno == syscall.ENODEV {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Link not found")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(msgs) == 0:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Link not found")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case len(msgs) == 1:
0000000000000000000000000000000000000000;;			return linkDeserialize(msgs[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("More than one link found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// linkDeserialize deserializes a raw message received from netlink into
0000000000000000000000000000000000000000;;	// a link object.
0000000000000000000000000000000000000000;;	func linkDeserialize(m []byte) (Link, error) {
0000000000000000000000000000000000000000;;		msg := nl.DeserializeIfInfomsg(m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs, err := nl.ParseRouteAttr(m[msg.Len():])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		base := LinkAttrs{Index: int(msg.Index), Flags: linkFlags(msg.Flags)}
0000000000000000000000000000000000000000;;		var link Link
0000000000000000000000000000000000000000;;		linkType := ""
0000000000000000000000000000000000000000;;		for _, attr := range attrs {
0000000000000000000000000000000000000000;;			switch attr.Attr.Type {
0000000000000000000000000000000000000000;;			case syscall.IFLA_LINKINFO:
0000000000000000000000000000000000000000;;				infos, err := nl.ParseRouteAttr(attr.Value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, info := range infos {
0000000000000000000000000000000000000000;;					switch info.Attr.Type {
0000000000000000000000000000000000000000;;					case nl.IFLA_INFO_KIND:
0000000000000000000000000000000000000000;;						linkType = string(info.Value[:len(info.Value)-1])
0000000000000000000000000000000000000000;;						switch linkType {
0000000000000000000000000000000000000000;;						case "dummy":
0000000000000000000000000000000000000000;;							link = &Dummy{}
0000000000000000000000000000000000000000;;						case "ifb":
0000000000000000000000000000000000000000;;							link = &Ifb{}
0000000000000000000000000000000000000000;;						case "bridge":
0000000000000000000000000000000000000000;;							link = &Bridge{}
0000000000000000000000000000000000000000;;						case "vlan":
0000000000000000000000000000000000000000;;							link = &Vlan{}
0000000000000000000000000000000000000000;;						case "veth":
0000000000000000000000000000000000000000;;							link = &Veth{}
0000000000000000000000000000000000000000;;						case "vxlan":
0000000000000000000000000000000000000000;;							link = &Vxlan{}
0000000000000000000000000000000000000000;;						case "ipvlan":
0000000000000000000000000000000000000000;;							link = &IPVlan{}
0000000000000000000000000000000000000000;;						case "macvlan":
0000000000000000000000000000000000000000;;							link = &Macvlan{}
0000000000000000000000000000000000000000;;						case "macvtap":
0000000000000000000000000000000000000000;;							link = &Macvtap{}
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;							link = &GenericLink{LinkType: linkType}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case nl.IFLA_INFO_DATA:
0000000000000000000000000000000000000000;;						data, err := nl.ParseRouteAttr(info.Value)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						switch linkType {
0000000000000000000000000000000000000000;;						case "vlan":
0000000000000000000000000000000000000000;;							parseVlanData(link, data)
0000000000000000000000000000000000000000;;						case "vxlan":
0000000000000000000000000000000000000000;;							parseVxlanData(link, data)
0000000000000000000000000000000000000000;;						case "ipvlan":
0000000000000000000000000000000000000000;;							parseIPVlanData(link, data)
0000000000000000000000000000000000000000;;						case "macvlan":
0000000000000000000000000000000000000000;;							parseMacvlanData(link, data)
0000000000000000000000000000000000000000;;						case "macvtap":
0000000000000000000000000000000000000000;;							parseMacvtapData(link, data)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case syscall.IFLA_ADDRESS:
0000000000000000000000000000000000000000;;				var nonzero bool
0000000000000000000000000000000000000000;;				for _, b := range attr.Value {
0000000000000000000000000000000000000000;;					if b != 0 {
0000000000000000000000000000000000000000;;						nonzero = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if nonzero {
0000000000000000000000000000000000000000;;					base.HardwareAddr = attr.Value[:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case syscall.IFLA_IFNAME:
0000000000000000000000000000000000000000;;				base.Name = string(attr.Value[:len(attr.Value)-1])
0000000000000000000000000000000000000000;;			case syscall.IFLA_MTU:
0000000000000000000000000000000000000000;;				base.MTU = int(native.Uint32(attr.Value[0:4]))
0000000000000000000000000000000000000000;;			case syscall.IFLA_LINK:
0000000000000000000000000000000000000000;;				base.ParentIndex = int(native.Uint32(attr.Value[0:4]))
0000000000000000000000000000000000000000;;			case syscall.IFLA_MASTER:
0000000000000000000000000000000000000000;;				base.MasterIndex = int(native.Uint32(attr.Value[0:4]))
0000000000000000000000000000000000000000;;			case syscall.IFLA_TXQLEN:
0000000000000000000000000000000000000000;;				base.TxQLen = int(native.Uint32(attr.Value[0:4]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Links that don't have IFLA_INFO_KIND are hardware devices
0000000000000000000000000000000000000000;;		if link == nil {
0000000000000000000000000000000000000000;;			link = &Device{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*link.Attrs() = base
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return link, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkList gets a list of link devices.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip link show`
0000000000000000000000000000000000000000;;	func LinkList() ([]Link, error) {
0000000000000000000000000000000000000000;;		// NOTE(vish): This duplicates functionality in net/iface_linux.go, but we need
0000000000000000000000000000000000000000;;		//             to get the message ourselves to parse link type.
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_GETLINK, syscall.NLM_F_DUMP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs, err := req.Execute(syscall.NETLINK_ROUTE, syscall.RTM_NEWLINK)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res []Link
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			link, err := linkDeserialize(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res = append(res, link)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LinkSetHairpin(link Link, mode bool) error {
0000000000000000000000000000000000000000;;		return setProtinfoAttr(link, mode, nl.IFLA_BRPORT_MODE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LinkSetGuard(link Link, mode bool) error {
0000000000000000000000000000000000000000;;		return setProtinfoAttr(link, mode, nl.IFLA_BRPORT_GUARD)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LinkSetFastLeave(link Link, mode bool) error {
0000000000000000000000000000000000000000;;		return setProtinfoAttr(link, mode, nl.IFLA_BRPORT_FAST_LEAVE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LinkSetLearning(link Link, mode bool) error {
0000000000000000000000000000000000000000;;		return setProtinfoAttr(link, mode, nl.IFLA_BRPORT_LEARNING)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LinkSetRootBlock(link Link, mode bool) error {
0000000000000000000000000000000000000000;;		return setProtinfoAttr(link, mode, nl.IFLA_BRPORT_PROTECT)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LinkSetFlood(link Link, mode bool) error {
0000000000000000000000000000000000000000;;		return setProtinfoAttr(link, mode, nl.IFLA_BRPORT_UNICAST_FLOOD)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setProtinfoAttr(link Link, mode bool, attr int) error {
0000000000000000000000000000000000000000;;		base := link.Attrs()
0000000000000000000000000000000000000000;;		ensureIndex(base)
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_SETLINK, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := nl.NewIfInfomsg(syscall.AF_BRIDGE)
0000000000000000000000000000000000000000;;		msg.Index = int32(base.Index)
0000000000000000000000000000000000000000;;		req.AddData(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		br := nl.NewRtAttr(syscall.IFLA_PROTINFO|syscall.NLA_F_NESTED, nil)
0000000000000000000000000000000000000000;;		nl.NewRtAttrChild(br, attr, boolToByte(mode))
0000000000000000000000000000000000000000;;		req.AddData(br)
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseVlanData(link Link, data []syscall.NetlinkRouteAttr) {
0000000000000000000000000000000000000000;;		vlan := link.(*Vlan)
0000000000000000000000000000000000000000;;		for _, datum := range data {
0000000000000000000000000000000000000000;;			switch datum.Attr.Type {
0000000000000000000000000000000000000000;;			case nl.IFLA_VLAN_ID:
0000000000000000000000000000000000000000;;				vlan.VlanId = int(native.Uint16(datum.Value[0:2]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseVxlanData(link Link, data []syscall.NetlinkRouteAttr) {
0000000000000000000000000000000000000000;;		vxlan := link.(*Vxlan)
0000000000000000000000000000000000000000;;		for _, datum := range data {
0000000000000000000000000000000000000000;;			switch datum.Attr.Type {
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_ID:
0000000000000000000000000000000000000000;;				vxlan.VxlanId = int(native.Uint32(datum.Value[0:4]))
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_LINK:
0000000000000000000000000000000000000000;;				vxlan.VtepDevIndex = int(native.Uint32(datum.Value[0:4]))
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_LOCAL:
0000000000000000000000000000000000000000;;				vxlan.SrcAddr = net.IP(datum.Value[0:4])
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_LOCAL6:
0000000000000000000000000000000000000000;;				vxlan.SrcAddr = net.IP(datum.Value[0:16])
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_GROUP:
0000000000000000000000000000000000000000;;				vxlan.Group = net.IP(datum.Value[0:4])
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_GROUP6:
0000000000000000000000000000000000000000;;				vxlan.Group = net.IP(datum.Value[0:16])
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_TTL:
0000000000000000000000000000000000000000;;				vxlan.TTL = int(datum.Value[0])
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_TOS:
0000000000000000000000000000000000000000;;				vxlan.TOS = int(datum.Value[0])
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_LEARNING:
0000000000000000000000000000000000000000;;				vxlan.Learning = int8(datum.Value[0]) != 0
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_PROXY:
0000000000000000000000000000000000000000;;				vxlan.Proxy = int8(datum.Value[0]) != 0
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_RSC:
0000000000000000000000000000000000000000;;				vxlan.RSC = int8(datum.Value[0]) != 0
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_L2MISS:
0000000000000000000000000000000000000000;;				vxlan.L2miss = int8(datum.Value[0]) != 0
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_L3MISS:
0000000000000000000000000000000000000000;;				vxlan.L3miss = int8(datum.Value[0]) != 0
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_GBP:
0000000000000000000000000000000000000000;;				vxlan.GBP = int8(datum.Value[0]) != 0
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_AGEING:
0000000000000000000000000000000000000000;;				vxlan.Age = int(native.Uint32(datum.Value[0:4]))
0000000000000000000000000000000000000000;;				vxlan.NoAge = vxlan.Age == 0
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_LIMIT:
0000000000000000000000000000000000000000;;				vxlan.Limit = int(native.Uint32(datum.Value[0:4]))
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_PORT:
0000000000000000000000000000000000000000;;				vxlan.Port = int(native.Uint16(datum.Value[0:2]))
0000000000000000000000000000000000000000;;			case nl.IFLA_VXLAN_PORT_RANGE:
0000000000000000000000000000000000000000;;				buf := bytes.NewBuffer(datum.Value[0:4])
0000000000000000000000000000000000000000;;				var pr vxlanPortRange
0000000000000000000000000000000000000000;;				if binary.Read(buf, binary.BigEndian, &pr) != nil {
0000000000000000000000000000000000000000;;					vxlan.PortLow = int(pr.Lo)
0000000000000000000000000000000000000000;;					vxlan.PortHigh = int(pr.Hi)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseIPVlanData(link Link, data []syscall.NetlinkRouteAttr) {
0000000000000000000000000000000000000000;;		ipv := link.(*IPVlan)
0000000000000000000000000000000000000000;;		for _, datum := range data {
0000000000000000000000000000000000000000;;			if datum.Attr.Type == nl.IFLA_IPVLAN_MODE {
0000000000000000000000000000000000000000;;				ipv.Mode = IPVlanMode(native.Uint32(datum.Value[0:4]))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseMacvtapData(link Link, data []syscall.NetlinkRouteAttr) {
0000000000000000000000000000000000000000;;		macv := link.(*Macvtap)
0000000000000000000000000000000000000000;;		parseMacvlanData(&macv.Macvlan, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseMacvlanData(link Link, data []syscall.NetlinkRouteAttr) {
0000000000000000000000000000000000000000;;		macv := link.(*Macvlan)
0000000000000000000000000000000000000000;;		for _, datum := range data {
0000000000000000000000000000000000000000;;			if datum.Attr.Type == nl.IFLA_MACVLAN_MODE {
0000000000000000000000000000000000000000;;				switch native.Uint32(datum.Value[0:4]) {
0000000000000000000000000000000000000000;;				case nl.MACVLAN_MODE_PRIVATE:
0000000000000000000000000000000000000000;;					macv.Mode = MACVLAN_MODE_PRIVATE
0000000000000000000000000000000000000000;;				case nl.MACVLAN_MODE_VEPA:
0000000000000000000000000000000000000000;;					macv.Mode = MACVLAN_MODE_VEPA
0000000000000000000000000000000000000000;;				case nl.MACVLAN_MODE_BRIDGE:
0000000000000000000000000000000000000000;;					macv.Mode = MACVLAN_MODE_BRIDGE
0000000000000000000000000000000000000000;;				case nl.MACVLAN_MODE_PASSTHRU:
0000000000000000000000000000000000000000;;					macv.Mode = MACVLAN_MODE_PASSTHRU
0000000000000000000000000000000000000000;;				case nl.MACVLAN_MODE_SOURCE:
0000000000000000000000000000000000000000;;					macv.Mode = MACVLAN_MODE_SOURCE
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copied from pkg/net_linux.go
0000000000000000000000000000000000000000;;	func linkFlags(rawFlags uint32) net.Flags {
0000000000000000000000000000000000000000;;		var f net.Flags
0000000000000000000000000000000000000000;;		if rawFlags&syscall.IFF_UP != 0 {
0000000000000000000000000000000000000000;;			f |= net.FlagUp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rawFlags&syscall.IFF_BROADCAST != 0 {
0000000000000000000000000000000000000000;;			f |= net.FlagBroadcast
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rawFlags&syscall.IFF_LOOPBACK != 0 {
0000000000000000000000000000000000000000;;			f |= net.FlagLoopback
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rawFlags&syscall.IFF_POINTOPOINT != 0 {
0000000000000000000000000000000000000000;;			f |= net.FlagPointToPoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rawFlags&syscall.IFF_MULTICAST != 0 {
0000000000000000000000000000000000000000;;			f |= net.FlagMulticast
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
