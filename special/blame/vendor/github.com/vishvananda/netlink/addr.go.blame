0000000000000000000000000000000000000000;;	package netlink
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/vishvananda/netlink/addr.go[Godeps/_workspace/src/github.com/vishvananda/netlink/addr.go][vendor/github.com/vishvananda/netlink/addr.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addr represents an IP address from netlink. Netlink ip addresses
0000000000000000000000000000000000000000;;	// include a mask, so it stores the address as a net.IPNet.
0000000000000000000000000000000000000000;;	type Addr struct {
0000000000000000000000000000000000000000;;		*net.IPNet
0000000000000000000000000000000000000000;;		Label string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns $ip/$netmask $label
0000000000000000000000000000000000000000;;	func (a Addr) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s %s", a.IPNet, a.Label)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseAddr parses the string representation of an address in the
0000000000000000000000000000000000000000;;	// form $ip/$netmask $label. The label portion is optional
0000000000000000000000000000000000000000;;	func ParseAddr(s string) (*Addr, error) {
0000000000000000000000000000000000000000;;		label := ""
0000000000000000000000000000000000000000;;		parts := strings.Split(s, " ")
0000000000000000000000000000000000000000;;		if len(parts) > 1 {
0000000000000000000000000000000000000000;;			s = parts[0]
0000000000000000000000000000000000000000;;			label = parts[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m, err := ParseIPNet(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Addr{IPNet: m, Label: label}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal returns true if both Addrs have the same net.IPNet value.
0000000000000000000000000000000000000000;;	func (a Addr) Equal(x Addr) bool {
0000000000000000000000000000000000000000;;		sizea, _ := a.Mask.Size()
0000000000000000000000000000000000000000;;		sizeb, _ := x.Mask.Size()
0000000000000000000000000000000000000000;;		// ignore label for comparison
0000000000000000000000000000000000000000;;		return a.IP.Equal(x.IP) && sizea == sizeb
0000000000000000000000000000000000000000;;	}
