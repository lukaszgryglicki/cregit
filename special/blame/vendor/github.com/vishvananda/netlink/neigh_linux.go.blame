0000000000000000000000000000000000000000;;	package netlink
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/vishvananda/netlink/neigh_linux.go[Godeps/_workspace/src/github.com/vishvananda/netlink/neigh_linux.go][vendor/github.com/vishvananda/netlink/neigh_linux.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink/nl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NDA_UNSPEC = iota
0000000000000000000000000000000000000000;;		NDA_DST
0000000000000000000000000000000000000000;;		NDA_LLADDR
0000000000000000000000000000000000000000;;		NDA_CACHEINFO
0000000000000000000000000000000000000000;;		NDA_PROBES
0000000000000000000000000000000000000000;;		NDA_VLAN
0000000000000000000000000000000000000000;;		NDA_PORT
0000000000000000000000000000000000000000;;		NDA_VNI
0000000000000000000000000000000000000000;;		NDA_IFINDEX
0000000000000000000000000000000000000000;;		NDA_MAX = NDA_IFINDEX
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Neighbor Cache Entry States.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NUD_NONE       = 0x00
0000000000000000000000000000000000000000;;		NUD_INCOMPLETE = 0x01
0000000000000000000000000000000000000000;;		NUD_REACHABLE  = 0x02
0000000000000000000000000000000000000000;;		NUD_STALE      = 0x04
0000000000000000000000000000000000000000;;		NUD_DELAY      = 0x08
0000000000000000000000000000000000000000;;		NUD_PROBE      = 0x10
0000000000000000000000000000000000000000;;		NUD_FAILED     = 0x20
0000000000000000000000000000000000000000;;		NUD_NOARP      = 0x40
0000000000000000000000000000000000000000;;		NUD_PERMANENT  = 0x80
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Neighbor Flags
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NTF_USE    = 0x01
0000000000000000000000000000000000000000;;		NTF_SELF   = 0x02
0000000000000000000000000000000000000000;;		NTF_MASTER = 0x04
0000000000000000000000000000000000000000;;		NTF_PROXY  = 0x08
0000000000000000000000000000000000000000;;		NTF_ROUTER = 0x80
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Ndmsg struct {
0000000000000000000000000000000000000000;;		Family uint8
0000000000000000000000000000000000000000;;		Index  uint32
0000000000000000000000000000000000000000;;		State  uint16
0000000000000000000000000000000000000000;;		Flags  uint8
0000000000000000000000000000000000000000;;		Type   uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deserializeNdmsg(b []byte) *Ndmsg {
0000000000000000000000000000000000000000;;		var dummy Ndmsg
0000000000000000000000000000000000000000;;		return (*Ndmsg)(unsafe.Pointer(&b[0:unsafe.Sizeof(dummy)][0]))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (msg *Ndmsg) Serialize() []byte {
0000000000000000000000000000000000000000;;		return (*(*[unsafe.Sizeof(*msg)]byte)(unsafe.Pointer(msg)))[:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (msg *Ndmsg) Len() int {
0000000000000000000000000000000000000000;;		return int(unsafe.Sizeof(*msg))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeighAdd will add an IP to MAC mapping to the ARP table
0000000000000000000000000000000000000000;;	// Equivalent to: `ip neigh add ....`
0000000000000000000000000000000000000000;;	func NeighAdd(neigh *Neigh) error {
0000000000000000000000000000000000000000;;		return neighAdd(neigh, syscall.NLM_F_CREATE|syscall.NLM_F_EXCL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeighAdd will add or replace an IP to MAC mapping to the ARP table
0000000000000000000000000000000000000000;;	// Equivalent to: `ip neigh replace....`
0000000000000000000000000000000000000000;;	func NeighSet(neigh *Neigh) error {
0000000000000000000000000000000000000000;;		return neighAdd(neigh, syscall.NLM_F_CREATE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeighAppend will append an entry to FDB
0000000000000000000000000000000000000000;;	// Equivalent to: `bridge fdb append...`
0000000000000000000000000000000000000000;;	func NeighAppend(neigh *Neigh) error {
0000000000000000000000000000000000000000;;		return neighAdd(neigh, syscall.NLM_F_CREATE|syscall.NLM_F_APPEND)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func neighAdd(neigh *Neigh, mode int) error {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_NEWNEIGH, mode|syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;		return neighHandle(neigh, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeighDel will delete an IP address from a link device.
0000000000000000000000000000000000000000;;	// Equivalent to: `ip addr del $addr dev $link`
0000000000000000000000000000000000000000;;	func NeighDel(neigh *Neigh) error {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_DELNEIGH, syscall.NLM_F_ACK)
0000000000000000000000000000000000000000;;		return neighHandle(neigh, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func neighHandle(neigh *Neigh, req *nl.NetlinkRequest) error {
0000000000000000000000000000000000000000;;		var family int
0000000000000000000000000000000000000000;;		if neigh.Family > 0 {
0000000000000000000000000000000000000000;;			family = neigh.Family
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			family = nl.GetIPFamily(neigh.IP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := Ndmsg{
0000000000000000000000000000000000000000;;			Family: uint8(family),
0000000000000000000000000000000000000000;;			Index:  uint32(neigh.LinkIndex),
0000000000000000000000000000000000000000;;			State:  uint16(neigh.State),
0000000000000000000000000000000000000000;;			Type:   uint8(neigh.Type),
0000000000000000000000000000000000000000;;			Flags:  uint8(neigh.Flags),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.AddData(&msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipData := neigh.IP.To4()
0000000000000000000000000000000000000000;;		if ipData == nil {
0000000000000000000000000000000000000000;;			ipData = neigh.IP.To16()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dstData := nl.NewRtAttr(NDA_DST, ipData)
0000000000000000000000000000000000000000;;		req.AddData(dstData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hwData := nl.NewRtAttr(NDA_LLADDR, []byte(neigh.HardwareAddr))
0000000000000000000000000000000000000000;;		req.AddData(hwData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := req.Execute(syscall.NETLINK_ROUTE, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeighList gets a list of IP-MAC mappings in the system (ARP table).
0000000000000000000000000000000000000000;;	// Equivalent to: `ip neighbor show`.
0000000000000000000000000000000000000000;;	// The list can be filtered by link and ip family.
0000000000000000000000000000000000000000;;	func NeighList(linkIndex, family int) ([]Neigh, error) {
0000000000000000000000000000000000000000;;		req := nl.NewNetlinkRequest(syscall.RTM_GETNEIGH, syscall.NLM_F_DUMP)
0000000000000000000000000000000000000000;;		msg := Ndmsg{
0000000000000000000000000000000000000000;;			Family: uint8(family),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.AddData(&msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs, err := req.Execute(syscall.NETLINK_ROUTE, syscall.RTM_NEWNEIGH)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res []Neigh
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			ndm := deserializeNdmsg(m)
0000000000000000000000000000000000000000;;			if linkIndex != 0 && int(ndm.Index) != linkIndex {
0000000000000000000000000000000000000000;;				// Ignore messages from other interfaces
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			neigh, err := NeighDeserialize(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			res = append(res, *neigh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NeighDeserialize(m []byte) (*Neigh, error) {
0000000000000000000000000000000000000000;;		msg := deserializeNdmsg(m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		neigh := Neigh{
0000000000000000000000000000000000000000;;			LinkIndex: int(msg.Index),
0000000000000000000000000000000000000000;;			Family:    int(msg.Family),
0000000000000000000000000000000000000000;;			State:     int(msg.State),
0000000000000000000000000000000000000000;;			Type:      int(msg.Type),
0000000000000000000000000000000000000000;;			Flags:     int(msg.Flags),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs, err := nl.ParseRouteAttr(m[msg.Len():])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, attr := range attrs {
0000000000000000000000000000000000000000;;			switch attr.Attr.Type {
0000000000000000000000000000000000000000;;			case NDA_DST:
0000000000000000000000000000000000000000;;				neigh.IP = net.IP(attr.Value)
0000000000000000000000000000000000000000;;			case NDA_LLADDR:
0000000000000000000000000000000000000000;;				neigh.HardwareAddr = net.HardwareAddr(attr.Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &neigh, nil
0000000000000000000000000000000000000000;;	}
