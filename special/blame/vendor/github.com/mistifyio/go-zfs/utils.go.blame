0000000000000000000000000000000000000000;;	package zfs
89bc075ca22301fc4fe03dcaa8c8fcf6f0b87b87;Godeps/_workspace/src/github.com/mistifyio/go-zfs/utils.go[Godeps/_workspace/src/github.com/mistifyio/go-zfs/utils.go][vendor/github.com/mistifyio/go-zfs/utils.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pborman/uuid"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type command struct {
0000000000000000000000000000000000000000;;		Command string
0000000000000000000000000000000000000000;;		Stdin   io.Reader
0000000000000000000000000000000000000000;;		Stdout  io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *command) Run(arg ...string) ([][]string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := exec.Command(c.Command, arg...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var stdout, stderr bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Stdout == nil {
0000000000000000000000000000000000000000;;			cmd.Stdout = &stdout
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cmd.Stdout = c.Stdout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Stdin != nil {
0000000000000000000000000000000000000000;;			cmd.Stdin = c.Stdin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Stderr = &stderr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := uuid.New()
0000000000000000000000000000000000000000;;		joinedArgs := strings.Join(cmd.Args, " ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Log([]string{"ID:" + id, "START", joinedArgs})
0000000000000000000000000000000000000000;;		err := cmd.Run()
0000000000000000000000000000000000000000;;		logger.Log([]string{"ID:" + id, "FINISH"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, &Error{
0000000000000000000000000000000000000000;;				Err:    err,
0000000000000000000000000000000000000000;;				Debug:  strings.Join([]string{cmd.Path, joinedArgs}, " "),
0000000000000000000000000000000000000000;;				Stderr: stderr.String(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assume if you passed in something for stdout, that you know what to do with it
0000000000000000000000000000000000000000;;		if c.Stdout != nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := strings.Split(stdout.String(), "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//last line is always blank
0000000000000000000000000000000000000000;;		lines = lines[0 : len(lines)-1]
0000000000000000000000000000000000000000;;		output := make([][]string, len(lines))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, l := range lines {
0000000000000000000000000000000000000000;;			output[i] = strings.Fields(l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setString(field *string, value string) {
0000000000000000000000000000000000000000;;		v := ""
0000000000000000000000000000000000000000;;		if value != "-" {
0000000000000000000000000000000000000000;;			v = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*field = v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setUint(field *uint64, value string) error {
0000000000000000000000000000000000000000;;		var v uint64
0000000000000000000000000000000000000000;;		if value != "-" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			v, err = strconv.ParseUint(value, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*field = v
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ds *Dataset) parseLine(line []string) error {
0000000000000000000000000000000000000000;;		prop := line[1]
0000000000000000000000000000000000000000;;		val := line[2]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch prop {
0000000000000000000000000000000000000000;;		case "available":
0000000000000000000000000000000000000000;;			err = setUint(&ds.Avail, val)
0000000000000000000000000000000000000000;;		case "compression":
0000000000000000000000000000000000000000;;			setString(&ds.Compression, val)
0000000000000000000000000000000000000000;;		case "mountpoint":
0000000000000000000000000000000000000000;;			setString(&ds.Mountpoint, val)
0000000000000000000000000000000000000000;;		case "quota":
0000000000000000000000000000000000000000;;			err = setUint(&ds.Quota, val)
0000000000000000000000000000000000000000;;		case "type":
0000000000000000000000000000000000000000;;			setString(&ds.Type, val)
0000000000000000000000000000000000000000;;		case "origin":
0000000000000000000000000000000000000000;;			setString(&ds.Origin, val)
0000000000000000000000000000000000000000;;		case "used":
0000000000000000000000000000000000000000;;			err = setUint(&ds.Used, val)
0000000000000000000000000000000000000000;;		case "volsize":
0000000000000000000000000000000000000000;;			err = setUint(&ds.Volsize, val)
0000000000000000000000000000000000000000;;		case "written":
0000000000000000000000000000000000000000;;			err = setUint(&ds.Written, val)
0000000000000000000000000000000000000000;;		case "logicalused":
0000000000000000000000000000000000000000;;			err = setUint(&ds.Logicalused, val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * from zfs diff`s escape function:
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Prints a file name out a character at a time.  If the character is
0000000000000000000000000000000000000000;;	 * not in the range of what we consider "printable" ASCII, display it
0000000000000000000000000000000000000000;;	 * as an escaped 3-digit octal value.  ASCII values less than a space
0000000000000000000000000000000000000000;;	 * are all control characters and we declare the upper end as the
0000000000000000000000000000000000000000;;	 * DELete character.  This also is the last 7-bit ASCII character.
0000000000000000000000000000000000000000;;	 * We choose to treat all 8-bit ASCII as not printable for this
0000000000000000000000000000000000000000;;	 * application.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func unescapeFilepath(path string) (string, error) {
0000000000000000000000000000000000000000;;		buf := make([]byte, 0, len(path))
0000000000000000000000000000000000000000;;		llen := len(path)
0000000000000000000000000000000000000000;;		for i := 0; i < llen; {
0000000000000000000000000000000000000000;;			if path[i] == '\\' {
0000000000000000000000000000000000000000;;				if llen < i+4 {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("Invalid octal code: too short")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				octalCode := path[(i + 1):(i + 4)]
0000000000000000000000000000000000000000;;				val, err := strconv.ParseUint(octalCode, 8, 8)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("Invalid octal code: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf = append(buf, byte(val))
0000000000000000000000000000000000000000;;				i += 4
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf = append(buf, path[i])
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var changeTypeMap = map[string]ChangeType{
0000000000000000000000000000000000000000;;		"-": Removed,
0000000000000000000000000000000000000000;;		"+": Created,
0000000000000000000000000000000000000000;;		"M": Modified,
0000000000000000000000000000000000000000;;		"R": Renamed,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	var inodeTypeMap = map[string]InodeType{
0000000000000000000000000000000000000000;;		"B": BlockDevice,
0000000000000000000000000000000000000000;;		"C": CharacterDevice,
0000000000000000000000000000000000000000;;		"/": Directory,
0000000000000000000000000000000000000000;;		">": Door,
0000000000000000000000000000000000000000;;		"|": NamedPipe,
0000000000000000000000000000000000000000;;		"@": SymbolicLink,
0000000000000000000000000000000000000000;;		"P": EventPort,
0000000000000000000000000000000000000000;;		"=": Socket,
0000000000000000000000000000000000000000;;		"F": File,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matches (+1) or (-1)
0000000000000000000000000000000000000000;;	var referenceCountRegex = regexp.MustCompile("\\(([+-]\\d+?)\\)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseReferenceCount(field string) (int, error) {
0000000000000000000000000000000000000000;;		matches := referenceCountRegex.FindStringSubmatch(field)
0000000000000000000000000000000000000000;;		if matches == nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Regexp does not match")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.Atoi(matches[1])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseInodeChange(line []string) (*InodeChange, error) {
0000000000000000000000000000000000000000;;		llen := len(line)
0000000000000000000000000000000000000000;;		if llen < 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Empty line passed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changeType := changeTypeMap[line[0]]
0000000000000000000000000000000000000000;;		if changeType == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unknown change type '%s'", line[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch changeType {
0000000000000000000000000000000000000000;;		case Renamed:
0000000000000000000000000000000000000000;;			if llen != 4 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Mismatching number of fields: expect 4, got: %d", llen)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Modified:
0000000000000000000000000000000000000000;;			if llen != 4 && llen != 3 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Mismatching number of fields: expect 3..4, got: %d", llen)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if llen != 3 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Mismatching number of fields: expect 3, got: %d", llen)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inodeType := inodeTypeMap[line[1]]
0000000000000000000000000000000000000000;;		if inodeType == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unknown inode type '%s'", line[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path, err := unescapeFilepath(line[2])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to parse filename: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var newPath string
0000000000000000000000000000000000000000;;		var referenceCount int
0000000000000000000000000000000000000000;;		switch changeType {
0000000000000000000000000000000000000000;;		case Renamed:
0000000000000000000000000000000000000000;;			newPath, err = unescapeFilepath(line[3])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to parse filename: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Modified:
0000000000000000000000000000000000000000;;			if llen == 4 {
0000000000000000000000000000000000000000;;				referenceCount, err = parseReferenceCount(line[3])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Failed to parse reference count: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			newPath = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &InodeChange{
0000000000000000000000000000000000000000;;			Change:               changeType,
0000000000000000000000000000000000000000;;			Type:                 inodeType,
0000000000000000000000000000000000000000;;			Path:                 path,
0000000000000000000000000000000000000000;;			NewPath:              newPath,
0000000000000000000000000000000000000000;;			ReferenceCountChange: referenceCount,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// example input
0000000000000000000000000000000000000000;;	//M       /       /testpool/bar/
0000000000000000000000000000000000000000;;	//+       F       /testpool/bar/hello.txt
0000000000000000000000000000000000000000;;	//M       /       /testpool/bar/hello.txt (+1)
0000000000000000000000000000000000000000;;	//M       /       /testpool/bar/hello-hardlink
0000000000000000000000000000000000000000;;	func parseInodeChanges(lines [][]string) ([]*InodeChange, error) {
0000000000000000000000000000000000000000;;		changes := make([]*InodeChange, len(lines))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, line := range lines {
0000000000000000000000000000000000000000;;			c, err := parseInodeChange(line)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to parse line %d of zfs diff: %v, got: '%s'", i, err, line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			changes[i] = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return changes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func listByType(t, filter string) ([]*Dataset, error) {
0000000000000000000000000000000000000000;;		args := []string{"get", "-rHp", "-t", t, "all"}
0000000000000000000000000000000000000000;;		if filter != "" {
0000000000000000000000000000000000000000;;			args = append(args, filter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, err := zfs(args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var datasets []*Dataset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := ""
0000000000000000000000000000000000000000;;		var ds *Dataset
0000000000000000000000000000000000000000;;		for _, line := range out {
0000000000000000000000000000000000000000;;			if name != line[0] {
0000000000000000000000000000000000000000;;				name = line[0]
0000000000000000000000000000000000000000;;				ds = &Dataset{Name: name}
0000000000000000000000000000000000000000;;				datasets = append(datasets, ds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := ds.parseLine(line); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return datasets, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func propsSlice(properties map[string]string) []string {
0000000000000000000000000000000000000000;;		args := make([]string, 0, len(properties)*3)
0000000000000000000000000000000000000000;;		for k, v := range properties {
0000000000000000000000000000000000000000;;			args = append(args, "-o")
0000000000000000000000000000000000000000;;			args = append(args, fmt.Sprintf("%s=%s", k, v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *Zpool) parseLine(line []string) error {
0000000000000000000000000000000000000000;;		prop := line[1]
0000000000000000000000000000000000000000;;		val := line[2]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch prop {
0000000000000000000000000000000000000000;;		case "health":
0000000000000000000000000000000000000000;;			setString(&z.Health, val)
0000000000000000000000000000000000000000;;		case "allocated":
0000000000000000000000000000000000000000;;			err = setUint(&z.Allocated, val)
0000000000000000000000000000000000000000;;		case "size":
0000000000000000000000000000000000000000;;			err = setUint(&z.Size, val)
0000000000000000000000000000000000000000;;		case "free":
0000000000000000000000000000000000000000;;			err = setUint(&z.Free, val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
