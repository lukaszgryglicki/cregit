0000000000000000000000000000000000000000;;	// Package zfs provides wrappers around the ZFS command line tools.
0000000000000000000000000000000000000000;;	package zfs
89bc075ca22301fc4fe03dcaa8c8fcf6f0b87b87;Godeps/_workspace/src/github.com/mistifyio/go-zfs/zfs.go[Godeps/_workspace/src/github.com/mistifyio/go-zfs/zfs.go][vendor/github.com/mistifyio/go-zfs/zfs.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ZFS dataset types, which can indicate if a dataset is a filesystem,
0000000000000000000000000000000000000000;;	// snapshot, or volume.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DatasetFilesystem = "filesystem"
0000000000000000000000000000000000000000;;		DatasetSnapshot   = "snapshot"
0000000000000000000000000000000000000000;;		DatasetVolume     = "volume"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dataset is a ZFS dataset.  A dataset could be a clone, filesystem, snapshot,
0000000000000000000000000000000000000000;;	// or volume.  The Type struct member can be used to determine a dataset's type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The field definitions can be found in the ZFS manual:
0000000000000000000000000000000000000000;;	// http://www.freebsd.org/cgi/man.cgi?zfs(8).
0000000000000000000000000000000000000000;;	type Dataset struct {
0000000000000000000000000000000000000000;;		Name          string
0000000000000000000000000000000000000000;;		Origin        string
0000000000000000000000000000000000000000;;		Used          uint64
0000000000000000000000000000000000000000;;		Avail         uint64
0000000000000000000000000000000000000000;;		Mountpoint    string
0000000000000000000000000000000000000000;;		Compression   string
0000000000000000000000000000000000000000;;		Type          string
0000000000000000000000000000000000000000;;		Written       uint64
0000000000000000000000000000000000000000;;		Volsize       uint64
0000000000000000000000000000000000000000;;		Usedbydataset uint64
0000000000000000000000000000000000000000;;		Logicalused   uint64
0000000000000000000000000000000000000000;;		Quota         uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InodeType is the type of inode as reported by Diff
0000000000000000000000000000000000000000;;	type InodeType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Types of Inodes
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_                     = iota // 0 == unknown type
0000000000000000000000000000000000000000;;		BlockDevice InodeType = iota
0000000000000000000000000000000000000000;;		CharacterDevice
0000000000000000000000000000000000000000;;		Directory
0000000000000000000000000000000000000000;;		Door
0000000000000000000000000000000000000000;;		NamedPipe
0000000000000000000000000000000000000000;;		SymbolicLink
0000000000000000000000000000000000000000;;		EventPort
0000000000000000000000000000000000000000;;		Socket
0000000000000000000000000000000000000000;;		File
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChangeType is the type of inode change as reported by Diff
0000000000000000000000000000000000000000;;	type ChangeType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Types of Changes
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_                  = iota // 0 == unknown type
0000000000000000000000000000000000000000;;		Removed ChangeType = iota
0000000000000000000000000000000000000000;;		Created
0000000000000000000000000000000000000000;;		Modified
0000000000000000000000000000000000000000;;		Renamed
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DestroyFlag is the options flag passed to Destroy
0000000000000000000000000000000000000000;;	type DestroyFlag int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid destroy options
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DestroyDefault         DestroyFlag = 1 << iota
0000000000000000000000000000000000000000;;		DestroyRecursive                   = 1 << iota
0000000000000000000000000000000000000000;;		DestroyRecursiveClones             = 1 << iota
0000000000000000000000000000000000000000;;		DestroyDeferDeletion               = 1 << iota
0000000000000000000000000000000000000000;;		DestroyForceUmount                 = 1 << iota
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InodeChange represents a change as reported by Diff
0000000000000000000000000000000000000000;;	type InodeChange struct {
0000000000000000000000000000000000000000;;		Change               ChangeType
0000000000000000000000000000000000000000;;		Type                 InodeType
0000000000000000000000000000000000000000;;		Path                 string
0000000000000000000000000000000000000000;;		NewPath              string
0000000000000000000000000000000000000000;;		ReferenceCountChange int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Logger can be used to log commands/actions
0000000000000000000000000000000000000000;;	type Logger interface {
0000000000000000000000000000000000000000;;		Log(cmd []string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultLogger struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*defaultLogger) Log(cmd []string) {
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var logger Logger = &defaultLogger{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLogger set a log handler to log all commands including arguments before
0000000000000000000000000000000000000000;;	// they are executed
0000000000000000000000000000000000000000;;	func SetLogger(l Logger) {
0000000000000000000000000000000000000000;;		if l != nil {
0000000000000000000000000000000000000000;;			logger = l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// zfs is a helper function to wrap typical calls to zfs.
0000000000000000000000000000000000000000;;	func zfs(arg ...string) ([][]string, error) {
0000000000000000000000000000000000000000;;		c := command{Command: "zfs"}
0000000000000000000000000000000000000000;;		return c.Run(arg...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Datasets returns a slice of ZFS datasets, regardless of type.
0000000000000000000000000000000000000000;;	// A filter argument may be passed to select a dataset with the matching name,
0000000000000000000000000000000000000000;;	// or empty string ("") may be used to select all datasets.
0000000000000000000000000000000000000000;;	func Datasets(filter string) ([]*Dataset, error) {
0000000000000000000000000000000000000000;;		return listByType("all", filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Snapshots returns a slice of ZFS snapshots.
0000000000000000000000000000000000000000;;	// A filter argument may be passed to select a snapshot with the matching name,
0000000000000000000000000000000000000000;;	// or empty string ("") may be used to select all snapshots.
0000000000000000000000000000000000000000;;	func Snapshots(filter string) ([]*Dataset, error) {
0000000000000000000000000000000000000000;;		return listByType(DatasetSnapshot, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filesystems returns a slice of ZFS filesystems.
0000000000000000000000000000000000000000;;	// A filter argument may be passed to select a filesystem with the matching name,
0000000000000000000000000000000000000000;;	// or empty string ("") may be used to select all filesystems.
0000000000000000000000000000000000000000;;	func Filesystems(filter string) ([]*Dataset, error) {
0000000000000000000000000000000000000000;;		return listByType(DatasetFilesystem, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volumes returns a slice of ZFS volumes.
0000000000000000000000000000000000000000;;	// A filter argument may be passed to select a volume with the matching name,
0000000000000000000000000000000000000000;;	// or empty string ("") may be used to select all volumes.
0000000000000000000000000000000000000000;;	func Volumes(filter string) ([]*Dataset, error) {
0000000000000000000000000000000000000000;;		return listByType(DatasetVolume, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDataset retrieves a single ZFS dataset by name.  This dataset could be
0000000000000000000000000000000000000000;;	// any valid ZFS dataset type, such as a clone, filesystem, snapshot, or volume.
0000000000000000000000000000000000000000;;	func GetDataset(name string) (*Dataset, error) {
0000000000000000000000000000000000000000;;		out, err := zfs("get", "-Hp", "all", name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ds := &Dataset{Name: name}
0000000000000000000000000000000000000000;;		for _, line := range out {
0000000000000000000000000000000000000000;;			if err := ds.parseLine(line); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ds, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clone clones a ZFS snapshot and returns a clone dataset.
0000000000000000000000000000000000000000;;	// An error will be returned if the input dataset is not of snapshot type.
0000000000000000000000000000000000000000;;	func (d *Dataset) Clone(dest string, properties map[string]string) (*Dataset, error) {
0000000000000000000000000000000000000000;;		if d.Type != DatasetSnapshot {
0000000000000000000000000000000000000000;;			return nil, errors.New("can only clone snapshots")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args := make([]string, 2, 4)
0000000000000000000000000000000000000000;;		args[0] = "clone"
0000000000000000000000000000000000000000;;		args[1] = "-p"
0000000000000000000000000000000000000000;;		if properties != nil {
0000000000000000000000000000000000000000;;			args = append(args, propsSlice(properties)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = append(args, []string{d.Name, dest}...)
0000000000000000000000000000000000000000;;		_, err := zfs(args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetDataset(dest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReceiveSnapshot receives a ZFS stream from the input io.Reader, creates a
0000000000000000000000000000000000000000;;	// new snapshot with the specified name, and streams the input data into the
0000000000000000000000000000000000000000;;	// newly-created snapshot.
0000000000000000000000000000000000000000;;	func ReceiveSnapshot(input io.Reader, name string) (*Dataset, error) {
0000000000000000000000000000000000000000;;		c := command{Command: "zfs", Stdin: input}
0000000000000000000000000000000000000000;;		_, err := c.Run("receive", name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetDataset(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendSnapshot sends a ZFS stream of a snapshot to the input io.Writer.
0000000000000000000000000000000000000000;;	// An error will be returned if the input dataset is not of snapshot type.
0000000000000000000000000000000000000000;;	func (d *Dataset) SendSnapshot(output io.Writer) error {
0000000000000000000000000000000000000000;;		if d.Type != DatasetSnapshot {
0000000000000000000000000000000000000000;;			return errors.New("can only send snapshots")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := command{Command: "zfs", Stdout: output}
0000000000000000000000000000000000000000;;		_, err := c.Run("send", d.Name)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateVolume creates a new ZFS volume with the specified name, size, and
0000000000000000000000000000000000000000;;	// properties.
0000000000000000000000000000000000000000;;	// A full list of available ZFS properties may be found here:
0000000000000000000000000000000000000000;;	// https://www.freebsd.org/cgi/man.cgi?zfs(8).
0000000000000000000000000000000000000000;;	func CreateVolume(name string, size uint64, properties map[string]string) (*Dataset, error) {
0000000000000000000000000000000000000000;;		args := make([]string, 4, 5)
0000000000000000000000000000000000000000;;		args[0] = "create"
0000000000000000000000000000000000000000;;		args[1] = "-p"
0000000000000000000000000000000000000000;;		args[2] = "-V"
0000000000000000000000000000000000000000;;		args[3] = strconv.FormatUint(size, 10)
0000000000000000000000000000000000000000;;		if properties != nil {
0000000000000000000000000000000000000000;;			args = append(args, propsSlice(properties)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = append(args, name)
0000000000000000000000000000000000000000;;		_, err := zfs(args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetDataset(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Destroy destroys a ZFS dataset. If the destroy bit flag is set, any
0000000000000000000000000000000000000000;;	// descendents of the dataset will be recursively destroyed, including snapshots.
0000000000000000000000000000000000000000;;	// If the deferred bit flag is set, the snapshot is marked for deferred
0000000000000000000000000000000000000000;;	// deletion.
0000000000000000000000000000000000000000;;	func (d *Dataset) Destroy(flags DestroyFlag) error {
0000000000000000000000000000000000000000;;		args := make([]string, 1, 3)
0000000000000000000000000000000000000000;;		args[0] = "destroy"
0000000000000000000000000000000000000000;;		if flags&DestroyRecursive != 0 {
0000000000000000000000000000000000000000;;			args = append(args, "-r")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flags&DestroyRecursiveClones != 0 {
0000000000000000000000000000000000000000;;			args = append(args, "-R")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flags&DestroyDeferDeletion != 0 {
0000000000000000000000000000000000000000;;			args = append(args, "-d")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flags&DestroyForceUmount != 0 {
0000000000000000000000000000000000000000;;			args = append(args, "-f")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args = append(args, d.Name)
0000000000000000000000000000000000000000;;		_, err := zfs(args...)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetProperty sets a ZFS property on the receiving dataset.
0000000000000000000000000000000000000000;;	// A full list of available ZFS properties may be found here:
0000000000000000000000000000000000000000;;	// https://www.freebsd.org/cgi/man.cgi?zfs(8).
0000000000000000000000000000000000000000;;	func (d *Dataset) SetProperty(key, val string) error {
0000000000000000000000000000000000000000;;		prop := strings.Join([]string{key, val}, "=")
0000000000000000000000000000000000000000;;		_, err := zfs("set", prop, d.Name)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetProperty returns the current value of a ZFS property from the
0000000000000000000000000000000000000000;;	// receiving dataset.
0000000000000000000000000000000000000000;;	// A full list of available ZFS properties may be found here:
0000000000000000000000000000000000000000;;	// https://www.freebsd.org/cgi/man.cgi?zfs(8).
0000000000000000000000000000000000000000;;	func (d *Dataset) GetProperty(key string) (string, error) {
0000000000000000000000000000000000000000;;		out, err := zfs("get", key, d.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out[0][2], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Snapshots returns a slice of all ZFS snapshots of a given dataset.
0000000000000000000000000000000000000000;;	func (d *Dataset) Snapshots() ([]*Dataset, error) {
0000000000000000000000000000000000000000;;		return Snapshots(d.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateFilesystem creates a new ZFS filesystem with the specified name and
0000000000000000000000000000000000000000;;	// properties.
0000000000000000000000000000000000000000;;	// A full list of available ZFS properties may be found here:
0000000000000000000000000000000000000000;;	// https://www.freebsd.org/cgi/man.cgi?zfs(8).
0000000000000000000000000000000000000000;;	func CreateFilesystem(name string, properties map[string]string) (*Dataset, error) {
0000000000000000000000000000000000000000;;		args := make([]string, 1, 4)
0000000000000000000000000000000000000000;;		args[0] = "create"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if properties != nil {
0000000000000000000000000000000000000000;;			args = append(args, propsSlice(properties)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args = append(args, name)
0000000000000000000000000000000000000000;;		_, err := zfs(args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetDataset(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Snapshot creates a new ZFS snapshot of the receiving dataset, using the
0000000000000000000000000000000000000000;;	// specified name.  Optionally, the snapshot can be taken recursively, creating
0000000000000000000000000000000000000000;;	// snapshots of all descendent filesystems in a single, atomic operation.
0000000000000000000000000000000000000000;;	func (d *Dataset) Snapshot(name string, recursive bool) (*Dataset, error) {
0000000000000000000000000000000000000000;;		args := make([]string, 1, 4)
0000000000000000000000000000000000000000;;		args[0] = "snapshot"
0000000000000000000000000000000000000000;;		if recursive {
0000000000000000000000000000000000000000;;			args = append(args, "-r")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		snapName := fmt.Sprintf("%s@%s", d.Name, name)
0000000000000000000000000000000000000000;;		args = append(args, snapName)
0000000000000000000000000000000000000000;;		_, err := zfs(args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetDataset(snapName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rollback rolls back the receiving ZFS dataset to a previous snapshot.
0000000000000000000000000000000000000000;;	// Optionally, intermediate snapshots can be destroyed.  A ZFS snapshot
0000000000000000000000000000000000000000;;	// rollback cannot be completed without this option, if more recent
0000000000000000000000000000000000000000;;	// snapshots exist.
0000000000000000000000000000000000000000;;	// An error will be returned if the input dataset is not of snapshot type.
0000000000000000000000000000000000000000;;	func (d *Dataset) Rollback(destroyMoreRecent bool) error {
0000000000000000000000000000000000000000;;		if d.Type != DatasetSnapshot {
0000000000000000000000000000000000000000;;			return errors.New("can only rollback snapshots")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := make([]string, 1, 3)
0000000000000000000000000000000000000000;;		args[0] = "rollback"
0000000000000000000000000000000000000000;;		if destroyMoreRecent {
0000000000000000000000000000000000000000;;			args = append(args, "-r")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = append(args, d.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := zfs(args...)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Children returns a slice of children of the receiving ZFS dataset.
0000000000000000000000000000000000000000;;	// A recursion depth may be specified, or a depth of 0 allows unlimited
0000000000000000000000000000000000000000;;	// recursion.
0000000000000000000000000000000000000000;;	func (d *Dataset) Children(depth uint64) ([]*Dataset, error) {
0000000000000000000000000000000000000000;;		args := []string{"get", "-t", "all", "-Hp", "all"}
0000000000000000000000000000000000000000;;		if depth > 0 {
0000000000000000000000000000000000000000;;			args = append(args, "-d")
0000000000000000000000000000000000000000;;			args = append(args, strconv.FormatUint(depth, 10))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			args = append(args, "-r")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = append(args, d.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := zfs(args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var datasets []*Dataset
0000000000000000000000000000000000000000;;		name := ""
0000000000000000000000000000000000000000;;		var ds *Dataset
0000000000000000000000000000000000000000;;		for _, line := range out {
0000000000000000000000000000000000000000;;			if name != line[0] {
0000000000000000000000000000000000000000;;				name = line[0]
0000000000000000000000000000000000000000;;				ds = &Dataset{Name: name}
0000000000000000000000000000000000000000;;				datasets = append(datasets, ds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := ds.parseLine(line); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return datasets[1:], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Diff returns changes between a snapshot and the given ZFS dataset.
0000000000000000000000000000000000000000;;	// The snapshot name must include the filesystem part as it is possible to
0000000000000000000000000000000000000000;;	// compare clones with their origin snapshots.
0000000000000000000000000000000000000000;;	func (d *Dataset) Diff(snapshot string) ([]*InodeChange, error) {
0000000000000000000000000000000000000000;;		args := []string{"diff", "-FH", snapshot, d.Name}[:]
0000000000000000000000000000000000000000;;		out, err := zfs(args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inodeChanges, err := parseInodeChanges(out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return inodeChanges, nil
0000000000000000000000000000000000000000;;	}
