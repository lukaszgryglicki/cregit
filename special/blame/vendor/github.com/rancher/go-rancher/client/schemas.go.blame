0000000000000000000000000000000000000000;;	package client
a70eec3531b96f9fd5397f7cec9cd89ffcaafa47;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Schemas struct {
0000000000000000000000000000000000000000;;		Collection
0000000000000000000000000000000000000000;;		Data          []Schema `json:"data,omitempty"`
0000000000000000000000000000000000000000;;		schemasByName map[string]*Schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Schema) CheckField(name string) (Field, bool) {
0000000000000000000000000000000000000000;;		for fieldName := range s.ResourceFields {
0000000000000000000000000000000000000000;;			if fieldName == name {
0000000000000000000000000000000000000000;;				v, ok := s.ResourceFields[fieldName]
0000000000000000000000000000000000000000;;				return v, ok
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Field{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Schema) Field(name string) Field {
0000000000000000000000000000000000000000;;		f, _ := s.CheckField(name)
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Schemas) CheckSchema(name string) (Schema, bool) {
0000000000000000000000000000000000000000;;		for i := range s.Data {
0000000000000000000000000000000000000000;;			if s.Data[i].Id == name {
0000000000000000000000000000000000000000;;				return s.Data[i], true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Schema{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Schemas) Schema(name string) Schema {
0000000000000000000000000000000000000000;;		r, _ := s.CheckSchema(name)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func typeToFields(t reflect.Type) map[string]Field {
0000000000000000000000000000000000000000;;		result := map[string]Field{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;			schemaField := Field{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			typeField := t.Field(i)
0000000000000000000000000000000000000000;;			if typeField.Anonymous && typeField.Type.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;				parentFields := typeToFields(typeField.Type)
0000000000000000000000000000000000000000;;				for k, v := range result {
0000000000000000000000000000000000000000;;					parentFields[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = parentFields
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if typeField.Anonymous {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fieldString := strings.ToLower(typeField.Type.Kind().String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case strings.HasPrefix(fieldString, "int") || strings.HasPrefix(fieldString, "uint"):
0000000000000000000000000000000000000000;;				schemaField.Type = "int"
0000000000000000000000000000000000000000;;			case fieldString == "bool":
0000000000000000000000000000000000000000;;				schemaField.Type = fieldString
0000000000000000000000000000000000000000;;			case fieldString == "float32" || fieldString == "float64":
0000000000000000000000000000000000000000;;				schemaField.Type = "float"
0000000000000000000000000000000000000000;;			case fieldString == "string":
0000000000000000000000000000000000000000;;				schemaField.Type = "string"
0000000000000000000000000000000000000000;;			case fieldString == "map":
0000000000000000000000000000000000000000;;				// HACK
0000000000000000000000000000000000000000;;				schemaField.Type = "map[string]"
0000000000000000000000000000000000000000;;			case fieldString == "slice":
0000000000000000000000000000000000000000;;				// HACK
0000000000000000000000000000000000000000;;				schemaField.Type = "array[string]"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			name := strings.Split(typeField.Tag.Get("json"), ",")[0]
0000000000000000000000000000000000000000;;			if name == "" && len(typeField.Name) > 1 {
0000000000000000000000000000000000000000;;				name = strings.ToLower(typeField.Name[0:1]) + typeField.Name[1:]
0000000000000000000000000000000000000000;;			} else if name == "" {
0000000000000000000000000000000000000000;;				name = typeField.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if schemaField.Type != "" {
0000000000000000000000000000000000000000;;				result[name] = schemaField
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Schemas) AddType(schemaName string, obj interface{}) *Schema {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		schema := Schema{
0000000000000000000000000000000000000000;;			Resource: Resource{
0000000000000000000000000000000000000000;;				Id:    schemaName,
0000000000000000000000000000000000000000;;				Type:  "schema",
0000000000000000000000000000000000000000;;				Links: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PluralName:        guessPluralName(schemaName),
0000000000000000000000000000000000000000;;			ResourceFields:    typeToFields(t),
0000000000000000000000000000000000000000;;			CollectionMethods: []string{"GET"},
0000000000000000000000000000000000000000;;			ResourceMethods:   []string{"GET"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Data == nil {
0000000000000000000000000000000000000000;;			s.Data = []Schema{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Data = append(s.Data, schema)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &s.Data[len(s.Data)-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func guessPluralName(name string) string {
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasSuffix(name, "s") ||
0000000000000000000000000000000000000000;;			strings.HasSuffix(name, "ch") ||
0000000000000000000000000000000000000000;;			strings.HasSuffix(name, "x") {
0000000000000000000000000000000000000000;;			return name + "es"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name + "s"
0000000000000000000000000000000000000000;;	}
