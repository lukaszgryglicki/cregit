0000000000000000000000000000000000000000;;	package client
a70eec3531b96f9fd5397f7cec9cd89ffcaafa47;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gorilla/websocket"
0000000000000000000000000000000000000000;;		"github.com/pkg/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SELF       = "self"
0000000000000000000000000000000000000000;;		COLLECTION = "collection"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		debug  = false
0000000000000000000000000000000000000000;;		dialer = &websocket.Dialer{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientOpts struct {
0000000000000000000000000000000000000000;;		Url       string
0000000000000000000000000000000000000000;;		AccessKey string
0000000000000000000000000000000000000000;;		SecretKey string
0000000000000000000000000000000000000000;;		Timeout   time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ApiError struct {
0000000000000000000000000000000000000000;;		StatusCode int
0000000000000000000000000000000000000000;;		Url        string
0000000000000000000000000000000000000000;;		Msg        string
0000000000000000000000000000000000000000;;		Status     string
0000000000000000000000000000000000000000;;		Body       string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ApiError) Error() string {
0000000000000000000000000000000000000000;;		return e.Msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsNotFound(err error) bool {
0000000000000000000000000000000000000000;;		apiError, ok := err.(*ApiError)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return apiError.StatusCode == http.StatusNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newApiError(resp *http.Response, url string) *ApiError {
0000000000000000000000000000000000000000;;		contents, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		var body string
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			body = "Unreadable body."
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			body = string(contents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if json.Unmarshal(contents, &data) == nil {
0000000000000000000000000000000000000000;;			delete(data, "id")
0000000000000000000000000000000000000000;;			delete(data, "links")
0000000000000000000000000000000000000000;;			delete(data, "actions")
0000000000000000000000000000000000000000;;			delete(data, "type")
0000000000000000000000000000000000000000;;			delete(data, "status")
0000000000000000000000000000000000000000;;			buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			for k, v := range data {
0000000000000000000000000000000000000000;;				if v == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if buf.Len() > 0 {
0000000000000000000000000000000000000000;;					buf.WriteString(", ")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "%s=%v", k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body = buf.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		formattedMsg := fmt.Sprintf("Bad response statusCode [%d]. Status [%s]. Body: [%s] from [%s]",
0000000000000000000000000000000000000000;;			resp.StatusCode, resp.Status, body, url)
0000000000000000000000000000000000000000;;		return &ApiError{
0000000000000000000000000000000000000000;;			Url:        url,
0000000000000000000000000000000000000000;;			Msg:        formattedMsg,
0000000000000000000000000000000000000000;;			StatusCode: resp.StatusCode,
0000000000000000000000000000000000000000;;			Status:     resp.Status,
0000000000000000000000000000000000000000;;			Body:       body,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(array []string, item string) bool {
0000000000000000000000000000000000000000;;		for _, check := range array {
0000000000000000000000000000000000000000;;			if check == item {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendFilters(urlString string, filters map[string]interface{}) (string, error) {
0000000000000000000000000000000000000000;;		if len(filters) == 0 {
0000000000000000000000000000000000000000;;			return urlString, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u, err := url.Parse(urlString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q := u.Query()
0000000000000000000000000000000000000000;;		for k, v := range filters {
0000000000000000000000000000000000000000;;			if l, ok := v.([]string); ok {
0000000000000000000000000000000000000000;;				for _, v := range l {
0000000000000000000000000000000000000000;;					q.Add(k, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				q.Add(k, fmt.Sprintf("%v", v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.RawQuery = q.Encode()
0000000000000000000000000000000000000000;;		return u.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupRancherBaseClient(rancherClient *RancherBaseClientImpl, opts *ClientOpts) error {
0000000000000000000000000000000000000000;;		if opts.Timeout == 0 {
0000000000000000000000000000000000000000;;			opts.Timeout = time.Second * 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client := &http.Client{Timeout: opts.Timeout}
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", opts.Url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.SetBasicAuth(opts.AccessKey, opts.SecretKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;			return newApiError(resp, opts.Url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schemasUrls := resp.Header.Get("X-API-Schemas")
0000000000000000000000000000000000000000;;		if len(schemasUrls) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("Failed to find schema at [" + opts.Url + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if schemasUrls != opts.Url {
0000000000000000000000000000000000000000;;			req, err = http.NewRequest("GET", schemasUrls, nil)
0000000000000000000000000000000000000000;;			req.SetBasicAuth(opts.AccessKey, opts.SecretKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err = client.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;				return newApiError(resp, opts.Url)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var schemas Schemas
0000000000000000000000000000000000000000;;		bytes, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = json.Unmarshal(bytes, &schemas)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rancherClient.Opts = opts
0000000000000000000000000000000000000000;;		rancherClient.Schemas = &schemas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, schema := range schemas.Data {
0000000000000000000000000000000000000000;;			rancherClient.Types[schema.Id] = schema
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewListOpts() *ListOpts {
0000000000000000000000000000000000000000;;		return &ListOpts{
0000000000000000000000000000000000000000;;			Filters: map[string]interface{}{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) setupRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		req.SetBasicAuth(rancherClient.Opts.AccessKey, rancherClient.Opts.SecretKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) newHttpClient() *http.Client {
0000000000000000000000000000000000000000;;		if rancherClient.Opts.Timeout == 0 {
0000000000000000000000000000000000000000;;			rancherClient.Opts.Timeout = time.Second * 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &http.Client{Timeout: rancherClient.Opts.Timeout}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doDelete(url string) error {
0000000000000000000000000000000000000000;;		client := rancherClient.newHttpClient()
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("DELETE", url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rancherClient.setupRequest(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		io.Copy(ioutil.Discard, resp.Body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			return newApiError(resp, url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) Websocket(url string, headers map[string][]string) (*websocket.Conn, *http.Response, error) {
0000000000000000000000000000000000000000;;		return dialer.Dial(url, http.Header(headers))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doGet(url string, opts *ListOpts, respObject interface{}) error {
0000000000000000000000000000000000000000;;		if opts == nil {
0000000000000000000000000000000000000000;;			opts = NewListOpts()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		url, err := appendFilters(url, opts.Filters)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if debug {
0000000000000000000000000000000000000000;;			fmt.Println("GET " + url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := rancherClient.newHttpClient()
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rancherClient.setupRequest(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;			return newApiError(resp, url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		byteContent, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if debug {
0000000000000000000000000000000000000000;;			fmt.Println("Response <= " + string(byteContent))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(byteContent, respObject); err != nil {
0000000000000000000000000000000000000000;;			return errors.Wrap(err, fmt.Sprintf("Failed to parse: %s", byteContent))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) List(schemaType string, opts *ListOpts, respObject interface{}) error {
0000000000000000000000000000000000000000;;		return rancherClient.doList(schemaType, opts, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doList(schemaType string, opts *ListOpts, respObject interface{}) error {
0000000000000000000000000000000000000000;;		schema, ok := rancherClient.Types[schemaType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Unknown schema type [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !contains(schema.CollectionMethods, "GET") {
0000000000000000000000000000000000000000;;			return errors.New("Resource type [" + schemaType + "] is not listable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		collectionUrl, ok := schema.Links[COLLECTION]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Failed to find collection URL for [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rancherClient.doGet(collectionUrl, opts, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) Post(url string, createObj interface{}, respObject interface{}) error {
0000000000000000000000000000000000000000;;		return rancherClient.doModify("POST", url, createObj, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) GetLink(resource Resource, link string, respObject interface{}) error {
0000000000000000000000000000000000000000;;		url := resource.Links[link]
0000000000000000000000000000000000000000;;		if url == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to find link: %s", link)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rancherClient.doGet(url, &ListOpts{}, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doModify(method string, url string, createObj interface{}, respObject interface{}) error {
0000000000000000000000000000000000000000;;		bodyContent, err := json.Marshal(createObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if debug {
0000000000000000000000000000000000000000;;			fmt.Println(method + " " + url)
0000000000000000000000000000000000000000;;			fmt.Println("Request => " + string(bodyContent))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := rancherClient.newHttpClient()
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(method, url, bytes.NewBuffer(bodyContent))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rancherClient.setupRequest(req)
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Length", string(len(bodyContent)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			return newApiError(resp, url)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		byteContent, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(byteContent) > 0 {
0000000000000000000000000000000000000000;;			if debug {
0000000000000000000000000000000000000000;;				fmt.Println("Response <= " + string(byteContent))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return json.Unmarshal(byteContent, respObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) Create(schemaType string, createObj interface{}, respObject interface{}) error {
0000000000000000000000000000000000000000;;		return rancherClient.doCreate(schemaType, createObj, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doCreate(schemaType string, createObj interface{}, respObject interface{}) error {
0000000000000000000000000000000000000000;;		if createObj == nil {
0000000000000000000000000000000000000000;;			createObj = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if respObject == nil {
0000000000000000000000000000000000000000;;			respObject = &map[string]interface{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		schema, ok := rancherClient.Types[schemaType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Unknown schema type [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !contains(schema.CollectionMethods, "POST") {
0000000000000000000000000000000000000000;;			return errors.New("Resource type [" + schemaType + "] is not creatable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var collectionUrl string
0000000000000000000000000000000000000000;;		collectionUrl, ok = schema.Links[COLLECTION]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// return errors.New("Failed to find collection URL for [" + schemaType + "]")
0000000000000000000000000000000000000000;;			// This is a hack to address https://github.com/rancher/cattle/issues/254
0000000000000000000000000000000000000000;;			re := regexp.MustCompile("schemas.*")
0000000000000000000000000000000000000000;;			collectionUrl = re.ReplaceAllString(schema.Links[SELF], schema.PluralName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rancherClient.doModify("POST", collectionUrl, createObj, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) Update(schemaType string, existing *Resource, updates interface{}, respObject interface{}) error {
0000000000000000000000000000000000000000;;		return rancherClient.doUpdate(schemaType, existing, updates, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doUpdate(schemaType string, existing *Resource, updates interface{}, respObject interface{}) error {
0000000000000000000000000000000000000000;;		if existing == nil {
0000000000000000000000000000000000000000;;			return errors.New("Existing object is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfUrl, ok := existing.Links[SELF]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New(fmt.Sprintf("Failed to find self URL of [%v]", existing))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if updates == nil {
0000000000000000000000000000000000000000;;			updates = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if respObject == nil {
0000000000000000000000000000000000000000;;			respObject = &map[string]interface{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schema, ok := rancherClient.Types[schemaType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Unknown schema type [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !contains(schema.ResourceMethods, "PUT") {
0000000000000000000000000000000000000000;;			return errors.New("Resource type [" + schemaType + "] is not updatable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rancherClient.doModify("PUT", selfUrl, updates, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) ById(schemaType string, id string, respObject interface{}) error {
0000000000000000000000000000000000000000;;		return rancherClient.doById(schemaType, id, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doById(schemaType string, id string, respObject interface{}) error {
0000000000000000000000000000000000000000;;		schema, ok := rancherClient.Types[schemaType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Unknown schema type [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !contains(schema.ResourceMethods, "GET") {
0000000000000000000000000000000000000000;;			return errors.New("Resource type [" + schemaType + "] can not be looked up by ID")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		collectionUrl, ok := schema.Links[COLLECTION]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Failed to find collection URL for [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := rancherClient.doGet(collectionUrl+"/"+id, nil, respObject)
0000000000000000000000000000000000000000;;		//TODO check for 404 and return nil, nil
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) Delete(existing *Resource) error {
0000000000000000000000000000000000000000;;		if existing == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rancherClient.doResourceDelete(existing.Type, existing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doResourceDelete(schemaType string, existing *Resource) error {
0000000000000000000000000000000000000000;;		schema, ok := rancherClient.Types[schemaType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Unknown schema type [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !contains(schema.ResourceMethods, "DELETE") {
0000000000000000000000000000000000000000;;			return errors.New("Resource type [" + schemaType + "] can not be deleted")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfUrl, ok := existing.Links[SELF]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New(fmt.Sprintf("Failed to find self URL of [%v]", existing))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rancherClient.doDelete(selfUrl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) Reload(existing *Resource, output interface{}) error {
0000000000000000000000000000000000000000;;		selfUrl, ok := existing.Links[SELF]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New(fmt.Sprintf("Failed to find self URL of [%v]", existing))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rancherClient.doGet(selfUrl, NewListOpts(), output)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) Action(schemaType string, action string,
0000000000000000000000000000000000000000;;		existing *Resource, inputObject, respObject interface{}) error {
0000000000000000000000000000000000000000;;		return rancherClient.doAction(schemaType, action, existing, inputObject, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rancherClient *RancherBaseClientImpl) doAction(schemaType string, action string,
0000000000000000000000000000000000000000;;		existing *Resource, inputObject, respObject interface{}) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if existing == nil {
0000000000000000000000000000000000000000;;			return errors.New("Existing object is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actionUrl, ok := existing.Actions[action]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New(fmt.Sprintf("Action [%v] not available on [%v]", action, existing))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, ok = rancherClient.Types[schemaType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("Unknown schema type [" + schemaType + "]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var input io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if inputObject != nil {
0000000000000000000000000000000000000000;;			bodyContent, err := json.Marshal(inputObject)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if debug {
0000000000000000000000000000000000000000;;				fmt.Println("Request => " + string(bodyContent))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			input = bytes.NewBuffer(bodyContent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := rancherClient.newHttpClient()
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", actionUrl, input)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rancherClient.setupRequest(req)
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Length", "0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			return newApiError(resp, actionUrl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		byteContent, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if debug {
0000000000000000000000000000000000000000;;			fmt.Println("Response <= " + string(byteContent))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Unmarshal(byteContent, respObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		debug = os.Getenv("RANCHER_CLIENT_DEBUG") == "true"
0000000000000000000000000000000000000000;;		if debug {
0000000000000000000000000000000000000000;;			fmt.Println("Rancher client debug on")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
