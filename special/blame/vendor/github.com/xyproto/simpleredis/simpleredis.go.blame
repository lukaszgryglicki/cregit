0000000000000000000000000000000000000000;;	// Easy way to use Redis from Go.
0000000000000000000000000000000000000000;;	package simpleredis
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/xyproto/simpleredis/simpleredis.go[Godeps/_workspace/src/github.com/xyproto/simpleredis/simpleredis.go][vendor/github.com/xyproto/simpleredis/simpleredis.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/garyburd/redigo/redis"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Common for each of the redis datastructures used here
0000000000000000000000000000000000000000;;	type redisDatastructure struct {
0000000000000000000000000000000000000000;;		pool    *ConnectionPool
0000000000000000000000000000000000000000;;		id      string
0000000000000000000000000000000000000000;;		dbindex int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type (
0000000000000000000000000000000000000000;;		// A pool of readily available Redis connections
0000000000000000000000000000000000000000;;		ConnectionPool redis.Pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		List     redisDatastructure
0000000000000000000000000000000000000000;;		Set      redisDatastructure
0000000000000000000000000000000000000000;;		HashMap  redisDatastructure
0000000000000000000000000000000000000000;;		KeyValue redisDatastructure
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Version number. Stable API within major version numbers.
0000000000000000000000000000000000000000;;		Version = 1.0
0000000000000000000000000000000000000000;;		// The default [url]:port that Redis is running at
0000000000000000000000000000000000000000;;		defaultRedisServer = ":6379"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// How many connections should stay ready for requests, at a maximum?
0000000000000000000000000000000000000000;;		// When an idle connection is used, new idle connections are created.
0000000000000000000000000000000000000000;;		maxIdleConnections = 3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- Helper functions --- */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connect to the local instance of Redis at port 6379
0000000000000000000000000000000000000000;;	func newRedisConnection() (redis.Conn, error) {
0000000000000000000000000000000000000000;;		return newRedisConnectionTo(defaultRedisServer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connect to host:port, host may be omitted, so ":6379" is valid.
0000000000000000000000000000000000000000;;	// Will not try to AUTH with any given password (password@host:port).
0000000000000000000000000000000000000000;;	func newRedisConnectionTo(hostColonPort string) (redis.Conn, error) {
0000000000000000000000000000000000000000;;		// Discard the password, if provided
0000000000000000000000000000000000000000;;		if _, theRest, ok := twoFields(hostColonPort, "@"); ok {
0000000000000000000000000000000000000000;;			hostColonPort = theRest
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hostColonPort = strings.TrimSpace(hostColonPort)
0000000000000000000000000000000000000000;;		return redis.Dial("tcp", hostColonPort)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a string from a list of results at a given position
0000000000000000000000000000000000000000;;	func getString(bi []interface{}, i int) string {
0000000000000000000000000000000000000000;;		return string(bi[i].([]uint8))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if the local Redis server is up and running
0000000000000000000000000000000000000000;;	func TestConnection() (err error) {
0000000000000000000000000000000000000000;;		return TestConnectionHost(defaultRedisServer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if a given Redis server at host:port is up and running.
0000000000000000000000000000000000000000;;	// Does not try to PING or AUTH.
0000000000000000000000000000000000000000;;	func TestConnectionHost(hostColonPort string) (err error) {
0000000000000000000000000000000000000000;;		// Connect to the given host:port
0000000000000000000000000000000000000000;;		conn, err := newRedisConnectionTo(hostColonPort)
0000000000000000000000000000000000000000;;		if conn != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if r := recover(); r != nil {
0000000000000000000000000000000000000000;;				err = errors.New("Could not connect to redis server: " + hostColonPort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- ConnectionPool functions --- */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new connection pool
0000000000000000000000000000000000000000;;	func NewConnectionPool() *ConnectionPool {
0000000000000000000000000000000000000000;;		// The second argument is the maximum number of idle connections
0000000000000000000000000000000000000000;;		redisPool := redis.NewPool(newRedisConnection, maxIdleConnections)
0000000000000000000000000000000000000000;;		pool := ConnectionPool(*redisPool)
0000000000000000000000000000000000000000;;		return &pool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Split a string into two parts, given a delimiter.
0000000000000000000000000000000000000000;;	// Returns the two parts and true if it works out.
0000000000000000000000000000000000000000;;	func twoFields(s, delim string) (string, string, bool) {
0000000000000000000000000000000000000000;;		if strings.Count(s, delim) != 1 {
0000000000000000000000000000000000000000;;			return s, "", false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fields := strings.Split(s, delim)
0000000000000000000000000000000000000000;;		return fields[0], fields[1], true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new connection pool given a host:port string.
0000000000000000000000000000000000000000;;	// A password may be supplied as well, on the form "password@host:port".
0000000000000000000000000000000000000000;;	func NewConnectionPoolHost(hostColonPort string) *ConnectionPool {
0000000000000000000000000000000000000000;;		// Create a redis Pool
0000000000000000000000000000000000000000;;		redisPool := redis.NewPool(
0000000000000000000000000000000000000000;;			// Anonymous function for calling new RedisConnectionTo with the host:port
0000000000000000000000000000000000000000;;			func() (redis.Conn, error) {
0000000000000000000000000000000000000000;;				conn, err := newRedisConnectionTo(hostColonPort)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If a password is given, use it to authenticate
0000000000000000000000000000000000000000;;				if password, _, ok := twoFields(hostColonPort, "@"); ok {
0000000000000000000000000000000000000000;;					if password != "" {
0000000000000000000000000000000000000000;;						if _, err := conn.Do("AUTH", password); err != nil {
0000000000000000000000000000000000000000;;							conn.Close()
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return conn, err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// Maximum number of idle connections to the redis database
0000000000000000000000000000000000000000;;			maxIdleConnections)
0000000000000000000000000000000000000000;;		pool := ConnectionPool(*redisPool)
0000000000000000000000000000000000000000;;		return &pool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the number of maximum *idle* connections standing ready when
0000000000000000000000000000000000000000;;	// creating new connection pools. When an idle connection is used,
0000000000000000000000000000000000000000;;	// a new idle connection is created. The default is 3 and should be fine
0000000000000000000000000000000000000000;;	// for most cases.
0000000000000000000000000000000000000000;;	func SetMaxIdleConnections(maximum int) {
0000000000000000000000000000000000000000;;		maxIdleConnections = maximum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get one of the available connections from the connection pool, given a database index
0000000000000000000000000000000000000000;;	func (pool *ConnectionPool) Get(dbindex int) redis.Conn {
0000000000000000000000000000000000000000;;		redisPool := redis.Pool(*pool)
0000000000000000000000000000000000000000;;		conn := redisPool.Get()
0000000000000000000000000000000000000000;;		// The default database index is 0
0000000000000000000000000000000000000000;;		if dbindex != 0 {
0000000000000000000000000000000000000000;;			// SELECT is not critical, ignore the return values
0000000000000000000000000000000000000000;;			conn.Do("SELECT", strconv.Itoa(dbindex))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ping the server by sending a PING command
0000000000000000000000000000000000000000;;	func (pool *ConnectionPool) Ping() (pong bool) {
0000000000000000000000000000000000000000;;		redisPool := redis.Pool(*pool)
0000000000000000000000000000000000000000;;		conn := redisPool.Get()
0000000000000000000000000000000000000000;;		_, err := conn.Do("PING")
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close down the connection pool
0000000000000000000000000000000000000000;;	func (pool *ConnectionPool) Close() {
0000000000000000000000000000000000000000;;		redisPool := redis.Pool(*pool)
0000000000000000000000000000000000000000;;		redisPool.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- List functions --- */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new list
0000000000000000000000000000000000000000;;	func NewList(pool *ConnectionPool, id string) *List {
0000000000000000000000000000000000000000;;		return &List{pool, id, 0}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Select a different database
0000000000000000000000000000000000000000;;	func (rl *List) SelectDatabase(dbindex int) {
0000000000000000000000000000000000000000;;		rl.dbindex = dbindex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add an element to the list
0000000000000000000000000000000000000000;;	func (rl *List) Add(value string) error {
0000000000000000000000000000000000000000;;		conn := rl.pool.Get(rl.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("RPUSH", rl.id, value)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get all elements of a list
0000000000000000000000000000000000000000;;	func (rl *List) GetAll() ([]string, error) {
0000000000000000000000000000000000000000;;		conn := rl.pool.Get(rl.dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.Values(conn.Do("LRANGE", rl.id, "0", "-1"))
0000000000000000000000000000000000000000;;		strs := make([]string, len(result))
0000000000000000000000000000000000000000;;		for i := 0; i < len(result); i++ {
0000000000000000000000000000000000000000;;			strs[i] = getString(result, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strs, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the last element of a list
0000000000000000000000000000000000000000;;	func (rl *List) GetLast() (string, error) {
0000000000000000000000000000000000000000;;		conn := rl.pool.Get(rl.dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.Values(conn.Do("LRANGE", rl.id, "-1", "-1"))
0000000000000000000000000000000000000000;;		if len(result) == 1 {
0000000000000000000000000000000000000000;;			return getString(result, 0), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the last N elements of a list
0000000000000000000000000000000000000000;;	func (rl *List) GetLastN(n int) ([]string, error) {
0000000000000000000000000000000000000000;;		conn := rl.pool.Get(rl.dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.Values(conn.Do("LRANGE", rl.id, "-"+strconv.Itoa(n), "-1"))
0000000000000000000000000000000000000000;;		strs := make([]string, len(result))
0000000000000000000000000000000000000000;;		for i := 0; i < len(result); i++ {
0000000000000000000000000000000000000000;;			strs[i] = getString(result, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strs, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove this list
0000000000000000000000000000000000000000;;	func (rl *List) Remove() error {
0000000000000000000000000000000000000000;;		conn := rl.pool.Get(rl.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("DEL", rl.id)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- Set functions --- */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new set
0000000000000000000000000000000000000000;;	func NewSet(pool *ConnectionPool, id string) *Set {
0000000000000000000000000000000000000000;;		return &Set{pool, id, 0}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Select a different database
0000000000000000000000000000000000000000;;	func (rs *Set) SelectDatabase(dbindex int) {
0000000000000000000000000000000000000000;;		rs.dbindex = dbindex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add an element to the set
0000000000000000000000000000000000000000;;	func (rs *Set) Add(value string) error {
0000000000000000000000000000000000000000;;		conn := rs.pool.Get(rs.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("SADD", rs.id, value)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a given value is in the set
0000000000000000000000000000000000000000;;	func (rs *Set) Has(value string) (bool, error) {
0000000000000000000000000000000000000000;;		conn := rs.pool.Get(rs.dbindex)
0000000000000000000000000000000000000000;;		retval, err := conn.Do("SISMEMBER", rs.id, value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return redis.Bool(retval, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get all elements of the set
0000000000000000000000000000000000000000;;	func (rs *Set) GetAll() ([]string, error) {
0000000000000000000000000000000000000000;;		conn := rs.pool.Get(rs.dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.Values(conn.Do("SMEMBERS", rs.id))
0000000000000000000000000000000000000000;;		strs := make([]string, len(result))
0000000000000000000000000000000000000000;;		for i := 0; i < len(result); i++ {
0000000000000000000000000000000000000000;;			strs[i] = getString(result, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strs, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove an element from the set
0000000000000000000000000000000000000000;;	func (rs *Set) Del(value string) error {
0000000000000000000000000000000000000000;;		conn := rs.pool.Get(rs.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("SREM", rs.id, value)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove this set
0000000000000000000000000000000000000000;;	func (rs *Set) Remove() error {
0000000000000000000000000000000000000000;;		conn := rs.pool.Get(rs.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("DEL", rs.id)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- HashMap functions --- */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new hashmap
0000000000000000000000000000000000000000;;	func NewHashMap(pool *ConnectionPool, id string) *HashMap {
0000000000000000000000000000000000000000;;		return &HashMap{pool, id, 0}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Select a different database
0000000000000000000000000000000000000000;;	func (rh *HashMap) SelectDatabase(dbindex int) {
0000000000000000000000000000000000000000;;		rh.dbindex = dbindex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set a value in a hashmap given the element id (for instance a user id) and the key (for instance "password")
0000000000000000000000000000000000000000;;	func (rh *HashMap) Set(elementid, key, value string) error {
0000000000000000000000000000000000000000;;		conn := rh.pool.Get(rh.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("HSET", rh.id+":"+elementid, key, value)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a value from a hashmap given the element id (for instance a user id) and the key (for instance "password")
0000000000000000000000000000000000000000;;	func (rh *HashMap) Get(elementid, key string) (string, error) {
0000000000000000000000000000000000000000;;		conn := rh.pool.Get(rh.dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.String(conn.Do("HGET", rh.id+":"+elementid, key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a given elementid + key is in the hash map
0000000000000000000000000000000000000000;;	func (rh *HashMap) Has(elementid, key string) (bool, error) {
0000000000000000000000000000000000000000;;		conn := rh.pool.Get(rh.dbindex)
0000000000000000000000000000000000000000;;		retval, err := conn.Do("HEXISTS", rh.id+":"+elementid, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return redis.Bool(retval, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a given elementid exists as a hash map at all
0000000000000000000000000000000000000000;;	func (rh *HashMap) Exists(elementid string) (bool, error) {
0000000000000000000000000000000000000000;;		// TODO: key is not meant to be a wildcard, check for "*"
0000000000000000000000000000000000000000;;		return hasKey(rh.pool, rh.id+":"+elementid, rh.dbindex)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get all elementid's for all hash elements
0000000000000000000000000000000000000000;;	func (rh *HashMap) GetAll() ([]string, error) {
0000000000000000000000000000000000000000;;		conn := rh.pool.Get(rh.dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.Values(conn.Do("KEYS", rh.id+":*"))
0000000000000000000000000000000000000000;;		strs := make([]string, len(result))
0000000000000000000000000000000000000000;;		idlen := len(rh.id)
0000000000000000000000000000000000000000;;		for i := 0; i < len(result); i++ {
0000000000000000000000000000000000000000;;			strs[i] = getString(result, i)[idlen+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strs, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove a key for an entry in a hashmap (for instance the email field for a user)
0000000000000000000000000000000000000000;;	func (rh *HashMap) DelKey(elementid, key string) error {
0000000000000000000000000000000000000000;;		conn := rh.pool.Get(rh.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("HDEL", rh.id+":"+elementid, key)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove an element (for instance a user)
0000000000000000000000000000000000000000;;	func (rh *HashMap) Del(elementid string) error {
0000000000000000000000000000000000000000;;		conn := rh.pool.Get(rh.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("DEL", rh.id+":"+elementid)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove this hashmap
0000000000000000000000000000000000000000;;	func (rh *HashMap) Remove() error {
0000000000000000000000000000000000000000;;		conn := rh.pool.Get(rh.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("DEL", rh.id)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* --- KeyValue functions --- */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new key/value
0000000000000000000000000000000000000000;;	func NewKeyValue(pool *ConnectionPool, id string) *KeyValue {
0000000000000000000000000000000000000000;;		return &KeyValue{pool, id, 0}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Select a different database
0000000000000000000000000000000000000000;;	func (rkv *KeyValue) SelectDatabase(dbindex int) {
0000000000000000000000000000000000000000;;		rkv.dbindex = dbindex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set a key and value
0000000000000000000000000000000000000000;;	func (rkv *KeyValue) Set(key, value string) error {
0000000000000000000000000000000000000000;;		conn := rkv.pool.Get(rkv.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("SET", rkv.id+":"+key, value)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a value given a key
0000000000000000000000000000000000000000;;	func (rkv *KeyValue) Get(key string) (string, error) {
0000000000000000000000000000000000000000;;		conn := rkv.pool.Get(rkv.dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.String(conn.Do("GET", rkv.id+":"+key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove a key
0000000000000000000000000000000000000000;;	func (rkv *KeyValue) Del(key string) error {
0000000000000000000000000000000000000000;;		conn := rkv.pool.Get(rkv.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("DEL", rkv.id+":"+key)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove this key/value
0000000000000000000000000000000000000000;;	func (rkv *KeyValue) Remove() error {
0000000000000000000000000000000000000000;;		conn := rkv.pool.Get(rkv.dbindex)
0000000000000000000000000000000000000000;;		_, err := conn.Do("DEL", rkv.id)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// --- Generic redis functions ---
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a key exists. The key can be a wildcard (ie. "user*").
0000000000000000000000000000000000000000;;	func hasKey(pool *ConnectionPool, wildcard string, dbindex int) (bool, error) {
0000000000000000000000000000000000000000;;		conn := pool.Get(dbindex)
0000000000000000000000000000000000000000;;		result, err := redis.Values(conn.Do("KEYS", wildcard))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(result) > 0, nil
0000000000000000000000000000000000000000;;	}
