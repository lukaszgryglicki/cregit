0000000000000000000000000000000000000000;;	// Package filters provides helper function to parse and handle command line
0000000000000000000000000000000000000000;;	// filter, used for example in docker ps or docker images commands.
0000000000000000000000000000000000000000;;	package filters
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/types/filters/parse.go[Godeps/_workspace/src/github.com/docker/engine-api/types/filters/parse.go][vendor/github.com/docker/engine-api/types/filters/parse.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types/versions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Args stores filter arguments as map key:{map key: bool}.
0000000000000000000000000000000000000000;;	// It contains an aggregation of the map of arguments (which are in the form
0000000000000000000000000000000000000000;;	// of -f 'key=value') based on the key, and stores values for the same key
0000000000000000000000000000000000000000;;	// in a map with string keys and boolean values.
0000000000000000000000000000000000000000;;	// e.g given -f 'label=label1=1' -f 'label=label2=2' -f 'image.name=ubuntu'
0000000000000000000000000000000000000000;;	// the args will be {"image.name":{"ubuntu":true},"label":{"label1=1":true,"label2=2":true}}
0000000000000000000000000000000000000000;;	type Args struct {
0000000000000000000000000000000000000000;;		fields map[string]map[string]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewArgs initializes a new Args struct.
0000000000000000000000000000000000000000;;	func NewArgs() Args {
0000000000000000000000000000000000000000;;		return Args{fields: map[string]map[string]bool{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseFlag parses the argument to the filter flag. Like
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   `docker ps -f 'created=today' -f 'image.name=ubuntu*'`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If prev map is provided, then it is appended to, and returned. By default a new
0000000000000000000000000000000000000000;;	// map is created.
0000000000000000000000000000000000000000;;	func ParseFlag(arg string, prev Args) (Args, error) {
0000000000000000000000000000000000000000;;		filters := prev
0000000000000000000000000000000000000000;;		if len(arg) == 0 {
0000000000000000000000000000000000000000;;			return filters, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.Contains(arg, "=") {
0000000000000000000000000000000000000000;;			return filters, ErrBadFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := strings.SplitN(arg, "=", 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := strings.ToLower(strings.TrimSpace(f[0]))
0000000000000000000000000000000000000000;;		value := strings.TrimSpace(f[1])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filters.Add(name, value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filters, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrBadFormat is an error returned in case of bad format for a filter.
0000000000000000000000000000000000000000;;	var ErrBadFormat = errors.New("bad format of filter (expected name=value)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToParam packs the Args into a string for easy transport from client to server.
0000000000000000000000000000000000000000;;	func ToParam(a Args) (string, error) {
0000000000000000000000000000000000000000;;		// this way we don't URL encode {}, just empty space
0000000000000000000000000000000000000000;;		if a.Len() == 0 {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf, err := json.Marshal(a.fields)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToParamWithVersion packs the Args into a string for easy transport from client to server.
0000000000000000000000000000000000000000;;	// The generated string will depend on the specified version (corresponding to the API version).
0000000000000000000000000000000000000000;;	func ToParamWithVersion(version string, a Args) (string, error) {
0000000000000000000000000000000000000000;;		// this way we don't URL encode {}, just empty space
0000000000000000000000000000000000000000;;		if a.Len() == 0 {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for daemons older than v1.10, filter must be of the form map[string][]string
0000000000000000000000000000000000000000;;		buf := []byte{}
0000000000000000000000000000000000000000;;		err := errors.New("")
0000000000000000000000000000000000000000;;		if version != "" && versions.LessThan(version, "1.22") {
0000000000000000000000000000000000000000;;			buf, err = json.Marshal(convertArgsToSlice(a.fields))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			buf, err = json.Marshal(a.fields)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromParam unpacks the filter Args.
0000000000000000000000000000000000000000;;	func FromParam(p string) (Args, error) {
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return NewArgs(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := strings.NewReader(p)
0000000000000000000000000000000000000000;;		d := json.NewDecoder(r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := map[string]map[string]bool{}
0000000000000000000000000000000000000000;;		if err := d.Decode(&m); err != nil {
0000000000000000000000000000000000000000;;			r.Seek(0, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Allow parsing old arguments in slice format.
0000000000000000000000000000000000000000;;			// Because other libraries might be sending them in this format.
0000000000000000000000000000000000000000;;			deprecated := map[string][]string{}
0000000000000000000000000000000000000000;;			if deprecatedErr := d.Decode(&deprecated); deprecatedErr == nil {
0000000000000000000000000000000000000000;;				m = deprecatedArgs(deprecated)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return NewArgs(), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Args{m}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the list of values associates with a field.
0000000000000000000000000000000000000000;;	// It returns a slice of strings to keep backwards compatibility with old code.
0000000000000000000000000000000000000000;;	func (filters Args) Get(field string) []string {
0000000000000000000000000000000000000000;;		values := filters.fields[field]
0000000000000000000000000000000000000000;;		if values == nil {
0000000000000000000000000000000000000000;;			return make([]string, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slice := make([]string, 0, len(values))
0000000000000000000000000000000000000000;;		for key := range values {
0000000000000000000000000000000000000000;;			slice = append(slice, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return slice
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a new value to a filter field.
0000000000000000000000000000000000000000;;	func (filters Args) Add(name, value string) {
0000000000000000000000000000000000000000;;		if _, ok := filters.fields[name]; ok {
0000000000000000000000000000000000000000;;			filters.fields[name][value] = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			filters.fields[name] = map[string]bool{value: true}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Del removes a value from a filter field.
0000000000000000000000000000000000000000;;	func (filters Args) Del(name, value string) {
0000000000000000000000000000000000000000;;		if _, ok := filters.fields[name]; ok {
0000000000000000000000000000000000000000;;			delete(filters.fields[name], value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of fields in the arguments.
0000000000000000000000000000000000000000;;	func (filters Args) Len() int {
0000000000000000000000000000000000000000;;		return len(filters.fields)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchKVList returns true if the values for the specified field matches the ones
0000000000000000000000000000000000000000;;	// from the sources.
0000000000000000000000000000000000000000;;	// e.g. given Args are {'label': {'label1=1','label2=1'}, 'image.name', {'ubuntu'}},
0000000000000000000000000000000000000000;;	//      field is 'label' and sources are {'label1': '1', 'label2': '2'}
0000000000000000000000000000000000000000;;	//      it returns true.
0000000000000000000000000000000000000000;;	func (filters Args) MatchKVList(field string, sources map[string]string) bool {
0000000000000000000000000000000000000000;;		fieldValues := filters.fields[field]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//do not filter if there is no filter set or cannot determine filter
0000000000000000000000000000000000000000;;		if len(fieldValues) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sources == nil || len(sources) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name2match := range fieldValues {
0000000000000000000000000000000000000000;;			testKV := strings.SplitN(name2match, "=", 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v, ok := sources[testKV[0]]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(testKV) == 2 && testKV[1] != v {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match returns true if the values for the specified field matches the source string
0000000000000000000000000000000000000000;;	// e.g. given Args are {'label': {'label1=1','label2=1'}, 'image.name', {'ubuntu'}},
0000000000000000000000000000000000000000;;	//      field is 'image.name' and source is 'ubuntu'
0000000000000000000000000000000000000000;;	//      it returns true.
0000000000000000000000000000000000000000;;	func (filters Args) Match(field, source string) bool {
0000000000000000000000000000000000000000;;		if filters.ExactMatch(field, source) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldValues := filters.fields[field]
0000000000000000000000000000000000000000;;		for name2match := range fieldValues {
0000000000000000000000000000000000000000;;			match, err := regexp.MatchString(name2match, source)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if match {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExactMatch returns true if the source matches exactly one of the filters.
0000000000000000000000000000000000000000;;	func (filters Args) ExactMatch(field, source string) bool {
0000000000000000000000000000000000000000;;		fieldValues, ok := filters.fields[field]
0000000000000000000000000000000000000000;;		//do not filter if there is no filter set or cannot determine filter
0000000000000000000000000000000000000000;;		if !ok || len(fieldValues) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to match full name value to avoid O(N) regular expression matching
0000000000000000000000000000000000000000;;		if fieldValues[source] {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FuzzyMatch returns true if the source matches exactly one of the filters,
0000000000000000000000000000000000000000;;	// or the source has one of the filters as a prefix.
0000000000000000000000000000000000000000;;	func (filters Args) FuzzyMatch(field, source string) bool {
0000000000000000000000000000000000000000;;		if filters.ExactMatch(field, source) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldValues := filters.fields[field]
0000000000000000000000000000000000000000;;		for prefix := range fieldValues {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(source, prefix) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Include returns true if the name of the field to filter is in the filters.
0000000000000000000000000000000000000000;;	func (filters Args) Include(field string) bool {
0000000000000000000000000000000000000000;;		_, ok := filters.fields[field]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate ensures that all the fields in the filter are valid.
0000000000000000000000000000000000000000;;	// It returns an error as soon as it finds an invalid field.
0000000000000000000000000000000000000000;;	func (filters Args) Validate(accepted map[string]bool) error {
0000000000000000000000000000000000000000;;		for name := range filters.fields {
0000000000000000000000000000000000000000;;			if !accepted[name] {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Invalid filter '%s'", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WalkValues iterates over the list of filtered values for a field.
0000000000000000000000000000000000000000;;	// It stops the iteration if it finds an error and it returns that error.
0000000000000000000000000000000000000000;;	func (filters Args) WalkValues(field string, op func(value string) error) error {
0000000000000000000000000000000000000000;;		if _, ok := filters.fields[field]; !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for v := range filters.fields[field] {
0000000000000000000000000000000000000000;;			if err := op(v); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deprecatedArgs(d map[string][]string) map[string]map[string]bool {
0000000000000000000000000000000000000000;;		m := map[string]map[string]bool{}
0000000000000000000000000000000000000000;;		for k, v := range d {
0000000000000000000000000000000000000000;;			values := map[string]bool{}
0000000000000000000000000000000000000000;;			for _, vv := range v {
0000000000000000000000000000000000000000;;				values[vv] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m[k] = values
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertArgsToSlice(f map[string]map[string]bool) map[string][]string {
0000000000000000000000000000000000000000;;		m := map[string][]string{}
0000000000000000000000000000000000000000;;		for k, v := range f {
0000000000000000000000000000000000000000;;			values := []string{}
0000000000000000000000000000000000000000;;			for kk := range v {
0000000000000000000000000000000000000000;;				if v[kk] {
0000000000000000000000000000000000000000;;					values = append(values, kk)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m[k] = values
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
