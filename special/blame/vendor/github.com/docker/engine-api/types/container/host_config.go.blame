0000000000000000000000000000000000000000;;	package container
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/types/container/host_config.go[Godeps/_workspace/src/github.com/docker/engine-api/types/container/host_config.go][vendor/github.com/docker/engine-api/types/container/host_config.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types/blkiodev"
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types/strslice"
0000000000000000000000000000000000000000;;		"github.com/docker/go-connections/nat"
0000000000000000000000000000000000000000;;		"github.com/docker/go-units"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkMode represents the container network stack.
0000000000000000000000000000000000000000;;	type NetworkMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Isolation represents the isolation technology of a container. The supported
0000000000000000000000000000000000000000;;	// values are platform specific
0000000000000000000000000000000000000000;;	type Isolation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDefault indicates the default isolation technology of a container. On Linux this
0000000000000000000000000000000000000000;;	// is the native driver. On Windows, this is a Windows Server Container.
0000000000000000000000000000000000000000;;	func (i Isolation) IsDefault() bool {
0000000000000000000000000000000000000000;;		return strings.ToLower(string(i)) == "default" || string(i) == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IpcMode represents the container ipc stack.
0000000000000000000000000000000000000000;;	type IpcMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrivate indicates whether the container uses its private ipc stack.
0000000000000000000000000000000000000000;;	func (n IpcMode) IsPrivate() bool {
0000000000000000000000000000000000000000;;		return !(n.IsHost() || n.IsContainer())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHost indicates whether the container uses the host's ipc stack.
0000000000000000000000000000000000000000;;	func (n IpcMode) IsHost() bool {
0000000000000000000000000000000000000000;;		return n == "host"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsContainer indicates whether the container uses a container's ipc stack.
0000000000000000000000000000000000000000;;	func (n IpcMode) IsContainer() bool {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(string(n), ":", 2)
0000000000000000000000000000000000000000;;		return len(parts) > 1 && parts[0] == "container"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid indicates whether the ipc stack is valid.
0000000000000000000000000000000000000000;;	func (n IpcMode) Valid() bool {
0000000000000000000000000000000000000000;;		parts := strings.Split(string(n), ":")
0000000000000000000000000000000000000000;;		switch mode := parts[0]; mode {
0000000000000000000000000000000000000000;;		case "", "host":
0000000000000000000000000000000000000000;;		case "container":
0000000000000000000000000000000000000000;;			if len(parts) != 2 || parts[1] == "" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container returns the name of the container ipc stack is going to be used.
0000000000000000000000000000000000000000;;	func (n IpcMode) Container() string {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(string(n), ":", 2)
0000000000000000000000000000000000000000;;		if len(parts) > 1 {
0000000000000000000000000000000000000000;;			return parts[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UsernsMode represents userns mode in the container.
0000000000000000000000000000000000000000;;	type UsernsMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHost indicates whether the container uses the host's userns.
0000000000000000000000000000000000000000;;	func (n UsernsMode) IsHost() bool {
0000000000000000000000000000000000000000;;		return n == "host"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrivate indicates whether the container uses the a private userns.
0000000000000000000000000000000000000000;;	func (n UsernsMode) IsPrivate() bool {
0000000000000000000000000000000000000000;;		return !(n.IsHost())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid indicates whether the userns is valid.
0000000000000000000000000000000000000000;;	func (n UsernsMode) Valid() bool {
0000000000000000000000000000000000000000;;		parts := strings.Split(string(n), ":")
0000000000000000000000000000000000000000;;		switch mode := parts[0]; mode {
0000000000000000000000000000000000000000;;		case "", "host":
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CgroupSpec represents the cgroup to use for the container.
0000000000000000000000000000000000000000;;	type CgroupSpec string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsContainer indicates whether the container is using another container cgroup
0000000000000000000000000000000000000000;;	func (c CgroupSpec) IsContainer() bool {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(string(c), ":", 2)
0000000000000000000000000000000000000000;;		return len(parts) > 1 && parts[0] == "container"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid indicates whether the cgroup spec is valid.
0000000000000000000000000000000000000000;;	func (c CgroupSpec) Valid() bool {
0000000000000000000000000000000000000000;;		return c.IsContainer() || c == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container returns the name of the container whose cgroup will be used.
0000000000000000000000000000000000000000;;	func (c CgroupSpec) Container() string {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(string(c), ":", 2)
0000000000000000000000000000000000000000;;		if len(parts) > 1 {
0000000000000000000000000000000000000000;;			return parts[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTSMode represents the UTS namespace of the container.
0000000000000000000000000000000000000000;;	type UTSMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrivate indicates whether the container uses its private UTS namespace.
0000000000000000000000000000000000000000;;	func (n UTSMode) IsPrivate() bool {
0000000000000000000000000000000000000000;;		return !(n.IsHost())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHost indicates whether the container uses the host's UTS namespace.
0000000000000000000000000000000000000000;;	func (n UTSMode) IsHost() bool {
0000000000000000000000000000000000000000;;		return n == "host"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid indicates whether the UTS namespace is valid.
0000000000000000000000000000000000000000;;	func (n UTSMode) Valid() bool {
0000000000000000000000000000000000000000;;		parts := strings.Split(string(n), ":")
0000000000000000000000000000000000000000;;		switch mode := parts[0]; mode {
0000000000000000000000000000000000000000;;		case "", "host":
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PidMode represents the pid namespace of the container.
0000000000000000000000000000000000000000;;	type PidMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrivate indicates whether the container uses its own new pid namespace.
0000000000000000000000000000000000000000;;	func (n PidMode) IsPrivate() bool {
0000000000000000000000000000000000000000;;		return !(n.IsHost() || n.IsContainer())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHost indicates whether the container uses the host's pid namespace.
0000000000000000000000000000000000000000;;	func (n PidMode) IsHost() bool {
0000000000000000000000000000000000000000;;		return n == "host"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsContainer indicates whether the container uses a container's pid namespace.
0000000000000000000000000000000000000000;;	func (n PidMode) IsContainer() bool {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(string(n), ":", 2)
0000000000000000000000000000000000000000;;		return len(parts) > 1 && parts[0] == "container"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid indicates whether the pid namespace is valid.
0000000000000000000000000000000000000000;;	func (n PidMode) Valid() bool {
0000000000000000000000000000000000000000;;		parts := strings.Split(string(n), ":")
0000000000000000000000000000000000000000;;		switch mode := parts[0]; mode {
0000000000000000000000000000000000000000;;		case "", "host":
0000000000000000000000000000000000000000;;		case "container":
0000000000000000000000000000000000000000;;			if len(parts) != 2 || parts[1] == "" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container returns the name of the container whose pid namespace is going to be used.
0000000000000000000000000000000000000000;;	func (n PidMode) Container() string {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(string(n), ":", 2)
0000000000000000000000000000000000000000;;		if len(parts) > 1 {
0000000000000000000000000000000000000000;;			return parts[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeviceMapping represents the device mapping between the host and the container.
0000000000000000000000000000000000000000;;	type DeviceMapping struct {
0000000000000000000000000000000000000000;;		PathOnHost        string
0000000000000000000000000000000000000000;;		PathInContainer   string
0000000000000000000000000000000000000000;;		CgroupPermissions string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestartPolicy represents the restart policies of the container.
0000000000000000000000000000000000000000;;	type RestartPolicy struct {
0000000000000000000000000000000000000000;;		Name              string
0000000000000000000000000000000000000000;;		MaximumRetryCount int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNone indicates whether the container has the "no" restart policy.
0000000000000000000000000000000000000000;;	// This means the container will not automatically restart when exiting.
0000000000000000000000000000000000000000;;	func (rp *RestartPolicy) IsNone() bool {
0000000000000000000000000000000000000000;;		return rp.Name == "no"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAlways indicates whether the container has the "always" restart policy.
0000000000000000000000000000000000000000;;	// This means the container will automatically restart regardless of the exit status.
0000000000000000000000000000000000000000;;	func (rp *RestartPolicy) IsAlways() bool {
0000000000000000000000000000000000000000;;		return rp.Name == "always"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsOnFailure indicates whether the container has the "on-failure" restart policy.
0000000000000000000000000000000000000000;;	// This means the container will automatically restart of exiting with a non-zero exit status.
0000000000000000000000000000000000000000;;	func (rp *RestartPolicy) IsOnFailure() bool {
0000000000000000000000000000000000000000;;		return rp.Name == "on-failure"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUnlessStopped indicates whether the container has the
0000000000000000000000000000000000000000;;	// "unless-stopped" restart policy. This means the container will
0000000000000000000000000000000000000000;;	// automatically restart unless user has put it to stopped state.
0000000000000000000000000000000000000000;;	func (rp *RestartPolicy) IsUnlessStopped() bool {
0000000000000000000000000000000000000000;;		return rp.Name == "unless-stopped"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSame compares two RestartPolicy to see if they are the same
0000000000000000000000000000000000000000;;	func (rp *RestartPolicy) IsSame(tp *RestartPolicy) bool {
0000000000000000000000000000000000000000;;		return rp.Name == tp.Name && rp.MaximumRetryCount == tp.MaximumRetryCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogConfig represents the logging configuration of the container.
0000000000000000000000000000000000000000;;	type LogConfig struct {
0000000000000000000000000000000000000000;;		Type   string
0000000000000000000000000000000000000000;;		Config map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resources contains container's resources (cgroups config, ulimits...)
0000000000000000000000000000000000000000;;	type Resources struct {
0000000000000000000000000000000000000000;;		// Applicable to all platforms
0000000000000000000000000000000000000000;;		CPUShares int64 `json:"CpuShares"` // CPU shares (relative weight vs. other containers)
0000000000000000000000000000000000000000;;		Memory    int64 // Memory limit (in bytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Applicable to UNIX platforms
0000000000000000000000000000000000000000;;		CgroupParent         string // Parent cgroup.
0000000000000000000000000000000000000000;;		BlkioWeight          uint16 // Block IO weight (relative weight vs. other containers)
0000000000000000000000000000000000000000;;		BlkioWeightDevice    []*blkiodev.WeightDevice
0000000000000000000000000000000000000000;;		BlkioDeviceReadBps   []*blkiodev.ThrottleDevice
0000000000000000000000000000000000000000;;		BlkioDeviceWriteBps  []*blkiodev.ThrottleDevice
0000000000000000000000000000000000000000;;		BlkioDeviceReadIOps  []*blkiodev.ThrottleDevice
0000000000000000000000000000000000000000;;		BlkioDeviceWriteIOps []*blkiodev.ThrottleDevice
0000000000000000000000000000000000000000;;		CPUPeriod            int64           `json:"CpuPeriod"` // CPU CFS (Completely Fair Scheduler) period
0000000000000000000000000000000000000000;;		CPUQuota             int64           `json:"CpuQuota"`  // CPU CFS (Completely Fair Scheduler) quota
0000000000000000000000000000000000000000;;		CpusetCpus           string          // CpusetCpus 0-2, 0,1
0000000000000000000000000000000000000000;;		CpusetMems           string          // CpusetMems 0-2, 0,1
0000000000000000000000000000000000000000;;		Devices              []DeviceMapping // List of devices to map inside the container
0000000000000000000000000000000000000000;;		DiskQuota            int64           // Disk limit (in bytes)
0000000000000000000000000000000000000000;;		KernelMemory         int64           // Kernel memory limit (in bytes)
0000000000000000000000000000000000000000;;		MemoryReservation    int64           // Memory soft limit (in bytes)
0000000000000000000000000000000000000000;;		MemorySwap           int64           // Total memory usage (memory + swap); set `-1` to enable unlimited swap
0000000000000000000000000000000000000000;;		MemorySwappiness     *int64          // Tuning container memory swappiness behaviour
0000000000000000000000000000000000000000;;		OomKillDisable       *bool           // Whether to disable OOM Killer or not
0000000000000000000000000000000000000000;;		PidsLimit            int64           // Setting pids limit for a container
0000000000000000000000000000000000000000;;		Ulimits              []*units.Ulimit // List of ulimits to be set in the container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Applicable to Windows
0000000000000000000000000000000000000000;;		CPUCount                int64  `json:"CpuCount"`   // CPU count
0000000000000000000000000000000000000000;;		CPUPercent              int64  `json:"CpuPercent"` // CPU percent
0000000000000000000000000000000000000000;;		IOMaximumIOps           uint64 // Maximum IOps for the container system drive
0000000000000000000000000000000000000000;;		IOMaximumBandwidth      uint64 // Maximum IO in bytes per second for the container system drive
0000000000000000000000000000000000000000;;		NetworkMaximumBandwidth uint64 // Maximum bandwidth of the network endpoint in bytes per second
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateConfig holds the mutable attributes of a Container.
0000000000000000000000000000000000000000;;	// Those attributes can be updated at runtime.
0000000000000000000000000000000000000000;;	type UpdateConfig struct {
0000000000000000000000000000000000000000;;		// Contains container's resources (cgroups, ulimits)
0000000000000000000000000000000000000000;;		Resources
0000000000000000000000000000000000000000;;		RestartPolicy RestartPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostConfig the non-portable Config structure of a container.
0000000000000000000000000000000000000000;;	// Here, "non-portable" means "dependent of the host we are running on".
0000000000000000000000000000000000000000;;	// Portable information *should* appear in Config.
0000000000000000000000000000000000000000;;	type HostConfig struct {
0000000000000000000000000000000000000000;;		// Applicable to all platforms
0000000000000000000000000000000000000000;;		Binds           []string      // List of volume bindings for this container
0000000000000000000000000000000000000000;;		ContainerIDFile string        // File (path) where the containerId is written
0000000000000000000000000000000000000000;;		LogConfig       LogConfig     // Configuration of the logs for this container
0000000000000000000000000000000000000000;;		NetworkMode     NetworkMode   // Network mode to use for the container
0000000000000000000000000000000000000000;;		PortBindings    nat.PortMap   // Port mapping between the exposed port (container) and the host
0000000000000000000000000000000000000000;;		RestartPolicy   RestartPolicy // Restart policy to be used for the container
0000000000000000000000000000000000000000;;		AutoRemove      bool          // Automatically remove container when it exits
0000000000000000000000000000000000000000;;		VolumeDriver    string        // Name of the volume driver used to mount volumes
0000000000000000000000000000000000000000;;		VolumesFrom     []string      // List of volumes to take from other container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Applicable to UNIX platforms
0000000000000000000000000000000000000000;;		CapAdd          strslice.StrSlice // List of kernel capabilities to add to the container
0000000000000000000000000000000000000000;;		CapDrop         strslice.StrSlice // List of kernel capabilities to remove from the container
0000000000000000000000000000000000000000;;		DNS             []string          `json:"Dns"`        // List of DNS server to lookup
0000000000000000000000000000000000000000;;		DNSOptions      []string          `json:"DnsOptions"` // List of DNSOption to look for
0000000000000000000000000000000000000000;;		DNSSearch       []string          `json:"DnsSearch"`  // List of DNSSearch to look for
0000000000000000000000000000000000000000;;		ExtraHosts      []string          // List of extra hosts
0000000000000000000000000000000000000000;;		GroupAdd        []string          // List of additional groups that the container process will run as
0000000000000000000000000000000000000000;;		IpcMode         IpcMode           // IPC namespace to use for the container
0000000000000000000000000000000000000000;;		Cgroup          CgroupSpec        // Cgroup to use for the container
0000000000000000000000000000000000000000;;		Links           []string          // List of links (in the name:alias form)
0000000000000000000000000000000000000000;;		OomScoreAdj     int               // Container preference for OOM-killing
0000000000000000000000000000000000000000;;		PidMode         PidMode           // PID namespace to use for the container
0000000000000000000000000000000000000000;;		Privileged      bool              // Is the container in privileged mode
0000000000000000000000000000000000000000;;		PublishAllPorts bool              // Should docker publish all exposed port for the container
0000000000000000000000000000000000000000;;		ReadonlyRootfs  bool              // Is the container root filesystem in read-only
0000000000000000000000000000000000000000;;		SecurityOpt     []string          // List of string values to customize labels for MLS systems, such as SELinux.
0000000000000000000000000000000000000000;;		StorageOpt      map[string]string // Storage driver options per container.
0000000000000000000000000000000000000000;;		Tmpfs           map[string]string `json:",omitempty"` // List of tmpfs (mounts) used for the container
0000000000000000000000000000000000000000;;		UTSMode         UTSMode           // UTS namespace to use for the container
0000000000000000000000000000000000000000;;		UsernsMode      UsernsMode        // The user namespace to use for the container
0000000000000000000000000000000000000000;;		ShmSize         int64             // Total shm memory usage
0000000000000000000000000000000000000000;;		Sysctls         map[string]string `json:",omitempty"` // List of Namespaced sysctls used for the container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Applicable to Windows
0000000000000000000000000000000000000000;;		ConsoleSize [2]int    // Initial console size
0000000000000000000000000000000000000000;;		Isolation   Isolation // Isolation technology of the container (eg default, hyperv)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Contains container's resources (cgroups, ulimits)
0000000000000000000000000000000000000000;;		Resources
0000000000000000000000000000000000000000;;	}
