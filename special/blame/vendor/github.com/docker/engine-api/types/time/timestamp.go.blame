0000000000000000000000000000000000000000;;	package time
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/types/time/timestamp.go[Godeps/_workspace/src/github.com/docker/engine-api/types/time/timestamp.go][vendor/github.com/docker/engine-api/types/time/timestamp.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are additional predefined layouts for use in Time.Format and Time.Parse
0000000000000000000000000000000000000000;;	// with --since and --until parameters for `docker logs` and `docker events`
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rFC3339Local     = "2006-01-02T15:04:05"           // RFC3339 with local timezone
0000000000000000000000000000000000000000;;		rFC3339NanoLocal = "2006-01-02T15:04:05.999999999" // RFC3339Nano with local timezone
0000000000000000000000000000000000000000;;		dateWithZone     = "2006-01-02Z07:00"              // RFC3339 with time at 00:00:00
0000000000000000000000000000000000000000;;		dateLocal        = "2006-01-02"                    // RFC3339 with local timezone and time at 00:00:00
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTimestamp tries to parse given string as golang duration,
0000000000000000000000000000000000000000;;	// then RFC3339 time and finally as a Unix timestamp. If
0000000000000000000000000000000000000000;;	// any of these were successful, it returns a Unix timestamp
0000000000000000000000000000000000000000;;	// as string otherwise returns the given value back.
0000000000000000000000000000000000000000;;	// In case of duration input, the returned timestamp is computed
0000000000000000000000000000000000000000;;	// as the given reference time minus the amount of the duration.
0000000000000000000000000000000000000000;;	func GetTimestamp(value string, reference time.Time) (string, error) {
0000000000000000000000000000000000000000;;		if d, err := time.ParseDuration(value); value != "0" && err == nil {
0000000000000000000000000000000000000000;;			return strconv.FormatInt(reference.Add(-d).Unix(), 10), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var format string
0000000000000000000000000000000000000000;;		var parseInLocation bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the string has a Z or a + or three dashes use parse otherwise use parseinlocation
0000000000000000000000000000000000000000;;		parseInLocation = !(strings.ContainsAny(value, "zZ+") || strings.Count(value, "-") == 3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.Contains(value, ".") {
0000000000000000000000000000000000000000;;			if parseInLocation {
0000000000000000000000000000000000000000;;				format = rFC3339NanoLocal
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				format = time.RFC3339Nano
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if strings.Contains(value, "T") {
0000000000000000000000000000000000000000;;			// we want the number of colons in the T portion of the timestamp
0000000000000000000000000000000000000000;;			tcolons := strings.Count(value, ":")
0000000000000000000000000000000000000000;;			// if parseInLocation is off and we have a +/- zone offset (not Z) then
0000000000000000000000000000000000000000;;			// there will be an extra colon in the input for the tz offset subtract that
0000000000000000000000000000000000000000;;			// colon from the tcolons count
0000000000000000000000000000000000000000;;			if !parseInLocation && !strings.ContainsAny(value, "zZ") && tcolons > 0 {
0000000000000000000000000000000000000000;;				tcolons--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parseInLocation {
0000000000000000000000000000000000000000;;				switch tcolons {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					format = "2006-01-02T15"
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					format = "2006-01-02T15:04"
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					format = rFC3339Local
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch tcolons {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					format = "2006-01-02T15Z07:00"
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					format = "2006-01-02T15:04Z07:00"
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					format = time.RFC3339
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if parseInLocation {
0000000000000000000000000000000000000000;;			format = dateLocal
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			format = dateWithZone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var t time.Time
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parseInLocation {
0000000000000000000000000000000000000000;;			t, err = time.ParseInLocation(format, value, time.FixedZone(reference.Zone()))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t, err = time.Parse(format, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if there is a `-` then its an RFC3339 like timestamp otherwise assume unixtimestamp
0000000000000000000000000000000000000000;;			if strings.Contains(value, "-") {
0000000000000000000000000000000000000000;;				return "", err // was probably an RFC3339 like timestamp but the parser failed with an error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return value, nil // unixtimestamp in and out case (meaning: the value passed at the command line is already in the right format for passing to the server)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d.%09d", t.Unix(), int64(t.Nanosecond())), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseTimestamps returns seconds and nanoseconds from a timestamp that has the
0000000000000000000000000000000000000000;;	// format "%d.%09d", time.Unix(), int64(time.Nanosecond()))
0000000000000000000000000000000000000000;;	// if the incoming nanosecond portion is longer or shorter than 9 digits it is
0000000000000000000000000000000000000000;;	// converted to nanoseconds.  The expectation is that the seconds and
0000000000000000000000000000000000000000;;	// seconds will be used to create a time variable.  For example:
0000000000000000000000000000000000000000;;	//     seconds, nanoseconds, err := ParseTimestamp("1136073600.000000001",0)
0000000000000000000000000000000000000000;;	//     if err == nil since := time.Unix(seconds, nanoseconds)
0000000000000000000000000000000000000000;;	// returns seconds as def(aultSeconds) if value == ""
0000000000000000000000000000000000000000;;	func ParseTimestamps(value string, def int64) (int64, int64, error) {
0000000000000000000000000000000000000000;;		if value == "" {
0000000000000000000000000000000000000000;;			return def, 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa := strings.SplitN(value, ".", 2)
0000000000000000000000000000000000000000;;		s, err := strconv.ParseInt(sa[0], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return s, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(sa) != 2 {
0000000000000000000000000000000000000000;;			return s, 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(sa[1], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return s, n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// should already be in nanoseconds but just in case convert n to nanoseonds
0000000000000000000000000000000000000000;;		n = int64(float64(n) * math.Pow(float64(10), float64(9-len(sa[1]))))
0000000000000000000000000000000000000000;;		return s, n, nil
0000000000000000000000000000000000000000;;	}
