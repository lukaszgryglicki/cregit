0000000000000000000000000000000000000000;;	package client
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/client/image_build.go[Godeps/_workspace/src/github.com/docker/engine-api/client/image_build.go][vendor/github.com/docker/engine-api/client/image_build.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var headerRegexp = regexp.MustCompile(`\ADocker/.+\s\((.+)\)\z`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImageBuild sends request to the daemon to build images.
0000000000000000000000000000000000000000;;	// The Body in the response implement an io.ReadCloser and it's up to the caller to
0000000000000000000000000000000000000000;;	// close it.
0000000000000000000000000000000000000000;;	func (cli *Client) ImageBuild(ctx context.Context, buildContext io.Reader, options types.ImageBuildOptions) (types.ImageBuildResponse, error) {
0000000000000000000000000000000000000000;;		query, err := imageBuildOptionsToQuery(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return types.ImageBuildResponse{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := http.Header(make(map[string][]string))
0000000000000000000000000000000000000000;;		buf, err := json.Marshal(options.AuthConfigs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return types.ImageBuildResponse{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headers.Add("X-Registry-Config", base64.URLEncoding.EncodeToString(buf))
0000000000000000000000000000000000000000;;		headers.Set("Content-Type", "application/tar")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverResp, err := cli.postRaw(ctx, "/build", query, buildContext, headers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return types.ImageBuildResponse{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		osType := getDockerOS(serverResp.header.Get("Server"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return types.ImageBuildResponse{
0000000000000000000000000000000000000000;;			Body:   serverResp.body,
0000000000000000000000000000000000000000;;			OSType: osType,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func imageBuildOptionsToQuery(options types.ImageBuildOptions) (url.Values, error) {
0000000000000000000000000000000000000000;;		query := url.Values{
0000000000000000000000000000000000000000;;			"t": options.Tags,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.SuppressOutput {
0000000000000000000000000000000000000000;;			query.Set("q", "1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.RemoteContext != "" {
0000000000000000000000000000000000000000;;			query.Set("remote", options.RemoteContext)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.NoCache {
0000000000000000000000000000000000000000;;			query.Set("nocache", "1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.Remove {
0000000000000000000000000000000000000000;;			query.Set("rm", "1")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			query.Set("rm", "0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.ForceRemove {
0000000000000000000000000000000000000000;;			query.Set("forcerm", "1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.PullParent {
0000000000000000000000000000000000000000;;			query.Set("pull", "1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !container.Isolation.IsDefault(options.Isolation) {
0000000000000000000000000000000000000000;;			query.Set("isolation", string(options.Isolation))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		query.Set("cpusetcpus", options.CPUSetCPUs)
0000000000000000000000000000000000000000;;		query.Set("cpusetmems", options.CPUSetMems)
0000000000000000000000000000000000000000;;		query.Set("cpushares", strconv.FormatInt(options.CPUShares, 10))
0000000000000000000000000000000000000000;;		query.Set("cpuquota", strconv.FormatInt(options.CPUQuota, 10))
0000000000000000000000000000000000000000;;		query.Set("cpuperiod", strconv.FormatInt(options.CPUPeriod, 10))
0000000000000000000000000000000000000000;;		query.Set("memory", strconv.FormatInt(options.Memory, 10))
0000000000000000000000000000000000000000;;		query.Set("memswap", strconv.FormatInt(options.MemorySwap, 10))
0000000000000000000000000000000000000000;;		query.Set("cgroupparent", options.CgroupParent)
0000000000000000000000000000000000000000;;		query.Set("shmsize", strconv.FormatInt(options.ShmSize, 10))
0000000000000000000000000000000000000000;;		query.Set("dockerfile", options.Dockerfile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ulimitsJSON, err := json.Marshal(options.Ulimits)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return query, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		query.Set("ulimits", string(ulimitsJSON))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buildArgsJSON, err := json.Marshal(options.BuildArgs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return query, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		query.Set("buildargs", string(buildArgsJSON))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelsJSON, err := json.Marshal(options.Labels)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return query, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		query.Set("labels", string(labelsJSON))
0000000000000000000000000000000000000000;;		return query, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDockerOS(serverHeader string) string {
0000000000000000000000000000000000000000;;		var osType string
0000000000000000000000000000000000000000;;		matches := headerRegexp.FindStringSubmatch(serverHeader)
0000000000000000000000000000000000000000;;		if len(matches) > 0 {
0000000000000000000000000000000000000000;;			osType = matches[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return osType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertKVStringsToMap converts ["key=value"] to {"key":"value"}
0000000000000000000000000000000000000000;;	func convertKVStringsToMap(values []string) map[string]string {
0000000000000000000000000000000000000000;;		result := make(map[string]string, len(values))
0000000000000000000000000000000000000000;;		for _, value := range values {
0000000000000000000000000000000000000000;;			kv := strings.SplitN(value, "=", 2)
0000000000000000000000000000000000000000;;			if len(kv) == 1 {
0000000000000000000000000000000000000000;;				result[kv[0]] = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				result[kv[0]] = kv[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
