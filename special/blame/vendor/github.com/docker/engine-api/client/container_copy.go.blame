0000000000000000000000000000000000000000;;	package client
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/client/container_copy.go[Godeps/_workspace/src/github.com/docker/engine-api/client/container_copy.go][vendor/github.com/docker/engine-api/client/container_copy.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStatPath returns Stat information about a path inside the container filesystem.
0000000000000000000000000000000000000000;;	func (cli *Client) ContainerStatPath(ctx context.Context, containerID, path string) (types.ContainerPathStat, error) {
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		query.Set("path", filepath.ToSlash(path)) // Normalize the paths used in the API.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		urlStr := fmt.Sprintf("/containers/%s/archive", containerID)
0000000000000000000000000000000000000000;;		response, err := cli.head(ctx, urlStr, query, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return types.ContainerPathStat{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer ensureReaderClosed(response)
0000000000000000000000000000000000000000;;		return getContainerPathStatFromHeader(response.header)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyToContainer copies content into the container filesystem.
0000000000000000000000000000000000000000;;	func (cli *Client) CopyToContainer(ctx context.Context, container, path string, content io.Reader, options types.CopyToContainerOptions) error {
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		query.Set("path", filepath.ToSlash(path)) // Normalize the paths used in the API.
0000000000000000000000000000000000000000;;		// Do not allow for an existing directory to be overwritten by a non-directory and vice versa.
0000000000000000000000000000000000000000;;		if !options.AllowOverwriteDirWithFile {
0000000000000000000000000000000000000000;;			query.Set("noOverwriteDirNonDir", "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiPath := fmt.Sprintf("/containers/%s/archive", container)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := cli.putRaw(ctx, apiPath, query, content, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer ensureReaderClosed(response)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.statusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected status code from daemon: %d", response.statusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyFromContainer gets the content from the container and returns it as a Reader
0000000000000000000000000000000000000000;;	// to manipulate it in the host. It's up to the caller to close the reader.
0000000000000000000000000000000000000000;;	func (cli *Client) CopyFromContainer(ctx context.Context, container, srcPath string) (io.ReadCloser, types.ContainerPathStat, error) {
0000000000000000000000000000000000000000;;		query := make(url.Values, 1)
0000000000000000000000000000000000000000;;		query.Set("path", filepath.ToSlash(srcPath)) // Normalize the paths used in the API.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiPath := fmt.Sprintf("/containers/%s/archive", container)
0000000000000000000000000000000000000000;;		response, err := cli.get(ctx, apiPath, query, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, types.ContainerPathStat{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.statusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return nil, types.ContainerPathStat{}, fmt.Errorf("unexpected status code from daemon: %d", response.statusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In order to get the copy behavior right, we need to know information
0000000000000000000000000000000000000000;;		// about both the source and the destination. The response headers include
0000000000000000000000000000000000000000;;		// stat info about the source that we can use in deciding exactly how to
0000000000000000000000000000000000000000;;		// copy it locally. Along with the stat info about the local destination,
0000000000000000000000000000000000000000;;		// we have everything we need to handle the multiple possibilities there
0000000000000000000000000000000000000000;;		// can be when copying a file/dir from one location to another file/dir.
0000000000000000000000000000000000000000;;		stat, err := getContainerPathStatFromHeader(response.header)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, stat, fmt.Errorf("unable to get resource stat from response: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return response.body, stat, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getContainerPathStatFromHeader(header http.Header) (types.ContainerPathStat, error) {
0000000000000000000000000000000000000000;;		var stat types.ContainerPathStat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encodedStat := header.Get("X-Docker-Container-Path-Stat")
0000000000000000000000000000000000000000;;		statDecoder := base64.NewDecoder(base64.StdEncoding, strings.NewReader(encodedStat))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.NewDecoder(statDecoder).Decode(&stat)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("unable to decode container path stat header: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stat, err
0000000000000000000000000000000000000000;;	}
