0000000000000000000000000000000000000000;;	package client
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/client/request.go[Godeps/_workspace/src/github.com/docker/engine-api/client/request.go][vendor/github.com/docker/engine-api/client/request.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/client/transport/cancellable"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serverResponse is a wrapper for http API responses.
0000000000000000000000000000000000000000;;	type serverResponse struct {
0000000000000000000000000000000000000000;;		body       io.ReadCloser
0000000000000000000000000000000000000000;;		header     http.Header
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// head sends an http request to the docker API using the method HEAD.
0000000000000000000000000000000000000000;;	func (cli *Client) head(ctx context.Context, path string, query url.Values, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		return cli.sendRequest(ctx, "HEAD", path, query, nil, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getWithContext sends an http request to the docker API using the method GET with a specific go context.
0000000000000000000000000000000000000000;;	func (cli *Client) get(ctx context.Context, path string, query url.Values, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		return cli.sendRequest(ctx, "GET", path, query, nil, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// postWithContext sends an http request to the docker API using the method POST with a specific go context.
0000000000000000000000000000000000000000;;	func (cli *Client) post(ctx context.Context, path string, query url.Values, obj interface{}, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		return cli.sendRequest(ctx, "POST", path, query, obj, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cli *Client) postRaw(ctx context.Context, path string, query url.Values, body io.Reader, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		return cli.sendClientRequest(ctx, "POST", path, query, body, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// put sends an http request to the docker API using the method PUT.
0000000000000000000000000000000000000000;;	func (cli *Client) put(ctx context.Context, path string, query url.Values, obj interface{}, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		return cli.sendRequest(ctx, "PUT", path, query, obj, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// put sends an http request to the docker API using the method PUT.
0000000000000000000000000000000000000000;;	func (cli *Client) putRaw(ctx context.Context, path string, query url.Values, body io.Reader, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		return cli.sendClientRequest(ctx, "PUT", path, query, body, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delete sends an http request to the docker API using the method DELETE.
0000000000000000000000000000000000000000;;	func (cli *Client) delete(ctx context.Context, path string, query url.Values, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		return cli.sendRequest(ctx, "DELETE", path, query, nil, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cli *Client) sendRequest(ctx context.Context, method, path string, query url.Values, obj interface{}, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		var body io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if obj != nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			body, err = encodeData(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if headers == nil {
0000000000000000000000000000000000000000;;				headers = make(map[string][]string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			headers["Content-Type"] = []string{"application/json"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cli.sendClientRequest(ctx, method, path, query, body, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cli *Client) sendClientRequest(ctx context.Context, method, path string, query url.Values, body io.Reader, headers map[string][]string) (*serverResponse, error) {
0000000000000000000000000000000000000000;;		serverResp := &serverResponse{
0000000000000000000000000000000000000000;;			body:       nil,
0000000000000000000000000000000000000000;;			statusCode: -1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedPayload := (method == "POST" || method == "PUT")
0000000000000000000000000000000000000000;;		if expectedPayload && body == nil {
0000000000000000000000000000000000000000;;			body = bytes.NewReader([]byte{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := cli.newRequest(method, path, query, body, headers)
0000000000000000000000000000000000000000;;		if cli.proto == "unix" || cli.proto == "npipe" {
0000000000000000000000000000000000000000;;			// For local communications, it doesn't matter what the host is. We just
0000000000000000000000000000000000000000;;			// need a valid and meaningful host name. (See #189)
0000000000000000000000000000000000000000;;			req.Host = "docker"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.URL.Host = cli.addr
0000000000000000000000000000000000000000;;		req.URL.Scheme = cli.transport.Scheme()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectedPayload && req.Header.Get("Content-Type") == "" {
0000000000000000000000000000000000000000;;			req.Header.Set("Content-Type", "text/plain")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := cancellable.Do(ctx, cli.transport, req)
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			serverResp.statusCode = resp.StatusCode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isTimeout(err) || strings.Contains(err.Error(), "connection refused") || strings.Contains(err.Error(), "dial unix") {
0000000000000000000000000000000000000000;;				return serverResp, ErrConnectionFailed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !cli.transport.Secure() && strings.Contains(err.Error(), "malformed HTTP response") {
0000000000000000000000000000000000000000;;				return serverResp, fmt.Errorf("%v.\n* Are you trying to connect to a TLS-enabled daemon without TLS?", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cli.transport.Secure() && strings.Contains(err.Error(), "remote error: bad certificate") {
0000000000000000000000000000000000000000;;				return serverResp, fmt.Errorf("The server probably has client authentication (--tlsverify) enabled. Please check your TLS client certification settings: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return serverResp, fmt.Errorf("An error occurred trying to connect: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if serverResp.statusCode < 200 || serverResp.statusCode >= 400 {
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return serverResp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(body) == 0 {
0000000000000000000000000000000000000000;;				return serverResp, fmt.Errorf("Error: request returned %s for API route and version %s, check if the server supports the requested API version", http.StatusText(serverResp.statusCode), req.URL)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return serverResp, fmt.Errorf("Error response from daemon: %s", bytes.TrimSpace(body))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverResp.body = resp.Body
0000000000000000000000000000000000000000;;		serverResp.header = resp.Header
0000000000000000000000000000000000000000;;		return serverResp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cli *Client) newRequest(method, path string, query url.Values, body io.Reader, headers map[string][]string) (*http.Request, error) {
0000000000000000000000000000000000000000;;		apiPath := cli.getAPIPath(path, query)
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(method, apiPath, body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add CLI Config's HTTP Headers BEFORE we set the Docker headers
0000000000000000000000000000000000000000;;		// then the user can't change OUR headers
0000000000000000000000000000000000000000;;		for k, v := range cli.customHTTPHeaders {
0000000000000000000000000000000000000000;;			req.Header.Set(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if headers != nil {
0000000000000000000000000000000000000000;;			for k, v := range headers {
0000000000000000000000000000000000000000;;				req.Header[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return req, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeData(data interface{}) (*bytes.Buffer, error) {
0000000000000000000000000000000000000000;;		params := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		if data != nil {
0000000000000000000000000000000000000000;;			if err := json.NewEncoder(params).Encode(data); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return params, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureReaderClosed(response *serverResponse) {
0000000000000000000000000000000000000000;;		if response != nil && response.body != nil {
0000000000000000000000000000000000000000;;			response.body.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isTimeout(err error) bool {
0000000000000000000000000000000000000000;;		type timeout interface {
0000000000000000000000000000000000000000;;			Timeout() bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := err
0000000000000000000000000000000000000000;;		switch urlErr := err.(type) {
0000000000000000000000000000000000000000;;		case *url.Error:
0000000000000000000000000000000000000000;;			e = urlErr.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, ok := e.(timeout)
0000000000000000000000000000000000000000;;		return ok && t.Timeout()
0000000000000000000000000000000000000000;;	}
