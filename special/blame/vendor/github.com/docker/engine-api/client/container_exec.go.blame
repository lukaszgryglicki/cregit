0000000000000000000000000000000000000000;;	package client
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/client/container_exec.go[Godeps/_workspace/src/github.com/docker/engine-api/client/container_exec.go][vendor/github.com/docker/engine-api/client/container_exec.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerExecCreate creates a new exec configuration to run an exec process.
0000000000000000000000000000000000000000;;	func (cli *Client) ContainerExecCreate(ctx context.Context, container string, config types.ExecConfig) (types.ContainerExecCreateResponse, error) {
0000000000000000000000000000000000000000;;		var response types.ContainerExecCreateResponse
0000000000000000000000000000000000000000;;		resp, err := cli.post(ctx, "/containers/"+container+"/exec", nil, config, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return response, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.body).Decode(&response)
0000000000000000000000000000000000000000;;		ensureReaderClosed(resp)
0000000000000000000000000000000000000000;;		return response, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerExecStart starts an exec process already created in the docker host.
0000000000000000000000000000000000000000;;	func (cli *Client) ContainerExecStart(ctx context.Context, execID string, config types.ExecStartCheck) error {
0000000000000000000000000000000000000000;;		resp, err := cli.post(ctx, "/exec/"+execID+"/start", nil, config, nil)
0000000000000000000000000000000000000000;;		ensureReaderClosed(resp)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerExecAttach attaches a connection to an exec process in the server.
0000000000000000000000000000000000000000;;	// It returns a types.HijackedConnection with the hijacked connection
0000000000000000000000000000000000000000;;	// and the a reader to get output. It's up to the called to close
0000000000000000000000000000000000000000;;	// the hijacked connection by calling types.HijackedResponse.Close.
0000000000000000000000000000000000000000;;	func (cli *Client) ContainerExecAttach(ctx context.Context, execID string, config types.ExecConfig) (types.HijackedResponse, error) {
0000000000000000000000000000000000000000;;		headers := map[string][]string{"Content-Type": {"application/json"}}
0000000000000000000000000000000000000000;;		return cli.postHijacked(ctx, "/exec/"+execID+"/start", nil, config, headers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerExecInspect returns information about a specific exec process on the docker host.
0000000000000000000000000000000000000000;;	func (cli *Client) ContainerExecInspect(ctx context.Context, execID string) (types.ContainerExecInspect, error) {
0000000000000000000000000000000000000000;;		var response types.ContainerExecInspect
0000000000000000000000000000000000000000;;		resp, err := cli.get(ctx, "/exec/"+execID+"/json", nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return response, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.body).Decode(&response)
0000000000000000000000000000000000000000;;		ensureReaderClosed(resp)
0000000000000000000000000000000000000000;;		return response, err
0000000000000000000000000000000000000000;;	}
