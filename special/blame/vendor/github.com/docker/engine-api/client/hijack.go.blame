0000000000000000000000000000000000000000;;	package client
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/client/hijack.go[Godeps/_workspace/src/github.com/docker/engine-api/client/hijack.go][vendor/github.com/docker/engine-api/client/hijack.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/docker/go-connections/sockets"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tlsClientCon holds tls information and a dialed connection.
0000000000000000000000000000000000000000;;	type tlsClientCon struct {
0000000000000000000000000000000000000000;;		*tls.Conn
0000000000000000000000000000000000000000;;		rawConn net.Conn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *tlsClientCon) CloseWrite() error {
0000000000000000000000000000000000000000;;		// Go standard tls.Conn doesn't provide the CloseWrite() method so we do it
0000000000000000000000000000000000000000;;		// on its underlying connection.
0000000000000000000000000000000000000000;;		if conn, ok := c.rawConn.(types.CloseWriter); ok {
0000000000000000000000000000000000000000;;			return conn.CloseWrite()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// postHijacked sends a POST request and hijacks the connection.
0000000000000000000000000000000000000000;;	func (cli *Client) postHijacked(ctx context.Context, path string, query url.Values, body interface{}, headers map[string][]string) (types.HijackedResponse, error) {
0000000000000000000000000000000000000000;;		bodyEncoded, err := encodeData(body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return types.HijackedResponse{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := cli.newRequest("POST", path, query, bodyEncoded, headers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return types.HijackedResponse{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Host = cli.addr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.Header.Set("Connection", "Upgrade")
0000000000000000000000000000000000000000;;		req.Header.Set("Upgrade", "tcp")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := dial(cli.proto, cli.addr, cli.transport.TLSConfig())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if strings.Contains(err.Error(), "connection refused") {
0000000000000000000000000000000000000000;;				return types.HijackedResponse{}, fmt.Errorf("Cannot connect to the Docker daemon. Is 'docker daemon' running on this host?")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return types.HijackedResponse{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When we set up a TCP connection for hijack, there could be long periods
0000000000000000000000000000000000000000;;		// of inactivity (a long running command with no output) that in certain
0000000000000000000000000000000000000000;;		// network setups may cause ECONNTIMEOUT, leaving the client in an unknown
0000000000000000000000000000000000000000;;		// state. Setting TCP KeepAlive on the socket connection will prohibit
0000000000000000000000000000000000000000;;		// ECONNTIMEOUT unless the socket connection truly is broken
0000000000000000000000000000000000000000;;		if tcpConn, ok := conn.(*net.TCPConn); ok {
0000000000000000000000000000000000000000;;			tcpConn.SetKeepAlive(true)
0000000000000000000000000000000000000000;;			tcpConn.SetKeepAlivePeriod(30 * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientconn := httputil.NewClientConn(conn, nil)
0000000000000000000000000000000000000000;;		defer clientconn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Server hijacks the connection, error 'connection closed' expected
0000000000000000000000000000000000000000;;		_, err = clientconn.Do(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rwc, br := clientconn.Hijack()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return types.HijackedResponse{Conn: rwc, Reader: br}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tlsDial(network, addr string, config *tls.Config) (net.Conn, error) {
0000000000000000000000000000000000000000;;		return tlsDialWithDialer(new(net.Dialer), network, addr, config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We need to copy Go's implementation of tls.Dial (pkg/cryptor/tls/tls.go) in
0000000000000000000000000000000000000000;;	// order to return our custom tlsClientCon struct which holds both the tls.Conn
0000000000000000000000000000000000000000;;	// object _and_ its underlying raw connection. The rationale for this is that
0000000000000000000000000000000000000000;;	// we need to be able to close the write end of the connection when attaching,
0000000000000000000000000000000000000000;;	// which tls.Conn does not provide.
0000000000000000000000000000000000000000;;	func tlsDialWithDialer(dialer *net.Dialer, network, addr string, config *tls.Config) (net.Conn, error) {
0000000000000000000000000000000000000000;;		// We want the Timeout and Deadline values from dialer to cover the
0000000000000000000000000000000000000000;;		// whole process: TCP connection and TLS handshake. This means that we
0000000000000000000000000000000000000000;;		// also need to start our own timers now.
0000000000000000000000000000000000000000;;		timeout := dialer.Timeout
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dialer.Deadline.IsZero() {
0000000000000000000000000000000000000000;;			deadlineTimeout := dialer.Deadline.Sub(time.Now())
0000000000000000000000000000000000000000;;			if timeout == 0 || deadlineTimeout < timeout {
0000000000000000000000000000000000000000;;				timeout = deadlineTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errChannel chan error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if timeout != 0 {
0000000000000000000000000000000000000000;;			errChannel = make(chan error, 2)
0000000000000000000000000000000000000000;;			time.AfterFunc(timeout, func() {
0000000000000000000000000000000000000000;;				errChannel <- errors.New("")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyDialer, err := sockets.DialerFromEnvironment(dialer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawConn, err := proxyDialer.Dial(network, addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// When we set up a TCP connection for hijack, there could be long periods
0000000000000000000000000000000000000000;;		// of inactivity (a long running command with no output) that in certain
0000000000000000000000000000000000000000;;		// network setups may cause ECONNTIMEOUT, leaving the client in an unknown
0000000000000000000000000000000000000000;;		// state. Setting TCP KeepAlive on the socket connection will prohibit
0000000000000000000000000000000000000000;;		// ECONNTIMEOUT unless the socket connection truly is broken
0000000000000000000000000000000000000000;;		if tcpConn, ok := rawConn.(*net.TCPConn); ok {
0000000000000000000000000000000000000000;;			tcpConn.SetKeepAlive(true)
0000000000000000000000000000000000000000;;			tcpConn.SetKeepAlivePeriod(30 * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		colonPos := strings.LastIndex(addr, ":")
0000000000000000000000000000000000000000;;		if colonPos == -1 {
0000000000000000000000000000000000000000;;			colonPos = len(addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hostname := addr[:colonPos]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If no ServerName is set, infer the ServerName
0000000000000000000000000000000000000000;;		// from the hostname we're connecting to.
0000000000000000000000000000000000000000;;		if config.ServerName == "" {
0000000000000000000000000000000000000000;;			// Make a copy to avoid polluting argument or default.
0000000000000000000000000000000000000000;;			c := *config
0000000000000000000000000000000000000000;;			c.ServerName = hostname
0000000000000000000000000000000000000000;;			config = &c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn := tls.Client(rawConn, config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if timeout == 0 {
0000000000000000000000000000000000000000;;			err = conn.Handshake()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				errChannel <- conn.Handshake()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = <-errChannel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			rawConn.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is Docker difference with standard's crypto/tls package: returned a
0000000000000000000000000000000000000000;;		// wrapper which holds both the TLS and raw connections.
0000000000000000000000000000000000000000;;		return &tlsClientCon{conn, rawConn}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dial(proto, addr string, tlsConfig *tls.Config) (net.Conn, error) {
0000000000000000000000000000000000000000;;		if tlsConfig != nil && proto != "unix" && proto != "npipe" {
0000000000000000000000000000000000000000;;			// Notice this isn't Go standard's tls.Dial function
0000000000000000000000000000000000000000;;			return tlsDial(proto, addr, tlsConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if proto == "npipe" {
0000000000000000000000000000000000000000;;			return sockets.DialPipe(addr, 32*time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return net.Dial(proto, addr)
0000000000000000000000000000000000000000;;	}
