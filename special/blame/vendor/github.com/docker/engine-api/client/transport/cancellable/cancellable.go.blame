0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/engine-api/client/transport/cancellable/cancellable.go[Godeps/_workspace/src/github.com/docker/engine-api/client/transport/cancellable/cancellable.go][vendor/github.com/docker/engine-api/client/transport/cancellable/cancellable.go];	
0000000000000000000000000000000000000000;;	// Package cancellable provides helper function to cancel http requests.
0000000000000000000000000000000000000000;;	package cancellable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/engine-api/client/transport"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nop() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		testHookContextDoneBeforeHeaders = nop
0000000000000000000000000000000000000000;;		testHookDoReturned               = nop
0000000000000000000000000000000000000000;;		testHookDidBodyClose             = nop
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do sends an HTTP request with the provided transport.Sender and returns an HTTP response.
0000000000000000000000000000000000000000;;	// If the client is nil, http.DefaultClient is used.
0000000000000000000000000000000000000000;;	// If the context is canceled or times out, ctx.Err() will be returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// FORK INFORMATION:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function deviates from the upstream version in golang.org/x/net/context/ctxhttp by
0000000000000000000000000000000000000000;;	// taking a Sender interface rather than a *http.Client directly. That allow us to use
0000000000000000000000000000000000000000;;	// this funcion with mocked clients and hijacked connections.
0000000000000000000000000000000000000000;;	func Do(ctx context.Context, client transport.Sender, req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if client == nil {
0000000000000000000000000000000000000000;;			client = http.DefaultClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Request cancelation changed in Go 1.5, see canceler.go and canceler_go14.go.
0000000000000000000000000000000000000000;;		cancel := canceler(client, req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type responseAndError struct {
0000000000000000000000000000000000000000;;			resp *http.Response
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make(chan responseAndError, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			resp, err := client.Do(req)
0000000000000000000000000000000000000000;;			testHookDoReturned()
0000000000000000000000000000000000000000;;			result <- responseAndError{resp, err}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp *http.Response
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			testHookContextDoneBeforeHeaders()
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;			// Clean up after the goroutine calling client.Do:
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				if r := <-result; r.resp != nil && r.resp.Body != nil {
0000000000000000000000000000000000000000;;					testHookDidBodyClose()
0000000000000000000000000000000000000000;;					r.resp.Body.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			return nil, ctx.Err()
0000000000000000000000000000000000000000;;		case r := <-result:
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			resp, err = r.resp, r.err
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				cancel()
0000000000000000000000000000000000000000;;			case <-c:
0000000000000000000000000000000000000000;;				// The response's Body is closed.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		resp.Body = &notifyingReader{resp.Body, c}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notifyingReader is an io.ReadCloser that closes the notify channel after
0000000000000000000000000000000000000000;;	// Close is called or a Read fails on the underlying ReadCloser.
0000000000000000000000000000000000000000;;	type notifyingReader struct {
0000000000000000000000000000000000000000;;		io.ReadCloser
0000000000000000000000000000000000000000;;		notify chan<- struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *notifyingReader) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		n, err := r.ReadCloser.Read(p)
0000000000000000000000000000000000000000;;		if err != nil && r.notify != nil {
0000000000000000000000000000000000000000;;			close(r.notify)
0000000000000000000000000000000000000000;;			r.notify = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *notifyingReader) Close() error {
0000000000000000000000000000000000000000;;		err := r.ReadCloser.Close()
0000000000000000000000000000000000000000;;		if r.notify != nil {
0000000000000000000000000000000000000000;;			close(r.notify)
0000000000000000000000000000000000000000;;			r.notify = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
