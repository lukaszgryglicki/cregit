0000000000000000000000000000000000000000;;	package units
89bc075ca22301fc4fe03dcaa8c8fcf6f0b87b87;Godeps/_workspace/src/github.com/docker/go-units/size.go[Godeps/_workspace/src/github.com/docker/go-units/size.go][vendor/github.com/docker/go-units/size.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See: http://en.wikipedia.org/wiki/Binary_prefix
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Decimal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		KB = 1000
0000000000000000000000000000000000000000;;		MB = 1000 * KB
0000000000000000000000000000000000000000;;		GB = 1000 * MB
0000000000000000000000000000000000000000;;		TB = 1000 * GB
0000000000000000000000000000000000000000;;		PB = 1000 * TB
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Binary
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		KiB = 1024
0000000000000000000000000000000000000000;;		MiB = 1024 * KiB
0000000000000000000000000000000000000000;;		GiB = 1024 * MiB
0000000000000000000000000000000000000000;;		TiB = 1024 * GiB
0000000000000000000000000000000000000000;;		PiB = 1024 * TiB
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unitMap map[string]int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		decimalMap = unitMap{"k": KB, "m": MB, "g": GB, "t": TB, "p": PB}
0000000000000000000000000000000000000000;;		binaryMap  = unitMap{"k": KiB, "m": MiB, "g": GiB, "t": TiB, "p": PiB}
0000000000000000000000000000000000000000;;		sizeRegex  = regexp.MustCompile(`^(\d+(\.\d+)*) ?([kKmMgGtTpP])?[bB]?$`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var decimapAbbrs = []string{"B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"}
0000000000000000000000000000000000000000;;	var binaryAbbrs = []string{"B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSizeAndUnit(size float64, base float64, _map []string) (float64, string) {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		unitsLimit := len(_map) - 1
0000000000000000000000000000000000000000;;		for size >= base && i < unitsLimit {
0000000000000000000000000000000000000000;;			size = size / base
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return size, _map[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CustomSize returns a human-readable approximation of a size
0000000000000000000000000000000000000000;;	// using custom format.
0000000000000000000000000000000000000000;;	func CustomSize(format string, size float64, base float64, _map []string) string {
0000000000000000000000000000000000000000;;		size, unit := getSizeAndUnit(size, base, _map)
0000000000000000000000000000000000000000;;		return fmt.Sprintf(format, size, unit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HumanSizeWithPrecision allows the size to be in any precision,
0000000000000000000000000000000000000000;;	// instead of 4 digit precision used in units.HumanSize.
0000000000000000000000000000000000000000;;	func HumanSizeWithPrecision(size float64, precision int) string {
0000000000000000000000000000000000000000;;		size, unit := getSizeAndUnit(size, 1000.0, decimapAbbrs)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%.*g %s", precision, size, unit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HumanSize returns a human-readable approximation of a size
0000000000000000000000000000000000000000;;	// capped at 4 valid numbers (eg. "2.746 MB", "796 KB").
0000000000000000000000000000000000000000;;	func HumanSize(size float64) string {
0000000000000000000000000000000000000000;;		return HumanSizeWithPrecision(size, 4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BytesSize returns a human-readable size in bytes, kibibytes,
0000000000000000000000000000000000000000;;	// mebibytes, gibibytes, or tebibytes (eg. "44kiB", "17MiB").
0000000000000000000000000000000000000000;;	func BytesSize(size float64) string {
0000000000000000000000000000000000000000;;		return CustomSize("%.4g %s", size, 1024.0, binaryAbbrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromHumanSize returns an integer from a human-readable specification of a
0000000000000000000000000000000000000000;;	// size using SI standard (eg. "44kB", "17MB").
0000000000000000000000000000000000000000;;	func FromHumanSize(size string) (int64, error) {
0000000000000000000000000000000000000000;;		return parseSize(size, decimalMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RAMInBytes parses a human-readable string representing an amount of RAM
0000000000000000000000000000000000000000;;	// in bytes, kibibytes, mebibytes, gibibytes, or tebibytes and
0000000000000000000000000000000000000000;;	// returns the number of bytes, or -1 if the string is unparseable.
0000000000000000000000000000000000000000;;	// Units are case-insensitive, and the 'b' suffix is optional.
0000000000000000000000000000000000000000;;	func RAMInBytes(size string) (int64, error) {
0000000000000000000000000000000000000000;;		return parseSize(size, binaryMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parses the human-readable size string into the amount it represents.
0000000000000000000000000000000000000000;;	func parseSize(sizeStr string, uMap unitMap) (int64, error) {
0000000000000000000000000000000000000000;;		matches := sizeRegex.FindStringSubmatch(sizeStr)
0000000000000000000000000000000000000000;;		if len(matches) != 4 {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf("invalid size: '%s'", sizeStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size, err := strconv.ParseFloat(matches[1], 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unitPrefix := strings.ToLower(matches[3])
0000000000000000000000000000000000000000;;		if mul, ok := uMap[unitPrefix]; ok {
0000000000000000000000000000000000000000;;			size *= float64(mul)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return int64(size), nil
0000000000000000000000000000000000000000;;	}
