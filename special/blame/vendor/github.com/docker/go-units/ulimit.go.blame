0000000000000000000000000000000000000000;;	package units
89bc075ca22301fc4fe03dcaa8c8fcf6f0b87b87;Godeps/_workspace/src/github.com/docker/go-units/ulimit.go[Godeps/_workspace/src/github.com/docker/go-units/ulimit.go][vendor/github.com/docker/go-units/ulimit.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ulimit is a human friendly version of Rlimit.
0000000000000000000000000000000000000000;;	type Ulimit struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Hard int64
0000000000000000000000000000000000000000;;		Soft int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rlimit specifies the resource limits, such as max open files.
0000000000000000000000000000000000000000;;	type Rlimit struct {
0000000000000000000000000000000000000000;;		Type int    `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		Hard uint64 `json:"hard,omitempty"`
0000000000000000000000000000000000000000;;		Soft uint64 `json:"soft,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// magic numbers for making the syscall
0000000000000000000000000000000000000000;;		// some of these are defined in the syscall package, but not all.
0000000000000000000000000000000000000000;;		// Also since Windows client doesn't get access to the syscall package, need to
0000000000000000000000000000000000000000;;		//	define these here
0000000000000000000000000000000000000000;;		rlimitAs         = 9
0000000000000000000000000000000000000000;;		rlimitCore       = 4
0000000000000000000000000000000000000000;;		rlimitCPU        = 0
0000000000000000000000000000000000000000;;		rlimitData       = 2
0000000000000000000000000000000000000000;;		rlimitFsize      = 1
0000000000000000000000000000000000000000;;		rlimitLocks      = 10
0000000000000000000000000000000000000000;;		rlimitMemlock    = 8
0000000000000000000000000000000000000000;;		rlimitMsgqueue   = 12
0000000000000000000000000000000000000000;;		rlimitNice       = 13
0000000000000000000000000000000000000000;;		rlimitNofile     = 7
0000000000000000000000000000000000000000;;		rlimitNproc      = 6
0000000000000000000000000000000000000000;;		rlimitRss        = 5
0000000000000000000000000000000000000000;;		rlimitRtprio     = 14
0000000000000000000000000000000000000000;;		rlimitRttime     = 15
0000000000000000000000000000000000000000;;		rlimitSigpending = 11
0000000000000000000000000000000000000000;;		rlimitStack      = 3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ulimitNameMapping = map[string]int{
0000000000000000000000000000000000000000;;		//"as":         rlimitAs, // Disabled since this doesn't seem usable with the way Docker inits a container.
0000000000000000000000000000000000000000;;		"core":       rlimitCore,
0000000000000000000000000000000000000000;;		"cpu":        rlimitCPU,
0000000000000000000000000000000000000000;;		"data":       rlimitData,
0000000000000000000000000000000000000000;;		"fsize":      rlimitFsize,
0000000000000000000000000000000000000000;;		"locks":      rlimitLocks,
0000000000000000000000000000000000000000;;		"memlock":    rlimitMemlock,
0000000000000000000000000000000000000000;;		"msgqueue":   rlimitMsgqueue,
0000000000000000000000000000000000000000;;		"nice":       rlimitNice,
0000000000000000000000000000000000000000;;		"nofile":     rlimitNofile,
0000000000000000000000000000000000000000;;		"nproc":      rlimitNproc,
0000000000000000000000000000000000000000;;		"rss":        rlimitRss,
0000000000000000000000000000000000000000;;		"rtprio":     rlimitRtprio,
0000000000000000000000000000000000000000;;		"rttime":     rlimitRttime,
0000000000000000000000000000000000000000;;		"sigpending": rlimitSigpending,
0000000000000000000000000000000000000000;;		"stack":      rlimitStack,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseUlimit parses and returns a Ulimit from the specified string.
0000000000000000000000000000000000000000;;	func ParseUlimit(val string) (*Ulimit, error) {
0000000000000000000000000000000000000000;;		parts := strings.SplitN(val, "=", 2)
0000000000000000000000000000000000000000;;		if len(parts) != 2 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid ulimit argument: %s", val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, exists := ulimitNameMapping[parts[0]]; !exists {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid ulimit type: %s", parts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			soft int64
0000000000000000000000000000000000000000;;			hard = &soft // default to soft in case no hard was set
0000000000000000000000000000000000000000;;			temp int64
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		switch limitVals := strings.Split(parts[1], ":"); len(limitVals) {
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			temp, err = strconv.ParseInt(limitVals[1], 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hard = &temp
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			soft, err = strconv.ParseInt(limitVals[0], 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("too many limit value arguments - %s, can only have up to two, `soft[:hard]`", parts[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if soft > *hard {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ulimit soft limit must be less than or equal to hard limit: %d > %d", soft, *hard)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Ulimit{Name: parts[0], Soft: soft, Hard: *hard}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRlimit returns the RLimit corresponding to Ulimit.
0000000000000000000000000000000000000000;;	func (u *Ulimit) GetRlimit() (*Rlimit, error) {
0000000000000000000000000000000000000000;;		t, exists := ulimitNameMapping[u.Name]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid ulimit name %s", u.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Rlimit{Type: t, Soft: uint64(u.Soft), Hard: uint64(u.Hard)}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Ulimit) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s=%d:%d", u.Name, u.Soft, u.Hard)
0000000000000000000000000000000000000000;;	}
