0000000000000000000000000000000000000000;;	// +build windows
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	package system
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MkdirAll implementation that is volume path aware for Windows.
0000000000000000000000000000000000000000;;	func MkdirAll(path string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		if re := regexp.MustCompile(`^\\\\\?\\Volume{[a-z0-9-]+}$`); re.MatchString(path) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The rest of this method is copied from os.MkdirAll and should be kept
0000000000000000000000000000000000000000;;		// as-is to ensure compatibility.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fast path: if we can tell whether path is a directory or file, stop with success or error.
0000000000000000000000000000000000000000;;		dir, err := os.Stat(path)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if dir.IsDir() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &os.PathError{
0000000000000000000000000000000000000000;;				Op:   "mkdir",
0000000000000000000000000000000000000000;;				Path: path,
0000000000000000000000000000000000000000;;				Err:  syscall.ENOTDIR,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Slow path: make sure parent exists and then call Mkdir for path.
0000000000000000000000000000000000000000;;		i := len(path)
0000000000000000000000000000000000000000;;		for i > 0 && os.IsPathSeparator(path[i-1]) { // Skip trailing path separator.
0000000000000000000000000000000000000000;;			i--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j := i
0000000000000000000000000000000000000000;;		for j > 0 && !os.IsPathSeparator(path[j-1]) { // Scan backward over element.
0000000000000000000000000000000000000000;;			j--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if j > 1 {
0000000000000000000000000000000000000000;;			// Create parent
0000000000000000000000000000000000000000;;			err = MkdirAll(path[0:j-1], perm)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parent now exists; invoke Mkdir and use its result.
0000000000000000000000000000000000000000;;		err = os.Mkdir(path, perm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Handle arguments like "foo/." by
0000000000000000000000000000000000000000;;			// double-checking that directory doesn't exist.
0000000000000000000000000000000000000000;;			dir, err1 := os.Lstat(path)
0000000000000000000000000000000000000000;;			if err1 == nil && dir.IsDir() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAbs is a platform-specific wrapper for filepath.IsAbs. On Windows,
0000000000000000000000000000000000000000;;	// golang filepath.IsAbs does not consider a path \windows\system32 as absolute
0000000000000000000000000000000000000000;;	// as it doesn't start with a drive-letter/colon combination. However, in
0000000000000000000000000000000000000000;;	// docker we need to verify things such as WORKDIR /windows/system32 in
0000000000000000000000000000000000000000;;	// a Dockerfile (which gets translated to \windows\system32 when being processed
0000000000000000000000000000000000000000;;	// by the daemon. This SHOULD be treated as absolute from a docker processing
0000000000000000000000000000000000000000;;	// perspective.
0000000000000000000000000000000000000000;;	func IsAbs(path string) bool {
0000000000000000000000000000000000000000;;		if !filepath.IsAbs(path) {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(path, string(os.PathSeparator)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
