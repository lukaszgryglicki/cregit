0000000000000000000000000000000000000000;;	package system
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	// This file implements syscalls for Win32 events which are not implemented
0000000000000000000000000000000000000000;;	// in golang.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		procCreateEvent = modkernel32.NewProc("CreateEventW")
0000000000000000000000000000000000000000;;		procOpenEvent   = modkernel32.NewProc("OpenEventW")
0000000000000000000000000000000000000000;;		procSetEvent    = modkernel32.NewProc("SetEvent")
0000000000000000000000000000000000000000;;		procResetEvent  = modkernel32.NewProc("ResetEvent")
0000000000000000000000000000000000000000;;		procPulseEvent  = modkernel32.NewProc("PulseEvent")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateEvent implements win32 CreateEventW func in golang. It will create an event object.
0000000000000000000000000000000000000000;;	func CreateEvent(eventAttributes *syscall.SecurityAttributes, manualReset bool, initialState bool, name string) (handle syscall.Handle, err error) {
0000000000000000000000000000000000000000;;		namep, _ := syscall.UTF16PtrFromString(name)
0000000000000000000000000000000000000000;;		var _p1 uint32
0000000000000000000000000000000000000000;;		if manualReset {
0000000000000000000000000000000000000000;;			_p1 = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var _p2 uint32
0000000000000000000000000000000000000000;;		if initialState {
0000000000000000000000000000000000000000;;			_p2 = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r0, _, e1 := procCreateEvent.Call(uintptr(unsafe.Pointer(eventAttributes)), uintptr(_p1), uintptr(_p2), uintptr(unsafe.Pointer(namep)))
0000000000000000000000000000000000000000;;		use(unsafe.Pointer(namep))
0000000000000000000000000000000000000000;;		handle = syscall.Handle(r0)
0000000000000000000000000000000000000000;;		if handle == syscall.InvalidHandle {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenEvent implements win32 OpenEventW func in golang. It opens an event object.
0000000000000000000000000000000000000000;;	func OpenEvent(desiredAccess uint32, inheritHandle bool, name string) (handle syscall.Handle, err error) {
0000000000000000000000000000000000000000;;		namep, _ := syscall.UTF16PtrFromString(name)
0000000000000000000000000000000000000000;;		var _p1 uint32
0000000000000000000000000000000000000000;;		if inheritHandle {
0000000000000000000000000000000000000000;;			_p1 = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r0, _, e1 := procOpenEvent.Call(uintptr(desiredAccess), uintptr(_p1), uintptr(unsafe.Pointer(namep)))
0000000000000000000000000000000000000000;;		use(unsafe.Pointer(namep))
0000000000000000000000000000000000000000;;		handle = syscall.Handle(r0)
0000000000000000000000000000000000000000;;		if handle == syscall.InvalidHandle {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEvent implements win32 SetEvent func in golang.
0000000000000000000000000000000000000000;;	func SetEvent(handle syscall.Handle) (err error) {
0000000000000000000000000000000000000000;;		return setResetPulse(handle, procSetEvent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetEvent implements win32 ResetEvent func in golang.
0000000000000000000000000000000000000000;;	func ResetEvent(handle syscall.Handle) (err error) {
0000000000000000000000000000000000000000;;		return setResetPulse(handle, procResetEvent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PulseEvent implements win32 PulseEvent func in golang.
0000000000000000000000000000000000000000;;	func PulseEvent(handle syscall.Handle) (err error) {
0000000000000000000000000000000000000000;;		return setResetPulse(handle, procPulseEvent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setResetPulse(handle syscall.Handle, proc *syscall.LazyProc) (err error) {
0000000000000000000000000000000000000000;;		r0, _, _ := proc.Call(uintptr(handle))
0000000000000000000000000000000000000000;;		if r0 != 0 {
0000000000000000000000000000000000000000;;			err = syscall.Errno(r0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var temp unsafe.Pointer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// use ensures a variable is kept alive without the GC freeing while still needed
0000000000000000000000000000000000000000;;	func use(p unsafe.Pointer) {
0000000000000000000000000000000000000000;;		temp = p
0000000000000000000000000000000000000000;;	}
