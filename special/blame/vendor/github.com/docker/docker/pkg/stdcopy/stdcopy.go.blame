0000000000000000000000000000000000000000;;	package stdcopy
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/docker/pkg/stdcopy/stdcopy.go[Godeps/_workspace/src/github.com/docker/docker/pkg/stdcopy/stdcopy.go][vendor/github.com/docker/docker/pkg/stdcopy/stdcopy.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Sirupsen/logrus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StdType is the type of standard stream
0000000000000000000000000000000000000000;;	// a writer can multiplex to.
0000000000000000000000000000000000000000;;	type StdType byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Stdin represents standard input stream type.
0000000000000000000000000000000000000000;;		Stdin StdType = iota
0000000000000000000000000000000000000000;;		// Stdout represents standard output stream type.
0000000000000000000000000000000000000000;;		Stdout
0000000000000000000000000000000000000000;;		// Stderr represents standard error steam type.
0000000000000000000000000000000000000000;;		Stderr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stdWriterPrefixLen = 8
0000000000000000000000000000000000000000;;		stdWriterFdIndex   = 0
0000000000000000000000000000000000000000;;		stdWriterSizeIndex = 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startingBufLen = 32*1024 + stdWriterPrefixLen + 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stdWriter is wrapper of io.Writer with extra customized info.
0000000000000000000000000000000000000000;;	type stdWriter struct {
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;		prefix byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write sends the buffer to the underneath writer.
0000000000000000000000000000000000000000;;	// It insert the prefix header before the buffer,
0000000000000000000000000000000000000000;;	// so stdcopy.StdCopy knows where to multiplex the output.
0000000000000000000000000000000000000000;;	// It makes stdWriter to implement io.Writer.
0000000000000000000000000000000000000000;;	func (w *stdWriter) Write(buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if w == nil || w.Writer == nil {
0000000000000000000000000000000000000000;;			return 0, errors.New("Writer not instantiated")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buf == nil {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header := [stdWriterPrefixLen]byte{stdWriterFdIndex: w.prefix}
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(header[stdWriterSizeIndex:], uint32(len(buf)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		line := append(header[:], buf...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err = w.Writer.Write(line)
0000000000000000000000000000000000000000;;		n -= stdWriterPrefixLen
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n < 0 {
0000000000000000000000000000000000000000;;			n = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStdWriter instantiates a new Writer.
0000000000000000000000000000000000000000;;	// Everything written to it will be encapsulated using a custom format,
0000000000000000000000000000000000000000;;	// and written to the underlying `w` stream.
0000000000000000000000000000000000000000;;	// This allows multiple write streams (e.g. stdout and stderr) to be muxed into a single connection.
0000000000000000000000000000000000000000;;	// `t` indicates the id of the stream to encapsulate.
0000000000000000000000000000000000000000;;	// It can be stdcopy.Stdin, stdcopy.Stdout, stdcopy.Stderr.
0000000000000000000000000000000000000000;;	func NewStdWriter(w io.Writer, t StdType) io.Writer {
0000000000000000000000000000000000000000;;		return &stdWriter{
0000000000000000000000000000000000000000;;			Writer: w,
0000000000000000000000000000000000000000;;			prefix: byte(t),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StdCopy is a modified version of io.Copy.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// StdCopy will demultiplex `src`, assuming that it contains two streams,
0000000000000000000000000000000000000000;;	// previously multiplexed together using a StdWriter instance.
0000000000000000000000000000000000000000;;	// As it reads from `src`, StdCopy will write to `dstout` and `dsterr`.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// StdCopy will read until it hits EOF on `src`. It will then return a nil error.
0000000000000000000000000000000000000000;;	// In other words: if `err` is non nil, it indicates a real underlying error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// `written` will hold the total number of bytes written to `dstout` and `dsterr`.
0000000000000000000000000000000000000000;;	func StdCopy(dstout, dsterr io.Writer, src io.Reader) (written int64, err error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			buf       = make([]byte, startingBufLen)
0000000000000000000000000000000000000000;;			bufLen    = len(buf)
0000000000000000000000000000000000000000;;			nr, nw    int
0000000000000000000000000000000000000000;;			er, ew    error
0000000000000000000000000000000000000000;;			out       io.Writer
0000000000000000000000000000000000000000;;			frameSize int
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Make sure we have at least a full header
0000000000000000000000000000000000000000;;			for nr < stdWriterPrefixLen {
0000000000000000000000000000000000000000;;				var nr2 int
0000000000000000000000000000000000000000;;				nr2, er = src.Read(buf[nr:])
0000000000000000000000000000000000000000;;				nr += nr2
0000000000000000000000000000000000000000;;				if er == io.EOF {
0000000000000000000000000000000000000000;;					if nr < stdWriterPrefixLen {
0000000000000000000000000000000000000000;;						logrus.Debugf("Corrupted prefix: %v", buf[:nr])
0000000000000000000000000000000000000000;;						return written, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if er != nil {
0000000000000000000000000000000000000000;;					logrus.Debugf("Error reading header: %s", er)
0000000000000000000000000000000000000000;;					return 0, er
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check the first byte to know where to write
0000000000000000000000000000000000000000;;			switch StdType(buf[stdWriterFdIndex]) {
0000000000000000000000000000000000000000;;			case Stdin:
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case Stdout:
0000000000000000000000000000000000000000;;				// Write on stdout
0000000000000000000000000000000000000000;;				out = dstout
0000000000000000000000000000000000000000;;			case Stderr:
0000000000000000000000000000000000000000;;				// Write on stderr
0000000000000000000000000000000000000000;;				out = dsterr
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				logrus.Debugf("Error selecting output fd: (%d)", buf[stdWriterFdIndex])
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("Unrecognized input header: %d", buf[stdWriterFdIndex])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Retrieve the size of the frame
0000000000000000000000000000000000000000;;			frameSize = int(binary.BigEndian.Uint32(buf[stdWriterSizeIndex : stdWriterSizeIndex+4]))
0000000000000000000000000000000000000000;;			logrus.Debugf("framesize: %d", frameSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if the buffer is big enough to read the frame.
0000000000000000000000000000000000000000;;			// Extend it if necessary.
0000000000000000000000000000000000000000;;			if frameSize+stdWriterPrefixLen > bufLen {
0000000000000000000000000000000000000000;;				logrus.Debugf("Extending buffer cap by %d (was %d)", frameSize+stdWriterPrefixLen-bufLen+1, len(buf))
0000000000000000000000000000000000000000;;				buf = append(buf, make([]byte, frameSize+stdWriterPrefixLen-bufLen+1)...)
0000000000000000000000000000000000000000;;				bufLen = len(buf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// While the amount of bytes read is less than the size of the frame + header, we keep reading
0000000000000000000000000000000000000000;;			for nr < frameSize+stdWriterPrefixLen {
0000000000000000000000000000000000000000;;				var nr2 int
0000000000000000000000000000000000000000;;				nr2, er = src.Read(buf[nr:])
0000000000000000000000000000000000000000;;				nr += nr2
0000000000000000000000000000000000000000;;				if er == io.EOF {
0000000000000000000000000000000000000000;;					if nr < frameSize+stdWriterPrefixLen {
0000000000000000000000000000000000000000;;						logrus.Debugf("Corrupted frame: %v", buf[stdWriterPrefixLen:nr])
0000000000000000000000000000000000000000;;						return written, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if er != nil {
0000000000000000000000000000000000000000;;					logrus.Debugf("Error reading frame: %s", er)
0000000000000000000000000000000000000000;;					return 0, er
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write the retrieved frame (without header)
0000000000000000000000000000000000000000;;			nw, ew = out.Write(buf[stdWriterPrefixLen : frameSize+stdWriterPrefixLen])
0000000000000000000000000000000000000000;;			if ew != nil {
0000000000000000000000000000000000000000;;				logrus.Debugf("Error writing frame: %s", ew)
0000000000000000000000000000000000000000;;				return 0, ew
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the frame has not been fully written: error
0000000000000000000000000000000000000000;;			if nw != frameSize {
0000000000000000000000000000000000000000;;				logrus.Debugf("Error Short Write: (%d on %d)", nw, frameSize)
0000000000000000000000000000000000000000;;				return 0, io.ErrShortWrite
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			written += int64(nw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Move the rest of the buffer to the beginning
0000000000000000000000000000000000000000;;			copy(buf, buf[frameSize+stdWriterPrefixLen:])
0000000000000000000000000000000000000000;;			// Move the index
0000000000000000000000000000000000000000;;			nr -= frameSize + stdWriterPrefixLen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
