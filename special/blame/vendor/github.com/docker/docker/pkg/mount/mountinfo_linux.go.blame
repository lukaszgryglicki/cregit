0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/docker/pkg/mount/mountinfo_linux.go[Godeps/_workspace/src/github.com/docker/docker/pkg/mount/mountinfo_linux.go][vendor/github.com/docker/docker/pkg/mount/mountinfo_linux.go];	
0000000000000000000000000000000000000000;;	package mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		/* 36 35 98:0 /mnt1 /mnt2 rw,noatime master:1 - ext3 /dev/root rw,errors=continue
0000000000000000000000000000000000000000;;		   (1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		   (1) mount ID:  unique identifier of the mount (may be reused after umount)
0000000000000000000000000000000000000000;;		   (2) parent ID:  ID of parent (or of self for the top of the mount tree)
0000000000000000000000000000000000000000;;		   (3) major:minor:  value of st_dev for files on filesystem
0000000000000000000000000000000000000000;;		   (4) root:  root of the mount within the filesystem
0000000000000000000000000000000000000000;;		   (5) mount point:  mount point relative to the process's root
0000000000000000000000000000000000000000;;		   (6) mount options:  per mount options
0000000000000000000000000000000000000000;;		   (7) optional fields:  zero or more fields of the form "tag[:value]"
0000000000000000000000000000000000000000;;		   (8) separator:  marks the end of the optional fields
0000000000000000000000000000000000000000;;		   (9) filesystem type:  name of filesystem of the form "type[.subtype]"
0000000000000000000000000000000000000000;;		   (10) mount source:  filesystem specific information or "none"
0000000000000000000000000000000000000000;;		   (11) super options:  per super block options*/
0000000000000000000000000000000000000000;;		mountinfoFormat = "%d %d %d:%d %s %s %s %s"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse /proc/self/mountinfo because comparing Dev and ino does not work from
0000000000000000000000000000000000000000;;	// bind mounts
0000000000000000000000000000000000000000;;	func parseMountTable() ([]*Info, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/self/mountinfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseInfoFile(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseInfoFile(r io.Reader) ([]*Info, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			s   = bufio.NewScanner(r)
0000000000000000000000000000000000000000;;			out = []*Info{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				p              = &Info{}
0000000000000000000000000000000000000000;;				text           = s.Text()
0000000000000000000000000000000000000000;;				optionalFields string
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := fmt.Sscanf(text, mountinfoFormat,
0000000000000000000000000000000000000000;;				&p.ID, &p.Parent, &p.Major, &p.Minor,
0000000000000000000000000000000000000000;;				&p.Root, &p.Mountpoint, &p.Opts, &optionalFields); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Scanning '%s' failed: %s", text, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Safe as mountinfo encodes mountpoints with spaces as \040.
0000000000000000000000000000000000000000;;			index := strings.Index(text, " - ")
0000000000000000000000000000000000000000;;			postSeparatorFields := strings.Fields(text[index+3:])
0000000000000000000000000000000000000000;;			if len(postSeparatorFields) < 3 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error found less than 3 fields post '-' in %q", text)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if optionalFields != "-" {
0000000000000000000000000000000000000000;;				p.Optional = optionalFields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.Fstype = postSeparatorFields[0]
0000000000000000000000000000000000000000;;			p.Source = postSeparatorFields[1]
0000000000000000000000000000000000000000;;			p.VfsOpts = strings.Join(postSeparatorFields[2:], " ")
0000000000000000000000000000000000000000;;			out = append(out, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PidMountInfo collects the mounts for a specific process ID. If the process
0000000000000000000000000000000000000000;;	// ID is unknown, it is better to use `GetMounts` which will inspect
0000000000000000000000000000000000000000;;	// "/proc/self/mountinfo" instead.
0000000000000000000000000000000000000000;;	func PidMountInfo(pid int) ([]*Info, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(fmt.Sprintf("/proc/%d/mountinfo", pid))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseInfoFile(f)
0000000000000000000000000000000000000000;;	}
