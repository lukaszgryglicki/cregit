0000000000000000000000000000000000000000;;	package mount
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/docker/pkg/mount/flags.go[Godeps/_workspace/src/github.com/docker/docker/pkg/mount/flags.go][vendor/github.com/docker/docker/pkg/mount/flags.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse fstab type mount options into mount() flags
0000000000000000000000000000000000000000;;	// and device specific data
0000000000000000000000000000000000000000;;	func parseOptions(options string) (int, string) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			flag int
0000000000000000000000000000000000000000;;			data []string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags := map[string]struct {
0000000000000000000000000000000000000000;;			clear bool
0000000000000000000000000000000000000000;;			flag  int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"defaults":      {false, 0},
0000000000000000000000000000000000000000;;			"ro":            {false, RDONLY},
0000000000000000000000000000000000000000;;			"rw":            {true, RDONLY},
0000000000000000000000000000000000000000;;			"suid":          {true, NOSUID},
0000000000000000000000000000000000000000;;			"nosuid":        {false, NOSUID},
0000000000000000000000000000000000000000;;			"dev":           {true, NODEV},
0000000000000000000000000000000000000000;;			"nodev":         {false, NODEV},
0000000000000000000000000000000000000000;;			"exec":          {true, NOEXEC},
0000000000000000000000000000000000000000;;			"noexec":        {false, NOEXEC},
0000000000000000000000000000000000000000;;			"sync":          {false, SYNCHRONOUS},
0000000000000000000000000000000000000000;;			"async":         {true, SYNCHRONOUS},
0000000000000000000000000000000000000000;;			"dirsync":       {false, DIRSYNC},
0000000000000000000000000000000000000000;;			"remount":       {false, REMOUNT},
0000000000000000000000000000000000000000;;			"mand":          {false, MANDLOCK},
0000000000000000000000000000000000000000;;			"nomand":        {true, MANDLOCK},
0000000000000000000000000000000000000000;;			"atime":         {true, NOATIME},
0000000000000000000000000000000000000000;;			"noatime":       {false, NOATIME},
0000000000000000000000000000000000000000;;			"diratime":      {true, NODIRATIME},
0000000000000000000000000000000000000000;;			"nodiratime":    {false, NODIRATIME},
0000000000000000000000000000000000000000;;			"bind":          {false, BIND},
0000000000000000000000000000000000000000;;			"rbind":         {false, RBIND},
0000000000000000000000000000000000000000;;			"unbindable":    {false, UNBINDABLE},
0000000000000000000000000000000000000000;;			"runbindable":   {false, RUNBINDABLE},
0000000000000000000000000000000000000000;;			"private":       {false, PRIVATE},
0000000000000000000000000000000000000000;;			"rprivate":      {false, RPRIVATE},
0000000000000000000000000000000000000000;;			"shared":        {false, SHARED},
0000000000000000000000000000000000000000;;			"rshared":       {false, RSHARED},
0000000000000000000000000000000000000000;;			"slave":         {false, SLAVE},
0000000000000000000000000000000000000000;;			"rslave":        {false, RSLAVE},
0000000000000000000000000000000000000000;;			"relatime":      {false, RELATIME},
0000000000000000000000000000000000000000;;			"norelatime":    {true, RELATIME},
0000000000000000000000000000000000000000;;			"strictatime":   {false, STRICTATIME},
0000000000000000000000000000000000000000;;			"nostrictatime": {true, STRICTATIME},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, o := range strings.Split(options, ",") {
0000000000000000000000000000000000000000;;			// If the option does not exist in the flags table or the flag
0000000000000000000000000000000000000000;;			// is not supported on the platform,
0000000000000000000000000000000000000000;;			// then it is a data value for a specific fs type
0000000000000000000000000000000000000000;;			if f, exists := flags[o]; exists && f.flag != 0 {
0000000000000000000000000000000000000000;;				if f.clear {
0000000000000000000000000000000000000000;;					flag &= ^f.flag
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					flag |= f.flag
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				data = append(data, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return flag, strings.Join(data, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseTmpfsOptions parse fstab type mount options into flags and data
0000000000000000000000000000000000000000;;	func ParseTmpfsOptions(options string) (int, string, error) {
0000000000000000000000000000000000000000;;		flags, data := parseOptions(options)
0000000000000000000000000000000000000000;;		validFlags := map[string]bool{
0000000000000000000000000000000000000000;;			"":          true,
0000000000000000000000000000000000000000;;			"size":      true,
0000000000000000000000000000000000000000;;			"mode":      true,
0000000000000000000000000000000000000000;;			"uid":       true,
0000000000000000000000000000000000000000;;			"gid":       true,
0000000000000000000000000000000000000000;;			"nr_inodes": true,
0000000000000000000000000000000000000000;;			"nr_blocks": true,
0000000000000000000000000000000000000000;;			"mpol":      true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, o := range strings.Split(data, ",") {
0000000000000000000000000000000000000000;;			opt := strings.SplitN(o, "=", 2)
0000000000000000000000000000000000000000;;			if !validFlags[opt[0]] {
0000000000000000000000000000000000000000;;				return 0, "", fmt.Errorf("Invalid tmpfs option %q", opt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return flags, data, nil
0000000000000000000000000000000000000000;;	}
