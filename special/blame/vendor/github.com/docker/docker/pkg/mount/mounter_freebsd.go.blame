0000000000000000000000000000000000000000;;	package mount
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/docker/pkg/mount/mounter_freebsd.go[Godeps/_workspace/src/github.com/docker/docker/pkg/mount/mounter_freebsd.go][vendor/github.com/docker/docker/pkg/mount/mounter_freebsd.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	#include <errno.h>
0000000000000000000000000000000000000000;;	#include <stdlib.h>
0000000000000000000000000000000000000000;;	#include <string.h>
0000000000000000000000000000000000000000;;	#include <sys/_iovec.h>
0000000000000000000000000000000000000000;;	#include <sys/mount.h>
0000000000000000000000000000000000000000;;	#include <sys/param.h>
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	import "C"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func allocateIOVecs(options []string) []C.struct_iovec {
0000000000000000000000000000000000000000;;		out := make([]C.struct_iovec, len(options))
0000000000000000000000000000000000000000;;		for i, option := range options {
0000000000000000000000000000000000000000;;			out[i].iov_base = unsafe.Pointer(C.CString(option))
0000000000000000000000000000000000000000;;			out[i].iov_len = C.size_t(len(option) + 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mount(device, target, mType string, flag uintptr, data string) error {
0000000000000000000000000000000000000000;;		isNullFS := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xs := strings.Split(data, ",")
0000000000000000000000000000000000000000;;		for _, x := range xs {
0000000000000000000000000000000000000000;;			if x == "bind" {
0000000000000000000000000000000000000000;;				isNullFS = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := []string{"fspath", target}
0000000000000000000000000000000000000000;;		if isNullFS {
0000000000000000000000000000000000000000;;			options = append(options, "fstype", "nullfs", "target", device)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			options = append(options, "fstype", mType, "from", device)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rawOptions := allocateIOVecs(options)
0000000000000000000000000000000000000000;;		for _, rawOption := range rawOptions {
0000000000000000000000000000000000000000;;			defer C.free(rawOption.iov_base)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if errno := C.nmount(&rawOptions[0], C.uint(len(options)), C.int(flag)); errno != 0 {
0000000000000000000000000000000000000000;;			reason := C.GoString(C.strerror(*C.__error()))
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to call nmount: %s", reason)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmount(target string, flag int) error {
0000000000000000000000000000000000000000;;		return syscall.Unmount(target, flag)
0000000000000000000000000000000000000000;;	}
