0000000000000000000000000000000000000000;;	package mount
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/docker/pkg/mount/mount.go[Godeps/_workspace/src/github.com/docker/docker/pkg/mount/mount.go][vendor/github.com/docker/docker/pkg/mount/mount.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMounts retrieves a list of mounts for the current running process.
0000000000000000000000000000000000000000;;	func GetMounts() ([]*Info, error) {
0000000000000000000000000000000000000000;;		return parseMountTable()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mounted looks at /proc/self/mountinfo to determine of the specified
0000000000000000000000000000000000000000;;	// mountpoint has been mounted
0000000000000000000000000000000000000000;;	func Mounted(mountpoint string) (bool, error) {
0000000000000000000000000000000000000000;;		entries, err := parseMountTable()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Search the table for the mountpoint
0000000000000000000000000000000000000000;;		for _, e := range entries {
0000000000000000000000000000000000000000;;			if e.Mountpoint == mountpoint {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mount will mount filesystem according to the specified configuration, on the
0000000000000000000000000000000000000000;;	// condition that the target path is *not* already mounted. Options must be
0000000000000000000000000000000000000000;;	// specified like the mount or fstab unix commands: "opt1=val1,opt2=val2". See
0000000000000000000000000000000000000000;;	// flags.go for supported option flags.
0000000000000000000000000000000000000000;;	func Mount(device, target, mType, options string) error {
0000000000000000000000000000000000000000;;		flag, _ := parseOptions(options)
0000000000000000000000000000000000000000;;		if flag&REMOUNT != REMOUNT {
0000000000000000000000000000000000000000;;			if mounted, err := Mounted(target); err != nil || mounted {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ForceMount(device, target, mType, options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForceMount will mount a filesystem according to the specified configuration,
0000000000000000000000000000000000000000;;	// *regardless* if the target path is not already mounted. Options must be
0000000000000000000000000000000000000000;;	// specified like the mount or fstab unix commands: "opt1=val1,opt2=val2". See
0000000000000000000000000000000000000000;;	// flags.go for supported option flags.
0000000000000000000000000000000000000000;;	func ForceMount(device, target, mType, options string) error {
0000000000000000000000000000000000000000;;		flag, data := parseOptions(options)
0000000000000000000000000000000000000000;;		if err := mount(device, target, mType, uintptr(flag), data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmount will unmount the target filesystem, so long as it is mounted.
0000000000000000000000000000000000000000;;	func Unmount(target string) error {
0000000000000000000000000000000000000000;;		if mounted, err := Mounted(target); err != nil || !mounted {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ForceUnmount(target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForceUnmount will force an unmount of the target filesystem, regardless if
0000000000000000000000000000000000000000;;	// it is mounted or not.
0000000000000000000000000000000000000000;;	func ForceUnmount(target string) (err error) {
0000000000000000000000000000000000000000;;		// Simple retry logic for unmount
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			if err = unmount(target, 0); err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
