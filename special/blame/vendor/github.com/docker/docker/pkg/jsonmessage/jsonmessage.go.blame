0000000000000000000000000000000000000000;;	package jsonmessage
2958e5670c297c4a2f8bd1a097998d33b7997d2e;Godeps/_workspace/src/github.com/docker/docker/pkg/jsonmessage/jsonmessage.go[Godeps/_workspace/src/github.com/docker/docker/pkg/jsonmessage/jsonmessage.go][vendor/github.com/docker/docker/pkg/jsonmessage/jsonmessage.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/jsonlog"
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/term"
0000000000000000000000000000000000000000;;		"github.com/docker/go-units"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONError wraps a concrete Code and Message, `Code` is
0000000000000000000000000000000000000000;;	// is a integer error code, `Message` is the error message.
0000000000000000000000000000000000000000;;	type JSONError struct {
0000000000000000000000000000000000000000;;		Code    int    `json:"code,omitempty"`
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *JSONError) Error() string {
0000000000000000000000000000000000000000;;		return e.Message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONProgress describes a Progress. terminalFd is the fd of the current terminal,
0000000000000000000000000000000000000000;;	// Start is the initial value for the operation. Current is the current status and
0000000000000000000000000000000000000000;;	// value of the progress made towards Total. Total is the end value describing when
0000000000000000000000000000000000000000;;	// we made 100% progress for an operation.
0000000000000000000000000000000000000000;;	type JSONProgress struct {
0000000000000000000000000000000000000000;;		terminalFd uintptr
0000000000000000000000000000000000000000;;		Current    int64 `json:"current,omitempty"`
0000000000000000000000000000000000000000;;		Total      int64 `json:"total,omitempty"`
0000000000000000000000000000000000000000;;		Start      int64 `json:"start,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *JSONProgress) String() string {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			width       = 200
0000000000000000000000000000000000000000;;			pbBox       string
0000000000000000000000000000000000000000;;			numbersBox  string
0000000000000000000000000000000000000000;;			timeLeftBox string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws, err := term.GetWinsize(p.terminalFd)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			width = int(ws.Width)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Current <= 0 && p.Total <= 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		current := units.HumanSize(float64(p.Current))
0000000000000000000000000000000000000000;;		if p.Total <= 0 {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%8v", current)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		total := units.HumanSize(float64(p.Total))
0000000000000000000000000000000000000000;;		percentage := int(float64(p.Current)/float64(p.Total)*100) / 2
0000000000000000000000000000000000000000;;		if percentage > 50 {
0000000000000000000000000000000000000000;;			percentage = 50
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if width > 110 {
0000000000000000000000000000000000000000;;			// this number can't be negative gh#7136
0000000000000000000000000000000000000000;;			numSpaces := 0
0000000000000000000000000000000000000000;;			if 50-percentage > 0 {
0000000000000000000000000000000000000000;;				numSpaces = 50 - percentage
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pbBox = fmt.Sprintf("[%s>%s] ", strings.Repeat("=", percentage), strings.Repeat(" ", numSpaces))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numbersBox = fmt.Sprintf("%8v/%v", current, total)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Current > p.Total {
0000000000000000000000000000000000000000;;			// remove total display if the reported current is wonky.
0000000000000000000000000000000000000000;;			numbersBox = fmt.Sprintf("%8v", current)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Current > 0 && p.Start > 0 && percentage < 50 {
0000000000000000000000000000000000000000;;			fromStart := time.Now().UTC().Sub(time.Unix(p.Start, 0))
0000000000000000000000000000000000000000;;			perEntry := fromStart / time.Duration(p.Current)
0000000000000000000000000000000000000000;;			left := time.Duration(p.Total-p.Current) * perEntry
0000000000000000000000000000000000000000;;			left = (left / time.Second) * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if width > 50 {
0000000000000000000000000000000000000000;;				timeLeftBox = " " + left.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pbBox + numbersBox + timeLeftBox
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONMessage defines a message struct. It describes
0000000000000000000000000000000000000000;;	// the created time, where it from, status, ID of the
0000000000000000000000000000000000000000;;	// message. It's used for docker events.
0000000000000000000000000000000000000000;;	type JSONMessage struct {
0000000000000000000000000000000000000000;;		Stream          string        `json:"stream,omitempty"`
0000000000000000000000000000000000000000;;		Status          string        `json:"status,omitempty"`
0000000000000000000000000000000000000000;;		Progress        *JSONProgress `json:"progressDetail,omitempty"`
0000000000000000000000000000000000000000;;		ProgressMessage string        `json:"progress,omitempty"` //deprecated
0000000000000000000000000000000000000000;;		ID              string        `json:"id,omitempty"`
0000000000000000000000000000000000000000;;		From            string        `json:"from,omitempty"`
0000000000000000000000000000000000000000;;		Time            int64         `json:"time,omitempty"`
0000000000000000000000000000000000000000;;		TimeNano        int64         `json:"timeNano,omitempty"`
0000000000000000000000000000000000000000;;		Error           *JSONError    `json:"errorDetail,omitempty"`
0000000000000000000000000000000000000000;;		ErrorMessage    string        `json:"error,omitempty"` //deprecated
0000000000000000000000000000000000000000;;		// Aux contains out-of-band data, such as digests for push signing.
0000000000000000000000000000000000000000;;		Aux *json.RawMessage `json:"aux,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Display displays the JSONMessage to `out`. `isTerminal` describes if `out`
0000000000000000000000000000000000000000;;	// is a terminal. If this is the case, it will erase the entire current line
0000000000000000000000000000000000000000;;	// when displaying the progressbar.
0000000000000000000000000000000000000000;;	func (jm *JSONMessage) Display(out io.Writer, isTerminal bool) error {
0000000000000000000000000000000000000000;;		if jm.Error != nil {
0000000000000000000000000000000000000000;;			if jm.Error.Code == 401 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Authentication is required.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return jm.Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var endl string
0000000000000000000000000000000000000000;;		if isTerminal && jm.Stream == "" && jm.Progress != nil {
0000000000000000000000000000000000000000;;			// <ESC>[2K = erase entire current line
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%c[2K\r", 27)
0000000000000000000000000000000000000000;;			endl = "\r"
0000000000000000000000000000000000000000;;		} else if jm.Progress != nil && jm.Progress.String() != "" { //disable progressbar in non-terminal
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if jm.TimeNano != 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s ", time.Unix(0, jm.TimeNano).Format(jsonlog.RFC3339NanoFixed))
0000000000000000000000000000000000000000;;		} else if jm.Time != 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s ", time.Unix(jm.Time, 0).Format(jsonlog.RFC3339NanoFixed))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if jm.ID != "" {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s: ", jm.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if jm.From != "" {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "(from %s) ", jm.From)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if jm.Progress != nil && isTerminal {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s %s%s", jm.Status, jm.Progress.String(), endl)
0000000000000000000000000000000000000000;;		} else if jm.ProgressMessage != "" { //deprecated
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s %s%s", jm.Status, jm.ProgressMessage, endl)
0000000000000000000000000000000000000000;;		} else if jm.Stream != "" {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s%s", jm.Stream, endl)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "%s%s\n", jm.Status, endl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisplayJSONMessagesStream displays a json message stream from `in` to `out`, `isTerminal`
0000000000000000000000000000000000000000;;	// describes if `out` is a terminal. If this is the case, it will print `\n` at the end of
0000000000000000000000000000000000000000;;	// each line and move the cursor while displaying.
0000000000000000000000000000000000000000;;	func DisplayJSONMessagesStream(in io.Reader, out io.Writer, terminalFd uintptr, isTerminal bool, auxCallback func(*json.RawMessage)) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dec = json.NewDecoder(in)
0000000000000000000000000000000000000000;;			ids = make(map[string]int)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			diff := 0
0000000000000000000000000000000000000000;;			var jm JSONMessage
0000000000000000000000000000000000000000;;			if err := dec.Decode(&jm); err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if jm.Aux != nil {
0000000000000000000000000000000000000000;;				if auxCallback != nil {
0000000000000000000000000000000000000000;;					auxCallback(jm.Aux)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if jm.Progress != nil {
0000000000000000000000000000000000000000;;				jm.Progress.terminalFd = terminalFd
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if jm.ID != "" && (jm.Progress != nil || jm.ProgressMessage != "") {
0000000000000000000000000000000000000000;;				line, ok := ids[jm.ID]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// NOTE: This approach of using len(id) to
0000000000000000000000000000000000000000;;					// figure out the number of lines of history
0000000000000000000000000000000000000000;;					// only works as long as we clear the history
0000000000000000000000000000000000000000;;					// when we output something that's not
0000000000000000000000000000000000000000;;					// accounted for in the map, such as a line
0000000000000000000000000000000000000000;;					// with no ID.
0000000000000000000000000000000000000000;;					line = len(ids)
0000000000000000000000000000000000000000;;					ids[jm.ID] = line
0000000000000000000000000000000000000000;;					if isTerminal {
0000000000000000000000000000000000000000;;						fmt.Fprintf(out, "\n")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					diff = len(ids) - line
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isTerminal {
0000000000000000000000000000000000000000;;					// NOTE: this appears to be necessary even if
0000000000000000000000000000000000000000;;					// diff == 0.
0000000000000000000000000000000000000000;;					// <ESC>[{diff}A = move cursor up diff rows
0000000000000000000000000000000000000000;;					fmt.Fprintf(out, "%c[%dA", 27, diff)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// When outputting something that isn't progress
0000000000000000000000000000000000000000;;				// output, clear the history of previous lines. We
0000000000000000000000000000000000000000;;				// don't want progress entries from some previous
0000000000000000000000000000000000000000;;				// operation to be updated (for example, pull -a
0000000000000000000000000000000000000000;;				// with multiple tags).
0000000000000000000000000000000000000000;;				ids = make(map[string]int)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := jm.Display(out, isTerminal)
0000000000000000000000000000000000000000;;			if jm.ID != "" && isTerminal {
0000000000000000000000000000000000000000;;				// NOTE: this appears to be necessary even if
0000000000000000000000000000000000000000;;				// diff == 0.
0000000000000000000000000000000000000000;;				// <ESC>[{diff}B = move cursor down diff rows
0000000000000000000000000000000000000000;;				fmt.Fprintf(out, "%c[%dB", 27, diff)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
