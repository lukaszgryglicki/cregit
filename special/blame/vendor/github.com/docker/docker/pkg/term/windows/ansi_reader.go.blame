0000000000000000000000000000000000000000;;	// +build windows
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	package windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ansiterm "github.com/Azure/go-ansiterm"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-ansiterm/winterm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		escapeSequence = ansiterm.KEY_ESC_CSI
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ansiReader wraps a standard input file (e.g., os.Stdin) providing ANSI sequence translation.
0000000000000000000000000000000000000000;;	type ansiReader struct {
0000000000000000000000000000000000000000;;		file     *os.File
0000000000000000000000000000000000000000;;		fd       uintptr
0000000000000000000000000000000000000000;;		buffer   []byte
0000000000000000000000000000000000000000;;		cbBuffer int
0000000000000000000000000000000000000000;;		command  []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAnsiReader(nFile int) *ansiReader {
0000000000000000000000000000000000000000;;		file, fd := winterm.GetStdFile(nFile)
0000000000000000000000000000000000000000;;		return &ansiReader{
0000000000000000000000000000000000000000;;			file:    file,
0000000000000000000000000000000000000000;;			fd:      fd,
0000000000000000000000000000000000000000;;			command: make([]byte, 0, ansiterm.ANSI_MAX_CMD_LENGTH),
0000000000000000000000000000000000000000;;			buffer:  make([]byte, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the wrapped file.
0000000000000000000000000000000000000000;;	func (ar *ansiReader) Close() (err error) {
0000000000000000000000000000000000000000;;		return ar.file.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fd returns the file descriptor of the wrapped file.
0000000000000000000000000000000000000000;;	func (ar *ansiReader) Fd() uintptr {
0000000000000000000000000000000000000000;;		return ar.fd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads up to len(p) bytes of translated input events into p.
0000000000000000000000000000000000000000;;	func (ar *ansiReader) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Previously read bytes exist, read as much as we can and return
0000000000000000000000000000000000000000;;		if len(ar.buffer) > 0 {
0000000000000000000000000000000000000000;;			logger.Debugf("Reading previously cached bytes")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalLength := len(ar.buffer)
0000000000000000000000000000000000000000;;			copiedLength := copy(p, ar.buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if copiedLength == originalLength {
0000000000000000000000000000000000000000;;				ar.buffer = make([]byte, 0, len(p))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ar.buffer = ar.buffer[copiedLength:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			logger.Debugf("Read from cache p[%d]: % x", copiedLength, p)
0000000000000000000000000000000000000000;;			return copiedLength, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read and translate key events
0000000000000000000000000000000000000000;;		events, err := readInputEvents(ar.fd, len(p))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		} else if len(events) == 0 {
0000000000000000000000000000000000000000;;			logger.Debug("No input events detected")
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyBytes := translateKeyEvents(events, []byte(escapeSequence))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save excess bytes and right-size keyBytes
0000000000000000000000000000000000000000;;		if len(keyBytes) > len(p) {
0000000000000000000000000000000000000000;;			logger.Debugf("Received %d keyBytes, only room for %d bytes", len(keyBytes), len(p))
0000000000000000000000000000000000000000;;			ar.buffer = keyBytes[len(p):]
0000000000000000000000000000000000000000;;			keyBytes = keyBytes[:len(p)]
0000000000000000000000000000000000000000;;		} else if len(keyBytes) == 0 {
0000000000000000000000000000000000000000;;			logger.Debug("No key bytes returned from the translator")
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copiedLength := copy(p, keyBytes)
0000000000000000000000000000000000000000;;		if copiedLength != len(keyBytes) {
0000000000000000000000000000000000000000;;			return 0, errors.New("Unexpected copy length encountered.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger.Debugf("Read        p[%d]: % x", copiedLength, p)
0000000000000000000000000000000000000000;;		logger.Debugf("Read keyBytes[%d]: % x", copiedLength, keyBytes)
0000000000000000000000000000000000000000;;		return copiedLength, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readInputEvents polls until at least one event is available.
0000000000000000000000000000000000000000;;	func readInputEvents(fd uintptr, maxBytes int) ([]winterm.INPUT_RECORD, error) {
0000000000000000000000000000000000000000;;		// Determine the maximum number of records to retrieve
0000000000000000000000000000000000000000;;		// -- Cast around the type system to obtain the size of a single INPUT_RECORD.
0000000000000000000000000000000000000000;;		//    unsafe.Sizeof requires an expression vs. a type-reference; the casting
0000000000000000000000000000000000000000;;		//    tricks the type system into believing it has such an expression.
0000000000000000000000000000000000000000;;		recordSize := int(unsafe.Sizeof(*((*winterm.INPUT_RECORD)(unsafe.Pointer(&maxBytes)))))
0000000000000000000000000000000000000000;;		countRecords := maxBytes / recordSize
0000000000000000000000000000000000000000;;		if countRecords > ansiterm.MAX_INPUT_EVENTS {
0000000000000000000000000000000000000000;;			countRecords = ansiterm.MAX_INPUT_EVENTS
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logger.Debugf("[windows] readInputEvents: Reading %v records (buffer size %v, record size %v)", countRecords, maxBytes, recordSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for and read input events
0000000000000000000000000000000000000000;;		events := make([]winterm.INPUT_RECORD, countRecords)
0000000000000000000000000000000000000000;;		nEvents := uint32(0)
0000000000000000000000000000000000000000;;		eventsExist, err := winterm.WaitForSingleObject(fd, winterm.WAIT_INFINITE)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if eventsExist {
0000000000000000000000000000000000000000;;			err = winterm.ReadConsoleInput(fd, events, &nEvents)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return a slice restricted to the number of returned records
0000000000000000000000000000000000000000;;		logger.Debugf("[windows] readInputEvents: Read %v events", nEvents)
0000000000000000000000000000000000000000;;		return events[:nEvents], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyEvent Translation Helpers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var arrowKeyMapPrefix = map[winterm.WORD]string{
0000000000000000000000000000000000000000;;		winterm.VK_UP:    "%s%sA",
0000000000000000000000000000000000000000;;		winterm.VK_DOWN:  "%s%sB",
0000000000000000000000000000000000000000;;		winterm.VK_RIGHT: "%s%sC",
0000000000000000000000000000000000000000;;		winterm.VK_LEFT:  "%s%sD",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var keyMapPrefix = map[winterm.WORD]string{
0000000000000000000000000000000000000000;;		winterm.VK_UP:     "\x1B[%sA",
0000000000000000000000000000000000000000;;		winterm.VK_DOWN:   "\x1B[%sB",
0000000000000000000000000000000000000000;;		winterm.VK_RIGHT:  "\x1B[%sC",
0000000000000000000000000000000000000000;;		winterm.VK_LEFT:   "\x1B[%sD",
0000000000000000000000000000000000000000;;		winterm.VK_HOME:   "\x1B[1%s~", // showkey shows ^[[1
0000000000000000000000000000000000000000;;		winterm.VK_END:    "\x1B[4%s~", // showkey shows ^[[4
0000000000000000000000000000000000000000;;		winterm.VK_INSERT: "\x1B[2%s~",
0000000000000000000000000000000000000000;;		winterm.VK_DELETE: "\x1B[3%s~",
0000000000000000000000000000000000000000;;		winterm.VK_PRIOR:  "\x1B[5%s~",
0000000000000000000000000000000000000000;;		winterm.VK_NEXT:   "\x1B[6%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F1:     "",
0000000000000000000000000000000000000000;;		winterm.VK_F2:     "",
0000000000000000000000000000000000000000;;		winterm.VK_F3:     "\x1B[13%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F4:     "\x1B[14%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F5:     "\x1B[15%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F6:     "\x1B[17%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F7:     "\x1B[18%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F8:     "\x1B[19%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F9:     "\x1B[20%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F10:    "\x1B[21%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F11:    "\x1B[23%s~",
0000000000000000000000000000000000000000;;		winterm.VK_F12:    "\x1B[24%s~",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// translateKeyEvents converts the input events into the appropriate ANSI string.
0000000000000000000000000000000000000000;;	func translateKeyEvents(events []winterm.INPUT_RECORD, escapeSequence []byte) []byte {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		for _, event := range events {
0000000000000000000000000000000000000000;;			if event.EventType == winterm.KEY_EVENT && event.KeyEvent.KeyDown != 0 {
0000000000000000000000000000000000000000;;				buffer.WriteString(keyToString(&event.KeyEvent, escapeSequence))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buffer.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keyToString maps the given input event record to the corresponding string.
0000000000000000000000000000000000000000;;	func keyToString(keyEvent *winterm.KEY_EVENT_RECORD, escapeSequence []byte) string {
0000000000000000000000000000000000000000;;		if keyEvent.UnicodeChar == 0 {
0000000000000000000000000000000000000000;;			return formatVirtualKey(keyEvent.VirtualKeyCode, keyEvent.ControlKeyState, escapeSequence)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, alt, control := getControlKeys(keyEvent.ControlKeyState)
0000000000000000000000000000000000000000;;		if control {
0000000000000000000000000000000000000000;;			// TODO(azlinux): Implement following control sequences
0000000000000000000000000000000000000000;;			// <Ctrl>-D  Signals the end of input from the keyboard; also exits current shell.
0000000000000000000000000000000000000000;;			// <Ctrl>-H  Deletes the first character to the left of the cursor. Also called the ERASE key.
0000000000000000000000000000000000000000;;			// <Ctrl>-Q  Restarts printing after it has been stopped with <Ctrl>-s.
0000000000000000000000000000000000000000;;			// <Ctrl>-S  Suspends printing on the screen (does not stop the program).
0000000000000000000000000000000000000000;;			// <Ctrl>-U  Deletes all characters on the current line. Also called the KILL key.
0000000000000000000000000000000000000000;;			// <Ctrl>-E  Quits current command and creates a core
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <Alt>+Key generates ESC N Key
0000000000000000000000000000000000000000;;		if !control && alt {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_ESC_N + strings.ToLower(string(keyEvent.UnicodeChar))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(keyEvent.UnicodeChar)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatVirtualKey converts a virtual key (e.g., up arrow) into the appropriate ANSI string.
0000000000000000000000000000000000000000;;	func formatVirtualKey(key winterm.WORD, controlState winterm.DWORD, escapeSequence []byte) string {
0000000000000000000000000000000000000000;;		shift, alt, control := getControlKeys(controlState)
0000000000000000000000000000000000000000;;		modifier := getControlKeysModifier(shift, alt, control)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if format, ok := arrowKeyMapPrefix[key]; ok {
0000000000000000000000000000000000000000;;			return fmt.Sprintf(format, escapeSequence, modifier)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if format, ok := keyMapPrefix[key]; ok {
0000000000000000000000000000000000000000;;			return fmt.Sprintf(format, modifier)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getControlKeys extracts the shift, alt, and ctrl key states.
0000000000000000000000000000000000000000;;	func getControlKeys(controlState winterm.DWORD) (shift, alt, control bool) {
0000000000000000000000000000000000000000;;		shift = 0 != (controlState & winterm.SHIFT_PRESSED)
0000000000000000000000000000000000000000;;		alt = 0 != (controlState & (winterm.LEFT_ALT_PRESSED | winterm.RIGHT_ALT_PRESSED))
0000000000000000000000000000000000000000;;		control = 0 != (controlState & (winterm.LEFT_CTRL_PRESSED | winterm.RIGHT_CTRL_PRESSED))
0000000000000000000000000000000000000000;;		return shift, alt, control
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getControlKeysModifier returns the ANSI modifier for the given combination of control keys.
0000000000000000000000000000000000000000;;	func getControlKeysModifier(shift, alt, control bool) string {
0000000000000000000000000000000000000000;;		if shift && alt && control {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_CONTROL_PARAM_8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if alt && control {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_CONTROL_PARAM_7
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if shift && control {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_CONTROL_PARAM_6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if control {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_CONTROL_PARAM_5
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if shift && alt {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_CONTROL_PARAM_4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if alt {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_CONTROL_PARAM_3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if shift {
0000000000000000000000000000000000000000;;			return ansiterm.KEY_CONTROL_PARAM_2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
