0000000000000000000000000000000000000000;;	// +build windows
ab71d75cf683c780361e644c5f2ee500a1c1e0f8;Godeps/_workspace/src/github.com/docker/docker/pkg/term/term_windows.go[Godeps/_workspace/src/github.com/docker/docker/pkg/term/term_windows.go][vendor/github.com/docker/docker/pkg/term/term_windows.go];	
0000000000000000000000000000000000000000;;	package term
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/signal"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/go-ansiterm/winterm"
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/system"
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/term/windows"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// State holds the console mode for the terminal.
0000000000000000000000000000000000000000;;	type State struct {
0000000000000000000000000000000000000000;;		inMode, outMode     uint32
0000000000000000000000000000000000000000;;		inHandle, outHandle syscall.Handle
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Winsize is used for window size.
0000000000000000000000000000000000000000;;	type Winsize struct {
0000000000000000000000000000000000000000;;		Height uint16
0000000000000000000000000000000000000000;;		Width  uint16
0000000000000000000000000000000000000000;;		x      uint16
0000000000000000000000000000000000000000;;		y      uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// https://msdn.microsoft.com/en-us/library/windows/desktop/ms683167(v=vs.85).aspx
0000000000000000000000000000000000000000;;		enableVirtualTerminalInput      = 0x0200
0000000000000000000000000000000000000000;;		enableVirtualTerminalProcessing = 0x0004
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// usingNativeConsole is true if we are using the Windows native console
0000000000000000000000000000000000000000;;	var usingNativeConsole bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StdStreams returns the standard streams (stdin, stdout, stedrr).
0000000000000000000000000000000000000000;;	func StdStreams() (stdIn io.ReadCloser, stdOut, stdErr io.Writer) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case os.Getenv("ConEmuANSI") == "ON":
0000000000000000000000000000000000000000;;			// The ConEmu terminal emulates ANSI on output streams well.
0000000000000000000000000000000000000000;;			return windows.ConEmuStreams()
0000000000000000000000000000000000000000;;		case os.Getenv("MSYSTEM") != "":
0000000000000000000000000000000000000000;;			// MSYS (mingw) does not emulate ANSI well.
0000000000000000000000000000000000000000;;			return windows.ConsoleStreams()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if useNativeConsole() {
0000000000000000000000000000000000000000;;				usingNativeConsole = true
0000000000000000000000000000000000000000;;				return os.Stdin, os.Stdout, os.Stderr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return windows.ConsoleStreams()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// useNativeConsole determines if the docker client should use the built-in
0000000000000000000000000000000000000000;;	// console which supports ANSI emulation, or fall-back to the golang emulator
0000000000000000000000000000000000000000;;	// (github.com/azure/go-ansiterm).
0000000000000000000000000000000000000000;;	func useNativeConsole() bool {
0000000000000000000000000000000000000000;;		osv, err := system.GetOSVersion()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Native console is not available before major version 10
0000000000000000000000000000000000000000;;		if osv.MajorVersion < 10 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must have a late pre-release TP4 build of Windows Server 2016/Windows 10 TH2 or later
0000000000000000000000000000000000000000;;		if osv.Build < 10578 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the console modes. If this fails, we can't use the native console
0000000000000000000000000000000000000000;;		state, err := getNativeConsole()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Probe the console to see if it can be enabled.
0000000000000000000000000000000000000000;;		if nil != probeNativeConsole(state) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Environment variable override
0000000000000000000000000000000000000000;;		if e := os.Getenv("USE_NATIVE_CONSOLE"); e != "" {
0000000000000000000000000000000000000000;;			if e == "1" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO Windows. The native emulator still has issues which
0000000000000000000000000000000000000000;;		// mean it shouldn't be enabled for everyone. Change this next line to true
0000000000000000000000000000000000000000;;		// to change the default to "enable if available". In the meantime, users
0000000000000000000000000000000000000000;;		// can still try it out by using USE_NATIVE_CONSOLE env variable.
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNativeConsole returns the console modes ('state') for the native Windows console
0000000000000000000000000000000000000000;;	func getNativeConsole() (State, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err   error
0000000000000000000000000000000000000000;;			state State
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the handle to stdout
0000000000000000000000000000000000000000;;		if state.outHandle, err = syscall.GetStdHandle(syscall.STD_OUTPUT_HANDLE); err != nil {
0000000000000000000000000000000000000000;;			return state, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the console mode from the consoles stdout handle
0000000000000000000000000000000000000000;;		if err = syscall.GetConsoleMode(state.outHandle, &state.outMode); err != nil {
0000000000000000000000000000000000000000;;			return state, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the handle to stdin
0000000000000000000000000000000000000000;;		if state.inHandle, err = syscall.GetStdHandle(syscall.STD_INPUT_HANDLE); err != nil {
0000000000000000000000000000000000000000;;			return state, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the console mode from the consoles stdin handle
0000000000000000000000000000000000000000;;		if err = syscall.GetConsoleMode(state.inHandle, &state.inMode); err != nil {
0000000000000000000000000000000000000000;;			return state, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// probeNativeConsole probes the console to determine if native can be supported,
0000000000000000000000000000000000000000;;	func probeNativeConsole(state State) error {
0000000000000000000000000000000000000000;;		if err := winterm.SetConsoleMode(uintptr(state.outHandle), state.outMode|enableVirtualTerminalProcessing); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer winterm.SetConsoleMode(uintptr(state.outHandle), state.outMode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := winterm.SetConsoleMode(uintptr(state.inHandle), state.inMode|enableVirtualTerminalInput); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer winterm.SetConsoleMode(uintptr(state.inHandle), state.inMode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enableNativeConsole turns on native console mode
0000000000000000000000000000000000000000;;	func enableNativeConsole(state State) error {
0000000000000000000000000000000000000000;;		if err := winterm.SetConsoleMode(uintptr(state.outHandle), state.outMode|enableVirtualTerminalProcessing); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := winterm.SetConsoleMode(uintptr(state.inHandle), state.inMode|enableVirtualTerminalInput); err != nil {
0000000000000000000000000000000000000000;;			winterm.SetConsoleMode(uintptr(state.outHandle), state.outMode) // restore out if we can
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// disableNativeConsole turns off native console mode
0000000000000000000000000000000000000000;;	func disableNativeConsole(state *State) error {
0000000000000000000000000000000000000000;;		// Try and restore both in an out before error checking.
0000000000000000000000000000000000000000;;		errout := winterm.SetConsoleMode(uintptr(state.outHandle), state.outMode)
0000000000000000000000000000000000000000;;		errin := winterm.SetConsoleMode(uintptr(state.inHandle), state.inMode)
0000000000000000000000000000000000000000;;		if errout != nil {
0000000000000000000000000000000000000000;;			return errout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errin != nil {
0000000000000000000000000000000000000000;;			return errin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFdInfo returns the file descriptor for an os.File and indicates whether the file represents a terminal.
0000000000000000000000000000000000000000;;	func GetFdInfo(in interface{}) (uintptr, bool) {
0000000000000000000000000000000000000000;;		return windows.GetHandleInfo(in)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetWinsize returns the window size based on the specified file descriptor.
0000000000000000000000000000000000000000;;	func GetWinsize(fd uintptr) (*Winsize, error) {
0000000000000000000000000000000000000000;;		info, err := winterm.GetConsoleScreenBufferInfo(fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		winsize := &Winsize{
0000000000000000000000000000000000000000;;			Width:  uint16(info.Window.Right - info.Window.Left + 1),
0000000000000000000000000000000000000000;;			Height: uint16(info.Window.Bottom - info.Window.Top + 1),
0000000000000000000000000000000000000000;;			x:      0,
0000000000000000000000000000000000000000;;			y:      0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return winsize, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsTerminal returns true if the given file descriptor is a terminal.
0000000000000000000000000000000000000000;;	func IsTerminal(fd uintptr) bool {
0000000000000000000000000000000000000000;;		return windows.IsConsole(fd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestoreTerminal restores the terminal connected to the given file descriptor
0000000000000000000000000000000000000000;;	// to a previous state.
0000000000000000000000000000000000000000;;	func RestoreTerminal(fd uintptr, state *State) error {
0000000000000000000000000000000000000000;;		if usingNativeConsole {
0000000000000000000000000000000000000000;;			return disableNativeConsole(state)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return winterm.SetConsoleMode(fd, state.outMode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SaveState saves the state of the terminal connected to the given file descriptor.
0000000000000000000000000000000000000000;;	func SaveState(fd uintptr) (*State, error) {
0000000000000000000000000000000000000000;;		if usingNativeConsole {
0000000000000000000000000000000000000000;;			state, err := getNativeConsole()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &state, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mode, e := winterm.GetConsoleMode(fd)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &State{outMode: mode}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisableEcho disables echo for the terminal connected to the given file descriptor.
0000000000000000000000000000000000000000;;	// -- See https://msdn.microsoft.com/en-us/library/windows/desktop/ms683462(v=vs.85).aspx
0000000000000000000000000000000000000000;;	func DisableEcho(fd uintptr, state *State) error {
0000000000000000000000000000000000000000;;		mode := state.inMode
0000000000000000000000000000000000000000;;		mode &^= winterm.ENABLE_ECHO_INPUT
0000000000000000000000000000000000000000;;		mode |= winterm.ENABLE_PROCESSED_INPUT | winterm.ENABLE_LINE_INPUT
0000000000000000000000000000000000000000;;		err := winterm.SetConsoleMode(fd, mode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register an interrupt handler to catch and restore prior state
0000000000000000000000000000000000000000;;		restoreAtInterrupt(fd, state)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetRawTerminal puts the terminal connected to the given file descriptor into raw
0000000000000000000000000000000000000000;;	// mode and returns the previous state.
0000000000000000000000000000000000000000;;	func SetRawTerminal(fd uintptr) (*State, error) {
0000000000000000000000000000000000000000;;		state, err := MakeRaw(fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register an interrupt handler to catch and restore prior state
0000000000000000000000000000000000000000;;		restoreAtInterrupt(fd, state)
0000000000000000000000000000000000000000;;		return state, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeRaw puts the terminal (Windows Console) connected to the given file descriptor into raw
0000000000000000000000000000000000000000;;	// mode and returns the previous state of the terminal so that it can be restored.
0000000000000000000000000000000000000000;;	func MakeRaw(fd uintptr) (*State, error) {
0000000000000000000000000000000000000000;;		state, err := SaveState(fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mode := state.inMode
0000000000000000000000000000000000000000;;		if usingNativeConsole {
0000000000000000000000000000000000000000;;			if err := enableNativeConsole(*state); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mode |= enableVirtualTerminalInput
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See
0000000000000000000000000000000000000000;;		// -- https://msdn.microsoft.com/en-us/library/windows/desktop/ms686033(v=vs.85).aspx
0000000000000000000000000000000000000000;;		// -- https://msdn.microsoft.com/en-us/library/windows/desktop/ms683462(v=vs.85).aspx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Disable these modes
0000000000000000000000000000000000000000;;		mode &^= winterm.ENABLE_ECHO_INPUT
0000000000000000000000000000000000000000;;		mode &^= winterm.ENABLE_LINE_INPUT
0000000000000000000000000000000000000000;;		mode &^= winterm.ENABLE_MOUSE_INPUT
0000000000000000000000000000000000000000;;		mode &^= winterm.ENABLE_WINDOW_INPUT
0000000000000000000000000000000000000000;;		mode &^= winterm.ENABLE_PROCESSED_INPUT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enable these modes
0000000000000000000000000000000000000000;;		mode |= winterm.ENABLE_EXTENDED_FLAGS
0000000000000000000000000000000000000000;;		mode |= winterm.ENABLE_INSERT_MODE
0000000000000000000000000000000000000000;;		mode |= winterm.ENABLE_QUICK_EDIT_MODE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = winterm.SetConsoleMode(fd, mode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restoreAtInterrupt(fd uintptr, state *State) {
0000000000000000000000000000000000000000;;		sigchan := make(chan os.Signal, 1)
0000000000000000000000000000000000000000;;		signal.Notify(sigchan, os.Interrupt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			_ = <-sigchan
0000000000000000000000000000000000000000;;			RestoreTerminal(fd, state)
0000000000000000000000000000000000000000;;			os.Exit(0)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
