0000000000000000000000000000000000000000;;	// +build !cgo
ab71d75cf683c780361e644c5f2ee500a1c1e0f8;Godeps/_workspace/src/github.com/docker/docker/pkg/term/termios_linux.go[Godeps/_workspace/src/github.com/docker/docker/pkg/term/termios_linux.go][vendor/github.com/docker/docker/pkg/term/termios_linux.go];	
0000000000000000000000000000000000000000;;	package term
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		getTermios = syscall.TCGETS
0000000000000000000000000000000000000000;;		setTermios = syscall.TCSETS
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Termios is the Unix API for terminal I/O.
0000000000000000000000000000000000000000;;	type Termios struct {
0000000000000000000000000000000000000000;;		Iflag  uint32
0000000000000000000000000000000000000000;;		Oflag  uint32
0000000000000000000000000000000000000000;;		Cflag  uint32
0000000000000000000000000000000000000000;;		Lflag  uint32
0000000000000000000000000000000000000000;;		Cc     [20]byte
0000000000000000000000000000000000000000;;		Ispeed uint32
0000000000000000000000000000000000000000;;		Ospeed uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MakeRaw put the terminal connected to the given file descriptor into raw
0000000000000000000000000000000000000000;;	// mode and returns the previous state of the terminal so that it can be
0000000000000000000000000000000000000000;;	// restored.
0000000000000000000000000000000000000000;;	func MakeRaw(fd uintptr) (*State, error) {
0000000000000000000000000000000000000000;;		var oldState State
0000000000000000000000000000000000000000;;		if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, getTermios, uintptr(unsafe.Pointer(&oldState.termios))); err != 0 {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newState := oldState.termios
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newState.Iflag &^= (syscall.IGNBRK | syscall.BRKINT | syscall.PARMRK | syscall.ISTRIP | syscall.INLCR | syscall.IGNCR | syscall.ICRNL | syscall.IXON)
0000000000000000000000000000000000000000;;		newState.Oflag &^= syscall.OPOST
0000000000000000000000000000000000000000;;		newState.Lflag &^= (syscall.ECHO | syscall.ECHONL | syscall.ICANON | syscall.ISIG | syscall.IEXTEN)
0000000000000000000000000000000000000000;;		newState.Cflag &^= (syscall.CSIZE | syscall.PARENB)
0000000000000000000000000000000000000000;;		newState.Cflag |= syscall.CS8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, setTermios, uintptr(unsafe.Pointer(&newState))); err != 0 {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &oldState, nil
0000000000000000000000000000000000000000;;	}
