0000000000000000000000000000000000000000;;	// This code was initially generated by ffjson <https://github.com/pquerna/ffjson>
0000000000000000000000000000000000000000;;	// This code was generated via the following steps:
0000000000000000000000000000000000000000;;	// $ go get -u github.com/pquerna/ffjson
0000000000000000000000000000000000000000;;	// $ make BIND_DIR=. shell
0000000000000000000000000000000000000000;;	// $ ffjson pkg/jsonlog/jsonlog.go
0000000000000000000000000000000000000000;;	// $ mv pkg/jsonglog/jsonlog_ffjson.go pkg/jsonlog/jsonlog_marshalling.go
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It has been modified to improve the performance of time marshalling to JSON
0000000000000000000000000000000000000000;;	// and to clean it up.
0000000000000000000000000000000000000000;;	// Should this code need to be regenerated when the JSONLog struct is changed,
0000000000000000000000000000000000000000;;	// the relevant changes which have been made are:
0000000000000000000000000000000000000000;;	// import (
0000000000000000000000000000000000000000;;	//        "bytes"
0000000000000000000000000000000000000000;;	//-
0000000000000000000000000000000000000000;;	//        "unicode/utf8"
0000000000000000000000000000000000000000;;	// )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// func (mj *JSONLog) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;	//@@ -20,13 +16,13 @@ func (mj *JSONLog) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;	//        }
0000000000000000000000000000000000000000;;	//        return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//+
0000000000000000000000000000000000000000;;	// func (mj *JSONLog) MarshalJSONBuf(buf *bytes.Buffer) error {
0000000000000000000000000000000000000000;;	//-       var err error
0000000000000000000000000000000000000000;;	//-       var obj []byte
0000000000000000000000000000000000000000;;	//-       var first bool = true
0000000000000000000000000000000000000000;;	//-       _ = obj
0000000000000000000000000000000000000000;;	//-       _ = err
0000000000000000000000000000000000000000;;	//-       _ = first
0000000000000000000000000000000000000000;;	//+       var (
0000000000000000000000000000000000000000;;	//+               err       error
0000000000000000000000000000000000000000;;	//+               timestamp string
0000000000000000000000000000000000000000;;	//+               first     bool = true
0000000000000000000000000000000000000000;;	//+       )
0000000000000000000000000000000000000000;;	//        buf.WriteString(`{`)
0000000000000000000000000000000000000000;;	//        if len(mj.Log) != 0 {
0000000000000000000000000000000000000000;;	//                if first == true {
0000000000000000000000000000000000000000;;	//@@ -52,11 +48,11 @@ func (mj *JSONLog) MarshalJSONBuf(buf *bytes.Buffer) error {
0000000000000000000000000000000000000000;;	//                buf.WriteString(`,`)
0000000000000000000000000000000000000000;;	//        }
0000000000000000000000000000000000000000;;	//        buf.WriteString(`"time":`)
0000000000000000000000000000000000000000;;	//-       obj, err = mj.Created.MarshalJSON()
0000000000000000000000000000000000000000;;	//+       timestamp, err = FastTimeMarshalJSON(mj.Created)
0000000000000000000000000000000000000000;;	//        if err != nil {
0000000000000000000000000000000000000000;;	//                return err
0000000000000000000000000000000000000000;;	//        }
0000000000000000000000000000000000000000;;	//-       buf.Write(obj)
0000000000000000000000000000000000000000;;	//+       buf.WriteString(timestamp)
0000000000000000000000000000000000000000;;	//        buf.WriteString(`}`)
0000000000000000000000000000000000000000;;	//        return nil
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	// @@ -81,9 +81,10 @@ func (mj *JSONLog) MarshalJSONBuf(buf *bytes.Buffer) error {
0000000000000000000000000000000000000000;;	//         if len(mj.Log) != 0 {
0000000000000000000000000000000000000000;;	// -                if first == true {
0000000000000000000000000000000000000000;;	// -                       first = false
0000000000000000000000000000000000000000;;	// -               } else {
0000000000000000000000000000000000000000;;	// -                       buf.WriteString(`,`)
0000000000000000000000000000000000000000;;	// -               }
0000000000000000000000000000000000000000;;	// +               first = false
0000000000000000000000000000000000000000;;	//                 buf.WriteString(`"log":`)
0000000000000000000000000000000000000000;;	//                 ffjsonWriteJSONString(buf, mj.Log)
0000000000000000000000000000000000000000;;	//         }
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	package jsonlog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshals the JSONLog.
0000000000000000000000000000000000000000;;	func (mj *JSONLog) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		buf.Grow(1024)
0000000000000000000000000000000000000000;;		if err := mj.MarshalJSONBuf(&buf); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSONBuf marshals the JSONLog and stores the result to a bytes.Buffer.
0000000000000000000000000000000000000000;;	func (mj *JSONLog) MarshalJSONBuf(buf *bytes.Buffer) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err       error
0000000000000000000000000000000000000000;;			timestamp string
0000000000000000000000000000000000000000;;			first     = true
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		buf.WriteString(`{`)
0000000000000000000000000000000000000000;;		if len(mj.Log) != 0 {
0000000000000000000000000000000000000000;;			first = false
0000000000000000000000000000000000000000;;			buf.WriteString(`"log":`)
0000000000000000000000000000000000000000;;			ffjsonWriteJSONString(buf, mj.Log)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(mj.Stream) != 0 {
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteString(`,`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteString(`"stream":`)
0000000000000000000000000000000000000000;;			ffjsonWriteJSONString(buf, mj.Stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !first {
0000000000000000000000000000000000000000;;			buf.WriteString(`,`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteString(`"time":`)
0000000000000000000000000000000000000000;;		timestamp, err = FastTimeMarshalJSON(mj.Created)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteString(timestamp)
0000000000000000000000000000000000000000;;		buf.WriteString(`}`)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ffjsonWriteJSONString(buf *bytes.Buffer, s string) {
0000000000000000000000000000000000000000;;		const hex = "0123456789abcdef"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteByte('"')
0000000000000000000000000000000000000000;;		start := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); {
0000000000000000000000000000000000000000;;			if b := s[i]; b < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				if 0x20 <= b && b != '\\' && b != '"' && b != '<' && b != '>' && b != '&' {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					buf.WriteString(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch b {
0000000000000000000000000000000000000000;;				case '\\', '"':
0000000000000000000000000000000000000000;;					buf.WriteByte('\\')
0000000000000000000000000000000000000000;;					buf.WriteByte(b)
0000000000000000000000000000000000000000;;				case '\n':
0000000000000000000000000000000000000000;;					buf.WriteByte('\\')
0000000000000000000000000000000000000000;;					buf.WriteByte('n')
0000000000000000000000000000000000000000;;				case '\r':
0000000000000000000000000000000000000000;;					buf.WriteByte('\\')
0000000000000000000000000000000000000000;;					buf.WriteByte('r')
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					buf.WriteString(`\u00`)
0000000000000000000000000000000000000000;;					buf.WriteByte(hex[b>>4])
0000000000000000000000000000000000000000;;					buf.WriteByte(hex[b&0xF])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c, size := utf8.DecodeRuneInString(s[i:])
0000000000000000000000000000000000000000;;			if c == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					buf.WriteString(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(`\ufffd`)
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c == '\u2028' || c == '\u2029' {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					buf.WriteString(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(`\u202`)
0000000000000000000000000000000000000000;;				buf.WriteByte(hex[c&0xF])
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start < len(s) {
0000000000000000000000000000000000000000;;			buf.WriteString(s[start:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteByte('"')
0000000000000000000000000000000000000000;;	}
