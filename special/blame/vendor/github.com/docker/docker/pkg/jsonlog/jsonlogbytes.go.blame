0000000000000000000000000000000000000000;;	package jsonlog
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONLogs is based on JSONLog.
0000000000000000000000000000000000000000;;	// It allows marshalling JSONLog from Log as []byte
0000000000000000000000000000000000000000;;	// and an already marshalled Created timestamp.
0000000000000000000000000000000000000000;;	type JSONLogs struct {
0000000000000000000000000000000000000000;;		Log     []byte `json:"log,omitempty"`
0000000000000000000000000000000000000000;;		Stream  string `json:"stream,omitempty"`
0000000000000000000000000000000000000000;;		Created string `json:"time"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// json-encoded bytes
0000000000000000000000000000000000000000;;		RawAttrs json.RawMessage `json:"attrs,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSONBuf is based on the same method from JSONLog
0000000000000000000000000000000000000000;;	// It has been modified to take into account the necessary changes.
0000000000000000000000000000000000000000;;	func (mj *JSONLogs) MarshalJSONBuf(buf *bytes.Buffer) error {
0000000000000000000000000000000000000000;;		var first = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteString(`{`)
0000000000000000000000000000000000000000;;		if len(mj.Log) != 0 {
0000000000000000000000000000000000000000;;			first = false
0000000000000000000000000000000000000000;;			buf.WriteString(`"log":`)
0000000000000000000000000000000000000000;;			ffjsonWriteJSONBytesAsString(buf, mj.Log)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(mj.Stream) != 0 {
0000000000000000000000000000000000000000;;			if first == true {
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteString(`,`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteString(`"stream":`)
0000000000000000000000000000000000000000;;			ffjsonWriteJSONString(buf, mj.Stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(mj.RawAttrs) > 0 {
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteString(`,`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteString(`"attrs":`)
0000000000000000000000000000000000000000;;			buf.Write(mj.RawAttrs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !first {
0000000000000000000000000000000000000000;;			buf.WriteString(`,`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteString(`"time":`)
0000000000000000000000000000000000000000;;		buf.WriteString(mj.Created)
0000000000000000000000000000000000000000;;		buf.WriteString(`}`)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is based on ffjsonWriteJSONBytesAsString. It has been changed
0000000000000000000000000000000000000000;;	// to accept a string passed as a slice of bytes.
0000000000000000000000000000000000000000;;	func ffjsonWriteJSONBytesAsString(buf *bytes.Buffer, s []byte) {
0000000000000000000000000000000000000000;;		const hex = "0123456789abcdef"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteByte('"')
0000000000000000000000000000000000000000;;		start := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); {
0000000000000000000000000000000000000000;;			if b := s[i]; b < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				if 0x20 <= b && b != '\\' && b != '"' && b != '<' && b != '>' && b != '&' {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					buf.Write(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch b {
0000000000000000000000000000000000000000;;				case '\\', '"':
0000000000000000000000000000000000000000;;					buf.WriteByte('\\')
0000000000000000000000000000000000000000;;					buf.WriteByte(b)
0000000000000000000000000000000000000000;;				case '\n':
0000000000000000000000000000000000000000;;					buf.WriteByte('\\')
0000000000000000000000000000000000000000;;					buf.WriteByte('n')
0000000000000000000000000000000000000000;;				case '\r':
0000000000000000000000000000000000000000;;					buf.WriteByte('\\')
0000000000000000000000000000000000000000;;					buf.WriteByte('r')
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					buf.WriteString(`\u00`)
0000000000000000000000000000000000000000;;					buf.WriteByte(hex[b>>4])
0000000000000000000000000000000000000000;;					buf.WriteByte(hex[b&0xF])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c, size := utf8.DecodeRune(s[i:])
0000000000000000000000000000000000000000;;			if c == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					buf.Write(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(`\ufffd`)
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c == '\u2028' || c == '\u2029' {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					buf.Write(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(`\u202`)
0000000000000000000000000000000000000000;;				buf.WriteByte(hex[c&0xF])
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start < len(s) {
0000000000000000000000000000000000000000;;			buf.Write(s[start:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteByte('"')
0000000000000000000000000000000000000000;;	}
