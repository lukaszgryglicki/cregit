0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE.BSD file.
d130243057bea8ebcfa3fdfcb8c3aeaf4ca246bf;Godeps/_workspace/src/github.com/docker/docker/pkg/symlink/fs.go[Godeps/_workspace/src/github.com/docker/docker/pkg/symlink/fs.go][vendor/github.com/docker/docker/pkg/symlink/fs.go];	
0000000000000000000000000000000000000000;;	// This code is a modified version of path/filepath/symlink.go from the Go standard library.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package symlink
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/system"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FollowSymlinkInScope is a wrapper around evalSymlinksInScope that returns an
0000000000000000000000000000000000000000;;	// absolute path. This function handles paths in a platform-agnostic manner.
0000000000000000000000000000000000000000;;	func FollowSymlinkInScope(path, root string) (string, error) {
0000000000000000000000000000000000000000;;		path, err := filepath.Abs(filepath.FromSlash(path))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		root, err = filepath.Abs(filepath.FromSlash(root))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return evalSymlinksInScope(path, root)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalSymlinksInScope will evaluate symlinks in `path` within a scope `root` and return
0000000000000000000000000000000000000000;;	// a result guaranteed to be contained within the scope `root`, at the time of the call.
0000000000000000000000000000000000000000;;	// Symlinks in `root` are not evaluated and left as-is.
0000000000000000000000000000000000000000;;	// Errors encountered while attempting to evaluate symlinks in path will be returned.
0000000000000000000000000000000000000000;;	// Non-existing paths are valid and do not constitute an error.
0000000000000000000000000000000000000000;;	// `path` has to contain `root` as a prefix, or else an error will be returned.
0000000000000000000000000000000000000000;;	// Trying to break out from `root` does not constitute an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	//   If /foo/bar -> /outside,
0000000000000000000000000000000000000000;;	//   FollowSymlinkInScope("/foo/bar", "/foo") == "/foo/outside" instead of "/oustide"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// IMPORTANT: it is the caller's responsibility to call evalSymlinksInScope *after* relevant symlinks
0000000000000000000000000000000000000000;;	// are created and not to create subsequently, additional symlinks that could potentially make a
0000000000000000000000000000000000000000;;	// previously-safe path, unsafe. Example: if /foo/bar does not exist, evalSymlinksInScope("/foo/bar", "/foo")
0000000000000000000000000000000000000000;;	// would return "/foo/bar". If one makes /foo/bar a symlink to /baz subsequently, then "/foo/bar" should
0000000000000000000000000000000000000000;;	// no longer be considered safely contained in "/foo".
0000000000000000000000000000000000000000;;	func evalSymlinksInScope(path, root string) (string, error) {
0000000000000000000000000000000000000000;;		root = filepath.Clean(root)
0000000000000000000000000000000000000000;;		if path == root {
0000000000000000000000000000000000000000;;			return path, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(path, root) {
0000000000000000000000000000000000000000;;			return "", errors.New("evalSymlinksInScope: " + path + " is not in " + root)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		const maxIter = 255
0000000000000000000000000000000000000000;;		originalPath := path
0000000000000000000000000000000000000000;;		// given root of "/a" and path of "/a/b/../../c" we want path to be "/b/../../c"
0000000000000000000000000000000000000000;;		path = path[len(root):]
0000000000000000000000000000000000000000;;		if root == string(filepath.Separator) {
0000000000000000000000000000000000000000;;			path = string(filepath.Separator) + path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(path, string(filepath.Separator)) {
0000000000000000000000000000000000000000;;			return "", errors.New("evalSymlinksInScope: " + path + " is not in " + root)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path = filepath.Clean(path)
0000000000000000000000000000000000000000;;		// consume path by taking each frontmost path element,
0000000000000000000000000000000000000000;;		// expanding it if it's a symlink, and appending it to b
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		// b here will always be considered to be the "current absolute path inside
0000000000000000000000000000000000000000;;		// root" when we append paths to it, we also append a slash and use
0000000000000000000000000000000000000000;;		// filepath.Clean after the loop to trim the trailing slash
0000000000000000000000000000000000000000;;		for n := 0; path != ""; n++ {
0000000000000000000000000000000000000000;;			if n > maxIter {
0000000000000000000000000000000000000000;;				return "", errors.New("evalSymlinksInScope: too many links in " + originalPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// find next path component, p
0000000000000000000000000000000000000000;;			i := strings.IndexRune(path, filepath.Separator)
0000000000000000000000000000000000000000;;			var p string
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				p, path = path, ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p, path = path[:i], path[i+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// this takes a b.String() like "b/../" and a p like "c" and turns it
0000000000000000000000000000000000000000;;			// into "/b/../c" which then gets filepath.Cleaned into "/c" and then
0000000000000000000000000000000000000000;;			// root gets prepended and we Clean again (to remove any trailing slash
0000000000000000000000000000000000000000;;			// if the first Clean gave us just "/")
0000000000000000000000000000000000000000;;			cleanP := filepath.Clean(string(filepath.Separator) + b.String() + p)
0000000000000000000000000000000000000000;;			if cleanP == string(filepath.Separator) {
0000000000000000000000000000000000000000;;				// never Lstat "/" itself
0000000000000000000000000000000000000000;;				b.Reset()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fullP := filepath.Clean(root + cleanP)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fi, err := os.Lstat(fullP)
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				// if p does not exist, accept it
0000000000000000000000000000000000000000;;				b.WriteString(p)
0000000000000000000000000000000000000000;;				b.WriteRune(filepath.Separator)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fi.Mode()&os.ModeSymlink == 0 {
0000000000000000000000000000000000000000;;				b.WriteString(p + string(filepath.Separator))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// it's a symlink, put it at the front of path
0000000000000000000000000000000000000000;;			dest, err := os.Readlink(fullP)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if system.IsAbs(dest) {
0000000000000000000000000000000000000000;;				b.Reset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			path = dest + string(filepath.Separator) + path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see note above on "fullP := ..." for why this is double-cleaned and
0000000000000000000000000000000000000000;;		// what's happening here
0000000000000000000000000000000000000000;;		return filepath.Clean(root + filepath.Clean(string(filepath.Separator)+b.String())), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EvalSymlinks returns the path name after the evaluation of any symbolic
0000000000000000000000000000000000000000;;	// links.
0000000000000000000000000000000000000000;;	// If path is relative the result will be relative to the current directory,
0000000000000000000000000000000000000000;;	// unless one of the components is an absolute symbolic link.
0000000000000000000000000000000000000000;;	// This version has been updated to support long paths prepended with `\\?\`.
0000000000000000000000000000000000000000;;	func EvalSymlinks(path string) (string, error) {
0000000000000000000000000000000000000000;;		return evalSymlinks(path)
0000000000000000000000000000000000000000;;	}
