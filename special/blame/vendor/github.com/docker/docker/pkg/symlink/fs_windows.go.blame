0000000000000000000000000000000000000000;;	package symlink
b515bda5eede841df021a5bfcc6c5c7c7a1e907e;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/longpath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toShort(path string) (string, error) {
0000000000000000000000000000000000000000;;		p, err := syscall.UTF16FromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := p // GetShortPathName says we can reuse buffer
0000000000000000000000000000000000000000;;		n, err := syscall.GetShortPathName(&p[0], &b[0], uint32(len(b)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n > uint32(len(b)) {
0000000000000000000000000000000000000000;;			b = make([]uint16, n)
0000000000000000000000000000000000000000;;			if _, err = syscall.GetShortPathName(&p[0], &b[0], uint32(len(b))); err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.UTF16ToString(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toLong(path string) (string, error) {
0000000000000000000000000000000000000000;;		p, err := syscall.UTF16FromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := p // GetLongPathName says we can reuse buffer
0000000000000000000000000000000000000000;;		n, err := syscall.GetLongPathName(&p[0], &b[0], uint32(len(b)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n > uint32(len(b)) {
0000000000000000000000000000000000000000;;			b = make([]uint16, n)
0000000000000000000000000000000000000000;;			n, err = syscall.GetLongPathName(&p[0], &b[0], uint32(len(b)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b = b[:n]
0000000000000000000000000000000000000000;;		return syscall.UTF16ToString(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func evalSymlinks(path string) (string, error) {
0000000000000000000000000000000000000000;;		path, err := walkSymlinks(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := toShort(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err = toLong(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// syscall.GetLongPathName does not change the case of the drive letter,
0000000000000000000000000000000000000000;;		// but the result of EvalSymlinks must be unique, so we have
0000000000000000000000000000000000000000;;		// EvalSymlinks(`c:\a`) == EvalSymlinks(`C:\a`).
0000000000000000000000000000000000000000;;		// Make drive letter upper case.
0000000000000000000000000000000000000000;;		if len(p) >= 2 && p[1] == ':' && 'a' <= p[0] && p[0] <= 'z' {
0000000000000000000000000000000000000000;;			p = string(p[0]+'A'-'a') + p[1:]
0000000000000000000000000000000000000000;;		} else if len(p) >= 6 && p[5] == ':' && 'a' <= p[4] && p[4] <= 'z' {
0000000000000000000000000000000000000000;;			p = p[:3] + string(p[4]+'A'-'a') + p[5:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Clean(p), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const utf8RuneSelf = 0x80
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func walkSymlinks(path string) (string, error) {
0000000000000000000000000000000000000000;;		const maxIter = 255
0000000000000000000000000000000000000000;;		originalPath := path
0000000000000000000000000000000000000000;;		// consume path by taking each frontmost path element,
0000000000000000000000000000000000000000;;		// expanding it if it's a symlink, and appending it to b
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		for n := 0; path != ""; n++ {
0000000000000000000000000000000000000000;;			if n > maxIter {
0000000000000000000000000000000000000000;;				return "", errors.New("EvalSymlinks: too many links in " + originalPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A path beginning with `\\?\` represents the root, so automatically
0000000000000000000000000000000000000000;;			// skip that part and begin processing the next segment.
0000000000000000000000000000000000000000;;			if strings.HasPrefix(path, longpath.Prefix) {
0000000000000000000000000000000000000000;;				b.WriteString(longpath.Prefix)
0000000000000000000000000000000000000000;;				path = path[4:]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// find next path component, p
0000000000000000000000000000000000000000;;			var i = -1
0000000000000000000000000000000000000000;;			for j, c := range path {
0000000000000000000000000000000000000000;;				if c < utf8RuneSelf && os.IsPathSeparator(uint8(c)) {
0000000000000000000000000000000000000000;;					i = j
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var p string
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				p, path = path, ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p, path = path[:i], path[i+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p == "" {
0000000000000000000000000000000000000000;;				if b.Len() == 0 {
0000000000000000000000000000000000000000;;					// must be absolute path
0000000000000000000000000000000000000000;;					b.WriteRune(filepath.Separator)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If this is the first segment after the long path prefix, accept the
0000000000000000000000000000000000000000;;			// current segment as a volume root or UNC share and move on to the next.
0000000000000000000000000000000000000000;;			if b.String() == longpath.Prefix {
0000000000000000000000000000000000000000;;				b.WriteString(p)
0000000000000000000000000000000000000000;;				b.WriteRune(filepath.Separator)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fi, err := os.Lstat(b.String() + p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fi.Mode()&os.ModeSymlink == 0 {
0000000000000000000000000000000000000000;;				b.WriteString(p)
0000000000000000000000000000000000000000;;				if path != "" || (b.Len() == 2 && len(p) == 2 && p[1] == ':') {
0000000000000000000000000000000000000000;;					b.WriteRune(filepath.Separator)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// it's a symlink, put it at the front of path
0000000000000000000000000000000000000000;;			dest, err := os.Readlink(b.String() + p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if filepath.IsAbs(dest) || os.IsPathSeparator(dest[0]) {
0000000000000000000000000000000000000000;;				b.Reset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			path = dest + string(filepath.Separator) + path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Clean(b.String()), nil
0000000000000000000000000000000000000000;;	}
