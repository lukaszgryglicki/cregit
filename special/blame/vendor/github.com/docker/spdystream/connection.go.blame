0000000000000000000000000000000000000000;;	package spdystream
ab71d75cf683c780361e644c5f2ee500a1c1e0f8;Godeps/_workspace/src/github.com/docker/spdystream/connection.go[Godeps/_workspace/src/github.com/docker/spdystream/connection.go][vendor/github.com/docker/spdystream/connection.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/spdystream/spdy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrInvalidStreamId   = errors.New("Invalid stream id")
0000000000000000000000000000000000000000;;		ErrTimeout           = errors.New("Timeout occured")
0000000000000000000000000000000000000000;;		ErrReset             = errors.New("Stream reset")
0000000000000000000000000000000000000000;;		ErrWriteClosedStream = errors.New("Write on closed stream")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FRAME_WORKERS = 5
0000000000000000000000000000000000000000;;		QUEUE_SIZE    = 50
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StreamHandler func(stream *Stream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuthHandler func(header http.Header, slot uint8, parent uint32) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type idleAwareFramer struct {
0000000000000000000000000000000000000000;;		f              *spdy.Framer
0000000000000000000000000000000000000000;;		conn           *Connection
0000000000000000000000000000000000000000;;		writeLock      sync.Mutex
0000000000000000000000000000000000000000;;		resetChan      chan struct{}
0000000000000000000000000000000000000000;;		setTimeoutLock sync.Mutex
0000000000000000000000000000000000000000;;		setTimeoutChan chan time.Duration
0000000000000000000000000000000000000000;;		timeout        time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newIdleAwareFramer(framer *spdy.Framer) *idleAwareFramer {
0000000000000000000000000000000000000000;;		iaf := &idleAwareFramer{
0000000000000000000000000000000000000000;;			f:         framer,
0000000000000000000000000000000000000000;;			resetChan: make(chan struct{}, 2),
0000000000000000000000000000000000000000;;			// setTimeoutChan needs to be buffered to avoid deadlocks when calling setIdleTimeout at about
0000000000000000000000000000000000000000;;			// the same time the connection is being closed
0000000000000000000000000000000000000000;;			setTimeoutChan: make(chan time.Duration, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return iaf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *idleAwareFramer) monitor() {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			timer          *time.Timer
0000000000000000000000000000000000000000;;			expired        <-chan time.Time
0000000000000000000000000000000000000000;;			resetChan      = i.resetChan
0000000000000000000000000000000000000000;;			setTimeoutChan = i.setTimeoutChan
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case timeout := <-i.setTimeoutChan:
0000000000000000000000000000000000000000;;				i.timeout = timeout
0000000000000000000000000000000000000000;;				if timeout == 0 {
0000000000000000000000000000000000000000;;					if timer != nil {
0000000000000000000000000000000000000000;;						timer.Stop()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if timer == nil {
0000000000000000000000000000000000000000;;						timer = time.NewTimer(timeout)
0000000000000000000000000000000000000000;;						expired = timer.C
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						timer.Reset(timeout)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-resetChan:
0000000000000000000000000000000000000000;;				if timer != nil && i.timeout > 0 {
0000000000000000000000000000000000000000;;					timer.Reset(i.timeout)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-expired:
0000000000000000000000000000000000000000;;				i.conn.streamCond.L.Lock()
0000000000000000000000000000000000000000;;				streams := i.conn.streams
0000000000000000000000000000000000000000;;				i.conn.streams = make(map[spdy.StreamId]*Stream)
0000000000000000000000000000000000000000;;				i.conn.streamCond.Broadcast()
0000000000000000000000000000000000000000;;				i.conn.streamCond.L.Unlock()
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					for _, stream := range streams {
0000000000000000000000000000000000000000;;						stream.resetStream()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					i.conn.Close()
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			case <-i.conn.closeChan:
0000000000000000000000000000000000000000;;				if timer != nil {
0000000000000000000000000000000000000000;;					timer.Stop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Start a goroutine to drain resetChan. This is needed because we've seen
0000000000000000000000000000000000000000;;				// some unit tests with large numbers of goroutines get into a situation
0000000000000000000000000000000000000000;;				// where resetChan fills up, at least 1 call to Write() is still trying to
0000000000000000000000000000000000000000;;				// send to resetChan, the connection gets closed, and this case statement
0000000000000000000000000000000000000000;;				// attempts to grab the write lock that Write() already has, causing a
0000000000000000000000000000000000000000;;				// deadlock.
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// See https://github.com/docker/spdystream/issues/49 for more details.
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					for _ = range resetChan {
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					for _ = range setTimeoutChan {
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				i.writeLock.Lock()
0000000000000000000000000000000000000000;;				close(resetChan)
0000000000000000000000000000000000000000;;				i.resetChan = nil
0000000000000000000000000000000000000000;;				i.writeLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				i.setTimeoutLock.Lock()
0000000000000000000000000000000000000000;;				close(i.setTimeoutChan)
0000000000000000000000000000000000000000;;				i.setTimeoutChan = nil
0000000000000000000000000000000000000000;;				i.setTimeoutLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Drain resetChan
0000000000000000000000000000000000000000;;		for _ = range resetChan {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *idleAwareFramer) WriteFrame(frame spdy.Frame) error {
0000000000000000000000000000000000000000;;		i.writeLock.Lock()
0000000000000000000000000000000000000000;;		defer i.writeLock.Unlock()
0000000000000000000000000000000000000000;;		if i.resetChan == nil {
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := i.f.WriteFrame(frame)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i.resetChan <- struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *idleAwareFramer) ReadFrame() (spdy.Frame, error) {
0000000000000000000000000000000000000000;;		frame, err := i.f.ReadFrame()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// resetChan should never be closed since it is only closed
0000000000000000000000000000000000000000;;		// when the connection has closed its closeChan. This closure
0000000000000000000000000000000000000000;;		// only occurs after all Reads have finished
0000000000000000000000000000000000000000;;		// TODO (dmcgowan): refactor relationship into connection
0000000000000000000000000000000000000000;;		i.resetChan <- struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return frame, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *idleAwareFramer) setIdleTimeout(timeout time.Duration) {
0000000000000000000000000000000000000000;;		i.setTimeoutLock.Lock()
0000000000000000000000000000000000000000;;		defer i.setTimeoutLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i.setTimeoutChan == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i.setTimeoutChan <- timeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Connection struct {
0000000000000000000000000000000000000000;;		conn   net.Conn
0000000000000000000000000000000000000000;;		framer *idleAwareFramer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closeChan      chan bool
0000000000000000000000000000000000000000;;		goneAway       bool
0000000000000000000000000000000000000000;;		lastStreamChan chan<- *Stream
0000000000000000000000000000000000000000;;		goAwayTimeout  time.Duration
0000000000000000000000000000000000000000;;		closeTimeout   time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamLock *sync.RWMutex
0000000000000000000000000000000000000000;;		streamCond *sync.Cond
0000000000000000000000000000000000000000;;		streams    map[spdy.StreamId]*Stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nextIdLock       sync.Mutex
0000000000000000000000000000000000000000;;		receiveIdLock    sync.Mutex
0000000000000000000000000000000000000000;;		nextStreamId     spdy.StreamId
0000000000000000000000000000000000000000;;		receivedStreamId spdy.StreamId
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pingIdLock sync.Mutex
0000000000000000000000000000000000000000;;		pingId     uint32
0000000000000000000000000000000000000000;;		pingChans  map[uint32]chan error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		shutdownLock sync.Mutex
0000000000000000000000000000000000000000;;		shutdownChan chan error
0000000000000000000000000000000000000000;;		hasShutdown  bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for testing https://github.com/docker/spdystream/pull/56
0000000000000000000000000000000000000000;;		dataFrameHandler func(*spdy.DataFrame) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConnection creates a new spdy connection from an existing
0000000000000000000000000000000000000000;;	// network connection.
0000000000000000000000000000000000000000;;	func NewConnection(conn net.Conn, server bool) (*Connection, error) {
0000000000000000000000000000000000000000;;		framer, framerErr := spdy.NewFramer(conn, conn)
0000000000000000000000000000000000000000;;		if framerErr != nil {
0000000000000000000000000000000000000000;;			return nil, framerErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idleAwareFramer := newIdleAwareFramer(framer)
0000000000000000000000000000000000000000;;		var sid spdy.StreamId
0000000000000000000000000000000000000000;;		var rid spdy.StreamId
0000000000000000000000000000000000000000;;		var pid uint32
0000000000000000000000000000000000000000;;		if server {
0000000000000000000000000000000000000000;;			sid = 2
0000000000000000000000000000000000000000;;			rid = 1
0000000000000000000000000000000000000000;;			pid = 2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sid = 1
0000000000000000000000000000000000000000;;			rid = 2
0000000000000000000000000000000000000000;;			pid = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamLock := new(sync.RWMutex)
0000000000000000000000000000000000000000;;		streamCond := sync.NewCond(streamLock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		session := &Connection{
0000000000000000000000000000000000000000;;			conn:   conn,
0000000000000000000000000000000000000000;;			framer: idleAwareFramer,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			closeChan:     make(chan bool),
0000000000000000000000000000000000000000;;			goAwayTimeout: time.Duration(0),
0000000000000000000000000000000000000000;;			closeTimeout:  time.Duration(0),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			streamLock:       streamLock,
0000000000000000000000000000000000000000;;			streamCond:       streamCond,
0000000000000000000000000000000000000000;;			streams:          make(map[spdy.StreamId]*Stream),
0000000000000000000000000000000000000000;;			nextStreamId:     sid,
0000000000000000000000000000000000000000;;			receivedStreamId: rid,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pingId:    pid,
0000000000000000000000000000000000000000;;			pingChans: make(map[uint32]chan error),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			shutdownChan: make(chan error),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		session.dataFrameHandler = session.handleDataFrame
0000000000000000000000000000000000000000;;		idleAwareFramer.conn = session
0000000000000000000000000000000000000000;;		go idleAwareFramer.monitor()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return session, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ping sends a ping frame across the connection and
0000000000000000000000000000000000000000;;	// returns the response time
0000000000000000000000000000000000000000;;	func (s *Connection) Ping() (time.Duration, error) {
0000000000000000000000000000000000000000;;		pid := s.pingId
0000000000000000000000000000000000000000;;		s.pingIdLock.Lock()
0000000000000000000000000000000000000000;;		if s.pingId > 0x7ffffffe {
0000000000000000000000000000000000000000;;			s.pingId = s.pingId - 0x7ffffffe
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.pingId = s.pingId + 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.pingIdLock.Unlock()
0000000000000000000000000000000000000000;;		pingChan := make(chan error)
0000000000000000000000000000000000000000;;		s.pingChans[pid] = pingChan
0000000000000000000000000000000000000000;;		defer delete(s.pingChans, pid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frame := &spdy.PingFrame{Id: pid}
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		writeErr := s.framer.WriteFrame(frame)
0000000000000000000000000000000000000000;;		if writeErr != nil {
0000000000000000000000000000000000000000;;			return time.Duration(0), writeErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.closeChan:
0000000000000000000000000000000000000000;;			return time.Duration(0), errors.New("connection closed")
0000000000000000000000000000000000000000;;		case err, ok := <-pingChan:
0000000000000000000000000000000000000000;;			if ok && err != nil {
0000000000000000000000000000000000000000;;				return time.Duration(0), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Now().Sub(startTime), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serve handles frames sent from the server, including reply frames
0000000000000000000000000000000000000000;;	// which are needed to fully initiate connections.  Both clients and servers
0000000000000000000000000000000000000000;;	// should call Serve in a separate goroutine before creating streams.
0000000000000000000000000000000000000000;;	func (s *Connection) Serve(newHandler StreamHandler) {
0000000000000000000000000000000000000000;;		// use a WaitGroup to wait for all frames to be drained after receiving
0000000000000000000000000000000000000000;;		// go-away.
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parition queues to ensure stream frames are handled
0000000000000000000000000000000000000000;;		// by the same worker, ensuring order is maintained
0000000000000000000000000000000000000000;;		frameQueues := make([]*PriorityFrameQueue, FRAME_WORKERS)
0000000000000000000000000000000000000000;;		for i := 0; i < FRAME_WORKERS; i++ {
0000000000000000000000000000000000000000;;			frameQueues[i] = NewPriorityFrameQueue(QUEUE_SIZE)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure frame queue is drained when connection is closed
0000000000000000000000000000000000000000;;			go func(frameQueue *PriorityFrameQueue) {
0000000000000000000000000000000000000000;;				<-s.closeChan
0000000000000000000000000000000000000000;;				frameQueue.Drain()
0000000000000000000000000000000000000000;;			}(frameQueues[i])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			go func(frameQueue *PriorityFrameQueue) {
0000000000000000000000000000000000000000;;				// let the WaitGroup know this worker is done
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				s.frameHandler(frameQueue, newHandler)
0000000000000000000000000000000000000000;;			}(frameQueues[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			partitionRoundRobin int
0000000000000000000000000000000000000000;;			goAwayFrame         *spdy.GoAwayFrame
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			readFrame, err := s.framer.ReadFrame()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					fmt.Errorf("frame read error: %s", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					debugMessage("(%p) EOF received", s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var priority uint8
0000000000000000000000000000000000000000;;			var partition int
0000000000000000000000000000000000000000;;			switch frame := readFrame.(type) {
0000000000000000000000000000000000000000;;			case *spdy.SynStreamFrame:
0000000000000000000000000000000000000000;;				if s.checkStreamFrame(frame) {
0000000000000000000000000000000000000000;;					priority = frame.Priority
0000000000000000000000000000000000000000;;					partition = int(frame.StreamId % FRAME_WORKERS)
0000000000000000000000000000000000000000;;					debugMessage("(%p) Add stream frame: %d ", s, frame.StreamId)
0000000000000000000000000000000000000000;;					s.addStreamFrame(frame)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					debugMessage("(%p) Rejected stream frame: %d ", s, frame.StreamId)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *spdy.SynReplyFrame:
0000000000000000000000000000000000000000;;				priority = s.getStreamPriority(frame.StreamId)
0000000000000000000000000000000000000000;;				partition = int(frame.StreamId % FRAME_WORKERS)
0000000000000000000000000000000000000000;;			case *spdy.DataFrame:
0000000000000000000000000000000000000000;;				priority = s.getStreamPriority(frame.StreamId)
0000000000000000000000000000000000000000;;				partition = int(frame.StreamId % FRAME_WORKERS)
0000000000000000000000000000000000000000;;			case *spdy.RstStreamFrame:
0000000000000000000000000000000000000000;;				priority = s.getStreamPriority(frame.StreamId)
0000000000000000000000000000000000000000;;				partition = int(frame.StreamId % FRAME_WORKERS)
0000000000000000000000000000000000000000;;			case *spdy.HeadersFrame:
0000000000000000000000000000000000000000;;				priority = s.getStreamPriority(frame.StreamId)
0000000000000000000000000000000000000000;;				partition = int(frame.StreamId % FRAME_WORKERS)
0000000000000000000000000000000000000000;;			case *spdy.PingFrame:
0000000000000000000000000000000000000000;;				priority = 0
0000000000000000000000000000000000000000;;				partition = partitionRoundRobin
0000000000000000000000000000000000000000;;				partitionRoundRobin = (partitionRoundRobin + 1) % FRAME_WORKERS
0000000000000000000000000000000000000000;;			case *spdy.GoAwayFrame:
0000000000000000000000000000000000000000;;				// hold on to the go away frame and exit the loop
0000000000000000000000000000000000000000;;				goAwayFrame = frame
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				priority = 7
0000000000000000000000000000000000000000;;				partition = partitionRoundRobin
0000000000000000000000000000000000000000;;				partitionRoundRobin = (partitionRoundRobin + 1) % FRAME_WORKERS
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			frameQueues[partition].Push(readFrame, priority)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(s.closeChan)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for all frame handler workers to indicate they've drained their queues
0000000000000000000000000000000000000000;;		// before handling the go away frame
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if goAwayFrame != nil {
0000000000000000000000000000000000000000;;			s.handleGoAwayFrame(goAwayFrame)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now it's safe to close remote channels and empty s.streams
0000000000000000000000000000000000000000;;		s.streamCond.L.Lock()
0000000000000000000000000000000000000000;;		// notify streams that they're now closed, which will
0000000000000000000000000000000000000000;;		// unblock any stream Read() calls
0000000000000000000000000000000000000000;;		for _, stream := range s.streams {
0000000000000000000000000000000000000000;;			stream.closeRemoteChannels()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.streams = make(map[spdy.StreamId]*Stream)
0000000000000000000000000000000000000000;;		s.streamCond.Broadcast()
0000000000000000000000000000000000000000;;		s.streamCond.L.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) frameHandler(frameQueue *PriorityFrameQueue, newHandler StreamHandler) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			popFrame := frameQueue.Pop()
0000000000000000000000000000000000000000;;			if popFrame == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var frameErr error
0000000000000000000000000000000000000000;;			switch frame := popFrame.(type) {
0000000000000000000000000000000000000000;;			case *spdy.SynStreamFrame:
0000000000000000000000000000000000000000;;				frameErr = s.handleStreamFrame(frame, newHandler)
0000000000000000000000000000000000000000;;			case *spdy.SynReplyFrame:
0000000000000000000000000000000000000000;;				frameErr = s.handleReplyFrame(frame)
0000000000000000000000000000000000000000;;			case *spdy.DataFrame:
0000000000000000000000000000000000000000;;				frameErr = s.dataFrameHandler(frame)
0000000000000000000000000000000000000000;;			case *spdy.RstStreamFrame:
0000000000000000000000000000000000000000;;				frameErr = s.handleResetFrame(frame)
0000000000000000000000000000000000000000;;			case *spdy.HeadersFrame:
0000000000000000000000000000000000000000;;				frameErr = s.handleHeaderFrame(frame)
0000000000000000000000000000000000000000;;			case *spdy.PingFrame:
0000000000000000000000000000000000000000;;				frameErr = s.handlePingFrame(frame)
0000000000000000000000000000000000000000;;			case *spdy.GoAwayFrame:
0000000000000000000000000000000000000000;;				frameErr = s.handleGoAwayFrame(frame)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				frameErr = fmt.Errorf("unhandled frame type: %T", frame)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if frameErr != nil {
0000000000000000000000000000000000000000;;				fmt.Errorf("frame handling error: %s", frameErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) getStreamPriority(streamId spdy.StreamId) uint8 {
0000000000000000000000000000000000000000;;		stream, streamOk := s.getStream(streamId)
0000000000000000000000000000000000000000;;		if !streamOk {
0000000000000000000000000000000000000000;;			return 7
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stream.priority
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) addStreamFrame(frame *spdy.SynStreamFrame) {
0000000000000000000000000000000000000000;;		var parent *Stream
0000000000000000000000000000000000000000;;		if frame.AssociatedToStreamId != spdy.StreamId(0) {
0000000000000000000000000000000000000000;;			parent, _ = s.getStream(frame.AssociatedToStreamId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream := &Stream{
0000000000000000000000000000000000000000;;			streamId:   frame.StreamId,
0000000000000000000000000000000000000000;;			parent:     parent,
0000000000000000000000000000000000000000;;			conn:       s,
0000000000000000000000000000000000000000;;			startChan:  make(chan error),
0000000000000000000000000000000000000000;;			headers:    frame.Headers,
0000000000000000000000000000000000000000;;			finished:   (frame.CFHeader.Flags & spdy.ControlFlagUnidirectional) != 0x00,
0000000000000000000000000000000000000000;;			replyCond:  sync.NewCond(new(sync.Mutex)),
0000000000000000000000000000000000000000;;			dataChan:   make(chan []byte),
0000000000000000000000000000000000000000;;			headerChan: make(chan http.Header),
0000000000000000000000000000000000000000;;			closeChan:  make(chan bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.CFHeader.Flags&spdy.ControlFlagFin != 0x00 {
0000000000000000000000000000000000000000;;			stream.closeRemoteChannels()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.addStream(stream)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkStreamFrame checks to see if a stream frame is allowed.
0000000000000000000000000000000000000000;;	// If the stream is invalid, then a reset frame with protocol error
0000000000000000000000000000000000000000;;	// will be returned.
0000000000000000000000000000000000000000;;	func (s *Connection) checkStreamFrame(frame *spdy.SynStreamFrame) bool {
0000000000000000000000000000000000000000;;		s.receiveIdLock.Lock()
0000000000000000000000000000000000000000;;		defer s.receiveIdLock.Unlock()
0000000000000000000000000000000000000000;;		if s.goneAway {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		validationErr := s.validateStreamId(frame.StreamId)
0000000000000000000000000000000000000000;;		if validationErr != nil {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				resetErr := s.sendResetFrame(spdy.ProtocolError, frame.StreamId)
0000000000000000000000000000000000000000;;				if resetErr != nil {
0000000000000000000000000000000000000000;;					fmt.Errorf("reset error: %s", resetErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) handleStreamFrame(frame *spdy.SynStreamFrame, newHandler StreamHandler) error {
0000000000000000000000000000000000000000;;		stream, ok := s.getStream(frame.StreamId)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Missing stream: %d", frame.StreamId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newHandler(stream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) handleReplyFrame(frame *spdy.SynReplyFrame) error {
0000000000000000000000000000000000000000;;		debugMessage("(%p) Reply frame received for %d", s, frame.StreamId)
0000000000000000000000000000000000000000;;		stream, streamOk := s.getStream(frame.StreamId)
0000000000000000000000000000000000000000;;		if !streamOk {
0000000000000000000000000000000000000000;;			debugMessage("Reply frame gone away for %d", frame.StreamId)
0000000000000000000000000000000000000000;;			// Stream has already gone away
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stream.replied {
0000000000000000000000000000000000000000;;			// Stream has already received reply
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stream.replied = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO Check for error
0000000000000000000000000000000000000000;;		if (frame.CFHeader.Flags & spdy.ControlFlagFin) != 0x00 {
0000000000000000000000000000000000000000;;			s.remoteStreamFinish(stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(stream.startChan)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) handleResetFrame(frame *spdy.RstStreamFrame) error {
0000000000000000000000000000000000000000;;		stream, streamOk := s.getStream(frame.StreamId)
0000000000000000000000000000000000000000;;		if !streamOk {
0000000000000000000000000000000000000000;;			// Stream has already been removed
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.removeStream(stream)
0000000000000000000000000000000000000000;;		stream.closeRemoteChannels()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !stream.replied {
0000000000000000000000000000000000000000;;			stream.replied = true
0000000000000000000000000000000000000000;;			stream.startChan <- ErrReset
0000000000000000000000000000000000000000;;			close(stream.startChan)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream.finishLock.Lock()
0000000000000000000000000000000000000000;;		stream.finished = true
0000000000000000000000000000000000000000;;		stream.finishLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) handleHeaderFrame(frame *spdy.HeadersFrame) error {
0000000000000000000000000000000000000000;;		stream, streamOk := s.getStream(frame.StreamId)
0000000000000000000000000000000000000000;;		if !streamOk {
0000000000000000000000000000000000000000;;			// Stream has already gone away
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stream.replied {
0000000000000000000000000000000000000000;;			// No reply received...Protocol error?
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO limit headers while not blocking (use buffered chan or goroutine?)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-stream.closeChan:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case stream.headerChan <- frame.Headers:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (frame.CFHeader.Flags & spdy.ControlFlagFin) != 0x00 {
0000000000000000000000000000000000000000;;			s.remoteStreamFinish(stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) handleDataFrame(frame *spdy.DataFrame) error {
0000000000000000000000000000000000000000;;		debugMessage("(%p) Data frame received for %d", s, frame.StreamId)
0000000000000000000000000000000000000000;;		stream, streamOk := s.getStream(frame.StreamId)
0000000000000000000000000000000000000000;;		if !streamOk {
0000000000000000000000000000000000000000;;			debugMessage("(%p) Data frame gone away for %d", s, frame.StreamId)
0000000000000000000000000000000000000000;;			// Stream has already gone away
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !stream.replied {
0000000000000000000000000000000000000000;;			debugMessage("(%p) Data frame not replied %d", s, frame.StreamId)
0000000000000000000000000000000000000000;;			// No reply received...Protocol error?
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debugMessage("(%p) (%d) Data frame handling", stream, stream.streamId)
0000000000000000000000000000000000000000;;		if len(frame.Data) > 0 {
0000000000000000000000000000000000000000;;			stream.dataLock.RLock()
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stream.closeChan:
0000000000000000000000000000000000000000;;				debugMessage("(%p) (%d) Data frame not sent (stream shut down)", stream, stream.streamId)
0000000000000000000000000000000000000000;;			case stream.dataChan <- frame.Data:
0000000000000000000000000000000000000000;;				debugMessage("(%p) (%d) Data frame sent", stream, stream.streamId)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stream.dataLock.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (frame.Flags & spdy.DataFlagFin) != 0x00 {
0000000000000000000000000000000000000000;;			s.remoteStreamFinish(stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) handlePingFrame(frame *spdy.PingFrame) error {
0000000000000000000000000000000000000000;;		if s.pingId&0x01 != frame.Id&0x01 {
0000000000000000000000000000000000000000;;			return s.framer.WriteFrame(frame)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pingChan, pingOk := s.pingChans[frame.Id]
0000000000000000000000000000000000000000;;		if pingOk {
0000000000000000000000000000000000000000;;			close(pingChan)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) handleGoAwayFrame(frame *spdy.GoAwayFrame) error {
0000000000000000000000000000000000000000;;		debugMessage("(%p) Go away received", s)
0000000000000000000000000000000000000000;;		s.receiveIdLock.Lock()
0000000000000000000000000000000000000000;;		if s.goneAway {
0000000000000000000000000000000000000000;;			s.receiveIdLock.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.goneAway = true
0000000000000000000000000000000000000000;;		s.receiveIdLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.lastStreamChan != nil {
0000000000000000000000000000000000000000;;			stream, _ := s.getStream(frame.LastGoodStreamId)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				s.lastStreamChan <- stream
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do not block frame handler waiting for closure
0000000000000000000000000000000000000000;;		go s.shutdown(s.goAwayTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) remoteStreamFinish(stream *Stream) {
0000000000000000000000000000000000000000;;		stream.closeRemoteChannels()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream.finishLock.Lock()
0000000000000000000000000000000000000000;;		if stream.finished {
0000000000000000000000000000000000000000;;			// Stream is fully closed, cleanup
0000000000000000000000000000000000000000;;			s.removeStream(stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stream.finishLock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateStream creates a new spdy stream using the parameters for
0000000000000000000000000000000000000000;;	// creating the stream frame.  The stream frame will be sent upon
0000000000000000000000000000000000000000;;	// calling this function, however this function does not wait for
0000000000000000000000000000000000000000;;	// the reply frame.  If waiting for the reply is desired, use
0000000000000000000000000000000000000000;;	// the stream Wait or WaitTimeout function on the stream returned
0000000000000000000000000000000000000000;;	// by this function.
0000000000000000000000000000000000000000;;	func (s *Connection) CreateStream(headers http.Header, parent *Stream, fin bool) (*Stream, error) {
0000000000000000000000000000000000000000;;		// MUST synchronize stream creation (all the way to writing the frame)
0000000000000000000000000000000000000000;;		// as stream IDs **MUST** increase monotonically.
0000000000000000000000000000000000000000;;		s.nextIdLock.Lock()
0000000000000000000000000000000000000000;;		defer s.nextIdLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamId := s.getNextStreamId()
0000000000000000000000000000000000000000;;		if streamId == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unable to get new stream id")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream := &Stream{
0000000000000000000000000000000000000000;;			streamId:   streamId,
0000000000000000000000000000000000000000;;			parent:     parent,
0000000000000000000000000000000000000000;;			conn:       s,
0000000000000000000000000000000000000000;;			startChan:  make(chan error),
0000000000000000000000000000000000000000;;			headers:    headers,
0000000000000000000000000000000000000000;;			dataChan:   make(chan []byte),
0000000000000000000000000000000000000000;;			headerChan: make(chan http.Header),
0000000000000000000000000000000000000000;;			closeChan:  make(chan bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debugMessage("(%p) (%p) Create stream", s, stream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.addStream(stream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stream, s.sendStream(stream, fin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) shutdown(closeTimeout time.Duration) {
0000000000000000000000000000000000000000;;		// TODO Ensure this isn't called multiple times
0000000000000000000000000000000000000000;;		s.shutdownLock.Lock()
0000000000000000000000000000000000000000;;		if s.hasShutdown {
0000000000000000000000000000000000000000;;			s.shutdownLock.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hasShutdown = true
0000000000000000000000000000000000000000;;		s.shutdownLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var timeout <-chan time.Time
0000000000000000000000000000000000000000;;		if closeTimeout > time.Duration(0) {
0000000000000000000000000000000000000000;;			timeout = time.After(closeTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		streamsClosed := make(chan bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			s.streamCond.L.Lock()
0000000000000000000000000000000000000000;;			for len(s.streams) > 0 {
0000000000000000000000000000000000000000;;				debugMessage("Streams opened: %d, %#v", len(s.streams), s.streams)
0000000000000000000000000000000000000000;;				s.streamCond.Wait()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.streamCond.L.Unlock()
0000000000000000000000000000000000000000;;			close(streamsClosed)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-streamsClosed:
0000000000000000000000000000000000000000;;			// No active streams, close should be safe
0000000000000000000000000000000000000000;;			err = s.conn.Close()
0000000000000000000000000000000000000000;;		case <-timeout:
0000000000000000000000000000000000000000;;			// Force ungraceful close
0000000000000000000000000000000000000000;;			err = s.conn.Close()
0000000000000000000000000000000000000000;;			// Wait for cleanup to clear active streams
0000000000000000000000000000000000000000;;			<-streamsClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			duration := 10 * time.Minute
0000000000000000000000000000000000000000;;			time.AfterFunc(duration, func() {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case err, ok := <-s.shutdownChan:
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						fmt.Errorf("Unhandled close error after %s: %s", duration, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			s.shutdownChan <- err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(s.shutdownChan)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Closes spdy connection by sending GoAway frame and initiating shutdown
0000000000000000000000000000000000000000;;	func (s *Connection) Close() error {
0000000000000000000000000000000000000000;;		s.receiveIdLock.Lock()
0000000000000000000000000000000000000000;;		if s.goneAway {
0000000000000000000000000000000000000000;;			s.receiveIdLock.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.goneAway = true
0000000000000000000000000000000000000000;;		s.receiveIdLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var lastStreamId spdy.StreamId
0000000000000000000000000000000000000000;;		if s.receivedStreamId > 2 {
0000000000000000000000000000000000000000;;			lastStreamId = s.receivedStreamId - 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		goAwayFrame := &spdy.GoAwayFrame{
0000000000000000000000000000000000000000;;			LastGoodStreamId: lastStreamId,
0000000000000000000000000000000000000000;;			Status:           spdy.GoAwayOK,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := s.framer.WriteFrame(goAwayFrame)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go s.shutdown(s.closeTimeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseWait closes the connection and waits for shutdown
0000000000000000000000000000000000000000;;	// to finish.  Note the underlying network Connection
0000000000000000000000000000000000000000;;	// is not closed until the end of shutdown.
0000000000000000000000000000000000000000;;	func (s *Connection) CloseWait() error {
0000000000000000000000000000000000000000;;		closeErr := s.Close()
0000000000000000000000000000000000000000;;		if closeErr != nil {
0000000000000000000000000000000000000000;;			return closeErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		shutdownErr, ok := <-s.shutdownChan
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return shutdownErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait waits for the connection to finish shutdown or for
0000000000000000000000000000000000000000;;	// the wait timeout duration to expire.  This needs to be
0000000000000000000000000000000000000000;;	// called either after Close has been called or the GOAWAYFRAME
0000000000000000000000000000000000000000;;	// has been received.  If the wait timeout is 0, this function
0000000000000000000000000000000000000000;;	// will block until shutdown finishes.  If wait is never called
0000000000000000000000000000000000000000;;	// and a shutdown error occurs, that error will be logged as an
0000000000000000000000000000000000000000;;	// unhandled error.
0000000000000000000000000000000000000000;;	func (s *Connection) Wait(waitTimeout time.Duration) error {
0000000000000000000000000000000000000000;;		var timeout <-chan time.Time
0000000000000000000000000000000000000000;;		if waitTimeout > time.Duration(0) {
0000000000000000000000000000000000000000;;			timeout = time.After(waitTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err, ok := <-s.shutdownChan:
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-timeout:
0000000000000000000000000000000000000000;;			return ErrTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotifyClose registers a channel to be called when the remote
0000000000000000000000000000000000000000;;	// peer inidicates connection closure.  The last stream to be
0000000000000000000000000000000000000000;;	// received by the remote will be sent on the channel.  The notify
0000000000000000000000000000000000000000;;	// timeout will determine the duration between go away received
0000000000000000000000000000000000000000;;	// and the connection being closed.
0000000000000000000000000000000000000000;;	func (s *Connection) NotifyClose(c chan<- *Stream, timeout time.Duration) {
0000000000000000000000000000000000000000;;		s.goAwayTimeout = timeout
0000000000000000000000000000000000000000;;		s.lastStreamChan = c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetCloseTimeout sets the amount of time close will wait for
0000000000000000000000000000000000000000;;	// streams to finish before terminating the underlying network
0000000000000000000000000000000000000000;;	// connection.  Setting the timeout to 0 will cause close to
0000000000000000000000000000000000000000;;	// wait forever, which is the default.
0000000000000000000000000000000000000000;;	func (s *Connection) SetCloseTimeout(timeout time.Duration) {
0000000000000000000000000000000000000000;;		s.closeTimeout = timeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetIdleTimeout sets the amount of time the connection may sit idle before
0000000000000000000000000000000000000000;;	// it is forcefully terminated.
0000000000000000000000000000000000000000;;	func (s *Connection) SetIdleTimeout(timeout time.Duration) {
0000000000000000000000000000000000000000;;		s.framer.setIdleTimeout(timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) sendHeaders(headers http.Header, stream *Stream, fin bool) error {
0000000000000000000000000000000000000000;;		var flags spdy.ControlFlags
0000000000000000000000000000000000000000;;		if fin {
0000000000000000000000000000000000000000;;			flags = spdy.ControlFlagFin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerFrame := &spdy.HeadersFrame{
0000000000000000000000000000000000000000;;			StreamId: stream.streamId,
0000000000000000000000000000000000000000;;			Headers:  headers,
0000000000000000000000000000000000000000;;			CFHeader: spdy.ControlFrameHeader{Flags: flags},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.framer.WriteFrame(headerFrame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) sendReply(headers http.Header, stream *Stream, fin bool) error {
0000000000000000000000000000000000000000;;		var flags spdy.ControlFlags
0000000000000000000000000000000000000000;;		if fin {
0000000000000000000000000000000000000000;;			flags = spdy.ControlFlagFin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		replyFrame := &spdy.SynReplyFrame{
0000000000000000000000000000000000000000;;			StreamId: stream.streamId,
0000000000000000000000000000000000000000;;			Headers:  headers,
0000000000000000000000000000000000000000;;			CFHeader: spdy.ControlFrameHeader{Flags: flags},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.framer.WriteFrame(replyFrame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) sendResetFrame(status spdy.RstStreamStatus, streamId spdy.StreamId) error {
0000000000000000000000000000000000000000;;		resetFrame := &spdy.RstStreamFrame{
0000000000000000000000000000000000000000;;			StreamId: streamId,
0000000000000000000000000000000000000000;;			Status:   status,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.framer.WriteFrame(resetFrame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) sendReset(status spdy.RstStreamStatus, stream *Stream) error {
0000000000000000000000000000000000000000;;		return s.sendResetFrame(status, stream.streamId)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) sendStream(stream *Stream, fin bool) error {
0000000000000000000000000000000000000000;;		var flags spdy.ControlFlags
0000000000000000000000000000000000000000;;		if fin {
0000000000000000000000000000000000000000;;			flags = spdy.ControlFlagFin
0000000000000000000000000000000000000000;;			stream.finished = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var parentId spdy.StreamId
0000000000000000000000000000000000000000;;		if stream.parent != nil {
0000000000000000000000000000000000000000;;			parentId = stream.parent.streamId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamFrame := &spdy.SynStreamFrame{
0000000000000000000000000000000000000000;;			StreamId:             spdy.StreamId(stream.streamId),
0000000000000000000000000000000000000000;;			AssociatedToStreamId: spdy.StreamId(parentId),
0000000000000000000000000000000000000000;;			Headers:              stream.headers,
0000000000000000000000000000000000000000;;			CFHeader:             spdy.ControlFrameHeader{Flags: flags},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.framer.WriteFrame(streamFrame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNextStreamId returns the next sequential id
0000000000000000000000000000000000000000;;	// every call should produce a unique value or an error
0000000000000000000000000000000000000000;;	func (s *Connection) getNextStreamId() spdy.StreamId {
0000000000000000000000000000000000000000;;		sid := s.nextStreamId
0000000000000000000000000000000000000000;;		if sid > 0x7fffffff {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.nextStreamId = s.nextStreamId + 2
0000000000000000000000000000000000000000;;		return sid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PeekNextStreamId returns the next sequential id and keeps the next id untouched
0000000000000000000000000000000000000000;;	func (s *Connection) PeekNextStreamId() spdy.StreamId {
0000000000000000000000000000000000000000;;		sid := s.nextStreamId
0000000000000000000000000000000000000000;;		return sid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) validateStreamId(rid spdy.StreamId) error {
0000000000000000000000000000000000000000;;		if rid > 0x7fffffff || rid < s.receivedStreamId {
0000000000000000000000000000000000000000;;			return ErrInvalidStreamId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.receivedStreamId = rid + 2
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) addStream(stream *Stream) {
0000000000000000000000000000000000000000;;		s.streamCond.L.Lock()
0000000000000000000000000000000000000000;;		s.streams[stream.streamId] = stream
0000000000000000000000000000000000000000;;		debugMessage("(%p) (%p) Stream added, broadcasting: %d", s, stream, stream.streamId)
0000000000000000000000000000000000000000;;		s.streamCond.Broadcast()
0000000000000000000000000000000000000000;;		s.streamCond.L.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) removeStream(stream *Stream) {
0000000000000000000000000000000000000000;;		s.streamCond.L.Lock()
0000000000000000000000000000000000000000;;		delete(s.streams, stream.streamId)
0000000000000000000000000000000000000000;;		debugMessage("(%p) (%p) Stream removed, broadcasting: %d", s, stream, stream.streamId)
0000000000000000000000000000000000000000;;		s.streamCond.Broadcast()
0000000000000000000000000000000000000000;;		s.streamCond.L.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) getStream(streamId spdy.StreamId) (stream *Stream, ok bool) {
0000000000000000000000000000000000000000;;		s.streamLock.RLock()
0000000000000000000000000000000000000000;;		stream, ok = s.streams[streamId]
0000000000000000000000000000000000000000;;		s.streamLock.RUnlock()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindStream looks up the given stream id and either waits for the
0000000000000000000000000000000000000000;;	// stream to be found or returns nil if the stream id is no longer
0000000000000000000000000000000000000000;;	// valid.
0000000000000000000000000000000000000000;;	func (s *Connection) FindStream(streamId uint32) *Stream {
0000000000000000000000000000000000000000;;		var stream *Stream
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		s.streamCond.L.Lock()
0000000000000000000000000000000000000000;;		stream, ok = s.streams[spdy.StreamId(streamId)]
0000000000000000000000000000000000000000;;		debugMessage("(%p) Found stream %d? %t", s, spdy.StreamId(streamId), ok)
0000000000000000000000000000000000000000;;		for !ok && streamId >= uint32(s.receivedStreamId) {
0000000000000000000000000000000000000000;;			s.streamCond.Wait()
0000000000000000000000000000000000000000;;			stream, ok = s.streams[spdy.StreamId(streamId)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.streamCond.L.Unlock()
0000000000000000000000000000000000000000;;		return stream
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Connection) CloseChan() <-chan bool {
0000000000000000000000000000000000000000;;		return s.closeChan
0000000000000000000000000000000000000000;;	}
