0000000000000000000000000000000000000000;;	package spdystream
ab71d75cf683c780361e644c5f2ee500a1c1e0f8;Godeps/_workspace/src/github.com/docker/spdystream/stream.go[Godeps/_workspace/src/github.com/docker/spdystream/stream.go][vendor/github.com/docker/spdystream/stream.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/spdystream/spdy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrUnreadPartialData = errors.New("unread partial data")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Stream struct {
0000000000000000000000000000000000000000;;		streamId  spdy.StreamId
0000000000000000000000000000000000000000;;		parent    *Stream
0000000000000000000000000000000000000000;;		conn      *Connection
0000000000000000000000000000000000000000;;		startChan chan error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataLock sync.RWMutex
0000000000000000000000000000000000000000;;		dataChan chan []byte
0000000000000000000000000000000000000000;;		unread   []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priority   uint8
0000000000000000000000000000000000000000;;		headers    http.Header
0000000000000000000000000000000000000000;;		headerChan chan http.Header
0000000000000000000000000000000000000000;;		finishLock sync.Mutex
0000000000000000000000000000000000000000;;		finished   bool
0000000000000000000000000000000000000000;;		replyCond  *sync.Cond
0000000000000000000000000000000000000000;;		replied    bool
0000000000000000000000000000000000000000;;		closeLock  sync.Mutex
0000000000000000000000000000000000000000;;		closeChan  chan bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteData writes data to stream, sending a dataframe per call
0000000000000000000000000000000000000000;;	func (s *Stream) WriteData(data []byte, fin bool) error {
0000000000000000000000000000000000000000;;		s.waitWriteReply()
0000000000000000000000000000000000000000;;		var flags spdy.DataFlags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fin {
0000000000000000000000000000000000000000;;			flags = spdy.DataFlagFin
0000000000000000000000000000000000000000;;			s.finishLock.Lock()
0000000000000000000000000000000000000000;;			if s.finished {
0000000000000000000000000000000000000000;;				s.finishLock.Unlock()
0000000000000000000000000000000000000000;;				return ErrWriteClosedStream
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.finished = true
0000000000000000000000000000000000000000;;			s.finishLock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataFrame := &spdy.DataFrame{
0000000000000000000000000000000000000000;;			StreamId: s.streamId,
0000000000000000000000000000000000000000;;			Flags:    flags,
0000000000000000000000000000000000000000;;			Data:     data,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debugMessage("(%p) (%d) Writing data frame", s, s.streamId)
0000000000000000000000000000000000000000;;		return s.conn.framer.WriteFrame(dataFrame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes bytes to a stream, calling write data for each call.
0000000000000000000000000000000000000000;;	func (s *Stream) Write(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		err = s.WriteData(data, false)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			n = len(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads bytes from a stream, a single read will never get more
0000000000000000000000000000000000000000;;	// than what is sent on a single data frame, but a multiple calls to
0000000000000000000000000000000000000000;;	// read may get data from the same data frame.
0000000000000000000000000000000000000000;;	func (s *Stream) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if s.unread == nil {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-s.closeChan:
0000000000000000000000000000000000000000;;				return 0, io.EOF
0000000000000000000000000000000000000000;;			case read, ok := <-s.dataChan:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return 0, io.EOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.unread = read
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n = copy(p, s.unread)
0000000000000000000000000000000000000000;;		if n < len(s.unread) {
0000000000000000000000000000000000000000;;			s.unread = s.unread[n:]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.unread = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadData reads an entire data frame and returns the byte array
0000000000000000000000000000000000000000;;	// from the data frame.  If there is unread data from the result
0000000000000000000000000000000000000000;;	// of a Read call, this function will return an ErrUnreadPartialData.
0000000000000000000000000000000000000000;;	func (s *Stream) ReadData() ([]byte, error) {
0000000000000000000000000000000000000000;;		debugMessage("(%p) Reading data from %d", s, s.streamId)
0000000000000000000000000000000000000000;;		if s.unread != nil {
0000000000000000000000000000000000000000;;			return nil, ErrUnreadPartialData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.closeChan:
0000000000000000000000000000000000000000;;			return nil, io.EOF
0000000000000000000000000000000000000000;;		case read, ok := <-s.dataChan:
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return read, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) waitWriteReply() {
0000000000000000000000000000000000000000;;		if s.replyCond != nil {
0000000000000000000000000000000000000000;;			s.replyCond.L.Lock()
0000000000000000000000000000000000000000;;			for !s.replied {
0000000000000000000000000000000000000000;;				s.replyCond.Wait()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.replyCond.L.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait waits for the stream to receive a reply.
0000000000000000000000000000000000000000;;	func (s *Stream) Wait() error {
0000000000000000000000000000000000000000;;		return s.WaitTimeout(time.Duration(0))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitTimeout waits for the stream to receive a reply or for timeout.
0000000000000000000000000000000000000000;;	// When the timeout is reached, ErrTimeout will be returned.
0000000000000000000000000000000000000000;;	func (s *Stream) WaitTimeout(timeout time.Duration) error {
0000000000000000000000000000000000000000;;		var timeoutChan <-chan time.Time
0000000000000000000000000000000000000000;;		if timeout > time.Duration(0) {
0000000000000000000000000000000000000000;;			timeoutChan = time.After(timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-s.startChan:
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case <-timeoutChan:
0000000000000000000000000000000000000000;;			return ErrTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the stream by sending an empty data frame with the
0000000000000000000000000000000000000000;;	// finish flag set, indicating this side is finished with the stream.
0000000000000000000000000000000000000000;;	func (s *Stream) Close() error {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.closeChan:
0000000000000000000000000000000000000000;;			// Stream is now fully closed
0000000000000000000000000000000000000000;;			s.conn.removeStream(s)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.WriteData([]byte{}, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset sends a reset frame, putting the stream into the fully closed state.
0000000000000000000000000000000000000000;;	func (s *Stream) Reset() error {
0000000000000000000000000000000000000000;;		s.conn.removeStream(s)
0000000000000000000000000000000000000000;;		return s.resetStream()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) resetStream() error {
0000000000000000000000000000000000000000;;		// Always call closeRemoteChannels, even if s.finished is already true.
0000000000000000000000000000000000000000;;		// This makes it so that stream.Close() followed by stream.Reset() allows
0000000000000000000000000000000000000000;;		// stream.Read() to unblock.
0000000000000000000000000000000000000000;;		s.closeRemoteChannels()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.finishLock.Lock()
0000000000000000000000000000000000000000;;		if s.finished {
0000000000000000000000000000000000000000;;			s.finishLock.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.finished = true
0000000000000000000000000000000000000000;;		s.finishLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resetFrame := &spdy.RstStreamFrame{
0000000000000000000000000000000000000000;;			StreamId: s.streamId,
0000000000000000000000000000000000000000;;			Status:   spdy.Cancel,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.conn.framer.WriteFrame(resetFrame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSubStream creates a stream using the current as the parent
0000000000000000000000000000000000000000;;	func (s *Stream) CreateSubStream(headers http.Header, fin bool) (*Stream, error) {
0000000000000000000000000000000000000000;;		return s.conn.CreateStream(headers, s, fin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPriority sets the stream priority, does not affect the
0000000000000000000000000000000000000000;;	// remote priority of this stream after Open has been called.
0000000000000000000000000000000000000000;;	// Valid values are 0 through 7, 0 being the highest priority
0000000000000000000000000000000000000000;;	// and 7 the lowest.
0000000000000000000000000000000000000000;;	func (s *Stream) SetPriority(priority uint8) {
0000000000000000000000000000000000000000;;		s.priority = priority
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendHeader sends a header frame across the stream
0000000000000000000000000000000000000000;;	func (s *Stream) SendHeader(headers http.Header, fin bool) error {
0000000000000000000000000000000000000000;;		return s.conn.sendHeaders(headers, s, fin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendReply sends a reply on a stream, only valid to be called once
0000000000000000000000000000000000000000;;	// when handling a new stream
0000000000000000000000000000000000000000;;	func (s *Stream) SendReply(headers http.Header, fin bool) error {
0000000000000000000000000000000000000000;;		if s.replyCond == nil {
0000000000000000000000000000000000000000;;			return errors.New("cannot reply on initiated stream")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.replyCond.L.Lock()
0000000000000000000000000000000000000000;;		defer s.replyCond.L.Unlock()
0000000000000000000000000000000000000000;;		if s.replied {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := s.conn.sendReply(headers, s, fin)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.replied = true
0000000000000000000000000000000000000000;;		s.replyCond.Broadcast()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Refuse sends a reset frame with the status refuse, only
0000000000000000000000000000000000000000;;	// valid to be called once when handling a new stream.  This
0000000000000000000000000000000000000000;;	// may be used to indicate that a stream is not allowed
0000000000000000000000000000000000000000;;	// when http status codes are not being used.
0000000000000000000000000000000000000000;;	func (s *Stream) Refuse() error {
0000000000000000000000000000000000000000;;		if s.replied {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.replied = true
0000000000000000000000000000000000000000;;		return s.conn.sendReset(spdy.RefusedStream, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cancel sends a reset frame with the status canceled. This
0000000000000000000000000000000000000000;;	// can be used at any time by the creator of the Stream to
0000000000000000000000000000000000000000;;	// indicate the stream is no longer needed.
0000000000000000000000000000000000000000;;	func (s *Stream) Cancel() error {
0000000000000000000000000000000000000000;;		return s.conn.sendReset(spdy.Cancel, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReceiveHeader receives a header sent on the other side
0000000000000000000000000000000000000000;;	// of the stream.  This function will block until a header
0000000000000000000000000000000000000000;;	// is received or stream is closed.
0000000000000000000000000000000000000000;;	func (s *Stream) ReceiveHeader() (http.Header, error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.closeChan:
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case header, ok := <-s.headerChan:
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("header chan closed")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return header, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("stream closed")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parent returns the parent stream
0000000000000000000000000000000000000000;;	func (s *Stream) Parent() *Stream {
0000000000000000000000000000000000000000;;		return s.parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Headers returns the headers used to create the stream
0000000000000000000000000000000000000000;;	func (s *Stream) Headers() http.Header {
0000000000000000000000000000000000000000;;		return s.headers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string version of stream using the
0000000000000000000000000000000000000000;;	// streamId to uniquely identify the stream
0000000000000000000000000000000000000000;;	func (s *Stream) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("stream:%d", s.streamId)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Identifier returns a 32 bit identifier for the stream
0000000000000000000000000000000000000000;;	func (s *Stream) Identifier() uint32 {
0000000000000000000000000000000000000000;;		return uint32(s.streamId)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFinished returns whether the stream has finished
0000000000000000000000000000000000000000;;	// sending data
0000000000000000000000000000000000000000;;	func (s *Stream) IsFinished() bool {
0000000000000000000000000000000000000000;;		return s.finished
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement net.Conn interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) LocalAddr() net.Addr {
0000000000000000000000000000000000000000;;		return s.conn.conn.LocalAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) RemoteAddr() net.Addr {
0000000000000000000000000000000000000000;;		return s.conn.conn.RemoteAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO set per stream values instead of connection-wide
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) SetDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		return s.conn.conn.SetDeadline(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) SetReadDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		return s.conn.conn.SetReadDeadline(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) SetWriteDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		return s.conn.conn.SetWriteDeadline(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) closeRemoteChannels() {
0000000000000000000000000000000000000000;;		s.closeLock.Lock()
0000000000000000000000000000000000000000;;		defer s.closeLock.Unlock()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.closeChan:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			close(s.closeChan)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
