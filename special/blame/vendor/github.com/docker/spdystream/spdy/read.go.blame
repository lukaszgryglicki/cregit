0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1d0fae6481d99ffc5bb4650837b76151bf731a37;Godeps/_workspace/src/github.com/docker/spdystream/spdy/read.go[Godeps/_workspace/src/github.com/docker/spdystream/spdy/read.go][vendor/github.com/docker/spdystream/spdy/read.go];	
0000000000000000000000000000000000000000;;	package spdy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"compress/zlib"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *SynStreamFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		return f.readSynStreamFrame(h, frame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *SynReplyFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		return f.readSynReplyFrame(h, frame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *RstStreamFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &frame.Status); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.Status == 0 {
0000000000000000000000000000000000000000;;			return &Error{InvalidControlFrame, frame.StreamId}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.StreamId == 0 {
0000000000000000000000000000000000000000;;			return &Error{ZeroStreamId, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *SettingsFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		var numSettings uint32
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &numSettings); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frame.FlagIdValues = make([]SettingsFlagIdValue, numSettings)
0000000000000000000000000000000000000000;;		for i := uint32(0); i < numSettings; i++ {
0000000000000000000000000000000000000000;;			if err := binary.Read(f.r, binary.BigEndian, &frame.FlagIdValues[i].Id); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			frame.FlagIdValues[i].Flag = SettingsFlag((frame.FlagIdValues[i].Id & 0xff000000) >> 24)
0000000000000000000000000000000000000000;;			frame.FlagIdValues[i].Id &= 0xffffff
0000000000000000000000000000000000000000;;			if err := binary.Read(f.r, binary.BigEndian, &frame.FlagIdValues[i].Value); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *PingFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &frame.Id); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.Id == 0 {
0000000000000000000000000000000000000000;;			return &Error{ZeroStreamId, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.CFHeader.Flags != 0 {
0000000000000000000000000000000000000000;;			return &Error{InvalidControlFrame, StreamId(frame.Id)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *GoAwayFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &frame.LastGoodStreamId); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.CFHeader.Flags != 0 {
0000000000000000000000000000000000000000;;			return &Error{InvalidControlFrame, frame.LastGoodStreamId}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.CFHeader.length != 8 {
0000000000000000000000000000000000000000;;			return &Error{InvalidControlFrame, frame.LastGoodStreamId}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &frame.Status); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *HeadersFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		return f.readHeadersFrame(h, frame)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *WindowUpdateFrame) read(h ControlFrameHeader, f *Framer) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.CFHeader.Flags != 0 {
0000000000000000000000000000000000000000;;			return &Error{InvalidControlFrame, frame.StreamId}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.CFHeader.length != 8 {
0000000000000000000000000000000000000000;;			return &Error{InvalidControlFrame, frame.StreamId}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &frame.DeltaWindowSize); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newControlFrame(frameType ControlFrameType) (controlFrame, error) {
0000000000000000000000000000000000000000;;		ctor, ok := cframeCtor[frameType]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, &Error{Err: InvalidControlFrame}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ctor(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cframeCtor = map[ControlFrameType]func() controlFrame{
0000000000000000000000000000000000000000;;		TypeSynStream:    func() controlFrame { return new(SynStreamFrame) },
0000000000000000000000000000000000000000;;		TypeSynReply:     func() controlFrame { return new(SynReplyFrame) },
0000000000000000000000000000000000000000;;		TypeRstStream:    func() controlFrame { return new(RstStreamFrame) },
0000000000000000000000000000000000000000;;		TypeSettings:     func() controlFrame { return new(SettingsFrame) },
0000000000000000000000000000000000000000;;		TypePing:         func() controlFrame { return new(PingFrame) },
0000000000000000000000000000000000000000;;		TypeGoAway:       func() controlFrame { return new(GoAwayFrame) },
0000000000000000000000000000000000000000;;		TypeHeaders:      func() controlFrame { return new(HeadersFrame) },
0000000000000000000000000000000000000000;;		TypeWindowUpdate: func() controlFrame { return new(WindowUpdateFrame) },
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) uncorkHeaderDecompressor(payloadSize int64) error {
0000000000000000000000000000000000000000;;		if f.headerDecompressor != nil {
0000000000000000000000000000000000000000;;			f.headerReader.N = payloadSize
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.headerReader = io.LimitedReader{R: f.r, N: payloadSize}
0000000000000000000000000000000000000000;;		decompressor, err := zlib.NewReaderDict(&f.headerReader, []byte(headerDictionary))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.headerDecompressor = decompressor
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadFrame reads SPDY encoded data and returns a decompressed Frame.
0000000000000000000000000000000000000000;;	func (f *Framer) ReadFrame() (Frame, error) {
0000000000000000000000000000000000000000;;		var firstWord uint32
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &firstWord); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if firstWord&0x80000000 != 0 {
0000000000000000000000000000000000000000;;			frameType := ControlFrameType(firstWord & 0xffff)
0000000000000000000000000000000000000000;;			version := uint16(firstWord >> 16 & 0x7fff)
0000000000000000000000000000000000000000;;			return f.parseControlFrame(version, frameType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.parseDataFrame(StreamId(firstWord & 0x7fffffff))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) parseControlFrame(version uint16, frameType ControlFrameType) (Frame, error) {
0000000000000000000000000000000000000000;;		var length uint32
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &length); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flags := ControlFlags((length & 0xff000000) >> 24)
0000000000000000000000000000000000000000;;		length &= 0xffffff
0000000000000000000000000000000000000000;;		header := ControlFrameHeader{version, frameType, flags, length}
0000000000000000000000000000000000000000;;		cframe, err := newControlFrame(frameType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = cframe.read(header, f); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cframe, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseHeaderValueBlock(r io.Reader, streamId StreamId) (http.Header, error) {
0000000000000000000000000000000000000000;;		var numHeaders uint32
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &numHeaders); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var e error
0000000000000000000000000000000000000000;;		h := make(http.Header, int(numHeaders))
0000000000000000000000000000000000000000;;		for i := 0; i < int(numHeaders); i++ {
0000000000000000000000000000000000000000;;			var length uint32
0000000000000000000000000000000000000000;;			if err := binary.Read(r, binary.BigEndian, &length); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nameBytes := make([]byte, length)
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(r, nameBytes); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := string(nameBytes)
0000000000000000000000000000000000000000;;			if name != strings.ToLower(name) {
0000000000000000000000000000000000000000;;				e = &Error{UnlowercasedHeaderName, streamId}
0000000000000000000000000000000000000000;;				name = strings.ToLower(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if h[name] != nil {
0000000000000000000000000000000000000000;;				e = &Error{DuplicateHeaders, streamId}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := binary.Read(r, binary.BigEndian, &length); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value := make([]byte, length)
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(r, value); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			valueList := strings.Split(string(value), headerValueSeparator)
0000000000000000000000000000000000000000;;			for _, v := range valueList {
0000000000000000000000000000000000000000;;				h.Add(name, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return h, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) readSynStreamFrame(h ControlFrameHeader, frame *SynStreamFrame) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = binary.Read(f.r, binary.BigEndian, &frame.AssociatedToStreamId); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = binary.Read(f.r, binary.BigEndian, &frame.Priority); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frame.Priority >>= 5
0000000000000000000000000000000000000000;;		if err = binary.Read(f.r, binary.BigEndian, &frame.Slot); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reader := f.r
0000000000000000000000000000000000000000;;		if !f.headerCompressionDisabled {
0000000000000000000000000000000000000000;;			err := f.uncorkHeaderDecompressor(int64(h.length - 10))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reader = f.headerDecompressor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frame.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)
0000000000000000000000000000000000000000;;		if !f.headerCompressionDisabled && (err == io.EOF && f.headerReader.N == 0 || f.headerReader.N != 0) {
0000000000000000000000000000000000000000;;			err = &Error{WrongCompressedPayloadSize, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for h := range frame.Headers {
0000000000000000000000000000000000000000;;			if invalidReqHeaders[h] {
0000000000000000000000000000000000000000;;				return &Error{InvalidHeaderPresent, frame.StreamId}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.StreamId == 0 {
0000000000000000000000000000000000000000;;			return &Error{ZeroStreamId, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) readSynReplyFrame(h ControlFrameHeader, frame *SynReplyFrame) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reader := f.r
0000000000000000000000000000000000000000;;		if !f.headerCompressionDisabled {
0000000000000000000000000000000000000000;;			err := f.uncorkHeaderDecompressor(int64(h.length - 4))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reader = f.headerDecompressor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frame.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)
0000000000000000000000000000000000000000;;		if !f.headerCompressionDisabled && (err == io.EOF && f.headerReader.N == 0 || f.headerReader.N != 0) {
0000000000000000000000000000000000000000;;			err = &Error{WrongCompressedPayloadSize, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for h := range frame.Headers {
0000000000000000000000000000000000000000;;			if invalidRespHeaders[h] {
0000000000000000000000000000000000000000;;				return &Error{InvalidHeaderPresent, frame.StreamId}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.StreamId == 0 {
0000000000000000000000000000000000000000;;			return &Error{ZeroStreamId, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) readHeadersFrame(h ControlFrameHeader, frame *HeadersFrame) error {
0000000000000000000000000000000000000000;;		frame.CFHeader = h
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if err = binary.Read(f.r, binary.BigEndian, &frame.StreamId); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reader := f.r
0000000000000000000000000000000000000000;;		if !f.headerCompressionDisabled {
0000000000000000000000000000000000000000;;			err := f.uncorkHeaderDecompressor(int64(h.length - 4))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reader = f.headerDecompressor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frame.Headers, err = parseHeaderValueBlock(reader, frame.StreamId)
0000000000000000000000000000000000000000;;		if !f.headerCompressionDisabled && (err == io.EOF && f.headerReader.N == 0 || f.headerReader.N != 0) {
0000000000000000000000000000000000000000;;			err = &Error{WrongCompressedPayloadSize, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var invalidHeaders map[string]bool
0000000000000000000000000000000000000000;;		if frame.StreamId%2 == 0 {
0000000000000000000000000000000000000000;;			invalidHeaders = invalidReqHeaders
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			invalidHeaders = invalidRespHeaders
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for h := range frame.Headers {
0000000000000000000000000000000000000000;;			if invalidHeaders[h] {
0000000000000000000000000000000000000000;;				return &Error{InvalidHeaderPresent, frame.StreamId}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.StreamId == 0 {
0000000000000000000000000000000000000000;;			return &Error{ZeroStreamId, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) parseDataFrame(streamId StreamId) (*DataFrame, error) {
0000000000000000000000000000000000000000;;		var length uint32
0000000000000000000000000000000000000000;;		if err := binary.Read(f.r, binary.BigEndian, &length); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var frame DataFrame
0000000000000000000000000000000000000000;;		frame.StreamId = streamId
0000000000000000000000000000000000000000;;		frame.Flags = DataFlags(length >> 24)
0000000000000000000000000000000000000000;;		length &= 0xffffff
0000000000000000000000000000000000000000;;		frame.Data = make([]byte, length)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(f.r, frame.Data); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.StreamId == 0 {
0000000000000000000000000000000000000000;;			return nil, &Error{ZeroStreamId, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &frame, nil
0000000000000000000000000000000000000000;;	}
