0000000000000000000000000000000000000000;;	// Package reference provides a general type to represent any way of referencing images within the registry.
0000000000000000000000000000000000000000;;	// Its main purpose is to abstract tags and digests (content-addressable hash).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Grammar
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	reference                       := name [ ":" tag ] [ "@" digest ]
0000000000000000000000000000000000000000;;	//	name                            := [hostname '/'] component ['/' component]*
0000000000000000000000000000000000000000;;	//	hostname                        := hostcomponent ['.' hostcomponent]* [':' port-number]
0000000000000000000000000000000000000000;;	//	hostcomponent                   := /([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])/
0000000000000000000000000000000000000000;;	//	port-number                     := /[0-9]+/
0000000000000000000000000000000000000000;;	//	component                       := alpha-numeric [separator alpha-numeric]*
0000000000000000000000000000000000000000;;	// 	alpha-numeric                   := /[a-z0-9]+/
0000000000000000000000000000000000000000;;	//	separator                       := /[_.]|__|[-]*/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	tag                             := /[\w][\w.-]{0,127}/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	digest                          := digest-algorithm ":" digest-hex
0000000000000000000000000000000000000000;;	//	digest-algorithm                := digest-algorithm-component [ digest-algorithm-separator digest-algorithm-component ]
0000000000000000000000000000000000000000;;	//	digest-algorithm-separator      := /[+.-_]/
0000000000000000000000000000000000000000;;	//	digest-algorithm-component      := /[A-Za-z][A-Za-z0-9]*/
0000000000000000000000000000000000000000;;	//	digest-hex                      := /[0-9a-fA-F]{32,}/ ; At least 128 bit digest value
0000000000000000000000000000000000000000;;	package reference
549dca0b4c1af0f858d69469b1e5d8de0e70e1c0;Godeps/_workspace/src/github.com/docker/distribution/reference/reference.go[Godeps/_workspace/src/github.com/docker/distribution/reference/reference.go][vendor/github.com/docker/distribution/reference/reference.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/distribution/digest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NameTotalLengthMax is the maximum total number of characters in a repository name.
0000000000000000000000000000000000000000;;		NameTotalLengthMax = 255
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrReferenceInvalidFormat represents an error while trying to parse a string as a reference.
0000000000000000000000000000000000000000;;		ErrReferenceInvalidFormat = errors.New("invalid reference format")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrTagInvalidFormat represents an error while trying to parse a string as a tag.
0000000000000000000000000000000000000000;;		ErrTagInvalidFormat = errors.New("invalid tag format")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDigestInvalidFormat represents an error while trying to parse a string as a tag.
0000000000000000000000000000000000000000;;		ErrDigestInvalidFormat = errors.New("invalid digest format")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNameEmpty is returned for empty, invalid repository names.
0000000000000000000000000000000000000000;;		ErrNameEmpty = errors.New("repository name must have at least one component")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNameTooLong is returned when a repository name is longer than NameTotalLengthMax.
0000000000000000000000000000000000000000;;		ErrNameTooLong = fmt.Errorf("repository name must not be more than %v characters", NameTotalLengthMax)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reference is an opaque object reference identifier that may include
0000000000000000000000000000000000000000;;	// modifiers such as a hostname, name, tag, and digest.
0000000000000000000000000000000000000000;;	type Reference interface {
0000000000000000000000000000000000000000;;		// String returns the full reference
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Field provides a wrapper type for resolving correct reference types when
0000000000000000000000000000000000000000;;	// working with encoding.
0000000000000000000000000000000000000000;;	type Field struct {
0000000000000000000000000000000000000000;;		reference Reference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsField wraps a reference in a Field for encoding.
0000000000000000000000000000000000000000;;	func AsField(reference Reference) Field {
0000000000000000000000000000000000000000;;		return Field{reference}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reference unwraps the reference type from the field to
0000000000000000000000000000000000000000;;	// return the Reference object. This object should be
0000000000000000000000000000000000000000;;	// of the appropriate type to further check for different
0000000000000000000000000000000000000000;;	// reference types.
0000000000000000000000000000000000000000;;	func (f Field) Reference() Reference {
0000000000000000000000000000000000000000;;		return f.reference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalText serializes the field to byte text which
0000000000000000000000000000000000000000;;	// is the string of the reference.
0000000000000000000000000000000000000000;;	func (f Field) MarshalText() (p []byte, err error) {
0000000000000000000000000000000000000000;;		return []byte(f.reference.String()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText parses text bytes by invoking the
0000000000000000000000000000000000000000;;	// reference parser to ensure the appropriately
0000000000000000000000000000000000000000;;	// typed reference object is wrapped by field.
0000000000000000000000000000000000000000;;	func (f *Field) UnmarshalText(p []byte) error {
0000000000000000000000000000000000000000;;		r, err := Parse(string(p))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.reference = r
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Named is an object with a full name
0000000000000000000000000000000000000000;;	type Named interface {
0000000000000000000000000000000000000000;;		Reference
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tagged is an object which has a tag
0000000000000000000000000000000000000000;;	type Tagged interface {
0000000000000000000000000000000000000000;;		Reference
0000000000000000000000000000000000000000;;		Tag() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamedTagged is an object including a name and tag.
0000000000000000000000000000000000000000;;	type NamedTagged interface {
0000000000000000000000000000000000000000;;		Named
0000000000000000000000000000000000000000;;		Tag() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Digested is an object which has a digest
0000000000000000000000000000000000000000;;	// in which it can be referenced by
0000000000000000000000000000000000000000;;	type Digested interface {
0000000000000000000000000000000000000000;;		Reference
0000000000000000000000000000000000000000;;		Digest() digest.Digest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonical reference is an object with a fully unique
0000000000000000000000000000000000000000;;	// name including a name with hostname and digest
0000000000000000000000000000000000000000;;	type Canonical interface {
0000000000000000000000000000000000000000;;		Named
0000000000000000000000000000000000000000;;		Digest() digest.Digest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitHostname splits a named reference into a
0000000000000000000000000000000000000000;;	// hostname and name string. If no valid hostname is
0000000000000000000000000000000000000000;;	// found, the hostname is empty and the full value
0000000000000000000000000000000000000000;;	// is returned as name
0000000000000000000000000000000000000000;;	func SplitHostname(named Named) (string, string) {
0000000000000000000000000000000000000000;;		name := named.Name()
0000000000000000000000000000000000000000;;		match := anchoredNameRegexp.FindStringSubmatch(name)
0000000000000000000000000000000000000000;;		if match == nil || len(match) != 3 {
0000000000000000000000000000000000000000;;			return "", name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return match[1], match[2]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parses s and returns a syntactically valid Reference.
0000000000000000000000000000000000000000;;	// If an error was encountered it is returned, along with a nil Reference.
0000000000000000000000000000000000000000;;	// NOTE: Parse will not handle short digests.
0000000000000000000000000000000000000000;;	func Parse(s string) (Reference, error) {
0000000000000000000000000000000000000000;;		matches := ReferenceRegexp.FindStringSubmatch(s)
0000000000000000000000000000000000000000;;		if matches == nil {
0000000000000000000000000000000000000000;;			if s == "" {
0000000000000000000000000000000000000000;;				return nil, ErrNameEmpty
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(dmcgowan): Provide more specific and helpful error
0000000000000000000000000000000000000000;;			return nil, ErrReferenceInvalidFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(matches[1]) > NameTotalLengthMax {
0000000000000000000000000000000000000000;;			return nil, ErrNameTooLong
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ref := reference{
0000000000000000000000000000000000000000;;			name: matches[1],
0000000000000000000000000000000000000000;;			tag:  matches[2],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matches[3] != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			ref.digest, err = digest.ParseDigest(matches[3])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := getBestReferenceType(ref)
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return nil, ErrNameEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseNamed parses s and returns a syntactically valid reference implementing
0000000000000000000000000000000000000000;;	// the Named interface. The reference must have a name, otherwise an error is
0000000000000000000000000000000000000000;;	// returned.
0000000000000000000000000000000000000000;;	// If an error was encountered it is returned, along with a nil Reference.
0000000000000000000000000000000000000000;;	// NOTE: ParseNamed will not handle short digests.
0000000000000000000000000000000000000000;;	func ParseNamed(s string) (Named, error) {
0000000000000000000000000000000000000000;;		ref, err := Parse(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		named, isNamed := ref.(Named)
0000000000000000000000000000000000000000;;		if !isNamed {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("reference %s has no name", ref.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return named, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithName returns a named object representing the given string. If the input
0000000000000000000000000000000000000000;;	// is invalid ErrReferenceInvalidFormat will be returned.
0000000000000000000000000000000000000000;;	func WithName(name string) (Named, error) {
0000000000000000000000000000000000000000;;		if len(name) > NameTotalLengthMax {
0000000000000000000000000000000000000000;;			return nil, ErrNameTooLong
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !anchoredNameRegexp.MatchString(name) {
0000000000000000000000000000000000000000;;			return nil, ErrReferenceInvalidFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return repository(name), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithTag combines the name from "name" and the tag from "tag" to form a
0000000000000000000000000000000000000000;;	// reference incorporating both the name and the tag.
0000000000000000000000000000000000000000;;	func WithTag(name Named, tag string) (NamedTagged, error) {
0000000000000000000000000000000000000000;;		if !anchoredTagRegexp.MatchString(tag) {
0000000000000000000000000000000000000000;;			return nil, ErrTagInvalidFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return taggedReference{
0000000000000000000000000000000000000000;;			name: name.Name(),
0000000000000000000000000000000000000000;;			tag:  tag,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDigest combines the name from "name" and the digest from "digest" to form
0000000000000000000000000000000000000000;;	// a reference incorporating both the name and the digest.
0000000000000000000000000000000000000000;;	func WithDigest(name Named, digest digest.Digest) (Canonical, error) {
0000000000000000000000000000000000000000;;		if !anchoredDigestRegexp.MatchString(digest.String()) {
0000000000000000000000000000000000000000;;			return nil, ErrDigestInvalidFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return canonicalReference{
0000000000000000000000000000000000000000;;			name:   name.Name(),
0000000000000000000000000000000000000000;;			digest: digest,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getBestReferenceType(ref reference) Reference {
0000000000000000000000000000000000000000;;		if ref.name == "" {
0000000000000000000000000000000000000000;;			// Allow digest only references
0000000000000000000000000000000000000000;;			if ref.digest != "" {
0000000000000000000000000000000000000000;;				return digestReference(ref.digest)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ref.tag == "" {
0000000000000000000000000000000000000000;;			if ref.digest != "" {
0000000000000000000000000000000000000000;;				return canonicalReference{
0000000000000000000000000000000000000000;;					name:   ref.name,
0000000000000000000000000000000000000000;;					digest: ref.digest,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return repository(ref.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ref.digest == "" {
0000000000000000000000000000000000000000;;			return taggedReference{
0000000000000000000000000000000000000000;;				name: ref.name,
0000000000000000000000000000000000000000;;				tag:  ref.tag,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ref
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reference struct {
0000000000000000000000000000000000000000;;		name   string
0000000000000000000000000000000000000000;;		tag    string
0000000000000000000000000000000000000000;;		digest digest.Digest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r reference) String() string {
0000000000000000000000000000000000000000;;		return r.name + ":" + r.tag + "@" + r.digest.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r reference) Name() string {
0000000000000000000000000000000000000000;;		return r.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r reference) Tag() string {
0000000000000000000000000000000000000000;;		return r.tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r reference) Digest() digest.Digest {
0000000000000000000000000000000000000000;;		return r.digest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type repository string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r repository) String() string {
0000000000000000000000000000000000000000;;		return string(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r repository) Name() string {
0000000000000000000000000000000000000000;;		return string(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type digestReference digest.Digest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d digestReference) String() string {
0000000000000000000000000000000000000000;;		return d.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d digestReference) Digest() digest.Digest {
0000000000000000000000000000000000000000;;		return digest.Digest(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type taggedReference struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		tag  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t taggedReference) String() string {
0000000000000000000000000000000000000000;;		return t.name + ":" + t.tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t taggedReference) Name() string {
0000000000000000000000000000000000000000;;		return t.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t taggedReference) Tag() string {
0000000000000000000000000000000000000000;;		return t.tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type canonicalReference struct {
0000000000000000000000000000000000000000;;		name   string
0000000000000000000000000000000000000000;;		digest digest.Digest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c canonicalReference) String() string {
0000000000000000000000000000000000000000;;		return c.name + "@" + c.digest.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c canonicalReference) Name() string {
0000000000000000000000000000000000000000;;		return c.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c canonicalReference) Digest() digest.Digest {
0000000000000000000000000000000000000000;;		return c.digest
0000000000000000000000000000000000000000;;	}
