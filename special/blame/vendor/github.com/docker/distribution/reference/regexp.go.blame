0000000000000000000000000000000000000000;;	package reference
549dca0b4c1af0f858d69469b1e5d8de0e70e1c0;Godeps/_workspace/src/github.com/docker/distribution/reference/regexp.go[Godeps/_workspace/src/github.com/docker/distribution/reference/regexp.go][vendor/github.com/docker/distribution/reference/regexp.go];	
0000000000000000000000000000000000000000;;	import "regexp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// alphaNumericRegexp defines the alpha numeric atom, typically a
0000000000000000000000000000000000000000;;		// component of names. This only allows lower case characters and digits.
0000000000000000000000000000000000000000;;		alphaNumericRegexp = match(`[a-z0-9]+`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// separatorRegexp defines the separators allowed to be embedded in name
0000000000000000000000000000000000000000;;		// components. This allow one period, one or two underscore and multiple
0000000000000000000000000000000000000000;;		// dashes.
0000000000000000000000000000000000000000;;		separatorRegexp = match(`(?:[._]|__|[-]*)`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nameComponentRegexp restricts registry path component names to start
0000000000000000000000000000000000000000;;		// with at least one letter or number, with following parts able to be
0000000000000000000000000000000000000000;;		// separated by one period, one or two underscore and multiple dashes.
0000000000000000000000000000000000000000;;		nameComponentRegexp = expression(
0000000000000000000000000000000000000000;;			alphaNumericRegexp,
0000000000000000000000000000000000000000;;			optional(repeated(separatorRegexp, alphaNumericRegexp)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// hostnameComponentRegexp restricts the registry hostname component of a
0000000000000000000000000000000000000000;;		// repository name to start with a component as defined by hostnameRegexp
0000000000000000000000000000000000000000;;		// and followed by an optional port.
0000000000000000000000000000000000000000;;		hostnameComponentRegexp = match(`(?:[a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// hostnameRegexp defines the structure of potential hostname components
0000000000000000000000000000000000000000;;		// that may be part of image names. This is purposely a subset of what is
0000000000000000000000000000000000000000;;		// allowed by DNS to ensure backwards compatibility with Docker image
0000000000000000000000000000000000000000;;		// names.
0000000000000000000000000000000000000000;;		hostnameRegexp = expression(
0000000000000000000000000000000000000000;;			hostnameComponentRegexp,
0000000000000000000000000000000000000000;;			optional(repeated(literal(`.`), hostnameComponentRegexp)),
0000000000000000000000000000000000000000;;			optional(literal(`:`), match(`[0-9]+`)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TagRegexp matches valid tag names. From docker/docker:graph/tags.go.
0000000000000000000000000000000000000000;;		TagRegexp = match(`[\w][\w.-]{0,127}`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// anchoredTagRegexp matches valid tag names, anchored at the start and
0000000000000000000000000000000000000000;;		// end of the matched string.
0000000000000000000000000000000000000000;;		anchoredTagRegexp = anchored(TagRegexp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DigestRegexp matches valid digests.
0000000000000000000000000000000000000000;;		DigestRegexp = match(`[A-Za-z][A-Za-z0-9]*(?:[-_+.][A-Za-z][A-Za-z0-9]*)*[:][[:xdigit:]]{32,}`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// anchoredDigestRegexp matches valid digests, anchored at the start and
0000000000000000000000000000000000000000;;		// end of the matched string.
0000000000000000000000000000000000000000;;		anchoredDigestRegexp = anchored(DigestRegexp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NameRegexp is the format for the name component of references. The
0000000000000000000000000000000000000000;;		// regexp has capturing groups for the hostname and name part omitting
0000000000000000000000000000000000000000;;		// the separating forward slash from either.
0000000000000000000000000000000000000000;;		NameRegexp = expression(
0000000000000000000000000000000000000000;;			optional(hostnameRegexp, literal(`/`)),
0000000000000000000000000000000000000000;;			nameComponentRegexp,
0000000000000000000000000000000000000000;;			optional(repeated(literal(`/`), nameComponentRegexp)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// anchoredNameRegexp is used to parse a name value, capturing the
0000000000000000000000000000000000000000;;		// hostname and trailing components.
0000000000000000000000000000000000000000;;		anchoredNameRegexp = anchored(
0000000000000000000000000000000000000000;;			optional(capture(hostnameRegexp), literal(`/`)),
0000000000000000000000000000000000000000;;			capture(nameComponentRegexp,
0000000000000000000000000000000000000000;;				optional(repeated(literal(`/`), nameComponentRegexp))))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReferenceRegexp is the full supported format of a reference. The regexp
0000000000000000000000000000000000000000;;		// is anchored and has capturing groups for name, tag, and digest
0000000000000000000000000000000000000000;;		// components.
0000000000000000000000000000000000000000;;		ReferenceRegexp = anchored(capture(NameRegexp),
0000000000000000000000000000000000000000;;			optional(literal(":"), capture(TagRegexp)),
0000000000000000000000000000000000000000;;			optional(literal("@"), capture(DigestRegexp)))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match compiles the string to a regular expression.
0000000000000000000000000000000000000000;;	var match = regexp.MustCompile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// literal compiles s into a literal regular expression, escaping any regexp
0000000000000000000000000000000000000000;;	// reserved characters.
0000000000000000000000000000000000000000;;	func literal(s string) *regexp.Regexp {
0000000000000000000000000000000000000000;;		re := match(regexp.QuoteMeta(s))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, complete := re.LiteralPrefix(); !complete {
0000000000000000000000000000000000000000;;			panic("must be a literal")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return re
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expression defines a full expression, where each regular expression must
0000000000000000000000000000000000000000;;	// follow the previous.
0000000000000000000000000000000000000000;;	func expression(res ...*regexp.Regexp) *regexp.Regexp {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for _, re := range res {
0000000000000000000000000000000000000000;;			s += re.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return match(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// optional wraps the expression in a non-capturing group and makes the
0000000000000000000000000000000000000000;;	// production optional.
0000000000000000000000000000000000000000;;	func optional(res ...*regexp.Regexp) *regexp.Regexp {
0000000000000000000000000000000000000000;;		return match(group(expression(res...)).String() + `?`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// repeated wraps the regexp in a non-capturing group to get one or more
0000000000000000000000000000000000000000;;	// matches.
0000000000000000000000000000000000000000;;	func repeated(res ...*regexp.Regexp) *regexp.Regexp {
0000000000000000000000000000000000000000;;		return match(group(expression(res...)).String() + `+`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// group wraps the regexp in a non-capturing group.
0000000000000000000000000000000000000000;;	func group(res ...*regexp.Regexp) *regexp.Regexp {
0000000000000000000000000000000000000000;;		return match(`(?:` + expression(res...).String() + `)`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// capture wraps the expression in a capturing group.
0000000000000000000000000000000000000000;;	func capture(res ...*regexp.Regexp) *regexp.Regexp {
0000000000000000000000000000000000000000;;		return match(`(` + expression(res...).String() + `)`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// anchored anchors the regular expression by adding start and end delimiters.
0000000000000000000000000000000000000000;;	func anchored(res ...*regexp.Regexp) *regexp.Regexp {
0000000000000000000000000000000000000000;;		return match(`^` + expression(res...).String() + `$`)
0000000000000000000000000000000000000000;;	}
