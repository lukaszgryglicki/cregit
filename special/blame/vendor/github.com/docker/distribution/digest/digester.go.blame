0000000000000000000000000000000000000000;;	package digest
549dca0b4c1af0f858d69469b1e5d8de0e70e1c0;Godeps/_workspace/src/github.com/docker/distribution/digest/digester.go[Godeps/_workspace/src/github.com/docker/distribution/digest/digester.go][vendor/github.com/docker/distribution/digest/digester.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Algorithm identifies and implementation of a digester by an identifier.
0000000000000000000000000000000000000000;;	// Note the that this defines both the hash algorithm used and the string
0000000000000000000000000000000000000000;;	// encoding.
0000000000000000000000000000000000000000;;	type Algorithm string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supported digest types
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SHA256 Algorithm = "sha256" // sha256 with hex encoding
0000000000000000000000000000000000000000;;		SHA384 Algorithm = "sha384" // sha384 with hex encoding
0000000000000000000000000000000000000000;;		SHA512 Algorithm = "sha512" // sha512 with hex encoding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Canonical is the primary digest algorithm used with the distribution
0000000000000000000000000000000000000000;;		// project. Other digests may be used but this one is the primary storage
0000000000000000000000000000000000000000;;		// digest.
0000000000000000000000000000000000000000;;		Canonical = SHA256
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// TODO(stevvooe): Follow the pattern of the standard crypto package for
0000000000000000000000000000000000000000;;		// registration of digests. Effectively, we are a registerable set and
0000000000000000000000000000000000000000;;		// common symbol access.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// algorithms maps values to hash.Hash implementations. Other algorithms
0000000000000000000000000000000000000000;;		// may be available but they cannot be calculated by the digest package.
0000000000000000000000000000000000000000;;		algorithms = map[Algorithm]crypto.Hash{
0000000000000000000000000000000000000000;;			SHA256: crypto.SHA256,
0000000000000000000000000000000000000000;;			SHA384: crypto.SHA384,
0000000000000000000000000000000000000000;;			SHA512: crypto.SHA512,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Available returns true if the digest type is available for use. If this
0000000000000000000000000000000000000000;;	// returns false, New and Hash will return nil.
0000000000000000000000000000000000000000;;	func (a Algorithm) Available() bool {
0000000000000000000000000000000000000000;;		h, ok := algorithms[a]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check availability of the hash, as well
0000000000000000000000000000000000000000;;		return h.Available()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Algorithm) String() string {
0000000000000000000000000000000000000000;;		return string(a)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns number of bytes returned by the hash.
0000000000000000000000000000000000000000;;	func (a Algorithm) Size() int {
0000000000000000000000000000000000000000;;		h, ok := algorithms[a]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h.Size()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set implemented to allow use of Algorithm as a command line flag.
0000000000000000000000000000000000000000;;	func (a *Algorithm) Set(value string) error {
0000000000000000000000000000000000000000;;		if value == "" {
0000000000000000000000000000000000000000;;			*a = Canonical
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// just do a type conversion, support is queried with Available.
0000000000000000000000000000000000000000;;			*a = Algorithm(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new digester for the specified algorithm. If the algorithm
0000000000000000000000000000000000000000;;	// does not have a digester implementation, nil will be returned. This can be
0000000000000000000000000000000000000000;;	// checked by calling Available before calling New.
0000000000000000000000000000000000000000;;	func (a Algorithm) New() Digester {
0000000000000000000000000000000000000000;;		return &digester{
0000000000000000000000000000000000000000;;			alg:  a,
0000000000000000000000000000000000000000;;			hash: a.Hash(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hash returns a new hash as used by the algorithm. If not available, the
0000000000000000000000000000000000000000;;	// method will panic. Check Algorithm.Available() before calling.
0000000000000000000000000000000000000000;;	func (a Algorithm) Hash() hash.Hash {
0000000000000000000000000000000000000000;;		if !a.Available() {
0000000000000000000000000000000000000000;;			// NOTE(stevvooe): A missing hash is usually a programming error that
0000000000000000000000000000000000000000;;			// must be resolved at compile time. We don't import in the digest
0000000000000000000000000000000000000000;;			// package to allow users to choose their hash implementation (such as
0000000000000000000000000000000000000000;;			// when using stevvooe/resumable or a hardware accelerated package).
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Applications that may want to resolve the hash at runtime should
0000000000000000000000000000000000000000;;			// call Algorithm.Available before call Algorithm.Hash().
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("%v not available (make sure it is imported)", a))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return algorithms[a].New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromReader returns the digest of the reader using the algorithm.
0000000000000000000000000000000000000000;;	func (a Algorithm) FromReader(rd io.Reader) (Digest, error) {
0000000000000000000000000000000000000000;;		digester := a.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := io.Copy(digester.Hash(), rd); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return digester.Digest(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromBytes digests the input and returns a Digest.
0000000000000000000000000000000000000000;;	func (a Algorithm) FromBytes(p []byte) Digest {
0000000000000000000000000000000000000000;;		digester := a.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := digester.Hash().Write(p); err != nil {
0000000000000000000000000000000000000000;;			// Writes to a Hash should never fail. None of the existing
0000000000000000000000000000000000000000;;			// hash implementations in the stdlib or hashes vendored
0000000000000000000000000000000000000000;;			// here can return errors from Write. Having a panic in this
0000000000000000000000000000000000000000;;			// condition instead of having FromBytes return an error value
0000000000000000000000000000000000000000;;			// avoids unnecessary error handling paths in all callers.
0000000000000000000000000000000000000000;;			panic("write to hash function returned error: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return digester.Digest()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(stevvooe): Allow resolution of verifiers using the digest type and
0000000000000000000000000000000000000000;;	// this registration system.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Digester calculates the digest of written data. Writes should go directly
0000000000000000000000000000000000000000;;	// to the return value of Hash, while calling Digest will return the current
0000000000000000000000000000000000000000;;	// value of the digest.
0000000000000000000000000000000000000000;;	type Digester interface {
0000000000000000000000000000000000000000;;		Hash() hash.Hash // provides direct access to underlying hash instance.
0000000000000000000000000000000000000000;;		Digest() Digest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// digester provides a simple digester definition that embeds a hasher.
0000000000000000000000000000000000000000;;	type digester struct {
0000000000000000000000000000000000000000;;		alg  Algorithm
0000000000000000000000000000000000000000;;		hash hash.Hash
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *digester) Hash() hash.Hash {
0000000000000000000000000000000000000000;;		return d.hash
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *digester) Digest() Digest {
0000000000000000000000000000000000000000;;		return NewDigest(d.alg, d.hash)
0000000000000000000000000000000000000000;;	}
