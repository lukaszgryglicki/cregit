0000000000000000000000000000000000000000;;	package digest
549dca0b4c1af0f858d69469b1e5d8de0e70e1c0;Godeps/_workspace/src/github.com/docker/distribution/digest/digest.go[Godeps/_workspace/src/github.com/docker/distribution/digest/digest.go][vendor/github.com/docker/distribution/digest/digest.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DigestSha256EmptyTar is the canonical sha256 digest of empty data
0000000000000000000000000000000000000000;;		DigestSha256EmptyTar = "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Digest allows simple protection of hex formatted digest strings, prefixed
0000000000000000000000000000000000000000;;	// by their algorithm. Strings of type Digest have some guarantee of being in
0000000000000000000000000000000000000000;;	// the correct format and it provides quick access to the components of a
0000000000000000000000000000000000000000;;	// digest string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following is an example of the contents of Digest types:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	sha256:7173b809ca12ec5dee4506cd86be934c4596dd234ee82c0662eac04a8c2c71dc
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This allows to abstract the digest behind this type and work only in those
0000000000000000000000000000000000000000;;	// terms.
0000000000000000000000000000000000000000;;	type Digest string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDigest returns a Digest from alg and a hash.Hash object.
0000000000000000000000000000000000000000;;	func NewDigest(alg Algorithm, h hash.Hash) Digest {
0000000000000000000000000000000000000000;;		return NewDigestFromBytes(alg, h.Sum(nil))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDigestFromBytes returns a new digest from the byte contents of p.
0000000000000000000000000000000000000000;;	// Typically, this can come from hash.Hash.Sum(...) or xxx.SumXXX(...)
0000000000000000000000000000000000000000;;	// functions. This is also useful for rebuilding digests from binary
0000000000000000000000000000000000000000;;	// serializations.
0000000000000000000000000000000000000000;;	func NewDigestFromBytes(alg Algorithm, p []byte) Digest {
0000000000000000000000000000000000000000;;		return Digest(fmt.Sprintf("%s:%x", alg, p))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDigestFromHex returns a Digest from alg and a the hex encoded digest.
0000000000000000000000000000000000000000;;	func NewDigestFromHex(alg, hex string) Digest {
0000000000000000000000000000000000000000;;		return Digest(fmt.Sprintf("%s:%s", alg, hex))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DigestRegexp matches valid digest types.
0000000000000000000000000000000000000000;;	var DigestRegexp = regexp.MustCompile(`[a-zA-Z0-9-_+.]+:[a-fA-F0-9]+`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DigestRegexpAnchored matches valid digest types, anchored to the start and end of the match.
0000000000000000000000000000000000000000;;	var DigestRegexpAnchored = regexp.MustCompile(`^` + DigestRegexp.String() + `$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrDigestInvalidFormat returned when digest format invalid.
0000000000000000000000000000000000000000;;		ErrDigestInvalidFormat = fmt.Errorf("invalid checksum digest format")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDigestInvalidLength returned when digest has invalid length.
0000000000000000000000000000000000000000;;		ErrDigestInvalidLength = fmt.Errorf("invalid checksum digest length")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDigestUnsupported returned when the digest algorithm is unsupported.
0000000000000000000000000000000000000000;;		ErrDigestUnsupported = fmt.Errorf("unsupported digest algorithm")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDigest parses s and returns the validated digest object. An error will
0000000000000000000000000000000000000000;;	// be returned if the format is invalid.
0000000000000000000000000000000000000000;;	func ParseDigest(s string) (Digest, error) {
0000000000000000000000000000000000000000;;		d := Digest(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return d, d.Validate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromReader returns the most valid digest for the underlying content using
0000000000000000000000000000000000000000;;	// the canonical digest algorithm.
0000000000000000000000000000000000000000;;	func FromReader(rd io.Reader) (Digest, error) {
0000000000000000000000000000000000000000;;		return Canonical.FromReader(rd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromBytes digests the input and returns a Digest.
0000000000000000000000000000000000000000;;	func FromBytes(p []byte) Digest {
0000000000000000000000000000000000000000;;		return Canonical.FromBytes(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks that the contents of d is a valid digest, returning an
0000000000000000000000000000000000000000;;	// error if not.
0000000000000000000000000000000000000000;;	func (d Digest) Validate() error {
0000000000000000000000000000000000000000;;		s := string(d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !DigestRegexpAnchored.MatchString(s) {
0000000000000000000000000000000000000000;;			return ErrDigestInvalidFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := strings.Index(s, ":")
0000000000000000000000000000000000000000;;		if i < 0 {
0000000000000000000000000000000000000000;;			return ErrDigestInvalidFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// case: "sha256:" with no hex.
0000000000000000000000000000000000000000;;		if i+1 == len(s) {
0000000000000000000000000000000000000000;;			return ErrDigestInvalidFormat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch algorithm := Algorithm(s[:i]); algorithm {
0000000000000000000000000000000000000000;;		case SHA256, SHA384, SHA512:
0000000000000000000000000000000000000000;;			if algorithm.Size()*2 != len(s[i+1:]) {
0000000000000000000000000000000000000000;;				return ErrDigestInvalidLength
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrDigestUnsupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Algorithm returns the algorithm portion of the digest. This will panic if
0000000000000000000000000000000000000000;;	// the underlying digest is not in a valid format.
0000000000000000000000000000000000000000;;	func (d Digest) Algorithm() Algorithm {
0000000000000000000000000000000000000000;;		return Algorithm(d[:d.sepIndex()])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hex returns the hex digest portion of the digest. This will panic if the
0000000000000000000000000000000000000000;;	// underlying digest is not in a valid format.
0000000000000000000000000000000000000000;;	func (d Digest) Hex() string {
0000000000000000000000000000000000000000;;		return string(d[d.sepIndex()+1:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Digest) String() string {
0000000000000000000000000000000000000000;;		return string(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Digest) sepIndex() int {
0000000000000000000000000000000000000000;;		i := strings.Index(string(d), ":")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i < 0 {
0000000000000000000000000000000000000000;;			panic("could not find ':' in digest: " + d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
