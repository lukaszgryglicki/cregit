0000000000000000000000000000000000000000;;	package digest
549dca0b4c1af0f858d69469b1e5d8de0e70e1c0;Godeps/_workspace/src/github.com/docker/distribution/digest/set.go[Godeps/_workspace/src/github.com/docker/distribution/digest/set.go][vendor/github.com/docker/distribution/digest/set.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrDigestNotFound is used when a matching digest
0000000000000000000000000000000000000000;;		// could not be found in a set.
0000000000000000000000000000000000000000;;		ErrDigestNotFound = errors.New("digest not found")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrDigestAmbiguous is used when multiple digests
0000000000000000000000000000000000000000;;		// are found in a set. None of the matching digests
0000000000000000000000000000000000000000;;		// should be considered valid matches.
0000000000000000000000000000000000000000;;		ErrDigestAmbiguous = errors.New("ambiguous digest string")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set is used to hold a unique set of digests which
0000000000000000000000000000000000000000;;	// may be easily referenced by easily  referenced by a string
0000000000000000000000000000000000000000;;	// representation of the digest as well as short representation.
0000000000000000000000000000000000000000;;	// The uniqueness of the short representation is based on other
0000000000000000000000000000000000000000;;	// digests in the set. If digests are omitted from this set,
0000000000000000000000000000000000000000;;	// collisions in a larger set may not be detected, therefore it
0000000000000000000000000000000000000000;;	// is important to always do short representation lookups on
0000000000000000000000000000000000000000;;	// the complete set of digests. To mitigate collisions, an
0000000000000000000000000000000000000000;;	// appropriately long short code should be used.
0000000000000000000000000000000000000000;;	type Set struct {
0000000000000000000000000000000000000000;;		mutex   sync.RWMutex
0000000000000000000000000000000000000000;;		entries digestEntries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSet creates an empty set of digests
0000000000000000000000000000000000000000;;	// which may have digests added.
0000000000000000000000000000000000000000;;	func NewSet() *Set {
0000000000000000000000000000000000000000;;		return &Set{
0000000000000000000000000000000000000000;;			entries: digestEntries{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkShortMatch checks whether two digests match as either whole
0000000000000000000000000000000000000000;;	// values or short values. This function does not test equality,
0000000000000000000000000000000000000000;;	// rather whether the second value could match against the first
0000000000000000000000000000000000000000;;	// value.
0000000000000000000000000000000000000000;;	func checkShortMatch(alg Algorithm, hex, shortAlg, shortHex string) bool {
0000000000000000000000000000000000000000;;		if len(hex) == len(shortHex) {
0000000000000000000000000000000000000000;;			if hex != shortHex {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(shortAlg) > 0 && string(alg) != shortAlg {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if !strings.HasPrefix(hex, shortHex) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		} else if len(shortAlg) > 0 && string(alg) != shortAlg {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup looks for a digest matching the given string representation.
0000000000000000000000000000000000000000;;	// If no digests could be found ErrDigestNotFound will be returned
0000000000000000000000000000000000000000;;	// with an empty digest value. If multiple matches are found
0000000000000000000000000000000000000000;;	// ErrDigestAmbiguous will be returned with an empty digest value.
0000000000000000000000000000000000000000;;	func (dst *Set) Lookup(d string) (Digest, error) {
0000000000000000000000000000000000000000;;		dst.mutex.RLock()
0000000000000000000000000000000000000000;;		defer dst.mutex.RUnlock()
0000000000000000000000000000000000000000;;		if len(dst.entries) == 0 {
0000000000000000000000000000000000000000;;			return "", ErrDigestNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			searchFunc func(int) bool
0000000000000000000000000000000000000000;;			alg        Algorithm
0000000000000000000000000000000000000000;;			hex        string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		dgst, err := ParseDigest(d)
0000000000000000000000000000000000000000;;		if err == ErrDigestInvalidFormat {
0000000000000000000000000000000000000000;;			hex = d
0000000000000000000000000000000000000000;;			searchFunc = func(i int) bool {
0000000000000000000000000000000000000000;;				return dst.entries[i].val >= d
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			hex = dgst.Hex()
0000000000000000000000000000000000000000;;			alg = dgst.Algorithm()
0000000000000000000000000000000000000000;;			searchFunc = func(i int) bool {
0000000000000000000000000000000000000000;;				if dst.entries[i].val == hex {
0000000000000000000000000000000000000000;;					return dst.entries[i].alg >= alg
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return dst.entries[i].val >= hex
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idx := sort.Search(len(dst.entries), searchFunc)
0000000000000000000000000000000000000000;;		if idx == len(dst.entries) || !checkShortMatch(dst.entries[idx].alg, dst.entries[idx].val, string(alg), hex) {
0000000000000000000000000000000000000000;;			return "", ErrDigestNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.entries[idx].alg == alg && dst.entries[idx].val == hex {
0000000000000000000000000000000000000000;;			return dst.entries[idx].digest, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if idx+1 < len(dst.entries) && checkShortMatch(dst.entries[idx+1].alg, dst.entries[idx+1].val, string(alg), hex) {
0000000000000000000000000000000000000000;;			return "", ErrDigestAmbiguous
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dst.entries[idx].digest, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds the given digest to the set. An error will be returned
0000000000000000000000000000000000000000;;	// if the given digest is invalid. If the digest already exists in the
0000000000000000000000000000000000000000;;	// set, this operation will be a no-op.
0000000000000000000000000000000000000000;;	func (dst *Set) Add(d Digest) error {
0000000000000000000000000000000000000000;;		if err := d.Validate(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dst.mutex.Lock()
0000000000000000000000000000000000000000;;		defer dst.mutex.Unlock()
0000000000000000000000000000000000000000;;		entry := &digestEntry{alg: d.Algorithm(), val: d.Hex(), digest: d}
0000000000000000000000000000000000000000;;		searchFunc := func(i int) bool {
0000000000000000000000000000000000000000;;			if dst.entries[i].val == entry.val {
0000000000000000000000000000000000000000;;				return dst.entries[i].alg >= entry.alg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dst.entries[i].val >= entry.val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idx := sort.Search(len(dst.entries), searchFunc)
0000000000000000000000000000000000000000;;		if idx == len(dst.entries) {
0000000000000000000000000000000000000000;;			dst.entries = append(dst.entries, entry)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if dst.entries[idx].digest == d {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entries := append(dst.entries, nil)
0000000000000000000000000000000000000000;;		copy(entries[idx+1:], entries[idx:len(entries)-1])
0000000000000000000000000000000000000000;;		entries[idx] = entry
0000000000000000000000000000000000000000;;		dst.entries = entries
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the given digest from the set. An err will be
0000000000000000000000000000000000000000;;	// returned if the given digest is invalid. If the digest does
0000000000000000000000000000000000000000;;	// not exist in the set, this operation will be a no-op.
0000000000000000000000000000000000000000;;	func (dst *Set) Remove(d Digest) error {
0000000000000000000000000000000000000000;;		if err := d.Validate(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dst.mutex.Lock()
0000000000000000000000000000000000000000;;		defer dst.mutex.Unlock()
0000000000000000000000000000000000000000;;		entry := &digestEntry{alg: d.Algorithm(), val: d.Hex(), digest: d}
0000000000000000000000000000000000000000;;		searchFunc := func(i int) bool {
0000000000000000000000000000000000000000;;			if dst.entries[i].val == entry.val {
0000000000000000000000000000000000000000;;				return dst.entries[i].alg >= entry.alg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dst.entries[i].val >= entry.val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idx := sort.Search(len(dst.entries), searchFunc)
0000000000000000000000000000000000000000;;		// Not found if idx is after or value at idx is not digest
0000000000000000000000000000000000000000;;		if idx == len(dst.entries) || dst.entries[idx].digest != d {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entries := dst.entries
0000000000000000000000000000000000000000;;		copy(entries[idx:], entries[idx+1:])
0000000000000000000000000000000000000000;;		entries = entries[:len(entries)-1]
0000000000000000000000000000000000000000;;		dst.entries = entries
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All returns all the digests in the set
0000000000000000000000000000000000000000;;	func (dst *Set) All() []Digest {
0000000000000000000000000000000000000000;;		dst.mutex.RLock()
0000000000000000000000000000000000000000;;		defer dst.mutex.RUnlock()
0000000000000000000000000000000000000000;;		retValues := make([]Digest, len(dst.entries))
0000000000000000000000000000000000000000;;		for i := range dst.entries {
0000000000000000000000000000000000000000;;			retValues[i] = dst.entries[i].digest
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return retValues
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShortCodeTable returns a map of Digest to unique short codes. The
0000000000000000000000000000000000000000;;	// length represents the minimum value, the maximum length may be the
0000000000000000000000000000000000000000;;	// entire value of digest if uniqueness cannot be achieved without the
0000000000000000000000000000000000000000;;	// full value. This function will attempt to make short codes as short
0000000000000000000000000000000000000000;;	// as possible to be unique.
0000000000000000000000000000000000000000;;	func ShortCodeTable(dst *Set, length int) map[Digest]string {
0000000000000000000000000000000000000000;;		dst.mutex.RLock()
0000000000000000000000000000000000000000;;		defer dst.mutex.RUnlock()
0000000000000000000000000000000000000000;;		m := make(map[Digest]string, len(dst.entries))
0000000000000000000000000000000000000000;;		l := length
0000000000000000000000000000000000000000;;		resetIdx := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(dst.entries); i++ {
0000000000000000000000000000000000000000;;			var short string
0000000000000000000000000000000000000000;;			extended := true
0000000000000000000000000000000000000000;;			for extended {
0000000000000000000000000000000000000000;;				extended = false
0000000000000000000000000000000000000000;;				if len(dst.entries[i].val) <= l {
0000000000000000000000000000000000000000;;					short = dst.entries[i].digest.String()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					short = dst.entries[i].val[:l]
0000000000000000000000000000000000000000;;					for j := i + 1; j < len(dst.entries); j++ {
0000000000000000000000000000000000000000;;						if checkShortMatch(dst.entries[j].alg, dst.entries[j].val, "", short) {
0000000000000000000000000000000000000000;;							if j > resetIdx {
0000000000000000000000000000000000000000;;								resetIdx = j
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							extended = true
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if extended {
0000000000000000000000000000000000000000;;						l++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m[dst.entries[i].digest] = short
0000000000000000000000000000000000000000;;			if i >= resetIdx {
0000000000000000000000000000000000000000;;				l = length
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type digestEntry struct {
0000000000000000000000000000000000000000;;		alg    Algorithm
0000000000000000000000000000000000000000;;		val    string
0000000000000000000000000000000000000000;;		digest Digest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type digestEntries []*digestEntry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d digestEntries) Len() int {
0000000000000000000000000000000000000000;;		return len(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d digestEntries) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if d[i].val != d[j].val {
0000000000000000000000000000000000000000;;			return d[i].val < d[j].val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d[i].alg < d[j].alg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d digestEntries) Swap(i, j int) {
0000000000000000000000000000000000000000;;		d[i], d[j] = d[j], d[i]
0000000000000000000000000000000000000000;;	}
