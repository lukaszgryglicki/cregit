0000000000000000000000000000000000000000;;	package nat
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/go-connections/nat/sort.go[Godeps/_workspace/src/github.com/docker/go-connections/nat/sort.go][vendor/github.com/docker/go-connections/nat/sort.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portSorter struct {
0000000000000000000000000000000000000000;;		ports []Port
0000000000000000000000000000000000000000;;		by    func(i, j Port) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *portSorter) Len() int {
0000000000000000000000000000000000000000;;		return len(s.ports)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *portSorter) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s.ports[i], s.ports[j] = s.ports[j], s.ports[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *portSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		ip := s.ports[i]
0000000000000000000000000000000000000000;;		jp := s.ports[j]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.by(ip, jp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sort sorts a list of ports using the provided predicate
0000000000000000000000000000000000000000;;	// This function should compare `i` and `j`, returning true if `i` is
0000000000000000000000000000000000000000;;	// considered to be less than `j`
0000000000000000000000000000000000000000;;	func Sort(ports []Port, predicate func(i, j Port) bool) {
0000000000000000000000000000000000000000;;		s := &portSorter{ports, predicate}
0000000000000000000000000000000000000000;;		sort.Sort(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portMapEntry struct {
0000000000000000000000000000000000000000;;		port    Port
0000000000000000000000000000000000000000;;		binding PortBinding
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type portMapSorter []portMapEntry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s portMapSorter) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s portMapSorter) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sort the port so that the order is:
0000000000000000000000000000000000000000;;	// 1. port with larger specified bindings
0000000000000000000000000000000000000000;;	// 2. larger port
0000000000000000000000000000000000000000;;	// 3. port with tcp protocol
0000000000000000000000000000000000000000;;	func (s portMapSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		pi, pj := s[i].port, s[j].port
0000000000000000000000000000000000000000;;		hpi, hpj := toInt(s[i].binding.HostPort), toInt(s[j].binding.HostPort)
0000000000000000000000000000000000000000;;		return hpi > hpj || pi.Int() > pj.Int() || (pi.Int() == pj.Int() && strings.ToLower(pi.Proto()) == "tcp")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SortPortMap sorts the list of ports and their respected mapping. The ports
0000000000000000000000000000000000000000;;	// will explicit HostPort will be placed first.
0000000000000000000000000000000000000000;;	func SortPortMap(ports []Port, bindings PortMap) {
0000000000000000000000000000000000000000;;		s := portMapSorter{}
0000000000000000000000000000000000000000;;		for _, p := range ports {
0000000000000000000000000000000000000000;;			if binding, ok := bindings[p]; ok {
0000000000000000000000000000000000000000;;				for _, b := range binding {
0000000000000000000000000000000000000000;;					s = append(s, portMapEntry{port: p, binding: b})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bindings[p] = []PortBinding{}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s = append(s, portMapEntry{port: p})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(s)
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			i  int
0000000000000000000000000000000000000000;;			pm = make(map[Port]struct{})
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// reorder ports
0000000000000000000000000000000000000000;;		for _, entry := range s {
0000000000000000000000000000000000000000;;			if _, ok := pm[entry.port]; !ok {
0000000000000000000000000000000000000000;;				ports[i] = entry.port
0000000000000000000000000000000000000000;;				pm[entry.port] = struct{}{}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// reorder bindings for this port
0000000000000000000000000000000000000000;;			if _, ok := bindings[entry.port]; ok {
0000000000000000000000000000000000000000;;				bindings[entry.port] = append(bindings[entry.port], entry.binding)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toInt(s string) uint64 {
0000000000000000000000000000000000000000;;		i, _, err := ParsePortRange(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			i = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
