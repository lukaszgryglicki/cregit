0000000000000000000000000000000000000000;;	// Package nat is a convenience package for manipulation of strings describing network ports.
0000000000000000000000000000000000000000;;	package nat
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/go-connections/nat/nat.go[Godeps/_workspace/src/github.com/docker/go-connections/nat/nat.go][vendor/github.com/docker/go-connections/nat/nat.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// portSpecTemplate is the expected format for port specifications
0000000000000000000000000000000000000000;;		portSpecTemplate = "ip:hostPort:containerPort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortBinding represents a binding between a Host IP address and a Host Port
0000000000000000000000000000000000000000;;	type PortBinding struct {
0000000000000000000000000000000000000000;;		// HostIP is the host IP Address
0000000000000000000000000000000000000000;;		HostIP string `json:"HostIp"`
0000000000000000000000000000000000000000;;		// HostPort is the host port number
0000000000000000000000000000000000000000;;		HostPort string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortMap is a collection of PortBinding indexed by Port
0000000000000000000000000000000000000000;;	type PortMap map[Port][]PortBinding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortSet is a collection of structs indexed by Port
0000000000000000000000000000000000000000;;	type PortSet map[Port]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Port is a string containing port number and protocol in the format "80/tcp"
0000000000000000000000000000000000000000;;	type Port string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPort creates a new instance of a Port given a protocol and port number or port range
0000000000000000000000000000000000000000;;	func NewPort(proto, port string) (Port, error) {
0000000000000000000000000000000000000000;;		// Check for parsing issues on "port" now so we can avoid having
0000000000000000000000000000000000000000;;		// to check it later on.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		portStartInt, portEndInt, err := ParsePortRangeToInt(port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if portStartInt == portEndInt {
0000000000000000000000000000000000000000;;			return Port(fmt.Sprintf("%d/%s", portStartInt, proto)), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Port(fmt.Sprintf("%d-%d/%s", portStartInt, portEndInt, proto)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePort parses the port number string and returns an int
0000000000000000000000000000000000000000;;	func ParsePort(rawPort string) (int, error) {
0000000000000000000000000000000000000000;;		if len(rawPort) == 0 {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port, err := strconv.ParseUint(rawPort, 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(port), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePortRangeToInt parses the port range string and returns start/end ints
0000000000000000000000000000000000000000;;	func ParsePortRangeToInt(rawPort string) (int, int, error) {
0000000000000000000000000000000000000000;;		if len(rawPort) == 0 {
0000000000000000000000000000000000000000;;			return 0, 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start, end, err := ParsePortRange(rawPort)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(start), int(end), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Proto returns the protocol of a Port
0000000000000000000000000000000000000000;;	func (p Port) Proto() string {
0000000000000000000000000000000000000000;;		proto, _ := SplitProtoPort(string(p))
0000000000000000000000000000000000000000;;		return proto
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Port returns the port number of a Port
0000000000000000000000000000000000000000;;	func (p Port) Port() string {
0000000000000000000000000000000000000000;;		_, port := SplitProtoPort(string(p))
0000000000000000000000000000000000000000;;		return port
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int returns the port number of a Port as an int
0000000000000000000000000000000000000000;;	func (p Port) Int() int {
0000000000000000000000000000000000000000;;		portStr := p.Port()
0000000000000000000000000000000000000000;;		if len(portStr) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't need to check for an error because we're going to
0000000000000000000000000000000000000000;;		// assume that any error would have been found, and reported, in NewPort()
0000000000000000000000000000000000000000;;		port, _ := strconv.ParseUint(portStr, 10, 16)
0000000000000000000000000000000000000000;;		return int(port)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Range returns the start/end port numbers of a Port range as ints
0000000000000000000000000000000000000000;;	func (p Port) Range() (int, int, error) {
0000000000000000000000000000000000000000;;		return ParsePortRangeToInt(p.Port())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitProtoPort splits a port in the format of proto/port
0000000000000000000000000000000000000000;;	func SplitProtoPort(rawPort string) (string, string) {
0000000000000000000000000000000000000000;;		parts := strings.Split(rawPort, "/")
0000000000000000000000000000000000000000;;		l := len(parts)
0000000000000000000000000000000000000000;;		if len(rawPort) == 0 || l == 0 || len(parts[0]) == 0 {
0000000000000000000000000000000000000000;;			return "", ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l == 1 {
0000000000000000000000000000000000000000;;			return "tcp", rawPort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(parts[1]) == 0 {
0000000000000000000000000000000000000000;;			return "tcp", parts[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parts[1], parts[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateProto(proto string) bool {
0000000000000000000000000000000000000000;;		for _, availableProto := range []string{"tcp", "udp"} {
0000000000000000000000000000000000000000;;			if availableProto == proto {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePortSpecs receives port specs in the format of ip:public:private/proto and parses
0000000000000000000000000000000000000000;;	// these in to the internal types
0000000000000000000000000000000000000000;;	func ParsePortSpecs(ports []string) (map[Port]struct{}, map[Port][]PortBinding, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			exposedPorts = make(map[Port]struct{}, len(ports))
0000000000000000000000000000000000000000;;			bindings     = make(map[Port][]PortBinding)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rawPort := range ports {
0000000000000000000000000000000000000000;;			proto := "tcp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i := strings.LastIndex(rawPort, "/"); i != -1 {
0000000000000000000000000000000000000000;;				proto = rawPort[i+1:]
0000000000000000000000000000000000000000;;				rawPort = rawPort[:i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(rawPort, ":") {
0000000000000000000000000000000000000000;;				rawPort = fmt.Sprintf("::%s", rawPort)
0000000000000000000000000000000000000000;;			} else if len(strings.Split(rawPort, ":")) == 2 {
0000000000000000000000000000000000000000;;				rawPort = fmt.Sprintf(":%s", rawPort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			parts, err := PartParser(portSpecTemplate, rawPort)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				containerPort = parts["containerPort"]
0000000000000000000000000000000000000000;;				rawIP         = parts["ip"]
0000000000000000000000000000000000000000;;				hostPort      = parts["hostPort"]
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if rawIP != "" && net.ParseIP(rawIP) == nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("Invalid ip address: %s", rawIP)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if containerPort == "" {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("No port specified: %s<empty>", rawPort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			startPort, endPort, err := ParsePortRange(containerPort)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("Invalid containerPort: %s", containerPort)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var startHostPort, endHostPort uint64 = 0, 0
0000000000000000000000000000000000000000;;			if len(hostPort) > 0 {
0000000000000000000000000000000000000000;;				startHostPort, endHostPort, err = ParsePortRange(hostPort)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("Invalid hostPort: %s", hostPort)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hostPort != "" && (endPort-startPort) != (endHostPort-startHostPort) {
0000000000000000000000000000000000000000;;				// Allow host port range iff containerPort is not a range.
0000000000000000000000000000000000000000;;				// In this case, use the host port range as the dynamic
0000000000000000000000000000000000000000;;				// host port range to allocate into.
0000000000000000000000000000000000000000;;				if endPort != startPort {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("Invalid ranges specified for container and host Ports: %s and %s", containerPort, hostPort)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !validateProto(strings.ToLower(proto)) {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("Invalid proto: %s", proto)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := uint64(0); i <= (endPort - startPort); i++ {
0000000000000000000000000000000000000000;;				containerPort = strconv.FormatUint(startPort+i, 10)
0000000000000000000000000000000000000000;;				if len(hostPort) > 0 {
0000000000000000000000000000000000000000;;					hostPort = strconv.FormatUint(startHostPort+i, 10)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Set hostPort to a range only if there is a single container port
0000000000000000000000000000000000000000;;				// and a dynamic host port.
0000000000000000000000000000000000000000;;				if startPort == endPort && startHostPort != endHostPort {
0000000000000000000000000000000000000000;;					hostPort = fmt.Sprintf("%s-%s", hostPort, strconv.FormatUint(endHostPort, 10))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				port, err := NewPort(strings.ToLower(proto), containerPort)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, exists := exposedPorts[port]; !exists {
0000000000000000000000000000000000000000;;					exposedPorts[port] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				binding := PortBinding{
0000000000000000000000000000000000000000;;					HostIP:   rawIP,
0000000000000000000000000000000000000000;;					HostPort: hostPort,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bslice, exists := bindings[port]
0000000000000000000000000000000000000000;;				if !exists {
0000000000000000000000000000000000000000;;					bslice = []PortBinding{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bindings[port] = append(bslice, binding)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return exposedPorts, bindings, nil
0000000000000000000000000000000000000000;;	}
