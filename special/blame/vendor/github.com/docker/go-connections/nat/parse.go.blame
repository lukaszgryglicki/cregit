0000000000000000000000000000000000000000;;	package nat
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/go-connections/nat/parse.go[Godeps/_workspace/src/github.com/docker/go-connections/nat/parse.go][vendor/github.com/docker/go-connections/nat/parse.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PartParser parses and validates the specified string (data) using the specified template
0000000000000000000000000000000000000000;;	// e.g. ip:public:private -> 192.168.0.1:80:8000
0000000000000000000000000000000000000000;;	func PartParser(template, data string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		// ip:public:private
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			templateParts = strings.Split(template, ":")
0000000000000000000000000000000000000000;;			parts         = strings.Split(data, ":")
0000000000000000000000000000000000000000;;			out           = make(map[string]string, len(templateParts))
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if len(parts) != len(templateParts) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Invalid format to parse. %s should match template %s", data, template)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, t := range templateParts {
0000000000000000000000000000000000000000;;			value := ""
0000000000000000000000000000000000000000;;			if len(parts) > i {
0000000000000000000000000000000000000000;;				value = parts[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out[t] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePortRange parses and validates the specified string as a port-range (8000-9000)
0000000000000000000000000000000000000000;;	func ParsePortRange(ports string) (uint64, uint64, error) {
0000000000000000000000000000000000000000;;		if ports == "" {
0000000000000000000000000000000000000000;;			return 0, 0, fmt.Errorf("Empty string specified for ports.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(ports, "-") {
0000000000000000000000000000000000000000;;			start, err := strconv.ParseUint(ports, 10, 16)
0000000000000000000000000000000000000000;;			end := start
0000000000000000000000000000000000000000;;			return start, end, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := strings.Split(ports, "-")
0000000000000000000000000000000000000000;;		start, err := strconv.ParseUint(parts[0], 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end, err := strconv.ParseUint(parts[1], 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end < start {
0000000000000000000000000000000000000000;;			return 0, 0, fmt.Errorf("Invalid range specified for the Port: %s", ports)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return start, end, nil
0000000000000000000000000000000000000000;;	}
