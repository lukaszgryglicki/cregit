0000000000000000000000000000000000000000;;	package sockets
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/go-connections/sockets/inmem_socket.go[Godeps/_workspace/src/github.com/docker/go-connections/sockets/inmem_socket.go][vendor/github.com/docker/go-connections/sockets/inmem_socket.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errClosed = errors.New("use of closed network connection")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InmemSocket implements net.Listener using in-memory only connections.
0000000000000000000000000000000000000000;;	type InmemSocket struct {
0000000000000000000000000000000000000000;;		chConn  chan net.Conn
0000000000000000000000000000000000000000;;		chClose chan struct{}
0000000000000000000000000000000000000000;;		addr    string
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dummyAddr is used to satisfy net.Addr for the in-mem socket
0000000000000000000000000000000000000000;;	// it is just stored as a string and returns the string for all calls
0000000000000000000000000000000000000000;;	type dummyAddr string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInmemSocket creates an in-memory only net.Listener
0000000000000000000000000000000000000000;;	// The addr argument can be any string, but is used to satisfy the `Addr()` part
0000000000000000000000000000000000000000;;	// of the net.Listener interface
0000000000000000000000000000000000000000;;	func NewInmemSocket(addr string, bufSize int) *InmemSocket {
0000000000000000000000000000000000000000;;		return &InmemSocket{
0000000000000000000000000000000000000000;;			chConn:  make(chan net.Conn, bufSize),
0000000000000000000000000000000000000000;;			chClose: make(chan struct{}),
0000000000000000000000000000000000000000;;			addr:    addr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addr returns the socket's addr string to satisfy net.Listener
0000000000000000000000000000000000000000;;	func (s *InmemSocket) Addr() net.Addr {
0000000000000000000000000000000000000000;;		return dummyAddr(s.addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn.
0000000000000000000000000000000000000000;;	func (s *InmemSocket) Accept() (net.Conn, error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case conn := <-s.chConn:
0000000000000000000000000000000000000000;;			return conn, nil
0000000000000000000000000000000000000000;;		case <-s.chClose:
0000000000000000000000000000000000000000;;			return nil, errClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the listener. It will be unavailable for use once closed.
0000000000000000000000000000000000000000;;	func (s *InmemSocket) Close() error {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.chClose:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			close(s.chClose)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial is used to establish a connection with the in-mem server
0000000000000000000000000000000000000000;;	func (s *InmemSocket) Dial(network, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		srvConn, clientConn := net.Pipe()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case s.chConn <- srvConn:
0000000000000000000000000000000000000000;;		case <-s.chClose:
0000000000000000000000000000000000000000;;			return nil, errClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientConn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Network returns the addr string, satisfies net.Addr
0000000000000000000000000000000000000000;;	func (a dummyAddr) Network() string {
0000000000000000000000000000000000000000;;		return string(a)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string form
0000000000000000000000000000000000000000;;	func (a dummyAddr) String() string {
0000000000000000000000000000000000000000;;		return string(a)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timeoutError is used when there is a timeout with a connection
0000000000000000000000000000000000000000;;	// this implements the net.Error interface
0000000000000000000000000000000000000000;;	type timeoutError struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *timeoutError) Error() string   { return "i/o timeout" }
0000000000000000000000000000000000000000;;	func (e *timeoutError) Timeout() bool   { return true }
0000000000000000000000000000000000000000;;	func (e *timeoutError) Temporary() bool { return true }
