0000000000000000000000000000000000000000;;	// Package tlsconfig provides primitives to retrieve secure-enough TLS configurations for both clients and servers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As a reminder from https://golang.org/pkg/crypto/tls/#Config:
0000000000000000000000000000000000000000;;	//	A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified.
0000000000000000000000000000000000000000;;	//	A Config may be reused; the tls package will also not modify it.
0000000000000000000000000000000000000000;;	package tlsconfig
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/docker/go-connections/tlsconfig/config.go[Godeps/_workspace/src/github.com/docker/go-connections/tlsconfig/config.go][vendor/github.com/docker/go-connections/tlsconfig/config.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Sirupsen/logrus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options represents the information needed to create client and server TLS configurations.
0000000000000000000000000000000000000000;;	type Options struct {
0000000000000000000000000000000000000000;;		CAFile string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If either CertFile or KeyFile is empty, Client() will not load them
0000000000000000000000000000000000000000;;		// preventing the client from authenticating to the server.
0000000000000000000000000000000000000000;;		// However, Server() requires them and will error out if they are empty.
0000000000000000000000000000000000000000;;		CertFile string
0000000000000000000000000000000000000000;;		KeyFile  string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// client-only option
0000000000000000000000000000000000000000;;		InsecureSkipVerify bool
0000000000000000000000000000000000000000;;		// server-only option
0000000000000000000000000000000000000000;;		ClientAuth tls.ClientAuthType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extra (server-side) accepted CBC cipher suites - will phase out in the future
0000000000000000000000000000000000000000;;	var acceptedCBCCiphers = []uint16{
0000000000000000000000000000000000000000;;		tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
0000000000000000000000000000000000000000;;		tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
0000000000000000000000000000000000000000;;		tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
0000000000000000000000000000000000000000;;		tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
0000000000000000000000000000000000000000;;		tls.TLS_RSA_WITH_AES_256_CBC_SHA,
0000000000000000000000000000000000000000;;		tls.TLS_RSA_WITH_AES_128_CBC_SHA,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultServerAcceptedCiphers should be uses by code which already has a crypto/tls
0000000000000000000000000000000000000000;;	// options struct but wants to use a commonly accepted set of TLS cipher suites, with
0000000000000000000000000000000000000000;;	// known weak algorithms removed.
0000000000000000000000000000000000000000;;	var DefaultServerAcceptedCiphers = append(clientCipherSuites, acceptedCBCCiphers...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerDefault is a secure-enough TLS configuration for the server TLS configuration.
0000000000000000000000000000000000000000;;	var ServerDefault = tls.Config{
0000000000000000000000000000000000000000;;		// Avoid fallback to SSL protocols < TLS1.0
0000000000000000000000000000000000000000;;		MinVersion:               tls.VersionTLS10,
0000000000000000000000000000000000000000;;		PreferServerCipherSuites: true,
0000000000000000000000000000000000000000;;		CipherSuites:             DefaultServerAcceptedCiphers,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientDefault is a secure-enough TLS configuration for the client TLS configuration.
0000000000000000000000000000000000000000;;	var ClientDefault = tls.Config{
0000000000000000000000000000000000000000;;		// Prefer TLS1.2 as the client minimum
0000000000000000000000000000000000000000;;		MinVersion:   tls.VersionTLS12,
0000000000000000000000000000000000000000;;		CipherSuites: clientCipherSuites,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// certPool returns an X.509 certificate pool from `caFile`, the certificate file.
0000000000000000000000000000000000000000;;	func certPool(caFile string) (*x509.CertPool, error) {
0000000000000000000000000000000000000000;;		// If we should verify the server, we need to load a trusted ca
0000000000000000000000000000000000000000;;		certPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;		pem, err := ioutil.ReadFile(caFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Could not read CA certificate %q: %v", caFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !certPool.AppendCertsFromPEM(pem) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to append certificates from PEM file: %q", caFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logrus.Debugf("Trusting %d certs", len(certPool.Subjects()))
0000000000000000000000000000000000000000;;		return certPool, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client returns a TLS configuration meant to be used by a client.
0000000000000000000000000000000000000000;;	func Client(options Options) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		tlsConfig := ClientDefault
0000000000000000000000000000000000000000;;		tlsConfig.InsecureSkipVerify = options.InsecureSkipVerify
0000000000000000000000000000000000000000;;		if !options.InsecureSkipVerify && options.CAFile != "" {
0000000000000000000000000000000000000000;;			CAs, err := certPool(options.CAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.RootCAs = CAs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.CertFile != "" || options.KeyFile != "" {
0000000000000000000000000000000000000000;;			tlsCert, err := tls.LoadX509KeyPair(options.CertFile, options.KeyFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Could not load X509 key pair: %v. Make sure the key is not encrypted", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.Certificates = []tls.Certificate{tlsCert}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &tlsConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server returns a TLS configuration meant to be used by a server.
0000000000000000000000000000000000000000;;	func Server(options Options) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		tlsConfig := ServerDefault
0000000000000000000000000000000000000000;;		tlsConfig.ClientAuth = options.ClientAuth
0000000000000000000000000000000000000000;;		tlsCert, err := tls.LoadX509KeyPair(options.CertFile, options.KeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Could not load X509 key pair (cert: %q, key: %q): %v", options.CertFile, options.KeyFile, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error reading X509 key pair (cert: %q, key: %q): %v. Make sure the key is not encrypted.", options.CertFile, options.KeyFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tlsConfig.Certificates = []tls.Certificate{tlsCert}
0000000000000000000000000000000000000000;;		if options.ClientAuth >= tls.VerifyClientCertIfGiven {
0000000000000000000000000000000000000000;;			CAs, err := certPool(options.CAFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.ClientCAs = CAs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &tlsConfig, nil
0000000000000000000000000000000000000000;;	}
