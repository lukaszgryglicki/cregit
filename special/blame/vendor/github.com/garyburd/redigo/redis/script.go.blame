0000000000000000000000000000000000000000;;	// Copyright 2012 Gary Burd
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/garyburd/redigo/redis/script.go[Godeps/_workspace/src/github.com/garyburd/redigo/redis/script.go][vendor/github.com/garyburd/redigo/redis/script.go];	
0000000000000000000000000000000000000000;;	package redis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Script encapsulates the source, hash and key count for a Lua script. See
0000000000000000000000000000000000000000;;	// http://redis.io/commands/eval for information on scripts in Redis.
0000000000000000000000000000000000000000;;	type Script struct {
0000000000000000000000000000000000000000;;		keyCount int
0000000000000000000000000000000000000000;;		src      string
0000000000000000000000000000000000000000;;		hash     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewScript returns a new script object. If keyCount is greater than or equal
0000000000000000000000000000000000000000;;	// to zero, then the count is automatically inserted in the EVAL command
0000000000000000000000000000000000000000;;	// argument list. If keyCount is less than zero, then the application supplies
0000000000000000000000000000000000000000;;	// the count as the first value in the keysAndArgs argument to the Do, Send and
0000000000000000000000000000000000000000;;	// SendHash methods.
0000000000000000000000000000000000000000;;	func NewScript(keyCount int, src string) *Script {
0000000000000000000000000000000000000000;;		h := sha1.New()
0000000000000000000000000000000000000000;;		io.WriteString(h, src)
0000000000000000000000000000000000000000;;		return &Script{keyCount, src, hex.EncodeToString(h.Sum(nil))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Script) args(spec string, keysAndArgs []interface{}) []interface{} {
0000000000000000000000000000000000000000;;		var args []interface{}
0000000000000000000000000000000000000000;;		if s.keyCount < 0 {
0000000000000000000000000000000000000000;;			args = make([]interface{}, 1+len(keysAndArgs))
0000000000000000000000000000000000000000;;			args[0] = spec
0000000000000000000000000000000000000000;;			copy(args[1:], keysAndArgs)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			args = make([]interface{}, 2+len(keysAndArgs))
0000000000000000000000000000000000000000;;			args[0] = spec
0000000000000000000000000000000000000000;;			args[1] = s.keyCount
0000000000000000000000000000000000000000;;			copy(args[2:], keysAndArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do evaluates the script. Under the covers, Do optimistically evaluates the
0000000000000000000000000000000000000000;;	// script using the EVALSHA command. If the command fails because the script is
0000000000000000000000000000000000000000;;	// not loaded, then Do evaluates the script using the EVAL command (thus
0000000000000000000000000000000000000000;;	// causing the script to load).
0000000000000000000000000000000000000000;;	func (s *Script) Do(c Conn, keysAndArgs ...interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		v, err := c.Do("EVALSHA", s.args(s.hash, keysAndArgs)...)
0000000000000000000000000000000000000000;;		if e, ok := err.(Error); ok && strings.HasPrefix(string(e), "NOSCRIPT ") {
0000000000000000000000000000000000000000;;			v, err = c.Do("EVAL", s.args(s.src, keysAndArgs)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendHash evaluates the script without waiting for the reply. The script is
0000000000000000000000000000000000000000;;	// evaluated with the EVALSHA command. The application must ensure that the
0000000000000000000000000000000000000000;;	// script is loaded by a previous call to Send, Do or Load methods.
0000000000000000000000000000000000000000;;	func (s *Script) SendHash(c Conn, keysAndArgs ...interface{}) error {
0000000000000000000000000000000000000000;;		return c.Send("EVALSHA", s.args(s.hash, keysAndArgs)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send evaluates the script without waiting for the reply.
0000000000000000000000000000000000000000;;	func (s *Script) Send(c Conn, keysAndArgs ...interface{}) error {
0000000000000000000000000000000000000000;;		return c.Send("EVAL", s.args(s.src, keysAndArgs)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load loads the script without evaluating it.
0000000000000000000000000000000000000000;;	func (s *Script) Load(c Conn) error {
0000000000000000000000000000000000000000;;		_, err := c.Do("SCRIPT", "LOAD", s.src)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
