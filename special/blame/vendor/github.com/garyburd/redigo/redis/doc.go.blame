0000000000000000000000000000000000000000;;	// Copyright 2012 Gary Burd
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/garyburd/redigo/redis/doc.go[Godeps/_workspace/src/github.com/garyburd/redigo/redis/doc.go][vendor/github.com/garyburd/redigo/redis/doc.go];	
0000000000000000000000000000000000000000;;	// Package redis is a client for the Redis database.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Redigo FAQ (https://github.com/garyburd/redigo/wiki/FAQ) contains more
0000000000000000000000000000000000000000;;	// documentation about this package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Connections
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Conn interface is the primary interface for working with Redis.
0000000000000000000000000000000000000000;;	// Applications create connections by calling the Dial, DialWithTimeout or
0000000000000000000000000000000000000000;;	// NewConn functions. In the future, functions will be added for creating
0000000000000000000000000000000000000000;;	// sharded and other types of connections.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The application must call the connection Close method when the application
0000000000000000000000000000000000000000;;	// is done with the connection.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Executing Commands
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Conn interface has a generic method for executing Redis commands:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  Do(commandName string, args ...interface{}) (reply interface{}, err error)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Redis command reference (http://redis.io/commands) lists the available
0000000000000000000000000000000000000000;;	// commands. An example of using the Redis APPEND command is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  n, err := conn.Do("APPEND", "key", "value")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Do method converts command arguments to binary strings for transmission
0000000000000000000000000000000000000000;;	// to the server as follows:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  Go Type                 Conversion
0000000000000000000000000000000000000000;;	//  []byte                  Sent as is
0000000000000000000000000000000000000000;;	//  string                  Sent as is
0000000000000000000000000000000000000000;;	//  int, int64              strconv.FormatInt(v)
0000000000000000000000000000000000000000;;	//  float64                 strconv.FormatFloat(v, 'g', -1, 64)
0000000000000000000000000000000000000000;;	//  bool                    true -> "1", false -> "0"
0000000000000000000000000000000000000000;;	//  nil                     ""
0000000000000000000000000000000000000000;;	//  all other types         fmt.Print(v)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redis command reply types are represented using the following Go types:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  Redis type              Go type
0000000000000000000000000000000000000000;;	//  error                   redis.Error
0000000000000000000000000000000000000000;;	//  integer                 int64
0000000000000000000000000000000000000000;;	//  simple string           string
0000000000000000000000000000000000000000;;	//  bulk string             []byte or nil if value not present.
0000000000000000000000000000000000000000;;	//  array                   []interface{} or nil if value not present.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use type assertions or the reply helper functions to convert from
0000000000000000000000000000000000000000;;	// interface{} to the specific Go type for the command result.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Pipelining
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Connections support pipelining using the Send, Flush and Receive methods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  Send(commandName string, args ...interface{}) error
0000000000000000000000000000000000000000;;	//  Flush() error
0000000000000000000000000000000000000000;;	//  Receive() (reply interface{}, err error)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Send writes the command to the connection's output buffer. Flush flushes the
0000000000000000000000000000000000000000;;	// connection's output buffer to the server. Receive reads a single reply from
0000000000000000000000000000000000000000;;	// the server. The following example shows a simple pipeline.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  c.Send("SET", "foo", "bar")
0000000000000000000000000000000000000000;;	//  c.Send("GET", "foo")
0000000000000000000000000000000000000000;;	//  c.Flush()
0000000000000000000000000000000000000000;;	//  c.Receive() // reply from SET
0000000000000000000000000000000000000000;;	//  v, err = c.Receive() // reply from GET
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Do method combines the functionality of the Send, Flush and Receive
0000000000000000000000000000000000000000;;	// methods. The Do method starts by writing the command and flushing the output
0000000000000000000000000000000000000000;;	// buffer. Next, the Do method receives all pending replies including the reply
0000000000000000000000000000000000000000;;	// for the command just sent by Do. If any of the received replies is an error,
0000000000000000000000000000000000000000;;	// then Do returns the error. If there are no errors, then Do returns the last
0000000000000000000000000000000000000000;;	// reply. If the command argument to the Do method is "", then the Do method
0000000000000000000000000000000000000000;;	// will flush the output buffer and receive pending replies without sending a
0000000000000000000000000000000000000000;;	// command.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use the Send and Do methods to implement pipelined transactions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  c.Send("MULTI")
0000000000000000000000000000000000000000;;	//  c.Send("INCR", "foo")
0000000000000000000000000000000000000000;;	//  c.Send("INCR", "bar")
0000000000000000000000000000000000000000;;	//  r, err := c.Do("EXEC")
0000000000000000000000000000000000000000;;	//  fmt.Println(r) // prints [1, 1]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Concurrency
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Connections support one concurrent caller to the Recieve method and one
0000000000000000000000000000000000000000;;	// concurrent caller to the Send and Flush methods. No other concurrency is
0000000000000000000000000000000000000000;;	// supported including concurrent calls to the Do method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For full concurrent access to Redis, use the thread-safe Pool to get, use
0000000000000000000000000000000000000000;;	// and release a connection from within a goroutine. Connections returned from
0000000000000000000000000000000000000000;;	// a Pool have the concurrency restrictions described in the previous
0000000000000000000000000000000000000000;;	// paragraph.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Publish and Subscribe
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use the Send, Flush and Receive methods to implement Pub/Sub subscribers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  c.Send("SUBSCRIBE", "example")
0000000000000000000000000000000000000000;;	//  c.Flush()
0000000000000000000000000000000000000000;;	//  for {
0000000000000000000000000000000000000000;;	//      reply, err := c.Receive()
0000000000000000000000000000000000000000;;	//      if err != nil {
0000000000000000000000000000000000000000;;	//          return err
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//      // process pushed message
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The PubSubConn type wraps a Conn with convenience methods for implementing
0000000000000000000000000000000000000000;;	// subscribers. The Subscribe, PSubscribe, Unsubscribe and PUnsubscribe methods
0000000000000000000000000000000000000000;;	// send and flush a subscription management command. The receive method
0000000000000000000000000000000000000000;;	// converts a pushed message to convenient types for use in a type switch.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  psc := redis.PubSubConn{c}
0000000000000000000000000000000000000000;;	//  psc.Subscribe("example")
0000000000000000000000000000000000000000;;	//  for {
0000000000000000000000000000000000000000;;	//      switch v := psc.Receive().(type) {
0000000000000000000000000000000000000000;;	//      case redis.Message:
0000000000000000000000000000000000000000;;	//          fmt.Printf("%s: message: %s\n", v.Channel, v.Data)
0000000000000000000000000000000000000000;;	//      case redis.Subscription:
0000000000000000000000000000000000000000;;	//          fmt.Printf("%s: %s %d\n", v.Channel, v.Kind, v.Count)
0000000000000000000000000000000000000000;;	//      case error:
0000000000000000000000000000000000000000;;	//          return v
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Reply Helpers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Bool, Int, Bytes, String, Strings and Values functions convert a reply
0000000000000000000000000000000000000000;;	// to a value of a specific type. To allow convenient wrapping of calls to the
0000000000000000000000000000000000000000;;	// connection Do and Receive methods, the functions take a second argument of
0000000000000000000000000000000000000000;;	// type error.  If the error is non-nil, then the helper function returns the
0000000000000000000000000000000000000000;;	// error. If the error is nil, the function converts the reply to the specified
0000000000000000000000000000000000000000;;	// type:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  exists, err := redis.Bool(c.Do("EXISTS", "foo"))
0000000000000000000000000000000000000000;;	//  if err != nil {
0000000000000000000000000000000000000000;;	//      // handle error return from c.Do or type conversion error.
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Scan function converts elements of a array reply to Go types:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  var value1 int
0000000000000000000000000000000000000000;;	//  var value2 string
0000000000000000000000000000000000000000;;	//  reply, err := redis.Values(c.Do("MGET", "key1", "key2"))
0000000000000000000000000000000000000000;;	//  if err != nil {
0000000000000000000000000000000000000000;;	//      // handle error
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//   if _, err := redis.Scan(reply, &value1, &value2); err != nil {
0000000000000000000000000000000000000000;;	//      // handle error
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	package redis
