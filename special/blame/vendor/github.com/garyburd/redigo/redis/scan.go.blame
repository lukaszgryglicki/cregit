0000000000000000000000000000000000000000;;	// Copyright 2012 Gary Burd
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/garyburd/redigo/redis/scan.go[Godeps/_workspace/src/github.com/garyburd/redigo/redis/scan.go][vendor/github.com/garyburd/redigo/redis/scan.go];	
0000000000000000000000000000000000000000;;	package redis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureLen(d reflect.Value, n int) {
0000000000000000000000000000000000000000;;		if n > d.Cap() {
0000000000000000000000000000000000000000;;			d.Set(reflect.MakeSlice(d.Type(), n, n))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.SetLen(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cannotConvert(d reflect.Value, s interface{}) error {
0000000000000000000000000000000000000000;;		var sname string
0000000000000000000000000000000000000000;;		switch s.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			sname = "Redis simple string"
0000000000000000000000000000000000000000;;		case Error:
0000000000000000000000000000000000000000;;			sname = "Redis error"
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			sname = "Redis integer"
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			sname = "Redis bulk string"
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			sname = "Redis array"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			sname = reflect.TypeOf(s).String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("cannot convert from %s to %s", sname, d.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertAssignBulkString(d reflect.Value, s []byte) (err error) {
0000000000000000000000000000000000000000;;		switch d.Type().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			var x float64
0000000000000000000000000000000000000000;;			x, err = strconv.ParseFloat(string(s), d.Type().Bits())
0000000000000000000000000000000000000000;;			d.SetFloat(x)
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			var x int64
0000000000000000000000000000000000000000;;			x, err = strconv.ParseInt(string(s), 10, d.Type().Bits())
0000000000000000000000000000000000000000;;			d.SetInt(x)
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			var x uint64
0000000000000000000000000000000000000000;;			x, err = strconv.ParseUint(string(s), 10, d.Type().Bits())
0000000000000000000000000000000000000000;;			d.SetUint(x)
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			var x bool
0000000000000000000000000000000000000000;;			x, err = strconv.ParseBool(string(s))
0000000000000000000000000000000000000000;;			d.SetBool(x)
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			d.SetString(string(s))
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if d.Type().Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;				err = cannotConvert(d, s)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.SetBytes(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = cannotConvert(d, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertAssignInt(d reflect.Value, s int64) (err error) {
0000000000000000000000000000000000000000;;		switch d.Type().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			d.SetInt(s)
0000000000000000000000000000000000000000;;			if d.Int() != s {
0000000000000000000000000000000000000000;;				err = strconv.ErrRange
0000000000000000000000000000000000000000;;				d.SetInt(0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			if s < 0 {
0000000000000000000000000000000000000000;;				err = strconv.ErrRange
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x := uint64(s)
0000000000000000000000000000000000000000;;				d.SetUint(x)
0000000000000000000000000000000000000000;;				if d.Uint() != x {
0000000000000000000000000000000000000000;;					err = strconv.ErrRange
0000000000000000000000000000000000000000;;					d.SetUint(0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			d.SetBool(s != 0)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = cannotConvert(d, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertAssignValue(d reflect.Value, s interface{}) (err error) {
0000000000000000000000000000000000000000;;		switch s := s.(type) {
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			err = convertAssignBulkString(d, s)
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			err = convertAssignInt(d, s)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = cannotConvert(d, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertAssignArray(d reflect.Value, s []interface{}) error {
0000000000000000000000000000000000000000;;		if d.Type().Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return cannotConvert(d, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ensureLen(d, len(s))
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if err := convertAssignValue(d.Index(i), s[i]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertAssign(d interface{}, s interface{}) (err error) {
0000000000000000000000000000000000000000;;		// Handle the most common destination types using type switches and
0000000000000000000000000000000000000000;;		// fall back to reflection for all other types.
0000000000000000000000000000000000000000;;		switch s := s.(type) {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			// ingore
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			switch d := d.(type) {
0000000000000000000000000000000000000000;;			case *string:
0000000000000000000000000000000000000000;;				*d = string(s)
0000000000000000000000000000000000000000;;			case *int:
0000000000000000000000000000000000000000;;				*d, err = strconv.Atoi(string(s))
0000000000000000000000000000000000000000;;			case *bool:
0000000000000000000000000000000000000000;;				*d, err = strconv.ParseBool(string(s))
0000000000000000000000000000000000000000;;			case *[]byte:
0000000000000000000000000000000000000000;;				*d = s
0000000000000000000000000000000000000000;;			case *interface{}:
0000000000000000000000000000000000000000;;				*d = s
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				// skip value
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if d := reflect.ValueOf(d); d.Type().Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;					err = cannotConvert(d, s)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = convertAssignBulkString(d.Elem(), s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			switch d := d.(type) {
0000000000000000000000000000000000000000;;			case *int:
0000000000000000000000000000000000000000;;				x := int(s)
0000000000000000000000000000000000000000;;				if int64(x) != s {
0000000000000000000000000000000000000000;;					err = strconv.ErrRange
0000000000000000000000000000000000000000;;					x = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*d = x
0000000000000000000000000000000000000000;;			case *bool:
0000000000000000000000000000000000000000;;				*d = s != 0
0000000000000000000000000000000000000000;;			case *interface{}:
0000000000000000000000000000000000000000;;				*d = s
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				// skip value
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if d := reflect.ValueOf(d); d.Type().Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;					err = cannotConvert(d, s)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = convertAssignInt(d.Elem(), s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			switch d := d.(type) {
0000000000000000000000000000000000000000;;			case *string:
0000000000000000000000000000000000000000;;				*d = string(s)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				err = cannotConvert(reflect.ValueOf(d), s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			switch d := d.(type) {
0000000000000000000000000000000000000000;;			case *[]interface{}:
0000000000000000000000000000000000000000;;				*d = s
0000000000000000000000000000000000000000;;			case *interface{}:
0000000000000000000000000000000000000000;;				*d = s
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				// skip value
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if d := reflect.ValueOf(d); d.Type().Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;					err = cannotConvert(d, s)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = convertAssignArray(d.Elem(), s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Error:
0000000000000000000000000000000000000000;;			err = s
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = cannotConvert(reflect.ValueOf(d), s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan copies from src to the values pointed at by dest.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The values pointed at by dest must be an integer, float, boolean, string,
0000000000000000000000000000000000000000;;	// []byte, interface{} or slices of these types. Scan uses the standard strconv
0000000000000000000000000000000000000000;;	// package to convert bulk strings to numeric and boolean types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a dest value is nil, then the corresponding src value is skipped.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a src element is nil, then the corresponding dest value is not modified.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To enable easy use of Scan in a loop, Scan returns the slice of src
0000000000000000000000000000000000000000;;	// following the copied values.
0000000000000000000000000000000000000000;;	func Scan(src []interface{}, dest ...interface{}) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		if len(src) < len(dest) {
0000000000000000000000000000000000000000;;			return nil, errors.New("redigo.Scan: array short")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i, d := range dest {
0000000000000000000000000000000000000000;;			err = convertAssign(d, src[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("redigo.Scan: cannot assign to dest %d: %v", i, err)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return src[len(dest):], err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldSpec struct {
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		index     []int
0000000000000000000000000000000000000000;;		omitEmpty bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type structSpec struct {
0000000000000000000000000000000000000000;;		m map[string]*fieldSpec
0000000000000000000000000000000000000000;;		l []*fieldSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *structSpec) fieldSpec(name []byte) *fieldSpec {
0000000000000000000000000000000000000000;;		return ss.m[string(name)]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compileStructSpec(t reflect.Type, depth map[string]int, index []int, ss *structSpec) {
0000000000000000000000000000000000000000;;		for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;			f := t.Field(i)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case f.PkgPath != "" && !f.Anonymous:
0000000000000000000000000000000000000000;;				// Ignore unexported fields.
0000000000000000000000000000000000000000;;			case f.Anonymous:
0000000000000000000000000000000000000000;;				// TODO: Handle pointers. Requires change to decoder and
0000000000000000000000000000000000000000;;				// protection against infinite recursion.
0000000000000000000000000000000000000000;;				if f.Type.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;					compileStructSpec(f.Type, depth, append(index, i), ss)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fs := &fieldSpec{name: f.Name}
0000000000000000000000000000000000000000;;				tag := f.Tag.Get("redis")
0000000000000000000000000000000000000000;;				p := strings.Split(tag, ",")
0000000000000000000000000000000000000000;;				if len(p) > 0 {
0000000000000000000000000000000000000000;;					if p[0] == "-" {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(p[0]) > 0 {
0000000000000000000000000000000000000000;;						fs.name = p[0]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, s := range p[1:] {
0000000000000000000000000000000000000000;;						switch s {
0000000000000000000000000000000000000000;;						case "omitempty":
0000000000000000000000000000000000000000;;							fs.omitEmpty = true
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;							panic(fmt.Errorf("redigo: unknown field tag %s for type %s", s, t.Name()))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d, found := depth[fs.name]
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					d = 1 << 30
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case len(index) == d:
0000000000000000000000000000000000000000;;					// At same depth, remove from result.
0000000000000000000000000000000000000000;;					delete(ss.m, fs.name)
0000000000000000000000000000000000000000;;					j := 0
0000000000000000000000000000000000000000;;					for i := 0; i < len(ss.l); i++ {
0000000000000000000000000000000000000000;;						if fs.name != ss.l[i].name {
0000000000000000000000000000000000000000;;							ss.l[j] = ss.l[i]
0000000000000000000000000000000000000000;;							j += 1
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ss.l = ss.l[:j]
0000000000000000000000000000000000000000;;				case len(index) < d:
0000000000000000000000000000000000000000;;					fs.index = make([]int, len(index)+1)
0000000000000000000000000000000000000000;;					copy(fs.index, index)
0000000000000000000000000000000000000000;;					fs.index[len(index)] = i
0000000000000000000000000000000000000000;;					depth[fs.name] = len(index)
0000000000000000000000000000000000000000;;					ss.m[fs.name] = fs
0000000000000000000000000000000000000000;;					ss.l = append(ss.l, fs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		structSpecMutex  sync.RWMutex
0000000000000000000000000000000000000000;;		structSpecCache  = make(map[reflect.Type]*structSpec)
0000000000000000000000000000000000000000;;		defaultFieldSpec = &fieldSpec{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structSpecForType(t reflect.Type) *structSpec {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		structSpecMutex.RLock()
0000000000000000000000000000000000000000;;		ss, found := structSpecCache[t]
0000000000000000000000000000000000000000;;		structSpecMutex.RUnlock()
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			return ss
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		structSpecMutex.Lock()
0000000000000000000000000000000000000000;;		defer structSpecMutex.Unlock()
0000000000000000000000000000000000000000;;		ss, found = structSpecCache[t]
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			return ss
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss = &structSpec{m: make(map[string]*fieldSpec)}
0000000000000000000000000000000000000000;;		compileStructSpec(t, make(map[string]int), nil, ss)
0000000000000000000000000000000000000000;;		structSpecCache[t] = ss
0000000000000000000000000000000000000000;;		return ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errScanStructValue = errors.New("redigo.ScanStruct: value must be non-nil pointer to a struct")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScanStruct scans alternating names and values from src to a struct. The
0000000000000000000000000000000000000000;;	// HGETALL and CONFIG GET commands return replies in this format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ScanStruct uses exported field names to match values in the response. Use
0000000000000000000000000000000000000000;;	// 'redis' field tag to override the name:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Field int `redis:"myName"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Fields with the tag redis:"-" are ignored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Integer, float, boolean, string and []byte fields are supported. Scan uses the
0000000000000000000000000000000000000000;;	// standard strconv package to convert bulk string values to numeric and
0000000000000000000000000000000000000000;;	// boolean types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a src element is nil, then the corresponding field is not modified.
0000000000000000000000000000000000000000;;	func ScanStruct(src []interface{}, dest interface{}) error {
0000000000000000000000000000000000000000;;		d := reflect.ValueOf(dest)
0000000000000000000000000000000000000000;;		if d.Kind() != reflect.Ptr || d.IsNil() {
0000000000000000000000000000000000000000;;			return errScanStructValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d = d.Elem()
0000000000000000000000000000000000000000;;		if d.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return errScanStructValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := structSpecForType(d.Type())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(src)%2 != 0 {
0000000000000000000000000000000000000000;;			return errors.New("redigo.ScanStruct: number of values not a multiple of 2")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(src); i += 2 {
0000000000000000000000000000000000000000;;			s := src[i+1]
0000000000000000000000000000000000000000;;			if s == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name, ok := src[i].([]byte)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("redigo.ScanStruct: key %d not a bulk string value", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fs := ss.fieldSpec(name)
0000000000000000000000000000000000000000;;			if fs == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := convertAssignValue(d.FieldByIndex(fs.index), s); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("redigo.ScanStruct: cannot assign field %s: %v", fs.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errScanSliceValue = errors.New("redigo.ScanSlice: dest must be non-nil pointer to a struct")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScanSlice scans src to the slice pointed to by dest. The elements the dest
0000000000000000000000000000000000000000;;	// slice must be integer, float, boolean, string, struct or pointer to struct
0000000000000000000000000000000000000000;;	// values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Struct fields must be integer, float, boolean or string values. All struct
0000000000000000000000000000000000000000;;	// fields are used unless a subset is specified using fieldNames.
0000000000000000000000000000000000000000;;	func ScanSlice(src []interface{}, dest interface{}, fieldNames ...string) error {
0000000000000000000000000000000000000000;;		d := reflect.ValueOf(dest)
0000000000000000000000000000000000000000;;		if d.Kind() != reflect.Ptr || d.IsNil() {
0000000000000000000000000000000000000000;;			return errScanSliceValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d = d.Elem()
0000000000000000000000000000000000000000;;		if d.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return errScanSliceValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isPtr := false
0000000000000000000000000000000000000000;;		t := d.Type().Elem()
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			isPtr = true
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			ensureLen(d, len(src))
0000000000000000000000000000000000000000;;			for i, s := range src {
0000000000000000000000000000000000000000;;				if s == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := convertAssignValue(d.Index(i), s); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("redigo.ScanSlice: cannot assign element %d: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss := structSpecForType(t)
0000000000000000000000000000000000000000;;		fss := ss.l
0000000000000000000000000000000000000000;;		if len(fieldNames) > 0 {
0000000000000000000000000000000000000000;;			fss = make([]*fieldSpec, len(fieldNames))
0000000000000000000000000000000000000000;;			for i, name := range fieldNames {
0000000000000000000000000000000000000000;;				fss[i] = ss.m[name]
0000000000000000000000000000000000000000;;				if fss[i] == nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("redigo.ScanSlice: ScanSlice bad field name %s", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(fss) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("redigo.ScanSlice: no struct fields")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := len(src) / len(fss)
0000000000000000000000000000000000000000;;		if n*len(fss) != len(src) {
0000000000000000000000000000000000000000;;			return errors.New("redigo.ScanSlice: length not a multiple of struct field count")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ensureLen(d, n)
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			d := d.Index(i)
0000000000000000000000000000000000000000;;			if isPtr {
0000000000000000000000000000000000000000;;				if d.IsNil() {
0000000000000000000000000000000000000000;;					d.Set(reflect.New(t))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d = d.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j, fs := range fss {
0000000000000000000000000000000000000000;;				s := src[i*len(fss)+j]
0000000000000000000000000000000000000000;;				if s == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := convertAssignValue(d.FieldByIndex(fs.index), s); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("redigo.ScanSlice: cannot assign element %d to field %s: %v", i*len(fss)+j, fs.name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Args is a helper for constructing command arguments from structured values.
0000000000000000000000000000000000000000;;	type Args []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add returns the result of appending value to args.
0000000000000000000000000000000000000000;;	func (args Args) Add(value ...interface{}) Args {
0000000000000000000000000000000000000000;;		return append(args, value...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlat returns the result of appending the flattened value of v to args.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Maps are flattened by appending the alternating keys and map values to args.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Slices are flattened by appending the slice elements to args.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Structs are flattened by appending the alternating names and values of
0000000000000000000000000000000000000000;;	// exported fields to args. If v is a nil struct pointer, then nothing is
0000000000000000000000000000000000000000;;	// appended. The 'redis' field tag overrides struct field names. See ScanStruct
0000000000000000000000000000000000000000;;	// for more information on the use of the 'redis' field tag.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Other types are appended to args as is.
0000000000000000000000000000000000000000;;	func (args Args) AddFlat(v interface{}) Args {
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(v)
0000000000000000000000000000000000000000;;		switch rv.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			args = flattenStruct(args, rv)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			for i := 0; i < rv.Len(); i++ {
0000000000000000000000000000000000000000;;				args = append(args, rv.Index(i).Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			for _, k := range rv.MapKeys() {
0000000000000000000000000000000000000000;;				args = append(args, k.Interface(), rv.MapIndex(k).Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if rv.Type().Elem().Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;				if !rv.IsNil() {
0000000000000000000000000000000000000000;;					args = flattenStruct(args, rv.Elem())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				args = append(args, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			args = append(args, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flattenStruct(args Args, v reflect.Value) Args {
0000000000000000000000000000000000000000;;		ss := structSpecForType(v.Type())
0000000000000000000000000000000000000000;;		for _, fs := range ss.l {
0000000000000000000000000000000000000000;;			fv := v.FieldByIndex(fs.index)
0000000000000000000000000000000000000000;;			if fs.omitEmpty {
0000000000000000000000000000000000000000;;				var empty = false
0000000000000000000000000000000000000000;;				switch fv.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;					empty = fv.Len() == 0
0000000000000000000000000000000000000000;;				case reflect.Bool:
0000000000000000000000000000000000000000;;					empty = !fv.Bool()
0000000000000000000000000000000000000000;;				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;					empty = fv.Int() == 0
0000000000000000000000000000000000000000;;				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;					empty = fv.Uint() == 0
0000000000000000000000000000000000000000;;				case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;					empty = fv.Float() == 0
0000000000000000000000000000000000000000;;				case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;					empty = fv.IsNil()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if empty {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			args = append(args, fs.name, fv.Interface())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
