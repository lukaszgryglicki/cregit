0000000000000000000000000000000000000000;;	// Copyright 2012 Gary Burd
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/garyburd/redigo/redis/pool.go[Godeps/_workspace/src/github.com/garyburd/redigo/redis/pool.go][vendor/github.com/garyburd/redigo/redis/pool.go];	
0000000000000000000000000000000000000000;;	package redis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/garyburd/redigo/internal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nowFunc = time.Now // for testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrPoolExhausted is returned from a pool connection method (Do, Send,
0000000000000000000000000000000000000000;;	// Receive, Flush, Err) when the maximum number of database connections in the
0000000000000000000000000000000000000000;;	// pool has been reached.
0000000000000000000000000000000000000000;;	var ErrPoolExhausted = errors.New("redigo: connection pool exhausted")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errPoolClosed = errors.New("redigo: connection pool closed")
0000000000000000000000000000000000000000;;		errConnClosed = errors.New("redigo: connection closed")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pool maintains a pool of connections. The application calls the Get method
0000000000000000000000000000000000000000;;	// to get a connection from the pool and the connection's Close method to
0000000000000000000000000000000000000000;;	// return the connection's resources to the pool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following example shows how to use a pool in a web application. The
0000000000000000000000000000000000000000;;	// application creates a pool at application startup and makes it available to
0000000000000000000000000000000000000000;;	// request handlers using a global variable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  func newPool(server, password string) *redis.Pool {
0000000000000000000000000000000000000000;;	//      return &redis.Pool{
0000000000000000000000000000000000000000;;	//          MaxIdle: 3,
0000000000000000000000000000000000000000;;	//          IdleTimeout: 240 * time.Second,
0000000000000000000000000000000000000000;;	//          Dial: func () (redis.Conn, error) {
0000000000000000000000000000000000000000;;	//              c, err := redis.Dial("tcp", server)
0000000000000000000000000000000000000000;;	//              if err != nil {
0000000000000000000000000000000000000000;;	//                  return nil, err
0000000000000000000000000000000000000000;;	//              }
0000000000000000000000000000000000000000;;	//              if _, err := c.Do("AUTH", password); err != nil {
0000000000000000000000000000000000000000;;	//                  c.Close()
0000000000000000000000000000000000000000;;	//                  return nil, err
0000000000000000000000000000000000000000;;	//              }
0000000000000000000000000000000000000000;;	//              return c, err
0000000000000000000000000000000000000000;;	//          },
0000000000000000000000000000000000000000;;	//          TestOnBorrow: func(c redis.Conn, t time.Time) error {
0000000000000000000000000000000000000000;;	//              _, err := c.Do("PING")
0000000000000000000000000000000000000000;;	//              return err
0000000000000000000000000000000000000000;;	//          },
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  var (
0000000000000000000000000000000000000000;;	//      pool *redis.Pool
0000000000000000000000000000000000000000;;	//      redisServer = flag.String("redisServer", ":6379", "")
0000000000000000000000000000000000000000;;	//      redisPassword = flag.String("redisPassword", "", "")
0000000000000000000000000000000000000000;;	//  )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  func main() {
0000000000000000000000000000000000000000;;	//      flag.Parse()
0000000000000000000000000000000000000000;;	//      pool = newPool(*redisServer, *redisPassword)
0000000000000000000000000000000000000000;;	//      ...
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A request handler gets a connection from the pool and closes the connection
0000000000000000000000000000000000000000;;	// when the handler is done:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  func serveHome(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;	//      conn := pool.Get()
0000000000000000000000000000000000000000;;	//      defer conn.Close()
0000000000000000000000000000000000000000;;	//      ....
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Pool struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dial is an application supplied function for creating and configuring a
0000000000000000000000000000000000000000;;		// connection.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The connection returned from Dial must not be in a special state
0000000000000000000000000000000000000000;;		// (subscribed to pubsub channel, transaction started, ...).
0000000000000000000000000000000000000000;;		Dial func() (Conn, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TestOnBorrow is an optional application supplied function for checking
0000000000000000000000000000000000000000;;		// the health of an idle connection before the connection is used again by
0000000000000000000000000000000000000000;;		// the application. Argument t is the time that the connection was returned
0000000000000000000000000000000000000000;;		// to the pool. If the function returns an error, then the connection is
0000000000000000000000000000000000000000;;		// closed.
0000000000000000000000000000000000000000;;		TestOnBorrow func(c Conn, t time.Time) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum number of idle connections in the pool.
0000000000000000000000000000000000000000;;		MaxIdle int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum number of connections allocated by the pool at a given time.
0000000000000000000000000000000000000000;;		// When zero, there is no limit on the number of connections in the pool.
0000000000000000000000000000000000000000;;		MaxActive int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close connections after remaining idle for this duration. If the value
0000000000000000000000000000000000000000;;		// is zero, then idle connections are not closed. Applications should set
0000000000000000000000000000000000000000;;		// the timeout to a value less than the server's timeout.
0000000000000000000000000000000000000000;;		IdleTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If Wait is true and the pool is at the MaxActive limit, then Get() waits
0000000000000000000000000000000000000000;;		// for a connection to be returned to the pool before returning.
0000000000000000000000000000000000000000;;		Wait bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects fields defined below.
0000000000000000000000000000000000000000;;		mu     sync.Mutex
0000000000000000000000000000000000000000;;		cond   *sync.Cond
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;		active int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stack of idleConn with most recently used at the front.
0000000000000000000000000000000000000000;;		idle list.List
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type idleConn struct {
0000000000000000000000000000000000000000;;		c Conn
0000000000000000000000000000000000000000;;		t time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPool creates a new pool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: Initialize the Pool directory as shown in the example.
0000000000000000000000000000000000000000;;	func NewPool(newFn func() (Conn, error), maxIdle int) *Pool {
0000000000000000000000000000000000000000;;		return &Pool{Dial: newFn, MaxIdle: maxIdle}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get gets a connection. The application must close the returned connection.
0000000000000000000000000000000000000000;;	// This method always returns a valid connection so that applications can defer
0000000000000000000000000000000000000000;;	// error handling to the first use of the connection. If there is an error
0000000000000000000000000000000000000000;;	// getting an underlying connection, then the connection Err, Do, Send, Flush
0000000000000000000000000000000000000000;;	// and Receive methods return that error.
0000000000000000000000000000000000000000;;	func (p *Pool) Get() Conn {
0000000000000000000000000000000000000000;;		c, err := p.get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return errorConnection{err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &pooledConnection{p: p, c: c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActiveCount returns the number of active connections in the pool.
0000000000000000000000000000000000000000;;	func (p *Pool) ActiveCount() int {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		active := p.active
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;		return active
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close releases the resources used by the pool.
0000000000000000000000000000000000000000;;	func (p *Pool) Close() error {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		idle := p.idle
0000000000000000000000000000000000000000;;		p.idle.Init()
0000000000000000000000000000000000000000;;		p.closed = true
0000000000000000000000000000000000000000;;		p.active -= idle.Len()
0000000000000000000000000000000000000000;;		if p.cond != nil {
0000000000000000000000000000000000000000;;			p.cond.Broadcast()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;		for e := idle.Front(); e != nil; e = e.Next() {
0000000000000000000000000000000000000000;;			e.Value.(idleConn).c.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// release decrements the active count and signals waiters. The caller must
0000000000000000000000000000000000000000;;	// hold p.mu during the call.
0000000000000000000000000000000000000000;;	func (p *Pool) release() {
0000000000000000000000000000000000000000;;		p.active -= 1
0000000000000000000000000000000000000000;;		if p.cond != nil {
0000000000000000000000000000000000000000;;			p.cond.Signal()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get prunes stale connections and returns a connection from the idle list or
0000000000000000000000000000000000000000;;	// creates a new connection.
0000000000000000000000000000000000000000;;	func (p *Pool) get() (Conn, error) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prune stale connections.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if timeout := p.IdleTimeout; timeout > 0 {
0000000000000000000000000000000000000000;;			for i, n := 0, p.idle.Len(); i < n; i++ {
0000000000000000000000000000000000000000;;				e := p.idle.Back()
0000000000000000000000000000000000000000;;				if e == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ic := e.Value.(idleConn)
0000000000000000000000000000000000000000;;				if ic.t.Add(timeout).After(nowFunc()) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.idle.Remove(e)
0000000000000000000000000000000000000000;;				p.release()
0000000000000000000000000000000000000000;;				p.mu.Unlock()
0000000000000000000000000000000000000000;;				ic.c.Close()
0000000000000000000000000000000000000000;;				p.mu.Lock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get idle connection.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, n := 0, p.idle.Len(); i < n; i++ {
0000000000000000000000000000000000000000;;				e := p.idle.Front()
0000000000000000000000000000000000000000;;				if e == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ic := e.Value.(idleConn)
0000000000000000000000000000000000000000;;				p.idle.Remove(e)
0000000000000000000000000000000000000000;;				test := p.TestOnBorrow
0000000000000000000000000000000000000000;;				p.mu.Unlock()
0000000000000000000000000000000000000000;;				if test == nil || test(ic.c, ic.t) == nil {
0000000000000000000000000000000000000000;;					return ic.c, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ic.c.Close()
0000000000000000000000000000000000000000;;				p.mu.Lock()
0000000000000000000000000000000000000000;;				p.release()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for pool closed before dialing a new connection.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.closed {
0000000000000000000000000000000000000000;;				p.mu.Unlock()
0000000000000000000000000000000000000000;;				return nil, errors.New("redigo: get on closed pool")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Dial new connection if under limit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.MaxActive == 0 || p.active < p.MaxActive {
0000000000000000000000000000000000000000;;				dial := p.Dial
0000000000000000000000000000000000000000;;				p.active += 1
0000000000000000000000000000000000000000;;				p.mu.Unlock()
0000000000000000000000000000000000000000;;				c, err := dial()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					p.mu.Lock()
0000000000000000000000000000000000000000;;					p.release()
0000000000000000000000000000000000000000;;					p.mu.Unlock()
0000000000000000000000000000000000000000;;					c = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return c, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !p.Wait {
0000000000000000000000000000000000000000;;				p.mu.Unlock()
0000000000000000000000000000000000000000;;				return nil, ErrPoolExhausted
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.cond == nil {
0000000000000000000000000000000000000000;;				p.cond = sync.NewCond(&p.mu)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Pool) put(c Conn, forceClose bool) error {
0000000000000000000000000000000000000000;;		err := c.Err()
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		if !p.closed && err == nil && !forceClose {
0000000000000000000000000000000000000000;;			p.idle.PushFront(idleConn{t: nowFunc(), c: c})
0000000000000000000000000000000000000000;;			if p.idle.Len() > p.MaxIdle {
0000000000000000000000000000000000000000;;				c = p.idle.Remove(p.idle.Back()).(idleConn).c
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			if p.cond != nil {
0000000000000000000000000000000000000000;;				p.cond.Signal()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.release()
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;		return c.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pooledConnection struct {
0000000000000000000000000000000000000000;;		p     *Pool
0000000000000000000000000000000000000000;;		c     Conn
0000000000000000000000000000000000000000;;		state int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		sentinel     []byte
0000000000000000000000000000000000000000;;		sentinelOnce sync.Once
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initSentinel() {
0000000000000000000000000000000000000000;;		p := make([]byte, 64)
0000000000000000000000000000000000000000;;		if _, err := rand.Read(p); err == nil {
0000000000000000000000000000000000000000;;			sentinel = p
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			h := sha1.New()
0000000000000000000000000000000000000000;;			io.WriteString(h, "Oops, rand failed. Use time instead.")
0000000000000000000000000000000000000000;;			io.WriteString(h, strconv.FormatInt(time.Now().UnixNano(), 10))
0000000000000000000000000000000000000000;;			sentinel = h.Sum(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *pooledConnection) Close() error {
0000000000000000000000000000000000000000;;		c := pc.c
0000000000000000000000000000000000000000;;		if _, ok := c.(errorConnection); ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pc.c = errorConnection{errConnClosed}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pc.state&internal.MultiState != 0 {
0000000000000000000000000000000000000000;;			c.Send("DISCARD")
0000000000000000000000000000000000000000;;			pc.state &^= (internal.MultiState | internal.WatchState)
0000000000000000000000000000000000000000;;		} else if pc.state&internal.WatchState != 0 {
0000000000000000000000000000000000000000;;			c.Send("UNWATCH")
0000000000000000000000000000000000000000;;			pc.state &^= internal.WatchState
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pc.state&internal.SubscribeState != 0 {
0000000000000000000000000000000000000000;;			c.Send("UNSUBSCRIBE")
0000000000000000000000000000000000000000;;			c.Send("PUNSUBSCRIBE")
0000000000000000000000000000000000000000;;			// To detect the end of the message stream, ask the server to echo
0000000000000000000000000000000000000000;;			// a sentinel value and read until we see that value.
0000000000000000000000000000000000000000;;			sentinelOnce.Do(initSentinel)
0000000000000000000000000000000000000000;;			c.Send("ECHO", sentinel)
0000000000000000000000000000000000000000;;			c.Flush()
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				p, err := c.Receive()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p, ok := p.([]byte); ok && bytes.Equal(p, sentinel) {
0000000000000000000000000000000000000000;;					pc.state &^= internal.SubscribeState
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Do("")
0000000000000000000000000000000000000000;;		pc.p.put(c, pc.state != 0)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *pooledConnection) Err() error {
0000000000000000000000000000000000000000;;		return pc.c.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *pooledConnection) Do(commandName string, args ...interface{}) (reply interface{}, err error) {
0000000000000000000000000000000000000000;;		ci := internal.LookupCommandInfo(commandName)
0000000000000000000000000000000000000000;;		pc.state = (pc.state | ci.Set) &^ ci.Clear
0000000000000000000000000000000000000000;;		return pc.c.Do(commandName, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *pooledConnection) Send(commandName string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		ci := internal.LookupCommandInfo(commandName)
0000000000000000000000000000000000000000;;		pc.state = (pc.state | ci.Set) &^ ci.Clear
0000000000000000000000000000000000000000;;		return pc.c.Send(commandName, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *pooledConnection) Flush() error {
0000000000000000000000000000000000000000;;		return pc.c.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *pooledConnection) Receive() (reply interface{}, err error) {
0000000000000000000000000000000000000000;;		return pc.c.Receive()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorConnection struct{ err error }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ec errorConnection) Do(string, ...interface{}) (interface{}, error) { return nil, ec.err }
0000000000000000000000000000000000000000;;	func (ec errorConnection) Send(string, ...interface{}) error              { return ec.err }
0000000000000000000000000000000000000000;;	func (ec errorConnection) Err() error                                     { return ec.err }
0000000000000000000000000000000000000000;;	func (ec errorConnection) Close() error                                   { return ec.err }
0000000000000000000000000000000000000000;;	func (ec errorConnection) Flush() error                                   { return ec.err }
0000000000000000000000000000000000000000;;	func (ec errorConnection) Receive() (interface{}, error)                  { return nil, ec.err }
