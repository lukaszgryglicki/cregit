0000000000000000000000000000000000000000;;	// Copyright 2012 Gary Burd
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/garyburd/redigo/redis/conn.go[Godeps/_workspace/src/github.com/garyburd/redigo/redis/conn.go][vendor/github.com/garyburd/redigo/redis/conn.go];	
0000000000000000000000000000000000000000;;	package redis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// conn is the low-level implementation of Conn
0000000000000000000000000000000000000000;;	type conn struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Shared
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		pending int
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;		conn    net.Conn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read
0000000000000000000000000000000000000000;;		readTimeout time.Duration
0000000000000000000000000000000000000000;;		br          *bufio.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write
0000000000000000000000000000000000000000;;		writeTimeout time.Duration
0000000000000000000000000000000000000000;;		bw           *bufio.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scratch space for formatting argument length.
0000000000000000000000000000000000000000;;		// '*' or '$', length, "\r\n"
0000000000000000000000000000000000000000;;		lenScratch [32]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scratch space for formatting integers and floats.
0000000000000000000000000000000000000000;;		numScratch [40]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialTimeout acts like Dial but takes timeouts for establishing the
0000000000000000000000000000000000000000;;	// connection to the server, writing a command and reading a reply.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: Use Dial with options instead.
0000000000000000000000000000000000000000;;	func DialTimeout(network, address string, connectTimeout, readTimeout, writeTimeout time.Duration) (Conn, error) {
0000000000000000000000000000000000000000;;		return Dial(network, address,
0000000000000000000000000000000000000000;;			DialConnectTimeout(connectTimeout),
0000000000000000000000000000000000000000;;			DialReadTimeout(readTimeout),
0000000000000000000000000000000000000000;;			DialWriteTimeout(writeTimeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialOption specifies an option for dialing a Redis server.
0000000000000000000000000000000000000000;;	type DialOption struct {
0000000000000000000000000000000000000000;;		f func(*dialOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dialOptions struct {
0000000000000000000000000000000000000000;;		readTimeout  time.Duration
0000000000000000000000000000000000000000;;		writeTimeout time.Duration
0000000000000000000000000000000000000000;;		dial         func(network, addr string) (net.Conn, error)
0000000000000000000000000000000000000000;;		db           int
0000000000000000000000000000000000000000;;		password     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialReadTimeout specifies the timeout for reading a single command reply.
0000000000000000000000000000000000000000;;	func DialReadTimeout(d time.Duration) DialOption {
0000000000000000000000000000000000000000;;		return DialOption{func(do *dialOptions) {
0000000000000000000000000000000000000000;;			do.readTimeout = d
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialWriteTimeout specifies the timeout for writing a single command.
0000000000000000000000000000000000000000;;	func DialWriteTimeout(d time.Duration) DialOption {
0000000000000000000000000000000000000000;;		return DialOption{func(do *dialOptions) {
0000000000000000000000000000000000000000;;			do.writeTimeout = d
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialConnectTimeout specifies the timeout for connecting to the Redis server.
0000000000000000000000000000000000000000;;	func DialConnectTimeout(d time.Duration) DialOption {
0000000000000000000000000000000000000000;;		return DialOption{func(do *dialOptions) {
0000000000000000000000000000000000000000;;			dialer := net.Dialer{Timeout: d}
0000000000000000000000000000000000000000;;			do.dial = dialer.Dial
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialNetDial specifies a custom dial function for creating TCP
0000000000000000000000000000000000000000;;	// connections. If this option is left out, then net.Dial is
0000000000000000000000000000000000000000;;	// used. DialNetDial overrides DialConnectTimeout.
0000000000000000000000000000000000000000;;	func DialNetDial(dial func(network, addr string) (net.Conn, error)) DialOption {
0000000000000000000000000000000000000000;;		return DialOption{func(do *dialOptions) {
0000000000000000000000000000000000000000;;			do.dial = dial
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialDatabase specifies the database to select when dialing a connection.
0000000000000000000000000000000000000000;;	func DialDatabase(db int) DialOption {
0000000000000000000000000000000000000000;;		return DialOption{func(do *dialOptions) {
0000000000000000000000000000000000000000;;			do.db = db
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialPassword specifies the password to use when connecting to
0000000000000000000000000000000000000000;;	// the Redis server.
0000000000000000000000000000000000000000;;	func DialPassword(password string) DialOption {
0000000000000000000000000000000000000000;;		return DialOption{func(do *dialOptions) {
0000000000000000000000000000000000000000;;			do.password = password
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial connects to the Redis server at the given network and
0000000000000000000000000000000000000000;;	// address using the specified options.
0000000000000000000000000000000000000000;;	func Dial(network, address string, options ...DialOption) (Conn, error) {
0000000000000000000000000000000000000000;;		do := dialOptions{
0000000000000000000000000000000000000000;;			dial: net.Dial,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			option.f(&do)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netConn, err := do.dial(network, address)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &conn{
0000000000000000000000000000000000000000;;			conn:         netConn,
0000000000000000000000000000000000000000;;			bw:           bufio.NewWriter(netConn),
0000000000000000000000000000000000000000;;			br:           bufio.NewReader(netConn),
0000000000000000000000000000000000000000;;			readTimeout:  do.readTimeout,
0000000000000000000000000000000000000000;;			writeTimeout: do.writeTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if do.password != "" {
0000000000000000000000000000000000000000;;			if _, err := c.Do("AUTH", do.password); err != nil {
0000000000000000000000000000000000000000;;				netConn.Close()
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if do.db != 0 {
0000000000000000000000000000000000000000;;			if _, err := c.Do("SELECT", do.db); err != nil {
0000000000000000000000000000000000000000;;				netConn.Close()
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var pathDBRegexp = regexp.MustCompile(`/(\d*)\z`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialURL connects to a Redis server at the given URL using the Redis
0000000000000000000000000000000000000000;;	// URI scheme. URLs should follow the draft IANA specification for the
0000000000000000000000000000000000000000;;	// scheme (https://www.iana.org/assignments/uri-schemes/prov/redis).
0000000000000000000000000000000000000000;;	func DialURL(rawurl string, options ...DialOption) (Conn, error) {
0000000000000000000000000000000000000000;;		u, err := url.Parse(rawurl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.Scheme != "redis" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid redis URL scheme: %s", u.Scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// As per the IANA draft spec, the host defaults to localhost and
0000000000000000000000000000000000000000;;		// the port defaults to 6379.
0000000000000000000000000000000000000000;;		host, port, err := net.SplitHostPort(u.Host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// assume port is missing
0000000000000000000000000000000000000000;;			host = u.Host
0000000000000000000000000000000000000000;;			port = "6379"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if host == "" {
0000000000000000000000000000000000000000;;			host = "localhost"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		address := net.JoinHostPort(host, port)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.User != nil {
0000000000000000000000000000000000000000;;			password, isSet := u.User.Password()
0000000000000000000000000000000000000000;;			if isSet {
0000000000000000000000000000000000000000;;				options = append(options, DialPassword(password))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match := pathDBRegexp.FindStringSubmatch(u.Path)
0000000000000000000000000000000000000000;;		if len(match) == 2 {
0000000000000000000000000000000000000000;;			db := 0
0000000000000000000000000000000000000000;;			if len(match[1]) > 0 {
0000000000000000000000000000000000000000;;				db, err = strconv.Atoi(match[1])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("invalid database: %s", u.Path[1:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if db != 0 {
0000000000000000000000000000000000000000;;				options = append(options, DialDatabase(db))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if u.Path != "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid database: %s", u.Path[1:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Dial("tcp", address, options...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConn returns a new Redigo connection for the given net connection.
0000000000000000000000000000000000000000;;	func NewConn(netConn net.Conn, readTimeout, writeTimeout time.Duration) Conn {
0000000000000000000000000000000000000000;;		return &conn{
0000000000000000000000000000000000000000;;			conn:         netConn,
0000000000000000000000000000000000000000;;			bw:           bufio.NewWriter(netConn),
0000000000000000000000000000000000000000;;			br:           bufio.NewReader(netConn),
0000000000000000000000000000000000000000;;			readTimeout:  readTimeout,
0000000000000000000000000000000000000000;;			writeTimeout: writeTimeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) Close() error {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		err := c.err
0000000000000000000000000000000000000000;;		if c.err == nil {
0000000000000000000000000000000000000000;;			c.err = errors.New("redigo: closed")
0000000000000000000000000000000000000000;;			err = c.conn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) fatal(err error) error {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		if c.err == nil {
0000000000000000000000000000000000000000;;			c.err = err
0000000000000000000000000000000000000000;;			// Close connection to force errors on subsequent calls and to unblock
0000000000000000000000000000000000000000;;			// other reader or writer.
0000000000000000000000000000000000000000;;			c.conn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) Err() error {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		err := c.err
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) writeLen(prefix byte, n int) error {
0000000000000000000000000000000000000000;;		c.lenScratch[len(c.lenScratch)-1] = '\n'
0000000000000000000000000000000000000000;;		c.lenScratch[len(c.lenScratch)-2] = '\r'
0000000000000000000000000000000000000000;;		i := len(c.lenScratch) - 3
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c.lenScratch[i] = byte('0' + n%10)
0000000000000000000000000000000000000000;;			i -= 1
0000000000000000000000000000000000000000;;			n = n / 10
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.lenScratch[i] = prefix
0000000000000000000000000000000000000000;;		_, err := c.bw.Write(c.lenScratch[i:])
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) writeString(s string) error {
0000000000000000000000000000000000000000;;		c.writeLen('$', len(s))
0000000000000000000000000000000000000000;;		c.bw.WriteString(s)
0000000000000000000000000000000000000000;;		_, err := c.bw.WriteString("\r\n")
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) writeBytes(p []byte) error {
0000000000000000000000000000000000000000;;		c.writeLen('$', len(p))
0000000000000000000000000000000000000000;;		c.bw.Write(p)
0000000000000000000000000000000000000000;;		_, err := c.bw.WriteString("\r\n")
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) writeInt64(n int64) error {
0000000000000000000000000000000000000000;;		return c.writeBytes(strconv.AppendInt(c.numScratch[:0], n, 10))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) writeFloat64(n float64) error {
0000000000000000000000000000000000000000;;		return c.writeBytes(strconv.AppendFloat(c.numScratch[:0], n, 'g', -1, 64))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) writeCommand(cmd string, args []interface{}) (err error) {
0000000000000000000000000000000000000000;;		c.writeLen('*', 1+len(args))
0000000000000000000000000000000000000000;;		err = c.writeString(cmd)
0000000000000000000000000000000000000000;;		for _, arg := range args {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch arg := arg.(type) {
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				err = c.writeString(arg)
0000000000000000000000000000000000000000;;			case []byte:
0000000000000000000000000000000000000000;;				err = c.writeBytes(arg)
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				err = c.writeInt64(int64(arg))
0000000000000000000000000000000000000000;;			case int64:
0000000000000000000000000000000000000000;;				err = c.writeInt64(arg)
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				err = c.writeFloat64(arg)
0000000000000000000000000000000000000000;;			case bool:
0000000000000000000000000000000000000000;;				if arg {
0000000000000000000000000000000000000000;;					err = c.writeString("1")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = c.writeString("0")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				err = c.writeString("")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				var buf bytes.Buffer
0000000000000000000000000000000000000000;;				fmt.Fprint(&buf, arg)
0000000000000000000000000000000000000000;;				err = c.writeBytes(buf.Bytes())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type protocolError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pe protocolError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("redigo: %s (possible server error or unsupported concurrent read by application)", string(pe))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) readLine() ([]byte, error) {
0000000000000000000000000000000000000000;;		p, err := c.br.ReadSlice('\n')
0000000000000000000000000000000000000000;;		if err == bufio.ErrBufferFull {
0000000000000000000000000000000000000000;;			return nil, protocolError("long response line")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := len(p) - 2
0000000000000000000000000000000000000000;;		if i < 0 || p[i] != '\r' {
0000000000000000000000000000000000000000;;			return nil, protocolError("bad response line terminator")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p[:i], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseLen parses bulk string and array lengths.
0000000000000000000000000000000000000000;;	func parseLen(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return -1, protocolError("malformed length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p[0] == '-' && len(p) == 2 && p[1] == '1' {
0000000000000000000000000000000000000000;;			// handle $-1 and $-1 null replies.
0000000000000000000000000000000000000000;;			return -1, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		for _, b := range p {
0000000000000000000000000000000000000000;;			n *= 10
0000000000000000000000000000000000000000;;			if b < '0' || b > '9' {
0000000000000000000000000000000000000000;;				return -1, protocolError("illegal bytes in length")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += int(b - '0')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseInt parses an integer reply.
0000000000000000000000000000000000000000;;	func parseInt(p []byte) (interface{}, error) {
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return 0, protocolError("malformed integer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var negate bool
0000000000000000000000000000000000000000;;		if p[0] == '-' {
0000000000000000000000000000000000000000;;			negate = true
0000000000000000000000000000000000000000;;			p = p[1:]
0000000000000000000000000000000000000000;;			if len(p) == 0 {
0000000000000000000000000000000000000000;;				return 0, protocolError("malformed integer")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var n int64
0000000000000000000000000000000000000000;;		for _, b := range p {
0000000000000000000000000000000000000000;;			n *= 10
0000000000000000000000000000000000000000;;			if b < '0' || b > '9' {
0000000000000000000000000000000000000000;;				return 0, protocolError("illegal bytes in length")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += int64(b - '0')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if negate {
0000000000000000000000000000000000000000;;			n = -n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		okReply   interface{} = "OK"
0000000000000000000000000000000000000000;;		pongReply interface{} = "PONG"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) readReply() (interface{}, error) {
0000000000000000000000000000000000000000;;		line, err := c.readLine()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(line) == 0 {
0000000000000000000000000000000000000000;;			return nil, protocolError("short response line")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch line[0] {
0000000000000000000000000000000000000000;;		case '+':
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case len(line) == 3 && line[1] == 'O' && line[2] == 'K':
0000000000000000000000000000000000000000;;				// Avoid allocation for frequent "+OK" response.
0000000000000000000000000000000000000000;;				return okReply, nil
0000000000000000000000000000000000000000;;			case len(line) == 5 && line[1] == 'P' && line[2] == 'O' && line[3] == 'N' && line[4] == 'G':
0000000000000000000000000000000000000000;;				// Avoid allocation in PING command benchmarks :)
0000000000000000000000000000000000000000;;				return pongReply, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return string(line[1:]), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			return Error(string(line[1:])), nil
0000000000000000000000000000000000000000;;		case ':':
0000000000000000000000000000000000000000;;			return parseInt(line[1:])
0000000000000000000000000000000000000000;;		case '$':
0000000000000000000000000000000000000000;;			n, err := parseLen(line[1:])
0000000000000000000000000000000000000000;;			if n < 0 || err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p := make([]byte, n)
0000000000000000000000000000000000000000;;			_, err = io.ReadFull(c.br, p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if line, err := c.readLine(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			} else if len(line) != 0 {
0000000000000000000000000000000000000000;;				return nil, protocolError("bad bulk string format")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		case '*':
0000000000000000000000000000000000000000;;			n, err := parseLen(line[1:])
0000000000000000000000000000000000000000;;			if n < 0 || err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r := make([]interface{}, n)
0000000000000000000000000000000000000000;;			for i := range r {
0000000000000000000000000000000000000000;;				r[i], err = c.readReply()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return r, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, protocolError("unexpected response line")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) Send(cmd string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		c.pending += 1
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;		if c.writeTimeout != 0 {
0000000000000000000000000000000000000000;;			c.conn.SetWriteDeadline(time.Now().Add(c.writeTimeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.writeCommand(cmd, args); err != nil {
0000000000000000000000000000000000000000;;			return c.fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) Flush() error {
0000000000000000000000000000000000000000;;		if c.writeTimeout != 0 {
0000000000000000000000000000000000000000;;			c.conn.SetWriteDeadline(time.Now().Add(c.writeTimeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.bw.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return c.fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) Receive() (reply interface{}, err error) {
0000000000000000000000000000000000000000;;		if c.readTimeout != 0 {
0000000000000000000000000000000000000000;;			c.conn.SetReadDeadline(time.Now().Add(c.readTimeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if reply, err = c.readReply(); err != nil {
0000000000000000000000000000000000000000;;			return nil, c.fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// When using pub/sub, the number of receives can be greater than the
0000000000000000000000000000000000000000;;		// number of sends. To enable normal use of the connection after
0000000000000000000000000000000000000000;;		// unsubscribing from all channels, we do not decrement pending to a
0000000000000000000000000000000000000000;;		// negative value.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The pending field is decremented after the reply is read to handle the
0000000000000000000000000000000000000000;;		// case where Receive is called before Send.
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		if c.pending > 0 {
0000000000000000000000000000000000000000;;			c.pending -= 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;		if err, ok := reply.(Error); ok {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) Do(cmd string, args ...interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		pending := c.pending
0000000000000000000000000000000000000000;;		c.pending = 0
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmd == "" && pending == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.writeTimeout != 0 {
0000000000000000000000000000000000000000;;			c.conn.SetWriteDeadline(time.Now().Add(c.writeTimeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmd != "" {
0000000000000000000000000000000000000000;;			if err := c.writeCommand(cmd, args); err != nil {
0000000000000000000000000000000000000000;;				return nil, c.fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.bw.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return nil, c.fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.readTimeout != 0 {
0000000000000000000000000000000000000000;;			c.conn.SetReadDeadline(time.Now().Add(c.readTimeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cmd == "" {
0000000000000000000000000000000000000000;;			reply := make([]interface{}, pending)
0000000000000000000000000000000000000000;;			for i := range reply {
0000000000000000000000000000000000000000;;				r, e := c.readReply()
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					return nil, c.fatal(e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				reply[i] = r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return reply, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var reply interface{}
0000000000000000000000000000000000000000;;		for i := 0; i <= pending; i++ {
0000000000000000000000000000000000000000;;			var e error
0000000000000000000000000000000000000000;;			if reply, e = c.readReply(); e != nil {
0000000000000000000000000000000000000000;;				return nil, c.fatal(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, ok := reply.(Error); ok && err == nil {
0000000000000000000000000000000000000000;;				err = e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reply, err
0000000000000000000000000000000000000000;;	}
