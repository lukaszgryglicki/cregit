0000000000000000000000000000000000000000;;	// Copyright 2012 Gary Burd
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License"): you may
0000000000000000000000000000000000000000;;	// not use this file except in compliance with the License. You may obtain
0000000000000000000000000000000000000000;;	// a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
0000000000000000000000000000000000000000;;	// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
0000000000000000000000000000000000000000;;	// License for the specific language governing permissions and limitations
0000000000000000000000000000000000000000;;	// under the License.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/garyburd/redigo/redis/log.go[Godeps/_workspace/src/github.com/garyburd/redigo/redis/log.go][vendor/github.com/garyburd/redigo/redis/log.go];	
0000000000000000000000000000000000000000;;	package redis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLoggingConn returns a logging wrapper around a connection.
0000000000000000000000000000000000000000;;	func NewLoggingConn(conn Conn, logger *log.Logger, prefix string) Conn {
0000000000000000000000000000000000000000;;		if prefix != "" {
0000000000000000000000000000000000000000;;			prefix = prefix + "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &loggingConn{conn, logger, prefix}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type loggingConn struct {
0000000000000000000000000000000000000000;;		Conn
0000000000000000000000000000000000000000;;		logger *log.Logger
0000000000000000000000000000000000000000;;		prefix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *loggingConn) Close() error {
0000000000000000000000000000000000000000;;		err := c.Conn.Close()
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "%sClose() -> (%v)", c.prefix, err)
0000000000000000000000000000000000000000;;		c.logger.Output(2, buf.String())
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *loggingConn) printValue(buf *bytes.Buffer, v interface{}) {
0000000000000000000000000000000000000000;;		const chop = 32
0000000000000000000000000000000000000000;;		switch v := v.(type) {
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			if len(v) > chop {
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "%q...", v[:chop])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "%q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			if len(v) > chop {
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "%q...", v[:chop])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "%q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			if len(v) == 0 {
0000000000000000000000000000000000000000;;				buf.WriteString("[]")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sep := "["
0000000000000000000000000000000000000000;;				fin := "]"
0000000000000000000000000000000000000000;;				if len(v) > chop {
0000000000000000000000000000000000000000;;					v = v[:chop]
0000000000000000000000000000000000000000;;					fin = "...]"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, vv := range v {
0000000000000000000000000000000000000000;;					buf.WriteString(sep)
0000000000000000000000000000000000000000;;					c.printValue(buf, vv)
0000000000000000000000000000000000000000;;					sep = ", "
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteString(fin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			fmt.Fprint(buf, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *loggingConn) print(method, commandName string, args []interface{}, reply interface{}, err error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "%s%s(", c.prefix, method)
0000000000000000000000000000000000000000;;		if method != "Receive" {
0000000000000000000000000000000000000000;;			buf.WriteString(commandName)
0000000000000000000000000000000000000000;;			for _, arg := range args {
0000000000000000000000000000000000000000;;				buf.WriteString(", ")
0000000000000000000000000000000000000000;;				c.printValue(&buf, arg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteString(") -> (")
0000000000000000000000000000000000000000;;		if method != "Send" {
0000000000000000000000000000000000000000;;			c.printValue(&buf, reply)
0000000000000000000000000000000000000000;;			buf.WriteString(", ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "%v)", err)
0000000000000000000000000000000000000000;;		c.logger.Output(3, buf.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *loggingConn) Do(commandName string, args ...interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		reply, err := c.Conn.Do(commandName, args...)
0000000000000000000000000000000000000000;;		c.print("Do", commandName, args, reply, err)
0000000000000000000000000000000000000000;;		return reply, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *loggingConn) Send(commandName string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		err := c.Conn.Send(commandName, args...)
0000000000000000000000000000000000000000;;		c.print("Send", commandName, args, nil, err)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *loggingConn) Receive() (interface{}, error) {
0000000000000000000000000000000000000000;;		reply, err := c.Conn.Receive()
0000000000000000000000000000000000000000;;		c.print("Receive", "", nil, reply, err)
0000000000000000000000000000000000000000;;		return reply, err
0000000000000000000000000000000000000000;;	}
