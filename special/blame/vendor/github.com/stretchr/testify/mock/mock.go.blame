0000000000000000000000000000000000000000;;	package mock
1a94c3b20410978e7ed06e2ef4fda76273f848ff;third_party/src/github.com/stretchr/testify/mock/mock.go[third_party/src/github.com/stretchr/testify/mock/mock.go][vendor/github.com/stretchr/testify/mock/mock.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/objx"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestingT is an interface wrapper around *testing.T
0000000000000000000000000000000000000000;;	type TestingT interface {
0000000000000000000000000000000000000000;;		Logf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Errorf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Call
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call represents a method call and is used for setting expectations,
0000000000000000000000000000000000000000;;	// as well as recording activity.
0000000000000000000000000000000000000000;;	type Call struct {
0000000000000000000000000000000000000000;;		Parent *Mock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The name of the method that was or will be called.
0000000000000000000000000000000000000000;;		Method string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Holds the arguments of the method.
0000000000000000000000000000000000000000;;		Arguments Arguments
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Holds the arguments that should be returned when
0000000000000000000000000000000000000000;;		// this method is called.
0000000000000000000000000000000000000000;;		ReturnArguments Arguments
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of times to return the return arguments when setting
0000000000000000000000000000000000000000;;		// expectations. 0 means to always return the value.
0000000000000000000000000000000000000000;;		Repeatability int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Holds a channel that will be used to block the Return until it either
0000000000000000000000000000000000000000;;		// recieves a message or is closed. nil means it returns immediately.
0000000000000000000000000000000000000000;;		WaitFor <-chan time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Holds a handler used to manipulate arguments content that are passed by
0000000000000000000000000000000000000000;;		// reference. It's useful when mocking methods such as unmarshalers or
0000000000000000000000000000000000000000;;		// decoders.
0000000000000000000000000000000000000000;;		RunFn func(Arguments)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCall(parent *Mock, methodName string, methodArguments ...interface{}) *Call {
0000000000000000000000000000000000000000;;		return &Call{
0000000000000000000000000000000000000000;;			Parent:          parent,
0000000000000000000000000000000000000000;;			Method:          methodName,
0000000000000000000000000000000000000000;;			Arguments:       methodArguments,
0000000000000000000000000000000000000000;;			ReturnArguments: make([]interface{}, 0),
0000000000000000000000000000000000000000;;			Repeatability:   0,
0000000000000000000000000000000000000000;;			WaitFor:         nil,
0000000000000000000000000000000000000000;;			RunFn:           nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Call) lock() {
0000000000000000000000000000000000000000;;		self.Parent.mutex.Lock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Call) unlock() {
0000000000000000000000000000000000000000;;		self.Parent.mutex.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Call) Return(returnArguments ...interface{}) *Call {
0000000000000000000000000000000000000000;;		self.lock()
0000000000000000000000000000000000000000;;		defer self.unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		self.ReturnArguments = returnArguments
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return self
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Once indicates that that the mock should only return the value once.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Mock.On("MyMethod", arg1, arg2).Return(returnArg1, returnArg2).Once()
0000000000000000000000000000000000000000;;	func (self *Call) Once() *Call {
0000000000000000000000000000000000000000;;		return self.Times(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Twice indicates that that the mock should only return the value twice.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Mock.On("MyMethod", arg1, arg2).Return(returnArg1, returnArg2).Twice()
0000000000000000000000000000000000000000;;	func (self *Call) Twice() *Call {
0000000000000000000000000000000000000000;;		return self.Times(2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Times indicates that that the mock should only return the indicated number
0000000000000000000000000000000000000000;;	// of times.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Mock.On("MyMethod", arg1, arg2).Return(returnArg1, returnArg2).Times(5)
0000000000000000000000000000000000000000;;	func (self *Call) Times(i int) *Call {
0000000000000000000000000000000000000000;;		self.lock()
0000000000000000000000000000000000000000;;		defer self.unlock()
0000000000000000000000000000000000000000;;		self.Repeatability = i
0000000000000000000000000000000000000000;;		return self
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntil sets the channel that will block the mock's return until its closed
0000000000000000000000000000000000000000;;	// or a message is received.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Mock.On("MyMethod", arg1, arg2).WaitUntil(time.After(time.Second))
0000000000000000000000000000000000000000;;	func (self *Call) WaitUntil(w <-chan time.Time) *Call {
0000000000000000000000000000000000000000;;		self.lock()
0000000000000000000000000000000000000000;;		defer self.unlock()
0000000000000000000000000000000000000000;;		self.WaitFor = w
0000000000000000000000000000000000000000;;		return self
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// After sets how long to block until the call returns
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Mock.On("MyMethod", arg1, arg2).After(time.Second)
0000000000000000000000000000000000000000;;	func (self *Call) After(d time.Duration) *Call {
0000000000000000000000000000000000000000;;		return self.WaitUntil(time.After(d))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run sets a handler to be called before returning. It can be used when
0000000000000000000000000000000000000000;;	// mocking a method such as unmarshalers that takes a pointer to a struct and
0000000000000000000000000000000000000000;;	// sets properties in such struct
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Mock.On("Unmarshal", AnythingOfType("*map[string]interface{}").Return().Run(function(args Arguments) {
0000000000000000000000000000000000000000;;	//    	arg := args.Get(0).(*map[string]interface{})
0000000000000000000000000000000000000000;;	//    	arg["foo"] = "bar"
0000000000000000000000000000000000000000;;	//    })
0000000000000000000000000000000000000000;;	func (self *Call) Run(fn func(Arguments)) *Call {
0000000000000000000000000000000000000000;;		self.lock()
0000000000000000000000000000000000000000;;		defer self.unlock()
0000000000000000000000000000000000000000;;		self.RunFn = fn
0000000000000000000000000000000000000000;;		return self
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// On chains a new expectation description onto the mocked interface. This
0000000000000000000000000000000000000000;;	// allows syntax like.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Mock.
0000000000000000000000000000000000000000;;	//       On("MyMethod", 1).Return(nil).
0000000000000000000000000000000000000000;;	//       On("MyOtherMethod", 'a', 'b', 'c').Return(errors.New("Some Error"))
0000000000000000000000000000000000000000;;	func (self *Call) On(methodName string, arguments ...interface{}) *Call {
0000000000000000000000000000000000000000;;		return self.Parent.On(methodName, arguments...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mock is the workhorse used to track activity on another object.
0000000000000000000000000000000000000000;;	// For an example of its usage, refer to the "Example Usage" section at the top
0000000000000000000000000000000000000000;;	// of this document.
0000000000000000000000000000000000000000;;	type Mock struct {
0000000000000000000000000000000000000000;;		// Represents the calls that are expected of
0000000000000000000000000000000000000000;;		// an object.
0000000000000000000000000000000000000000;;		ExpectedCalls []*Call
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Holds the calls that were made to this mocked object.
0000000000000000000000000000000000000000;;		Calls []Call
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TestData holds any data that might be useful for testing.  Testify ignores
0000000000000000000000000000000000000000;;		// this data completely allowing you to do whatever you like with it.
0000000000000000000000000000000000000000;;		testData objx.Map
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mutex sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestData holds any data that might be useful for testing.  Testify ignores
0000000000000000000000000000000000000000;;	// this data completely allowing you to do whatever you like with it.
0000000000000000000000000000000000000000;;	func (m *Mock) TestData() objx.Map {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.testData == nil {
0000000000000000000000000000000000000000;;			m.testData = make(objx.Map)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.testData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Setting expectations
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// On starts a description of an expectation of the specified method
0000000000000000000000000000000000000000;;	// being called.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     Mock.On("MyMethod", arg1, arg2)
0000000000000000000000000000000000000000;;	func (self *Mock) On(methodName string, arguments ...interface{}) *Call {
0000000000000000000000000000000000000000;;		for _, arg := range arguments {
0000000000000000000000000000000000000000;;			if v := reflect.ValueOf(arg); v.Kind() == reflect.Func {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("cannot use Func in expectations. Use mock.AnythingOfType(\"%T\")", arg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		self.mutex.Lock()
0000000000000000000000000000000000000000;;		defer self.mutex.Unlock()
0000000000000000000000000000000000000000;;		c := newCall(self, methodName, arguments...)
0000000000000000000000000000000000000000;;		self.ExpectedCalls = append(self.ExpectedCalls, c)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// /*
0000000000000000000000000000000000000000;;	// 	Recording and responding to activity
0000000000000000000000000000000000000000;;	// */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Mock) findExpectedCall(method string, arguments ...interface{}) (int, *Call) {
0000000000000000000000000000000000000000;;		m.mutex.Lock()
0000000000000000000000000000000000000000;;		defer m.mutex.Unlock()
0000000000000000000000000000000000000000;;		for i, call := range m.ExpectedCalls {
0000000000000000000000000000000000000000;;			if call.Method == method && call.Repeatability > -1 {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, diffCount := call.Arguments.Diff(arguments)
0000000000000000000000000000000000000000;;				if diffCount == 0 {
0000000000000000000000000000000000000000;;					return i, call
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Mock) findClosestCall(method string, arguments ...interface{}) (bool, *Call) {
0000000000000000000000000000000000000000;;		diffCount := 0
0000000000000000000000000000000000000000;;		var closestCall *Call = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, call := range m.expectedCalls() {
0000000000000000000000000000000000000000;;			if call.Method == method {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, tempDiffCount := call.Arguments.Diff(arguments)
0000000000000000000000000000000000000000;;				if tempDiffCount < diffCount || diffCount == 0 {
0000000000000000000000000000000000000000;;					diffCount = tempDiffCount
0000000000000000000000000000000000000000;;					closestCall = call
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if closestCall == nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, closestCall
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func callString(method string, arguments Arguments, includeArgumentValues bool) string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var argValsString string = ""
0000000000000000000000000000000000000000;;		if includeArgumentValues {
0000000000000000000000000000000000000000;;			var argVals []string
0000000000000000000000000000000000000000;;			for argIndex, arg := range arguments {
0000000000000000000000000000000000000000;;				argVals = append(argVals, fmt.Sprintf("%d: %#v", argIndex, arg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			argValsString = fmt.Sprintf("\n\t\t%s", strings.Join(argVals, "\n\t\t"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s(%s)%s", method, arguments.String(), argValsString)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Called tells the mock object that a method has been called, and gets an array
0000000000000000000000000000000000000000;;	// of arguments to return.  Panics if the call is unexpected (i.e. not preceeded by
0000000000000000000000000000000000000000;;	// appropriate .On .Return() calls)
0000000000000000000000000000000000000000;;	// If Call.WaitFor is set, blocks until the channel is closed or receives a message.
0000000000000000000000000000000000000000;;	func (m *Mock) Called(arguments ...interface{}) Arguments {
0000000000000000000000000000000000000000;;		// get the calling function's name
0000000000000000000000000000000000000000;;		pc, _, _, ok := runtime.Caller(1)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic("Couldn't get the caller information")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		functionPath := runtime.FuncForPC(pc).Name()
0000000000000000000000000000000000000000;;		//Next four lines are required to use GCCGO function naming conventions.
0000000000000000000000000000000000000000;;		//For Ex:  github_com_docker_libkv_store_mock.WatchTree.pN39_github_com_docker_libkv_store_mock.Mock
0000000000000000000000000000000000000000;;		//uses inteface information unlike golang github.com/docker/libkv/store/mock.(*Mock).WatchTree
0000000000000000000000000000000000000000;;		//With GCCGO we need to remove interface information starting from pN<dd>.
0000000000000000000000000000000000000000;;		re := regexp.MustCompile("\\.pN\\d+_")
0000000000000000000000000000000000000000;;		if re.MatchString(functionPath) {
0000000000000000000000000000000000000000;;			functionPath = re.Split(functionPath, -1)[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.Split(functionPath, ".")
0000000000000000000000000000000000000000;;		functionName := parts[len(parts)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found, call := m.findExpectedCall(functionName, arguments...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if found < 0 {
0000000000000000000000000000000000000000;;			// we have to fail here - because we don't know what to do
0000000000000000000000000000000000000000;;			// as the return arguments.  This is because:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			//   a) this is a totally unexpected call to this method,
0000000000000000000000000000000000000000;;			//   b) the arguments are not what was expected, or
0000000000000000000000000000000000000000;;			//   c) the developer has forgotten to add an accompanying On...Return pair.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			closestFound, closestCall := m.findClosestCall(functionName, arguments...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if closestFound {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("\n\nmock: Unexpected Method Call\n-----------------------------\n\n%s\n\nThe closest call I have is: \n\n%s\n", callString(functionName, arguments, true), callString(functionName, closestCall.Arguments, true)))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("\nassert: mock: I don't know what to return because the method call was unexpected.\n\tEither do Mock.On(\"%s\").Return(...) first, or remove the %s() call.\n\tThis method was unexpected:\n\t\t%s\n\tat: %s", functionName, functionName, callString(functionName, arguments, true), assert.CallerInfo()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m.mutex.Lock()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case call.Repeatability == 1:
0000000000000000000000000000000000000000;;				call.Repeatability = -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case call.Repeatability > 1:
0000000000000000000000000000000000000000;;				call.Repeatability -= 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.mutex.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add the call
0000000000000000000000000000000000000000;;		m.mutex.Lock()
0000000000000000000000000000000000000000;;		m.Calls = append(m.Calls, *newCall(m, functionName, arguments...))
0000000000000000000000000000000000000000;;		m.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// block if specified
0000000000000000000000000000000000000000;;		if call.WaitFor != nil {
0000000000000000000000000000000000000000;;			<-call.WaitFor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if call.RunFn != nil {
0000000000000000000000000000000000000000;;			call.RunFn(arguments)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return call.ReturnArguments
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Assertions
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertExpectationsForObjects asserts that everything specified with On and Return
0000000000000000000000000000000000000000;;	// of the specified objects was in fact called as expected.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Calls may have occurred in any order.
0000000000000000000000000000000000000000;;	func AssertExpectationsForObjects(t TestingT, testObjects ...interface{}) bool {
0000000000000000000000000000000000000000;;		var success bool = true
0000000000000000000000000000000000000000;;		for _, obj := range testObjects {
0000000000000000000000000000000000000000;;			mockObj := obj.(Mock)
0000000000000000000000000000000000000000;;			success = success && mockObj.AssertExpectations(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return success
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertExpectations asserts that everything specified with On and Return was
0000000000000000000000000000000000000000;;	// in fact called as expected.  Calls may have occurred in any order.
0000000000000000000000000000000000000000;;	func (m *Mock) AssertExpectations(t TestingT) bool {
0000000000000000000000000000000000000000;;		var somethingMissing bool = false
0000000000000000000000000000000000000000;;		var failedExpectations int = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// iterate through each expectation
0000000000000000000000000000000000000000;;		expectedCalls := m.expectedCalls()
0000000000000000000000000000000000000000;;		for _, expectedCall := range expectedCalls {
0000000000000000000000000000000000000000;;			if !m.methodWasCalled(expectedCall.Method, expectedCall.Arguments) {
0000000000000000000000000000000000000000;;				somethingMissing = true
0000000000000000000000000000000000000000;;				failedExpectations++
0000000000000000000000000000000000000000;;				t.Logf("\u274C\t%s(%s)", expectedCall.Method, expectedCall.Arguments.String())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				m.mutex.Lock()
0000000000000000000000000000000000000000;;				if expectedCall.Repeatability > 0 {
0000000000000000000000000000000000000000;;					somethingMissing = true
0000000000000000000000000000000000000000;;					failedExpectations++
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Logf("\u2705\t%s(%s)", expectedCall.Method, expectedCall.Arguments.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m.mutex.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if somethingMissing {
0000000000000000000000000000000000000000;;			t.Errorf("FAIL: %d out of %d expectation(s) were met.\n\tThe code you are testing needs to make %d more call(s).\n\tat: %s", len(expectedCalls)-failedExpectations, len(expectedCalls), failedExpectations, assert.CallerInfo())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return !somethingMissing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertNumberOfCalls asserts that the method was called expectedCalls times.
0000000000000000000000000000000000000000;;	func (m *Mock) AssertNumberOfCalls(t TestingT, methodName string, expectedCalls int) bool {
0000000000000000000000000000000000000000;;		var actualCalls int = 0
0000000000000000000000000000000000000000;;		for _, call := range m.calls() {
0000000000000000000000000000000000000000;;			if call.Method == methodName {
0000000000000000000000000000000000000000;;				actualCalls++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return assert.Equal(t, expectedCalls, actualCalls, fmt.Sprintf("Expected number of calls (%d) does not match the actual number of calls (%d).", expectedCalls, actualCalls))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertCalled asserts that the method was called.
0000000000000000000000000000000000000000;;	func (m *Mock) AssertCalled(t TestingT, methodName string, arguments ...interface{}) bool {
0000000000000000000000000000000000000000;;		if !assert.True(t, m.methodWasCalled(methodName, arguments), fmt.Sprintf("The \"%s\" method should have been called with %d argument(s), but was not.", methodName, len(arguments))) {
0000000000000000000000000000000000000000;;			t.Logf("%v", m.expectedCalls())
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertNotCalled asserts that the method was not called.
0000000000000000000000000000000000000000;;	func (m *Mock) AssertNotCalled(t TestingT, methodName string, arguments ...interface{}) bool {
0000000000000000000000000000000000000000;;		if !assert.False(t, m.methodWasCalled(methodName, arguments), fmt.Sprintf("The \"%s\" method was called with %d argument(s), but should NOT have been.", methodName, len(arguments))) {
0000000000000000000000000000000000000000;;			t.Logf("%v", m.expectedCalls())
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Mock) methodWasCalled(methodName string, expected []interface{}) bool {
0000000000000000000000000000000000000000;;		for _, call := range m.calls() {
0000000000000000000000000000000000000000;;			if call.Method == methodName {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				_, differences := Arguments(expected).Diff(call.Arguments)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if differences == 0 {
0000000000000000000000000000000000000000;;					// found the expected call
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we didn't find the expected call
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Mock) expectedCalls() []*Call {
0000000000000000000000000000000000000000;;		m.mutex.Lock()
0000000000000000000000000000000000000000;;		defer m.mutex.Unlock()
0000000000000000000000000000000000000000;;		return append([]*Call{}, m.ExpectedCalls...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Mock) calls() []Call {
0000000000000000000000000000000000000000;;		m.mutex.Lock()
0000000000000000000000000000000000000000;;		defer m.mutex.Unlock()
0000000000000000000000000000000000000000;;		return append([]Call{}, m.Calls...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Arguments
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Arguments holds an array of method arguments or return values.
0000000000000000000000000000000000000000;;	type Arguments []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The "any" argument.  Used in Diff and Assert when
0000000000000000000000000000000000000000;;		// the argument being tested shouldn't be taken into consideration.
0000000000000000000000000000000000000000;;		Anything string = "mock.Anything"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnythingOfTypeArgument is a string that contains the type of an argument
0000000000000000000000000000000000000000;;	// for use when type checking.  Used in Diff and Assert.
0000000000000000000000000000000000000000;;	type AnythingOfTypeArgument string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnythingOfType returns an AnythingOfTypeArgument object containing the
0000000000000000000000000000000000000000;;	// name of the type to check for.  Used in Diff and Assert.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	//	Assert(t, AnythingOfType("string"), AnythingOfType("int"))
0000000000000000000000000000000000000000;;	func AnythingOfType(t string) AnythingOfTypeArgument {
0000000000000000000000000000000000000000;;		return AnythingOfTypeArgument(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get Returns the argument at the specified index.
0000000000000000000000000000000000000000;;	func (args Arguments) Get(index int) interface{} {
0000000000000000000000000000000000000000;;		if index+1 > len(args) {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("assert: arguments: Cannot call Get(%d) because there are %d argument(s).", index, len(args)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args[index]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is gets whether the objects match the arguments specified.
0000000000000000000000000000000000000000;;	func (args Arguments) Is(objects ...interface{}) bool {
0000000000000000000000000000000000000000;;		for i, obj := range args {
0000000000000000000000000000000000000000;;			if obj != objects[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Diff gets a string describing the differences between the arguments
0000000000000000000000000000000000000000;;	// and the specified objects.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns the diff string and number of differences found.
0000000000000000000000000000000000000000;;	func (args Arguments) Diff(objects []interface{}) (string, int) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var output string = "\n"
0000000000000000000000000000000000000000;;		var differences int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var maxArgCount int = len(args)
0000000000000000000000000000000000000000;;		if len(objects) > maxArgCount {
0000000000000000000000000000000000000000;;			maxArgCount = len(objects)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < maxArgCount; i++ {
0000000000000000000000000000000000000000;;			var actual, expected interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(objects) <= i {
0000000000000000000000000000000000000000;;				actual = "(Missing)"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				actual = objects[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(args) <= i {
0000000000000000000000000000000000000000;;				expected = "(Missing)"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				expected = args[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if reflect.TypeOf(expected) == reflect.TypeOf((*AnythingOfTypeArgument)(nil)).Elem() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// type checking
0000000000000000000000000000000000000000;;				if reflect.TypeOf(actual).Name() != string(expected.(AnythingOfTypeArgument)) && reflect.TypeOf(actual).String() != string(expected.(AnythingOfTypeArgument)) {
0000000000000000000000000000000000000000;;					// not match
0000000000000000000000000000000000000000;;					differences++
0000000000000000000000000000000000000000;;					output = fmt.Sprintf("%s\t%d: \u274C  type %s != type %s - %s\n", output, i, expected, reflect.TypeOf(actual).Name(), actual)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// normal checking
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if assert.ObjectsAreEqual(expected, Anything) || assert.ObjectsAreEqual(actual, Anything) || assert.ObjectsAreEqual(actual, expected) {
0000000000000000000000000000000000000000;;					// match
0000000000000000000000000000000000000000;;					output = fmt.Sprintf("%s\t%d: \u2705  %s == %s\n", output, i, actual, expected)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// not match
0000000000000000000000000000000000000000;;					differences++
0000000000000000000000000000000000000000;;					output = fmt.Sprintf("%s\t%d: \u274C  %s != %s\n", output, i, actual, expected)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if differences == 0 {
0000000000000000000000000000000000000000;;			return "No differences.", differences
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output, differences
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assert compares the arguments with the specified objects and fails if
0000000000000000000000000000000000000000;;	// they do not exactly match.
0000000000000000000000000000000000000000;;	func (args Arguments) Assert(t TestingT, objects ...interface{}) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the differences
0000000000000000000000000000000000000000;;		diff, diffCount := args.Diff(objects)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if diffCount == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// there are differences... report them...
0000000000000000000000000000000000000000;;		t.Logf(diff)
0000000000000000000000000000000000000000;;		t.Errorf("%sArguments do not match.", assert.CallerInfo())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String gets the argument at the specified index. Panics if there is no argument, or
0000000000000000000000000000000000000000;;	// if the argument is of the wrong type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If no index is provided, String() returns a complete string representation
0000000000000000000000000000000000000000;;	// of the arguments.
0000000000000000000000000000000000000000;;	func (args Arguments) String(indexOrNil ...int) string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(indexOrNil) == 0 {
0000000000000000000000000000000000000000;;			// normal String() method - return a string representation of the args
0000000000000000000000000000000000000000;;			var argsStr []string
0000000000000000000000000000000000000000;;			for _, arg := range args {
0000000000000000000000000000000000000000;;				argsStr = append(argsStr, fmt.Sprintf("%s", reflect.TypeOf(arg)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strings.Join(argsStr, ",")
0000000000000000000000000000000000000000;;		} else if len(indexOrNil) == 1 {
0000000000000000000000000000000000000000;;			// Index has been specified - get the argument at that index
0000000000000000000000000000000000000000;;			var index int = indexOrNil[0]
0000000000000000000000000000000000000000;;			var s string
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			if s, ok = args.Get(index).(string); !ok {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("assert: arguments: String(%d) failed because object wasn't correct type: %s", index, args.Get(index)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("assert: arguments: Wrong number of arguments passed to String.  Must be 0 or 1, not %d", len(indexOrNil)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int gets the argument at the specified index. Panics if there is no argument, or
0000000000000000000000000000000000000000;;	// if the argument is of the wrong type.
0000000000000000000000000000000000000000;;	func (args Arguments) Int(index int) int {
0000000000000000000000000000000000000000;;		var s int
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if s, ok = args.Get(index).(int); !ok {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("assert: arguments: Int(%d) failed because object wasn't correct type: %v", index, args.Get(index)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error gets the argument at the specified index. Panics if there is no argument, or
0000000000000000000000000000000000000000;;	// if the argument is of the wrong type.
0000000000000000000000000000000000000000;;	func (args Arguments) Error(index int) error {
0000000000000000000000000000000000000000;;		obj := args.Get(index)
0000000000000000000000000000000000000000;;		var s error
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s, ok = obj.(error); !ok {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("assert: arguments: Error(%d) failed because object wasn't correct type: %v", index, args.Get(index)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bool gets the argument at the specified index. Panics if there is no argument, or
0000000000000000000000000000000000000000;;	// if the argument is of the wrong type.
0000000000000000000000000000000000000000;;	func (args Arguments) Bool(index int) bool {
0000000000000000000000000000000000000000;;		var s bool
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if s, ok = args.Get(index).(bool); !ok {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("assert: arguments: Bool(%d) failed because object wasn't correct type: %v", index, args.Get(index)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
