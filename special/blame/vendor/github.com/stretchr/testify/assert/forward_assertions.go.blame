0000000000000000000000000000000000000000;;	package assert
b8afb3b69b1f3498b6aaeb3117617fa5bef8af8a;Godeps/_workspace/src/github.com/stretchr/testify/assert/forward_assertions.go[Godeps/_workspace/src/github.com/stretchr/testify/assert/forward_assertions.go][vendor/github.com/stretchr/testify/assert/forward_assertions.go];	
0000000000000000000000000000000000000000;;	import "time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assertions provides assertion methods around the
0000000000000000000000000000000000000000;;	// TestingT interface.
0000000000000000000000000000000000000000;;	type Assertions struct {
0000000000000000000000000000000000000000;;		t TestingT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New makes a new Assertions object for the specified TestingT.
0000000000000000000000000000000000000000;;	func New(t TestingT) *Assertions {
0000000000000000000000000000000000000000;;		return &Assertions{
0000000000000000000000000000000000000000;;			t: t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fail reports a failure through
0000000000000000000000000000000000000000;;	func (a *Assertions) Fail(failureMessage string, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Fail(a.t, failureMessage, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements asserts that an object is implemented by the specified interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.Implements((*MyInterface)(nil), new(MyObject), "MyObject")
0000000000000000000000000000000000000000;;	func (a *Assertions) Implements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Implements(a.t, interfaceObject, object, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsType asserts that the specified objects are of the same type.
0000000000000000000000000000000000000000;;	func (a *Assertions) IsType(expectedType interface{}, object interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return IsType(a.t, expectedType, object, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal asserts that two objects are equal.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.Equal(123, 123, "123 and 123 should be equal")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Equal(expected, actual interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Equal(a.t, expected, actual, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EqualValues asserts that two objects are equal or convertable to the same types
0000000000000000000000000000000000000000;;	// and equal.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.EqualValues(uint32(123), int32(123), "123 and 123 should be equal")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) EqualValues(expected, actual interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return EqualValues(a.t, expected, actual, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exactly asserts that two objects are equal is value and type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.Exactly(int32(123), int64(123), "123 and 123 should NOT be equal")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Exactly(expected, actual interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Exactly(a.t, expected, actual, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotNil asserts that the specified object is not nil.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.NotNil(err, "err should be something")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) NotNil(object interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NotNil(a.t, object, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nil asserts that the specified object is nil.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.Nil(err, "err should be nothing")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Nil(object interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Nil(a.t, object, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or a
0000000000000000000000000000000000000000;;	// slice with len == 0.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  assert.Empty(obj)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Empty(a.t, object, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or a
0000000000000000000000000000000000000000;;	// slice with len == 0.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  if assert.NotEmpty(obj) {
0000000000000000000000000000000000000000;;	//    assert.Equal("two", obj[1])
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NotEmpty(a.t, object, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len asserts that the specified object has specific length.
0000000000000000000000000000000000000000;;	// Len also fails if the object has a type that len() not accept.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.Len(mySlice, 3, "The size of slice is not 3")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Len(a.t, object, length, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// True asserts that the specified value is true.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.True(myBool, "myBool should be true")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) True(value bool, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return True(a.t, value, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// False asserts that the specified value is false.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.False(myBool, "myBool should be false")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) False(value bool, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return False(a.t, value, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotEqual asserts that the specified values are NOT equal.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.NotEqual(obj1, obj2, "two objects shouldn't be equal")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) NotEqual(expected, actual interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NotEqual(a.t, expected, actual, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains asserts that the specified string contains the specified substring.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.Contains("Hello World", "World", "But 'Hello World' does contain 'World'")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Contains(s, contains interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Contains(a.t, s, contains, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotContains asserts that the specified string does NOT contain the specified substring.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    assert.NotContains("Hello World", "Earth", "But 'Hello World' does NOT contain 'Earth'")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) NotContains(s, contains interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NotContains(a.t, s, contains, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Condition uses a Comparison to assert a complex condition.
0000000000000000000000000000000000000000;;	func (a *Assertions) Condition(comp Comparison, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Condition(a.t, comp, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Panics asserts that the code inside the specified PanicTestFunc panics.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   assert.Panics(func(){
0000000000000000000000000000000000000000;;	//     GoCrazy()
0000000000000000000000000000000000000000;;	//   }, "Calling GoCrazy() should panic")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Panics(f PanicTestFunc, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Panics(a.t, f, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   assert.NotPanics(func(){
0000000000000000000000000000000000000000;;	//     RemainCalm()
0000000000000000000000000000000000000000;;	//   }, "Calling RemainCalm() should NOT panic")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) NotPanics(f PanicTestFunc, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NotPanics(a.t, f, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithinDuration asserts that the two times are within duration delta of each other.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   assert.WithinDuration(time.Now(), time.Now(), 10*time.Second, "The difference should not be more than 10s")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) WithinDuration(expected, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return WithinDuration(a.t, expected, actual, delta, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InDelta asserts that the two numerals are within delta of each other.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	 assert.InDelta(t, math.Pi, (22 / 7.0), 0.01)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) InDelta(expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return InDelta(a.t, expected, actual, delta, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InEpsilon asserts that expected and actual have a relative error less than epsilon
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) InEpsilon(expected, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return InEpsilon(a.t, expected, actual, epsilon, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoError asserts that a function returned no error (i.e. `nil`).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   actualObj, err := SomeFunction()
0000000000000000000000000000000000000000;;	//   if assert.NoError(err) {
0000000000000000000000000000000000000000;;	//	   assert.Equal(actualObj, expectedObj)
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) NoError(theError error, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NoError(a.t, theError, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error asserts that a function returned an error (i.e. not `nil`).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   actualObj, err := SomeFunction()
0000000000000000000000000000000000000000;;	//   if assert.Error(err, "An error was expected") {
0000000000000000000000000000000000000000;;	//	   assert.Equal(err, expectedError)
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Error(theError error, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Error(a.t, theError, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EqualError asserts that a function returned an error (i.e. not `nil`)
0000000000000000000000000000000000000000;;	// and that it is equal to the provided error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   actualObj, err := SomeFunction()
0000000000000000000000000000000000000000;;	//   if assert.Error(err, "An error was expected") {
0000000000000000000000000000000000000000;;	//	   assert.Equal(err, expectedError)
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return EqualError(a.t, theError, errString, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Regexp asserts that a specified regexp matches a string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  assert.Regexp(t, regexp.MustCompile("start"), "it's starting")
0000000000000000000000000000000000000000;;	//  assert.Regexp(t, "start...$", "it's not starting")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Regexp(a.t, rx, str, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotRegexp asserts that a specified regexp does not match a string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  assert.NotRegexp(t, regexp.MustCompile("starts"), "it's starting")
0000000000000000000000000000000000000000;;	//  assert.NotRegexp(t, "^start", "it's not starting")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NotRegexp(a.t, rx, str, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Zero asserts that i is the zero value for its type and returns the truth.
0000000000000000000000000000000000000000;;	func (a *Assertions) Zero(i interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return Zero(a.t, i, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotZero asserts that i is not the zero value for its type and returns the truth.
0000000000000000000000000000000000000000;;	func (a *Assertions) NotZero(i interface{}, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return NotZero(a.t, i, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONEq asserts that two JSON strings are equivalent.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  assert.JSONEq(t, `{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns whether the assertion was successful (true) or not (false).
0000000000000000000000000000000000000000;;	func (a *Assertions) JSONEq(expected string, actual string, msgAndArgs ...interface{}) bool {
0000000000000000000000000000000000000000;;		return JSONEq(a.t, expected, actual, msgAndArgs...)
0000000000000000000000000000000000000000;;	}
