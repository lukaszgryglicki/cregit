0000000000000000000000000000000000000000;;	package objx
3cf0baf74e8a07b2c54564947f6896a529cec0c7;third_party/src/github.com/stretchr/objx/map.go[third_party/src/github.com/stretchr/objx/map.go][vendor/github.com/stretchr/objx/map.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MSIConvertable is an interface that defines methods for converting your
0000000000000000000000000000000000000000;;	// custom types to a map[string]interface{} representation.
0000000000000000000000000000000000000000;;	type MSIConvertable interface {
0000000000000000000000000000000000000000;;		// MSI gets a map[string]interface{} (msi) representing the
0000000000000000000000000000000000000000;;		// object.
0000000000000000000000000000000000000000;;		MSI() map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map provides extended functionality for working with
0000000000000000000000000000000000000000;;	// untyped data, in particular map[string]interface (msi).
0000000000000000000000000000000000000000;;	type Map map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value returns the internal value instance
0000000000000000000000000000000000000000;;	func (m Map) Value() *Value {
0000000000000000000000000000000000000000;;		return &Value{data: m}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nil represents a nil Map.
0000000000000000000000000000000000000000;;	var Nil Map = New(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new Map containing the map[string]interface{} in the data argument.
0000000000000000000000000000000000000000;;	// If the data argument is not a map[string]interface, New attempts to call the
0000000000000000000000000000000000000000;;	// MSI() method on the MSIConvertable interface to create one.
0000000000000000000000000000000000000000;;	func New(data interface{}) Map {
0000000000000000000000000000000000000000;;		if _, ok := data.(map[string]interface{}); !ok {
0000000000000000000000000000000000000000;;			if converter, ok := data.(MSIConvertable); ok {
0000000000000000000000000000000000000000;;				data = converter.MSI()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Map(data.(map[string]interface{}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MSI creates a map[string]interface{} and puts it inside a new Map.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The arguments follow a key, value pattern.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if any key arugment is non-string or if there are an odd number of arguments.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To easily create Maps:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     m := objx.MSI("name", "Mat", "age", 29, "subobj", objx.MSI("active", true))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // creates an Map equivalent to
0000000000000000000000000000000000000000;;	//     m := objx.New(map[string]interface{}{"name": "Mat", "age": 29, "subobj": map[string]interface{}{"active": true}})
0000000000000000000000000000000000000000;;	func MSI(keyAndValuePairs ...interface{}) Map {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;		keyAndValuePairsLen := len(keyAndValuePairs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if keyAndValuePairsLen%2 != 0 {
0000000000000000000000000000000000000000;;			panic("objx: MSI must have an even number of arguments following the 'key, value' pattern.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < keyAndValuePairsLen; i = i + 2 {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			key := keyAndValuePairs[i]
0000000000000000000000000000000000000000;;			value := keyAndValuePairs[i+1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// make sure the key is a string
0000000000000000000000000000000000000000;;			keyString, keyStringOK := key.(string)
0000000000000000000000000000000000000000;;			if !keyStringOK {
0000000000000000000000000000000000000000;;				panic("objx: MSI must follow 'string, interface{}' pattern.  " + keyString + " is not a valid key.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newMap[keyString] = value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return New(newMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ****** Conversion Constructors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFromJSON creates a new Map containing the data specified in the
0000000000000000000000000000000000000000;;	// jsonString.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the JSON is invalid.
0000000000000000000000000000000000000000;;	func MustFromJSON(jsonString string) Map {
0000000000000000000000000000000000000000;;		o, err := FromJSON(jsonString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("objx: MustFromJSON failed with error: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromJSON creates a new Map containing the data specified in the
0000000000000000000000000000000000000000;;	// jsonString.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns an error if the JSON is invalid.
0000000000000000000000000000000000000000;;	func FromJSON(jsonString string) (Map, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var data interface{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal([]byte(jsonString), &data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return New(data), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromBase64 creates a new Obj containing the data specified
0000000000000000000000000000000000000000;;	// in the Base64 string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The string is an encoded JSON string returned by Base64
0000000000000000000000000000000000000000;;	func FromBase64(base64String string) (Map, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := base64.NewDecoder(base64.StdEncoding, strings.NewReader(base64String))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoded, err := ioutil.ReadAll(decoder)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return FromJSON(string(decoded))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFromBase64 creates a new Obj containing the data specified
0000000000000000000000000000000000000000;;	// in the Base64 string and panics if there is an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The string is an encoded JSON string returned by Base64
0000000000000000000000000000000000000000;;	func MustFromBase64(base64String string) Map {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err := FromBase64(base64String)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("objx: MustFromBase64 failed with error: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromSignedBase64 creates a new Obj containing the data specified
0000000000000000000000000000000000000000;;	// in the Base64 string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The string is an encoded JSON string returned by SignedBase64
0000000000000000000000000000000000000000;;	func FromSignedBase64(base64String, key string) (Map, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(base64String, SignatureSeparator)
0000000000000000000000000000000000000000;;		if len(parts) != 2 {
0000000000000000000000000000000000000000;;			return nil, errors.New("objx: Signed base64 string is malformed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sig := HashWithKey(parts[0], key)
0000000000000000000000000000000000000000;;		if parts[1] != sig {
0000000000000000000000000000000000000000;;			return nil, errors.New("objx: Signature for base64 data does not match.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return FromBase64(parts[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFromSignedBase64 creates a new Obj containing the data specified
0000000000000000000000000000000000000000;;	// in the Base64 string and panics if there is an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The string is an encoded JSON string returned by Base64
0000000000000000000000000000000000000000;;	func MustFromSignedBase64(base64String, key string) Map {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err := FromSignedBase64(base64String, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("objx: MustFromSignedBase64 failed with error: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromURLQuery generates a new Obj by parsing the specified
0000000000000000000000000000000000000000;;	// query.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For queries with multiple values, the first value is selected.
0000000000000000000000000000000000000000;;	func FromURLQuery(query string) (Map, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vals, err := url.ParseQuery(query)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(map[string]interface{})
0000000000000000000000000000000000000000;;		for k, vals := range vals {
0000000000000000000000000000000000000000;;			m[k] = vals[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return New(m), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFromURLQuery generates a new Obj by parsing the specified
0000000000000000000000000000000000000000;;	// query.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For queries with multiple values, the first value is selected.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if it encounters an error
0000000000000000000000000000000000000000;;	func MustFromURLQuery(query string) Map {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o, err := FromURLQuery(query)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("objx: MustFromURLQuery failed with error: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
