0000000000000000000000000000000000000000;;	package objx
3cf0baf74e8a07b2c54564947f6896a529cec0c7;third_party/src/github.com/stretchr/objx/mutations.go[third_party/src/github.com/stretchr/objx/mutations.go][vendor/github.com/stretchr/objx/mutations.go];	
0000000000000000000000000000000000000000;;	// Exclude returns a new Map with the keys in the specified []string
0000000000000000000000000000000000000000;;	// excluded.
0000000000000000000000000000000000000000;;	func (d Map) Exclude(exclude []string) Map {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		excluded := make(Map)
0000000000000000000000000000000000000000;;		for k, v := range d {
0000000000000000000000000000000000000000;;			var shouldInclude bool = true
0000000000000000000000000000000000000000;;			for _, toExclude := range exclude {
0000000000000000000000000000000000000000;;				if k == toExclude {
0000000000000000000000000000000000000000;;					shouldInclude = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if shouldInclude {
0000000000000000000000000000000000000000;;				excluded[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return excluded
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy creates a shallow copy of the Obj.
0000000000000000000000000000000000000000;;	func (m Map) Copy() Map {
0000000000000000000000000000000000000000;;		copied := make(map[string]interface{})
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			copied[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return New(copied)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge blends the specified map with a copy of this map and returns the result.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Keys that appear in both will be selected from the specified map.
0000000000000000000000000000000000000000;;	// This method requires that the wrapped object be a map[string]interface{}
0000000000000000000000000000000000000000;;	func (m Map) Merge(merge Map) Map {
0000000000000000000000000000000000000000;;		return m.Copy().MergeHere(merge)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge blends the specified map with this map and returns the current map.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Keys that appear in both will be selected from the specified map.  The original map
0000000000000000000000000000000000000000;;	// will be modified. This method requires that
0000000000000000000000000000000000000000;;	// the wrapped object be a map[string]interface{}
0000000000000000000000000000000000000000;;	func (m Map) MergeHere(merge Map) Map {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range merge {
0000000000000000000000000000000000000000;;			m[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform builds a new Obj giving the transformer a chance
0000000000000000000000000000000000000000;;	// to change the keys and values as it goes. This method requires that
0000000000000000000000000000000000000000;;	// the wrapped object be a map[string]interface{}
0000000000000000000000000000000000000000;;	func (m Map) Transform(transformer func(key string, value interface{}) (string, interface{})) Map {
0000000000000000000000000000000000000000;;		newMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			modifiedKey, modifiedVal := transformer(k, v)
0000000000000000000000000000000000000000;;			newMap[modifiedKey] = modifiedVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return New(newMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransformKeys builds a new map using the specified key mapping.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unspecified keys will be unaltered.
0000000000000000000000000000000000000000;;	// This method requires that the wrapped object be a map[string]interface{}
0000000000000000000000000000000000000000;;	func (m Map) TransformKeys(mapping map[string]string) Map {
0000000000000000000000000000000000000000;;		return m.Transform(func(key string, value interface{}) (string, interface{}) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if newKey, ok := mapping[key]; ok {
0000000000000000000000000000000000000000;;				return newKey, value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return key, value
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
