0000000000000000000000000000000000000000;;	package objx
3cf0baf74e8a07b2c54564947f6896a529cec0c7;third_party/src/github.com/stretchr/objx/type_specific_codegen.go[third_party/src/github.com/stretchr/objx/type_specific_codegen.go][vendor/github.com/stretchr/objx/type_specific_codegen.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Inter (interface{} and []interface{})
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Inter gets the value as a interface{}, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Inter(optionalDefault ...interface{}) interface{} {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(interface{}); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInter gets the value as a interface{}.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) MustInter() interface{} {
0000000000000000000000000000000000000000;;		return v.data.(interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InterSlice gets the value as a []interface{}, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) InterSlice(optionalDefault ...[]interface{}) []interface{} {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]interface{}); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInterSlice gets the value as a []interface{}.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) MustInterSlice() []interface{} {
0000000000000000000000000000000000000000;;		return v.data.([]interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInter gets whether the object contained is a interface{} or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInter() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(interface{})
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInterSlice gets whether the object contained is a []interface{} or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInterSlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]interface{})
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachInter calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []interface{}.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachInter(callback func(int, interface{}) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustInterSlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereInter uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []interface{}.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereInter(decider func(int, interface{}) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInter(func(index int, val interface{}) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupInter uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) GroupInter(grouper func(int, interface{}) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInter(func(index int, val interface{}) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]interface{}, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceInter uses the specified function to replace each interface{}s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []interface{} containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceInter(replacer func(int, interface{}) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInterSlice()
0000000000000000000000000000000000000000;;		replaced := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInter(func(index int, val interface{}) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectInter uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the interface{}s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectInter(collector func(int, interface{}) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInterSlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInter(func(index int, val interface{}) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		MSI (map[string]interface{} and []map[string]interface{})
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MSI gets the value as a map[string]interface{}, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) MSI(optionalDefault ...map[string]interface{}) map[string]interface{} {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustMSI gets the value as a map[string]interface{}.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a map[string]interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) MustMSI() map[string]interface{} {
0000000000000000000000000000000000000000;;		return v.data.(map[string]interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MSISlice gets the value as a []map[string]interface{}, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []map[string]interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) MSISlice(optionalDefault ...[]map[string]interface{}) []map[string]interface{} {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]map[string]interface{}); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustMSISlice gets the value as a []map[string]interface{}.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []map[string]interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) MustMSISlice() []map[string]interface{} {
0000000000000000000000000000000000000000;;		return v.data.([]map[string]interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsMSI gets whether the object contained is a map[string]interface{} or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsMSI() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(map[string]interface{})
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsMSISlice gets whether the object contained is a []map[string]interface{} or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsMSISlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]map[string]interface{})
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachMSI calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []map[string]interface{}.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachMSI(callback func(int, map[string]interface{}) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustMSISlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereMSI uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []map[string]interface{}.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereMSI(decider func(int, map[string]interface{}) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachMSI(func(index int, val map[string]interface{}) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupMSI uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]map[string]interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) GroupMSI(grouper func(int, map[string]interface{}) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachMSI(func(index int, val map[string]interface{}) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]map[string]interface{}, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceMSI uses the specified function to replace each map[string]interface{}s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []map[string]interface{} containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceMSI(replacer func(int, map[string]interface{}) map[string]interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustMSISlice()
0000000000000000000000000000000000000000;;		replaced := make([]map[string]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachMSI(func(index int, val map[string]interface{}) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectMSI uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the map[string]interface{}s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectMSI(collector func(int, map[string]interface{}) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustMSISlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachMSI(func(index int, val map[string]interface{}) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		ObjxMap ((Map) and [](Map))
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjxMap gets the value as a (Map), returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) ObjxMap(optionalDefault ...(Map)) Map {
0000000000000000000000000000000000000000;;		if s, ok := v.data.((Map)); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return New(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustObjxMap gets the value as a (Map).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a (Map).
0000000000000000000000000000000000000000;;	func (v *Value) MustObjxMap() Map {
0000000000000000000000000000000000000000;;		return v.data.((Map))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjxMapSlice gets the value as a [](Map), returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a [](Map).
0000000000000000000000000000000000000000;;	func (v *Value) ObjxMapSlice(optionalDefault ...[](Map)) [](Map) {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([](Map)); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustObjxMapSlice gets the value as a [](Map).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a [](Map).
0000000000000000000000000000000000000000;;	func (v *Value) MustObjxMapSlice() [](Map) {
0000000000000000000000000000000000000000;;		return v.data.([](Map))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsObjxMap gets whether the object contained is a (Map) or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsObjxMap() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.((Map))
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsObjxMapSlice gets whether the object contained is a [](Map) or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsObjxMapSlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([](Map))
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachObjxMap calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the [](Map).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachObjxMap(callback func(int, Map) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustObjxMapSlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereObjxMap uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the [](Map).  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereObjxMap(decider func(int, Map) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected [](Map)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachObjxMap(func(index int, val Map) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupObjxMap uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][](Map).
0000000000000000000000000000000000000000;;	func (v *Value) GroupObjxMap(grouper func(int, Map) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][](Map))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachObjxMap(func(index int, val Map) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([](Map), 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceObjxMap uses the specified function to replace each (Map)s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// [](Map) containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceObjxMap(replacer func(int, Map) Map) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustObjxMapSlice()
0000000000000000000000000000000000000000;;		replaced := make([](Map), len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachObjxMap(func(index int, val Map) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectObjxMap uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the (Map)s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectObjxMap(collector func(int, Map) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustObjxMapSlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachObjxMap(func(index int, val Map) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Bool (bool and []bool)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bool gets the value as a bool, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Bool(optionalDefault ...bool) bool {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(bool); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustBool gets the value as a bool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a bool.
0000000000000000000000000000000000000000;;	func (v *Value) MustBool() bool {
0000000000000000000000000000000000000000;;		return v.data.(bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSlice gets the value as a []bool, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []bool.
0000000000000000000000000000000000000000;;	func (v *Value) BoolSlice(optionalDefault ...[]bool) []bool {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]bool); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustBoolSlice gets the value as a []bool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []bool.
0000000000000000000000000000000000000000;;	func (v *Value) MustBoolSlice() []bool {
0000000000000000000000000000000000000000;;		return v.data.([]bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsBool gets whether the object contained is a bool or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsBool() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(bool)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsBoolSlice gets whether the object contained is a []bool or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsBoolSlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]bool)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachBool calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []bool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachBool(callback func(int, bool) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustBoolSlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereBool uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []bool.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereBool(decider func(int, bool) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachBool(func(index int, val bool) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupBool uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]bool.
0000000000000000000000000000000000000000;;	func (v *Value) GroupBool(grouper func(int, bool) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachBool(func(index int, val bool) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]bool, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceBool uses the specified function to replace each bools
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []bool containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceBool(replacer func(int, bool) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustBoolSlice()
0000000000000000000000000000000000000000;;		replaced := make([]bool, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachBool(func(index int, val bool) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectBool uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the bools in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectBool(collector func(int, bool) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustBoolSlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachBool(func(index int, val bool) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Str (string and []string)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Str gets the value as a string, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Str(optionalDefault ...string) string {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(string); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustStr gets the value as a string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a string.
0000000000000000000000000000000000000000;;	func (v *Value) MustStr() string {
0000000000000000000000000000000000000000;;		return v.data.(string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrSlice gets the value as a []string, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []string.
0000000000000000000000000000000000000000;;	func (v *Value) StrSlice(optionalDefault ...[]string) []string {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]string); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustStrSlice gets the value as a []string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []string.
0000000000000000000000000000000000000000;;	func (v *Value) MustStrSlice() []string {
0000000000000000000000000000000000000000;;		return v.data.([]string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStr gets whether the object contained is a string or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsStr() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(string)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsStrSlice gets whether the object contained is a []string or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsStrSlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]string)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachStr calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachStr(callback func(int, string) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustStrSlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereStr uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []string.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereStr(decider func(int, string) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachStr(func(index int, val string) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupStr uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]string.
0000000000000000000000000000000000000000;;	func (v *Value) GroupStr(grouper func(int, string) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachStr(func(index int, val string) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]string, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceStr uses the specified function to replace each strings
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []string containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceStr(replacer func(int, string) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustStrSlice()
0000000000000000000000000000000000000000;;		replaced := make([]string, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachStr(func(index int, val string) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectStr uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the strings in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectStr(collector func(int, string) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustStrSlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachStr(func(index int, val string) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Int (int and []int)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int gets the value as a int, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Int(optionalDefault ...int) int {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(int); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt gets the value as a int.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a int.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt() int {
0000000000000000000000000000000000000000;;		return v.data.(int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntSlice gets the value as a []int, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []int.
0000000000000000000000000000000000000000;;	func (v *Value) IntSlice(optionalDefault ...[]int) []int {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]int); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustIntSlice gets the value as a []int.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []int.
0000000000000000000000000000000000000000;;	func (v *Value) MustIntSlice() []int {
0000000000000000000000000000000000000000;;		return v.data.([]int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt gets whether the object contained is a int or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(int)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsIntSlice gets whether the object contained is a []int or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsIntSlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]int)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachInt calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []int.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachInt(callback func(int, int) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustIntSlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereInt uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []int.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereInt(decider func(int, int) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt(func(index int, val int) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupInt uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]int.
0000000000000000000000000000000000000000;;	func (v *Value) GroupInt(grouper func(int, int) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt(func(index int, val int) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]int, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceInt uses the specified function to replace each ints
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []int containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceInt(replacer func(int, int) int) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustIntSlice()
0000000000000000000000000000000000000000;;		replaced := make([]int, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt(func(index int, val int) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectInt uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the ints in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectInt(collector func(int, int) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustIntSlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt(func(index int, val int) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Int8 (int8 and []int8)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int8 gets the value as a int8, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Int8(optionalDefault ...int8) int8 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(int8); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt8 gets the value as a int8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a int8.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt8() int8 {
0000000000000000000000000000000000000000;;		return v.data.(int8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int8Slice gets the value as a []int8, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []int8.
0000000000000000000000000000000000000000;;	func (v *Value) Int8Slice(optionalDefault ...[]int8) []int8 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]int8); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt8Slice gets the value as a []int8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []int8.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt8Slice() []int8 {
0000000000000000000000000000000000000000;;		return v.data.([]int8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt8 gets whether the object contained is a int8 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt8() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(int8)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt8Slice gets whether the object contained is a []int8 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt8Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]int8)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachInt8 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []int8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachInt8(callback func(int, int8) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustInt8Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereInt8 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []int8.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereInt8(decider func(int, int8) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []int8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt8(func(index int, val int8) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupInt8 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]int8.
0000000000000000000000000000000000000000;;	func (v *Value) GroupInt8(grouper func(int, int8) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]int8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt8(func(index int, val int8) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]int8, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceInt8 uses the specified function to replace each int8s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []int8 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceInt8(replacer func(int, int8) int8) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt8Slice()
0000000000000000000000000000000000000000;;		replaced := make([]int8, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt8(func(index int, val int8) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectInt8 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the int8s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectInt8(collector func(int, int8) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt8Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt8(func(index int, val int8) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Int16 (int16 and []int16)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int16 gets the value as a int16, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Int16(optionalDefault ...int16) int16 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(int16); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt16 gets the value as a int16.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a int16.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt16() int16 {
0000000000000000000000000000000000000000;;		return v.data.(int16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int16Slice gets the value as a []int16, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []int16.
0000000000000000000000000000000000000000;;	func (v *Value) Int16Slice(optionalDefault ...[]int16) []int16 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]int16); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt16Slice gets the value as a []int16.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []int16.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt16Slice() []int16 {
0000000000000000000000000000000000000000;;		return v.data.([]int16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt16 gets whether the object contained is a int16 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt16() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(int16)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt16Slice gets whether the object contained is a []int16 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt16Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]int16)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachInt16 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []int16.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachInt16(callback func(int, int16) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustInt16Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereInt16 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []int16.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereInt16(decider func(int, int16) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []int16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt16(func(index int, val int16) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupInt16 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]int16.
0000000000000000000000000000000000000000;;	func (v *Value) GroupInt16(grouper func(int, int16) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]int16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt16(func(index int, val int16) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]int16, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceInt16 uses the specified function to replace each int16s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []int16 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceInt16(replacer func(int, int16) int16) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt16Slice()
0000000000000000000000000000000000000000;;		replaced := make([]int16, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt16(func(index int, val int16) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectInt16 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the int16s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectInt16(collector func(int, int16) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt16Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt16(func(index int, val int16) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Int32 (int32 and []int32)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int32 gets the value as a int32, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Int32(optionalDefault ...int32) int32 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(int32); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt32 gets the value as a int32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a int32.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt32() int32 {
0000000000000000000000000000000000000000;;		return v.data.(int32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int32Slice gets the value as a []int32, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []int32.
0000000000000000000000000000000000000000;;	func (v *Value) Int32Slice(optionalDefault ...[]int32) []int32 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]int32); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt32Slice gets the value as a []int32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []int32.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt32Slice() []int32 {
0000000000000000000000000000000000000000;;		return v.data.([]int32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt32 gets whether the object contained is a int32 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt32() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(int32)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt32Slice gets whether the object contained is a []int32 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt32Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]int32)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachInt32 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []int32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachInt32(callback func(int, int32) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustInt32Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereInt32 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []int32.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereInt32(decider func(int, int32) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt32(func(index int, val int32) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupInt32 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]int32.
0000000000000000000000000000000000000000;;	func (v *Value) GroupInt32(grouper func(int, int32) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]int32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt32(func(index int, val int32) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]int32, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceInt32 uses the specified function to replace each int32s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []int32 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceInt32(replacer func(int, int32) int32) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt32Slice()
0000000000000000000000000000000000000000;;		replaced := make([]int32, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt32(func(index int, val int32) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectInt32 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the int32s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectInt32(collector func(int, int32) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt32Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt32(func(index int, val int32) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Int64 (int64 and []int64)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int64 gets the value as a int64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Int64(optionalDefault ...int64) int64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(int64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt64 gets the value as a int64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a int64.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt64() int64 {
0000000000000000000000000000000000000000;;		return v.data.(int64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int64Slice gets the value as a []int64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []int64.
0000000000000000000000000000000000000000;;	func (v *Value) Int64Slice(optionalDefault ...[]int64) []int64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]int64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustInt64Slice gets the value as a []int64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []int64.
0000000000000000000000000000000000000000;;	func (v *Value) MustInt64Slice() []int64 {
0000000000000000000000000000000000000000;;		return v.data.([]int64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt64 gets whether the object contained is a int64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt64() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(int64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt64Slice gets whether the object contained is a []int64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsInt64Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]int64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachInt64 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []int64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachInt64(callback func(int, int64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustInt64Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereInt64 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []int64.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereInt64(decider func(int, int64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt64(func(index int, val int64) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupInt64 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]int64.
0000000000000000000000000000000000000000;;	func (v *Value) GroupInt64(grouper func(int, int64) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]int64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt64(func(index int, val int64) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]int64, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceInt64 uses the specified function to replace each int64s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []int64 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceInt64(replacer func(int, int64) int64) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt64Slice()
0000000000000000000000000000000000000000;;		replaced := make([]int64, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt64(func(index int, val int64) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectInt64 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the int64s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectInt64(collector func(int, int64) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustInt64Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachInt64(func(index int, val int64) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Uint (uint and []uint)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint gets the value as a uint, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Uint(optionalDefault ...uint) uint {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(uint); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint gets the value as a uint.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a uint.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint() uint {
0000000000000000000000000000000000000000;;		return v.data.(uint)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UintSlice gets the value as a []uint, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []uint.
0000000000000000000000000000000000000000;;	func (v *Value) UintSlice(optionalDefault ...[]uint) []uint {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]uint); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUintSlice gets the value as a []uint.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []uint.
0000000000000000000000000000000000000000;;	func (v *Value) MustUintSlice() []uint {
0000000000000000000000000000000000000000;;		return v.data.([]uint)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint gets whether the object contained is a uint or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(uint)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUintSlice gets whether the object contained is a []uint or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUintSlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]uint)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachUint calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []uint.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachUint(callback func(int, uint) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustUintSlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereUint uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []uint.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereUint(decider func(int, uint) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint(func(index int, val uint) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupUint uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]uint.
0000000000000000000000000000000000000000;;	func (v *Value) GroupUint(grouper func(int, uint) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]uint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint(func(index int, val uint) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]uint, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceUint uses the specified function to replace each uints
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []uint containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceUint(replacer func(int, uint) uint) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUintSlice()
0000000000000000000000000000000000000000;;		replaced := make([]uint, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint(func(index int, val uint) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectUint uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the uints in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectUint(collector func(int, uint) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUintSlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint(func(index int, val uint) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Uint8 (uint8 and []uint8)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint8 gets the value as a uint8, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Uint8(optionalDefault ...uint8) uint8 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(uint8); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint8 gets the value as a uint8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a uint8.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint8() uint8 {
0000000000000000000000000000000000000000;;		return v.data.(uint8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint8Slice gets the value as a []uint8, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []uint8.
0000000000000000000000000000000000000000;;	func (v *Value) Uint8Slice(optionalDefault ...[]uint8) []uint8 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]uint8); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint8Slice gets the value as a []uint8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []uint8.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint8Slice() []uint8 {
0000000000000000000000000000000000000000;;		return v.data.([]uint8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint8 gets whether the object contained is a uint8 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint8() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(uint8)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint8Slice gets whether the object contained is a []uint8 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint8Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]uint8)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachUint8 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []uint8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachUint8(callback func(int, uint8) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustUint8Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereUint8 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []uint8.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereUint8(decider func(int, uint8) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint8(func(index int, val uint8) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupUint8 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]uint8.
0000000000000000000000000000000000000000;;	func (v *Value) GroupUint8(grouper func(int, uint8) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]uint8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint8(func(index int, val uint8) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]uint8, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceUint8 uses the specified function to replace each uint8s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []uint8 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceUint8(replacer func(int, uint8) uint8) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint8Slice()
0000000000000000000000000000000000000000;;		replaced := make([]uint8, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint8(func(index int, val uint8) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectUint8 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the uint8s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectUint8(collector func(int, uint8) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint8Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint8(func(index int, val uint8) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Uint16 (uint16 and []uint16)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint16 gets the value as a uint16, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Uint16(optionalDefault ...uint16) uint16 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(uint16); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint16 gets the value as a uint16.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a uint16.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint16() uint16 {
0000000000000000000000000000000000000000;;		return v.data.(uint16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint16Slice gets the value as a []uint16, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []uint16.
0000000000000000000000000000000000000000;;	func (v *Value) Uint16Slice(optionalDefault ...[]uint16) []uint16 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]uint16); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint16Slice gets the value as a []uint16.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []uint16.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint16Slice() []uint16 {
0000000000000000000000000000000000000000;;		return v.data.([]uint16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint16 gets whether the object contained is a uint16 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint16() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(uint16)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint16Slice gets whether the object contained is a []uint16 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint16Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]uint16)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachUint16 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []uint16.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachUint16(callback func(int, uint16) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustUint16Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereUint16 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []uint16.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereUint16(decider func(int, uint16) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint16(func(index int, val uint16) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupUint16 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]uint16.
0000000000000000000000000000000000000000;;	func (v *Value) GroupUint16(grouper func(int, uint16) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]uint16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint16(func(index int, val uint16) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]uint16, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceUint16 uses the specified function to replace each uint16s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []uint16 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceUint16(replacer func(int, uint16) uint16) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint16Slice()
0000000000000000000000000000000000000000;;		replaced := make([]uint16, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint16(func(index int, val uint16) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectUint16 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the uint16s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectUint16(collector func(int, uint16) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint16Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint16(func(index int, val uint16) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Uint32 (uint32 and []uint32)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint32 gets the value as a uint32, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Uint32(optionalDefault ...uint32) uint32 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(uint32); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint32 gets the value as a uint32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a uint32.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint32() uint32 {
0000000000000000000000000000000000000000;;		return v.data.(uint32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint32Slice gets the value as a []uint32, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []uint32.
0000000000000000000000000000000000000000;;	func (v *Value) Uint32Slice(optionalDefault ...[]uint32) []uint32 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]uint32); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint32Slice gets the value as a []uint32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []uint32.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint32Slice() []uint32 {
0000000000000000000000000000000000000000;;		return v.data.([]uint32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint32 gets whether the object contained is a uint32 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint32() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(uint32)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint32Slice gets whether the object contained is a []uint32 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint32Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]uint32)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachUint32 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []uint32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachUint32(callback func(int, uint32) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustUint32Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereUint32 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []uint32.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereUint32(decider func(int, uint32) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint32(func(index int, val uint32) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupUint32 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]uint32.
0000000000000000000000000000000000000000;;	func (v *Value) GroupUint32(grouper func(int, uint32) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]uint32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint32(func(index int, val uint32) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]uint32, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceUint32 uses the specified function to replace each uint32s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []uint32 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceUint32(replacer func(int, uint32) uint32) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint32Slice()
0000000000000000000000000000000000000000;;		replaced := make([]uint32, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint32(func(index int, val uint32) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectUint32 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the uint32s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectUint32(collector func(int, uint32) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint32Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint32(func(index int, val uint32) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Uint64 (uint64 and []uint64)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint64 gets the value as a uint64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Uint64(optionalDefault ...uint64) uint64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(uint64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint64 gets the value as a uint64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a uint64.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint64() uint64 {
0000000000000000000000000000000000000000;;		return v.data.(uint64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uint64Slice gets the value as a []uint64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []uint64.
0000000000000000000000000000000000000000;;	func (v *Value) Uint64Slice(optionalDefault ...[]uint64) []uint64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]uint64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUint64Slice gets the value as a []uint64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []uint64.
0000000000000000000000000000000000000000;;	func (v *Value) MustUint64Slice() []uint64 {
0000000000000000000000000000000000000000;;		return v.data.([]uint64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint64 gets whether the object contained is a uint64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint64() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(uint64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUint64Slice gets whether the object contained is a []uint64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUint64Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]uint64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachUint64 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []uint64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachUint64(callback func(int, uint64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustUint64Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereUint64 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []uint64.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereUint64(decider func(int, uint64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint64(func(index int, val uint64) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupUint64 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]uint64.
0000000000000000000000000000000000000000;;	func (v *Value) GroupUint64(grouper func(int, uint64) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint64(func(index int, val uint64) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]uint64, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceUint64 uses the specified function to replace each uint64s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []uint64 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceUint64(replacer func(int, uint64) uint64) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint64Slice()
0000000000000000000000000000000000000000;;		replaced := make([]uint64, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint64(func(index int, val uint64) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectUint64 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the uint64s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectUint64(collector func(int, uint64) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUint64Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUint64(func(index int, val uint64) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Uintptr (uintptr and []uintptr)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Uintptr gets the value as a uintptr, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Uintptr(optionalDefault ...uintptr) uintptr {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(uintptr); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUintptr gets the value as a uintptr.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a uintptr.
0000000000000000000000000000000000000000;;	func (v *Value) MustUintptr() uintptr {
0000000000000000000000000000000000000000;;		return v.data.(uintptr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UintptrSlice gets the value as a []uintptr, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []uintptr.
0000000000000000000000000000000000000000;;	func (v *Value) UintptrSlice(optionalDefault ...[]uintptr) []uintptr {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]uintptr); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustUintptrSlice gets the value as a []uintptr.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []uintptr.
0000000000000000000000000000000000000000;;	func (v *Value) MustUintptrSlice() []uintptr {
0000000000000000000000000000000000000000;;		return v.data.([]uintptr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUintptr gets whether the object contained is a uintptr or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUintptr() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(uintptr)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUintptrSlice gets whether the object contained is a []uintptr or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsUintptrSlice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]uintptr)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachUintptr calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []uintptr.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachUintptr(callback func(int, uintptr) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustUintptrSlice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereUintptr uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []uintptr.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereUintptr(decider func(int, uintptr) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUintptr(func(index int, val uintptr) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupUintptr uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]uintptr.
0000000000000000000000000000000000000000;;	func (v *Value) GroupUintptr(grouper func(int, uintptr) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]uintptr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUintptr(func(index int, val uintptr) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]uintptr, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceUintptr uses the specified function to replace each uintptrs
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []uintptr containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceUintptr(replacer func(int, uintptr) uintptr) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUintptrSlice()
0000000000000000000000000000000000000000;;		replaced := make([]uintptr, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUintptr(func(index int, val uintptr) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectUintptr uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the uintptrs in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectUintptr(collector func(int, uintptr) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustUintptrSlice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachUintptr(func(index int, val uintptr) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Float32 (float32 and []float32)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float32 gets the value as a float32, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Float32(optionalDefault ...float32) float32 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(float32); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFloat32 gets the value as a float32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a float32.
0000000000000000000000000000000000000000;;	func (v *Value) MustFloat32() float32 {
0000000000000000000000000000000000000000;;		return v.data.(float32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float32Slice gets the value as a []float32, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []float32.
0000000000000000000000000000000000000000;;	func (v *Value) Float32Slice(optionalDefault ...[]float32) []float32 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]float32); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFloat32Slice gets the value as a []float32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []float32.
0000000000000000000000000000000000000000;;	func (v *Value) MustFloat32Slice() []float32 {
0000000000000000000000000000000000000000;;		return v.data.([]float32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFloat32 gets whether the object contained is a float32 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsFloat32() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(float32)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFloat32Slice gets whether the object contained is a []float32 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsFloat32Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]float32)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachFloat32 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []float32.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachFloat32(callback func(int, float32) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustFloat32Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereFloat32 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []float32.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereFloat32(decider func(int, float32) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []float32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat32(func(index int, val float32) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupFloat32 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]float32.
0000000000000000000000000000000000000000;;	func (v *Value) GroupFloat32(grouper func(int, float32) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]float32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat32(func(index int, val float32) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]float32, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceFloat32 uses the specified function to replace each float32s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []float32 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceFloat32(replacer func(int, float32) float32) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustFloat32Slice()
0000000000000000000000000000000000000000;;		replaced := make([]float32, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat32(func(index int, val float32) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectFloat32 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the float32s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectFloat32(collector func(int, float32) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustFloat32Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat32(func(index int, val float32) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Float64 (float64 and []float64)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float64 gets the value as a float64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Float64(optionalDefault ...float64) float64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(float64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFloat64 gets the value as a float64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a float64.
0000000000000000000000000000000000000000;;	func (v *Value) MustFloat64() float64 {
0000000000000000000000000000000000000000;;		return v.data.(float64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float64Slice gets the value as a []float64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []float64.
0000000000000000000000000000000000000000;;	func (v *Value) Float64Slice(optionalDefault ...[]float64) []float64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]float64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFloat64Slice gets the value as a []float64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []float64.
0000000000000000000000000000000000000000;;	func (v *Value) MustFloat64Slice() []float64 {
0000000000000000000000000000000000000000;;		return v.data.([]float64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFloat64 gets whether the object contained is a float64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsFloat64() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(float64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFloat64Slice gets whether the object contained is a []float64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsFloat64Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]float64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachFloat64 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []float64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachFloat64(callback func(int, float64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustFloat64Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereFloat64 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []float64.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereFloat64(decider func(int, float64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat64(func(index int, val float64) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupFloat64 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]float64.
0000000000000000000000000000000000000000;;	func (v *Value) GroupFloat64(grouper func(int, float64) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]float64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat64(func(index int, val float64) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]float64, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceFloat64 uses the specified function to replace each float64s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []float64 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceFloat64(replacer func(int, float64) float64) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustFloat64Slice()
0000000000000000000000000000000000000000;;		replaced := make([]float64, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat64(func(index int, val float64) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectFloat64 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the float64s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectFloat64(collector func(int, float64) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustFloat64Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachFloat64(func(index int, val float64) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Complex64 (complex64 and []complex64)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complex64 gets the value as a complex64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Complex64(optionalDefault ...complex64) complex64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(complex64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustComplex64 gets the value as a complex64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a complex64.
0000000000000000000000000000000000000000;;	func (v *Value) MustComplex64() complex64 {
0000000000000000000000000000000000000000;;		return v.data.(complex64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complex64Slice gets the value as a []complex64, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []complex64.
0000000000000000000000000000000000000000;;	func (v *Value) Complex64Slice(optionalDefault ...[]complex64) []complex64 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]complex64); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustComplex64Slice gets the value as a []complex64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []complex64.
0000000000000000000000000000000000000000;;	func (v *Value) MustComplex64Slice() []complex64 {
0000000000000000000000000000000000000000;;		return v.data.([]complex64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsComplex64 gets whether the object contained is a complex64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsComplex64() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(complex64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsComplex64Slice gets whether the object contained is a []complex64 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsComplex64Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]complex64)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachComplex64 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []complex64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachComplex64(callback func(int, complex64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustComplex64Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereComplex64 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []complex64.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereComplex64(decider func(int, complex64) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []complex64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex64(func(index int, val complex64) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupComplex64 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]complex64.
0000000000000000000000000000000000000000;;	func (v *Value) GroupComplex64(grouper func(int, complex64) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]complex64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex64(func(index int, val complex64) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]complex64, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceComplex64 uses the specified function to replace each complex64s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []complex64 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceComplex64(replacer func(int, complex64) complex64) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustComplex64Slice()
0000000000000000000000000000000000000000;;		replaced := make([]complex64, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex64(func(index int, val complex64) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectComplex64 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the complex64s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectComplex64(collector func(int, complex64) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustComplex64Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex64(func(index int, val complex64) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Complex128 (complex128 and []complex128)
0000000000000000000000000000000000000000;;		--------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complex128 gets the value as a complex128, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or a system default object if the value is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) Complex128(optionalDefault ...complex128) complex128 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.(complex128); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustComplex128 gets the value as a complex128.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a complex128.
0000000000000000000000000000000000000000;;	func (v *Value) MustComplex128() complex128 {
0000000000000000000000000000000000000000;;		return v.data.(complex128)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complex128Slice gets the value as a []complex128, returns the optionalDefault
0000000000000000000000000000000000000000;;	// value or nil if the value is not a []complex128.
0000000000000000000000000000000000000000;;	func (v *Value) Complex128Slice(optionalDefault ...[]complex128) []complex128 {
0000000000000000000000000000000000000000;;		if s, ok := v.data.([]complex128); ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(optionalDefault) == 1 {
0000000000000000000000000000000000000000;;			return optionalDefault[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustComplex128Slice gets the value as a []complex128.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is not a []complex128.
0000000000000000000000000000000000000000;;	func (v *Value) MustComplex128Slice() []complex128 {
0000000000000000000000000000000000000000;;		return v.data.([]complex128)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsComplex128 gets whether the object contained is a complex128 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsComplex128() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.(complex128)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsComplex128Slice gets whether the object contained is a []complex128 or not.
0000000000000000000000000000000000000000;;	func (v *Value) IsComplex128Slice() bool {
0000000000000000000000000000000000000000;;		_, ok := v.data.([]complex128)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachComplex128 calls the specified callback for each object
0000000000000000000000000000000000000000;;	// in the []complex128.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Panics if the object is the wrong type.
0000000000000000000000000000000000000000;;	func (v *Value) EachComplex128(callback func(int, complex128) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, val := range v.MustComplex128Slice() {
0000000000000000000000000000000000000000;;			carryon := callback(index, val)
0000000000000000000000000000000000000000;;			if carryon == false {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhereComplex128 uses the specified decider function to select items
0000000000000000000000000000000000000000;;	// from the []complex128.  The object contained in the result will contain
0000000000000000000000000000000000000000;;	// only the selected items.
0000000000000000000000000000000000000000;;	func (v *Value) WhereComplex128(decider func(int, complex128) bool) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var selected []complex128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex128(func(index int, val complex128) bool {
0000000000000000000000000000000000000000;;			shouldSelect := decider(index, val)
0000000000000000000000000000000000000000;;			if shouldSelect == false {
0000000000000000000000000000000000000000;;				selected = append(selected, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: selected}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupComplex128 uses the specified grouper function to group the items
0000000000000000000000000000000000000000;;	// keyed by the return of the grouper.  The object contained in the
0000000000000000000000000000000000000000;;	// result will contain a map[string][]complex128.
0000000000000000000000000000000000000000;;	func (v *Value) GroupComplex128(grouper func(int, complex128) string) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groups := make(map[string][]complex128)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex128(func(index int, val complex128) bool {
0000000000000000000000000000000000000000;;			group := grouper(index, val)
0000000000000000000000000000000000000000;;			if _, ok := groups[group]; !ok {
0000000000000000000000000000000000000000;;				groups[group] = make([]complex128, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			groups[group] = append(groups[group], val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: groups}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceComplex128 uses the specified function to replace each complex128s
0000000000000000000000000000000000000000;;	// by iterating each item.  The data in the returned result will be a
0000000000000000000000000000000000000000;;	// []complex128 containing the replaced items.
0000000000000000000000000000000000000000;;	func (v *Value) ReplaceComplex128(replacer func(int, complex128) complex128) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustComplex128Slice()
0000000000000000000000000000000000000000;;		replaced := make([]complex128, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex128(func(index int, val complex128) bool {
0000000000000000000000000000000000000000;;			replaced[index] = replacer(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: replaced}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectComplex128 uses the specified collector function to collect a value
0000000000000000000000000000000000000000;;	// for each of the complex128s in the slice.  The data returned will be a
0000000000000000000000000000000000000000;;	// []interface{}.
0000000000000000000000000000000000000000;;	func (v *Value) CollectComplex128(collector func(int, complex128) interface{}) *Value {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		arr := v.MustComplex128Slice()
0000000000000000000000000000000000000000;;		collected := make([]interface{}, len(arr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.EachComplex128(func(index int, val complex128) bool {
0000000000000000000000000000000000000000;;			collected[index] = collector(index, val)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Value{data: collected}
0000000000000000000000000000000000000000;;	}
