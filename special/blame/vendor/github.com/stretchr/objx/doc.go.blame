0000000000000000000000000000000000000000;;	// objx - Go package for dealing with maps, slices, JSON and other data.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Overview
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Objx provides the `objx.Map` type, which is a `map[string]interface{}` that exposes
0000000000000000000000000000000000000000;;	// a powerful `Get` method (among others) that allows you to easily and quickly get
0000000000000000000000000000000000000000;;	// access to data within the map, without having to worry too much about type assertions,
0000000000000000000000000000000000000000;;	// missing data, default values etc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Pattern
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Objx uses a preditable pattern to make access data from within `map[string]interface{}'s
0000000000000000000000000000000000000000;;	// easy.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Call one of the `objx.` functions to create your `objx.Map` to get going:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     m, err := objx.FromJSON(json)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Any methods or functions with the `Must` prefix will panic if something goes wrong,
0000000000000000000000000000000000000000;;	// the rest will be optimistic and try to figure things out without panicking.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use `Get` to access the value you're interested in.  You can use dot and array
0000000000000000000000000000000000000000;;	// notation too:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     m.Get("places[0].latlng")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Once you have saught the `Value` you're interested in, you can use the `Is*` methods
0000000000000000000000000000000000000000;;	// to determine its type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     if m.Get("code").IsStr() { /* ... */ }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Or you can just assume the type, and use one of the strong type methods to
0000000000000000000000000000000000000000;;	// extract the real value:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     m.Get("code").Int()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If there's no value there (or if it's the wrong type) then a default value
0000000000000000000000000000000000000000;;	// will be returned, or you can be explicit about the default value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     Get("code").Int(-1)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you're dealing with a slice of data as a value, Objx provides many useful
0000000000000000000000000000000000000000;;	// methods for iterating, manipulating and selecting that data.  You can find out more
0000000000000000000000000000000000000000;;	// by exploring the index below.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Reading data
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A simple example of how to use Objx:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // use MustFromJSON to make an objx.Map from some JSON
0000000000000000000000000000000000000000;;	//     m := objx.MustFromJSON(`{"name": "Mat", "age": 30}`)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // get the details
0000000000000000000000000000000000000000;;	//     name := m.Get("name").Str()
0000000000000000000000000000000000000000;;	//     age := m.Get("age").Int()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // get their nickname (or use their name if they
0000000000000000000000000000000000000000;;	//     // don't have one)
0000000000000000000000000000000000000000;;	//     nickname := m.Get("nickname").Str(name)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Ranging
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Since `objx.Map` is a `map[string]interface{}` you can treat it as such.  For
0000000000000000000000000000000000000000;;	// example, to `range` the data, do what you would expect:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     m := objx.MustFromJSON(json)
0000000000000000000000000000000000000000;;	//     for key, value := range m {
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       /* ... do your magic ... */
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	package objx
