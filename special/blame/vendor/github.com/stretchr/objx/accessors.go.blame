0000000000000000000000000000000000000000;;	package objx
3cf0baf74e8a07b2c54564947f6896a529cec0c7;third_party/src/github.com/stretchr/objx/accessors.go[third_party/src/github.com/stretchr/objx/accessors.go][vendor/github.com/stretchr/objx/accessors.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// arrayAccesRegexString is the regex used to extract the array number
0000000000000000000000000000000000000000;;	// from the access path
0000000000000000000000000000000000000000;;	const arrayAccesRegexString = `^(.+)\[([0-9]+)\]$`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// arrayAccesRegex is the compiled arrayAccesRegexString
0000000000000000000000000000000000000000;;	var arrayAccesRegex = regexp.MustCompile(arrayAccesRegexString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get gets the value using the specified selector and
0000000000000000000000000000000000000000;;	// returns it inside a new Obj object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If it cannot find the value, Get will return a nil
0000000000000000000000000000000000000000;;	// value inside an instance of Obj.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Get can only operate directly on map[string]interface{} and []interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To access the title of the third chapter of the second book, do:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    o.Get("books[1].chapters[2].title")
0000000000000000000000000000000000000000;;	func (m Map) Get(selector string) *Value {
0000000000000000000000000000000000000000;;		rawObj := access(m, selector, nil, false, false)
0000000000000000000000000000000000000000;;		return &Value{data: rawObj}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets the value using the specified selector and
0000000000000000000000000000000000000000;;	// returns the object on which Set was called.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Set can only operate directly on map[string]interface{} and []interface
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To set the title of the third chapter of the second book, do:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    o.Set("books[1].chapters[2].title","Time to Go")
0000000000000000000000000000000000000000;;	func (m Map) Set(selector string, value interface{}) Map {
0000000000000000000000000000000000000000;;		access(m, selector, value, true, false)
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// access accesses the object using the selector and performs the
0000000000000000000000000000000000000000;;	// appropriate action.
0000000000000000000000000000000000000000;;	func access(current, selector, value interface{}, isSet, panics bool) interface{} {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch selector.(type) {
0000000000000000000000000000000000000000;;		case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if array, ok := current.([]interface{}); ok {
0000000000000000000000000000000000000000;;				index := intFromInterface(selector)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if index >= len(array) {
0000000000000000000000000000000000000000;;					if panics {
0000000000000000000000000000000000000000;;						panic(fmt.Sprintf("objx: Index %d is out of range. Slice only contains %d items.", index, len(array)))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return array[index]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			selStr := selector.(string)
0000000000000000000000000000000000000000;;			selSegs := strings.SplitN(selStr, PathSeparator, 2)
0000000000000000000000000000000000000000;;			thisSel := selSegs[0]
0000000000000000000000000000000000000000;;			index := -1
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// https://github.com/stretchr/objx/issues/12
0000000000000000000000000000000000000000;;			if strings.Contains(thisSel, "[") {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				arrayMatches := arrayAccesRegex.FindStringSubmatch(thisSel)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(arrayMatches) > 0 {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Get the key into the map
0000000000000000000000000000000000000000;;					thisSel = arrayMatches[1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Get the index into the array at the key
0000000000000000000000000000000000000000;;					index, err = strconv.Atoi(arrayMatches[2])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// This should never happen. If it does, something has gone
0000000000000000000000000000000000000000;;						// seriously wrong. Panic.
0000000000000000000000000000000000000000;;						panic("objx: Array index is not an integer.  Must use array[int].")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if curMap, ok := current.(Map); ok {
0000000000000000000000000000000000000000;;				current = map[string]interface{}(curMap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// get the object in question
0000000000000000000000000000000000000000;;			switch current.(type) {
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				curMSI := current.(map[string]interface{})
0000000000000000000000000000000000000000;;				if len(selSegs) <= 1 && isSet {
0000000000000000000000000000000000000000;;					curMSI[thisSel] = value
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					current = curMSI[thisSel]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				current = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if current == nil && panics {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("objx: '%v' invalid on object.", selector))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// do we need to access the item of an array?
0000000000000000000000000000000000000000;;			if index > -1 {
0000000000000000000000000000000000000000;;				if array, ok := current.([]interface{}); ok {
0000000000000000000000000000000000000000;;					if index < len(array) {
0000000000000000000000000000000000000000;;						current = array[index]
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if panics {
0000000000000000000000000000000000000000;;							panic(fmt.Sprintf("objx: Index %d is out of range. Slice only contains %d items.", index, len(array)))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						current = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(selSegs) > 1 {
0000000000000000000000000000000000000000;;				current = access(current, selSegs[1], value, isSet, panics)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return current
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// intFromInterface converts an interface object to the largest
0000000000000000000000000000000000000000;;	// representation of an unsigned integer using a type switch and
0000000000000000000000000000000000000000;;	// assertions
0000000000000000000000000000000000000000;;	func intFromInterface(selector interface{}) int {
0000000000000000000000000000000000000000;;		var value int
0000000000000000000000000000000000000000;;		switch selector.(type) {
0000000000000000000000000000000000000000;;		case int:
0000000000000000000000000000000000000000;;			value = selector.(int)
0000000000000000000000000000000000000000;;		case int8:
0000000000000000000000000000000000000000;;			value = int(selector.(int8))
0000000000000000000000000000000000000000;;		case int16:
0000000000000000000000000000000000000000;;			value = int(selector.(int16))
0000000000000000000000000000000000000000;;		case int32:
0000000000000000000000000000000000000000;;			value = int(selector.(int32))
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			value = int(selector.(int64))
0000000000000000000000000000000000000000;;		case uint:
0000000000000000000000000000000000000000;;			value = int(selector.(uint))
0000000000000000000000000000000000000000;;		case uint8:
0000000000000000000000000000000000000000;;			value = int(selector.(uint8))
0000000000000000000000000000000000000000;;		case uint16:
0000000000000000000000000000000000000000;;			value = int(selector.(uint16))
0000000000000000000000000000000000000000;;		case uint32:
0000000000000000000000000000000000000000;;			value = int(selector.(uint32))
0000000000000000000000000000000000000000;;		case uint64:
0000000000000000000000000000000000000000;;			value = int(selector.(uint64))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("objx: array access argument is not an integer type (this should never happen)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
