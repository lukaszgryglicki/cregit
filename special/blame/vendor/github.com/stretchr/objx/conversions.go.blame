0000000000000000000000000000000000000000;;	package objx
3cf0baf74e8a07b2c54564947f6896a529cec0c7;third_party/src/github.com/stretchr/objx/conversions.go[third_party/src/github.com/stretchr/objx/conversions.go][vendor/github.com/stretchr/objx/conversions.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSON converts the contained object to a JSON string
0000000000000000000000000000000000000000;;	// representation
0000000000000000000000000000000000000000;;	func (m Map) JSON() (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err := json.Marshal(m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = errors.New("objx: JSON encode failed with: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(result), err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustJSON converts the contained object to a JSON string
0000000000000000000000000000000000000000;;	// representation and panics if there is an error
0000000000000000000000000000000000000000;;	func (m Map) MustJSON() string {
0000000000000000000000000000000000000000;;		result, err := m.JSON()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Base64 converts the contained object to a Base64 string
0000000000000000000000000000000000000000;;	// representation of the JSON string representation
0000000000000000000000000000000000000000;;	func (m Map) Base64() (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonData, err := m.JSON()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoder := base64.NewEncoder(base64.StdEncoding, &buf)
0000000000000000000000000000000000000000;;		encoder.Write([]byte(jsonData))
0000000000000000000000000000000000000000;;		encoder.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.String(), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustBase64 converts the contained object to a Base64 string
0000000000000000000000000000000000000000;;	// representation of the JSON string representation and panics
0000000000000000000000000000000000000000;;	// if there is an error
0000000000000000000000000000000000000000;;	func (m Map) MustBase64() string {
0000000000000000000000000000000000000000;;		result, err := m.Base64()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignedBase64 converts the contained object to a Base64 string
0000000000000000000000000000000000000000;;	// representation of the JSON string representation and signs it
0000000000000000000000000000000000000000;;	// using the provided key.
0000000000000000000000000000000000000000;;	func (m Map) SignedBase64(key string) (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		base64, err := m.Base64()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sig := HashWithKey(base64, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return base64 + SignatureSeparator + sig, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustSignedBase64 converts the contained object to a Base64 string
0000000000000000000000000000000000000000;;	// representation of the JSON string representation and signs it
0000000000000000000000000000000000000000;;	// using the provided key and panics if there is an error
0000000000000000000000000000000000000000;;	func (m Map) MustSignedBase64(key string) string {
0000000000000000000000000000000000000000;;		result, err := m.SignedBase64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		URL Query
0000000000000000000000000000000000000000;;		------------------------------------------------
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLValues creates a url.Values object from an Obj. This
0000000000000000000000000000000000000000;;	// function requires that the wrapped object be a map[string]interface{}
0000000000000000000000000000000000000000;;	func (m Map) URLValues() url.Values {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vals := make(url.Values)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			//TODO: can this be done without sprintf?
0000000000000000000000000000000000000000;;			vals.Set(k, fmt.Sprintf("%v", v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLQuery gets an encoded URL query representing the given
0000000000000000000000000000000000000000;;	// Obj. This function requires that the wrapped object be a
0000000000000000000000000000000000000000;;	// map[string]interface{}
0000000000000000000000000000000000000000;;	func (m Map) URLQuery() (string, error) {
0000000000000000000000000000000000000000;;		return m.URLValues().Encode(), nil
0000000000000000000000000000000000000000;;	}
