0000000000000000000000000000000000000000;;	// Package quantile computes approximate quantiles over an unbounded data
0000000000000000000000000000000000000000;;	// stream within low memory and CPU bounds.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A small amount of accuracy is traded to achieve the above properties.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Multiple streams can be merged before calling Query to generate a single set
0000000000000000000000000000000000000000;;	// of results. This is meaningful when the streams represent the same type of
0000000000000000000000000000000000000000;;	// data. See Merge and Samples.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more detailed information about the algorithm used, see:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Effective Computation of Biased Quantiles over Data Streams
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.cs.rutgers.edu/~muthu/bquant.pdf
0000000000000000000000000000000000000000;;	package quantile
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/prometheus/client_golang/_vendor/perks/quantile/stream.go[Godeps/_workspace/src/github.com/prometheus/client_golang/_vendor/perks/quantile/stream.go][vendor/github.com/beorn7/perks/quantile/stream.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sample holds an observed value and meta information for compression. JSON
0000000000000000000000000000000000000000;;	// tags have been added for convenience.
0000000000000000000000000000000000000000;;	type Sample struct {
0000000000000000000000000000000000000000;;		Value float64 `json:",string"`
0000000000000000000000000000000000000000;;		Width float64 `json:",string"`
0000000000000000000000000000000000000000;;		Delta float64 `json:",string"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Samples represents a slice of samples. It implements sort.Interface.
0000000000000000000000000000000000000000;;	type Samples []Sample
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Samples) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a Samples) Less(i, j int) bool { return a[i].Value < a[j].Value }
0000000000000000000000000000000000000000;;	func (a Samples) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type invariant func(s *stream, r float64) float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLowBiased returns an initialized Stream for low-biased quantiles
0000000000000000000000000000000000000000;;	// (e.g. 0.01, 0.1, 0.5) where the needed quantiles are not known a priori, but
0000000000000000000000000000000000000000;;	// error guarantees can still be given even for the lower ranks of the data
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The provided epsilon is a relative error, i.e. the true quantile of a value
0000000000000000000000000000000000000000;;	// returned by a query is guaranteed to be within (1±Epsilon)*Quantile.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://www.cs.rutgers.edu/~muthu/bquant.pdf for time, space, and error
0000000000000000000000000000000000000000;;	// properties.
0000000000000000000000000000000000000000;;	func NewLowBiased(epsilon float64) *Stream {
0000000000000000000000000000000000000000;;		ƒ := func(s *stream, r float64) float64 {
0000000000000000000000000000000000000000;;			return 2 * epsilon * r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newStream(ƒ)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHighBiased returns an initialized Stream for high-biased quantiles
0000000000000000000000000000000000000000;;	// (e.g. 0.01, 0.1, 0.5) where the needed quantiles are not known a priori, but
0000000000000000000000000000000000000000;;	// error guarantees can still be given even for the higher ranks of the data
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The provided epsilon is a relative error, i.e. the true quantile of a value
0000000000000000000000000000000000000000;;	// returned by a query is guaranteed to be within 1-(1±Epsilon)*(1-Quantile).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://www.cs.rutgers.edu/~muthu/bquant.pdf for time, space, and error
0000000000000000000000000000000000000000;;	// properties.
0000000000000000000000000000000000000000;;	func NewHighBiased(epsilon float64) *Stream {
0000000000000000000000000000000000000000;;		ƒ := func(s *stream, r float64) float64 {
0000000000000000000000000000000000000000;;			return 2 * epsilon * (s.n - r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newStream(ƒ)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTargeted returns an initialized Stream concerned with a particular set of
0000000000000000000000000000000000000000;;	// quantile values that are supplied a priori. Knowing these a priori reduces
0000000000000000000000000000000000000000;;	// space and computation time. The targets map maps the desired quantiles to
0000000000000000000000000000000000000000;;	// their absolute errors, i.e. the true quantile of a value returned by a query
0000000000000000000000000000000000000000;;	// is guaranteed to be within (Quantile±Epsilon).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://www.cs.rutgers.edu/~muthu/bquant.pdf for time, space, and error properties.
0000000000000000000000000000000000000000;;	func NewTargeted(targets map[float64]float64) *Stream {
0000000000000000000000000000000000000000;;		ƒ := func(s *stream, r float64) float64 {
0000000000000000000000000000000000000000;;			var m = math.MaxFloat64
0000000000000000000000000000000000000000;;			var f float64
0000000000000000000000000000000000000000;;			for quantile, epsilon := range targets {
0000000000000000000000000000000000000000;;				if quantile*s.n <= r {
0000000000000000000000000000000000000000;;					f = (2 * epsilon * r) / quantile
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					f = (2 * epsilon * (s.n - r)) / (1 - quantile)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if f < m {
0000000000000000000000000000000000000000;;					m = f
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newStream(ƒ)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stream computes quantiles for a stream of float64s. It is not thread-safe by
0000000000000000000000000000000000000000;;	// design. Take care when using across multiple goroutines.
0000000000000000000000000000000000000000;;	type Stream struct {
0000000000000000000000000000000000000000;;		*stream
0000000000000000000000000000000000000000;;		b      Samples
0000000000000000000000000000000000000000;;		sorted bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStream(ƒ invariant) *Stream {
0000000000000000000000000000000000000000;;		x := &stream{ƒ: ƒ}
0000000000000000000000000000000000000000;;		return &Stream{x, make(Samples, 0, 500), true}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert inserts v into the stream.
0000000000000000000000000000000000000000;;	func (s *Stream) Insert(v float64) {
0000000000000000000000000000000000000000;;		s.insert(Sample{Value: v, Width: 1})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) insert(sample Sample) {
0000000000000000000000000000000000000000;;		s.b = append(s.b, sample)
0000000000000000000000000000000000000000;;		s.sorted = false
0000000000000000000000000000000000000000;;		if len(s.b) == cap(s.b) {
0000000000000000000000000000000000000000;;			s.flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query returns the computed qth percentiles value. If s was created with
0000000000000000000000000000000000000000;;	// NewTargeted, and q is not in the set of quantiles provided a priori, Query
0000000000000000000000000000000000000000;;	// will return an unspecified result.
0000000000000000000000000000000000000000;;	func (s *Stream) Query(q float64) float64 {
0000000000000000000000000000000000000000;;		if !s.flushed() {
0000000000000000000000000000000000000000;;			// Fast path when there hasn't been enough data for a flush;
0000000000000000000000000000000000000000;;			// this also yields better accuracy for small sets of data.
0000000000000000000000000000000000000000;;			l := len(s.b)
0000000000000000000000000000000000000000;;			if l == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i := int(float64(l) * q)
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				i -= 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.maybeSort()
0000000000000000000000000000000000000000;;			return s.b[i].Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.flush()
0000000000000000000000000000000000000000;;		return s.stream.query(q)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge merges samples into the underlying streams samples. This is handy when
0000000000000000000000000000000000000000;;	// merging multiple streams from separate threads, database shards, etc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ATTENTION: This method is broken and does not yield correct results. The
0000000000000000000000000000000000000000;;	// underlying algorithm is not capable of merging streams correctly.
0000000000000000000000000000000000000000;;	func (s *Stream) Merge(samples Samples) {
0000000000000000000000000000000000000000;;		sort.Sort(samples)
0000000000000000000000000000000000000000;;		s.stream.merge(samples)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset reinitializes and clears the list reusing the samples buffer memory.
0000000000000000000000000000000000000000;;	func (s *Stream) Reset() {
0000000000000000000000000000000000000000;;		s.stream.reset()
0000000000000000000000000000000000000000;;		s.b = s.b[:0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Samples returns stream samples held by s.
0000000000000000000000000000000000000000;;	func (s *Stream) Samples() Samples {
0000000000000000000000000000000000000000;;		if !s.flushed() {
0000000000000000000000000000000000000000;;			return s.b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.flush()
0000000000000000000000000000000000000000;;		return s.stream.samples()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Count returns the total number of samples observed in the stream
0000000000000000000000000000000000000000;;	// since initialization.
0000000000000000000000000000000000000000;;	func (s *Stream) Count() int {
0000000000000000000000000000000000000000;;		return len(s.b) + s.stream.count()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) flush() {
0000000000000000000000000000000000000000;;		s.maybeSort()
0000000000000000000000000000000000000000;;		s.stream.merge(s.b)
0000000000000000000000000000000000000000;;		s.b = s.b[:0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) maybeSort() {
0000000000000000000000000000000000000000;;		if !s.sorted {
0000000000000000000000000000000000000000;;			s.sorted = true
0000000000000000000000000000000000000000;;			sort.Sort(s.b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stream) flushed() bool {
0000000000000000000000000000000000000000;;		return len(s.stream.l) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stream struct {
0000000000000000000000000000000000000000;;		n float64
0000000000000000000000000000000000000000;;		l []Sample
0000000000000000000000000000000000000000;;		ƒ invariant
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stream) reset() {
0000000000000000000000000000000000000000;;		s.l = s.l[:0]
0000000000000000000000000000000000000000;;		s.n = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stream) insert(v float64) {
0000000000000000000000000000000000000000;;		s.merge(Samples{{v, 1, 0}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stream) merge(samples Samples) {
0000000000000000000000000000000000000000;;		// TODO(beorn7): This tries to merge not only individual samples, but
0000000000000000000000000000000000000000;;		// whole summaries. The paper doesn't mention merging summaries at
0000000000000000000000000000000000000000;;		// all. Unittests show that the merging is inaccurate. Find out how to
0000000000000000000000000000000000000000;;		// do merges properly.
0000000000000000000000000000000000000000;;		var r float64
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for _, sample := range samples {
0000000000000000000000000000000000000000;;			for ; i < len(s.l); i++ {
0000000000000000000000000000000000000000;;				c := s.l[i]
0000000000000000000000000000000000000000;;				if c.Value > sample.Value {
0000000000000000000000000000000000000000;;					// Insert at position i.
0000000000000000000000000000000000000000;;					s.l = append(s.l, Sample{})
0000000000000000000000000000000000000000;;					copy(s.l[i+1:], s.l[i:])
0000000000000000000000000000000000000000;;					s.l[i] = Sample{
0000000000000000000000000000000000000000;;						sample.Value,
0000000000000000000000000000000000000000;;						sample.Width,
0000000000000000000000000000000000000000;;						math.Max(sample.Delta, math.Floor(s.ƒ(s, r))-1),
0000000000000000000000000000000000000000;;						// TODO(beorn7): How to calculate delta correctly?
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					goto inserted
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r += c.Width
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.l = append(s.l, Sample{sample.Value, sample.Width, 0})
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		inserted:
0000000000000000000000000000000000000000;;			s.n += sample.Width
0000000000000000000000000000000000000000;;			r += sample.Width
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.compress()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stream) count() int {
0000000000000000000000000000000000000000;;		return int(s.n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stream) query(q float64) float64 {
0000000000000000000000000000000000000000;;		t := math.Ceil(q * s.n)
0000000000000000000000000000000000000000;;		t += math.Ceil(s.ƒ(s, t) / 2)
0000000000000000000000000000000000000000;;		p := s.l[0]
0000000000000000000000000000000000000000;;		var r float64
0000000000000000000000000000000000000000;;		for _, c := range s.l[1:] {
0000000000000000000000000000000000000000;;			r += p.Width
0000000000000000000000000000000000000000;;			if r+c.Width+c.Delta > t {
0000000000000000000000000000000000000000;;				return p.Value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stream) compress() {
0000000000000000000000000000000000000000;;		if len(s.l) < 2 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := s.l[len(s.l)-1]
0000000000000000000000000000000000000000;;		xi := len(s.l) - 1
0000000000000000000000000000000000000000;;		r := s.n - 1 - x.Width
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := len(s.l) - 2; i >= 0; i-- {
0000000000000000000000000000000000000000;;			c := s.l[i]
0000000000000000000000000000000000000000;;			if c.Width+x.Width+x.Delta <= s.ƒ(s, r) {
0000000000000000000000000000000000000000;;				x.Width += c.Width
0000000000000000000000000000000000000000;;				s.l[xi] = x
0000000000000000000000000000000000000000;;				// Remove element at i.
0000000000000000000000000000000000000000;;				copy(s.l[i:], s.l[i+1:])
0000000000000000000000000000000000000000;;				s.l = s.l[:len(s.l)-1]
0000000000000000000000000000000000000000;;				xi -= 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x = c
0000000000000000000000000000000000000000;;				xi = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r -= c.Width
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stream) samples() Samples {
0000000000000000000000000000000000000000;;		samples := make(Samples, len(s.l))
0000000000000000000000000000000000000000;;		copy(samples, s.l)
0000000000000000000000000000000000000000;;		return samples
0000000000000000000000000000000000000000;;	}
