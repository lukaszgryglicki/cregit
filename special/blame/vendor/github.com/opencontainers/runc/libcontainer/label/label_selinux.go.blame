0000000000000000000000000000000000000000;;	// +build selinux,linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/label/label_selinux.go[Godeps/_workspace/src/github.com/docker/libcontainer/label/label_selinux.go][vendor/github.com/opencontainers/runc/libcontainer/label/label_selinux.go];	
0000000000000000000000000000000000000000;;	package label
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/selinux"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid Label Options
0000000000000000000000000000000000000000;;	var validOptions = map[string]bool{
0000000000000000000000000000000000000000;;		"disable": true,
0000000000000000000000000000000000000000;;		"type":    true,
0000000000000000000000000000000000000000;;		"user":    true,
0000000000000000000000000000000000000000;;		"role":    true,
0000000000000000000000000000000000000000;;		"level":   true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrIncompatibleLabel = fmt.Errorf("Bad SELinux option z and Z can not be used together")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitLabels returns the process label and file labels to be used within
0000000000000000000000000000000000000000;;	// the container.  A list of options can be passed into this function to alter
0000000000000000000000000000000000000000;;	// the labels.  The labels returned will include a random MCS String, that is
0000000000000000000000000000000000000000;;	// guaranteed to be unique.
0000000000000000000000000000000000000000;;	func InitLabels(options []string) (string, string, error) {
0000000000000000000000000000000000000000;;		if !selinux.SelinuxEnabled() {
0000000000000000000000000000000000000000;;			return "", "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		processLabel, mountLabel := selinux.GetLxcContexts()
0000000000000000000000000000000000000000;;		if processLabel != "" {
0000000000000000000000000000000000000000;;			pcon := selinux.NewContext(processLabel)
0000000000000000000000000000000000000000;;			mcon := selinux.NewContext(mountLabel)
0000000000000000000000000000000000000000;;			for _, opt := range options {
0000000000000000000000000000000000000000;;				val := strings.SplitN(opt, "=", 2)
0000000000000000000000000000000000000000;;				if val[0] != "label" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(val) < 2 {
0000000000000000000000000000000000000000;;					return "", "", fmt.Errorf("bad label option %q, valid options 'disable' or \n'user, role, level, type' followed by ':' and a value", opt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if val[1] == "disable" {
0000000000000000000000000000000000000000;;					return "", "", nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				con := strings.SplitN(val[1], ":", 2)
0000000000000000000000000000000000000000;;				if len(con) < 2 || !validOptions[con[0]] {
0000000000000000000000000000000000000000;;					return "", "", fmt.Errorf("bad label option %q, valid options 'disable, user, role, level, type'", con[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pcon[con[0]] = con[1]
0000000000000000000000000000000000000000;;				if con[0] == "level" || con[0] == "user" {
0000000000000000000000000000000000000000;;					mcon[con[0]] = con[1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			processLabel = pcon.Get()
0000000000000000000000000000000000000000;;			mountLabel = mcon.Get()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return processLabel, mountLabel, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetROMountLabel() string {
0000000000000000000000000000000000000000;;		return selinux.GetROFileLabel()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DEPRECATED: The GenLabels function is only to be used during the transition to the official API.
0000000000000000000000000000000000000000;;	func GenLabels(options string) (string, string, error) {
0000000000000000000000000000000000000000;;		return InitLabels(strings.Fields(options))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatMountLabel returns a string to be used by the mount command.
0000000000000000000000000000000000000000;;	// The format of this string will be used to alter the labeling of the mountpoint.
0000000000000000000000000000000000000000;;	// The string returned is suitable to be used as the options field of the mount command.
0000000000000000000000000000000000000000;;	// If you need to have additional mount point options, you can pass them in as
0000000000000000000000000000000000000000;;	// the first parameter.  Second parameter is the label that you wish to apply
0000000000000000000000000000000000000000;;	// to all content in the mount point.
0000000000000000000000000000000000000000;;	func FormatMountLabel(src, mountLabel string) string {
0000000000000000000000000000000000000000;;		if mountLabel != "" {
0000000000000000000000000000000000000000;;			switch src {
0000000000000000000000000000000000000000;;			case "":
0000000000000000000000000000000000000000;;				src = fmt.Sprintf("context=%q", mountLabel)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				src = fmt.Sprintf("%s,context=%q", src, mountLabel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return src
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetProcessLabel takes a process label and tells the kernel to assign the
0000000000000000000000000000000000000000;;	// label to the next program executed by the current process.
0000000000000000000000000000000000000000;;	func SetProcessLabel(processLabel string) error {
0000000000000000000000000000000000000000;;		if processLabel == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selinux.Setexeccon(processLabel)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetProcessLabel returns the process label that the kernel will assign
0000000000000000000000000000000000000000;;	// to the next program executed by the current process.  If "" is returned
0000000000000000000000000000000000000000;;	// this indicates that the default labeling will happen for the process.
0000000000000000000000000000000000000000;;	func GetProcessLabel() (string, error) {
0000000000000000000000000000000000000000;;		return selinux.Getexeccon()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFileLabel returns the label for specified path
0000000000000000000000000000000000000000;;	func GetFileLabel(path string) (string, error) {
0000000000000000000000000000000000000000;;		return selinux.Getfilecon(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetFileLabel modifies the "path" label to the specified file label
0000000000000000000000000000000000000000;;	func SetFileLabel(path string, fileLabel string) error {
0000000000000000000000000000000000000000;;		if selinux.SelinuxEnabled() && fileLabel != "" {
0000000000000000000000000000000000000000;;			return selinux.Setfilecon(path, fileLabel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetFileCreateLabel tells the kernel the label for all files to be created
0000000000000000000000000000000000000000;;	func SetFileCreateLabel(fileLabel string) error {
0000000000000000000000000000000000000000;;		if selinux.SelinuxEnabled() {
0000000000000000000000000000000000000000;;			return selinux.Setfscreatecon(fileLabel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Relabel changes the label of path to the filelabel string.
0000000000000000000000000000000000000000;;	// It changes the MCS label to s0 if shared is true.
0000000000000000000000000000000000000000;;	// This will allow all containers to share the content.
0000000000000000000000000000000000000000;;	func Relabel(path string, fileLabel string, shared bool) error {
0000000000000000000000000000000000000000;;		if !selinux.SelinuxEnabled() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fileLabel == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exclude_paths := map[string]bool{"/": true, "/usr": true, "/etc": true}
0000000000000000000000000000000000000000;;		if exclude_paths[path] {
0000000000000000000000000000000000000000;;			return fmt.Errorf("SELinux relabeling of %s is not allowed", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if shared {
0000000000000000000000000000000000000000;;			c := selinux.NewContext(fileLabel)
0000000000000000000000000000000000000000;;			c["level"] = "s0"
0000000000000000000000000000000000000000;;			fileLabel = c.Get()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := selinux.Chcon(path, fileLabel, true); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("SELinux relabeling of %s is not allowed: %q", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPidLabel will return the label of the process running with the specified pid
0000000000000000000000000000000000000000;;	func GetPidLabel(pid int) (string, error) {
0000000000000000000000000000000000000000;;		return selinux.Getpidcon(pid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init initialises the labeling system
0000000000000000000000000000000000000000;;	func Init() {
0000000000000000000000000000000000000000;;		selinux.SelinuxEnabled()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReserveLabel will record the fact that the MCS label has already been used.
0000000000000000000000000000000000000000;;	// This will prevent InitLabels from using the MCS label in a newly created
0000000000000000000000000000000000000000;;	// container
0000000000000000000000000000000000000000;;	func ReserveLabel(label string) error {
0000000000000000000000000000000000000000;;		selinux.ReserveLabel(label)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnreserveLabel will remove the reservation of the MCS label.
0000000000000000000000000000000000000000;;	// This will allow InitLabels to use the MCS label in a newly created
0000000000000000000000000000000000000000;;	// containers
0000000000000000000000000000000000000000;;	func UnreserveLabel(label string) error {
0000000000000000000000000000000000000000;;		selinux.FreeLxcContexts(label)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DupSecOpt takes an process label and returns security options that
0000000000000000000000000000000000000000;;	// can be used to set duplicate labels on future container processes
0000000000000000000000000000000000000000;;	func DupSecOpt(src string) []string {
0000000000000000000000000000000000000000;;		return selinux.DupSecOpt(src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisableSecOpt returns a security opt that can disable labeling
0000000000000000000000000000000000000000;;	// support for future container processes
0000000000000000000000000000000000000000;;	func DisableSecOpt() []string {
0000000000000000000000000000000000000000;;		return selinux.DisableSecOpt()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks that the label does not include unexpected options
0000000000000000000000000000000000000000;;	func Validate(label string) error {
0000000000000000000000000000000000000000;;		if strings.Contains(label, "z") && strings.Contains(label, "Z") {
0000000000000000000000000000000000000000;;			return ErrIncompatibleLabel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RelabelNeeded checks whether the user requested a relabel
0000000000000000000000000000000000000000;;	func RelabelNeeded(label string) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(label, "z") || strings.Contains(label, "Z")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsShared checks that the label includes a "shared" mark
0000000000000000000000000000000000000000;;	func IsShared(label string) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(label, "z")
0000000000000000000000000000000000000000;;	}
