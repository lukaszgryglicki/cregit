0000000000000000000000000000000000000000;;	// +build linux
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/rootfs_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/rootfs_linux.go][vendor/github.com/opencontainers/runc/libcontainer/rootfs_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/mount"
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/symlink"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/label"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/system"
0000000000000000000000000000000000000000;;		libcontainerUtils "github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultMountFlags = syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// needsSetupDev returns true if /dev needs to be set up.
0000000000000000000000000000000000000000;;	func needsSetupDev(config *configs.Config) bool {
0000000000000000000000000000000000000000;;		for _, m := range config.Mounts {
0000000000000000000000000000000000000000;;			if m.Device == "bind" && libcontainerUtils.CleanPath(m.Destination) == "/dev" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setupRootfs sets up the devices, mount points, and filesystems for use inside a
0000000000000000000000000000000000000000;;	// new mount namespace.
0000000000000000000000000000000000000000;;	func setupRootfs(config *configs.Config, console *linuxConsole, pipe io.ReadWriter) (err error) {
0000000000000000000000000000000000000000;;		if err := prepareRoot(config); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "preparing rootfs")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setupDev := needsSetupDev(config)
0000000000000000000000000000000000000000;;		for _, m := range config.Mounts {
0000000000000000000000000000000000000000;;			for _, precmd := range m.PremountCmds {
0000000000000000000000000000000000000000;;				if err := mountCmd(precmd); err != nil {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "running premount command")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := mountToRootfs(m, config.Rootfs, config.MountLabel); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCausef(err, "mounting %q to rootfs %q at %q", m.Source, config.Rootfs, m.Destination)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, postcmd := range m.PostmountCmds {
0000000000000000000000000000000000000000;;				if err := mountCmd(postcmd); err != nil {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "running postmount command")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if setupDev {
0000000000000000000000000000000000000000;;			if err := createDevices(config); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "creating device nodes")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := setupPtmx(config, console); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "setting up ptmx")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := setupDevSymlinks(config.Rootfs); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "setting up /dev symlinks")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Signal the parent to run the pre-start hooks.
0000000000000000000000000000000000000000;;		// The hooks are run after the mounts are setup, but before we switch to the new
0000000000000000000000000000000000000000;;		// root, so that the old root is still available in the hooks for any mount
0000000000000000000000000000000000000000;;		// manipulations.
0000000000000000000000000000000000000000;;		if err := syncParentHooks(pipe); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Chdir(config.Rootfs); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCausef(err, "changing dir to %q", config.Rootfs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.NoPivotRoot {
0000000000000000000000000000000000000000;;			err = msMoveRoot(config.Rootfs)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = pivotRoot(config.Rootfs, config.PivotDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "jailing process inside rootfs")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if setupDev {
0000000000000000000000000000000000000000;;			if err := reOpenDevNull(); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "reopening /dev/null inside container")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// remount dev as ro if specified
0000000000000000000000000000000000000000;;		for _, m := range config.Mounts {
0000000000000000000000000000000000000000;;			if libcontainerUtils.CleanPath(m.Destination) == "/dev" {
0000000000000000000000000000000000000000;;				if m.Flags&syscall.MS_RDONLY != 0 {
0000000000000000000000000000000000000000;;					if err := remountReadonly(m.Destination); err != nil {
0000000000000000000000000000000000000000;;						return newSystemErrorWithCausef(err, "remounting %q as readonly", m.Destination)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// set rootfs ( / ) as readonly
0000000000000000000000000000000000000000;;		if config.Readonlyfs {
0000000000000000000000000000000000000000;;			if err := setReadonly(); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "setting rootfs as readonly")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syscall.Umask(0022)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mountCmd(cmd configs.Command) error {
0000000000000000000000000000000000000000;;		command := exec.Command(cmd.Path, cmd.Args[:]...)
0000000000000000000000000000000000000000;;		command.Env = cmd.Env
0000000000000000000000000000000000000000;;		command.Dir = cmd.Dir
0000000000000000000000000000000000000000;;		if out, err := command.CombinedOutput(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%#v failed: %s: %v", cmd, string(out), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mountToRootfs(m *configs.Mount, rootfs, mountLabel string) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dest = m.Destination
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(dest, rootfs) {
0000000000000000000000000000000000000000;;			dest = filepath.Join(rootfs, dest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch m.Device {
0000000000000000000000000000000000000000;;		case "proc", "sysfs":
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(dest, 0755); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Selinux kernels do not support labeling of /proc or /sys
0000000000000000000000000000000000000000;;			return mountPropagate(m, rootfs, "")
0000000000000000000000000000000000000000;;		case "mqueue":
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(dest, 0755); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := mountPropagate(m, rootfs, mountLabel); err != nil {
0000000000000000000000000000000000000000;;				// older kernels do not support labeling of /dev/mqueue
0000000000000000000000000000000000000000;;				if err := mountPropagate(m, rootfs, ""); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return label.SetFileLabel(dest, mountLabel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case "tmpfs":
0000000000000000000000000000000000000000;;			stat, err := os.Stat(dest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(dest, 0755); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := mountPropagate(m, rootfs, mountLabel); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat != nil {
0000000000000000000000000000000000000000;;				if err = os.Chmod(dest, stat.Mode()); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case "bind":
0000000000000000000000000000000000000000;;			stat, err := os.Stat(m.Source)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// error out if the source of a bind mount does not exist as we will be
0000000000000000000000000000000000000000;;				// unable to bind anything to it.
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ensure that the destination of the bind mount is resolved of symlinks at mount time because
0000000000000000000000000000000000000000;;			// any previous mounts can invalidate the next mount's destination.
0000000000000000000000000000000000000000;;			// this can happen when a user specifies mounts within other mounts to cause breakouts or other
0000000000000000000000000000000000000000;;			// evil stuff to try to escape the container's rootfs.
0000000000000000000000000000000000000000;;			if dest, err = symlink.FollowSymlinkInScope(filepath.Join(rootfs, m.Destination), rootfs); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := checkMountDestination(rootfs, dest); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// update the mount with the correct dest after symlinks are resolved.
0000000000000000000000000000000000000000;;			m.Destination = dest
0000000000000000000000000000000000000000;;			if err := createIfNotExists(dest, stat.IsDir()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := mountPropagate(m, rootfs, mountLabel); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bind mount won't change mount options, we need remount to make mount options effective.
0000000000000000000000000000000000000000;;			// first check that we have non-default options required before attempting a remount
0000000000000000000000000000000000000000;;			if m.Flags&^(syscall.MS_REC|syscall.MS_REMOUNT|syscall.MS_BIND) != 0 {
0000000000000000000000000000000000000000;;				// only remount if unique mount options are set
0000000000000000000000000000000000000000;;				if err := remount(m, rootfs); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m.Relabel != "" {
0000000000000000000000000000000000000000;;				if err := label.Validate(m.Relabel); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				shared := label.IsShared(m.Relabel)
0000000000000000000000000000000000000000;;				if err := label.Relabel(m.Source, mountLabel, shared); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "cgroup":
0000000000000000000000000000000000000000;;			binds, err := getCgroupMounts(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var merged []string
0000000000000000000000000000000000000000;;			for _, b := range binds {
0000000000000000000000000000000000000000;;				ss := filepath.Base(b.Destination)
0000000000000000000000000000000000000000;;				if strings.Contains(ss, ",") {
0000000000000000000000000000000000000000;;					merged = append(merged, ss)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tmpfs := &configs.Mount{
0000000000000000000000000000000000000000;;				Source:           "tmpfs",
0000000000000000000000000000000000000000;;				Device:           "tmpfs",
0000000000000000000000000000000000000000;;				Destination:      m.Destination,
0000000000000000000000000000000000000000;;				Flags:            defaultMountFlags,
0000000000000000000000000000000000000000;;				Data:             "mode=755",
0000000000000000000000000000000000000000;;				PropagationFlags: m.PropagationFlags,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := mountToRootfs(tmpfs, rootfs, mountLabel); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, b := range binds {
0000000000000000000000000000000000000000;;				if err := mountToRootfs(b, rootfs, mountLabel); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, mc := range merged {
0000000000000000000000000000000000000000;;				for _, ss := range strings.Split(mc, ",") {
0000000000000000000000000000000000000000;;					// symlink(2) is very dumb, it will just shove the path into
0000000000000000000000000000000000000000;;					// the link and doesn't do any checks or relative path
0000000000000000000000000000000000000000;;					// conversion. Also, don't error out if the cgroup already exists.
0000000000000000000000000000000000000000;;					if err := os.Symlink(mc, filepath.Join(rootfs, m.Destination, ss)); err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if m.Flags&syscall.MS_RDONLY != 0 {
0000000000000000000000000000000000000000;;				// remount cgroup root as readonly
0000000000000000000000000000000000000000;;				mcgrouproot := &configs.Mount{
0000000000000000000000000000000000000000;;					Source:      m.Destination,
0000000000000000000000000000000000000000;;					Device:      "bind",
0000000000000000000000000000000000000000;;					Destination: m.Destination,
0000000000000000000000000000000000000000;;					Flags:       defaultMountFlags | syscall.MS_RDONLY | syscall.MS_BIND,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := remount(mcgrouproot, rootfs); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(dest, 0755); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return mountPropagate(m, rootfs, mountLabel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCgroupMounts(m *configs.Mount) ([]*configs.Mount, error) {
0000000000000000000000000000000000000000;;		mounts, err := cgroups.GetCgroupMounts(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupPaths, err := cgroups.ParseCgroupFile("/proc/self/cgroup")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var binds []*configs.Mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, mm := range mounts {
0000000000000000000000000000000000000000;;			dir, err := mm.GetThisCgroupDir(cgroupPaths)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			relDir, err := filepath.Rel(mm.Root, dir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			binds = append(binds, &configs.Mount{
0000000000000000000000000000000000000000;;				Device:           "bind",
0000000000000000000000000000000000000000;;				Source:           filepath.Join(mm.Mountpoint, relDir),
0000000000000000000000000000000000000000;;				Destination:      filepath.Join(m.Destination, strings.Join(mm.Subsystems, ",")),
0000000000000000000000000000000000000000;;				Flags:            syscall.MS_BIND | syscall.MS_REC | m.Flags,
0000000000000000000000000000000000000000;;				PropagationFlags: m.PropagationFlags,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return binds, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkMountDestination checks to ensure that the mount destination is not over the top of /proc.
0000000000000000000000000000000000000000;;	// dest is required to be an abs path and have any symlinks resolved before calling this function.
0000000000000000000000000000000000000000;;	func checkMountDestination(rootfs, dest string) error {
0000000000000000000000000000000000000000;;		invalidDestinations := []string{
0000000000000000000000000000000000000000;;			"/proc",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// White list, it should be sub directories of invalid destinations
0000000000000000000000000000000000000000;;		validDestinations := []string{
0000000000000000000000000000000000000000;;			// These entries can be bind mounted by files emulated by fuse,
0000000000000000000000000000000000000000;;			// so commands like top, free displays stats in container.
0000000000000000000000000000000000000000;;			"/proc/cpuinfo",
0000000000000000000000000000000000000000;;			"/proc/diskstats",
0000000000000000000000000000000000000000;;			"/proc/meminfo",
0000000000000000000000000000000000000000;;			"/proc/stat",
0000000000000000000000000000000000000000;;			"/proc/swaps",
0000000000000000000000000000000000000000;;			"/proc/uptime",
0000000000000000000000000000000000000000;;			"/proc/net/dev",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, valid := range validDestinations {
0000000000000000000000000000000000000000;;			path, err := filepath.Rel(filepath.Join(rootfs, valid), dest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if path == "." {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, invalid := range invalidDestinations {
0000000000000000000000000000000000000000;;			path, err := filepath.Rel(filepath.Join(rootfs, invalid), dest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if path == "." || !strings.HasPrefix(path, "..") {
0000000000000000000000000000000000000000;;				return fmt.Errorf("%q cannot be mounted because it is located inside %q", dest, invalid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupDevSymlinks(rootfs string) error {
0000000000000000000000000000000000000000;;		var links = [][2]string{
0000000000000000000000000000000000000000;;			{"/proc/self/fd", "/dev/fd"},
0000000000000000000000000000000000000000;;			{"/proc/self/fd/0", "/dev/stdin"},
0000000000000000000000000000000000000000;;			{"/proc/self/fd/1", "/dev/stdout"},
0000000000000000000000000000000000000000;;			{"/proc/self/fd/2", "/dev/stderr"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// kcore support can be toggled with CONFIG_PROC_KCORE; only create a symlink
0000000000000000000000000000000000000000;;		// in /dev if it exists in /proc.
0000000000000000000000000000000000000000;;		if _, err := os.Stat("/proc/kcore"); err == nil {
0000000000000000000000000000000000000000;;			links = append(links, [2]string{"/proc/kcore", "/dev/core"})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, link := range links {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				src = link[0]
0000000000000000000000000000000000000000;;				dst = filepath.Join(rootfs, link[1])
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("symlink %s %s %s", src, dst, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If stdin, stdout, and/or stderr are pointing to `/dev/null` in the parent's rootfs
0000000000000000000000000000000000000000;;	// this method will make them point to `/dev/null` in this container's rootfs.  This
0000000000000000000000000000000000000000;;	// needs to be called after we chroot/pivot into the container's rootfs so that any
0000000000000000000000000000000000000000;;	// symlinks are resolved locally.
0000000000000000000000000000000000000000;;	func reOpenDevNull() error {
0000000000000000000000000000000000000000;;		var stat, devNullStat syscall.Stat_t
0000000000000000000000000000000000000000;;		file, err := os.OpenFile("/dev/null", os.O_RDWR, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to open /dev/null - %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		if err := syscall.Fstat(int(file.Fd()), &devNullStat); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for fd := 0; fd < 3; fd++ {
0000000000000000000000000000000000000000;;			if err := syscall.Fstat(fd, &stat); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.Rdev == devNullStat.Rdev {
0000000000000000000000000000000000000000;;				// Close and re-open the fd.
0000000000000000000000000000000000000000;;				if err := syscall.Dup3(int(file.Fd()), fd, 0); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create the device nodes in the container.
0000000000000000000000000000000000000000;;	func createDevices(config *configs.Config) error {
0000000000000000000000000000000000000000;;		useBindMount := system.RunningInUserNS() || config.Namespaces.Contains(configs.NEWUSER)
0000000000000000000000000000000000000000;;		oldMask := syscall.Umask(0000)
0000000000000000000000000000000000000000;;		for _, node := range config.Devices {
0000000000000000000000000000000000000000;;			// containers running in a user namespace are not allowed to mknod
0000000000000000000000000000000000000000;;			// devices so we can just bind mount it from the host.
0000000000000000000000000000000000000000;;			if err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {
0000000000000000000000000000000000000000;;				syscall.Umask(oldMask)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syscall.Umask(oldMask)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bindMountDeviceNode(dest string, node *configs.Device) error {
0000000000000000000000000000000000000000;;		f, err := os.Create(dest)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f != nil {
0000000000000000000000000000000000000000;;			f.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Mount(node.Path, dest, "bind", syscall.MS_BIND, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates the device node in the rootfs of the container.
0000000000000000000000000000000000000000;;	func createDeviceNode(rootfs string, node *configs.Device, bind bool) error {
0000000000000000000000000000000000000000;;		dest := filepath.Join(rootfs, node.Path)
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(filepath.Dir(dest), 0755); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bind {
0000000000000000000000000000000000000000;;			return bindMountDeviceNode(dest, node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := mknodDevice(dest, node); err != nil {
0000000000000000000000000000000000000000;;			if os.IsExist(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if os.IsPermission(err) {
0000000000000000000000000000000000000000;;				return bindMountDeviceNode(dest, node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mknodDevice(dest string, node *configs.Device) error {
0000000000000000000000000000000000000000;;		fileMode := node.FileMode
0000000000000000000000000000000000000000;;		switch node.Type {
0000000000000000000000000000000000000000;;		case 'c':
0000000000000000000000000000000000000000;;			fileMode |= syscall.S_IFCHR
0000000000000000000000000000000000000000;;		case 'b':
0000000000000000000000000000000000000000;;			fileMode |= syscall.S_IFBLK
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("%c is not a valid device type for device %s", node.Type, node.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Mknod(dest, uint32(fileMode), node.Mkdev()); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Chown(dest, int(node.Uid), int(node.Gid))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMountInfo(mountinfo []*mount.Info, dir string) *mount.Info {
0000000000000000000000000000000000000000;;		for _, m := range mountinfo {
0000000000000000000000000000000000000000;;			if m.Mountpoint == dir {
0000000000000000000000000000000000000000;;				return m
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the parent mount point of directory passed in as argument. Also return
0000000000000000000000000000000000000000;;	// optional fields.
0000000000000000000000000000000000000000;;	func getParentMount(rootfs string) (string, string, error) {
0000000000000000000000000000000000000000;;		var path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountinfos, err := mount.GetMounts()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountinfo := getMountInfo(mountinfos, rootfs)
0000000000000000000000000000000000000000;;		if mountinfo != nil {
0000000000000000000000000000000000000000;;			return rootfs, mountinfo.Optional, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path = rootfs
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			path = filepath.Dir(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mountinfo = getMountInfo(mountinfos, path)
0000000000000000000000000000000000000000;;			if mountinfo != nil {
0000000000000000000000000000000000000000;;				return path, mountinfo.Optional, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if path == "/" {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we are here, we did not find parent mount. Something is wrong.
0000000000000000000000000000000000000000;;		return "", "", fmt.Errorf("Could not find parent mount of %s", rootfs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make parent mount private if it was shared
0000000000000000000000000000000000000000;;	func rootfsParentMountPrivate(rootfs string) error {
0000000000000000000000000000000000000000;;		sharedMount := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parentMount, optionalOpts, err := getParentMount(rootfs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsSplit := strings.Split(optionalOpts, " ")
0000000000000000000000000000000000000000;;		for _, opt := range optsSplit {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(opt, "shared:") {
0000000000000000000000000000000000000000;;				sharedMount = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make parent mount PRIVATE if it was shared. It is needed for two
0000000000000000000000000000000000000000;;		// reasons. First of all pivot_root() will fail if parent mount is
0000000000000000000000000000000000000000;;		// shared. Secondly when we bind mount rootfs it will propagate to
0000000000000000000000000000000000000000;;		// parent namespace and we don't want that to happen.
0000000000000000000000000000000000000000;;		if sharedMount {
0000000000000000000000000000000000000000;;			return syscall.Mount("", parentMount, "", syscall.MS_PRIVATE, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prepareRoot(config *configs.Config) error {
0000000000000000000000000000000000000000;;		flag := syscall.MS_SLAVE | syscall.MS_REC
0000000000000000000000000000000000000000;;		if config.RootPropagation != 0 {
0000000000000000000000000000000000000000;;			flag = config.RootPropagation
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Mount("", "/", "", uintptr(flag), ""); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.NoPivotRoot {
0000000000000000000000000000000000000000;;			if err := rootfsParentMountPrivate(config.Rootfs); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return syscall.Mount(config.Rootfs, config.Rootfs, "bind", syscall.MS_BIND|syscall.MS_REC, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setReadonly() error {
0000000000000000000000000000000000000000;;		return syscall.Mount("/", "/", "bind", syscall.MS_BIND|syscall.MS_REMOUNT|syscall.MS_RDONLY|syscall.MS_REC, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupPtmx(config *configs.Config, console *linuxConsole) error {
0000000000000000000000000000000000000000;;		ptmx := filepath.Join(config.Rootfs, "dev/ptmx")
0000000000000000000000000000000000000000;;		if err := os.Remove(ptmx); err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.Symlink("pts/ptmx", ptmx); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("symlink dev ptmx %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if console != nil {
0000000000000000000000000000000000000000;;			return console.mount(config.Rootfs, config.MountLabel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pivotRoot(rootfs, pivotBaseDir string) (err error) {
0000000000000000000000000000000000000000;;		if pivotBaseDir == "" {
0000000000000000000000000000000000000000;;			pivotBaseDir = "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmpDir := filepath.Join(rootfs, pivotBaseDir)
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(tmpDir, 0755); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't create tmp dir %s, error %v", tmpDir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pivotDir, err := ioutil.TempDir(tmpDir, ".pivot_root")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't create pivot_root dir %s, error %v", pivotDir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			errVal := os.Remove(pivotDir)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = errVal
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err := syscall.PivotRoot(rootfs, pivotDir); err != nil {
0000000000000000000000000000000000000000;;			// Make the parent mount private
0000000000000000000000000000000000000000;;			if err := rootfsParentMountPrivate(rootfs); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Try again
0000000000000000000000000000000000000000;;			if err := syscall.PivotRoot(rootfs, pivotDir); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("pivot_root %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Chdir("/"); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("chdir / %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// path to pivot dir now changed, update
0000000000000000000000000000000000000000;;		pivotDir = filepath.Join(pivotBaseDir, filepath.Base(pivotDir))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make pivotDir rprivate to make sure any of the unmounts don't
0000000000000000000000000000000000000000;;		// propagate to parent.
0000000000000000000000000000000000000000;;		if err := syscall.Mount("", pivotDir, "", syscall.MS_PRIVATE|syscall.MS_REC, ""); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := syscall.Unmount(pivotDir, syscall.MNT_DETACH); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unmount pivot_root dir %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func msMoveRoot(rootfs string) error {
0000000000000000000000000000000000000000;;		if err := syscall.Mount(rootfs, "/", "", syscall.MS_MOVE, ""); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Chroot("."); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Chdir("/")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createIfNotExists creates a file or a directory only if it does not already exist.
0000000000000000000000000000000000000000;;	func createIfNotExists(path string, isDir bool) error {
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				if isDir {
0000000000000000000000000000000000000000;;					return os.MkdirAll(path, 0755)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f, err := os.OpenFile(path, os.O_CREATE, 0755)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remountReadonly will bind over the top of an existing path and ensure that it is read-only.
0000000000000000000000000000000000000000;;	func remountReadonly(path string) error {
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			if err := syscall.Mount("", path, "", syscall.MS_REMOUNT|syscall.MS_RDONLY, ""); err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				switch err {
0000000000000000000000000000000000000000;;				case syscall.EINVAL:
0000000000000000000000000000000000000000;;					// Probably not a mountpoint, use bind-mount
0000000000000000000000000000000000000000;;					if err := syscall.Mount(path, path, "", syscall.MS_BIND, ""); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return syscall.Mount(path, path, "", syscall.MS_BIND|syscall.MS_REMOUNT|syscall.MS_RDONLY|syscall.MS_REC|defaultMountFlags, "")
0000000000000000000000000000000000000000;;				case syscall.EBUSY:
0000000000000000000000000000000000000000;;					time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("unable to mount %s as readonly max retries reached", path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maskPath masks the top of the specified path inside a container to avoid
0000000000000000000000000000000000000000;;	// security issues from processes reading information from non-namespace aware
0000000000000000000000000000000000000000;;	// mounts ( proc/kcore ).
0000000000000000000000000000000000000000;;	// For files, maskPath bind mounts /dev/null over the top of the specified path.
0000000000000000000000000000000000000000;;	// For directories, maskPath mounts read-only tmpfs over the top of the specified path.
0000000000000000000000000000000000000000;;	func maskPath(path string) error {
0000000000000000000000000000000000000000;;		if err := syscall.Mount("/dev/null", path, "", syscall.MS_BIND, ""); err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			if err == syscall.ENOTDIR {
0000000000000000000000000000000000000000;;				return syscall.Mount("tmpfs", path, "tmpfs", syscall.MS_RDONLY, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeSystemProperty writes the value to a path under /proc/sys as determined from the key.
0000000000000000000000000000000000000000;;	// For e.g. net.ipv4.ip_forward translated to /proc/sys/net/ipv4/ip_forward.
0000000000000000000000000000000000000000;;	func writeSystemProperty(key, value string) error {
0000000000000000000000000000000000000000;;		keyPath := strings.Replace(key, ".", "/", -1)
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(path.Join("/proc/sys", keyPath), []byte(value), 0644)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func remount(m *configs.Mount, rootfs string) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dest = m.Destination
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(dest, rootfs) {
0000000000000000000000000000000000000000;;			dest = filepath.Join(rootfs, dest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Mount(m.Source, dest, m.Device, uintptr(m.Flags|syscall.MS_REMOUNT), ""); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do the mount operation followed by additional mounts required to take care
0000000000000000000000000000000000000000;;	// of propagation flags.
0000000000000000000000000000000000000000;;	func mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dest  = m.Destination
0000000000000000000000000000000000000000;;			data  = label.FormatMountLabel(m.Data, mountLabel)
0000000000000000000000000000000000000000;;			flags = m.Flags
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if libcontainerUtils.CleanPath(dest) == "/dev" {
0000000000000000000000000000000000000000;;			flags &= ^syscall.MS_RDONLY
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(dest, rootfs) {
0000000000000000000000000000000000000000;;			dest = filepath.Join(rootfs, dest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := syscall.Mount(m.Source, dest, m.Device, uintptr(flags), data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pflag := range m.PropagationFlags {
0000000000000000000000000000000000000000;;			if err := syscall.Mount("", dest, "", uintptr(pflag), ""); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
