0000000000000000000000000000000000000000;;	// +build linux
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/network_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/network_linux.go][vendor/github.com/opencontainers/runc/libcontainer/network_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var strategies = map[string]networkStrategy{
0000000000000000000000000000000000000000;;		"veth":     &veth{},
0000000000000000000000000000000000000000;;		"loopback": &loopback{},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// networkStrategy represents a specific network configuration for
0000000000000000000000000000000000000000;;	// a container's networking stack
0000000000000000000000000000000000000000;;	type networkStrategy interface {
0000000000000000000000000000000000000000;;		create(*network, int) error
0000000000000000000000000000000000000000;;		initialize(*network) error
0000000000000000000000000000000000000000;;		detach(*configs.Network) error
0000000000000000000000000000000000000000;;		attach(*configs.Network) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStrategy returns the specific network strategy for the
0000000000000000000000000000000000000000;;	// provided type.
0000000000000000000000000000000000000000;;	func getStrategy(tpe string) (networkStrategy, error) {
0000000000000000000000000000000000000000;;		s, exists := strategies[tpe]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown strategy type %q", tpe)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the network statistics for the network interfaces represented by the NetworkRuntimeInfo.
0000000000000000000000000000000000000000;;	func getNetworkInterfaceStats(interfaceName string) (*NetworkInterface, error) {
0000000000000000000000000000000000000000;;		out := &NetworkInterface{Name: interfaceName}
0000000000000000000000000000000000000000;;		// This can happen if the network runtime information is missing - possible if the
0000000000000000000000000000000000000000;;		// container was created by an old version of libcontainer.
0000000000000000000000000000000000000000;;		if interfaceName == "" {
0000000000000000000000000000000000000000;;			return out, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type netStatsPair struct {
0000000000000000000000000000000000000000;;			// Where to write the output.
0000000000000000000000000000000000000000;;			Out *uint64
0000000000000000000000000000000000000000;;			// The network stats file to read.
0000000000000000000000000000000000000000;;			File string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ingress for host veth is from the container. Hence tx_bytes stat on the host veth is actually number of bytes received by the container.
0000000000000000000000000000000000000000;;		netStats := []netStatsPair{
0000000000000000000000000000000000000000;;			{Out: &out.RxBytes, File: "tx_bytes"},
0000000000000000000000000000000000000000;;			{Out: &out.RxPackets, File: "tx_packets"},
0000000000000000000000000000000000000000;;			{Out: &out.RxErrors, File: "tx_errors"},
0000000000000000000000000000000000000000;;			{Out: &out.RxDropped, File: "tx_dropped"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{Out: &out.TxBytes, File: "rx_bytes"},
0000000000000000000000000000000000000000;;			{Out: &out.TxPackets, File: "rx_packets"},
0000000000000000000000000000000000000000;;			{Out: &out.TxErrors, File: "rx_errors"},
0000000000000000000000000000000000000000;;			{Out: &out.TxDropped, File: "rx_dropped"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, netStat := range netStats {
0000000000000000000000000000000000000000;;			data, err := readSysfsNetworkStats(interfaceName, netStat.File)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*(netStat.Out) = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reads the specified statistics available under /sys/class/net/<EthInterface>/statistics
0000000000000000000000000000000000000000;;	func readSysfsNetworkStats(ethInterface, statsFile string) (uint64, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(filepath.Join("/sys/class/net", ethInterface, "statistics", statsFile))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.ParseUint(strings.TrimSpace(string(data)), 10, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loopback is a network strategy that provides a basic loopback device
0000000000000000000000000000000000000000;;	type loopback struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loopback) create(n *network, nspid int) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loopback) initialize(config *network) error {
0000000000000000000000000000000000000000;;		return netlink.LinkSetUp(&netlink.Device{LinkAttrs: netlink.LinkAttrs{Name: "lo"}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loopback) attach(n *configs.Network) (err error) {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *loopback) detach(n *configs.Network) (err error) {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// veth is a network strategy that uses a bridge and creates
0000000000000000000000000000000000000000;;	// a veth pair, one that is attached to the bridge on the host and the other
0000000000000000000000000000000000000000;;	// is placed inside the container's namespace
0000000000000000000000000000000000000000;;	type veth struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *veth) detach(n *configs.Network) (err error) {
0000000000000000000000000000000000000000;;		return netlink.LinkSetMaster(&netlink.Device{LinkAttrs: netlink.LinkAttrs{Name: n.HostInterfaceName}}, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// attach a container network interface to an external network
0000000000000000000000000000000000000000;;	func (v *veth) attach(n *configs.Network) (err error) {
0000000000000000000000000000000000000000;;		brl, err := netlink.LinkByName(n.Bridge)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		br, ok := brl.(*netlink.Bridge)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Wrong device type %T", brl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		host, err := netlink.LinkByName(n.HostInterfaceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := netlink.LinkSetMaster(host, br); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.LinkSetMTU(host, n.Mtu); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.HairpinMode {
0000000000000000000000000000000000000000;;			if err := netlink.LinkSetHairpin(host, true); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.LinkSetUp(host); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *veth) create(n *network, nspid int) (err error) {
0000000000000000000000000000000000000000;;		tmpName, err := v.generateTempPeerName()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.TempVethPeerName = tmpName
0000000000000000000000000000000000000000;;		if n.Bridge == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("bridge is not specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		veth := &netlink.Veth{
0000000000000000000000000000000000000000;;			LinkAttrs: netlink.LinkAttrs{
0000000000000000000000000000000000000000;;				Name:   n.HostInterfaceName,
0000000000000000000000000000000000000000;;				TxQLen: n.TxQueueLen,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PeerName: n.TempVethPeerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.LinkAdd(veth); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				netlink.LinkDel(veth)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err := v.attach(&n.Network); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		child, err := netlink.LinkByName(n.TempVethPeerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return netlink.LinkSetNsPid(child, nspid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *veth) generateTempPeerName() (string, error) {
0000000000000000000000000000000000000000;;		return utils.GenerateRandomName("veth", 7)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *veth) initialize(config *network) error {
0000000000000000000000000000000000000000;;		peer := config.TempVethPeerName
0000000000000000000000000000000000000000;;		if peer == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("peer is not specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		child, err := netlink.LinkByName(peer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.LinkSetDown(child); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.LinkSetName(child, config.Name); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// get the interface again after we changed the name as the index also changes.
0000000000000000000000000000000000000000;;		if child, err = netlink.LinkByName(config.Name); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.MacAddress != "" {
0000000000000000000000000000000000000000;;			mac, err := net.ParseMAC(config.MacAddress)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := netlink.LinkSetHardwareAddr(child, mac); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip, err := netlink.ParseAddr(config.Address)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.AddrAdd(child, ip); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.IPv6Address != "" {
0000000000000000000000000000000000000000;;			ip6, err := netlink.ParseAddr(config.IPv6Address)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := netlink.AddrAdd(child, ip6); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.LinkSetMTU(child, config.Mtu); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := netlink.LinkSetUp(child); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.Gateway != "" {
0000000000000000000000000000000000000000;;			gw := net.ParseIP(config.Gateway)
0000000000000000000000000000000000000000;;			if err := netlink.RouteAdd(&netlink.Route{
0000000000000000000000000000000000000000;;				Scope:     netlink.SCOPE_UNIVERSE,
0000000000000000000000000000000000000000;;				LinkIndex: child.Attrs().Index,
0000000000000000000000000000000000000000;;				Gw:        gw,
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.IPv6Gateway != "" {
0000000000000000000000000000000000000000;;			gw := net.ParseIP(config.IPv6Gateway)
0000000000000000000000000000000000000000;;			if err := netlink.RouteAdd(&netlink.Route{
0000000000000000000000000000000000000000;;				Scope:     netlink.SCOPE_UNIVERSE,
0000000000000000000000000000000000000000;;				LinkIndex: child.Attrs().Index,
0000000000000000000000000000000000000000;;				Gw:        gw,
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
