0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/selinux/selinux.go[Godeps/_workspace/src/github.com/docker/libcontainer/selinux/selinux.go][vendor/github.com/opencontainers/runc/libcontainer/selinux/selinux.go];	
0000000000000000000000000000000000000000;;	package selinux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/system"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Enforcing        = 1
0000000000000000000000000000000000000000;;		Permissive       = 0
0000000000000000000000000000000000000000;;		Disabled         = -1
0000000000000000000000000000000000000000;;		selinuxDir       = "/etc/selinux/"
0000000000000000000000000000000000000000;;		selinuxConfig    = selinuxDir + "config"
0000000000000000000000000000000000000000;;		selinuxTypeTag   = "SELINUXTYPE"
0000000000000000000000000000000000000000;;		selinuxTag       = "SELINUX"
0000000000000000000000000000000000000000;;		selinuxPath      = "/sys/fs/selinux"
0000000000000000000000000000000000000000;;		xattrNameSelinux = "security.selinux"
0000000000000000000000000000000000000000;;		stRdOnly         = 0x01
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		assignRegex           = regexp.MustCompile(`^([^=]+)=(.*)$`)
0000000000000000000000000000000000000000;;		mcsList               = make(map[string]bool)
0000000000000000000000000000000000000000;;		mcsLock               sync.Mutex
0000000000000000000000000000000000000000;;		selinuxfs             = "unknown"
0000000000000000000000000000000000000000;;		selinuxEnabled        = false // Stores whether selinux is currently enabled
0000000000000000000000000000000000000000;;		selinuxEnabledChecked = false // Stores whether selinux enablement has been checked or established yet
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SELinuxContext map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDisabled disables selinux support for the package
0000000000000000000000000000000000000000;;	func SetDisabled() {
0000000000000000000000000000000000000000;;		selinuxEnabled, selinuxEnabledChecked = false, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSelinuxMountPoint returns the path to the mountpoint of an selinuxfs
0000000000000000000000000000000000000000;;	// filesystem or an empty string if no mountpoint is found.  Selinuxfs is
0000000000000000000000000000000000000000;;	// a proc-like pseudo-filesystem that exposes the selinux policy API to
0000000000000000000000000000000000000000;;	// processes.  The existence of an selinuxfs mount is used to determine
0000000000000000000000000000000000000000;;	// whether selinux is currently enabled or not.
0000000000000000000000000000000000000000;;	func getSelinuxMountPoint() string {
0000000000000000000000000000000000000000;;		if selinuxfs != "unknown" {
0000000000000000000000000000000000000000;;			return selinuxfs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selinuxfs = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/self/mountinfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return selinuxfs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			txt := scanner.Text()
0000000000000000000000000000000000000000;;			// Safe as mountinfo encodes mountpoints with spaces as \040.
0000000000000000000000000000000000000000;;			sepIdx := strings.Index(txt, " - ")
0000000000000000000000000000000000000000;;			if sepIdx == -1 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(txt[sepIdx:], "selinuxfs") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Split(txt, " ")
0000000000000000000000000000000000000000;;			if len(fields) < 5 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selinuxfs = fields[4]
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if selinuxfs != "" {
0000000000000000000000000000000000000000;;			var buf syscall.Statfs_t
0000000000000000000000000000000000000000;;			syscall.Statfs(selinuxfs, &buf)
0000000000000000000000000000000000000000;;			if (buf.Flags & stRdOnly) == 1 {
0000000000000000000000000000000000000000;;				selinuxfs = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selinuxfs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelinuxEnabled returns whether selinux is currently enabled.
0000000000000000000000000000000000000000;;	func SelinuxEnabled() bool {
0000000000000000000000000000000000000000;;		if selinuxEnabledChecked {
0000000000000000000000000000000000000000;;			return selinuxEnabled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selinuxEnabledChecked = true
0000000000000000000000000000000000000000;;		if fs := getSelinuxMountPoint(); fs != "" {
0000000000000000000000000000000000000000;;			if con, _ := Getcon(); con != "kernel" {
0000000000000000000000000000000000000000;;				selinuxEnabled = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selinuxEnabled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readConfig(target string) (value string) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			val, key string
0000000000000000000000000000000000000000;;			bufin    *bufio.Reader
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in, err := os.Open(selinuxConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer in.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bufin = bufio.NewReader(in)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for done := false; !done; {
0000000000000000000000000000000000000000;;			var line string
0000000000000000000000000000000000000000;;			if line, err = bufin.ReadString('\n'); err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					return ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				done = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line = strings.TrimSpace(line)
0000000000000000000000000000000000000000;;			if len(line) == 0 {
0000000000000000000000000000000000000000;;				// Skip blank lines
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if line[0] == ';' || line[0] == '#' {
0000000000000000000000000000000000000000;;				// Skip comments
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if groups := assignRegex.FindStringSubmatch(line); groups != nil {
0000000000000000000000000000000000000000;;				key, val = strings.TrimSpace(groups[1]), strings.TrimSpace(groups[2])
0000000000000000000000000000000000000000;;				if key == target {
0000000000000000000000000000000000000000;;					return strings.Trim(val, "\"")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSELinuxPolicyRoot() string {
0000000000000000000000000000000000000000;;		return selinuxDir + readConfig(selinuxTypeTag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readCon(name string) (string, error) {
0000000000000000000000000000000000000000;;		var val string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in, err := os.Open(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer in.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fscanf(in, "%s", &val)
0000000000000000000000000000000000000000;;		return val, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setfilecon sets the SELinux label for this path or returns an error.
0000000000000000000000000000000000000000;;	func Setfilecon(path string, scon string) error {
0000000000000000000000000000000000000000;;		return system.Lsetxattr(path, xattrNameSelinux, []byte(scon), 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Getfilecon returns the SELinux label for this path or returns an error.
0000000000000000000000000000000000000000;;	func Getfilecon(path string) (string, error) {
0000000000000000000000000000000000000000;;		con, err := system.Lgetxattr(path, xattrNameSelinux)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Trim the NUL byte at the end of the byte buffer, if present.
0000000000000000000000000000000000000000;;		if len(con) > 0 && con[len(con)-1] == '\x00' {
0000000000000000000000000000000000000000;;			con = con[:len(con)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(con), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setfscreatecon(scon string) error {
0000000000000000000000000000000000000000;;		return writeCon(fmt.Sprintf("/proc/self/task/%d/attr/fscreate", syscall.Gettid()), scon)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getfscreatecon() (string, error) {
0000000000000000000000000000000000000000;;		return readCon(fmt.Sprintf("/proc/self/task/%d/attr/fscreate", syscall.Gettid()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Getcon returns the SELinux label of the current process thread, or an error.
0000000000000000000000000000000000000000;;	func Getcon() (string, error) {
0000000000000000000000000000000000000000;;		return readCon(fmt.Sprintf("/proc/self/task/%d/attr/current", syscall.Gettid()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Getpidcon returns the SELinux label of the given pid, or an error.
0000000000000000000000000000000000000000;;	func Getpidcon(pid int) (string, error) {
0000000000000000000000000000000000000000;;		return readCon(fmt.Sprintf("/proc/%d/attr/current", pid))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getexeccon() (string, error) {
0000000000000000000000000000000000000000;;		return readCon(fmt.Sprintf("/proc/self/task/%d/attr/exec", syscall.Gettid()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeCon(name string, val string) error {
0000000000000000000000000000000000000000;;		out, err := os.OpenFile(name, os.O_WRONLY, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer out.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val != "" {
0000000000000000000000000000000000000000;;			_, err = out.Write([]byte(val))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, err = out.Write(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setexeccon(scon string) error {
0000000000000000000000000000000000000000;;		return writeCon(fmt.Sprintf("/proc/self/task/%d/attr/exec", syscall.Gettid()), scon)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c SELinuxContext) Get() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s:%s:%s:%s", c["user"], c["role"], c["type"], c["level"])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewContext(scon string) SELinuxContext {
0000000000000000000000000000000000000000;;		c := make(SELinuxContext)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(scon) != 0 {
0000000000000000000000000000000000000000;;			con := strings.SplitN(scon, ":", 4)
0000000000000000000000000000000000000000;;			c["user"] = con[0]
0000000000000000000000000000000000000000;;			c["role"] = con[1]
0000000000000000000000000000000000000000;;			c["type"] = con[2]
0000000000000000000000000000000000000000;;			c["level"] = con[3]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReserveLabel(scon string) {
0000000000000000000000000000000000000000;;		if len(scon) != 0 {
0000000000000000000000000000000000000000;;			con := strings.SplitN(scon, ":", 4)
0000000000000000000000000000000000000000;;			mcsAdd(con[3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func selinuxEnforcePath() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/enforce", selinuxPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SelinuxGetEnforce() int {
0000000000000000000000000000000000000000;;		var enforce int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enforceS, err := readCon(selinuxEnforcePath())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enforce, err = strconv.Atoi(string(enforceS))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return enforce
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SelinuxSetEnforce(mode int) error {
0000000000000000000000000000000000000000;;		return writeCon(selinuxEnforcePath(), fmt.Sprintf("%d", mode))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SelinuxGetEnforceMode() int {
0000000000000000000000000000000000000000;;		switch readConfig(selinuxTag) {
0000000000000000000000000000000000000000;;		case "enforcing":
0000000000000000000000000000000000000000;;			return Enforcing
0000000000000000000000000000000000000000;;		case "permissive":
0000000000000000000000000000000000000000;;			return Permissive
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Disabled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mcsAdd(mcs string) error {
0000000000000000000000000000000000000000;;		mcsLock.Lock()
0000000000000000000000000000000000000000;;		defer mcsLock.Unlock()
0000000000000000000000000000000000000000;;		if mcsList[mcs] {
0000000000000000000000000000000000000000;;			return fmt.Errorf("MCS Label already exists")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mcsList[mcs] = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mcsDelete(mcs string) {
0000000000000000000000000000000000000000;;		mcsLock.Lock()
0000000000000000000000000000000000000000;;		mcsList[mcs] = false
0000000000000000000000000000000000000000;;		mcsLock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IntToMcs(id int, catRange uint32) string {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			SETSIZE = int(catRange)
0000000000000000000000000000000000000000;;			TIER    = SETSIZE
0000000000000000000000000000000000000000;;			ORD     = id
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if id < 1 || id > 523776 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ORD > TIER {
0000000000000000000000000000000000000000;;			ORD = ORD - TIER
0000000000000000000000000000000000000000;;			TIER--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		TIER = SETSIZE - TIER
0000000000000000000000000000000000000000;;		ORD = ORD + TIER
0000000000000000000000000000000000000000;;		return fmt.Sprintf("s0:c%d,c%d", TIER, ORD)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func uniqMcs(catRange uint32) string {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			n      uint32
0000000000000000000000000000000000000000;;			c1, c2 uint32
0000000000000000000000000000000000000000;;			mcs    string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			binary.Read(rand.Reader, binary.LittleEndian, &n)
0000000000000000000000000000000000000000;;			c1 = n % catRange
0000000000000000000000000000000000000000;;			binary.Read(rand.Reader, binary.LittleEndian, &n)
0000000000000000000000000000000000000000;;			c2 = n % catRange
0000000000000000000000000000000000000000;;			if c1 == c2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if c1 > c2 {
0000000000000000000000000000000000000000;;					t := c1
0000000000000000000000000000000000000000;;					c1 = c2
0000000000000000000000000000000000000000;;					c2 = t
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mcs = fmt.Sprintf("s0:c%d,c%d", c1, c2)
0000000000000000000000000000000000000000;;			if err := mcsAdd(mcs); err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mcs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FreeLxcContexts(scon string) {
0000000000000000000000000000000000000000;;		if len(scon) != 0 {
0000000000000000000000000000000000000000;;			con := strings.SplitN(scon, ":", 4)
0000000000000000000000000000000000000000;;			mcsDelete(con[3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var roFileLabel string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetROFileLabel() (fileLabel string) {
0000000000000000000000000000000000000000;;		return roFileLabel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetLxcContexts() (processLabel string, fileLabel string) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			val, key string
0000000000000000000000000000000000000000;;			bufin    *bufio.Reader
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !SelinuxEnabled() {
0000000000000000000000000000000000000000;;			return "", ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lxcPath := fmt.Sprintf("%s/contexts/lxc_contexts", getSELinuxPolicyRoot())
0000000000000000000000000000000000000000;;		in, err := os.Open(lxcPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer in.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bufin = bufio.NewReader(in)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for done := false; !done; {
0000000000000000000000000000000000000000;;			var line string
0000000000000000000000000000000000000000;;			if line, err = bufin.ReadString('\n'); err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					done = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					goto exit
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line = strings.TrimSpace(line)
0000000000000000000000000000000000000000;;			if len(line) == 0 {
0000000000000000000000000000000000000000;;				// Skip blank lines
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if line[0] == ';' || line[0] == '#' {
0000000000000000000000000000000000000000;;				// Skip comments
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if groups := assignRegex.FindStringSubmatch(line); groups != nil {
0000000000000000000000000000000000000000;;				key, val = strings.TrimSpace(groups[1]), strings.TrimSpace(groups[2])
0000000000000000000000000000000000000000;;				if key == "process" {
0000000000000000000000000000000000000000;;					processLabel = strings.Trim(val, "\"")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if key == "file" {
0000000000000000000000000000000000000000;;					fileLabel = strings.Trim(val, "\"")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if key == "ro_file" {
0000000000000000000000000000000000000000;;					roFileLabel = strings.Trim(val, "\"")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if processLabel == "" || fileLabel == "" {
0000000000000000000000000000000000000000;;			return "", ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if roFileLabel == "" {
0000000000000000000000000000000000000000;;			roFileLabel = fileLabel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	exit:
0000000000000000000000000000000000000000;;		//	mcs := IntToMcs(os.Getpid(), 1024)
0000000000000000000000000000000000000000;;		mcs := uniqMcs(1024)
0000000000000000000000000000000000000000;;		scon := NewContext(processLabel)
0000000000000000000000000000000000000000;;		scon["level"] = mcs
0000000000000000000000000000000000000000;;		processLabel = scon.Get()
0000000000000000000000000000000000000000;;		scon = NewContext(fileLabel)
0000000000000000000000000000000000000000;;		scon["level"] = mcs
0000000000000000000000000000000000000000;;		fileLabel = scon.Get()
0000000000000000000000000000000000000000;;		return processLabel, fileLabel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SecurityCheckContext(val string) error {
0000000000000000000000000000000000000000;;		return writeCon(fmt.Sprintf("%s.context", selinuxPath), val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CopyLevel(src, dest string) (string, error) {
0000000000000000000000000000000000000000;;		if src == "" {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := SecurityCheckContext(src); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := SecurityCheckContext(dest); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scon := NewContext(src)
0000000000000000000000000000000000000000;;		tcon := NewContext(dest)
0000000000000000000000000000000000000000;;		mcsDelete(tcon["level"])
0000000000000000000000000000000000000000;;		mcsAdd(scon["level"])
0000000000000000000000000000000000000000;;		tcon["level"] = scon["level"]
0000000000000000000000000000000000000000;;		return tcon.Get(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prevent users from relabing system files
0000000000000000000000000000000000000000;;	func badPrefix(fpath string) error {
0000000000000000000000000000000000000000;;		var badprefixes = []string{"/usr"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, prefix := range badprefixes {
0000000000000000000000000000000000000000;;			if fpath == prefix || strings.HasPrefix(fpath, fmt.Sprintf("%s/", prefix)) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Relabeling content in %s is not allowed.", prefix)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chcon changes the fpath file object to the SELinux label scon.
0000000000000000000000000000000000000000;;	// If the fpath is a directory and recurse is true Chcon will walk the
0000000000000000000000000000000000000000;;	// directory tree setting the label
0000000000000000000000000000000000000000;;	func Chcon(fpath string, scon string, recurse bool) error {
0000000000000000000000000000000000000000;;		if scon == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := badPrefix(fpath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		callback := func(p string, info os.FileInfo, err error) error {
0000000000000000000000000000000000000000;;			return Setfilecon(p, scon)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if recurse {
0000000000000000000000000000000000000000;;			return filepath.Walk(fpath, callback)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Setfilecon(fpath, scon)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DupSecOpt takes an SELinux process label and returns security options that
0000000000000000000000000000000000000000;;	// can will set the SELinux Type and Level for future container processes
0000000000000000000000000000000000000000;;	func DupSecOpt(src string) []string {
0000000000000000000000000000000000000000;;		if src == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		con := NewContext(src)
0000000000000000000000000000000000000000;;		if con["user"] == "" ||
0000000000000000000000000000000000000000;;			con["role"] == "" ||
0000000000000000000000000000000000000000;;			con["type"] == "" ||
0000000000000000000000000000000000000000;;			con["level"] == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{"label=user:" + con["user"],
0000000000000000000000000000000000000000;;			"label=role:" + con["role"],
0000000000000000000000000000000000000000;;			"label=type:" + con["type"],
0000000000000000000000000000000000000000;;			"label=level:" + con["level"]}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisableSecOpt returns a security opt that can be used to disabling SELinux
0000000000000000000000000000000000000000;;	// labeling support for future container processes
0000000000000000000000000000000000000000;;	func DisableSecOpt() []string {
0000000000000000000000000000000000000000;;		return []string{"label=disable"}
0000000000000000000000000000000000000000;;	}
