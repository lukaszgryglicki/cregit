0000000000000000000000000000000000000000;;	package libcontainer
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/console/console.go[Godeps/_workspace/src/github.com/docker/libcontainer/console/console.go][vendor/github.com/opencontainers/runc/libcontainer/console_linux.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/label"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConsole returns an initalized console that can be used within a container by copying bytes
0000000000000000000000000000000000000000;;	// from the master side to the slave that is attached as the tty for the container's init process.
0000000000000000000000000000000000000000;;	func NewConsole(uid, gid int) (Console, error) {
0000000000000000000000000000000000000000;;		master, err := os.OpenFile("/dev/ptmx", syscall.O_RDWR|syscall.O_NOCTTY|syscall.O_CLOEXEC, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		console, err := ptsname(master)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := unlockpt(master); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.Chmod(console, 0600); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.Chown(console, uid, gid); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &linuxConsole{
0000000000000000000000000000000000000000;;			slavePath: console,
0000000000000000000000000000000000000000;;			master:    master,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newConsoleFromPath is an internal function returning an initialized console for use inside
0000000000000000000000000000000000000000;;	// a container's MNT namespace.
0000000000000000000000000000000000000000;;	func newConsoleFromPath(slavePath string) *linuxConsole {
0000000000000000000000000000000000000000;;		return &linuxConsole{
0000000000000000000000000000000000000000;;			slavePath: slavePath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// linuxConsole is a linux pseudo TTY for use within a container.
0000000000000000000000000000000000000000;;	type linuxConsole struct {
0000000000000000000000000000000000000000;;		master    *os.File
0000000000000000000000000000000000000000;;		slavePath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxConsole) Fd() uintptr {
0000000000000000000000000000000000000000;;		return c.master.Fd()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxConsole) Path() string {
0000000000000000000000000000000000000000;;		return c.slavePath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxConsole) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		return c.master.Read(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxConsole) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		return c.master.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxConsole) Close() error {
0000000000000000000000000000000000000000;;		if m := c.master; m != nil {
0000000000000000000000000000000000000000;;			return m.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mount initializes the console inside the rootfs mounting with the specified mount label
0000000000000000000000000000000000000000;;	// and applying the correct ownership of the console.
0000000000000000000000000000000000000000;;	func (c *linuxConsole) mount(rootfs, mountLabel string) error {
0000000000000000000000000000000000000000;;		oldMask := syscall.Umask(0000)
0000000000000000000000000000000000000000;;		defer syscall.Umask(oldMask)
0000000000000000000000000000000000000000;;		if err := label.SetFileLabel(c.slavePath, mountLabel); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dest := filepath.Join(rootfs, "/dev/console")
0000000000000000000000000000000000000000;;		f, err := os.Create(dest)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f != nil {
0000000000000000000000000000000000000000;;			f.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Mount(c.slavePath, dest, "bind", syscall.MS_BIND, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dupStdio opens the slavePath for the console and dups the fds to the current
0000000000000000000000000000000000000000;;	// processes stdio, fd 0,1,2.
0000000000000000000000000000000000000000;;	func (c *linuxConsole) dupStdio() error {
0000000000000000000000000000000000000000;;		slave, err := c.open(syscall.O_RDWR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd := int(slave.Fd())
0000000000000000000000000000000000000000;;		for _, i := range []int{0, 1, 2} {
0000000000000000000000000000000000000000;;			if err := syscall.Dup3(fd, i, 0); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// open is a clone of os.OpenFile without the O_CLOEXEC used to open the pty slave.
0000000000000000000000000000000000000000;;	func (c *linuxConsole) open(flag int) (*os.File, error) {
0000000000000000000000000000000000000000;;		r, e := syscall.Open(c.slavePath, flag, 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{
0000000000000000000000000000000000000000;;				Op:   "open",
0000000000000000000000000000000000000000;;				Path: c.slavePath,
0000000000000000000000000000000000000000;;				Err:  e,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.NewFile(uintptr(r), c.slavePath), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ioctl(fd uintptr, flag, data uintptr) error {
0000000000000000000000000000000000000000;;		if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, flag, data); err != 0 {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unlockpt unlocks the slave pseudoterminal device corresponding to the master pseudoterminal referred to by f.
0000000000000000000000000000000000000000;;	// unlockpt should be called before opening the slave side of a pty.
0000000000000000000000000000000000000000;;	func unlockpt(f *os.File) error {
0000000000000000000000000000000000000000;;		var u int32
0000000000000000000000000000000000000000;;		return ioctl(f.Fd(), syscall.TIOCSPTLCK, uintptr(unsafe.Pointer(&u)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ptsname retrieves the name of the first available pts for the given master.
0000000000000000000000000000000000000000;;	func ptsname(f *os.File) (string, error) {
0000000000000000000000000000000000000000;;		var n int32
0000000000000000000000000000000000000000;;		if err := ioctl(f.Fd(), syscall.TIOCGPTN, uintptr(unsafe.Pointer(&n))); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/dev/pts/%d", n), nil
0000000000000000000000000000000000000000;;	}
