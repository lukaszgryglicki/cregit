0000000000000000000000000000000000000000;;	package user
3cd2b760f8f9db0b07f58b8e6b98471e2fc3d640;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/github.com/opencontainers/runc/libcontainer/user/lookup.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/github.com/opencontainers/runc/libcontainer/user/lookup.go][vendor/github.com/opencontainers/runc/libcontainer/user/lookup.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// The current operating system does not provide the required data for user lookups.
0000000000000000000000000000000000000000;;		ErrUnsupported = errors.New("user lookup: operating system does not provide passwd-formatted data")
0000000000000000000000000000000000000000;;		// No matching entries found in file.
0000000000000000000000000000000000000000;;		ErrNoPasswdEntries = errors.New("no matching entries in passwd file")
0000000000000000000000000000000000000000;;		ErrNoGroupEntries  = errors.New("no matching entries in group file")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lookupUser(filter func(u User) bool) (User, error) {
0000000000000000000000000000000000000000;;		// Get operating system-specific passwd reader-closer.
0000000000000000000000000000000000000000;;		passwd, err := GetPasswd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return User{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer passwd.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the users.
0000000000000000000000000000000000000000;;		users, err := ParsePasswdFilter(passwd, filter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return User{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No user entries found.
0000000000000000000000000000000000000000;;		if len(users) == 0 {
0000000000000000000000000000000000000000;;			return User{}, ErrNoPasswdEntries
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume the first entry is the "correct" one.
0000000000000000000000000000000000000000;;		return users[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CurrentUser looks up the current user by their user id in /etc/passwd. If the
0000000000000000000000000000000000000000;;	// user cannot be found (or there is no /etc/passwd file on the filesystem),
0000000000000000000000000000000000000000;;	// then CurrentUser returns an error.
0000000000000000000000000000000000000000;;	func CurrentUser() (User, error) {
0000000000000000000000000000000000000000;;		return LookupUid(syscall.Getuid())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupUser looks up a user by their username in /etc/passwd. If the user
0000000000000000000000000000000000000000;;	// cannot be found (or there is no /etc/passwd file on the filesystem), then
0000000000000000000000000000000000000000;;	// LookupUser returns an error.
0000000000000000000000000000000000000000;;	func LookupUser(username string) (User, error) {
0000000000000000000000000000000000000000;;		return lookupUser(func(u User) bool {
0000000000000000000000000000000000000000;;			return u.Name == username
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupUid looks up a user by their user id in /etc/passwd. If the user cannot
0000000000000000000000000000000000000000;;	// be found (or there is no /etc/passwd file on the filesystem), then LookupId
0000000000000000000000000000000000000000;;	// returns an error.
0000000000000000000000000000000000000000;;	func LookupUid(uid int) (User, error) {
0000000000000000000000000000000000000000;;		return lookupUser(func(u User) bool {
0000000000000000000000000000000000000000;;			return u.Uid == uid
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lookupGroup(filter func(g Group) bool) (Group, error) {
0000000000000000000000000000000000000000;;		// Get operating system-specific group reader-closer.
0000000000000000000000000000000000000000;;		group, err := GetGroup()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Group{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer group.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the users.
0000000000000000000000000000000000000000;;		groups, err := ParseGroupFilter(group, filter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Group{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No user entries found.
0000000000000000000000000000000000000000;;		if len(groups) == 0 {
0000000000000000000000000000000000000000;;			return Group{}, ErrNoGroupEntries
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume the first entry is the "correct" one.
0000000000000000000000000000000000000000;;		return groups[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CurrentGroup looks up the current user's group by their primary group id's
0000000000000000000000000000000000000000;;	// entry in /etc/passwd. If the group cannot be found (or there is no
0000000000000000000000000000000000000000;;	// /etc/group file on the filesystem), then CurrentGroup returns an error.
0000000000000000000000000000000000000000;;	func CurrentGroup() (Group, error) {
0000000000000000000000000000000000000000;;		return LookupGid(syscall.Getgid())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupGroup looks up a group by its name in /etc/group. If the group cannot
0000000000000000000000000000000000000000;;	// be found (or there is no /etc/group file on the filesystem), then LookupGroup
0000000000000000000000000000000000000000;;	// returns an error.
0000000000000000000000000000000000000000;;	func LookupGroup(groupname string) (Group, error) {
0000000000000000000000000000000000000000;;		return lookupGroup(func(g Group) bool {
0000000000000000000000000000000000000000;;			return g.Name == groupname
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupGid looks up a group by its group id in /etc/group. If the group cannot
0000000000000000000000000000000000000000;;	// be found (or there is no /etc/group file on the filesystem), then LookupGid
0000000000000000000000000000000000000000;;	// returns an error.
0000000000000000000000000000000000000000;;	func LookupGid(gid int) (Group, error) {
0000000000000000000000000000000000000000;;		return lookupGroup(func(g Group) bool {
0000000000000000000000000000000000000000;;			return g.Gid == gid
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
