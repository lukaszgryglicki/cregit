0000000000000000000000000000000000000000;;	package user
3cd2b760f8f9db0b07f58b8e6b98471e2fc3d640;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/github.com/opencontainers/runc/libcontainer/user/user.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/github.com/opencontainers/runc/libcontainer/user/user.go][vendor/github.com/opencontainers/runc/libcontainer/user/user.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		minId = 0
0000000000000000000000000000000000000000;;		maxId = 1<<31 - 1 //for 32-bit systems compatibility
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrRange = fmt.Errorf("uids and gids must be in range %d-%d", minId, maxId)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type User struct {
0000000000000000000000000000000000000000;;		Name  string
0000000000000000000000000000000000000000;;		Pass  string
0000000000000000000000000000000000000000;;		Uid   int
0000000000000000000000000000000000000000;;		Gid   int
0000000000000000000000000000000000000000;;		Gecos string
0000000000000000000000000000000000000000;;		Home  string
0000000000000000000000000000000000000000;;		Shell string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Group struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Pass string
0000000000000000000000000000000000000000;;		Gid  int
0000000000000000000000000000000000000000;;		List []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseLine(line string, v ...interface{}) {
0000000000000000000000000000000000000000;;		if line == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := strings.Split(line, ":")
0000000000000000000000000000000000000000;;		for i, p := range parts {
0000000000000000000000000000000000000000;;			// Ignore cases where we don't have enough fields to populate the arguments.
0000000000000000000000000000000000000000;;			// Some configuration files like to misbehave.
0000000000000000000000000000000000000000;;			if len(v) <= i {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Use the type of the argument to figure out how to parse it, scanf() style.
0000000000000000000000000000000000000000;;			// This is legit.
0000000000000000000000000000000000000000;;			switch e := v[i].(type) {
0000000000000000000000000000000000000000;;			case *string:
0000000000000000000000000000000000000000;;				*e = p
0000000000000000000000000000000000000000;;			case *int:
0000000000000000000000000000000000000000;;				// "numbers", with conversion errors ignored because of some misbehaving configuration files.
0000000000000000000000000000000000000000;;				*e, _ = strconv.Atoi(p)
0000000000000000000000000000000000000000;;			case *[]string:
0000000000000000000000000000000000000000;;				// Comma-separated lists.
0000000000000000000000000000000000000000;;				if p != "" {
0000000000000000000000000000000000000000;;					*e = strings.Split(p, ",")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					*e = []string{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Someone goof'd when writing code using this function. Scream so they can hear us.
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("parseLine only accepts {*string, *int, *[]string} as arguments! %#v is not a pointer!", e))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParsePasswdFile(path string) ([]User, error) {
0000000000000000000000000000000000000000;;		passwd, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer passwd.Close()
0000000000000000000000000000000000000000;;		return ParsePasswd(passwd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParsePasswd(passwd io.Reader) ([]User, error) {
0000000000000000000000000000000000000000;;		return ParsePasswdFilter(passwd, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParsePasswdFileFilter(path string, filter func(User) bool) ([]User, error) {
0000000000000000000000000000000000000000;;		passwd, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer passwd.Close()
0000000000000000000000000000000000000000;;		return ParsePasswdFilter(passwd, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParsePasswdFilter(r io.Reader, filter func(User) bool) ([]User, error) {
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("nil source for passwd-formatted data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			s   = bufio.NewScanner(r)
0000000000000000000000000000000000000000;;			out = []User{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			line := strings.TrimSpace(s.Text())
0000000000000000000000000000000000000000;;			if line == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// see: man 5 passwd
0000000000000000000000000000000000000000;;			//  name:password:UID:GID:GECOS:directory:shell
0000000000000000000000000000000000000000;;			// Name:Pass:Uid:Gid:Gecos:Home:Shell
0000000000000000000000000000000000000000;;			//  root:x:0:0:root:/root:/bin/bash
0000000000000000000000000000000000000000;;			//  adm:x:3:4:adm:/var/adm:/bin/false
0000000000000000000000000000000000000000;;			p := User{}
0000000000000000000000000000000000000000;;			parseLine(line, &p.Name, &p.Pass, &p.Uid, &p.Gid, &p.Gecos, &p.Home, &p.Shell)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if filter == nil || filter(p) {
0000000000000000000000000000000000000000;;				out = append(out, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseGroupFile(path string) ([]Group, error) {
0000000000000000000000000000000000000000;;		group, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer group.Close()
0000000000000000000000000000000000000000;;		return ParseGroup(group)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseGroup(group io.Reader) ([]Group, error) {
0000000000000000000000000000000000000000;;		return ParseGroupFilter(group, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseGroupFileFilter(path string, filter func(Group) bool) ([]Group, error) {
0000000000000000000000000000000000000000;;		group, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer group.Close()
0000000000000000000000000000000000000000;;		return ParseGroupFilter(group, filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseGroupFilter(r io.Reader, filter func(Group) bool) ([]Group, error) {
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("nil source for group-formatted data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			s   = bufio.NewScanner(r)
0000000000000000000000000000000000000000;;			out = []Group{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			text := s.Text()
0000000000000000000000000000000000000000;;			if text == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// see: man 5 group
0000000000000000000000000000000000000000;;			//  group_name:password:GID:user_list
0000000000000000000000000000000000000000;;			// Name:Pass:Gid:List
0000000000000000000000000000000000000000;;			//  root:x:0:root
0000000000000000000000000000000000000000;;			//  adm:x:4:root,adm,daemon
0000000000000000000000000000000000000000;;			p := Group{}
0000000000000000000000000000000000000000;;			parseLine(text, &p.Name, &p.Pass, &p.Gid, &p.List)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if filter == nil || filter(p) {
0000000000000000000000000000000000000000;;				out = append(out, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ExecUser struct {
0000000000000000000000000000000000000000;;		Uid   int
0000000000000000000000000000000000000000;;		Gid   int
0000000000000000000000000000000000000000;;		Sgids []int
0000000000000000000000000000000000000000;;		Home  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExecUserPath is a wrapper for GetExecUser. It reads data from each of the
0000000000000000000000000000000000000000;;	// given file paths and uses that data as the arguments to GetExecUser. If the
0000000000000000000000000000000000000000;;	// files cannot be opened for any reason, the error is ignored and a nil
0000000000000000000000000000000000000000;;	// io.Reader is passed instead.
0000000000000000000000000000000000000000;;	func GetExecUserPath(userSpec string, defaults *ExecUser, passwdPath, groupPath string) (*ExecUser, error) {
0000000000000000000000000000000000000000;;		passwd, err := os.Open(passwdPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			passwd = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			defer passwd.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		group, err := os.Open(groupPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			group = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			defer group.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return GetExecUser(userSpec, defaults, passwd, group)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExecUser parses a user specification string (using the passwd and group
0000000000000000000000000000000000000000;;	// readers as sources for /etc/passwd and /etc/group data, respectively). In
0000000000000000000000000000000000000000;;	// the case of blank fields or missing data from the sources, the values in
0000000000000000000000000000000000000000;;	// defaults is used.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// GetExecUser will return an error if a user or group literal could not be
0000000000000000000000000000000000000000;;	// found in any entry in passwd and group respectively.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples of valid user specifications are:
0000000000000000000000000000000000000000;;	//     * ""
0000000000000000000000000000000000000000;;	//     * "user"
0000000000000000000000000000000000000000;;	//     * "uid"
0000000000000000000000000000000000000000;;	//     * "user:group"
0000000000000000000000000000000000000000;;	//     * "uid:gid
0000000000000000000000000000000000000000;;	//     * "user:gid"
0000000000000000000000000000000000000000;;	//     * "uid:group"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It should be noted that if you specify a numeric user or group id, they will
0000000000000000000000000000000000000000;;	// not be evaluated as usernames (only the metadata will be filled). So attempting
0000000000000000000000000000000000000000;;	// to parse a user with user.Name = "1337" will produce the user with a UID of
0000000000000000000000000000000000000000;;	// 1337.
0000000000000000000000000000000000000000;;	func GetExecUser(userSpec string, defaults *ExecUser, passwd, group io.Reader) (*ExecUser, error) {
0000000000000000000000000000000000000000;;		if defaults == nil {
0000000000000000000000000000000000000000;;			defaults = new(ExecUser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy over defaults.
0000000000000000000000000000000000000000;;		user := &ExecUser{
0000000000000000000000000000000000000000;;			Uid:   defaults.Uid,
0000000000000000000000000000000000000000;;			Gid:   defaults.Gid,
0000000000000000000000000000000000000000;;			Sgids: defaults.Sgids,
0000000000000000000000000000000000000000;;			Home:  defaults.Home,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sgids slice *cannot* be nil.
0000000000000000000000000000000000000000;;		if user.Sgids == nil {
0000000000000000000000000000000000000000;;			user.Sgids = []int{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow for userArg to have either "user" syntax, or optionally "user:group" syntax
0000000000000000000000000000000000000000;;		var userArg, groupArg string
0000000000000000000000000000000000000000;;		parseLine(userSpec, &userArg, &groupArg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert userArg and groupArg to be numeric, so we don't have to execute
0000000000000000000000000000000000000000;;		// Atoi *twice* for each iteration over lines.
0000000000000000000000000000000000000000;;		uidArg, uidErr := strconv.Atoi(userArg)
0000000000000000000000000000000000000000;;		gidArg, gidErr := strconv.Atoi(groupArg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the matching user.
0000000000000000000000000000000000000000;;		users, err := ParsePasswdFilter(passwd, func(u User) bool {
0000000000000000000000000000000000000000;;			if userArg == "" {
0000000000000000000000000000000000000000;;				// Default to current state of the user.
0000000000000000000000000000000000000000;;				return u.Uid == user.Uid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if uidErr == nil {
0000000000000000000000000000000000000000;;				// If the userArg is numeric, always treat it as a UID.
0000000000000000000000000000000000000000;;				return uidArg == u.Uid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return u.Name == userArg
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we can't find the user, we have to bail.
0000000000000000000000000000000000000000;;		if err != nil && passwd != nil {
0000000000000000000000000000000000000000;;			if userArg == "" {
0000000000000000000000000000000000000000;;				userArg = strconv.Itoa(user.Uid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to find user %s: %v", userArg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var matchedUserName string
0000000000000000000000000000000000000000;;		if len(users) > 0 {
0000000000000000000000000000000000000000;;			// First match wins, even if there's more than one matching entry.
0000000000000000000000000000000000000000;;			matchedUserName = users[0].Name
0000000000000000000000000000000000000000;;			user.Uid = users[0].Uid
0000000000000000000000000000000000000000;;			user.Gid = users[0].Gid
0000000000000000000000000000000000000000;;			user.Home = users[0].Home
0000000000000000000000000000000000000000;;		} else if userArg != "" {
0000000000000000000000000000000000000000;;			// If we can't find a user with the given username, the only other valid
0000000000000000000000000000000000000000;;			// option is if it's a numeric username with no associated entry in passwd.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if uidErr != nil {
0000000000000000000000000000000000000000;;				// Not numeric.
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to find user %s: %v", userArg, ErrNoPasswdEntries)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			user.Uid = uidArg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Must be inside valid uid range.
0000000000000000000000000000000000000000;;			if user.Uid < minId || user.Uid > maxId {
0000000000000000000000000000000000000000;;				return nil, ErrRange
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Okay, so it's numeric. We can just roll with this.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// On to the groups. If we matched a username, we need to do this because of
0000000000000000000000000000000000000000;;		// the supplementary group IDs.
0000000000000000000000000000000000000000;;		if groupArg != "" || matchedUserName != "" {
0000000000000000000000000000000000000000;;			groups, err := ParseGroupFilter(group, func(g Group) bool {
0000000000000000000000000000000000000000;;				// If the group argument isn't explicit, we'll just search for it.
0000000000000000000000000000000000000000;;				if groupArg == "" {
0000000000000000000000000000000000000000;;					// Check if user is a member of this group.
0000000000000000000000000000000000000000;;					for _, u := range g.List {
0000000000000000000000000000000000000000;;						if u == matchedUserName {
0000000000000000000000000000000000000000;;							return true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if gidErr == nil {
0000000000000000000000000000000000000000;;					// If the groupArg is numeric, always treat it as a GID.
0000000000000000000000000000000000000000;;					return gidArg == g.Gid
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return g.Name == groupArg
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil && group != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to find groups for spec %v: %v", matchedUserName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only start modifying user.Gid if it is in explicit form.
0000000000000000000000000000000000000000;;			if groupArg != "" {
0000000000000000000000000000000000000000;;				if len(groups) > 0 {
0000000000000000000000000000000000000000;;					// First match wins, even if there's more than one matching entry.
0000000000000000000000000000000000000000;;					user.Gid = groups[0].Gid
0000000000000000000000000000000000000000;;				} else if groupArg != "" {
0000000000000000000000000000000000000000;;					// If we can't find a group with the given name, the only other valid
0000000000000000000000000000000000000000;;					// option is if it's a numeric group name with no associated entry in group.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if gidErr != nil {
0000000000000000000000000000000000000000;;						// Not numeric.
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unable to find group %s: %v", groupArg, ErrNoGroupEntries)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					user.Gid = gidArg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Must be inside valid gid range.
0000000000000000000000000000000000000000;;					if user.Gid < minId || user.Gid > maxId {
0000000000000000000000000000000000000000;;						return nil, ErrRange
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Okay, so it's numeric. We can just roll with this.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(groups) > 0 {
0000000000000000000000000000000000000000;;				// Supplementary group ids only make sense if in the implicit form.
0000000000000000000000000000000000000000;;				user.Sgids = make([]int, len(groups))
0000000000000000000000000000000000000000;;				for i, group := range groups {
0000000000000000000000000000000000000000;;					user.Sgids[i] = group.Gid
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return user, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAdditionalGroups looks up a list of groups by name or group id
0000000000000000000000000000000000000000;;	// against the given /etc/group formatted data. If a group name cannot
0000000000000000000000000000000000000000;;	// be found, an error will be returned. If a group id cannot be found,
0000000000000000000000000000000000000000;;	// or the given group data is nil, the id will be returned as-is
0000000000000000000000000000000000000000;;	// provided it is in the legal range.
0000000000000000000000000000000000000000;;	func GetAdditionalGroups(additionalGroups []string, group io.Reader) ([]int, error) {
0000000000000000000000000000000000000000;;		var groups = []Group{}
0000000000000000000000000000000000000000;;		if group != nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			groups, err = ParseGroupFilter(group, func(g Group) bool {
0000000000000000000000000000000000000000;;				for _, ag := range additionalGroups {
0000000000000000000000000000000000000000;;					if g.Name == ag || strconv.Itoa(g.Gid) == ag {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Unable to find additional groups %v: %v", additionalGroups, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gidMap := make(map[int]struct{})
0000000000000000000000000000000000000000;;		for _, ag := range additionalGroups {
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			for _, g := range groups {
0000000000000000000000000000000000000000;;				// if we found a matched group either by name or gid, take the
0000000000000000000000000000000000000000;;				// first matched as correct
0000000000000000000000000000000000000000;;				if g.Name == ag || strconv.Itoa(g.Gid) == ag {
0000000000000000000000000000000000000000;;					if _, ok := gidMap[g.Gid]; !ok {
0000000000000000000000000000000000000000;;						gidMap[g.Gid] = struct{}{}
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// we asked for a group but didn't find it. let's check to see
0000000000000000000000000000000000000000;;			// if we wanted a numeric group
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				gid, err := strconv.Atoi(ag)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Unable to find group %s", ag)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ensure gid is inside gid range.
0000000000000000000000000000000000000000;;				if gid < minId || gid > maxId {
0000000000000000000000000000000000000000;;					return nil, ErrRange
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gidMap[gid] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gids := []int{}
0000000000000000000000000000000000000000;;		for gid := range gidMap {
0000000000000000000000000000000000000000;;			gids = append(gids, gid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gids, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAdditionalGroupsPath is a wrapper around GetAdditionalGroups
0000000000000000000000000000000000000000;;	// that opens the groupPath given and gives it as an argument to
0000000000000000000000000000000000000000;;	// GetAdditionalGroups.
0000000000000000000000000000000000000000;;	func GetAdditionalGroupsPath(additionalGroups []string, groupPath string) ([]int, error) {
0000000000000000000000000000000000000000;;		group, err := os.Open(groupPath)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			defer group.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetAdditionalGroups(additionalGroups, group)
0000000000000000000000000000000000000000;;	}
