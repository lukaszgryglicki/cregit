0000000000000000000000000000000000000000;;	// +build linux,cgo,seccomp
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/opencontainers/runc/libcontainer/seccomp/seccomp_linux.go[Godeps/_workspace/src/github.com/opencontainers/runc/libcontainer/seccomp/seccomp_linux.go][vendor/github.com/opencontainers/runc/libcontainer/seccomp/seccomp_linux.go];	
0000000000000000000000000000000000000000;;	package seccomp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		libseccomp "github.com/seccomp/libseccomp-golang"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		actAllow = libseccomp.ActAllow
0000000000000000000000000000000000000000;;		actTrap  = libseccomp.ActTrap
0000000000000000000000000000000000000000;;		actKill  = libseccomp.ActKill
0000000000000000000000000000000000000000;;		actTrace = libseccomp.ActTrace.SetReturnCode(int16(syscall.EPERM))
0000000000000000000000000000000000000000;;		actErrno = libseccomp.ActErrno.SetReturnCode(int16(syscall.EPERM))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SeccompModeFilter refers to the syscall argument SECCOMP_MODE_FILTER.
0000000000000000000000000000000000000000;;		SeccompModeFilter = uintptr(2)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filters given syscalls in a container, preventing them from being used
0000000000000000000000000000000000000000;;	// Started in the container init process, and carried over to all child processes
0000000000000000000000000000000000000000;;	// Setns calls, however, require a separate invocation, as they are not children
0000000000000000000000000000000000000000;;	// of the init until they join the namespace
0000000000000000000000000000000000000000;;	func InitSeccomp(config *configs.Seccomp) error {
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot initialize Seccomp - nil config passed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultAction, err := getAction(config.DefaultAction)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error initializing seccomp - invalid default action")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filter, err := libseccomp.NewFilter(defaultAction)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error creating filter: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add extra architectures
0000000000000000000000000000000000000000;;		for _, arch := range config.Architectures {
0000000000000000000000000000000000000000;;			scmpArch, err := libseccomp.GetArchFromString(arch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := filter.AddArch(scmpArch); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unset no new privs bit
0000000000000000000000000000000000000000;;		if err := filter.SetNoNewPrivsBit(false); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error setting no new privileges: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add a rule for each syscall
0000000000000000000000000000000000000000;;		for _, call := range config.Syscalls {
0000000000000000000000000000000000000000;;			if call == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("encountered nil syscall while initializing Seccomp")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = matchCall(filter, call); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = filter.Load(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error loading seccomp filter into kernel: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEnabled returns if the kernel has been configured to support seccomp.
0000000000000000000000000000000000000000;;	func IsEnabled() bool {
0000000000000000000000000000000000000000;;		// Try to read from /proc/self/status for kernels > 3.8
0000000000000000000000000000000000000000;;		s, err := parseStatusFile("/proc/self/status")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Check if Seccomp is supported, via CONFIG_SECCOMP.
0000000000000000000000000000000000000000;;			if _, _, err := syscall.RawSyscall(syscall.SYS_PRCTL, syscall.PR_GET_SECCOMP, 0, 0); err != syscall.EINVAL {
0000000000000000000000000000000000000000;;				// Make sure the kernel has CONFIG_SECCOMP_FILTER.
0000000000000000000000000000000000000000;;				if _, _, err := syscall.RawSyscall(syscall.SYS_PRCTL, syscall.PR_SET_SECCOMP, SeccompModeFilter, 0); err != syscall.EINVAL {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := s["Seccomp"]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert Libcontainer Action to Libseccomp ScmpAction
0000000000000000000000000000000000000000;;	func getAction(act configs.Action) (libseccomp.ScmpAction, error) {
0000000000000000000000000000000000000000;;		switch act {
0000000000000000000000000000000000000000;;		case configs.Kill:
0000000000000000000000000000000000000000;;			return actKill, nil
0000000000000000000000000000000000000000;;		case configs.Errno:
0000000000000000000000000000000000000000;;			return actErrno, nil
0000000000000000000000000000000000000000;;		case configs.Trap:
0000000000000000000000000000000000000000;;			return actTrap, nil
0000000000000000000000000000000000000000;;		case configs.Allow:
0000000000000000000000000000000000000000;;			return actAllow, nil
0000000000000000000000000000000000000000;;		case configs.Trace:
0000000000000000000000000000000000000000;;			return actTrace, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return libseccomp.ActInvalid, fmt.Errorf("invalid action, cannot use in rule")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert Libcontainer Operator to Libseccomp ScmpCompareOp
0000000000000000000000000000000000000000;;	func getOperator(op configs.Operator) (libseccomp.ScmpCompareOp, error) {
0000000000000000000000000000000000000000;;		switch op {
0000000000000000000000000000000000000000;;		case configs.EqualTo:
0000000000000000000000000000000000000000;;			return libseccomp.CompareEqual, nil
0000000000000000000000000000000000000000;;		case configs.NotEqualTo:
0000000000000000000000000000000000000000;;			return libseccomp.CompareNotEqual, nil
0000000000000000000000000000000000000000;;		case configs.GreaterThan:
0000000000000000000000000000000000000000;;			return libseccomp.CompareGreater, nil
0000000000000000000000000000000000000000;;		case configs.GreaterThanOrEqualTo:
0000000000000000000000000000000000000000;;			return libseccomp.CompareGreaterEqual, nil
0000000000000000000000000000000000000000;;		case configs.LessThan:
0000000000000000000000000000000000000000;;			return libseccomp.CompareLess, nil
0000000000000000000000000000000000000000;;		case configs.LessThanOrEqualTo:
0000000000000000000000000000000000000000;;			return libseccomp.CompareLessOrEqual, nil
0000000000000000000000000000000000000000;;		case configs.MaskEqualTo:
0000000000000000000000000000000000000000;;			return libseccomp.CompareMaskedEqual, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return libseccomp.CompareInvalid, fmt.Errorf("invalid operator, cannot use in rule")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert Libcontainer Arg to Libseccomp ScmpCondition
0000000000000000000000000000000000000000;;	func getCondition(arg *configs.Arg) (libseccomp.ScmpCondition, error) {
0000000000000000000000000000000000000000;;		cond := libseccomp.ScmpCondition{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if arg == nil {
0000000000000000000000000000000000000000;;			return cond, fmt.Errorf("cannot convert nil to syscall condition")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		op, err := getOperator(arg.Op)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return cond, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return libseccomp.MakeCondition(arg.Index, op, arg.Value, arg.ValueTwo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a rule to match a single syscall
0000000000000000000000000000000000000000;;	func matchCall(filter *libseccomp.ScmpFilter, call *configs.Syscall) error {
0000000000000000000000000000000000000000;;		if call == nil || filter == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot use nil as syscall to block")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(call.Name) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("empty string is not a valid syscall")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we can't resolve the syscall, assume it's not supported on this kernel
0000000000000000000000000000000000000000;;		// Ignore it, don't error out
0000000000000000000000000000000000000000;;		callNum, err := libseccomp.GetSyscallFromName(call.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert the call's action to the libseccomp equivalent
0000000000000000000000000000000000000000;;		callAct, err := getAction(call.Action)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unconditional match - just add the rule
0000000000000000000000000000000000000000;;		if len(call.Args) == 0 {
0000000000000000000000000000000000000000;;			if err = filter.AddRule(callNum, callAct); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Conditional match - convert the per-arg rules into library format
0000000000000000000000000000000000000000;;			conditions := []libseccomp.ScmpCondition{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, cond := range call.Args {
0000000000000000000000000000000000000000;;				newCond, err := getCondition(cond)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				conditions = append(conditions, newCond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = filter.AddRuleConditional(callNum, callAct, conditions); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseStatusFile(path string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		status := make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			text := s.Text()
0000000000000000000000000000000000000000;;			parts := strings.Split(text, ":")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(parts) <= 1 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status[parts[0]] = parts[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
