0000000000000000000000000000000000000000;;	package seccomp
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/opencontainers/runc/libcontainer/seccomp/config.go[Godeps/_workspace/src/github.com/opencontainers/runc/libcontainer/seccomp/config.go][vendor/github.com/opencontainers/runc/libcontainer/seccomp/config.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var operators = map[string]configs.Operator{
0000000000000000000000000000000000000000;;		"SCMP_CMP_NE":        configs.NotEqualTo,
0000000000000000000000000000000000000000;;		"SCMP_CMP_LT":        configs.LessThan,
0000000000000000000000000000000000000000;;		"SCMP_CMP_LE":        configs.LessThanOrEqualTo,
0000000000000000000000000000000000000000;;		"SCMP_CMP_EQ":        configs.EqualTo,
0000000000000000000000000000000000000000;;		"SCMP_CMP_GE":        configs.GreaterThanOrEqualTo,
0000000000000000000000000000000000000000;;		"SCMP_CMP_GT":        configs.GreaterThan,
0000000000000000000000000000000000000000;;		"SCMP_CMP_MASKED_EQ": configs.MaskEqualTo,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var actions = map[string]configs.Action{
0000000000000000000000000000000000000000;;		"SCMP_ACT_KILL":  configs.Kill,
0000000000000000000000000000000000000000;;		"SCMP_ACT_ERRNO": configs.Errno,
0000000000000000000000000000000000000000;;		"SCMP_ACT_TRAP":  configs.Trap,
0000000000000000000000000000000000000000;;		"SCMP_ACT_ALLOW": configs.Allow,
0000000000000000000000000000000000000000;;		"SCMP_ACT_TRACE": configs.Trace,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var archs = map[string]string{
0000000000000000000000000000000000000000;;		"SCMP_ARCH_X86":         "x86",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_X86_64":      "amd64",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_X32":         "x32",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_ARM":         "arm",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_AARCH64":     "arm64",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_MIPS":        "mips",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_MIPS64":      "mips64",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_MIPS64N32":   "mips64n32",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_MIPSEL":      "mipsel",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_MIPSEL64":    "mipsel64",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_MIPSEL64N32": "mipsel64n32",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_PPC":         "ppc",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_PPC64":       "ppc64",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_PPC64LE":     "ppc64le",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_S390":        "s390",
0000000000000000000000000000000000000000;;		"SCMP_ARCH_S390X":       "s390x",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertStringToOperator converts a string into a Seccomp comparison operator.
0000000000000000000000000000000000000000;;	// Comparison operators use the names they are assigned by Libseccomp's header.
0000000000000000000000000000000000000000;;	// Attempting to convert a string that is not a valid operator results in an
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func ConvertStringToOperator(in string) (configs.Operator, error) {
0000000000000000000000000000000000000000;;		if op, ok := operators[in]; ok == true {
0000000000000000000000000000000000000000;;			return op, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("string %s is not a valid operator for seccomp", in)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertStringToAction converts a string into a Seccomp rule match action.
0000000000000000000000000000000000000000;;	// Actions use the names they are assigned in Libseccomp's header, though some
0000000000000000000000000000000000000000;;	// (notable, SCMP_ACT_TRACE) are not available in this implementation and will
0000000000000000000000000000000000000000;;	// return errors.
0000000000000000000000000000000000000000;;	// Attempting to convert a string that is not a valid action results in an
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func ConvertStringToAction(in string) (configs.Action, error) {
0000000000000000000000000000000000000000;;		if act, ok := actions[in]; ok == true {
0000000000000000000000000000000000000000;;			return act, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("string %s is not a valid action for seccomp", in)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertStringToArch converts a string into a Seccomp comparison arch.
0000000000000000000000000000000000000000;;	func ConvertStringToArch(in string) (string, error) {
0000000000000000000000000000000000000000;;		if arch, ok := archs[in]; ok == true {
0000000000000000000000000000000000000000;;			return arch, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("string %s is not a valid arch for seccomp", in)
0000000000000000000000000000000000000000;;	}
