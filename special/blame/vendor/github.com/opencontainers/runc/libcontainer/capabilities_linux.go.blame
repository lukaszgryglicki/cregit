0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/security/capabilities/types.go[Godeps/_workspace/src/github.com/docker/libcontainer/security/capabilities/types.go][vendor/github.com/opencontainers/runc/libcontainer/capabilities_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/syndtr/gocapability/capability"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const allCapabilityTypes = capability.CAPS | capability.BOUNDS | capability.AMBS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var capabilityMap map[string]capability.Cap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		capabilityMap = make(map[string]capability.Cap)
0000000000000000000000000000000000000000;;		last := capability.CAP_LAST_CAP
0000000000000000000000000000000000000000;;		// workaround for RHEL6 which has no /proc/sys/kernel/cap_last_cap
0000000000000000000000000000000000000000;;		if last == capability.Cap(63) {
0000000000000000000000000000000000000000;;			last = capability.CAP_BLOCK_SUSPEND
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cap := range capability.List() {
0000000000000000000000000000000000000000;;			if cap > last {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			capKey := fmt.Sprintf("CAP_%s", strings.ToUpper(cap.String()))
0000000000000000000000000000000000000000;;			capabilityMap[capKey] = cap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCapWhitelist(caps []string) (*whitelist, error) {
0000000000000000000000000000000000000000;;		l := []capability.Cap{}
0000000000000000000000000000000000000000;;		for _, c := range caps {
0000000000000000000000000000000000000000;;			v, ok := capabilityMap[c]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unknown capability %q", c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l = append(l, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pid, err := capability.NewPid(os.Getpid())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &whitelist{
0000000000000000000000000000000000000000;;			keep: l,
0000000000000000000000000000000000000000;;			pid:  pid,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type whitelist struct {
0000000000000000000000000000000000000000;;		pid  capability.Capabilities
0000000000000000000000000000000000000000;;		keep []capability.Cap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dropBoundingSet drops the capability bounding set to those specified in the whitelist.
0000000000000000000000000000000000000000;;	func (w *whitelist) dropBoundingSet() error {
0000000000000000000000000000000000000000;;		w.pid.Clear(capability.BOUNDS)
0000000000000000000000000000000000000000;;		w.pid.Set(capability.BOUNDS, w.keep...)
0000000000000000000000000000000000000000;;		return w.pid.Apply(capability.BOUNDS)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// drop drops all capabilities for the current process except those specified in the whitelist.
0000000000000000000000000000000000000000;;	func (w *whitelist) drop() error {
0000000000000000000000000000000000000000;;		w.pid.Clear(allCapabilityTypes)
0000000000000000000000000000000000000000;;		w.pid.Set(allCapabilityTypes, w.keep...)
0000000000000000000000000000000000000000;;		return w.pid.Apply(allCapabilityTypes)
0000000000000000000000000000000000000000;;	}
