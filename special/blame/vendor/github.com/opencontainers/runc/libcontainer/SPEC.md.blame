0000000000000000000000000000000000000000;;	## Container Specification - v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This is the standard configuration for version 1 containers.  It includes
0000000000000000000000000000000000000000;;	namespaces, standard filesystem setup, a default Linux capability set, and
0000000000000000000000000000000000000000;;	information about resource reservations.  It also has information about any 
0000000000000000000000000000000000000000;;	populated environment settings for the processes running inside a container.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Along with the configuration of how a container is created the standard also
0000000000000000000000000000000000000000;;	discusses actions that can be performed on a container to manage and inspect
0000000000000000000000000000000000000000;;	information about the processes running inside.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The v1 profile is meant to be able to accommodate the majority of applications
0000000000000000000000000000000000000000;;	with a strong security configuration.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### System Requirements and Compatibility
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Minimum requirements:
0000000000000000000000000000000000000000;;	* Kernel version - 3.10 recommended 2.6.2x minimum(with backported patches)
0000000000000000000000000000000000000000;;	* Mounted cgroups with each subsystem in its own hierarchy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Namespaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|     Flag      | Enabled | 
0000000000000000000000000000000000000000;;	| ------------  | ------- |
0000000000000000000000000000000000000000;;	| CLONE_NEWPID  |    1    |
0000000000000000000000000000000000000000;;	| CLONE_NEWUTS  |    1    |
0000000000000000000000000000000000000000;;	| CLONE_NEWIPC  |    1    |
0000000000000000000000000000000000000000;;	| CLONE_NEWNET  |    1    |
0000000000000000000000000000000000000000;;	| CLONE_NEWNS   |    1    |
0000000000000000000000000000000000000000;;	| CLONE_NEWUSER |    1    |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Namespaces are created for the container via the `clone` syscall.  
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Filesystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A root filesystem must be provided to a container for execution.  The container
0000000000000000000000000000000000000000;;	will use this root filesystem (rootfs) to jail and spawn processes inside where
0000000000000000000000000000000000000000;;	the binaries and system libraries are local to that directory.  Any binaries
0000000000000000000000000000000000000000;;	to be executed must be contained within this rootfs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Mounts that happen inside the container are automatically cleaned up when the
0000000000000000000000000000000000000000;;	container exits as the mount namespace is destroyed and the kernel will 
0000000000000000000000000000000000000000;;	unmount all the mounts that were setup within that namespace.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For a container to execute properly there are certain filesystems that 
0000000000000000000000000000000000000000;;	are required to be mounted within the rootfs that the runtime will setup.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|     Path    |  Type  |                  Flags                 |                 Data                     |
0000000000000000000000000000000000000000;;	| ----------- | ------ | -------------------------------------- | ---------------------------------------- |
0000000000000000000000000000000000000000;;	| /proc       | proc   | MS_NOEXEC,MS_NOSUID,MS_NODEV           |                                          |
0000000000000000000000000000000000000000;;	| /dev        | tmpfs  | MS_NOEXEC,MS_STRICTATIME               | mode=755                                 |
0000000000000000000000000000000000000000;;	| /dev/shm    | tmpfs  | MS_NOEXEC,MS_NOSUID,MS_NODEV           | mode=1777,size=65536k                    |
0000000000000000000000000000000000000000;;	| /dev/mqueue | mqueue | MS_NOEXEC,MS_NOSUID,MS_NODEV           |                                          |
0000000000000000000000000000000000000000;;	| /dev/pts    | devpts | MS_NOEXEC,MS_NOSUID                    | newinstance,ptmxmode=0666,mode=620,gid=5 |
0000000000000000000000000000000000000000;;	| /sys        | sysfs  | MS_NOEXEC,MS_NOSUID,MS_NODEV,MS_RDONLY |                                          |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After a container's filesystems are mounted within the newly created 
0000000000000000000000000000000000000000;;	mount namespace `/dev` will need to be populated with a set of device nodes.
0000000000000000000000000000000000000000;;	It is expected that a rootfs does not need to have any device nodes specified
0000000000000000000000000000000000000000;;	for `/dev` within the rootfs as the container will setup the correct devices
0000000000000000000000000000000000000000;;	that are required for executing a container's process.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|      Path    | Mode |   Access   |
0000000000000000000000000000000000000000;;	| ------------ | ---- | ---------- |
0000000000000000000000000000000000000000;;	| /dev/null    | 0666 |  rwm       |
0000000000000000000000000000000000000000;;	| /dev/zero    | 0666 |  rwm       |
0000000000000000000000000000000000000000;;	| /dev/full    | 0666 |  rwm       |
0000000000000000000000000000000000000000;;	| /dev/tty     | 0666 |  rwm       |
0000000000000000000000000000000000000000;;	| /dev/random  | 0666 |  rwm       |
0000000000000000000000000000000000000000;;	| /dev/urandom | 0666 |  rwm       |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**ptmx**
0000000000000000000000000000000000000000;;	`/dev/ptmx` will need to be a symlink to the host's `/dev/ptmx` within
0000000000000000000000000000000000000000;;	the container.  
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The use of a pseudo TTY is optional within a container and it should support both.
0000000000000000000000000000000000000000;;	If a pseudo is provided to the container `/dev/console` will need to be 
0000000000000000000000000000000000000000;;	setup by binding the console in `/dev/` after it has been populated and mounted
0000000000000000000000000000000000000000;;	in tmpfs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|      Source     | Destination  | UID GID | Mode | Type |
0000000000000000000000000000000000000000;;	| --------------- | ------------ | ------- | ---- | ---- |
0000000000000000000000000000000000000000;;	| *pty host path* | /dev/console | 0 0     | 0600 | bind | 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After `/dev/null` has been setup we check for any external links between
0000000000000000000000000000000000000000;;	the container's io, STDIN, STDOUT, STDERR.  If the container's io is pointing
0000000000000000000000000000000000000000;;	to `/dev/null` outside the container we close and `dup2` the `/dev/null` 
0000000000000000000000000000000000000000;;	that is local to the container's rootfs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After the container has `/proc` mounted a few standard symlinks are setup 
0000000000000000000000000000000000000000;;	within `/dev/` for the io.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|    Source       | Destination |
0000000000000000000000000000000000000000;;	| --------------- | ----------- |
0000000000000000000000000000000000000000;;	| /proc/self/fd   | /dev/fd     |
0000000000000000000000000000000000000000;;	| /proc/self/fd/0 | /dev/stdin  |
0000000000000000000000000000000000000000;;	| /proc/self/fd/1 | /dev/stdout |
0000000000000000000000000000000000000000;;	| /proc/self/fd/2 | /dev/stderr |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A `pivot_root` is used to change the root for the process, effectively 
0000000000000000000000000000000000000000;;	jailing the process inside the rootfs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```c
0000000000000000000000000000000000000000;;	put_old = mkdir(...);
0000000000000000000000000000000000000000;;	pivot_root(rootfs, put_old);
0000000000000000000000000000000000000000;;	chdir("/");
0000000000000000000000000000000000000000;;	unmount(put_old, MS_DETACH);
0000000000000000000000000000000000000000;;	rmdir(put_old);
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For container's running with a rootfs inside `ramfs` a `MS_MOVE` combined
0000000000000000000000000000000000000000;;	with a `chroot` is required as `pivot_root` is not supported in `ramfs`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```c
0000000000000000000000000000000000000000;;	mount(rootfs, "/", NULL, MS_MOVE, NULL);
0000000000000000000000000000000000000000;;	chroot(".");
0000000000000000000000000000000000000000;;	chdir("/");
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `umask` is set back to `0022` after the filesystem setup has been completed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Resources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cgroups are used to handle resource allocation for containers.  This includes
0000000000000000000000000000000000000000;;	system resources like cpu, memory, and device access.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	| Subsystem  | Enabled |
0000000000000000000000000000000000000000;;	| ---------- | ------- |
0000000000000000000000000000000000000000;;	| devices    | 1       |
0000000000000000000000000000000000000000;;	| memory     | 1       |
0000000000000000000000000000000000000000;;	| cpu        | 1       |
0000000000000000000000000000000000000000;;	| cpuacct    | 1       |
0000000000000000000000000000000000000000;;	| cpuset     | 1       |
0000000000000000000000000000000000000000;;	| blkio      | 1       |
0000000000000000000000000000000000000000;;	| perf_event | 1       |
0000000000000000000000000000000000000000;;	| freezer    | 1       |
0000000000000000000000000000000000000000;;	| hugetlb    | 1       |
0000000000000000000000000000000000000000;;	| pids       | 1       |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	All cgroup subsystem are joined so that statistics can be collected from
0000000000000000000000000000000000000000;;	each of the subsystems.  Freezer does not expose any stats but is joined
0000000000000000000000000000000000000000;;	so that containers can be paused and resumed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The parent process of the container's init must place the init pid inside
0000000000000000000000000000000000000000;;	the correct cgroups before the initialization begins.  This is done so
0000000000000000000000000000000000000000;;	that no processes or threads escape the cgroups.  This sync is 
0000000000000000000000000000000000000000;;	done via a pipe ( specified in the runtime section below ) that the container's
0000000000000000000000000000000000000000;;	init process will block waiting for the parent to finish setup.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Security 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The standard set of Linux capabilities that are set in a container
0000000000000000000000000000000000000000;;	provide a good default for security and flexibility for the applications.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|     Capability       | Enabled |
0000000000000000000000000000000000000000;;	| -------------------- | ------- |
0000000000000000000000000000000000000000;;	| CAP_NET_RAW          | 1       |
0000000000000000000000000000000000000000;;	| CAP_NET_BIND_SERVICE | 1       |
0000000000000000000000000000000000000000;;	| CAP_AUDIT_READ       | 1       |
0000000000000000000000000000000000000000;;	| CAP_AUDIT_WRITE      | 1       |
0000000000000000000000000000000000000000;;	| CAP_DAC_OVERRIDE     | 1       |
0000000000000000000000000000000000000000;;	| CAP_SETFCAP          | 1       |
0000000000000000000000000000000000000000;;	| CAP_SETPCAP          | 1       |
0000000000000000000000000000000000000000;;	| CAP_SETGID           | 1       |
0000000000000000000000000000000000000000;;	| CAP_SETUID           | 1       |
0000000000000000000000000000000000000000;;	| CAP_MKNOD            | 1       |
0000000000000000000000000000000000000000;;	| CAP_CHOWN            | 1       |
0000000000000000000000000000000000000000;;	| CAP_FOWNER           | 1       |
0000000000000000000000000000000000000000;;	| CAP_FSETID           | 1       |
0000000000000000000000000000000000000000;;	| CAP_KILL             | 1       |
0000000000000000000000000000000000000000;;	| CAP_SYS_CHROOT       | 1       |
0000000000000000000000000000000000000000;;	| CAP_NET_BROADCAST    | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_MODULE       | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_RAWIO        | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_PACCT        | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_ADMIN        | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_NICE         | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_RESOURCE     | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_TIME         | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_TTY_CONFIG   | 0       |
0000000000000000000000000000000000000000;;	| CAP_AUDIT_CONTROL    | 0       |
0000000000000000000000000000000000000000;;	| CAP_MAC_OVERRIDE     | 0       |
0000000000000000000000000000000000000000;;	| CAP_MAC_ADMIN        | 0       |
0000000000000000000000000000000000000000;;	| CAP_NET_ADMIN        | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYSLOG           | 0       |
0000000000000000000000000000000000000000;;	| CAP_DAC_READ_SEARCH  | 0       |
0000000000000000000000000000000000000000;;	| CAP_LINUX_IMMUTABLE  | 0       |
0000000000000000000000000000000000000000;;	| CAP_IPC_LOCK         | 0       |
0000000000000000000000000000000000000000;;	| CAP_IPC_OWNER        | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_PTRACE       | 0       |
0000000000000000000000000000000000000000;;	| CAP_SYS_BOOT         | 0       |
0000000000000000000000000000000000000000;;	| CAP_LEASE            | 0       |
0000000000000000000000000000000000000000;;	| CAP_WAKE_ALARM       | 0       |
0000000000000000000000000000000000000000;;	| CAP_BLOCK_SUSPEND    | 0       |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Additional security layers like [apparmor](https://wiki.ubuntu.com/AppArmor)
0000000000000000000000000000000000000000;;	and [selinux](http://selinuxproject.org/page/Main_Page) can be used with
0000000000000000000000000000000000000000;;	the containers.  A container should support setting an apparmor profile or 
0000000000000000000000000000000000000000;;	selinux process and mount labels if provided in the configuration.  
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Standard apparmor profile:
0000000000000000000000000000000000000000;;	```c
0000000000000000000000000000000000000000;;	#include <tunables/global>
0000000000000000000000000000000000000000;;	profile <profile_name> flags=(attach_disconnected,mediate_deleted) {
0000000000000000000000000000000000000000;;	  #include <abstractions/base>
0000000000000000000000000000000000000000;;	  network,
0000000000000000000000000000000000000000;;	  capability,
0000000000000000000000000000000000000000;;	  file,
0000000000000000000000000000000000000000;;	  umount,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  deny @{PROC}/sys/fs/** wklx,
0000000000000000000000000000000000000000;;	  deny @{PROC}/sysrq-trigger rwklx,
0000000000000000000000000000000000000000;;	  deny @{PROC}/mem rwklx,
0000000000000000000000000000000000000000;;	  deny @{PROC}/kmem rwklx,
0000000000000000000000000000000000000000;;	  deny @{PROC}/sys/kernel/[^s][^h][^m]* wklx,
0000000000000000000000000000000000000000;;	  deny @{PROC}/sys/kernel/*/** wklx,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  deny mount,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  deny /sys/[^f]*/** wklx,
0000000000000000000000000000000000000000;;	  deny /sys/f[^s]*/** wklx,
0000000000000000000000000000000000000000;;	  deny /sys/fs/[^c]*/** wklx,
0000000000000000000000000000000000000000;;	  deny /sys/fs/c[^g]*/** wklx,
0000000000000000000000000000000000000000;;	  deny /sys/fs/cg[^r]*/** wklx,
0000000000000000000000000000000000000000;;	  deny /sys/firmware/efi/efivars/** rwklx,
0000000000000000000000000000000000000000;;	  deny /sys/kernel/security/** rwklx,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*TODO: seccomp work is being done to find a good default config*
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Runtime and Init Process
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	During container creation the parent process needs to talk to the container's init 
0000000000000000000000000000000000000000;;	process and have a form of synchronization.  This is accomplished by creating
0000000000000000000000000000000000000000;;	a pipe that is passed to the container's init.  When the init process first spawns 
0000000000000000000000000000000000000000;;	it will block on its side of the pipe until the parent closes its side.  This
0000000000000000000000000000000000000000;;	allows the parent to have time to set the new process inside a cgroup hierarchy 
0000000000000000000000000000000000000000;;	and/or write any uid/gid mappings required for user namespaces.  
0000000000000000000000000000000000000000;;	The pipe is passed to the init process via FD 3.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The application consuming libcontainer should be compiled statically.  libcontainer
0000000000000000000000000000000000000000;;	does not define any init process and the arguments provided are used to `exec` the
0000000000000000000000000000000000000000;;	process inside the application.  There should be no long running init within the 
0000000000000000000000000000000000000000;;	container spec.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If a pseudo tty is provided to a container it will open and `dup2` the console
0000000000000000000000000000000000000000;;	as the container's STDIN, STDOUT, STDERR as well as mounting the console
0000000000000000000000000000000000000000;;	as `/dev/console`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	An extra set of mounts are provided to a container and setup for use.  A container's
0000000000000000000000000000000000000000;;	rootfs can contain some non portable files inside that can cause side effects during
0000000000000000000000000000000000000000;;	execution of a process.  These files are usually created and populated with the container
0000000000000000000000000000000000000000;;	specific information via the runtime.  
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Extra runtime files:**
0000000000000000000000000000000000000000;;	* /etc/hosts 
0000000000000000000000000000000000000000;;	* /etc/resolv.conf
0000000000000000000000000000000000000000;;	* /etc/hostname
0000000000000000000000000000000000000000;;	* /etc/localtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Defaults
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are a few defaults that can be overridden by users, but in their omission
0000000000000000000000000000000000000000;;	these apply to processes within a container.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|       Type          |             Value              |
0000000000000000000000000000000000000000;;	| ------------------- | ------------------------------ |
0000000000000000000000000000000000000000;;	| Parent Death Signal | SIGKILL                        | 
0000000000000000000000000000000000000000;;	| UID                 | 0                              |
0000000000000000000000000000000000000000;;	| GID                 | 0                              |
0000000000000000000000000000000000000000;;	| GROUPS              | 0, NULL                        |
0000000000000000000000000000000000000000;;	| CWD                 | "/"                            |
0000000000000000000000000000000000000000;;	| $HOME               | Current user's home dir or "/" |
0000000000000000000000000000000000000000;;	| Readonly rootfs     | false                          |
0000000000000000000000000000000000000000;;	| Pseudo TTY          | false                          |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Actions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After a container is created there is a standard set of actions that can
0000000000000000000000000000000000000000;;	be done to the container.  These actions are part of the public API for 
0000000000000000000000000000000000000000;;	a container.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	|     Action     |                         Description                                |
0000000000000000000000000000000000000000;;	| -------------- | ------------------------------------------------------------------ |
0000000000000000000000000000000000000000;;	| Get processes  | Return all the pids for processes running inside a container       | 
0000000000000000000000000000000000000000;;	| Get Stats      | Return resource statistics for the container as a whole            |
0000000000000000000000000000000000000000;;	| Wait           | Waits on the container's init process ( pid 1 )                    |
0000000000000000000000000000000000000000;;	| Wait Process   | Wait on any of the container's processes returning the exit status | 
0000000000000000000000000000000000000000;;	| Destroy        | Kill the container's init process and remove any filesystem state  |
0000000000000000000000000000000000000000;;	| Signal         | Send a signal to the container's init process                      |
0000000000000000000000000000000000000000;;	| Signal Process | Send a signal to any of the container's processes                  |
0000000000000000000000000000000000000000;;	| Pause          | Pause all processes inside the container                           |
0000000000000000000000000000000000000000;;	| Resume         | Resume all processes inside the container if paused                |
0000000000000000000000000000000000000000;;	| Exec           | Execute a new process inside of the container  ( requires setns )  |
0000000000000000000000000000000000000000;;	| Set            | Setup configs of the container after it's created                  |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Execute a new process inside of a running container.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	User can execute a new process inside of a running container. Any binaries to be
0000000000000000000000000000000000000000;;	executed must be accessible within the container's rootfs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The started process will run inside the container's rootfs. Any changes
0000000000000000000000000000000000000000;;	made by the process to the container's filesystem will persist after the
0000000000000000000000000000000000000000;;	process finished executing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The started process will join all the container's existing namespaces. When the
0000000000000000000000000000000000000000;;	container is paused, the process will also be paused and will resume when
0000000000000000000000000000000000000000;;	the container is unpaused.  The started process will only run when the container's
0000000000000000000000000000000000000000;;	primary process (PID 1) is running, and will not be restarted when the container
0000000000000000000000000000000000000000;;	is restarted.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Planned additions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The started process will have its own cgroups nested inside the container's
0000000000000000000000000000000000000000;;	cgroups. This is used for process tracking and optionally resource allocation
0000000000000000000000000000000000000000;;	handling for the new process. Freezer cgroup is required, the rest of the cgroups
0000000000000000000000000000000000000000;;	are optional. The process executor must place its pid inside the correct
0000000000000000000000000000000000000000;;	cgroups before starting the process. This is done so that no child processes or
0000000000000000000000000000000000000000;;	threads can escape the cgroups.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When the process is stopped, the process executor will try (in a best-effort way)
0000000000000000000000000000000000000000;;	to stop all its children and remove the sub-cgroups.
