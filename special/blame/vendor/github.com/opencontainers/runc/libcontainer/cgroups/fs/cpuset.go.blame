0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/cpuset.go[Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/cpuset.go][vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs/cpuset.go];	
0000000000000000000000000000000000000000;;	package fs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		libcontainerUtils "github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CpusetGroup struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) Name() string {
0000000000000000000000000000000000000000;;		return "cpuset"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) Apply(d *cgroupData) error {
0000000000000000000000000000000000000000;;		dir, err := d.path("cpuset")
0000000000000000000000000000000000000000;;		if err != nil && !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.ApplyDir(dir, d.config, d.pid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) Set(path string, cgroup *configs.Cgroup) error {
0000000000000000000000000000000000000000;;		if cgroup.Resources.CpusetCpus != "" {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "cpuset.cpus", cgroup.Resources.CpusetCpus); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cgroup.Resources.CpusetMems != "" {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "cpuset.mems", cgroup.Resources.CpusetMems); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) Remove(d *cgroupData) error {
0000000000000000000000000000000000000000;;		return removePath(d.path("cpuset"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) GetStats(path string, stats *cgroups.Stats) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) ApplyDir(dir string, cgroup *configs.Cgroup, pid int) error {
0000000000000000000000000000000000000000;;		// This might happen if we have no cpuset cgroup mounted.
0000000000000000000000000000000000000000;;		// Just do nothing and don't fail.
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		root, err := getCgroupRoot()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.ensureParent(dir, root); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// because we are not using d.join we need to place the pid into the procs file
0000000000000000000000000000000000000000;;		// unlike the other subsystems
0000000000000000000000000000000000000000;;		if err := cgroups.WriteCgroupProc(dir, pid); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) getSubsystemSettings(parent string) (cpus []byte, mems []byte, err error) {
0000000000000000000000000000000000000000;;		if cpus, err = ioutil.ReadFile(filepath.Join(parent, "cpuset.cpus")); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mems, err = ioutil.ReadFile(filepath.Join(parent, "cpuset.mems")); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cpus, mems, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureParent makes sure that the parent directory of current is created
0000000000000000000000000000000000000000;;	// and populated with the proper cpus and mems files copied from
0000000000000000000000000000000000000000;;	// it's parent.
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) ensureParent(current, root string) error {
0000000000000000000000000000000000000000;;		parent := filepath.Dir(current)
0000000000000000000000000000000000000000;;		if libcontainerUtils.CleanPath(parent) == root {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Avoid infinite recursion.
0000000000000000000000000000000000000000;;		if parent == current {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cpuset: cgroup parent path outside cgroup root")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.ensureParent(parent, root); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(current, 0755); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.copyIfNeeded(current, parent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyIfNeeded copies the cpuset.cpus and cpuset.mems from the parent
0000000000000000000000000000000000000000;;	// directory to the current directory if the file's contents are 0
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) copyIfNeeded(current, parent string) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err                      error
0000000000000000000000000000000000000000;;			currentCpus, currentMems []byte
0000000000000000000000000000000000000000;;			parentCpus, parentMems   []byte
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if currentCpus, currentMems, err = s.getSubsystemSettings(current); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parentCpus, parentMems, err = s.getSubsystemSettings(parent); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.isEmpty(currentCpus) {
0000000000000000000000000000000000000000;;			if err := writeFile(current, "cpuset.cpus", string(parentCpus)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.isEmpty(currentMems) {
0000000000000000000000000000000000000000;;			if err := writeFile(current, "cpuset.mems", string(parentMems)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpusetGroup) isEmpty(b []byte) bool {
0000000000000000000000000000000000000000;;		return len(bytes.Trim(b, "\n")) == 0
0000000000000000000000000000000000000000;;	}
