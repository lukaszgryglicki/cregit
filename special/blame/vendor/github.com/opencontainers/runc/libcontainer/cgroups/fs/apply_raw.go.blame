0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/apply_raw.go[Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/apply_raw.go][vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs/apply_raw.go];	
0000000000000000000000000000000000000000;;	package fs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		libcontainerUtils "github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		subsystems = subsystemSet{
0000000000000000000000000000000000000000;;			&CpusetGroup{},
0000000000000000000000000000000000000000;;			&DevicesGroup{},
0000000000000000000000000000000000000000;;			&MemoryGroup{},
0000000000000000000000000000000000000000;;			&CpuGroup{},
0000000000000000000000000000000000000000;;			&CpuacctGroup{},
0000000000000000000000000000000000000000;;			&PidsGroup{},
0000000000000000000000000000000000000000;;			&BlkioGroup{},
0000000000000000000000000000000000000000;;			&HugetlbGroup{},
0000000000000000000000000000000000000000;;			&NetClsGroup{},
0000000000000000000000000000000000000000;;			&NetPrioGroup{},
0000000000000000000000000000000000000000;;			&PerfEventGroup{},
0000000000000000000000000000000000000000;;			&FreezerGroup{},
0000000000000000000000000000000000000000;;			&NameGroup{GroupName: "name=systemd", Join: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		HugePageSizes, _ = cgroups.GetHugePageSize()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errSubsystemDoesNotExist = errors.New("cgroup: subsystem does not exist")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subsystemSet []subsystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s subsystemSet) Get(name string) (subsystem, error) {
0000000000000000000000000000000000000000;;		for _, ss := range s {
0000000000000000000000000000000000000000;;			if ss.Name() == name {
0000000000000000000000000000000000000000;;				return ss, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errSubsystemDoesNotExist
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subsystem interface {
0000000000000000000000000000000000000000;;		// Name returns the name of the subsystem.
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		// Returns the stats, as 'stats', corresponding to the cgroup under 'path'.
0000000000000000000000000000000000000000;;		GetStats(path string, stats *cgroups.Stats) error
0000000000000000000000000000000000000000;;		// Removes the cgroup represented by 'cgroupData'.
0000000000000000000000000000000000000000;;		Remove(*cgroupData) error
0000000000000000000000000000000000000000;;		// Creates and joins the cgroup represented by 'cgroupData'.
0000000000000000000000000000000000000000;;		Apply(*cgroupData) error
0000000000000000000000000000000000000000;;		// Set the cgroup represented by cgroup.
0000000000000000000000000000000000000000;;		Set(path string, cgroup *configs.Cgroup) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Manager struct {
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		Cgroups *configs.Cgroup
0000000000000000000000000000000000000000;;		Paths   map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The absolute path to the root of the cgroup hierarchies.
0000000000000000000000000000000000000000;;	var cgroupRootLock sync.Mutex
0000000000000000000000000000000000000000;;	var cgroupRoot string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the cgroupRoot.
0000000000000000000000000000000000000000;;	func getCgroupRoot() (string, error) {
0000000000000000000000000000000000000000;;		cgroupRootLock.Lock()
0000000000000000000000000000000000000000;;		defer cgroupRootLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cgroupRoot != "" {
0000000000000000000000000000000000000000;;			return cgroupRoot, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		root, err := cgroups.FindCgroupMountpointDir()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := os.Stat(root); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupRoot = root
0000000000000000000000000000000000000000;;		return cgroupRoot, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cgroupData struct {
0000000000000000000000000000000000000000;;		root      string
0000000000000000000000000000000000000000;;		innerPath string
0000000000000000000000000000000000000000;;		config    *configs.Cgroup
0000000000000000000000000000000000000000;;		pid       int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) Apply(pid int) (err error) {
0000000000000000000000000000000000000000;;		if m.Cgroups == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		defer m.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var c = m.Cgroups
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d, err := getCgroupData(m.Cgroups, pid)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Paths != nil {
0000000000000000000000000000000000000000;;			paths := make(map[string]string)
0000000000000000000000000000000000000000;;			for name, path := range c.Paths {
0000000000000000000000000000000000000000;;				_, err := d.path(name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				paths[name] = path
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.Paths = paths
0000000000000000000000000000000000000000;;			return cgroups.EnterPid(m.Paths, pid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		paths := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, sys := range subsystems {
0000000000000000000000000000000000000000;;			if err := sys.Apply(d); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Apply should, ideally, be reentrant or be broken up into a separate
0000000000000000000000000000000000000000;;			// create and join phase so that the cgroup hierarchy for a container can be
0000000000000000000000000000000000000000;;			// created then join consists of writing the process pids to cgroup.procs
0000000000000000000000000000000000000000;;			p, err := d.path(sys.Name())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// The non-presence of the devices subsystem is
0000000000000000000000000000000000000000;;				// considered fatal for security reasons.
0000000000000000000000000000000000000000;;				if cgroups.IsNotFound(err) && sys.Name() != "devices" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			paths[sys.Name()] = p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.Paths = paths
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) Destroy() error {
0000000000000000000000000000000000000000;;		if m.Cgroups.Paths != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		defer m.mu.Unlock()
0000000000000000000000000000000000000000;;		if err := cgroups.RemovePaths(m.Paths); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.Paths = make(map[string]string)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetPaths() map[string]string {
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		paths := m.Paths
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;		return paths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetStats() (*cgroups.Stats, error) {
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		defer m.mu.Unlock()
0000000000000000000000000000000000000000;;		stats := cgroups.NewStats()
0000000000000000000000000000000000000000;;		for name, path := range m.Paths {
0000000000000000000000000000000000000000;;			sys, err := subsystems.Get(name)
0000000000000000000000000000000000000000;;			if err == errSubsystemDoesNotExist || !cgroups.PathExists(path) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := sys.GetStats(path, stats); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) Set(container *configs.Config) error {
0000000000000000000000000000000000000000;;		// If Paths are set, then we are just joining cgroups paths
0000000000000000000000000000000000000000;;		// and there is no need to set any values.
0000000000000000000000000000000000000000;;		if m.Cgroups.Paths != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		paths := m.GetPaths()
0000000000000000000000000000000000000000;;		for _, sys := range subsystems {
0000000000000000000000000000000000000000;;			path := paths[sys.Name()]
0000000000000000000000000000000000000000;;			if err := sys.Set(path, container.Cgroups); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.Paths["cpu"] != "" {
0000000000000000000000000000000000000000;;			if err := CheckCpushares(m.Paths["cpu"], container.Cgroups.Resources.CpuShares); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Freeze toggles the container's freezer cgroup depending on the state
0000000000000000000000000000000000000000;;	// provided
0000000000000000000000000000000000000000;;	func (m *Manager) Freeze(state configs.FreezerState) error {
0000000000000000000000000000000000000000;;		paths := m.GetPaths()
0000000000000000000000000000000000000000;;		dir := paths["freezer"]
0000000000000000000000000000000000000000;;		prevState := m.Cgroups.Resources.Freezer
0000000000000000000000000000000000000000;;		m.Cgroups.Resources.Freezer = state
0000000000000000000000000000000000000000;;		freezer, err := subsystems.Get("freezer")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = freezer.Set(dir, m.Cgroups)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			m.Cgroups.Resources.Freezer = prevState
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetPids() ([]int, error) {
0000000000000000000000000000000000000000;;		paths := m.GetPaths()
0000000000000000000000000000000000000000;;		return cgroups.GetPids(paths["devices"])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetAllPids() ([]int, error) {
0000000000000000000000000000000000000000;;		paths := m.GetPaths()
0000000000000000000000000000000000000000;;		return cgroups.GetAllPids(paths["devices"])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCgroupData(c *configs.Cgroup, pid int) (*cgroupData, error) {
0000000000000000000000000000000000000000;;		root, err := getCgroupRoot()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (c.Name != "" || c.Parent != "") && c.Path != "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cgroup: either Path or Name and Parent should be used")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// XXX: Do not remove this code. Path safety is important! -- cyphar
0000000000000000000000000000000000000000;;		cgPath := libcontainerUtils.CleanPath(c.Path)
0000000000000000000000000000000000000000;;		cgParent := libcontainerUtils.CleanPath(c.Parent)
0000000000000000000000000000000000000000;;		cgName := libcontainerUtils.CleanPath(c.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		innerPath := cgPath
0000000000000000000000000000000000000000;;		if innerPath == "" {
0000000000000000000000000000000000000000;;			innerPath = filepath.Join(cgParent, cgName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &cgroupData{
0000000000000000000000000000000000000000;;			root:      root,
0000000000000000000000000000000000000000;;			innerPath: innerPath,
0000000000000000000000000000000000000000;;			config:    c,
0000000000000000000000000000000000000000;;			pid:       pid,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (raw *cgroupData) parentPath(subsystem, mountpoint, root string) (string, error) {
0000000000000000000000000000000000000000;;		// Use GetThisCgroupDir instead of GetInitCgroupDir, because the creating
0000000000000000000000000000000000000000;;		// process could in container and shared pid namespace with host, and
0000000000000000000000000000000000000000;;		// /proc/1/cgroup could point to whole other world of cgroups.
0000000000000000000000000000000000000000;;		initPath, err := cgroups.GetThisCgroupDir(subsystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This is needed for nested containers, because in /proc/self/cgroup we
0000000000000000000000000000000000000000;;		// see pathes from host, which don't exist in container.
0000000000000000000000000000000000000000;;		relDir, err := filepath.Rel(root, initPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(mountpoint, relDir), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (raw *cgroupData) path(subsystem string) (string, error) {
0000000000000000000000000000000000000000;;		mnt, root, err := cgroups.FindCgroupMountpointAndRoot(subsystem)
0000000000000000000000000000000000000000;;		// If we didn't mount the subsystem, there is no point we make the path.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the cgroup name/path is absolute do not look relative to the cgroup of the init process.
0000000000000000000000000000000000000000;;		if filepath.IsAbs(raw.innerPath) {
0000000000000000000000000000000000000000;;			// Sometimes subsystems can be mounted together as 'cpu,cpuacct'.
0000000000000000000000000000000000000000;;			return filepath.Join(raw.root, filepath.Base(mnt), raw.innerPath), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parentPath, err := raw.parentPath(subsystem, mnt, root)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filepath.Join(parentPath, raw.innerPath), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (raw *cgroupData) join(subsystem string) (string, error) {
0000000000000000000000000000000000000000;;		path, err := raw.path(subsystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(path, 0755); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cgroups.WriteCgroupProc(path, raw.pid); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeFile(dir, file, data string) error {
0000000000000000000000000000000000000000;;		// Normally dir should not be empty, one case is that cgroup subsystem
0000000000000000000000000000000000000000;;		// is not mounted, we will get empty dir, and we want it fail here.
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no such directory for %s", file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(filepath.Join(dir, file), []byte(data), 0700); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to write %v to %v: %v", data, file, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readFile(dir, file string) (string, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(filepath.Join(dir, file))
0000000000000000000000000000000000000000;;		return string(data), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removePath(p string, err error) error {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p != "" {
0000000000000000000000000000000000000000;;			return os.RemoveAll(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CheckCpushares(path string, c int64) error {
0000000000000000000000000000000000000000;;		var cpuShares int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fd, err := os.Open(filepath.Join(path, "cpu.shares"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer fd.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fscanf(fd, "%d", &cpuShares)
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c > cpuShares {
0000000000000000000000000000000000000000;;			return fmt.Errorf("The maximum allowed cpu-shares is %d", cpuShares)
0000000000000000000000000000000000000000;;		} else if c < cpuShares {
0000000000000000000000000000000000000000;;			return fmt.Errorf("The minimum allowed cpu-shares is %d", cpuShares)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
