0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/utils.go[Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/utils.go][vendor/github.com/opencontainers/runc/libcontainer/cgroups/utils.go];	
0000000000000000000000000000000000000000;;	package cgroups
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/go-units"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cgroupNamePrefix = "name="
0000000000000000000000000000000000000000;;		CgroupProcesses  = "cgroup.procs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt
0000000000000000000000000000000000000000;;	func FindCgroupMountpoint(subsystem string) (string, error) {
0000000000000000000000000000000000000000;;		// We are not using mount.GetMounts() because it's super-inefficient,
0000000000000000000000000000000000000000;;		// parsing it directly sped up x10 times because of not using Sscanf.
0000000000000000000000000000000000000000;;		// It was one of two major performance drawbacks in container start.
0000000000000000000000000000000000000000;;		if !isSubsystemAvailable(subsystem) {
0000000000000000000000000000000000000000;;			return "", NewNotFoundError(subsystem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/self/mountinfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			txt := scanner.Text()
0000000000000000000000000000000000000000;;			fields := strings.Split(txt, " ")
0000000000000000000000000000000000000000;;			for _, opt := range strings.Split(fields[len(fields)-1], ",") {
0000000000000000000000000000000000000000;;				if opt == subsystem {
0000000000000000000000000000000000000000;;					return fields[4], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", NewNotFoundError(subsystem)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FindCgroupMountpointAndRoot(subsystem string) (string, string, error) {
0000000000000000000000000000000000000000;;		if !isSubsystemAvailable(subsystem) {
0000000000000000000000000000000000000000;;			return "", "", NewNotFoundError(subsystem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/self/mountinfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			txt := scanner.Text()
0000000000000000000000000000000000000000;;			fields := strings.Split(txt, " ")
0000000000000000000000000000000000000000;;			for _, opt := range strings.Split(fields[len(fields)-1], ",") {
0000000000000000000000000000000000000000;;				if opt == subsystem {
0000000000000000000000000000000000000000;;					return fields[4], fields[3], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", "", NewNotFoundError(subsystem)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSubsystemAvailable(subsystem string) bool {
0000000000000000000000000000000000000000;;		cgroups, err := ParseCgroupFile("/proc/self/cgroup")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, avail := cgroups[subsystem]
0000000000000000000000000000000000000000;;		return avail
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FindCgroupMountpointDir() (string, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/self/mountinfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			text := scanner.Text()
0000000000000000000000000000000000000000;;			fields := strings.Split(text, " ")
0000000000000000000000000000000000000000;;			// Safe as mountinfo encodes mountpoints with spaces as \040.
0000000000000000000000000000000000000000;;			index := strings.Index(text, " - ")
0000000000000000000000000000000000000000;;			postSeparatorFields := strings.Fields(text[index+3:])
0000000000000000000000000000000000000000;;			numPostFields := len(postSeparatorFields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This is an error as we can't detect if the mount is for "cgroup"
0000000000000000000000000000000000000000;;			if numPostFields == 0 {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("Found no fields post '-' in %q", text)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if postSeparatorFields[0] == "cgroup" {
0000000000000000000000000000000000000000;;				// Check that the mount is properly formated.
0000000000000000000000000000000000000000;;				if numPostFields < 3 {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("Error found less than 3 fields post '-' in %q", text)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return filepath.Dir(fields[4]), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", NewNotFoundError("cgroup")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Mount struct {
0000000000000000000000000000000000000000;;		Mountpoint string
0000000000000000000000000000000000000000;;		Root       string
0000000000000000000000000000000000000000;;		Subsystems []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m Mount) GetThisCgroupDir(cgroups map[string]string) (string, error) {
0000000000000000000000000000000000000000;;		if len(m.Subsystems) == 0 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no subsystem for mount")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getControllerPath(m.Subsystems[0], cgroups)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCgroupMountsHelper(ss map[string]bool, mi io.Reader, all bool) ([]Mount, error) {
0000000000000000000000000000000000000000;;		res := make([]Mount, 0, len(ss))
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(mi)
0000000000000000000000000000000000000000;;		numFound := 0
0000000000000000000000000000000000000000;;		for scanner.Scan() && numFound < len(ss) {
0000000000000000000000000000000000000000;;			txt := scanner.Text()
0000000000000000000000000000000000000000;;			sepIdx := strings.Index(txt, " - ")
0000000000000000000000000000000000000000;;			if sepIdx == -1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid mountinfo format")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if txt[sepIdx+3:sepIdx+9] != "cgroup" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Split(txt, " ")
0000000000000000000000000000000000000000;;			m := Mount{
0000000000000000000000000000000000000000;;				Mountpoint: fields[4],
0000000000000000000000000000000000000000;;				Root:       fields[3],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, opt := range strings.Split(fields[len(fields)-1], ",") {
0000000000000000000000000000000000000000;;				if !ss[opt] {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if strings.HasPrefix(opt, cgroupNamePrefix) {
0000000000000000000000000000000000000000;;					m.Subsystems = append(m.Subsystems, opt[len(cgroupNamePrefix):])
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					m.Subsystems = append(m.Subsystems, opt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !all {
0000000000000000000000000000000000000000;;					numFound++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res = append(res, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCgroupMounts returns the mounts for the cgroup subsystems.
0000000000000000000000000000000000000000;;	// all indicates whether to return just the first instance or all the mounts.
0000000000000000000000000000000000000000;;	func GetCgroupMounts(all bool) ([]Mount, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/self/mountinfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allSubsystems, err := ParseCgroupFile("/proc/self/cgroup")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allMap := make(map[string]bool)
0000000000000000000000000000000000000000;;		for s := range allSubsystems {
0000000000000000000000000000000000000000;;			allMap[s] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return getCgroupMountsHelper(allMap, f, all)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAllSubsystems returns all the cgroup subsystems supported by the kernel
0000000000000000000000000000000000000000;;	func GetAllSubsystems() ([]string, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/cgroups")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subsystems := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			text := s.Text()
0000000000000000000000000000000000000000;;			if text[0] != '#' {
0000000000000000000000000000000000000000;;				parts := strings.Fields(text)
0000000000000000000000000000000000000000;;				if len(parts) >= 4 && parts[3] != "0" {
0000000000000000000000000000000000000000;;					subsystems = append(subsystems, parts[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return subsystems, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetThisCgroupDir returns the relative path to the cgroup docker is running in.
0000000000000000000000000000000000000000;;	func GetThisCgroupDir(subsystem string) (string, error) {
0000000000000000000000000000000000000000;;		cgroups, err := ParseCgroupFile("/proc/self/cgroup")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getControllerPath(subsystem, cgroups)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetInitCgroupDir(subsystem string) (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroups, err := ParseCgroupFile("/proc/1/cgroup")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getControllerPath(subsystem, cgroups)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readProcsFile(dir string) ([]int, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(filepath.Join(dir, CgroupProcesses))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			s   = bufio.NewScanner(f)
0000000000000000000000000000000000000000;;			out = []int{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if t := s.Text(); t != "" {
0000000000000000000000000000000000000000;;				pid, err := strconv.Atoi(t)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out = append(out, pid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCgroupFile parses the given cgroup file, typically from
0000000000000000000000000000000000000000;;	// /proc/<pid>/cgroup, into a map of subgroups to cgroup names.
0000000000000000000000000000000000000000;;	func ParseCgroupFile(path string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseCgroupFromReader(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper function for ParseCgroupFile to make testing easier
0000000000000000000000000000000000000000;;	func parseCgroupFromReader(r io.Reader) (map[string]string, error) {
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(r)
0000000000000000000000000000000000000000;;		cgroups := make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			text := s.Text()
0000000000000000000000000000000000000000;;			// from cgroups(7):
0000000000000000000000000000000000000000;;			// /proc/[pid]/cgroup
0000000000000000000000000000000000000000;;			// ...
0000000000000000000000000000000000000000;;			// For each cgroup hierarchy ... there is one entry
0000000000000000000000000000000000000000;;			// containing three colon-separated fields of the form:
0000000000000000000000000000000000000000;;			//     hierarchy-ID:subsystem-list:cgroup-path
0000000000000000000000000000000000000000;;			parts := strings.SplitN(text, ":", 3)
0000000000000000000000000000000000000000;;			if len(parts) < 3 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid cgroup entry: must contain at least two colons: %v", text)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, subs := range strings.Split(parts[1], ",") {
0000000000000000000000000000000000000000;;				cgroups[subs] = parts[2]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cgroups, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getControllerPath(subsystem string, cgroups map[string]string) (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p, ok := cgroups[subsystem]; ok {
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p, ok := cgroups[cgroupNamePrefix+subsystem]; ok {
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", NewNotFoundError(subsystem)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PathExists(path string) bool {
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EnterPid(cgroupPaths map[string]string, pid int) error {
0000000000000000000000000000000000000000;;		for _, path := range cgroupPaths {
0000000000000000000000000000000000000000;;			if PathExists(path) {
0000000000000000000000000000000000000000;;				if err := WriteCgroupProc(path, pid); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemovePaths iterates over the provided paths removing them.
0000000000000000000000000000000000000000;;	// We trying to remove all paths five times with increasing delay between tries.
0000000000000000000000000000000000000000;;	// If after all there are not removed cgroups - appropriate error will be
0000000000000000000000000000000000000000;;	// returned.
0000000000000000000000000000000000000000;;	func RemovePaths(paths map[string]string) (err error) {
0000000000000000000000000000000000000000;;		delay := 10 * time.Millisecond
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				time.Sleep(delay)
0000000000000000000000000000000000000000;;				delay *= 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for s, p := range paths {
0000000000000000000000000000000000000000;;				os.RemoveAll(p)
0000000000000000000000000000000000000000;;				// TODO: here probably should be logging
0000000000000000000000000000000000000000;;				_, err := os.Stat(p)
0000000000000000000000000000000000000000;;				// We need this strange way of checking cgroups existence because
0000000000000000000000000000000000000000;;				// RemoveAll almost always returns error, even on already removed
0000000000000000000000000000000000000000;;				// cgroups
0000000000000000000000000000000000000000;;				if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					delete(paths, s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(paths) == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("Failed to remove paths: %v", paths)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetHugePageSize() ([]string, error) {
0000000000000000000000000000000000000000;;		var pageSizes []string
0000000000000000000000000000000000000000;;		sizeList := []string{"B", "kB", "MB", "GB", "TB", "PB"}
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir("/sys/kernel/mm/hugepages")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return pageSizes, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, st := range files {
0000000000000000000000000000000000000000;;			nameArray := strings.Split(st.Name(), "-")
0000000000000000000000000000000000000000;;			pageSize, err := units.RAMInBytes(nameArray[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []string{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sizeString := units.CustomSize("%g%s", float64(pageSize), 1024.0, sizeList)
0000000000000000000000000000000000000000;;			pageSizes = append(pageSizes, sizeString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pageSizes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPids returns all pids, that were added to cgroup at path.
0000000000000000000000000000000000000000;;	func GetPids(path string) ([]int, error) {
0000000000000000000000000000000000000000;;		return readProcsFile(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAllPids returns all pids, that were added to cgroup at path and to all its
0000000000000000000000000000000000000000;;	// subcgroups.
0000000000000000000000000000000000000000;;	func GetAllPids(path string) ([]int, error) {
0000000000000000000000000000000000000000;;		var pids []int
0000000000000000000000000000000000000000;;		// collect pids from all sub-cgroups
0000000000000000000000000000000000000000;;		err := filepath.Walk(path, func(p string, info os.FileInfo, iErr error) error {
0000000000000000000000000000000000000000;;			dir, file := filepath.Split(p)
0000000000000000000000000000000000000000;;			if file != CgroupProcesses {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if iErr != nil {
0000000000000000000000000000000000000000;;				return iErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cPids, err := readProcsFile(dir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pids = append(pids, cPids...)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return pids, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteCgroupProc writes the specified pid into the cgroup's cgroup.procs file
0000000000000000000000000000000000000000;;	func WriteCgroupProc(dir string, pid int) error {
0000000000000000000000000000000000000000;;		// Normally dir should not be empty, one case is that cgroup subsystem
0000000000000000000000000000000000000000;;		// is not mounted, we will get empty dir, and we want it fail here.
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no such directory for %s", CgroupProcesses)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dont attach any pid to the cgroup if -1 is specified as a pid
0000000000000000000000000000000000000000;;		if pid != -1 {
0000000000000000000000000000000000000000;;			if err := ioutil.WriteFile(filepath.Join(dir, CgroupProcesses), []byte(strconv.Itoa(pid)), 0700); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to write %v to %v: %v", pid, CgroupProcesses, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
