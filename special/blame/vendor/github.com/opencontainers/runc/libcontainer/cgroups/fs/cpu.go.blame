0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/cpu.go[Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/cpu.go][vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs/cpu.go];	
0000000000000000000000000000000000000000;;	package fs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CpuGroup struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpuGroup) Name() string {
0000000000000000000000000000000000000000;;		return "cpu"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpuGroup) Apply(d *cgroupData) error {
0000000000000000000000000000000000000000;;		// We always want to join the cpu group, to allow fair cpu scheduling
0000000000000000000000000000000000000000;;		// on a container basis
0000000000000000000000000000000000000000;;		path, err := d.path("cpu")
0000000000000000000000000000000000000000;;		if err != nil && !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.ApplyDir(path, d.config, d.pid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpuGroup) ApplyDir(path string, cgroup *configs.Cgroup, pid int) error {
0000000000000000000000000000000000000000;;		// This might happen if we have no cpu cgroup mounted.
0000000000000000000000000000000000000000;;		// Just do nothing and don't fail.
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(path, 0755); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We should set the real-Time group scheduling settings before moving
0000000000000000000000000000000000000000;;		// in the process because if the process is already in SCHED_RR mode
0000000000000000000000000000000000000000;;		// and no RT bandwidth is set, adding it will fail.
0000000000000000000000000000000000000000;;		if err := s.SetRtSched(path, cgroup); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// because we are not using d.join we need to place the pid into the procs file
0000000000000000000000000000000000000000;;		// unlike the other subsystems
0000000000000000000000000000000000000000;;		if err := cgroups.WriteCgroupProc(path, pid); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpuGroup) SetRtSched(path string, cgroup *configs.Cgroup) error {
0000000000000000000000000000000000000000;;		if cgroup.Resources.CpuRtPeriod != 0 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "cpu.rt_period_us", strconv.FormatInt(cgroup.Resources.CpuRtPeriod, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cgroup.Resources.CpuRtRuntime != 0 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "cpu.rt_runtime_us", strconv.FormatInt(cgroup.Resources.CpuRtRuntime, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpuGroup) Set(path string, cgroup *configs.Cgroup) error {
0000000000000000000000000000000000000000;;		if cgroup.Resources.CpuShares != 0 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "cpu.shares", strconv.FormatInt(cgroup.Resources.CpuShares, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cgroup.Resources.CpuPeriod != 0 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "cpu.cfs_period_us", strconv.FormatInt(cgroup.Resources.CpuPeriod, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cgroup.Resources.CpuQuota != 0 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "cpu.cfs_quota_us", strconv.FormatInt(cgroup.Resources.CpuQuota, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.SetRtSched(path, cgroup); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpuGroup) Remove(d *cgroupData) error {
0000000000000000000000000000000000000000;;		return removePath(d.path("cpu"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *CpuGroup) GetStats(path string, stats *cgroups.Stats) error {
0000000000000000000000000000000000000000;;		f, err := os.Open(filepath.Join(path, "cpu.stat"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;		for sc.Scan() {
0000000000000000000000000000000000000000;;			t, v, err := getCgroupParamKeyValue(sc.Text())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case "nr_periods":
0000000000000000000000000000000000000000;;				stats.CpuStats.ThrottlingData.Periods = v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case "nr_throttled":
0000000000000000000000000000000000000000;;				stats.CpuStats.ThrottlingData.ThrottledPeriods = v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case "throttled_time":
0000000000000000000000000000000000000000;;				stats.CpuStats.ThrottlingData.ThrottledTime = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
