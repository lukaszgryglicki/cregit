0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/systemd/apply_systemd.go[Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/systemd/apply_systemd.go][vendor/github.com/opencontainers/runc/libcontainer/cgroups/systemd/apply_systemd.go];	
0000000000000000000000000000000000000000;;	package systemd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		systemdDbus "github.com/coreos/go-systemd/dbus"
0000000000000000000000000000000000000000;;		systemdUtil "github.com/coreos/go-systemd/util"
0000000000000000000000000000000000000000;;		"github.com/godbus/dbus"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups/fs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Manager struct {
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		Cgroups *configs.Cgroup
0000000000000000000000000000000000000000;;		Paths   map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subsystem interface {
0000000000000000000000000000000000000000;;		// Name returns the name of the subsystem.
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		// Returns the stats, as 'stats', corresponding to the cgroup under 'path'.
0000000000000000000000000000000000000000;;		GetStats(path string, stats *cgroups.Stats) error
0000000000000000000000000000000000000000;;		// Set the cgroup represented by cgroup.
0000000000000000000000000000000000000000;;		Set(path string, cgroup *configs.Cgroup) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errSubsystemDoesNotExist = errors.New("cgroup: subsystem does not exist")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type subsystemSet []subsystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s subsystemSet) Get(name string) (subsystem, error) {
0000000000000000000000000000000000000000;;		for _, ss := range s {
0000000000000000000000000000000000000000;;			if ss.Name() == name {
0000000000000000000000000000000000000000;;				return ss, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errSubsystemDoesNotExist
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var subsystems = subsystemSet{
0000000000000000000000000000000000000000;;		&fs.CpusetGroup{},
0000000000000000000000000000000000000000;;		&fs.DevicesGroup{},
0000000000000000000000000000000000000000;;		&fs.MemoryGroup{},
0000000000000000000000000000000000000000;;		&fs.CpuGroup{},
0000000000000000000000000000000000000000;;		&fs.CpuacctGroup{},
0000000000000000000000000000000000000000;;		&fs.PidsGroup{},
0000000000000000000000000000000000000000;;		&fs.BlkioGroup{},
0000000000000000000000000000000000000000;;		&fs.HugetlbGroup{},
0000000000000000000000000000000000000000;;		&fs.PerfEventGroup{},
0000000000000000000000000000000000000000;;		&fs.FreezerGroup{},
0000000000000000000000000000000000000000;;		&fs.NetPrioGroup{},
0000000000000000000000000000000000000000;;		&fs.NetClsGroup{},
0000000000000000000000000000000000000000;;		&fs.NameGroup{GroupName: "name=systemd"},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		testScopeWait = 4
0000000000000000000000000000000000000000;;		testSliceWait = 4
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		connLock                        sync.Mutex
0000000000000000000000000000000000000000;;		theConn                         *systemdDbus.Conn
0000000000000000000000000000000000000000;;		hasStartTransientUnit           bool
0000000000000000000000000000000000000000;;		hasStartTransientSliceUnit      bool
0000000000000000000000000000000000000000;;		hasTransientDefaultDependencies bool
0000000000000000000000000000000000000000;;		hasDelegate                     bool
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProp(name string, units interface{}) systemdDbus.Property {
0000000000000000000000000000000000000000;;		return systemdDbus.Property{
0000000000000000000000000000000000000000;;			Name:  name,
0000000000000000000000000000000000000000;;			Value: dbus.MakeVariant(units),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UseSystemd() bool {
0000000000000000000000000000000000000000;;		if !systemdUtil.IsRunningSystemd() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		connLock.Lock()
0000000000000000000000000000000000000000;;		defer connLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if theConn == nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			theConn, err = systemdDbus.New()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assume we have StartTransientUnit
0000000000000000000000000000000000000000;;			hasStartTransientUnit = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// But if we get UnknownMethod error we don't
0000000000000000000000000000000000000000;;			if _, err := theConn.StartTransientUnit("test.scope", "invalid", nil, nil); err != nil {
0000000000000000000000000000000000000000;;				if dbusError, ok := err.(dbus.Error); ok {
0000000000000000000000000000000000000000;;					if dbusError.Name == "org.freedesktop.DBus.Error.UnknownMethod" {
0000000000000000000000000000000000000000;;						hasStartTransientUnit = false
0000000000000000000000000000000000000000;;						return hasStartTransientUnit
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure the scope name we use doesn't exist. Use the Pid to
0000000000000000000000000000000000000000;;			// avoid collisions between multiple libcontainer users on a
0000000000000000000000000000000000000000;;			// single host.
0000000000000000000000000000000000000000;;			scope := fmt.Sprintf("libcontainer-%d-systemd-test-default-dependencies.scope", os.Getpid())
0000000000000000000000000000000000000000;;			testScopeExists := true
0000000000000000000000000000000000000000;;			for i := 0; i <= testScopeWait; i++ {
0000000000000000000000000000000000000000;;				if _, err := theConn.StopUnit(scope, "replace", nil); err != nil {
0000000000000000000000000000000000000000;;					if dbusError, ok := err.(dbus.Error); ok {
0000000000000000000000000000000000000000;;						if strings.Contains(dbusError.Name, "org.freedesktop.systemd1.NoSuchUnit") {
0000000000000000000000000000000000000000;;							testScopeExists = false
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Bail out if we can't kill this scope without testing for DefaultDependencies
0000000000000000000000000000000000000000;;			if testScopeExists {
0000000000000000000000000000000000000000;;				return hasStartTransientUnit
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assume StartTransientUnit on a scope allows DefaultDependencies
0000000000000000000000000000000000000000;;			hasTransientDefaultDependencies = true
0000000000000000000000000000000000000000;;			ddf := newProp("DefaultDependencies", false)
0000000000000000000000000000000000000000;;			if _, err := theConn.StartTransientUnit(scope, "replace", []systemdDbus.Property{ddf}, nil); err != nil {
0000000000000000000000000000000000000000;;				if dbusError, ok := err.(dbus.Error); ok {
0000000000000000000000000000000000000000;;					if strings.Contains(dbusError.Name, "org.freedesktop.DBus.Error.PropertyReadOnly") {
0000000000000000000000000000000000000000;;						hasTransientDefaultDependencies = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Not critical because of the stop unit logic above.
0000000000000000000000000000000000000000;;			theConn.StopUnit(scope, "replace", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assume StartTransientUnit on a scope allows Delegate
0000000000000000000000000000000000000000;;			hasDelegate = true
0000000000000000000000000000000000000000;;			dl := newProp("Delegate", true)
0000000000000000000000000000000000000000;;			if _, err := theConn.StartTransientUnit(scope, "replace", []systemdDbus.Property{dl}, nil); err != nil {
0000000000000000000000000000000000000000;;				if dbusError, ok := err.(dbus.Error); ok {
0000000000000000000000000000000000000000;;					if strings.Contains(dbusError.Name, "org.freedesktop.DBus.Error.PropertyReadOnly") {
0000000000000000000000000000000000000000;;						hasDelegate = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assume we have the ability to start a transient unit as a slice
0000000000000000000000000000000000000000;;			// This was broken until systemd v229, but has been back-ported on RHEL environments >= 219
0000000000000000000000000000000000000000;;			// For details, see: https://bugzilla.redhat.com/show_bug.cgi?id=1370299
0000000000000000000000000000000000000000;;			hasStartTransientSliceUnit = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// To ensure simple clean-up, we create a slice off the root with no hierarchy
0000000000000000000000000000000000000000;;			slice := fmt.Sprintf("libcontainer_%d_systemd_test_default.slice", os.Getpid())
0000000000000000000000000000000000000000;;			if _, err := theConn.StartTransientUnit(slice, "replace", nil, nil); err != nil {
0000000000000000000000000000000000000000;;				if _, ok := err.(dbus.Error); ok {
0000000000000000000000000000000000000000;;					hasStartTransientSliceUnit = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i <= testSliceWait; i++ {
0000000000000000000000000000000000000000;;				if _, err := theConn.StopUnit(slice, "replace", nil); err != nil {
0000000000000000000000000000000000000000;;					if dbusError, ok := err.(dbus.Error); ok {
0000000000000000000000000000000000000000;;						if strings.Contains(dbusError.Name, "org.freedesktop.systemd1.NoSuchUnit") {
0000000000000000000000000000000000000000;;							hasStartTransientSliceUnit = false
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(time.Millisecond)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Not critical because of the stop unit logic above.
0000000000000000000000000000000000000000;;			theConn.StopUnit(scope, "replace", nil)
0000000000000000000000000000000000000000;;			theConn.StopUnit(slice, "replace", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hasStartTransientUnit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) Apply(pid int) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			c          = m.Cgroups
0000000000000000000000000000000000000000;;			unitName   = getUnitName(c)
0000000000000000000000000000000000000000;;			slice      = "system.slice"
0000000000000000000000000000000000000000;;			properties []systemdDbus.Property
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Paths != nil {
0000000000000000000000000000000000000000;;			paths := make(map[string]string)
0000000000000000000000000000000000000000;;			for name, path := range c.Paths {
0000000000000000000000000000000000000000;;				_, err := getSubsystemPath(m.Cgroups, name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Don't fail if a cgroup hierarchy was not found, just skip this subsystem
0000000000000000000000000000000000000000;;					if cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				paths[name] = path
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.Paths = paths
0000000000000000000000000000000000000000;;			return cgroups.EnterPid(m.Paths, pid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Parent != "" {
0000000000000000000000000000000000000000;;			slice = c.Parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		properties = append(properties, systemdDbus.PropDescription("libcontainer container "+c.Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we create a slice, the parent is defined via a Wants=
0000000000000000000000000000000000000000;;		if strings.HasSuffix(unitName, ".slice") {
0000000000000000000000000000000000000000;;			// This was broken until systemd v229, but has been back-ported on RHEL environments >= 219
0000000000000000000000000000000000000000;;			if !hasStartTransientSliceUnit {
0000000000000000000000000000000000000000;;				return fmt.Errorf("systemd version does not support ability to start a slice as transient unit")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			properties = append(properties, systemdDbus.PropWants(slice))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// otherwise, we use Slice=
0000000000000000000000000000000000000000;;			properties = append(properties, systemdDbus.PropSlice(slice))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only add pid if its valid, -1 is used w/ general slice creation.
0000000000000000000000000000000000000000;;		if pid != -1 {
0000000000000000000000000000000000000000;;			properties = append(properties, newProp("PIDs", []uint32{uint32(pid)}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasDelegate {
0000000000000000000000000000000000000000;;			// This is only supported on systemd versions 218 and above.
0000000000000000000000000000000000000000;;			properties = append(properties, newProp("Delegate", true))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Always enable accounting, this gets us the same behaviour as the fs implementation,
0000000000000000000000000000000000000000;;		// plus the kernel has some problems with joining the memory cgroup at a later time.
0000000000000000000000000000000000000000;;		properties = append(properties,
0000000000000000000000000000000000000000;;			newProp("MemoryAccounting", true),
0000000000000000000000000000000000000000;;			newProp("CPUAccounting", true),
0000000000000000000000000000000000000000;;			newProp("BlockIOAccounting", true))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasTransientDefaultDependencies {
0000000000000000000000000000000000000000;;			properties = append(properties,
0000000000000000000000000000000000000000;;				newProp("DefaultDependencies", false))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Resources.Memory != 0 {
0000000000000000000000000000000000000000;;			properties = append(properties,
0000000000000000000000000000000000000000;;				newProp("MemoryLimit", uint64(c.Resources.Memory)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Resources.CpuShares != 0 {
0000000000000000000000000000000000000000;;			properties = append(properties,
0000000000000000000000000000000000000000;;				newProp("CPUShares", uint64(c.Resources.CpuShares)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Resources.BlkioWeight != 0 {
0000000000000000000000000000000000000000;;			properties = append(properties,
0000000000000000000000000000000000000000;;				newProp("BlockIOWeight", uint64(c.Resources.BlkioWeight)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have to set kernel memory here, as we can't change it once
0000000000000000000000000000000000000000;;		// processes have been attached to the cgroup.
0000000000000000000000000000000000000000;;		if c.Resources.KernelMemory != 0 {
0000000000000000000000000000000000000000;;			if err := setKernelMemory(c); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := theConn.StartTransientUnit(unitName, "replace", properties, nil); err != nil && !isUnitExists(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := joinCgroups(c, pid); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		paths := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, s := range subsystems {
0000000000000000000000000000000000000000;;			subsystemPath, err := getSubsystemPath(m.Cgroups, s.Name())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Don't fail if a cgroup hierarchy was not found, just skip this subsystem
0000000000000000000000000000000000000000;;				if cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			paths[s.Name()] = subsystemPath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.Paths = paths
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) Destroy() error {
0000000000000000000000000000000000000000;;		if m.Cgroups.Paths != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		defer m.mu.Unlock()
0000000000000000000000000000000000000000;;		theConn.StopUnit(getUnitName(m.Cgroups), "replace", nil)
0000000000000000000000000000000000000000;;		if err := cgroups.RemovePaths(m.Paths); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.Paths = make(map[string]string)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetPaths() map[string]string {
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		paths := m.Paths
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;		return paths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeFile(dir, file, data string) error {
0000000000000000000000000000000000000000;;		// Normally dir should not be empty, one case is that cgroup subsystem
0000000000000000000000000000000000000000;;		// is not mounted, we will get empty dir, and we want it fail here.
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no such directory for %s", file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(filepath.Join(dir, file), []byte(data), 0700)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func join(c *configs.Cgroup, subsystem string, pid int) (string, error) {
0000000000000000000000000000000000000000;;		path, err := getSubsystemPath(c, subsystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(path, 0755); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cgroups.WriteCgroupProc(path, pid); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func joinCgroups(c *configs.Cgroup, pid int) error {
0000000000000000000000000000000000000000;;		for _, sys := range subsystems {
0000000000000000000000000000000000000000;;			name := sys.Name()
0000000000000000000000000000000000000000;;			switch name {
0000000000000000000000000000000000000000;;			case "name=systemd":
0000000000000000000000000000000000000000;;				// let systemd handle this
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case "cpuset":
0000000000000000000000000000000000000000;;				path, err := getSubsystemPath(c, name)
0000000000000000000000000000000000000000;;				if err != nil && !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s := &fs.CpusetGroup{}
0000000000000000000000000000000000000000;;				if err := s.ApplyDir(path, c, pid); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				_, err := join(c, name, pid)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Even if it's `not found` error, we'll return err
0000000000000000000000000000000000000000;;					// because devices cgroup is hard requirement for
0000000000000000000000000000000000000000;;					// container security.
0000000000000000000000000000000000000000;;					if name == "devices" {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// For other subsystems, omit the `not found` error
0000000000000000000000000000000000000000;;					// because they are optional.
0000000000000000000000000000000000000000;;					if !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// systemd represents slice hierarchy using `-`, so we need to follow suit when
0000000000000000000000000000000000000000;;	// generating the path of slice. Essentially, test-a-b.slice becomes
0000000000000000000000000000000000000000;;	// test.slice/test-a.slice/test-a-b.slice.
0000000000000000000000000000000000000000;;	func ExpandSlice(slice string) (string, error) {
0000000000000000000000000000000000000000;;		suffix := ".slice"
0000000000000000000000000000000000000000;;		// Name has to end with ".slice", but can't be just ".slice".
0000000000000000000000000000000000000000;;		if len(slice) < len(suffix) || !strings.HasSuffix(slice, suffix) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid slice name: %s", slice)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path-separators are not allowed.
0000000000000000000000000000000000000000;;		if strings.Contains(slice, "/") {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid slice name: %s", slice)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var path, prefix string
0000000000000000000000000000000000000000;;		sliceName := strings.TrimSuffix(slice, suffix)
0000000000000000000000000000000000000000;;		// if input was -.slice, we should just return root now
0000000000000000000000000000000000000000;;		if sliceName == "-" {
0000000000000000000000000000000000000000;;			return "/", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, component := range strings.Split(sliceName, "-") {
0000000000000000000000000000000000000000;;			// test--a.slice isn't permitted, nor is -test.slice.
0000000000000000000000000000000000000000;;			if component == "" {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("invalid slice name: %s", slice)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Append the component to the path and to the prefix.
0000000000000000000000000000000000000000;;			path += prefix + component + suffix + "/"
0000000000000000000000000000000000000000;;			prefix += component + "-"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSubsystemPath(c *configs.Cgroup, subsystem string) (string, error) {
0000000000000000000000000000000000000000;;		mountpoint, err := cgroups.FindCgroupMountpoint(subsystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initPath, err := cgroups.GetInitCgroupDir(subsystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if pid 1 is systemd 226 or later, it will be in init.scope, not the root
0000000000000000000000000000000000000000;;		initPath = strings.TrimSuffix(filepath.Clean(initPath), "init.scope")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		slice := "system.slice"
0000000000000000000000000000000000000000;;		if c.Parent != "" {
0000000000000000000000000000000000000000;;			slice = c.Parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		slice, err = ExpandSlice(slice)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filepath.Join(mountpoint, initPath, slice, getUnitName(c)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) Freeze(state configs.FreezerState) error {
0000000000000000000000000000000000000000;;		path, err := getSubsystemPath(m.Cgroups, "freezer")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prevState := m.Cgroups.Resources.Freezer
0000000000000000000000000000000000000000;;		m.Cgroups.Resources.Freezer = state
0000000000000000000000000000000000000000;;		freezer, err := subsystems.Get("freezer")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = freezer.Set(path, m.Cgroups)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			m.Cgroups.Resources.Freezer = prevState
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetPids() ([]int, error) {
0000000000000000000000000000000000000000;;		path, err := getSubsystemPath(m.Cgroups, "devices")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cgroups.GetPids(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetAllPids() ([]int, error) {
0000000000000000000000000000000000000000;;		path, err := getSubsystemPath(m.Cgroups, "devices")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cgroups.GetAllPids(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) GetStats() (*cgroups.Stats, error) {
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		defer m.mu.Unlock()
0000000000000000000000000000000000000000;;		stats := cgroups.NewStats()
0000000000000000000000000000000000000000;;		for name, path := range m.Paths {
0000000000000000000000000000000000000000;;			sys, err := subsystems.Get(name)
0000000000000000000000000000000000000000;;			if err == errSubsystemDoesNotExist || !cgroups.PathExists(path) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := sys.GetStats(path, stats); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Manager) Set(container *configs.Config) error {
0000000000000000000000000000000000000000;;		// If Paths are set, then we are just joining cgroups paths
0000000000000000000000000000000000000000;;		// and there is no need to set any values.
0000000000000000000000000000000000000000;;		if m.Cgroups.Paths != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, sys := range subsystems {
0000000000000000000000000000000000000000;;			// Get the subsystem path, but don't error out for not found cgroups.
0000000000000000000000000000000000000000;;			path, err := getSubsystemPath(container.Cgroups, sys.Name())
0000000000000000000000000000000000000000;;			if err != nil && !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := sys.Set(path, container.Cgroups); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.Paths["cpu"] != "" {
0000000000000000000000000000000000000000;;			if err := fs.CheckCpushares(m.Paths["cpu"], container.Cgroups.Resources.CpuShares); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getUnitName(c *configs.Cgroup) string {
0000000000000000000000000000000000000000;;		// by default, we create a scope unless the user explicitly asks for a slice.
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(c.Name, ".slice") {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s-%s.scope", c.ScopePrefix, c.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setKernelMemory(c *configs.Cgroup) error {
0000000000000000000000000000000000000000;;		path, err := getSubsystemPath(c, "memory")
0000000000000000000000000000000000000000;;		if err != nil && !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(path, 0755); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fs.EnableKernelMemoryAccounting(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isUnitExists returns true if the error is that a systemd unit already exists.
0000000000000000000000000000000000000000;;	func isUnitExists(err error) bool {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if dbusError, ok := err.(dbus.Error); ok {
0000000000000000000000000000000000000000;;				return strings.Contains(dbusError.Name, "org.freedesktop.systemd1.UnitExists")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
