0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/memory.go[Godeps/_workspace/src/github.com/docker/libcontainer/cgroups/fs/memory.go][vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs/memory.go];	
0000000000000000000000000000000000000000;;	package fs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const cgroupKernelMemoryLimit = "memory.kmem.limit_in_bytes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MemoryGroup struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *MemoryGroup) Name() string {
0000000000000000000000000000000000000000;;		return "memory"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *MemoryGroup) Apply(d *cgroupData) (err error) {
0000000000000000000000000000000000000000;;		path, err := d.path("memory")
0000000000000000000000000000000000000000;;		if err != nil && !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if memoryAssigned(d.config) {
0000000000000000000000000000000000000000;;			if path != "" {
0000000000000000000000000000000000000000;;				if err := os.MkdirAll(path, 0755); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if d.config.KernelMemory != 0 {
0000000000000000000000000000000000000000;;				if err := EnableKernelMemoryAccounting(path); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				os.RemoveAll(path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need to join memory cgroup after set memory limits, because
0000000000000000000000000000000000000000;;		// kmem.limit_in_bytes can only be set when the cgroup is empty.
0000000000000000000000000000000000000000;;		_, err = d.join("memory")
0000000000000000000000000000000000000000;;		if err != nil && !cgroups.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EnableKernelMemoryAccounting(path string) error {
0000000000000000000000000000000000000000;;		// Check if kernel memory is enabled
0000000000000000000000000000000000000000;;		// We have to limit the kernel memory here as it won't be accounted at all
0000000000000000000000000000000000000000;;		// until a limit is set on the cgroup and limit cannot be set once the
0000000000000000000000000000000000000000;;		// cgroup has children, or if there are already tasks in the cgroup.
0000000000000000000000000000000000000000;;		for _, i := range []int64{1, -1} {
0000000000000000000000000000000000000000;;			if err := setKernelMemory(path, i); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setKernelMemory(path string, kernelMemoryLimit int64) error {
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no such directory for %s", cgroupKernelMemoryLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cgroups.PathExists(filepath.Join(path, cgroupKernelMemoryLimit)) {
0000000000000000000000000000000000000000;;			// kernel memory is not enabled on the system so we should do nothing
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(filepath.Join(path, cgroupKernelMemoryLimit), []byte(strconv.FormatInt(kernelMemoryLimit, 10)), 0700); err != nil {
0000000000000000000000000000000000000000;;			// Check if the error number returned by the syscall is "EBUSY"
0000000000000000000000000000000000000000;;			// The EBUSY signal is returned on attempts to write to the
0000000000000000000000000000000000000000;;			// memory.kmem.limit_in_bytes file if the cgroup has children or
0000000000000000000000000000000000000000;;			// once tasks have been attached to the cgroup
0000000000000000000000000000000000000000;;			if pathErr, ok := err.(*os.PathError); ok {
0000000000000000000000000000000000000000;;				if errNo, ok := pathErr.Err.(syscall.Errno); ok {
0000000000000000000000000000000000000000;;					if errNo == syscall.EBUSY {
0000000000000000000000000000000000000000;;						return fmt.Errorf("failed to set %s, because either tasks have already joined this cgroup or it has children", cgroupKernelMemoryLimit)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to write %v to %v: %v", kernelMemoryLimit, cgroupKernelMemoryLimit, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMemoryAndSwap(path string, cgroup *configs.Cgroup) error {
0000000000000000000000000000000000000000;;		// When memory and swap memory are both set, we need to handle the cases
0000000000000000000000000000000000000000;;		// for updating container.
0000000000000000000000000000000000000000;;		if cgroup.Resources.Memory != 0 && cgroup.Resources.MemorySwap > 0 {
0000000000000000000000000000000000000000;;			memoryUsage, err := getMemoryData(path, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// When update memory limit, we should adapt the write sequence
0000000000000000000000000000000000000000;;			// for memory and swap memory, so it won't fail because the new
0000000000000000000000000000000000000000;;			// value and the old value don't fit kernel's validation.
0000000000000000000000000000000000000000;;			if memoryUsage.Limit < uint64(cgroup.Resources.MemorySwap) {
0000000000000000000000000000000000000000;;				if err := writeFile(path, "memory.memsw.limit_in_bytes", strconv.FormatInt(cgroup.Resources.MemorySwap, 10)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := writeFile(path, "memory.limit_in_bytes", strconv.FormatInt(cgroup.Resources.Memory, 10)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := writeFile(path, "memory.limit_in_bytes", strconv.FormatInt(cgroup.Resources.Memory, 10)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := writeFile(path, "memory.memsw.limit_in_bytes", strconv.FormatInt(cgroup.Resources.MemorySwap, 10)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if cgroup.Resources.Memory != 0 {
0000000000000000000000000000000000000000;;				if err := writeFile(path, "memory.limit_in_bytes", strconv.FormatInt(cgroup.Resources.Memory, 10)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cgroup.Resources.MemorySwap > 0 {
0000000000000000000000000000000000000000;;				if err := writeFile(path, "memory.memsw.limit_in_bytes", strconv.FormatInt(cgroup.Resources.MemorySwap, 10)); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *MemoryGroup) Set(path string, cgroup *configs.Cgroup) error {
0000000000000000000000000000000000000000;;		if err := setMemoryAndSwap(path, cgroup); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cgroup.Resources.KernelMemory != 0 {
0000000000000000000000000000000000000000;;			if err := setKernelMemory(path, cgroup.Resources.KernelMemory); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cgroup.Resources.MemoryReservation != 0 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "memory.soft_limit_in_bytes", strconv.FormatInt(cgroup.Resources.MemoryReservation, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cgroup.Resources.KernelMemoryTCP != 0 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "memory.kmem.tcp.limit_in_bytes", strconv.FormatInt(cgroup.Resources.KernelMemoryTCP, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cgroup.Resources.OomKillDisable {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "memory.oom_control", "1"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cgroup.Resources.MemorySwappiness == nil || int64(*cgroup.Resources.MemorySwappiness) == -1 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if int64(*cgroup.Resources.MemorySwappiness) >= 0 && int64(*cgroup.Resources.MemorySwappiness) <= 100 {
0000000000000000000000000000000000000000;;			if err := writeFile(path, "memory.swappiness", strconv.FormatInt(*cgroup.Resources.MemorySwappiness, 10)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid value:%d. valid memory swappiness range is 0-100", int64(*cgroup.Resources.MemorySwappiness))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *MemoryGroup) Remove(d *cgroupData) error {
0000000000000000000000000000000000000000;;		return removePath(d.path("memory"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *MemoryGroup) GetStats(path string, stats *cgroups.Stats) error {
0000000000000000000000000000000000000000;;		// Set stats from memory.stat.
0000000000000000000000000000000000000000;;		statsFile, err := os.Open(filepath.Join(path, "memory.stat"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer statsFile.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc := bufio.NewScanner(statsFile)
0000000000000000000000000000000000000000;;		for sc.Scan() {
0000000000000000000000000000000000000000;;			t, v, err := getCgroupParamKeyValue(sc.Text())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to parse memory.stat (%q) - %v", sc.Text(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stats.MemoryStats.Stats[t] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.MemoryStats.Cache = stats.MemoryStats.Stats["cache"]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		memoryUsage, err := getMemoryData(path, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.MemoryStats.Usage = memoryUsage
0000000000000000000000000000000000000000;;		swapUsage, err := getMemoryData(path, "memsw")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.MemoryStats.SwapUsage = swapUsage
0000000000000000000000000000000000000000;;		kernelUsage, err := getMemoryData(path, "kmem")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.MemoryStats.KernelUsage = kernelUsage
0000000000000000000000000000000000000000;;		kernelTCPUsage, err := getMemoryData(path, "kmem.tcp")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.MemoryStats.KernelTCPUsage = kernelTCPUsage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func memoryAssigned(cgroup *configs.Cgroup) bool {
0000000000000000000000000000000000000000;;		return cgroup.Resources.Memory != 0 ||
0000000000000000000000000000000000000000;;			cgroup.Resources.MemoryReservation != 0 ||
0000000000000000000000000000000000000000;;			cgroup.Resources.MemorySwap > 0 ||
0000000000000000000000000000000000000000;;			cgroup.Resources.KernelMemory > 0 ||
0000000000000000000000000000000000000000;;			cgroup.Resources.KernelMemoryTCP > 0 ||
0000000000000000000000000000000000000000;;			cgroup.Resources.OomKillDisable ||
0000000000000000000000000000000000000000;;			(cgroup.Resources.MemorySwappiness != nil && *cgroup.Resources.MemorySwappiness != -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMemoryData(path, name string) (cgroups.MemoryData, error) {
0000000000000000000000000000000000000000;;		memoryData := cgroups.MemoryData{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		moduleName := "memory"
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			moduleName = strings.Join([]string{"memory", name}, ".")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usage := strings.Join([]string{moduleName, "usage_in_bytes"}, ".")
0000000000000000000000000000000000000000;;		maxUsage := strings.Join([]string{moduleName, "max_usage_in_bytes"}, ".")
0000000000000000000000000000000000000000;;		failcnt := strings.Join([]string{moduleName, "failcnt"}, ".")
0000000000000000000000000000000000000000;;		limit := strings.Join([]string{moduleName, "limit_in_bytes"}, ".")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		value, err := getCgroupParamUint(path, usage)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if moduleName != "memory" && os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return cgroups.MemoryData{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cgroups.MemoryData{}, fmt.Errorf("failed to parse %s - %v", usage, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		memoryData.Usage = value
0000000000000000000000000000000000000000;;		value, err = getCgroupParamUint(path, maxUsage)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if moduleName != "memory" && os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return cgroups.MemoryData{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cgroups.MemoryData{}, fmt.Errorf("failed to parse %s - %v", maxUsage, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		memoryData.MaxUsage = value
0000000000000000000000000000000000000000;;		value, err = getCgroupParamUint(path, failcnt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if moduleName != "memory" && os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return cgroups.MemoryData{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cgroups.MemoryData{}, fmt.Errorf("failed to parse %s - %v", failcnt, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		memoryData.Failcnt = value
0000000000000000000000000000000000000000;;		value, err = getCgroupParamUint(path, limit)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if moduleName != "memory" && os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return cgroups.MemoryData{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cgroups.MemoryData{}, fmt.Errorf("failed to parse %s - %v", limit, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		memoryData.Limit = value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return memoryData, nil
0000000000000000000000000000000000000000;;	}
