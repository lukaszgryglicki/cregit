0000000000000000000000000000000000000000;;	Libcontainer provides a native Go implementation for creating containers
0000000000000000000000000000000000000000;;	with namespaces, cgroups, capabilities, and filesystem access controls.
0000000000000000000000000000000000000000;;	It allows you to manage the lifecycle of the container performing additional operations
0000000000000000000000000000000000000000;;	after the container is created.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Container
0000000000000000000000000000000000000000;;	A container is a self contained execution environment that shares the kernel of the
0000000000000000000000000000000000000000;;	host system and which is (optionally) isolated from other containers in the system.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Using libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Because containers are spawned in a two step process you will need a binary that
0000000000000000000000000000000000000000;;	will be executed as the init process for the container. In libcontainer, we use
0000000000000000000000000000000000000000;;	the current binary (/proc/self/exe) to be executed as the init process, and use
0000000000000000000000000000000000000000;;	arg "init", we call the first step process "bootstrap", so you always need a "init"
0000000000000000000000000000000000000000;;	function as the entry of "bootstrap".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if len(os.Args) > 1 && os.Args[1] == "init" {
0000000000000000000000000000000000000000;;			runtime.GOMAXPROCS(1)
0000000000000000000000000000000000000000;;			runtime.LockOSThread()
0000000000000000000000000000000000000000;;			factory, _ := libcontainer.New("")
0000000000000000000000000000000000000000;;			if err := factory.StartInitialization(); err != nil {
0000000000000000000000000000000000000000;;				logrus.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			panic("--this line should have never been executed, congratulations--")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then to create a container you first have to initialize an instance of a factory
0000000000000000000000000000000000000000;;	that will handle the creation and initialization for a container.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	factory, err := libcontainer.New("/var/lib/container", libcontainer.Cgroupfs, libcontainer.InitArgs(os.Args[0], "init"))
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		logrus.Fatal(err)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Once you have an instance of the factory created we can create a configuration
0000000000000000000000000000000000000000;;	struct describing how the container is to be created. A sample would look similar to this:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	defaultMountFlags := syscall.MS_NOEXEC | syscall.MS_NOSUID | syscall.MS_NODEV
0000000000000000000000000000000000000000;;	config := &configs.Config{
0000000000000000000000000000000000000000;;		Rootfs: "/your/path/to/rootfs",
0000000000000000000000000000000000000000;;		Capabilities: []string{
0000000000000000000000000000000000000000;;			"CAP_CHOWN",
0000000000000000000000000000000000000000;;			"CAP_DAC_OVERRIDE",
0000000000000000000000000000000000000000;;			"CAP_FSETID",
0000000000000000000000000000000000000000;;			"CAP_FOWNER",
0000000000000000000000000000000000000000;;			"CAP_MKNOD",
0000000000000000000000000000000000000000;;			"CAP_NET_RAW",
0000000000000000000000000000000000000000;;			"CAP_SETGID",
0000000000000000000000000000000000000000;;			"CAP_SETUID",
0000000000000000000000000000000000000000;;			"CAP_SETFCAP",
0000000000000000000000000000000000000000;;			"CAP_SETPCAP",
0000000000000000000000000000000000000000;;			"CAP_NET_BIND_SERVICE",
0000000000000000000000000000000000000000;;			"CAP_SYS_CHROOT",
0000000000000000000000000000000000000000;;			"CAP_KILL",
0000000000000000000000000000000000000000;;			"CAP_AUDIT_WRITE",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		Namespaces: configs.Namespaces([]configs.Namespace{
0000000000000000000000000000000000000000;;			{Type: configs.NEWNS},
0000000000000000000000000000000000000000;;			{Type: configs.NEWUTS},
0000000000000000000000000000000000000000;;			{Type: configs.NEWIPC},
0000000000000000000000000000000000000000;;			{Type: configs.NEWPID},
0000000000000000000000000000000000000000;;			{Type: configs.NEWUSER},
0000000000000000000000000000000000000000;;			{Type: configs.NEWNET},
0000000000000000000000000000000000000000;;		}),
0000000000000000000000000000000000000000;;		Cgroups: &configs.Cgroup{
0000000000000000000000000000000000000000;;			Name:   "test-container",
0000000000000000000000000000000000000000;;			Parent: "system",
0000000000000000000000000000000000000000;;			Resources: &configs.Resources{
0000000000000000000000000000000000000000;;				MemorySwappiness: nil,
0000000000000000000000000000000000000000;;				AllowAllDevices:  nil,
0000000000000000000000000000000000000000;;				AllowedDevices:   configs.DefaultAllowedDevices,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		MaskPaths: []string{
0000000000000000000000000000000000000000;;			"/proc/kcore",
0000000000000000000000000000000000000000;;			"/sys/firmware",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		ReadonlyPaths: []string{
0000000000000000000000000000000000000000;;			"/proc/sys", "/proc/sysrq-trigger", "/proc/irq", "/proc/bus",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		Devices:  configs.DefaultAutoCreatedDevices,
0000000000000000000000000000000000000000;;		Hostname: "testing",
0000000000000000000000000000000000000000;;		Mounts: []*configs.Mount{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Source:      "proc",
0000000000000000000000000000000000000000;;				Destination: "/proc",
0000000000000000000000000000000000000000;;				Device:      "proc",
0000000000000000000000000000000000000000;;				Flags:       defaultMountFlags,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Source:      "tmpfs",
0000000000000000000000000000000000000000;;				Destination: "/dev",
0000000000000000000000000000000000000000;;				Device:      "tmpfs",
0000000000000000000000000000000000000000;;				Flags:       syscall.MS_NOSUID | syscall.MS_STRICTATIME,
0000000000000000000000000000000000000000;;				Data:        "mode=755",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Source:      "devpts",
0000000000000000000000000000000000000000;;				Destination: "/dev/pts",
0000000000000000000000000000000000000000;;				Device:      "devpts",
0000000000000000000000000000000000000000;;				Flags:       syscall.MS_NOSUID | syscall.MS_NOEXEC,
0000000000000000000000000000000000000000;;				Data:        "newinstance,ptmxmode=0666,mode=0620,gid=5",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Device:      "tmpfs",
0000000000000000000000000000000000000000;;				Source:      "shm",
0000000000000000000000000000000000000000;;				Destination: "/dev/shm",
0000000000000000000000000000000000000000;;				Data:        "mode=1777,size=65536k",
0000000000000000000000000000000000000000;;				Flags:       defaultMountFlags,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Source:      "mqueue",
0000000000000000000000000000000000000000;;				Destination: "/dev/mqueue",
0000000000000000000000000000000000000000;;				Device:      "mqueue",
0000000000000000000000000000000000000000;;				Flags:       defaultMountFlags,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Source:      "sysfs",
0000000000000000000000000000000000000000;;				Destination: "/sys",
0000000000000000000000000000000000000000;;				Device:      "sysfs",
0000000000000000000000000000000000000000;;				Flags:       defaultMountFlags | syscall.MS_RDONLY,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		UidMappings: []configs.IDMap{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ContainerID: 0,
0000000000000000000000000000000000000000;;				HostID: 1000,
0000000000000000000000000000000000000000;;				Size: 65536,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		GidMappings: []configs.IDMap{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				ContainerID: 0,
0000000000000000000000000000000000000000;;				HostID: 1000,
0000000000000000000000000000000000000000;;				Size: 65536,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		Networks: []*configs.Network{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    "loopback",
0000000000000000000000000000000000000000;;				Address: "127.0.0.1/0",
0000000000000000000000000000000000000000;;				Gateway: "localhost",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		Rlimits: []configs.Rlimit{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type: syscall.RLIMIT_NOFILE,
0000000000000000000000000000000000000000;;				Hard: uint64(1025),
0000000000000000000000000000000000000000;;				Soft: uint64(1025),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Once you have the configuration populated you can create a container:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	container, err := factory.Create("container-id", config)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		logrus.Fatal(err)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To spawn bash as the initial process inside the container and have the
0000000000000000000000000000000000000000;;	processes pid returned in order to wait, signal, or kill the process:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	process := &libcontainer.Process{
0000000000000000000000000000000000000000;;		Args:   []string{"/bin/bash"},
0000000000000000000000000000000000000000;;		Env:    []string{"PATH=/bin"},
0000000000000000000000000000000000000000;;		User:   "daemon",
0000000000000000000000000000000000000000;;		Stdin:  os.Stdin,
0000000000000000000000000000000000000000;;		Stdout: os.Stdout,
0000000000000000000000000000000000000000;;		Stderr: os.Stderr,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	err := container.Run(process)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		container.Destroy()
0000000000000000000000000000000000000000;;		logrus.Fatal(err)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wait for the process to finish.
0000000000000000000000000000000000000000;;	_, err := process.Wait()
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		logrus.Fatal(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// destroy the container.
0000000000000000000000000000000000000000;;	container.Destroy()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Additional ways to interact with a running container are:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// return all the pids for all processes running inside the container.
0000000000000000000000000000000000000000;;	processes, err := container.Processes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get detailed cpu, memory, io, and network statistics for the container and
0000000000000000000000000000000000000000;;	// it's processes.
0000000000000000000000000000000000000000;;	stats, err := container.Stats()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pause all processes inside the container.
0000000000000000000000000000000000000000;;	container.Pause()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resume all paused processes.
0000000000000000000000000000000000000000;;	container.Resume()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// send signal to container's init process.
0000000000000000000000000000000000000000;;	container.Signal(signal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// update container resource constraints.
0000000000000000000000000000000000000000;;	container.Set(config)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Checkpoint & Restore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	libcontainer now integrates [CRIU](http://criu.org/) for checkpointing and restoring containers.
0000000000000000000000000000000000000000;;	This let's you save the state of a process running inside a container to disk, and then restore
0000000000000000000000000000000000000000;;	that state into a new process, on the same machine or on another machine.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`criu` version 1.5.2 or higher is required to use checkpoint and restore.
0000000000000000000000000000000000000000;;	If you don't already  have `criu` installed, you can build it from source, following the
0000000000000000000000000000000000000000;;	[online instructions](http://criu.org/Installation). `criu` is also installed in the docker image
0000000000000000000000000000000000000000;;	generated when building libcontainer with docker.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Copyright and license
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Code and documentation copyright 2014 Docker, inc. Code released under the Apache 2.0 license.
0000000000000000000000000000000000000000;;	Docs released under Creative commons.
0000000000000000000000000000000000000000;;	
