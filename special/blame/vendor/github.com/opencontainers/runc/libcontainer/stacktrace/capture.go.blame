0000000000000000000000000000000000000000;;	package stacktrace
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/stacktrace/capture.go[Godeps/_workspace/src/github.com/docker/libcontainer/stacktrace/capture.go][vendor/github.com/opencontainers/runc/libcontainer/stacktrace/capture.go];	
0000000000000000000000000000000000000000;;	import "runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Capture captures a stacktrace for the current calling go program
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// skip is the number of frames to skip
0000000000000000000000000000000000000000;;	func Capture(userSkip int) Stacktrace {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			skip   = userSkip + 1 // add one for our own function
0000000000000000000000000000000000000000;;			frames []Frame
0000000000000000000000000000000000000000;;			prevPc uintptr
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for i := skip; ; i++ {
0000000000000000000000000000000000000000;;			pc, file, line, ok := runtime.Caller(i)
0000000000000000000000000000000000000000;;			//detect if caller is repeated to avoid loop, gccgo
0000000000000000000000000000000000000000;;			//currently runs  into a loop without this check
0000000000000000000000000000000000000000;;			if !ok || pc == prevPc {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			frames = append(frames, NewFrame(pc, file, line))
0000000000000000000000000000000000000000;;			prevPc = pc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Stacktrace{
0000000000000000000000000000000000000000;;			Frames: frames,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
