0000000000000000000000000000000000000000;;	// +build linux
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/container_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/container_linux.go][vendor/github.com/opencontainers/runc/libcontainer/container_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Sirupsen/logrus"
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/criurpc"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/system"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;		"github.com/syndtr/gocapability/capability"
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink/nl"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const stdioFdCount = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type linuxContainer struct {
0000000000000000000000000000000000000000;;		id                   string
0000000000000000000000000000000000000000;;		root                 string
0000000000000000000000000000000000000000;;		config               *configs.Config
0000000000000000000000000000000000000000;;		cgroupManager        cgroups.Manager
0000000000000000000000000000000000000000;;		initArgs             []string
0000000000000000000000000000000000000000;;		initProcess          parentProcess
0000000000000000000000000000000000000000;;		initProcessStartTime string
0000000000000000000000000000000000000000;;		criuPath             string
0000000000000000000000000000000000000000;;		m                    sync.Mutex
0000000000000000000000000000000000000000;;		criuVersion          int
0000000000000000000000000000000000000000;;		state                containerState
0000000000000000000000000000000000000000;;		created              time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// State represents a running container's state
0000000000000000000000000000000000000000;;	type State struct {
0000000000000000000000000000000000000000;;		BaseState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Platform specific fields below here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path to all the cgroups setup for a container. Key is cgroup subsystem name
0000000000000000000000000000000000000000;;		// with the value as the path.
0000000000000000000000000000000000000000;;		CgroupPaths map[string]string `json:"cgroup_paths"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NamespacePaths are filepaths to the container's namespaces. Key is the namespace type
0000000000000000000000000000000000000000;;		// with the value as the path.
0000000000000000000000000000000000000000;;		NamespacePaths map[configs.NamespaceType]string `json:"namespace_paths"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Container's standard descriptors (std{in,out,err}), needed for checkpoint and restore
0000000000000000000000000000000000000000;;		ExternalDescriptors []string `json:"external_descriptors,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container is a libcontainer container object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each container is thread-safe within the same process. Since a container can
0000000000000000000000000000000000000000;;	// be destroyed by a separate process, any function may return that the container
0000000000000000000000000000000000000000;;	// was not found.
0000000000000000000000000000000000000000;;	type Container interface {
0000000000000000000000000000000000000000;;		BaseContainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Methods below here are platform specific
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Checkpoint checkpoints the running container's state to disk using the criu(8) utility.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// errors:
0000000000000000000000000000000000000000;;		// Systemerror - System error.
0000000000000000000000000000000000000000;;		Checkpoint(criuOpts *CriuOpts) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Restore restores the checkpointed container to a running state using the criu(8) utility.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// errors:
0000000000000000000000000000000000000000;;		// Systemerror - System error.
0000000000000000000000000000000000000000;;		Restore(process *Process, criuOpts *CriuOpts) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the Container state is RUNNING or CREATED, sets the Container state to PAUSING and pauses
0000000000000000000000000000000000000000;;		// the execution of any user processes. Asynchronously, when the container finished being paused the
0000000000000000000000000000000000000000;;		// state is changed to PAUSED.
0000000000000000000000000000000000000000;;		// If the Container state is PAUSED, do nothing.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// errors:
0000000000000000000000000000000000000000;;		// ContainerNotExists - Container no longer exists,
0000000000000000000000000000000000000000;;		// ContainerNotRunning - Container not running or created,
0000000000000000000000000000000000000000;;		// Systemerror - System error.
0000000000000000000000000000000000000000;;		Pause() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the Container state is PAUSED, resumes the execution of any user processes in the
0000000000000000000000000000000000000000;;		// Container before setting the Container state to RUNNING.
0000000000000000000000000000000000000000;;		// If the Container state is RUNNING, do nothing.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// errors:
0000000000000000000000000000000000000000;;		// ContainerNotExists - Container no longer exists,
0000000000000000000000000000000000000000;;		// ContainerNotPaused - Container is not paused,
0000000000000000000000000000000000000000;;		// Systemerror - System error.
0000000000000000000000000000000000000000;;		Resume() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NotifyOOM returns a read-only channel signaling when the container receives an OOM notification.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// errors:
0000000000000000000000000000000000000000;;		// Systemerror - System error.
0000000000000000000000000000000000000000;;		NotifyOOM() (<-chan struct{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NotifyMemoryPressure returns a read-only channel signaling when the container reaches a given pressure level
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// errors:
0000000000000000000000000000000000000000;;		// Systemerror - System error.
0000000000000000000000000000000000000000;;		NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ID returns the container's unique ID
0000000000000000000000000000000000000000;;	func (c *linuxContainer) ID() string {
0000000000000000000000000000000000000000;;		return c.id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config returns the container's configuration
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Config() configs.Config {
0000000000000000000000000000000000000000;;		return *c.config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Status() (Status, error) {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		return c.currentStatus()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) State() (*State, error) {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		return c.currentState()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Processes() ([]int, error) {
0000000000000000000000000000000000000000;;		pids, err := c.cgroupManager.GetAllPids()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, newSystemErrorWithCause(err, "getting all container pids from cgroups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pids, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Stats() (*Stats, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err   error
0000000000000000000000000000000000000000;;			stats = &Stats{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if stats.CgroupStats, err = c.cgroupManager.GetStats(); err != nil {
0000000000000000000000000000000000000000;;			return stats, newSystemErrorWithCause(err, "getting container stats from cgroups")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, iface := range c.config.Networks {
0000000000000000000000000000000000000000;;			switch iface.Type {
0000000000000000000000000000000000000000;;			case "veth":
0000000000000000000000000000000000000000;;				istats, err := getNetworkInterfaceStats(iface.HostInterfaceName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return stats, newSystemErrorWithCausef(err, "getting network stats for interface %q", iface.HostInterfaceName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stats.Interfaces = append(stats.Interfaces, istats)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Set(config configs.Config) error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		status, err := c.currentStatus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status == Stopped {
0000000000000000000000000000000000000000;;			return newGenericError(fmt.Errorf("container not running"), ContainerNotRunning)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.config = &config
0000000000000000000000000000000000000000;;		return c.cgroupManager.Set(c.config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Start(process *Process) error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		status, err := c.currentStatus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.start(process, status == Stopped)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Run(process *Process) error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		status, err := c.currentStatus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.start(process, status == Stopped); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status == Stopped {
0000000000000000000000000000000000000000;;			return c.exec()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Exec() error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		return c.exec()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) exec() error {
0000000000000000000000000000000000000000;;		path := filepath.Join(c.root, execFifoFilename)
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(path, os.O_RDONLY, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "open exec fifo for reading")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(data) > 0 {
0000000000000000000000000000000000000000;;			os.Remove(path)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("cannot start an already running container")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) start(process *Process, isInit bool) error {
0000000000000000000000000000000000000000;;		parent, err := c.newParentProcess(process, isInit)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "creating new parent process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := parent.start(); err != nil {
0000000000000000000000000000000000000000;;			// terminate the process to ensure that it properly is reaped.
0000000000000000000000000000000000000000;;			if err := parent.terminate(); err != nil {
0000000000000000000000000000000000000000;;				logrus.Warn(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "starting container process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// generate a timestamp indicating when the container was started
0000000000000000000000000000000000000000;;		c.created = time.Now().UTC()
0000000000000000000000000000000000000000;;		c.state = &runningState{
0000000000000000000000000000000000000000;;			c: c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isInit {
0000000000000000000000000000000000000000;;			c.state = &createdState{
0000000000000000000000000000000000000000;;				c: c,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			state, err := c.updateState(parent)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.initProcessStartTime = state.InitProcessStartTime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.config.Hooks != nil {
0000000000000000000000000000000000000000;;				s := configs.HookState{
0000000000000000000000000000000000000000;;					Version:    c.config.Version,
0000000000000000000000000000000000000000;;					ID:         c.id,
0000000000000000000000000000000000000000;;					Pid:        parent.pid(),
0000000000000000000000000000000000000000;;					Root:       c.config.Rootfs,
0000000000000000000000000000000000000000;;					BundlePath: utils.SearchLabels(c.config.Labels, "bundle"),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i, hook := range c.config.Hooks.Poststart {
0000000000000000000000000000000000000000;;					if err := hook.Run(s); err != nil {
0000000000000000000000000000000000000000;;						if err := parent.terminate(); err != nil {
0000000000000000000000000000000000000000;;							logrus.Warn(err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return newSystemErrorWithCausef(err, "running poststart hook %d", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Signal(s os.Signal) error {
0000000000000000000000000000000000000000;;		if err := c.initProcess.signal(s); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "signaling init process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) newParentProcess(p *Process, doInit bool) (parentProcess, error) {
0000000000000000000000000000000000000000;;		parentPipe, childPipe, err := newPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, newSystemErrorWithCause(err, "creating new init pipe")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rootDir, err := os.Open(c.root)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd, err := c.commandTemplate(p, childPipe, rootDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, newSystemErrorWithCause(err, "creating new command template")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !doInit {
0000000000000000000000000000000000000000;;			return c.newSetnsProcess(p, cmd, parentPipe, childPipe, rootDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.newInitProcess(p, cmd, parentPipe, childPipe, rootDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) commandTemplate(p *Process, childPipe, rootDir *os.File) (*exec.Cmd, error) {
0000000000000000000000000000000000000000;;		cmd := exec.Command(c.initArgs[0], c.initArgs[1:]...)
0000000000000000000000000000000000000000;;		cmd.Stdin = p.Stdin
0000000000000000000000000000000000000000;;		cmd.Stdout = p.Stdout
0000000000000000000000000000000000000000;;		cmd.Stderr = p.Stderr
0000000000000000000000000000000000000000;;		cmd.Dir = c.config.Rootfs
0000000000000000000000000000000000000000;;		if cmd.SysProcAttr == nil {
0000000000000000000000000000000000000000;;			cmd.SysProcAttr = &syscall.SysProcAttr{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.ExtraFiles = append(p.ExtraFiles, childPipe, rootDir)
0000000000000000000000000000000000000000;;		cmd.Env = append(cmd.Env,
0000000000000000000000000000000000000000;;			fmt.Sprintf("_LIBCONTAINER_INITPIPE=%d", stdioFdCount+len(cmd.ExtraFiles)-2),
0000000000000000000000000000000000000000;;			fmt.Sprintf("_LIBCONTAINER_STATEDIR=%d", stdioFdCount+len(cmd.ExtraFiles)-1))
0000000000000000000000000000000000000000;;		// NOTE: when running a container with no PID namespace and the parent process spawning the container is
0000000000000000000000000000000000000000;;		// PID1 the pdeathsig is being delivered to the container's init process by the kernel for some reason
0000000000000000000000000000000000000000;;		// even with the parent still running.
0000000000000000000000000000000000000000;;		if c.config.ParentDeathSignal > 0 {
0000000000000000000000000000000000000000;;			cmd.SysProcAttr.Pdeathsig = syscall.Signal(c.config.ParentDeathSignal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmd, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, parentPipe, childPipe, rootDir *os.File) (*initProcess, error) {
0000000000000000000000000000000000000000;;		cmd.Env = append(cmd.Env, "_LIBCONTAINER_INITTYPE="+string(initStandard))
0000000000000000000000000000000000000000;;		nsMaps := make(map[configs.NamespaceType]string)
0000000000000000000000000000000000000000;;		for _, ns := range c.config.Namespaces {
0000000000000000000000000000000000000000;;			if ns.Path != "" {
0000000000000000000000000000000000000000;;				nsMaps[ns.Type] = ns.Path
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, sharePidns := nsMaps[configs.NEWPID]
0000000000000000000000000000000000000000;;		data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &initProcess{
0000000000000000000000000000000000000000;;			cmd:           cmd,
0000000000000000000000000000000000000000;;			childPipe:     childPipe,
0000000000000000000000000000000000000000;;			parentPipe:    parentPipe,
0000000000000000000000000000000000000000;;			manager:       c.cgroupManager,
0000000000000000000000000000000000000000;;			config:        c.newInitConfig(p),
0000000000000000000000000000000000000000;;			container:     c,
0000000000000000000000000000000000000000;;			process:       p,
0000000000000000000000000000000000000000;;			bootstrapData: data,
0000000000000000000000000000000000000000;;			sharePidns:    sharePidns,
0000000000000000000000000000000000000000;;			rootDir:       rootDir,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, parentPipe, childPipe, rootDir *os.File) (*setnsProcess, error) {
0000000000000000000000000000000000000000;;		cmd.Env = append(cmd.Env, "_LIBCONTAINER_INITTYPE="+string(initSetns))
0000000000000000000000000000000000000000;;		state, err := c.currentState()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, newSystemErrorWithCause(err, "getting container's current state")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// for setns process, we dont have to set cloneflags as the process namespaces
0000000000000000000000000000000000000000;;		// will only be set via setns syscall
0000000000000000000000000000000000000000;;		data, err := c.bootstrapData(0, state.NamespacePaths, p.consolePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: set on container for process management
0000000000000000000000000000000000000000;;		return &setnsProcess{
0000000000000000000000000000000000000000;;			cmd:           cmd,
0000000000000000000000000000000000000000;;			cgroupPaths:   c.cgroupManager.GetPaths(),
0000000000000000000000000000000000000000;;			childPipe:     childPipe,
0000000000000000000000000000000000000000;;			parentPipe:    parentPipe,
0000000000000000000000000000000000000000;;			config:        c.newInitConfig(p),
0000000000000000000000000000000000000000;;			process:       p,
0000000000000000000000000000000000000000;;			bootstrapData: data,
0000000000000000000000000000000000000000;;			rootDir:       rootDir,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) newInitConfig(process *Process) *initConfig {
0000000000000000000000000000000000000000;;		cfg := &initConfig{
0000000000000000000000000000000000000000;;			Config:           c.config,
0000000000000000000000000000000000000000;;			Args:             process.Args,
0000000000000000000000000000000000000000;;			Env:              process.Env,
0000000000000000000000000000000000000000;;			User:             process.User,
0000000000000000000000000000000000000000;;			AdditionalGroups: process.AdditionalGroups,
0000000000000000000000000000000000000000;;			Cwd:              process.Cwd,
0000000000000000000000000000000000000000;;			Console:          process.consolePath,
0000000000000000000000000000000000000000;;			Capabilities:     process.Capabilities,
0000000000000000000000000000000000000000;;			PassedFilesCount: len(process.ExtraFiles),
0000000000000000000000000000000000000000;;			ContainerId:      c.ID(),
0000000000000000000000000000000000000000;;			NoNewPrivileges:  c.config.NoNewPrivileges,
0000000000000000000000000000000000000000;;			AppArmorProfile:  c.config.AppArmorProfile,
0000000000000000000000000000000000000000;;			ProcessLabel:     c.config.ProcessLabel,
0000000000000000000000000000000000000000;;			Rlimits:          c.config.Rlimits,
0000000000000000000000000000000000000000;;			ExecFifoPath:     filepath.Join(c.root, execFifoFilename),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if process.NoNewPrivileges != nil {
0000000000000000000000000000000000000000;;			cfg.NoNewPrivileges = *process.NoNewPrivileges
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if process.AppArmorProfile != "" {
0000000000000000000000000000000000000000;;			cfg.AppArmorProfile = process.AppArmorProfile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if process.Label != "" {
0000000000000000000000000000000000000000;;			cfg.ProcessLabel = process.Label
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(process.Rlimits) > 0 {
0000000000000000000000000000000000000000;;			cfg.Rlimits = process.Rlimits
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPipe() (parent *os.File, child *os.File, err error) {
0000000000000000000000000000000000000000;;		fds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_STREAM|syscall.SOCK_CLOEXEC, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.NewFile(uintptr(fds[1]), "parent"), os.NewFile(uintptr(fds[0]), "child"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Destroy() error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		return c.state.destroy()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Pause() error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		status, err := c.currentStatus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch status {
0000000000000000000000000000000000000000;;		case Running, Created:
0000000000000000000000000000000000000000;;			if err := c.cgroupManager.Freeze(configs.Frozen); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c.state.transition(&pausedState{
0000000000000000000000000000000000000000;;				c: c,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newGenericError(fmt.Errorf("container not running or created: %s", status), ContainerNotRunning)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Resume() error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		status, err := c.currentStatus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if status != Paused {
0000000000000000000000000000000000000000;;			return newGenericError(fmt.Errorf("container not paused"), ContainerNotPaused)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.cgroupManager.Freeze(configs.Thawed); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.state.transition(&runningState{
0000000000000000000000000000000000000000;;			c: c,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) NotifyOOM() (<-chan struct{}, error) {
0000000000000000000000000000000000000000;;		return notifyOnOOM(c.cgroupManager.GetPaths())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error) {
0000000000000000000000000000000000000000;;		return notifyMemoryPressure(c.cgroupManager.GetPaths(), level)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkCriuVersion checks Criu version greater than or equal to minVersion
0000000000000000000000000000000000000000;;	func (c *linuxContainer) checkCriuVersion(minVersion string) error {
0000000000000000000000000000000000000000;;		var x, y, z, versionReq int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := fmt.Sscanf(minVersion, "%d.%d.%d\n", &x, &y, &z) // 1.5.2
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			_, err = fmt.Sscanf(minVersion, "Version: %d.%d\n", &x, &y) // 1.6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versionReq = x*10000 + y*100 + z
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := exec.Command(c.criuPath, "-V").Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unable to execute CRIU command: %s", c.criuPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x = 0
0000000000000000000000000000000000000000;;		y = 0
0000000000000000000000000000000000000000;;		z = 0
0000000000000000000000000000000000000000;;		if ep := strings.Index(string(out), "-"); ep >= 0 {
0000000000000000000000000000000000000000;;			// criu Git version format
0000000000000000000000000000000000000000;;			var version string
0000000000000000000000000000000000000000;;			if sp := strings.Index(string(out), "GitID"); sp > 0 {
0000000000000000000000000000000000000000;;				version = string(out)[sp:ep]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to parse the CRIU version: %s", c.criuPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n, err := fmt.Sscanf(string(version), "GitID: v%d.%d.%d", &x, &y, &z) // 1.5.2
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				n, err = fmt.Sscanf(string(version), "GitID: v%d.%d", &x, &y) // 1.6
0000000000000000000000000000000000000000;;				y++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				z++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n < 2 || err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to parse the CRIU version: %s %d %s", version, n, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// criu release version format
0000000000000000000000000000000000000000;;			n, err := fmt.Sscanf(string(out), "Version: %d.%d.%d\n", &x, &y, &z) // 1.5.2
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				n, err = fmt.Sscanf(string(out), "Version: %d.%d\n", &x, &y) // 1.6
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n < 2 || err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to parse the CRIU version: %s %d %s", out, n, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.criuVersion = x*10000 + y*100 + z
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.criuVersion < versionReq {
0000000000000000000000000000000000000000;;			return fmt.Errorf("CRIU version must be %s or higher", minVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const descriptorsFilename = "descriptors.json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) addCriuDumpMount(req *criurpc.CriuReq, m *configs.Mount) {
0000000000000000000000000000000000000000;;		mountDest := m.Destination
0000000000000000000000000000000000000000;;		if strings.HasPrefix(mountDest, c.config.Rootfs) {
0000000000000000000000000000000000000000;;			mountDest = mountDest[len(c.config.Rootfs):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extMnt := &criurpc.ExtMountMap{
0000000000000000000000000000000000000000;;			Key: proto.String(mountDest),
0000000000000000000000000000000000000000;;			Val: proto.String(mountDest),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Checkpoint(criuOpts *CriuOpts) error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.checkCriuVersion("1.5.2"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if criuOpts.ImagesDirectory == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid directory to save checkpoint")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since a container can be C/R'ed multiple times,
0000000000000000000000000000000000000000;;		// the checkpoint directory may already exist.
0000000000000000000000000000000000000000;;		if err := os.Mkdir(criuOpts.ImagesDirectory, 0755); err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if criuOpts.WorkDirectory == "" {
0000000000000000000000000000000000000000;;			criuOpts.WorkDirectory = filepath.Join(c.root, "criu.work")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := os.Mkdir(criuOpts.WorkDirectory, 0755); err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		workDir, err := os.Open(criuOpts.WorkDirectory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer workDir.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		imageDir, err := os.Open(criuOpts.ImagesDirectory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer imageDir.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rpcOpts := criurpc.CriuOpts{
0000000000000000000000000000000000000000;;			ImagesDirFd:    proto.Int32(int32(imageDir.Fd())),
0000000000000000000000000000000000000000;;			WorkDirFd:      proto.Int32(int32(workDir.Fd())),
0000000000000000000000000000000000000000;;			LogLevel:       proto.Int32(4),
0000000000000000000000000000000000000000;;			LogFile:        proto.String("dump.log"),
0000000000000000000000000000000000000000;;			Root:           proto.String(c.config.Rootfs),
0000000000000000000000000000000000000000;;			ManageCgroups:  proto.Bool(true),
0000000000000000000000000000000000000000;;			NotifyScripts:  proto.Bool(true),
0000000000000000000000000000000000000000;;			Pid:            proto.Int32(int32(c.initProcess.pid())),
0000000000000000000000000000000000000000;;			ShellJob:       proto.Bool(criuOpts.ShellJob),
0000000000000000000000000000000000000000;;			LeaveRunning:   proto.Bool(criuOpts.LeaveRunning),
0000000000000000000000000000000000000000;;			TcpEstablished: proto.Bool(criuOpts.TcpEstablished),
0000000000000000000000000000000000000000;;			ExtUnixSk:      proto.Bool(criuOpts.ExternalUnixConnections),
0000000000000000000000000000000000000000;;			FileLocks:      proto.Bool(criuOpts.FileLocks),
0000000000000000000000000000000000000000;;			EmptyNs:        proto.Uint32(criuOpts.EmptyNs),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// append optional criu opts, e.g., page-server and port
0000000000000000000000000000000000000000;;		if criuOpts.PageServer.Address != "" && criuOpts.PageServer.Port != 0 {
0000000000000000000000000000000000000000;;			rpcOpts.Ps = &criurpc.CriuPageServerInfo{
0000000000000000000000000000000000000000;;				Address: proto.String(criuOpts.PageServer.Address),
0000000000000000000000000000000000000000;;				Port:    proto.Int32(criuOpts.PageServer.Port),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// append optional manage cgroups mode
0000000000000000000000000000000000000000;;		if criuOpts.ManageCgroupsMode != 0 {
0000000000000000000000000000000000000000;;			if err := c.checkCriuVersion("1.7"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mode := criurpc.CriuCgMode(criuOpts.ManageCgroupsMode)
0000000000000000000000000000000000000000;;			rpcOpts.ManageCgroupsMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := criurpc.CriuReqType_DUMP
0000000000000000000000000000000000000000;;		req := &criurpc.CriuReq{
0000000000000000000000000000000000000000;;			Type: &t,
0000000000000000000000000000000000000000;;			Opts: &rpcOpts,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range c.config.Mounts {
0000000000000000000000000000000000000000;;			switch m.Device {
0000000000000000000000000000000000000000;;			case "bind":
0000000000000000000000000000000000000000;;				c.addCriuDumpMount(req, m)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case "cgroup":
0000000000000000000000000000000000000000;;				binds, err := getCgroupMounts(m)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, b := range binds {
0000000000000000000000000000000000000000;;					c.addCriuDumpMount(req, b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the FD info to a file in the image directory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fdsJSON, err := json.Marshal(c.initProcess.externalDescriptors())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ioutil.WriteFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename), fdsJSON, 0655)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.criuSwrk(nil, req, criuOpts, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) addCriuRestoreMount(req *criurpc.CriuReq, m *configs.Mount) {
0000000000000000000000000000000000000000;;		mountDest := m.Destination
0000000000000000000000000000000000000000;;		if strings.HasPrefix(mountDest, c.config.Rootfs) {
0000000000000000000000000000000000000000;;			mountDest = mountDest[len(c.config.Rootfs):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extMnt := &criurpc.ExtMountMap{
0000000000000000000000000000000000000000;;			Key: proto.String(mountDest),
0000000000000000000000000000000000000000;;			Val: proto.String(m.Source),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) restoreNetwork(req *criurpc.CriuReq, criuOpts *CriuOpts) {
0000000000000000000000000000000000000000;;		for _, iface := range c.config.Networks {
0000000000000000000000000000000000000000;;			switch iface.Type {
0000000000000000000000000000000000000000;;			case "veth":
0000000000000000000000000000000000000000;;				veth := new(criurpc.CriuVethPair)
0000000000000000000000000000000000000000;;				veth.IfOut = proto.String(iface.HostInterfaceName)
0000000000000000000000000000000000000000;;				veth.IfIn = proto.String(iface.Name)
0000000000000000000000000000000000000000;;				req.Opts.Veths = append(req.Opts.Veths, veth)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case "loopback":
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, i := range criuOpts.VethPairs {
0000000000000000000000000000000000000000;;			veth := new(criurpc.CriuVethPair)
0000000000000000000000000000000000000000;;			veth.IfOut = proto.String(i.HostInterfaceName)
0000000000000000000000000000000000000000;;			veth.IfIn = proto.String(i.ContainerInterfaceName)
0000000000000000000000000000000000000000;;			req.Opts.Veths = append(req.Opts.Veths, veth)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) Restore(process *Process, criuOpts *CriuOpts) error {
0000000000000000000000000000000000000000;;		c.m.Lock()
0000000000000000000000000000000000000000;;		defer c.m.Unlock()
0000000000000000000000000000000000000000;;		if err := c.checkCriuVersion("1.5.2"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if criuOpts.WorkDirectory == "" {
0000000000000000000000000000000000000000;;			criuOpts.WorkDirectory = filepath.Join(c.root, "criu.work")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Since a container can be C/R'ed multiple times,
0000000000000000000000000000000000000000;;		// the work directory may already exist.
0000000000000000000000000000000000000000;;		if err := os.Mkdir(criuOpts.WorkDirectory, 0655); err != nil && !os.IsExist(err) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		workDir, err := os.Open(criuOpts.WorkDirectory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer workDir.Close()
0000000000000000000000000000000000000000;;		if criuOpts.ImagesDirectory == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid directory to restore checkpoint")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageDir, err := os.Open(criuOpts.ImagesDirectory)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer imageDir.Close()
0000000000000000000000000000000000000000;;		// CRIU has a few requirements for a root directory:
0000000000000000000000000000000000000000;;		// * it must be a mount point
0000000000000000000000000000000000000000;;		// * its parent must not be overmounted
0000000000000000000000000000000000000000;;		// c.config.Rootfs is bind-mounted to a temporary directory
0000000000000000000000000000000000000000;;		// to satisfy these requirements.
0000000000000000000000000000000000000000;;		root := filepath.Join(c.root, "criu-root")
0000000000000000000000000000000000000000;;		if err := os.Mkdir(root, 0755); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer os.Remove(root)
0000000000000000000000000000000000000000;;		root, err = filepath.EvalSymlinks(root)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = syscall.Mount(c.config.Rootfs, root, "", syscall.MS_BIND|syscall.MS_REC, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer syscall.Unmount(root, syscall.MNT_DETACH)
0000000000000000000000000000000000000000;;		t := criurpc.CriuReqType_RESTORE
0000000000000000000000000000000000000000;;		req := &criurpc.CriuReq{
0000000000000000000000000000000000000000;;			Type: &t,
0000000000000000000000000000000000000000;;			Opts: &criurpc.CriuOpts{
0000000000000000000000000000000000000000;;				ImagesDirFd:    proto.Int32(int32(imageDir.Fd())),
0000000000000000000000000000000000000000;;				WorkDirFd:      proto.Int32(int32(workDir.Fd())),
0000000000000000000000000000000000000000;;				EvasiveDevices: proto.Bool(true),
0000000000000000000000000000000000000000;;				LogLevel:       proto.Int32(4),
0000000000000000000000000000000000000000;;				LogFile:        proto.String("restore.log"),
0000000000000000000000000000000000000000;;				RstSibling:     proto.Bool(true),
0000000000000000000000000000000000000000;;				Root:           proto.String(root),
0000000000000000000000000000000000000000;;				ManageCgroups:  proto.Bool(true),
0000000000000000000000000000000000000000;;				NotifyScripts:  proto.Bool(true),
0000000000000000000000000000000000000000;;				ShellJob:       proto.Bool(criuOpts.ShellJob),
0000000000000000000000000000000000000000;;				ExtUnixSk:      proto.Bool(criuOpts.ExternalUnixConnections),
0000000000000000000000000000000000000000;;				TcpEstablished: proto.Bool(criuOpts.TcpEstablished),
0000000000000000000000000000000000000000;;				FileLocks:      proto.Bool(criuOpts.FileLocks),
0000000000000000000000000000000000000000;;				EmptyNs:        proto.Uint32(criuOpts.EmptyNs),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range c.config.Mounts {
0000000000000000000000000000000000000000;;			switch m.Device {
0000000000000000000000000000000000000000;;			case "bind":
0000000000000000000000000000000000000000;;				c.addCriuRestoreMount(req, m)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case "cgroup":
0000000000000000000000000000000000000000;;				binds, err := getCgroupMounts(m)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, b := range binds {
0000000000000000000000000000000000000000;;					c.addCriuRestoreMount(req, b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if criuOpts.EmptyNs&syscall.CLONE_NEWNET == 0 {
0000000000000000000000000000000000000000;;			c.restoreNetwork(req, criuOpts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// append optional manage cgroups mode
0000000000000000000000000000000000000000;;		if criuOpts.ManageCgroupsMode != 0 {
0000000000000000000000000000000000000000;;			if err := c.checkCriuVersion("1.7"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mode := criurpc.CriuCgMode(criuOpts.ManageCgroupsMode)
0000000000000000000000000000000000000000;;			req.Opts.ManageCgroupsMode = &mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			fds    []string
0000000000000000000000000000000000000000;;			fdJSON []byte
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if fdJSON, err = ioutil.ReadFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(fdJSON, &fds); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range fds {
0000000000000000000000000000000000000000;;			if s := fds[i]; strings.Contains(s, "pipe:") {
0000000000000000000000000000000000000000;;				inheritFd := new(criurpc.InheritFd)
0000000000000000000000000000000000000000;;				inheritFd.Key = proto.String(s)
0000000000000000000000000000000000000000;;				inheritFd.Fd = proto.Int32(int32(i))
0000000000000000000000000000000000000000;;				req.Opts.InheritFd = append(req.Opts.InheritFd, inheritFd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.criuSwrk(process, req, criuOpts, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) criuApplyCgroups(pid int, req *criurpc.CriuReq) error {
0000000000000000000000000000000000000000;;		if err := c.cgroupManager.Apply(pid); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := fmt.Sprintf("/proc/%d/cgroup", pid)
0000000000000000000000000000000000000000;;		cgroupsPaths, err := cgroups.ParseCgroupFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for c, p := range cgroupsPaths {
0000000000000000000000000000000000000000;;			cgroupRoot := &criurpc.CgroupRoot{
0000000000000000000000000000000000000000;;				Ctrl: proto.String(c),
0000000000000000000000000000000000000000;;				Path: proto.String(p),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Opts.CgRoot = append(req.Opts.CgRoot, cgroupRoot)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) criuSwrk(process *Process, req *criurpc.CriuReq, opts *CriuOpts, applyCgroups bool) error {
0000000000000000000000000000000000000000;;		fds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_SEQPACKET|syscall.SOCK_CLOEXEC, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logPath := filepath.Join(opts.WorkDirectory, req.GetOpts().GetLogFile())
0000000000000000000000000000000000000000;;		criuClient := os.NewFile(uintptr(fds[0]), "criu-transport-client")
0000000000000000000000000000000000000000;;		criuServer := os.NewFile(uintptr(fds[1]), "criu-transport-server")
0000000000000000000000000000000000000000;;		defer criuClient.Close()
0000000000000000000000000000000000000000;;		defer criuServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := []string{"swrk", "3"}
0000000000000000000000000000000000000000;;		logrus.Debugf("Using CRIU %d at: %s", c.criuVersion, c.criuPath)
0000000000000000000000000000000000000000;;		logrus.Debugf("Using CRIU with following args: %s", args)
0000000000000000000000000000000000000000;;		cmd := exec.Command(c.criuPath, args...)
0000000000000000000000000000000000000000;;		if process != nil {
0000000000000000000000000000000000000000;;			cmd.Stdin = process.Stdin
0000000000000000000000000000000000000000;;			cmd.Stdout = process.Stdout
0000000000000000000000000000000000000000;;			cmd.Stderr = process.Stderr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.ExtraFiles = append(cmd.ExtraFiles, criuServer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := cmd.Start(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		criuServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			criuClient.Close()
0000000000000000000000000000000000000000;;			_, err := cmd.Process.Wait()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if applyCgroups {
0000000000000000000000000000000000000000;;			err := c.criuApplyCgroups(cmd.Process.Pid, req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var extFds []string
0000000000000000000000000000000000000000;;		if process != nil {
0000000000000000000000000000000000000000;;			extFds, err = getPipeFds(cmd.Process.Pid)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logrus.Debugf("Using CRIU in %s mode", req.GetType().String())
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(req.GetOpts())
0000000000000000000000000000000000000000;;		v := reflect.Indirect(val)
0000000000000000000000000000000000000000;;		for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;			st := v.Type()
0000000000000000000000000000000000000000;;			name := st.Field(i).Name
0000000000000000000000000000000000000000;;			if strings.HasPrefix(name, "XXX_") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value := val.MethodByName("Get" + name).Call([]reflect.Value{})
0000000000000000000000000000000000000000;;			logrus.Debugf("CRIU option %s with value %v", name, value[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := proto.Marshal(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = criuClient.Write(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]byte, 10*4096)
0000000000000000000000000000000000000000;;		for true {
0000000000000000000000000000000000000000;;			n, err := criuClient.Read(buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unexpected EOF")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n == len(buf) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("buffer is too small")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp := new(criurpc.CriuResp)
0000000000000000000000000000000000000000;;			err = proto.Unmarshal(buf[:n], resp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !resp.GetSuccess() {
0000000000000000000000000000000000000000;;				typeString := req.GetType().String()
0000000000000000000000000000000000000000;;				return fmt.Errorf("criu failed: type %s errno %d\nlog file: %s", typeString, resp.GetCrErrno(), logPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t := resp.GetType()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case t == criurpc.CriuReqType_NOTIFY:
0000000000000000000000000000000000000000;;				if err := c.criuNotifications(resp, process, opts, extFds); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t = criurpc.CriuReqType_NOTIFY
0000000000000000000000000000000000000000;;				req = &criurpc.CriuReq{
0000000000000000000000000000000000000000;;					Type:          &t,
0000000000000000000000000000000000000000;;					NotifySuccess: proto.Bool(true),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				data, err = proto.Marshal(req)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = criuClient.Write(data)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case t == criurpc.CriuReqType_RESTORE:
0000000000000000000000000000000000000000;;			case t == criurpc.CriuReqType_DUMP:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to parse the response %s", resp.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cmd.Wait() waits cmd.goroutines which are used for proxying file descriptors.
0000000000000000000000000000000000000000;;		// Here we want to wait only the CRIU process.
0000000000000000000000000000000000000000;;		st, err := cmd.Process.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !st.Success() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("criu failed: %s\nlog file: %s", st.String(), logPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// block any external network activity
0000000000000000000000000000000000000000;;	func lockNetwork(config *configs.Config) error {
0000000000000000000000000000000000000000;;		for _, config := range config.Networks {
0000000000000000000000000000000000000000;;			strategy, err := getStrategy(config.Type)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := strategy.detach(config); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unlockNetwork(config *configs.Config) error {
0000000000000000000000000000000000000000;;		for _, config := range config.Networks {
0000000000000000000000000000000000000000;;			strategy, err := getStrategy(config.Type)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = strategy.attach(config); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) criuNotifications(resp *criurpc.CriuResp, process *Process, opts *CriuOpts, fds []string) error {
0000000000000000000000000000000000000000;;		notify := resp.GetNotify()
0000000000000000000000000000000000000000;;		if notify == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid response: %s", resp.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case notify.GetScript() == "post-dump":
0000000000000000000000000000000000000000;;			f, err := os.Create(filepath.Join(c.root, "checkpoint"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.Close()
0000000000000000000000000000000000000000;;		case notify.GetScript() == "network-unlock":
0000000000000000000000000000000000000000;;			if err := unlockNetwork(c.config); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case notify.GetScript() == "network-lock":
0000000000000000000000000000000000000000;;			if err := lockNetwork(c.config); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case notify.GetScript() == "setup-namespaces":
0000000000000000000000000000000000000000;;			if c.config.Hooks != nil {
0000000000000000000000000000000000000000;;				s := configs.HookState{
0000000000000000000000000000000000000000;;					Version: c.config.Version,
0000000000000000000000000000000000000000;;					ID:      c.id,
0000000000000000000000000000000000000000;;					Pid:     int(notify.GetPid()),
0000000000000000000000000000000000000000;;					Root:    c.config.Rootfs,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i, hook := range c.config.Hooks.Prestart {
0000000000000000000000000000000000000000;;					if err := hook.Run(s); err != nil {
0000000000000000000000000000000000000000;;						return newSystemErrorWithCausef(err, "running prestart hook %d", i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case notify.GetScript() == "post-restore":
0000000000000000000000000000000000000000;;			pid := notify.GetPid()
0000000000000000000000000000000000000000;;			r, err := newRestoredProcess(int(pid), fds)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			process.ops = r
0000000000000000000000000000000000000000;;			if err := c.state.transition(&restoredState{
0000000000000000000000000000000000000000;;				imageDir: opts.ImagesDirectory,
0000000000000000000000000000000000000000;;				c:        c,
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// create a timestamp indicating when the restored checkpoint was started
0000000000000000000000000000000000000000;;			c.created = time.Now().UTC()
0000000000000000000000000000000000000000;;			if _, err := c.updateState(r); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := os.Remove(filepath.Join(c.root, "checkpoint")); err != nil {
0000000000000000000000000000000000000000;;				if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					logrus.Error(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) updateState(process parentProcess) (*State, error) {
0000000000000000000000000000000000000000;;		c.initProcess = process
0000000000000000000000000000000000000000;;		state, err := c.currentState()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.saveState(state)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) saveState(s *State) error {
0000000000000000000000000000000000000000;;		f, err := os.Create(filepath.Join(c.root, stateFilename))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		return utils.WriteJSON(f, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) deleteState() error {
0000000000000000000000000000000000000000;;		return os.Remove(filepath.Join(c.root, stateFilename))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) currentStatus() (Status, error) {
0000000000000000000000000000000000000000;;		if err := c.refreshState(); err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.state.status(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// refreshState needs to be called to verify that the current state on the
0000000000000000000000000000000000000000;;	// container is what is true.  Because consumers of libcontainer can use it
0000000000000000000000000000000000000000;;	// out of process we need to verify the container's status based on runtime
0000000000000000000000000000000000000000;;	// information and not rely on our in process info.
0000000000000000000000000000000000000000;;	func (c *linuxContainer) refreshState() error {
0000000000000000000000000000000000000000;;		paused, err := c.isPaused()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if paused {
0000000000000000000000000000000000000000;;			return c.state.transition(&pausedState{c: c})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := c.runType()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case Created:
0000000000000000000000000000000000000000;;			return c.state.transition(&createdState{c: c})
0000000000000000000000000000000000000000;;		case Running:
0000000000000000000000000000000000000000;;			return c.state.transition(&runningState{c: c})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.state.transition(&stoppedState{c: c})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doesInitProcessExist checks if the init process is still the same process
0000000000000000000000000000000000000000;;	// as the initial one, it could happen that the original process has exited
0000000000000000000000000000000000000000;;	// and a new process has been created with the same pid, in this case, the
0000000000000000000000000000000000000000;;	// container would already be stopped.
0000000000000000000000000000000000000000;;	func (c *linuxContainer) doesInitProcessExist(initPid int) (bool, error) {
0000000000000000000000000000000000000000;;		startTime, err := system.GetProcessStartTime(initPid)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, newSystemErrorWithCausef(err, "getting init process %d start time", initPid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.initProcessStartTime != startTime {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) runType() (Status, error) {
0000000000000000000000000000000000000000;;		if c.initProcess == nil {
0000000000000000000000000000000000000000;;			return Stopped, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pid := c.initProcess.pid()
0000000000000000000000000000000000000000;;		// return Running if the init process is alive
0000000000000000000000000000000000000000;;		if err := syscall.Kill(pid, 0); err != nil {
0000000000000000000000000000000000000000;;			if err == syscall.ESRCH {
0000000000000000000000000000000000000000;;				// It means the process does not exist anymore, could happen when the
0000000000000000000000000000000000000000;;				// process exited just when we call the function, we should not return
0000000000000000000000000000000000000000;;				// error in this case.
0000000000000000000000000000000000000000;;				return Stopped, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Stopped, newSystemErrorWithCausef(err, "sending signal 0 to pid %d", pid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check if the process is still the original init process.
0000000000000000000000000000000000000000;;		exist, err := c.doesInitProcessExist(pid)
0000000000000000000000000000000000000000;;		if !exist || err != nil {
0000000000000000000000000000000000000000;;			return Stopped, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check if the process that is running is the init process or the user's process.
0000000000000000000000000000000000000000;;		// this is the difference between the container Running and Created.
0000000000000000000000000000000000000000;;		environ, err := ioutil.ReadFile(fmt.Sprintf("/proc/%d/environ", pid))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Stopped, newSystemErrorWithCausef(err, "reading /proc/%d/environ", pid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		check := []byte("_LIBCONTAINER")
0000000000000000000000000000000000000000;;		if bytes.Contains(environ, check) {
0000000000000000000000000000000000000000;;			return Created, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Running, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) isPaused() (bool, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(filepath.Join(c.cgroupManager.GetPaths()["freezer"], "freezer.state"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If freezer cgroup is not mounted, the container would just be not paused.
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, newSystemErrorWithCause(err, "checking if container is paused")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes.Equal(bytes.TrimSpace(data), []byte("FROZEN")), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *linuxContainer) currentState() (*State, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			startTime           string
0000000000000000000000000000000000000000;;			externalDescriptors []string
0000000000000000000000000000000000000000;;			pid                 = -1
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if c.initProcess != nil {
0000000000000000000000000000000000000000;;			pid = c.initProcess.pid()
0000000000000000000000000000000000000000;;			startTime, _ = c.initProcess.startTime()
0000000000000000000000000000000000000000;;			externalDescriptors = c.initProcess.externalDescriptors()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		state := &State{
0000000000000000000000000000000000000000;;			BaseState: BaseState{
0000000000000000000000000000000000000000;;				ID:                   c.ID(),
0000000000000000000000000000000000000000;;				Config:               *c.config,
0000000000000000000000000000000000000000;;				InitProcessPid:       pid,
0000000000000000000000000000000000000000;;				InitProcessStartTime: startTime,
0000000000000000000000000000000000000000;;				Created:              c.created,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			CgroupPaths:         c.cgroupManager.GetPaths(),
0000000000000000000000000000000000000000;;			NamespacePaths:      make(map[configs.NamespaceType]string),
0000000000000000000000000000000000000000;;			ExternalDescriptors: externalDescriptors,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pid > 0 {
0000000000000000000000000000000000000000;;			for _, ns := range c.config.Namespaces {
0000000000000000000000000000000000000000;;				state.NamespacePaths[ns.Type] = ns.GetPath(pid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, nsType := range configs.NamespaceTypes() {
0000000000000000000000000000000000000000;;				if !configs.IsNamespaceSupported(nsType) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := state.NamespacePaths[nsType]; !ok {
0000000000000000000000000000000000000000;;					ns := configs.Namespace{Type: nsType}
0000000000000000000000000000000000000000;;					state.NamespacePaths[ns.Type] = ns.GetPath(pid)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// orderNamespacePaths sorts namespace paths into a list of paths that we
0000000000000000000000000000000000000000;;	// can setns in order.
0000000000000000000000000000000000000000;;	func (c *linuxContainer) orderNamespacePaths(namespaces map[configs.NamespaceType]string) ([]string, error) {
0000000000000000000000000000000000000000;;		paths := []string{}
0000000000000000000000000000000000000000;;		nsTypes := []configs.NamespaceType{
0000000000000000000000000000000000000000;;			configs.NEWIPC,
0000000000000000000000000000000000000000;;			configs.NEWUTS,
0000000000000000000000000000000000000000;;			configs.NEWNET,
0000000000000000000000000000000000000000;;			configs.NEWPID,
0000000000000000000000000000000000000000;;			configs.NEWNS,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// join userns if the init process explicitly requires NEWUSER
0000000000000000000000000000000000000000;;		if c.config.Namespaces.Contains(configs.NEWUSER) {
0000000000000000000000000000000000000000;;			nsTypes = append(nsTypes, configs.NEWUSER)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, nsType := range nsTypes {
0000000000000000000000000000000000000000;;			if p, ok := namespaces[nsType]; ok && p != "" {
0000000000000000000000000000000000000000;;				// check if the requested namespace is supported
0000000000000000000000000000000000000000;;				if !configs.IsNamespaceSupported(nsType) {
0000000000000000000000000000000000000000;;					return nil, newSystemError(fmt.Errorf("namespace %s is not supported", nsType))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// only set to join this namespace if it exists
0000000000000000000000000000000000000000;;				if _, err := os.Lstat(p); err != nil {
0000000000000000000000000000000000000000;;					return nil, newSystemErrorWithCausef(err, "running lstat on namespace path %q", p)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// do not allow namespace path with comma as we use it to separate
0000000000000000000000000000000000000000;;				// the namespace paths
0000000000000000000000000000000000000000;;				if strings.ContainsRune(p, ',') {
0000000000000000000000000000000000000000;;					return nil, newSystemError(fmt.Errorf("invalid path %s", p))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				paths = append(paths, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return paths, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {
0000000000000000000000000000000000000000;;		data := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		for _, im := range idMap {
0000000000000000000000000000000000000000;;			line := fmt.Sprintf("%d %d %d\n", im.ContainerID, im.HostID, im.Size)
0000000000000000000000000000000000000000;;			if _, err := data.WriteString(line); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bootstrapData encodes the necessary data in netlink binary format
0000000000000000000000000000000000000000;;	// as a io.Reader.
0000000000000000000000000000000000000000;;	// Consumer can write the data to a bootstrap program
0000000000000000000000000000000000000000;;	// such as one that uses nsenter package to bootstrap the container's
0000000000000000000000000000000000000000;;	// init process correctly, i.e. with correct namespaces, uid/gid
0000000000000000000000000000000000000000;;	// mapping etc.
0000000000000000000000000000000000000000;;	func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, consolePath string) (io.Reader, error) {
0000000000000000000000000000000000000000;;		// create the netlink message
0000000000000000000000000000000000000000;;		r := nl.NewNetlinkRequest(int(InitMsg), 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write cloneFlags
0000000000000000000000000000000000000000;;		r.AddData(&Int32msg{
0000000000000000000000000000000000000000;;			Type:  CloneFlagsAttr,
0000000000000000000000000000000000000000;;			Value: uint32(cloneFlags),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write console path
0000000000000000000000000000000000000000;;		if consolePath != "" {
0000000000000000000000000000000000000000;;			r.AddData(&Bytemsg{
0000000000000000000000000000000000000000;;				Type:  ConsolePathAttr,
0000000000000000000000000000000000000000;;				Value: []byte(consolePath),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write custom namespace paths
0000000000000000000000000000000000000000;;		if len(nsMaps) > 0 {
0000000000000000000000000000000000000000;;			nsPaths, err := c.orderNamespacePaths(nsMaps)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.AddData(&Bytemsg{
0000000000000000000000000000000000000000;;				Type:  NsPathsAttr,
0000000000000000000000000000000000000000;;				Value: []byte(strings.Join(nsPaths, ",")),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write namespace paths only when we are not joining an existing user ns
0000000000000000000000000000000000000000;;		_, joinExistingUser := nsMaps[configs.NEWUSER]
0000000000000000000000000000000000000000;;		if !joinExistingUser {
0000000000000000000000000000000000000000;;			// write uid mappings
0000000000000000000000000000000000000000;;			if len(c.config.UidMappings) > 0 {
0000000000000000000000000000000000000000;;				b, err := encodeIDMapping(c.config.UidMappings)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.AddData(&Bytemsg{
0000000000000000000000000000000000000000;;					Type:  UidmapAttr,
0000000000000000000000000000000000000000;;					Value: b,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// write gid mappings
0000000000000000000000000000000000000000;;			if len(c.config.GidMappings) > 0 {
0000000000000000000000000000000000000000;;				b, err := encodeIDMapping(c.config.GidMappings)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.AddData(&Bytemsg{
0000000000000000000000000000000000000000;;					Type:  GidmapAttr,
0000000000000000000000000000000000000000;;					Value: b,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				// check if we have CAP_SETGID to setgroup properly
0000000000000000000000000000000000000000;;				pid, err := capability.NewPid(os.Getpid())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !pid.Get(capability.EFFECTIVE, capability.CAP_SETGID) {
0000000000000000000000000000000000000000;;					r.AddData(&Boolmsg{
0000000000000000000000000000000000000000;;						Type:  SetgroupAttr,
0000000000000000000000000000000000000000;;						Value: true,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return bytes.NewReader(r.Serialize()), nil
0000000000000000000000000000000000000000;;	}
