0000000000000000000000000000000000000000;;	// +build linux
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/process_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/process_linux.go][vendor/github.com/opencontainers/runc/libcontainer/process_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/system"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parentProcess interface {
0000000000000000000000000000000000000000;;		// pid returns the pid for the running process.
0000000000000000000000000000000000000000;;		pid() int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start starts the process execution.
0000000000000000000000000000000000000000;;		start() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// send a SIGKILL to the process and wait for the exit.
0000000000000000000000000000000000000000;;		terminate() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait waits on the process returning the process state.
0000000000000000000000000000000000000000;;		wait() (*os.ProcessState, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// startTime returns the process start time.
0000000000000000000000000000000000000000;;		startTime() (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signal(os.Signal) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		externalDescriptors() []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setExternalDescriptors(fds []string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setnsProcess struct {
0000000000000000000000000000000000000000;;		cmd           *exec.Cmd
0000000000000000000000000000000000000000;;		parentPipe    *os.File
0000000000000000000000000000000000000000;;		childPipe     *os.File
0000000000000000000000000000000000000000;;		cgroupPaths   map[string]string
0000000000000000000000000000000000000000;;		config        *initConfig
0000000000000000000000000000000000000000;;		fds           []string
0000000000000000000000000000000000000000;;		process       *Process
0000000000000000000000000000000000000000;;		bootstrapData io.Reader
0000000000000000000000000000000000000000;;		rootDir       *os.File
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *setnsProcess) startTime() (string, error) {
0000000000000000000000000000000000000000;;		return system.GetProcessStartTime(p.pid())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *setnsProcess) signal(sig os.Signal) error {
0000000000000000000000000000000000000000;;		s, ok := sig.(syscall.Signal)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("os: unsupported signal type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Kill(p.pid(), s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *setnsProcess) start() (err error) {
0000000000000000000000000000000000000000;;		defer p.parentPipe.Close()
0000000000000000000000000000000000000000;;		err = p.cmd.Start()
0000000000000000000000000000000000000000;;		p.childPipe.Close()
0000000000000000000000000000000000000000;;		p.rootDir.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "starting setns process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.bootstrapData != nil {
0000000000000000000000000000000000000000;;			if _, err := io.Copy(p.parentPipe, p.bootstrapData); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "copying bootstrap data to pipe")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = p.execSetns(); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "executing setns process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.cgroupPaths) > 0 {
0000000000000000000000000000000000000000;;			if err := cgroups.EnterPid(p.cgroupPaths, p.pid()); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCausef(err, "adding pid %d to cgroups", p.pid())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// set oom_score_adj
0000000000000000000000000000000000000000;;		if err := setOomScoreAdj(p.config.Config.OomScoreAdj, p.pid()); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "setting oom score")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// set rlimits, this has to be done here because we lose permissions
0000000000000000000000000000000000000000;;		// to raise the limits once we enter a user-namespace
0000000000000000000000000000000000000000;;		if err := setupRlimits(p.config.Rlimits, p.pid()); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "setting rlimits for process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := utils.WriteJSON(p.parentPipe, p.config); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "writing config to pipe")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := syscall.Shutdown(int(p.parentPipe.Fd()), syscall.SHUT_WR); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "calling shutdown on init pipe")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// wait for the child process to fully complete and receive an error message
0000000000000000000000000000000000000000;;		// if one was encoutered
0000000000000000000000000000000000000000;;		var ierr *genericError
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(p.parentPipe).Decode(&ierr); err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "decoding init error from pipe")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Must be done after Shutdown so the child will exit and we can wait for it.
0000000000000000000000000000000000000000;;		if ierr != nil {
0000000000000000000000000000000000000000;;			p.wait()
0000000000000000000000000000000000000000;;			return ierr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// execSetns runs the process that executes C code to perform the setns calls
0000000000000000000000000000000000000000;;	// because setns support requires the C process to fork off a child and perform the setns
0000000000000000000000000000000000000000;;	// before the go runtime boots, we wait on the process to die and receive the child's pid
0000000000000000000000000000000000000000;;	// over the provided pipe.
0000000000000000000000000000000000000000;;	func (p *setnsProcess) execSetns() error {
0000000000000000000000000000000000000000;;		status, err := p.cmd.Process.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.cmd.Wait()
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "waiting on setns process to finish")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !status.Success() {
0000000000000000000000000000000000000000;;			p.cmd.Wait()
0000000000000000000000000000000000000000;;			return newSystemError(&exec.ExitError{ProcessState: status})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var pid *pid
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(p.parentPipe).Decode(&pid); err != nil {
0000000000000000000000000000000000000000;;			p.cmd.Wait()
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "reading pid from init pipe")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		process, err := os.FindProcess(pid.Pid)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cmd.Process = process
0000000000000000000000000000000000000000;;		p.process.ops = p
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// terminate sends a SIGKILL to the forked process for the setns routine then waits to
0000000000000000000000000000000000000000;;	// avoid the process becoming a zombie.
0000000000000000000000000000000000000000;;	func (p *setnsProcess) terminate() error {
0000000000000000000000000000000000000000;;		if p.cmd.Process == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := p.cmd.Process.Kill()
0000000000000000000000000000000000000000;;		if _, werr := p.wait(); err == nil {
0000000000000000000000000000000000000000;;			err = werr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *setnsProcess) wait() (*os.ProcessState, error) {
0000000000000000000000000000000000000000;;		err := p.cmd.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return actual ProcessState even on Wait error
0000000000000000000000000000000000000000;;		return p.cmd.ProcessState, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *setnsProcess) pid() int {
0000000000000000000000000000000000000000;;		return p.cmd.Process.Pid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *setnsProcess) externalDescriptors() []string {
0000000000000000000000000000000000000000;;		return p.fds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *setnsProcess) setExternalDescriptors(newFds []string) {
0000000000000000000000000000000000000000;;		p.fds = newFds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initProcess struct {
0000000000000000000000000000000000000000;;		cmd           *exec.Cmd
0000000000000000000000000000000000000000;;		parentPipe    *os.File
0000000000000000000000000000000000000000;;		childPipe     *os.File
0000000000000000000000000000000000000000;;		config        *initConfig
0000000000000000000000000000000000000000;;		manager       cgroups.Manager
0000000000000000000000000000000000000000;;		container     *linuxContainer
0000000000000000000000000000000000000000;;		fds           []string
0000000000000000000000000000000000000000;;		process       *Process
0000000000000000000000000000000000000000;;		bootstrapData io.Reader
0000000000000000000000000000000000000000;;		sharePidns    bool
0000000000000000000000000000000000000000;;		rootDir       *os.File
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) pid() int {
0000000000000000000000000000000000000000;;		return p.cmd.Process.Pid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) externalDescriptors() []string {
0000000000000000000000000000000000000000;;		return p.fds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// execSetns runs the process that executes C code to perform the setns calls
0000000000000000000000000000000000000000;;	// because setns support requires the C process to fork off a child and perform the setns
0000000000000000000000000000000000000000;;	// before the go runtime boots, we wait on the process to die and receive the child's pid
0000000000000000000000000000000000000000;;	// over the provided pipe.
0000000000000000000000000000000000000000;;	// This is called by initProcess.start function
0000000000000000000000000000000000000000;;	func (p *initProcess) execSetns() error {
0000000000000000000000000000000000000000;;		status, err := p.cmd.Process.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.cmd.Wait()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !status.Success() {
0000000000000000000000000000000000000000;;			p.cmd.Wait()
0000000000000000000000000000000000000000;;			return &exec.ExitError{ProcessState: status}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var pid *pid
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(p.parentPipe).Decode(&pid); err != nil {
0000000000000000000000000000000000000000;;			p.cmd.Wait()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		process, err := os.FindProcess(pid.Pid)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cmd.Process = process
0000000000000000000000000000000000000000;;		p.process.ops = p
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) start() error {
0000000000000000000000000000000000000000;;		defer p.parentPipe.Close()
0000000000000000000000000000000000000000;;		err := p.cmd.Start()
0000000000000000000000000000000000000000;;		p.process.ops = p
0000000000000000000000000000000000000000;;		p.childPipe.Close()
0000000000000000000000000000000000000000;;		p.rootDir.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.process.ops = nil
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "starting init process command")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := io.Copy(p.parentPipe, p.bootstrapData); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := p.execSetns(); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "running exec setns process for init")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Save the standard descriptor names before the container process
0000000000000000000000000000000000000000;;		// can potentially move them (e.g., via dup2()).  If we don't do this now,
0000000000000000000000000000000000000000;;		// we won't know at checkpoint time which file descriptor to look up.
0000000000000000000000000000000000000000;;		fds, err := getPipeFds(p.pid())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCausef(err, "getting pipe fds for pid %d", p.pid())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.setExternalDescriptors(fds)
0000000000000000000000000000000000000000;;		// Do this before syncing with child so that no children
0000000000000000000000000000000000000000;;		// can escape the cgroup
0000000000000000000000000000000000000000;;		if err := p.manager.Apply(p.pid()); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "applying cgroup configuration for process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO: should not be the responsibility to call here
0000000000000000000000000000000000000000;;				p.manager.Destroy()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if err := p.createNetworkInterfaces(); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "creating network interfaces")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := p.sendConfig(); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "sending config to init process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			procSync   syncT
0000000000000000000000000000000000000000;;			sentRun    bool
0000000000000000000000000000000000000000;;			sentResume bool
0000000000000000000000000000000000000000;;			ierr       *genericError
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(p.parentPipe)
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err := dec.Decode(&procSync); err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "decoding sync type from init pipe")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch procSync.Type {
0000000000000000000000000000000000000000;;			case procReady:
0000000000000000000000000000000000000000;;				if err := p.manager.Set(p.config.Config); err != nil {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "setting cgroup config for ready process")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// set oom_score_adj
0000000000000000000000000000000000000000;;				if err := setOomScoreAdj(p.config.Config.OomScoreAdj, p.pid()); err != nil {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "setting oom score for ready process")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// set rlimits, this has to be done here because we lose permissions
0000000000000000000000000000000000000000;;				// to raise the limits once we enter a user-namespace
0000000000000000000000000000000000000000;;				if err := setupRlimits(p.config.Rlimits, p.pid()); err != nil {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "setting rlimits for ready process")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// call prestart hooks
0000000000000000000000000000000000000000;;				if !p.config.Config.Namespaces.Contains(configs.NEWNS) {
0000000000000000000000000000000000000000;;					if p.config.Config.Hooks != nil {
0000000000000000000000000000000000000000;;						s := configs.HookState{
0000000000000000000000000000000000000000;;							Version: p.container.config.Version,
0000000000000000000000000000000000000000;;							ID:      p.container.id,
0000000000000000000000000000000000000000;;							Pid:     p.pid(),
0000000000000000000000000000000000000000;;							Root:    p.config.Config.Rootfs,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for i, hook := range p.config.Config.Hooks.Prestart {
0000000000000000000000000000000000000000;;							if err := hook.Run(s); err != nil {
0000000000000000000000000000000000000000;;								return newSystemErrorWithCausef(err, "running prestart hook %d", i)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Sync with child.
0000000000000000000000000000000000000000;;				if err := utils.WriteJSON(p.parentPipe, syncT{procRun}); err != nil {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "reading syncT run type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sentRun = true
0000000000000000000000000000000000000000;;			case procHooks:
0000000000000000000000000000000000000000;;				if p.config.Config.Hooks != nil {
0000000000000000000000000000000000000000;;					s := configs.HookState{
0000000000000000000000000000000000000000;;						Version:    p.container.config.Version,
0000000000000000000000000000000000000000;;						ID:         p.container.id,
0000000000000000000000000000000000000000;;						Pid:        p.pid(),
0000000000000000000000000000000000000000;;						Root:       p.config.Config.Rootfs,
0000000000000000000000000000000000000000;;						BundlePath: utils.SearchLabels(p.config.Config.Labels, "bundle"),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for i, hook := range p.config.Config.Hooks.Prestart {
0000000000000000000000000000000000000000;;						if err := hook.Run(s); err != nil {
0000000000000000000000000000000000000000;;							return newSystemErrorWithCausef(err, "running prestart hook %d", i)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Sync with child.
0000000000000000000000000000000000000000;;				if err := utils.WriteJSON(p.parentPipe, syncT{procResume}); err != nil {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "reading syncT resume type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sentResume = true
0000000000000000000000000000000000000000;;			case procError:
0000000000000000000000000000000000000000;;				// wait for the child process to fully complete and receive an error message
0000000000000000000000000000000000000000;;				// if one was encoutered
0000000000000000000000000000000000000000;;				if err := dec.Decode(&ierr); err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					return newSystemErrorWithCause(err, "decoding proc error from init")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ierr != nil {
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Programmer error.
0000000000000000000000000000000000000000;;				panic("No error following JSON procError payload.")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return newSystemError(fmt.Errorf("invalid JSON payload from child"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sentRun {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(ierr, "container init")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.config.Config.Namespaces.Contains(configs.NEWNS) && !sentResume {
0000000000000000000000000000000000000000;;			return newSystemError(fmt.Errorf("could not synchronise after executing prestart hooks with container process"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Shutdown(int(p.parentPipe.Fd()), syscall.SHUT_WR); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "shutting down init pipe")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Must be done after Shutdown so the child will exit and we can wait for it.
0000000000000000000000000000000000000000;;		if ierr != nil {
0000000000000000000000000000000000000000;;			p.wait()
0000000000000000000000000000000000000000;;			return ierr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) wait() (*os.ProcessState, error) {
0000000000000000000000000000000000000000;;		err := p.cmd.Wait()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return p.cmd.ProcessState, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we should kill all processes in cgroup when init is died if we use host PID namespace
0000000000000000000000000000000000000000;;		if p.sharePidns {
0000000000000000000000000000000000000000;;			killCgroupProcesses(p.manager)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.cmd.ProcessState, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) terminate() error {
0000000000000000000000000000000000000000;;		if p.cmd.Process == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := p.cmd.Process.Kill()
0000000000000000000000000000000000000000;;		if _, werr := p.wait(); err == nil {
0000000000000000000000000000000000000000;;			err = werr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) startTime() (string, error) {
0000000000000000000000000000000000000000;;		return system.GetProcessStartTime(p.pid())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) sendConfig() error {
0000000000000000000000000000000000000000;;		// send the config to the container's init process, we don't use JSON Encode
0000000000000000000000000000000000000000;;		// here because there might be a problem in JSON decoder in some cases, see:
0000000000000000000000000000000000000000;;		// https://github.com/docker/docker/issues/14203#issuecomment-174177790
0000000000000000000000000000000000000000;;		return utils.WriteJSON(p.parentPipe, p.config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) createNetworkInterfaces() error {
0000000000000000000000000000000000000000;;		for _, config := range p.config.Config.Networks {
0000000000000000000000000000000000000000;;			strategy, err := getStrategy(config.Type)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n := &network{
0000000000000000000000000000000000000000;;				Network: *config,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := strategy.create(n, p.pid()); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.config.Networks = append(p.config.Networks, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) signal(sig os.Signal) error {
0000000000000000000000000000000000000000;;		s, ok := sig.(syscall.Signal)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("os: unsupported signal type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Kill(p.pid(), s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *initProcess) setExternalDescriptors(newFds []string) {
0000000000000000000000000000000000000000;;		p.fds = newFds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPipeFds(pid int) ([]string, error) {
0000000000000000000000000000000000000000;;		fds := make([]string, 3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirPath := filepath.Join("/proc", strconv.Itoa(pid), "/fd")
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			f := filepath.Join(dirPath, strconv.Itoa(i))
0000000000000000000000000000000000000000;;			target, err := os.Readlink(f)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fds, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fds[i] = target
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fds, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitializeIO creates pipes for use with the process's STDIO
0000000000000000000000000000000000000000;;	// and returns the opposite side for each
0000000000000000000000000000000000000000;;	func (p *Process) InitializeIO(rootuid, rootgid int) (i *IO, err error) {
0000000000000000000000000000000000000000;;		var fds []uintptr
0000000000000000000000000000000000000000;;		i = &IO{}
0000000000000000000000000000000000000000;;		// cleanup in case of an error
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				for _, fd := range fds {
0000000000000000000000000000000000000000;;					syscall.Close(int(fd))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// STDIN
0000000000000000000000000000000000000000;;		r, w, err := os.Pipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fds = append(fds, r.Fd(), w.Fd())
0000000000000000000000000000000000000000;;		p.Stdin, i.Stdin = r, w
0000000000000000000000000000000000000000;;		// STDOUT
0000000000000000000000000000000000000000;;		if r, w, err = os.Pipe(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fds = append(fds, r.Fd(), w.Fd())
0000000000000000000000000000000000000000;;		p.Stdout, i.Stdout = w, r
0000000000000000000000000000000000000000;;		// STDERR
0000000000000000000000000000000000000000;;		if r, w, err = os.Pipe(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fds = append(fds, r.Fd(), w.Fd())
0000000000000000000000000000000000000000;;		p.Stderr, i.Stderr = w, r
0000000000000000000000000000000000000000;;		// change ownership of the pipes incase we are in a user namespace
0000000000000000000000000000000000000000;;		for _, fd := range fds {
0000000000000000000000000000000000000000;;			if err := syscall.Fchown(int(fd), rootuid, rootgid); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i, nil
0000000000000000000000000000000000000000;;	}
