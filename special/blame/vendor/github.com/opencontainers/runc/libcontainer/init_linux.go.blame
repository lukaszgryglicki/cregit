0000000000000000000000000000000000000000;;	// +build linux
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/init_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/init_linux.go][vendor/github.com/opencontainers/runc/libcontainer/init_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Sirupsen/logrus"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/system"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/user"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;		"github.com/vishvananda/netlink"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		initSetns    initType = "setns"
0000000000000000000000000000000000000000;;		initStandard initType = "standard"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pid struct {
0000000000000000000000000000000000000000;;		Pid int `json:"pid"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// network is an internal struct used to setup container networks.
0000000000000000000000000000000000000000;;	type network struct {
0000000000000000000000000000000000000000;;		configs.Network
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TempVethPeerName is a unique temporary veth peer name that was placed into
0000000000000000000000000000000000000000;;		// the container's namespace.
0000000000000000000000000000000000000000;;		TempVethPeerName string `json:"temp_veth_peer_name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// initConfig is used for transferring parameters from Exec() to Init()
0000000000000000000000000000000000000000;;	type initConfig struct {
0000000000000000000000000000000000000000;;		Args             []string         `json:"args"`
0000000000000000000000000000000000000000;;		Env              []string         `json:"env"`
0000000000000000000000000000000000000000;;		Cwd              string           `json:"cwd"`
0000000000000000000000000000000000000000;;		Capabilities     []string         `json:"capabilities"`
0000000000000000000000000000000000000000;;		ProcessLabel     string           `json:"process_label"`
0000000000000000000000000000000000000000;;		AppArmorProfile  string           `json:"apparmor_profile"`
0000000000000000000000000000000000000000;;		NoNewPrivileges  bool             `json:"no_new_privileges"`
0000000000000000000000000000000000000000;;		User             string           `json:"user"`
0000000000000000000000000000000000000000;;		AdditionalGroups []string         `json:"additional_groups"`
0000000000000000000000000000000000000000;;		Config           *configs.Config  `json:"config"`
0000000000000000000000000000000000000000;;		Console          string           `json:"console"`
0000000000000000000000000000000000000000;;		Networks         []*network       `json:"network"`
0000000000000000000000000000000000000000;;		PassedFilesCount int              `json:"passed_files_count"`
0000000000000000000000000000000000000000;;		ContainerId      string           `json:"containerid"`
0000000000000000000000000000000000000000;;		Rlimits          []configs.Rlimit `json:"rlimits"`
0000000000000000000000000000000000000000;;		ExecFifoPath     string           `json:"start_pipe_path"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type initer interface {
0000000000000000000000000000000000000000;;		Init() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newContainerInit(t initType, pipe *os.File, stateDirFD int) (initer, error) {
0000000000000000000000000000000000000000;;		var config *initConfig
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(pipe).Decode(&config); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := populateProcessEnvironment(config.Env); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case initSetns:
0000000000000000000000000000000000000000;;			return &linuxSetnsInit{
0000000000000000000000000000000000000000;;				config: config,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case initStandard:
0000000000000000000000000000000000000000;;			return &linuxStandardInit{
0000000000000000000000000000000000000000;;				pipe:       pipe,
0000000000000000000000000000000000000000;;				parentPid:  syscall.Getppid(),
0000000000000000000000000000000000000000;;				config:     config,
0000000000000000000000000000000000000000;;				stateDirFD: stateDirFD,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unknown init type %q", t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// populateProcessEnvironment loads the provided environment variables into the
0000000000000000000000000000000000000000;;	// current processes's environment.
0000000000000000000000000000000000000000;;	func populateProcessEnvironment(env []string) error {
0000000000000000000000000000000000000000;;		for _, pair := range env {
0000000000000000000000000000000000000000;;			p := strings.SplitN(pair, "=", 2)
0000000000000000000000000000000000000000;;			if len(p) < 2 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid environment '%v'", pair)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := os.Setenv(p[0], p[1]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finalizeNamespace drops the caps, sets the correct user
0000000000000000000000000000000000000000;;	// and working dir, and closes any leaked file descriptors
0000000000000000000000000000000000000000;;	// before executing the command inside the namespace
0000000000000000000000000000000000000000;;	func finalizeNamespace(config *initConfig) error {
0000000000000000000000000000000000000000;;		// Ensure that all unwanted fds we may have accidentally
0000000000000000000000000000000000000000;;		// inherited are marked close-on-exec so they stay out of the
0000000000000000000000000000000000000000;;		// container
0000000000000000000000000000000000000000;;		if err := utils.CloseExecFrom(config.PassedFilesCount + 3); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capabilities := config.Config.Capabilities
0000000000000000000000000000000000000000;;		if config.Capabilities != nil {
0000000000000000000000000000000000000000;;			capabilities = config.Capabilities
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w, err := newCapWhitelist(capabilities)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// drop capabilities in bounding set before changing user
0000000000000000000000000000000000000000;;		if err := w.dropBoundingSet(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// preserve existing capabilities while we change users
0000000000000000000000000000000000000000;;		if err := system.SetKeepCaps(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := setupUser(config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := system.ClearKeepCaps(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// drop all other capabilities
0000000000000000000000000000000000000000;;		if err := w.drop(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.Cwd != "" {
0000000000000000000000000000000000000000;;			if err := syscall.Chdir(config.Cwd); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("chdir to cwd (%q) set in config.json failed: %v", config.Cwd, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncParentReady sends to the given pipe a JSON payload which indicates that
0000000000000000000000000000000000000000;;	// the init is ready to Exec the child process. It then waits for the parent to
0000000000000000000000000000000000000000;;	// indicate that it is cleared to Exec.
0000000000000000000000000000000000000000;;	func syncParentReady(pipe io.ReadWriter) error {
0000000000000000000000000000000000000000;;		// Tell parent.
0000000000000000000000000000000000000000;;		if err := utils.WriteJSON(pipe, syncT{procReady}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait for parent to give the all-clear.
0000000000000000000000000000000000000000;;		var procSync syncT
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(pipe).Decode(&procSync); err != nil {
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return fmt.Errorf("parent closed synchronisation channel")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if procSync.Type != procRun {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid synchronisation flag from parent")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncParentHooks sends to the given pipe a JSON payload which indicates that
0000000000000000000000000000000000000000;;	// the parent should execute pre-start hooks. It then waits for the parent to
0000000000000000000000000000000000000000;;	// indicate that it is cleared to resume.
0000000000000000000000000000000000000000;;	func syncParentHooks(pipe io.ReadWriter) error {
0000000000000000000000000000000000000000;;		// Tell parent.
0000000000000000000000000000000000000000;;		if err := utils.WriteJSON(pipe, syncT{procHooks}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait for parent to give the all-clear.
0000000000000000000000000000000000000000;;		var procSync syncT
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(pipe).Decode(&procSync); err != nil {
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return fmt.Errorf("parent closed synchronisation channel")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if procSync.Type != procResume {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid synchronisation flag from parent")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setupUser changes the groups, gid, and uid for the user inside the container
0000000000000000000000000000000000000000;;	func setupUser(config *initConfig) error {
0000000000000000000000000000000000000000;;		// Set up defaults.
0000000000000000000000000000000000000000;;		defaultExecUser := user.ExecUser{
0000000000000000000000000000000000000000;;			Uid:  syscall.Getuid(),
0000000000000000000000000000000000000000;;			Gid:  syscall.Getgid(),
0000000000000000000000000000000000000000;;			Home: "/",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		passwdPath, err := user.GetPasswdPath()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupPath, err := user.GetGroupPath()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		execUser, err := user.GetExecUserPath(config.User, &defaultExecUser, passwdPath, groupPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var addGroups []int
0000000000000000000000000000000000000000;;		if len(config.AdditionalGroups) > 0 {
0000000000000000000000000000000000000000;;			addGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// before we change to the container's user make sure that the processes STDIO
0000000000000000000000000000000000000000;;		// is correctly owned by the user that we are switching to.
0000000000000000000000000000000000000000;;		if err := fixStdioPermissions(execUser); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suppGroups := append(execUser.Sgids, addGroups...)
0000000000000000000000000000000000000000;;		if err := syscall.Setgroups(suppGroups); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := system.Setgid(execUser.Gid); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := system.Setuid(execUser.Uid); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if we didn't get HOME already, set it based on the user's HOME
0000000000000000000000000000000000000000;;		if envHome := os.Getenv("HOME"); envHome == "" {
0000000000000000000000000000000000000000;;			if err := os.Setenv("HOME", execUser.Home); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fixStdioPermissions fixes the permissions of PID 1's STDIO within the container to the specified user.
0000000000000000000000000000000000000000;;	// The ownership needs to match because it is created outside of the container and needs to be
0000000000000000000000000000000000000000;;	// localized.
0000000000000000000000000000000000000000;;	func fixStdioPermissions(u *user.ExecUser) error {
0000000000000000000000000000000000000000;;		var null syscall.Stat_t
0000000000000000000000000000000000000000;;		if err := syscall.Stat("/dev/null", &null); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, fd := range []uintptr{
0000000000000000000000000000000000000000;;			os.Stdin.Fd(),
0000000000000000000000000000000000000000;;			os.Stderr.Fd(),
0000000000000000000000000000000000000000;;			os.Stdout.Fd(),
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			var s syscall.Stat_t
0000000000000000000000000000000000000000;;			if err := syscall.Fstat(int(fd), &s); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// skip chown of /dev/null if it was used as one of the STDIO fds.
0000000000000000000000000000000000000000;;			if s.Rdev == null.Rdev {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := syscall.Fchown(int(fd), u.Uid, u.Gid); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setupNetwork sets up and initializes any network interface inside the container.
0000000000000000000000000000000000000000;;	func setupNetwork(config *initConfig) error {
0000000000000000000000000000000000000000;;		for _, config := range config.Networks {
0000000000000000000000000000000000000000;;			strategy, err := getStrategy(config.Type)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := strategy.initialize(config); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupRoute(config *configs.Config) error {
0000000000000000000000000000000000000000;;		for _, config := range config.Routes {
0000000000000000000000000000000000000000;;			_, dst, err := net.ParseCIDR(config.Destination)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			src := net.ParseIP(config.Source)
0000000000000000000000000000000000000000;;			if src == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Invalid source for route: %s", config.Source)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gw := net.ParseIP(config.Gateway)
0000000000000000000000000000000000000000;;			if gw == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Invalid gateway for route: %s", config.Gateway)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l, err := netlink.LinkByName(config.InterfaceName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			route := &netlink.Route{
0000000000000000000000000000000000000000;;				Scope:     netlink.SCOPE_UNIVERSE,
0000000000000000000000000000000000000000;;				Dst:       dst,
0000000000000000000000000000000000000000;;				Src:       src,
0000000000000000000000000000000000000000;;				Gw:        gw,
0000000000000000000000000000000000000000;;				LinkIndex: l.Attrs().Index,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := netlink.RouteAdd(route); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setupRlimits(limits []configs.Rlimit, pid int) error {
0000000000000000000000000000000000000000;;		for _, rlimit := range limits {
0000000000000000000000000000000000000000;;			if err := system.Prlimit(pid, rlimit.Type, syscall.Rlimit{Max: rlimit.Hard, Cur: rlimit.Soft}); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error setting rlimit type %v: %v", rlimit.Type, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setOomScoreAdj(oomScoreAdj int, pid int) error {
0000000000000000000000000000000000000000;;		path := fmt.Sprintf("/proc/%d/oom_score_adj", pid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(path, []byte(strconv.Itoa(oomScoreAdj)), 0600)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// killCgroupProcesses freezes then iterates over all the processes inside the
0000000000000000000000000000000000000000;;	// manager's cgroups sending a SIGKILL to each process then waiting for them to
0000000000000000000000000000000000000000;;	// exit.
0000000000000000000000000000000000000000;;	func killCgroupProcesses(m cgroups.Manager) error {
0000000000000000000000000000000000000000;;		var procs []*os.Process
0000000000000000000000000000000000000000;;		if err := m.Freeze(configs.Frozen); err != nil {
0000000000000000000000000000000000000000;;			logrus.Warn(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pids, err := m.GetAllPids()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			m.Freeze(configs.Thawed)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pid := range pids {
0000000000000000000000000000000000000000;;			p, err := os.FindProcess(pid)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				logrus.Warn(err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			procs = append(procs, p)
0000000000000000000000000000000000000000;;			if err := p.Kill(); err != nil {
0000000000000000000000000000000000000000;;				logrus.Warn(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := m.Freeze(configs.Thawed); err != nil {
0000000000000000000000000000000000000000;;			logrus.Warn(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range procs {
0000000000000000000000000000000000000000;;			if _, err := p.Wait(); err != nil {
0000000000000000000000000000000000000000;;				logrus.Warn(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
