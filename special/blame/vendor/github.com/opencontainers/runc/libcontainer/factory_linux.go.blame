0000000000000000000000000000000000000000;;	// +build linux
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/factory_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/factory_linux.go][vendor/github.com/opencontainers/runc/libcontainer/factory_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/mount"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups/fs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups/systemd"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs/validate"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		stateFilename    = "state.json"
0000000000000000000000000000000000000000;;		execFifoFilename = "exec.fifo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		idRegex  = regexp.MustCompile(`^[\w+-\.]+$`)
0000000000000000000000000000000000000000;;		maxIdLen = 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitArgs returns an options func to configure a LinuxFactory with the
0000000000000000000000000000000000000000;;	// provided init binary path and arguments.
0000000000000000000000000000000000000000;;	func InitArgs(args ...string) func(*LinuxFactory) error {
0000000000000000000000000000000000000000;;		return func(l *LinuxFactory) error {
0000000000000000000000000000000000000000;;			l.InitArgs = args
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SystemdCgroups is an options func to configure a LinuxFactory to return
0000000000000000000000000000000000000000;;	// containers that use systemd to create and manage cgroups.
0000000000000000000000000000000000000000;;	func SystemdCgroups(l *LinuxFactory) error {
0000000000000000000000000000000000000000;;		l.NewCgroupsManager = func(config *configs.Cgroup, paths map[string]string) cgroups.Manager {
0000000000000000000000000000000000000000;;			return &systemd.Manager{
0000000000000000000000000000000000000000;;				Cgroups: config,
0000000000000000000000000000000000000000;;				Paths:   paths,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cgroupfs is an options func to configure a LinuxFactory to return
0000000000000000000000000000000000000000;;	// containers that use the native cgroups filesystem implementation to
0000000000000000000000000000000000000000;;	// create and manage cgroups.
0000000000000000000000000000000000000000;;	func Cgroupfs(l *LinuxFactory) error {
0000000000000000000000000000000000000000;;		l.NewCgroupsManager = func(config *configs.Cgroup, paths map[string]string) cgroups.Manager {
0000000000000000000000000000000000000000;;			return &fs.Manager{
0000000000000000000000000000000000000000;;				Cgroups: config,
0000000000000000000000000000000000000000;;				Paths:   paths,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TmpfsRoot is an option func to mount LinuxFactory.Root to tmpfs.
0000000000000000000000000000000000000000;;	func TmpfsRoot(l *LinuxFactory) error {
0000000000000000000000000000000000000000;;		mounted, err := mount.Mounted(l.Root)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !mounted {
0000000000000000000000000000000000000000;;			if err := syscall.Mount("tmpfs", l.Root, "tmpfs", 0, ""); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CriuPath returns an option func to configure a LinuxFactory with the
0000000000000000000000000000000000000000;;	// provided criupath
0000000000000000000000000000000000000000;;	func CriuPath(criupath string) func(*LinuxFactory) error {
0000000000000000000000000000000000000000;;		return func(l *LinuxFactory) error {
0000000000000000000000000000000000000000;;			l.CriuPath = criupath
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a linux based container factory based in the root directory and
0000000000000000000000000000000000000000;;	// configures the factory with the provided option funcs.
0000000000000000000000000000000000000000;;	func New(root string, options ...func(*LinuxFactory) error) (Factory, error) {
0000000000000000000000000000000000000000;;		if root != "" {
0000000000000000000000000000000000000000;;			if err := os.MkdirAll(root, 0700); err != nil {
0000000000000000000000000000000000000000;;				return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := &LinuxFactory{
0000000000000000000000000000000000000000;;			Root:      root,
0000000000000000000000000000000000000000;;			InitArgs:  []string{"/proc/self/exe", "init"},
0000000000000000000000000000000000000000;;			Validator: validate.New(),
0000000000000000000000000000000000000000;;			CriuPath:  "criu",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		Cgroupfs(l)
0000000000000000000000000000000000000000;;		for _, opt := range options {
0000000000000000000000000000000000000000;;			if err := opt(l); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinuxFactory implements the default factory interface for linux based systems.
0000000000000000000000000000000000000000;;	type LinuxFactory struct {
0000000000000000000000000000000000000000;;		// Root directory for the factory to store state.
0000000000000000000000000000000000000000;;		Root string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InitArgs are arguments for calling the init responsibilities for spawning
0000000000000000000000000000000000000000;;		// a container.
0000000000000000000000000000000000000000;;		InitArgs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CriuPath is the path to the criu binary used for checkpoint and restore of
0000000000000000000000000000000000000000;;		// containers.
0000000000000000000000000000000000000000;;		CriuPath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validator provides validation to container configurations.
0000000000000000000000000000000000000000;;		Validator validate.Validator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewCgroupsManager returns an initialized cgroups manager for a single container.
0000000000000000000000000000000000000000;;		NewCgroupsManager func(config *configs.Cgroup, paths map[string]string) cgroups.Manager
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) {
0000000000000000000000000000000000000000;;		if l.Root == "" {
0000000000000000000000000000000000000000;;			return nil, newGenericError(fmt.Errorf("invalid root"), ConfigInvalid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := l.validateID(id); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := l.Validator.Validate(config); err != nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, ConfigInvalid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uid, err := config.HostUID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gid, err := config.HostGID()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerRoot := filepath.Join(l.Root, id)
0000000000000000000000000000000000000000;;		if _, err := os.Stat(containerRoot); err == nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(fmt.Errorf("container with id exists: %v", id), IdInUse)
0000000000000000000000000000000000000000;;		} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.MkdirAll(containerRoot, 0711); err != nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := os.Chown(containerRoot, uid, gid); err != nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fifoName := filepath.Join(containerRoot, execFifoFilename)
0000000000000000000000000000000000000000;;		oldMask := syscall.Umask(0000)
0000000000000000000000000000000000000000;;		if err := syscall.Mkfifo(fifoName, 0622); err != nil {
0000000000000000000000000000000000000000;;			syscall.Umask(oldMask)
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syscall.Umask(oldMask)
0000000000000000000000000000000000000000;;		if err := os.Chown(fifoName, uid, gid); err != nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &linuxContainer{
0000000000000000000000000000000000000000;;			id:            id,
0000000000000000000000000000000000000000;;			root:          containerRoot,
0000000000000000000000000000000000000000;;			config:        config,
0000000000000000000000000000000000000000;;			initArgs:      l.InitArgs,
0000000000000000000000000000000000000000;;			criuPath:      l.CriuPath,
0000000000000000000000000000000000000000;;			cgroupManager: l.NewCgroupsManager(config.Cgroups, nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.state = &stoppedState{c: c}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *LinuxFactory) Load(id string) (Container, error) {
0000000000000000000000000000000000000000;;		if l.Root == "" {
0000000000000000000000000000000000000000;;			return nil, newGenericError(fmt.Errorf("invalid root"), ConfigInvalid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		containerRoot := filepath.Join(l.Root, id)
0000000000000000000000000000000000000000;;		state, err := l.loadState(containerRoot, id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := &nonChildProcess{
0000000000000000000000000000000000000000;;			processPid:       state.InitProcessPid,
0000000000000000000000000000000000000000;;			processStartTime: state.InitProcessStartTime,
0000000000000000000000000000000000000000;;			fds:              state.ExternalDescriptors,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &linuxContainer{
0000000000000000000000000000000000000000;;			initProcess:          r,
0000000000000000000000000000000000000000;;			initProcessStartTime: state.InitProcessStartTime,
0000000000000000000000000000000000000000;;			id:                   id,
0000000000000000000000000000000000000000;;			config:               &state.Config,
0000000000000000000000000000000000000000;;			initArgs:             l.InitArgs,
0000000000000000000000000000000000000000;;			criuPath:             l.CriuPath,
0000000000000000000000000000000000000000;;			cgroupManager:        l.NewCgroupsManager(state.Config.Cgroups, state.CgroupPaths),
0000000000000000000000000000000000000000;;			root:                 containerRoot,
0000000000000000000000000000000000000000;;			created:              state.Created,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.state = &loadedState{c: c}
0000000000000000000000000000000000000000;;		if err := c.refreshState(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *LinuxFactory) Type() string {
0000000000000000000000000000000000000000;;		return "libcontainer"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state
0000000000000000000000000000000000000000;;	// This is a low level implementation detail of the reexec and should not be consumed externally
0000000000000000000000000000000000000000;;	func (l *LinuxFactory) StartInitialization() (err error) {
0000000000000000000000000000000000000000;;		var pipefd, rootfd int
0000000000000000000000000000000000000000;;		for _, pair := range []struct {
0000000000000000000000000000000000000000;;			k string
0000000000000000000000000000000000000000;;			v *int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"_LIBCONTAINER_INITPIPE", &pipefd},
0000000000000000000000000000000000000000;;			{"_LIBCONTAINER_STATEDIR", &rootfd},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s := os.Getenv(pair.k)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i, err := strconv.Atoi(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to convert %s=%s to int", pair.k, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*pair.v = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			pipe = os.NewFile(uintptr(pipefd), "pipe")
0000000000000000000000000000000000000000;;			it   = initType(os.Getenv("_LIBCONTAINER_INITTYPE"))
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// clear the current process's environment to clean any libcontainer
0000000000000000000000000000000000000000;;		// specific env vars.
0000000000000000000000000000000000000000;;		os.Clearenv()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var i initer
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// We have an error during the initialization of the container's init,
0000000000000000000000000000000000000000;;			// send it back to the parent process in the form of an initError.
0000000000000000000000000000000000000000;;			// If container's init successed, syscall.Exec will not return, hence
0000000000000000000000000000000000000000;;			// this defer function will never be called.
0000000000000000000000000000000000000000;;			if _, ok := i.(*linuxStandardInit); ok {
0000000000000000000000000000000000000000;;				//  Synchronisation only necessary for standard init.
0000000000000000000000000000000000000000;;				if werr := utils.WriteJSON(pipe, syncT{procError}); werr != nil {
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if werr := utils.WriteJSON(pipe, newSystemError(err)); werr != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ensure that this pipe is always closed
0000000000000000000000000000000000000000;;			pipe.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if e := recover(); e != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("panic from initialization: %v, %v", e, string(debug.Stack()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		i, err = newContainerInit(it, pipe, rootfd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i.Init()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *LinuxFactory) loadState(root, id string) (*State, error) {
0000000000000000000000000000000000000000;;		f, err := os.Open(filepath.Join(root, stateFilename))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil, newGenericError(fmt.Errorf("container %q does not exist", id), ContainerNotExists)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		var state *State
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(f).Decode(&state); err != nil {
0000000000000000000000000000000000000000;;			return nil, newGenericError(err, SystemError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *LinuxFactory) validateID(id string) error {
0000000000000000000000000000000000000000;;		if !idRegex.MatchString(id) {
0000000000000000000000000000000000000000;;			return newGenericError(fmt.Errorf("invalid id format: %v", id), InvalidIdFormat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(id) > maxIdLen {
0000000000000000000000000000000000000000;;			return newGenericError(fmt.Errorf("invalid id format: %v", id), InvalidIdFormat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
