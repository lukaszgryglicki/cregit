0000000000000000000000000000000000000000;;	package configs
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/configs/config.go[Godeps/_workspace/src/github.com/docker/libcontainer/configs/config.go][vendor/github.com/opencontainers/runc/libcontainer/configs/config.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Sirupsen/logrus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Rlimit struct {
0000000000000000000000000000000000000000;;		Type int    `json:"type"`
0000000000000000000000000000000000000000;;		Hard uint64 `json:"hard"`
0000000000000000000000000000000000000000;;		Soft uint64 `json:"soft"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IDMap represents UID/GID Mappings for User Namespaces.
0000000000000000000000000000000000000000;;	type IDMap struct {
0000000000000000000000000000000000000000;;		ContainerID int `json:"container_id"`
0000000000000000000000000000000000000000;;		HostID      int `json:"host_id"`
0000000000000000000000000000000000000000;;		Size        int `json:"size"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seccomp represents syscall restrictions
0000000000000000000000000000000000000000;;	// By default, only the native architecture of the kernel is allowed to be used
0000000000000000000000000000000000000000;;	// for syscalls. Additional architectures can be added by specifying them in
0000000000000000000000000000000000000000;;	// Architectures.
0000000000000000000000000000000000000000;;	type Seccomp struct {
0000000000000000000000000000000000000000;;		DefaultAction Action     `json:"default_action"`
0000000000000000000000000000000000000000;;		Architectures []string   `json:"architectures"`
0000000000000000000000000000000000000000;;		Syscalls      []*Syscall `json:"syscalls"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Action is taken upon rule match in Seccomp
0000000000000000000000000000000000000000;;	type Action int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Kill Action = iota + 1
0000000000000000000000000000000000000000;;		Errno
0000000000000000000000000000000000000000;;		Trap
0000000000000000000000000000000000000000;;		Allow
0000000000000000000000000000000000000000;;		Trace
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Operator is a comparison operator to be used when matching syscall arguments in Seccomp
0000000000000000000000000000000000000000;;	type Operator int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EqualTo Operator = iota + 1
0000000000000000000000000000000000000000;;		NotEqualTo
0000000000000000000000000000000000000000;;		GreaterThan
0000000000000000000000000000000000000000;;		GreaterThanOrEqualTo
0000000000000000000000000000000000000000;;		LessThan
0000000000000000000000000000000000000000;;		LessThanOrEqualTo
0000000000000000000000000000000000000000;;		MaskEqualTo
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Arg is a rule to match a specific syscall argument in Seccomp
0000000000000000000000000000000000000000;;	type Arg struct {
0000000000000000000000000000000000000000;;		Index    uint     `json:"index"`
0000000000000000000000000000000000000000;;		Value    uint64   `json:"value"`
0000000000000000000000000000000000000000;;		ValueTwo uint64   `json:"value_two"`
0000000000000000000000000000000000000000;;		Op       Operator `json:"op"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Syscall is a rule to match a syscall in Seccomp
0000000000000000000000000000000000000000;;	type Syscall struct {
0000000000000000000000000000000000000000;;		Name   string `json:"name"`
0000000000000000000000000000000000000000;;		Action Action `json:"action"`
0000000000000000000000000000000000000000;;		Args   []*Arg `json:"args"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO Windows. Many of these fields should be factored out into those parts
0000000000000000000000000000000000000000;;	// which are common across platforms, and those which are platform specific.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config defines configuration options for executing a process inside a contained environment.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// NoPivotRoot will use MS_MOVE and a chroot to jail the process into the container's rootfs
0000000000000000000000000000000000000000;;		// This is a common option when the container is running in ramdisk
0000000000000000000000000000000000000000;;		NoPivotRoot bool `json:"no_pivot_root"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ParentDeathSignal specifies the signal that is sent to the container's process in the case
0000000000000000000000000000000000000000;;		// that the parent process dies.
0000000000000000000000000000000000000000;;		ParentDeathSignal int `json:"parent_death_signal"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PivotDir allows a custom directory inside the container's root filesystem to be used as pivot, when NoPivotRoot is not set.
0000000000000000000000000000000000000000;;		// When a custom PivotDir not set, a temporary dir inside the root filesystem will be used. The pivot dir needs to be writeable.
0000000000000000000000000000000000000000;;		// This is required when using read only root filesystems. In these cases, a read/writeable path can be (bind) mounted somewhere inside the root filesystem to act as pivot.
0000000000000000000000000000000000000000;;		PivotDir string `json:"pivot_dir"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path to a directory containing the container's root filesystem.
0000000000000000000000000000000000000000;;		Rootfs string `json:"rootfs"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Readonlyfs will remount the container's rootfs as readonly where only externally mounted
0000000000000000000000000000000000000000;;		// bind mounts are writtable.
0000000000000000000000000000000000000000;;		Readonlyfs bool `json:"readonlyfs"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specifies the mount propagation flags to be applied to /.
0000000000000000000000000000000000000000;;		RootPropagation int `json:"rootPropagation"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mounts specify additional source and destination paths that will be mounted inside the container's
0000000000000000000000000000000000000000;;		// rootfs and mount namespace if specified
0000000000000000000000000000000000000000;;		Mounts []*Mount `json:"mounts"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The device nodes that should be automatically created within the container upon container start.  Note, make sure that the node is marked as allowed in the cgroup as well!
0000000000000000000000000000000000000000;;		Devices []*Device `json:"devices"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		MountLabel string `json:"mount_label"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hostname optionally sets the container's hostname if provided
0000000000000000000000000000000000000000;;		Hostname string `json:"hostname"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Namespaces specifies the container's namespaces that it should setup when cloning the init process
0000000000000000000000000000000000000000;;		// If a namespace is not provided that namespace is shared from the container's parent process
0000000000000000000000000000000000000000;;		Namespaces Namespaces `json:"namespaces"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Capabilities specify the capabilities to keep when executing the process inside the container
0000000000000000000000000000000000000000;;		// All capbilities not specified will be dropped from the processes capability mask
0000000000000000000000000000000000000000;;		Capabilities []string `json:"capabilities"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Networks specifies the container's network setup to be created
0000000000000000000000000000000000000000;;		Networks []*Network `json:"networks"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Routes can be specified to create entries in the route table as the container is started
0000000000000000000000000000000000000000;;		Routes []*Route `json:"routes"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cgroups specifies specific cgroup settings for the various subsystems that the container is
0000000000000000000000000000000000000000;;		// placed into to limit the resources the container has available
0000000000000000000000000000000000000000;;		Cgroups *Cgroup `json:"cgroups"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AppArmorProfile specifies the profile to apply to the process running in the container and is
0000000000000000000000000000000000000000;;		// change at the time the process is execed
0000000000000000000000000000000000000000;;		AppArmorProfile string `json:"apparmor_profile,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ProcessLabel specifies the label to apply to the process running in the container.  It is
0000000000000000000000000000000000000000;;		// commonly used by selinux
0000000000000000000000000000000000000000;;		ProcessLabel string `json:"process_label,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rlimits specifies the resource limits, such as max open files, to set in the container
0000000000000000000000000000000000000000;;		// If Rlimits are not set, the container will inherit rlimits from the parent process
0000000000000000000000000000000000000000;;		Rlimits []Rlimit `json:"rlimits,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OomScoreAdj specifies the adjustment to be made by the kernel when calculating oom scores
0000000000000000000000000000000000000000;;		// for a process. Valid values are between the range [-1000, '1000'], where processes with
0000000000000000000000000000000000000000;;		// higher scores are preferred for being killed.
0000000000000000000000000000000000000000;;		// More information about kernel oom score calculation here: https://lwn.net/Articles/317814/
0000000000000000000000000000000000000000;;		OomScoreAdj int `json:"oom_score_adj"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UidMappings is an array of User ID mappings for User Namespaces
0000000000000000000000000000000000000000;;		UidMappings []IDMap `json:"uid_mappings"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GidMappings is an array of Group ID mappings for User Namespaces
0000000000000000000000000000000000000000;;		GidMappings []IDMap `json:"gid_mappings"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaskPaths specifies paths within the container's rootfs to mask over with a bind
0000000000000000000000000000000000000000;;		// mount pointing to /dev/null as to prevent reads of the file.
0000000000000000000000000000000000000000;;		MaskPaths []string `json:"mask_paths"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadonlyPaths specifies paths within the container's rootfs to remount as read-only
0000000000000000000000000000000000000000;;		// so that these files prevent any writes.
0000000000000000000000000000000000000000;;		ReadonlyPaths []string `json:"readonly_paths"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sysctl is a map of properties and their values. It is the equivalent of using
0000000000000000000000000000000000000000;;		// sysctl -w my.property.name value in Linux.
0000000000000000000000000000000000000000;;		Sysctl map[string]string `json:"sysctl"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Seccomp allows actions to be taken whenever a syscall is made within the container.
0000000000000000000000000000000000000000;;		// A number of rules are given, each having an action to be taken if a syscall matches it.
0000000000000000000000000000000000000000;;		// A default action to be taken if no rules match is also given.
0000000000000000000000000000000000000000;;		Seccomp *Seccomp `json:"seccomp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoNewPrivileges controls whether processes in the container can gain additional privileges.
0000000000000000000000000000000000000000;;		NoNewPrivileges bool `json:"no_new_privileges,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hooks are a collection of actions to perform at various container lifecycle events.
0000000000000000000000000000000000000000;;		// CommandHooks are serialized to JSON, but other hooks are not.
0000000000000000000000000000000000000000;;		Hooks *Hooks
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Version is the version of opencontainer specification that is supported.
0000000000000000000000000000000000000000;;		Version string `json:"version"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Labels are user defined metadata that is stored in the config and populated on the state
0000000000000000000000000000000000000000;;		Labels []string `json:"labels"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoNewKeyring will not allocated a new session keyring for the container.  It will use the
0000000000000000000000000000000000000000;;		// callers keyring in this case.
0000000000000000000000000000000000000000;;		NoNewKeyring bool `json:"no_new_keyring"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Hooks struct {
0000000000000000000000000000000000000000;;		// Prestart commands are executed after the container namespaces are created,
0000000000000000000000000000000000000000;;		// but before the user supplied command is executed from init.
0000000000000000000000000000000000000000;;		Prestart []Hook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Poststart commands are executed after the container init process starts.
0000000000000000000000000000000000000000;;		Poststart []Hook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Poststop commands are executed after the container init process exits.
0000000000000000000000000000000000000000;;		Poststop []Hook
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hooks *Hooks) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var state struct {
0000000000000000000000000000000000000000;;			Prestart  []CommandHook
0000000000000000000000000000000000000000;;			Poststart []CommandHook
0000000000000000000000000000000000000000;;			Poststop  []CommandHook
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &state); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deserialize := func(shooks []CommandHook) (hooks []Hook) {
0000000000000000000000000000000000000000;;			for _, shook := range shooks {
0000000000000000000000000000000000000000;;				hooks = append(hooks, shook)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return hooks
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hooks.Prestart = deserialize(state.Prestart)
0000000000000000000000000000000000000000;;		hooks.Poststart = deserialize(state.Poststart)
0000000000000000000000000000000000000000;;		hooks.Poststop = deserialize(state.Poststop)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hooks Hooks) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		serialize := func(hooks []Hook) (serializableHooks []CommandHook) {
0000000000000000000000000000000000000000;;			for _, hook := range hooks {
0000000000000000000000000000000000000000;;				switch chook := hook.(type) {
0000000000000000000000000000000000000000;;				case CommandHook:
0000000000000000000000000000000000000000;;					serializableHooks = append(serializableHooks, chook)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					logrus.Warnf("cannot serialize hook of type %T, skipping", hook)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return serializableHooks
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(map[string]interface{}{
0000000000000000000000000000000000000000;;			"prestart":  serialize(hooks.Prestart),
0000000000000000000000000000000000000000;;			"poststart": serialize(hooks.Poststart),
0000000000000000000000000000000000000000;;			"poststop":  serialize(hooks.Poststop),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HookState is the payload provided to a hook on execution.
0000000000000000000000000000000000000000;;	type HookState struct {
0000000000000000000000000000000000000000;;		Version    string `json:"ociVersion"`
0000000000000000000000000000000000000000;;		ID         string `json:"id"`
0000000000000000000000000000000000000000;;		Pid        int    `json:"pid"`
0000000000000000000000000000000000000000;;		Root       string `json:"root"`
0000000000000000000000000000000000000000;;		BundlePath string `json:"bundlePath"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Hook interface {
0000000000000000000000000000000000000000;;		// Run executes the hook with the provided state.
0000000000000000000000000000000000000000;;		Run(HookState) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFunctionHook will call the provided function when the hook is run.
0000000000000000000000000000000000000000;;	func NewFunctionHook(f func(HookState) error) FuncHook {
0000000000000000000000000000000000000000;;		return FuncHook{
0000000000000000000000000000000000000000;;			run: f,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FuncHook struct {
0000000000000000000000000000000000000000;;		run func(HookState) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f FuncHook) Run(s HookState) error {
0000000000000000000000000000000000000000;;		return f.run(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Command struct {
0000000000000000000000000000000000000000;;		Path    string         `json:"path"`
0000000000000000000000000000000000000000;;		Args    []string       `json:"args"`
0000000000000000000000000000000000000000;;		Env     []string       `json:"env"`
0000000000000000000000000000000000000000;;		Dir     string         `json:"dir"`
0000000000000000000000000000000000000000;;		Timeout *time.Duration `json:"timeout"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCommandHook will execute the provided command when the hook is run.
0000000000000000000000000000000000000000;;	func NewCommandHook(cmd Command) CommandHook {
0000000000000000000000000000000000000000;;		return CommandHook{
0000000000000000000000000000000000000000;;			Command: cmd,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CommandHook struct {
0000000000000000000000000000000000000000;;		Command
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Command) Run(s HookState) error {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var stdout, stderr bytes.Buffer
0000000000000000000000000000000000000000;;		cmd := exec.Cmd{
0000000000000000000000000000000000000000;;			Path:   c.Path,
0000000000000000000000000000000000000000;;			Args:   c.Args,
0000000000000000000000000000000000000000;;			Env:    c.Env,
0000000000000000000000000000000000000000;;			Stdin:  bytes.NewReader(b),
0000000000000000000000000000000000000000;;			Stdout: &stdout,
0000000000000000000000000000000000000000;;			Stderr: &stderr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cmd.Start(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errC := make(chan error, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			err := cmd.Wait()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("error running hook: %v, stdout: %s, stderr: %s", err, stdout.String(), stderr.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errC <- err
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var timerCh <-chan time.Time
0000000000000000000000000000000000000000;;		if c.Timeout != nil {
0000000000000000000000000000000000000000;;			timer := time.NewTimer(*c.Timeout)
0000000000000000000000000000000000000000;;			defer timer.Stop()
0000000000000000000000000000000000000000;;			timerCh = timer.C
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err := <-errC:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		case <-timerCh:
0000000000000000000000000000000000000000;;			cmd.Process.Kill()
0000000000000000000000000000000000000000;;			cmd.Wait()
0000000000000000000000000000000000000000;;			return fmt.Errorf("hook ran past specified timeout of %.1fs", c.Timeout.Seconds())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
