0000000000000000000000000000000000000000;;	// +build linux freebsd
d130243057bea8ebcfa3fdfcb8c3aeaf4ca246bf;Godeps/_workspace/src/github.com/docker/libcontainer/configs/namespaces_unix.go[Godeps/_workspace/src/github.com/docker/libcontainer/configs/namespaces_unix.go][vendor/github.com/opencontainers/runc/libcontainer/configs/namespaces_unix.go];	
0000000000000000000000000000000000000000;;	package configs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NEWNET  NamespaceType = "NEWNET"
0000000000000000000000000000000000000000;;		NEWPID  NamespaceType = "NEWPID"
0000000000000000000000000000000000000000;;		NEWNS   NamespaceType = "NEWNS"
0000000000000000000000000000000000000000;;		NEWUTS  NamespaceType = "NEWUTS"
0000000000000000000000000000000000000000;;		NEWIPC  NamespaceType = "NEWIPC"
0000000000000000000000000000000000000000;;		NEWUSER NamespaceType = "NEWUSER"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		nsLock              sync.Mutex
0000000000000000000000000000000000000000;;		supportedNamespaces = make(map[NamespaceType]bool)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nsToFile converts the namespace type to its filename
0000000000000000000000000000000000000000;;	func nsToFile(ns NamespaceType) string {
0000000000000000000000000000000000000000;;		switch ns {
0000000000000000000000000000000000000000;;		case NEWNET:
0000000000000000000000000000000000000000;;			return "net"
0000000000000000000000000000000000000000;;		case NEWNS:
0000000000000000000000000000000000000000;;			return "mnt"
0000000000000000000000000000000000000000;;		case NEWPID:
0000000000000000000000000000000000000000;;			return "pid"
0000000000000000000000000000000000000000;;		case NEWIPC:
0000000000000000000000000000000000000000;;			return "ipc"
0000000000000000000000000000000000000000;;		case NEWUSER:
0000000000000000000000000000000000000000;;			return "user"
0000000000000000000000000000000000000000;;		case NEWUTS:
0000000000000000000000000000000000000000;;			return "uts"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNamespaceSupported returns whether a namespace is available or
0000000000000000000000000000000000000000;;	// not
0000000000000000000000000000000000000000;;	func IsNamespaceSupported(ns NamespaceType) bool {
0000000000000000000000000000000000000000;;		nsLock.Lock()
0000000000000000000000000000000000000000;;		defer nsLock.Unlock()
0000000000000000000000000000000000000000;;		supported, ok := supportedNamespaces[ns]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return supported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nsFile := nsToFile(ns)
0000000000000000000000000000000000000000;;		// if the namespace type is unknown, just return false
0000000000000000000000000000000000000000;;		if nsFile == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := os.Stat(fmt.Sprintf("/proc/self/ns/%s", nsFile))
0000000000000000000000000000000000000000;;		// a namespace is supported if it exists and we have permissions to read it
0000000000000000000000000000000000000000;;		supported = err == nil
0000000000000000000000000000000000000000;;		supportedNamespaces[ns] = supported
0000000000000000000000000000000000000000;;		return supported
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NamespaceTypes() []NamespaceType {
0000000000000000000000000000000000000000;;		return []NamespaceType{
0000000000000000000000000000000000000000;;			NEWNET,
0000000000000000000000000000000000000000;;			NEWPID,
0000000000000000000000000000000000000000;;			NEWNS,
0000000000000000000000000000000000000000;;			NEWUTS,
0000000000000000000000000000000000000000;;			NEWIPC,
0000000000000000000000000000000000000000;;			NEWUSER,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namespace defines configuration for each namespace.  It specifies an
0000000000000000000000000000000000000000;;	// alternate path that is able to be joined via setns.
0000000000000000000000000000000000000000;;	type Namespace struct {
0000000000000000000000000000000000000000;;		Type NamespaceType `json:"type"`
0000000000000000000000000000000000000000;;		Path string        `json:"path"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Namespace) GetPath(pid int) string {
0000000000000000000000000000000000000000;;		if n.Path != "" {
0000000000000000000000000000000000000000;;			return n.Path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("/proc/%d/ns/%s", pid, nsToFile(n.Type))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Namespaces) Remove(t NamespaceType) bool {
0000000000000000000000000000000000000000;;		i := n.index(t)
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*n = append((*n)[:i], (*n)[i+1:]...)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Namespaces) Add(t NamespaceType, path string) {
0000000000000000000000000000000000000000;;		i := n.index(t)
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			*n = append(*n, Namespace{Type: t, Path: path})
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		(*n)[i].Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Namespaces) index(t NamespaceType) int {
0000000000000000000000000000000000000000;;		for i, ns := range *n {
0000000000000000000000000000000000000000;;			if ns.Type == t {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Namespaces) Contains(t NamespaceType) bool {
0000000000000000000000000000000000000000;;		return n.index(t) != -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Namespaces) PathOf(t NamespaceType) string {
0000000000000000000000000000000000000000;;		i := n.index(t)
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*n)[i].Path
0000000000000000000000000000000000000000;;	}
