0000000000000000000000000000000000000000;;	package validate
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/configs/validate/config.go[Godeps/_workspace/src/github.com/docker/libcontainer/configs/validate/config.go][vendor/github.com/opencontainers/runc/libcontainer/configs/validate/validator.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/selinux"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Validator interface {
0000000000000000000000000000000000000000;;		Validate(*configs.Config) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New() Validator {
0000000000000000000000000000000000000000;;		return &ConfigValidator{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConfigValidator struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *ConfigValidator) Validate(config *configs.Config) error {
0000000000000000000000000000000000000000;;		if err := v.rootfs(config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := v.network(config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := v.hostname(config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := v.security(config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := v.usernamespace(config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := v.sysctl(config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rootfs validates if the rootfs is an absolute path and is not a symlink
0000000000000000000000000000000000000000;;	// to the container's root filesystem.
0000000000000000000000000000000000000000;;	func (v *ConfigValidator) rootfs(config *configs.Config) error {
0000000000000000000000000000000000000000;;		cleaned, err := filepath.Abs(config.Rootfs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cleaned, err = filepath.EvalSymlinks(cleaned); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if filepath.Clean(config.Rootfs) != cleaned {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s is not an absolute path or is a symlink", config.Rootfs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *ConfigValidator) network(config *configs.Config) error {
0000000000000000000000000000000000000000;;		if !config.Namespaces.Contains(configs.NEWNET) {
0000000000000000000000000000000000000000;;			if len(config.Networks) > 0 || len(config.Routes) > 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to apply network settings without a private NET namespace")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *ConfigValidator) hostname(config *configs.Config) error {
0000000000000000000000000000000000000000;;		if config.Hostname != "" && !config.Namespaces.Contains(configs.NEWUTS) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to set hostname without a private UTS namespace")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *ConfigValidator) security(config *configs.Config) error {
0000000000000000000000000000000000000000;;		// restrict sys without mount namespace
0000000000000000000000000000000000000000;;		if (len(config.MaskPaths) > 0 || len(config.ReadonlyPaths) > 0) &&
0000000000000000000000000000000000000000;;			!config.Namespaces.Contains(configs.NEWNS) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to restrict sys entries without a private MNT namespace")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.ProcessLabel != "" && !selinux.SelinuxEnabled() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("selinux label is specified in config, but selinux is disabled or not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *ConfigValidator) usernamespace(config *configs.Config) error {
0000000000000000000000000000000000000000;;		if config.Namespaces.Contains(configs.NEWUSER) {
0000000000000000000000000000000000000000;;			if _, err := os.Stat("/proc/self/ns/user"); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("USER namespaces aren't enabled in the kernel")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if config.UidMappings != nil || config.GidMappings != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("User namespace mappings specified, but USER namespace isn't enabled in the config")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sysctl validates that the specified sysctl keys are valid or not.
0000000000000000000000000000000000000000;;	// /proc/sys isn't completely namespaced and depending on which namespaces
0000000000000000000000000000000000000000;;	// are specified, a subset of sysctls are permitted.
0000000000000000000000000000000000000000;;	func (v *ConfigValidator) sysctl(config *configs.Config) error {
0000000000000000000000000000000000000000;;		validSysctlMap := map[string]bool{
0000000000000000000000000000000000000000;;			"kernel.msgmax":          true,
0000000000000000000000000000000000000000;;			"kernel.msgmnb":          true,
0000000000000000000000000000000000000000;;			"kernel.msgmni":          true,
0000000000000000000000000000000000000000;;			"kernel.sem":             true,
0000000000000000000000000000000000000000;;			"kernel.shmall":          true,
0000000000000000000000000000000000000000;;			"kernel.shmmax":          true,
0000000000000000000000000000000000000000;;			"kernel.shmmni":          true,
0000000000000000000000000000000000000000;;			"kernel.shm_rmid_forced": true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s := range config.Sysctl {
0000000000000000000000000000000000000000;;			if validSysctlMap[s] || strings.HasPrefix(s, "fs.mqueue.") {
0000000000000000000000000000000000000000;;				if config.Namespaces.Contains(configs.NEWIPC) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return fmt.Errorf("sysctl %q is not allowed in the hosts ipc namespace", s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(s, "net.") {
0000000000000000000000000000000000000000;;				if config.Namespaces.Contains(configs.NEWNET) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return fmt.Errorf("sysctl %q is not allowed in the hosts network namespace", s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("sysctl %q is not in a separate kernel namespace", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
