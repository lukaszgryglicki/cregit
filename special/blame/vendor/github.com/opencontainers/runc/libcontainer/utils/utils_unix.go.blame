0000000000000000000000000000000000000000;;	// +build !windows
a15085f256eebbe1e0d714ff4882a7611c12d312;Godeps/_workspace/src/github.com/opencontainers/runc/libcontainer/utils/utils_unix.go[Godeps/_workspace/src/github.com/opencontainers/runc/libcontainer/utils/utils_unix.go][vendor/github.com/opencontainers/runc/libcontainer/utils/utils_unix.go];	
0000000000000000000000000000000000000000;;	package utils
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CloseExecFrom(minFd int) error {
0000000000000000000000000000000000000000;;		fdList, err := ioutil.ReadDir("/proc/self/fd")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, fi := range fdList {
0000000000000000000000000000000000000000;;			fd, err := strconv.Atoi(fi.Name())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// ignore non-numeric file names
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fd < minFd {
0000000000000000000000000000000000000000;;				// ignore descriptors lower than our specified minimum
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// intentionally ignore errors from syscall.CloseOnExec
0000000000000000000000000000000000000000;;			syscall.CloseOnExec(fd)
0000000000000000000000000000000000000000;;			// the cases where this might fail are basically file descriptors that have already been closed (including and especially the one that was created when ioutil.ReadDir did the "opendir" syscall)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
