0000000000000000000000000000000000000000;;	package utils
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/utils/utils.go[Godeps/_workspace/src/github.com/docker/libcontainer/utils/utils.go][vendor/github.com/opencontainers/runc/libcontainer/utils/utils.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		exitSignalOffset = 128
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateRandomName returns a new name joined with a prefix.  This size
0000000000000000000000000000000000000000;;	// specified is used to truncate the randomly generated value
0000000000000000000000000000000000000000;;	func GenerateRandomName(prefix string, size int) (string, error) {
0000000000000000000000000000000000000000;;		id := make([]byte, 32)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand.Reader, id); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if size > 64 {
0000000000000000000000000000000000000000;;			size = 64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return prefix + hex.EncodeToString(id)[:size], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveRootfs ensures that the current working directory is
0000000000000000000000000000000000000000;;	// not a symlink and returns the absolute path to the rootfs
0000000000000000000000000000000000000000;;	func ResolveRootfs(uncleanRootfs string) (string, error) {
0000000000000000000000000000000000000000;;		rootfs, err := filepath.Abs(uncleanRootfs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.EvalSymlinks(rootfs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExitStatus returns the correct exit status for a process based on if it
0000000000000000000000000000000000000000;;	// was signaled or exited cleanly
0000000000000000000000000000000000000000;;	func ExitStatus(status syscall.WaitStatus) int {
0000000000000000000000000000000000000000;;		if status.Signaled() {
0000000000000000000000000000000000000000;;			return exitSignalOffset + int(status.Signal())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return status.ExitStatus()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteJSON writes the provided struct v to w using standard json marshaling
0000000000000000000000000000000000000000;;	func WriteJSON(w io.Writer, v interface{}) error {
0000000000000000000000000000000000000000;;		data, err := json.Marshal(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = w.Write(data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CleanPath makes a path safe for use with filepath.Join. This is done by not
0000000000000000000000000000000000000000;;	// only cleaning the path, but also (if the path is relative) adding a leading
0000000000000000000000000000000000000000;;	// '/' and cleaning it (then removing the leading '/'). This ensures that a
0000000000000000000000000000000000000000;;	// path resulting from prepending another path will always resolve to lexically
0000000000000000000000000000000000000000;;	// be a subdirectory of the prefixed path. This is all done lexically, so paths
0000000000000000000000000000000000000000;;	// that include symlinks won't be safe as a result of using CleanPath.
0000000000000000000000000000000000000000;;	func CleanPath(path string) string {
0000000000000000000000000000000000000000;;		// Deal with empty strings nicely.
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that all paths are cleaned (especially problematic ones like
0000000000000000000000000000000000000000;;		// "/../../../../../" which can cause lots of issues).
0000000000000000000000000000000000000000;;		path = filepath.Clean(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the path isn't absolute, we need to do more processing to fix paths
0000000000000000000000000000000000000000;;		// such as "../../../../<etc>/some/path". We also shouldn't convert absolute
0000000000000000000000000000000000000000;;		// paths to relative ones.
0000000000000000000000000000000000000000;;		if !filepath.IsAbs(path) {
0000000000000000000000000000000000000000;;			path = filepath.Clean(string(os.PathSeparator) + path)
0000000000000000000000000000000000000000;;			// This can't fail, as (by definition) all paths are relative to root.
0000000000000000000000000000000000000000;;			path, _ = filepath.Rel(string(os.PathSeparator), path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clean the path again for good measure.
0000000000000000000000000000000000000000;;		return filepath.Clean(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SearchLabels searches a list of key-value pairs for the provided key and
0000000000000000000000000000000000000000;;	// returns the corresponding value. The pairs must be separated with '='.
0000000000000000000000000000000000000000;;	func SearchLabels(labels []string, query string) string {
0000000000000000000000000000000000000000;;		for _, l := range labels {
0000000000000000000000000000000000000000;;			parts := strings.SplitN(l, "=", 2)
0000000000000000000000000000000000000000;;			if len(parts) < 2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parts[0] == query {
0000000000000000000000000000000000000000;;				return parts[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Annotations returns the bundle path and user defined annotations from the
0000000000000000000000000000000000000000;;	// libcontainer state.  We need to remove the bundle because that is a label
0000000000000000000000000000000000000000;;	// added by libcontainer.
0000000000000000000000000000000000000000;;	func Annotations(labels []string) (bundle string, userAnnotations map[string]string) {
0000000000000000000000000000000000000000;;		userAnnotations = make(map[string]string)
0000000000000000000000000000000000000000;;		for _, l := range labels {
0000000000000000000000000000000000000000;;			parts := strings.SplitN(l, "=", 2)
0000000000000000000000000000000000000000;;			if len(parts) < 2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parts[0] == "bundle" {
0000000000000000000000000000000000000000;;				bundle = parts[1]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				userAnnotations[parts[0]] = parts[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetIntSize() int {
0000000000000000000000000000000000000000;;		return int(unsafe.Sizeof(1))
0000000000000000000000000000000000000000;;	}
