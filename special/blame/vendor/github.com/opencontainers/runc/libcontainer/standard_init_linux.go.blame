0000000000000000000000000000000000000000;;	// +build linux
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/docker/libcontainer/standard_init_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/standard_init_linux.go][vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/apparmor"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/keys"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/label"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/seccomp"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/system"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type linuxStandardInit struct {
0000000000000000000000000000000000000000;;		pipe       io.ReadWriteCloser
0000000000000000000000000000000000000000;;		parentPid  int
0000000000000000000000000000000000000000;;		stateDirFD int
0000000000000000000000000000000000000000;;		config     *initConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *linuxStandardInit) getSessionRingParams() (string, uint32, uint32) {
0000000000000000000000000000000000000000;;		var newperms uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.config.Config.Namespaces.Contains(configs.NEWUSER) {
0000000000000000000000000000000000000000;;			// with user ns we need 'other' search permissions
0000000000000000000000000000000000000000;;			newperms = 0x8
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// without user ns we need 'UID' search permissions
0000000000000000000000000000000000000000;;			newperms = 0x80000
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a unique per session container name that we can
0000000000000000000000000000000000000000;;		// join in setns; however, other containers can also join it
0000000000000000000000000000000000000000;;		return fmt.Sprintf("_ses.%s", l.config.ContainerId), 0xffffffff, newperms
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PR_SET_NO_NEW_PRIVS isn't exposed in Golang so we define it ourselves copying the value
0000000000000000000000000000000000000000;;	// the kernel
0000000000000000000000000000000000000000;;	const PR_SET_NO_NEW_PRIVS = 0x26
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *linuxStandardInit) Init() error {
0000000000000000000000000000000000000000;;		if !l.config.Config.NoNewKeyring {
0000000000000000000000000000000000000000;;			ringname, keepperms, newperms := l.getSessionRingParams()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// do not inherit the parent's session keyring
0000000000000000000000000000000000000000;;			sessKeyId, err := keys.JoinSessionKeyring(ringname)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// make session keyring searcheable
0000000000000000000000000000000000000000;;			if err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var console *linuxConsole
0000000000000000000000000000000000000000;;		if l.config.Console != "" {
0000000000000000000000000000000000000000;;			console = newConsoleFromPath(l.config.Console)
0000000000000000000000000000000000000000;;			if err := console.dupStdio(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if console != nil {
0000000000000000000000000000000000000000;;			if err := system.Setctty(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := setupNetwork(l.config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := setupRoute(l.config.Config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		label.Init()
0000000000000000000000000000000000000000;;		// InitializeMountNamespace() can be executed only for a new mount namespace
0000000000000000000000000000000000000000;;		if l.config.Config.Namespaces.Contains(configs.NEWNS) {
0000000000000000000000000000000000000000;;			if err := setupRootfs(l.config.Config, console, l.pipe); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hostname := l.config.Config.Hostname; hostname != "" {
0000000000000000000000000000000000000000;;			if err := syscall.Sethostname([]byte(hostname)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := label.SetProcessLabel(l.config.ProcessLabel); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range l.config.Config.Sysctl {
0000000000000000000000000000000000000000;;			if err := writeSystemProperty(key, value); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, path := range l.config.Config.ReadonlyPaths {
0000000000000000000000000000000000000000;;			if err := remountReadonly(path); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, path := range l.config.Config.MaskPaths {
0000000000000000000000000000000000000000;;			if err := maskPath(path); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pdeath, err := system.GetParentDeathSignal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.config.NoNewPrivileges {
0000000000000000000000000000000000000000;;			if err := system.Prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Tell our parent that we're ready to Execv. This must be done before the
0000000000000000000000000000000000000000;;		// Seccomp rules have been applied, because we need to be able to read and
0000000000000000000000000000000000000000;;		// write to a socket.
0000000000000000000000000000000000000000;;		if err := syncParentReady(l.pipe); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Without NoNewPrivileges seccomp is a privileged operation, so we need to
0000000000000000000000000000000000000000;;		// do this before dropping capabilities; otherwise do it as late as possible
0000000000000000000000000000000000000000;;		// just before execve so as few syscalls take place after it as possible.
0000000000000000000000000000000000000000;;		if l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {
0000000000000000000000000000000000000000;;			if err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := finalizeNamespace(l.config); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// finalizeNamespace can change user/group which clears the parent death
0000000000000000000000000000000000000000;;		// signal, so we restore it here.
0000000000000000000000000000000000000000;;		if err := pdeath.Restore(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// compare the parent from the initial start of the init process and make sure that it did not change.
0000000000000000000000000000000000000000;;		// if the parent changes that means it died and we were reparented to something else so we should
0000000000000000000000000000000000000000;;		// just kill ourself and not cause problems for someone else.
0000000000000000000000000000000000000000;;		if syscall.Getppid() != l.parentPid {
0000000000000000000000000000000000000000;;			return syscall.Kill(syscall.Getpid(), syscall.SIGKILL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check for the arg before waiting to make sure it exists and it is returned
0000000000000000000000000000000000000000;;		// as a create time error.
0000000000000000000000000000000000000000;;		name, err := exec.LookPath(l.config.Args[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// close the pipe to signal that we have completed our init.
0000000000000000000000000000000000000000;;		l.pipe.Close()
0000000000000000000000000000000000000000;;		// wait for the fifo to be opened on the other side before
0000000000000000000000000000000000000000;;		// exec'ing the users process.
0000000000000000000000000000000000000000;;		fd, err := syscall.Openat(l.stateDirFD, execFifoFilename, os.O_WRONLY|syscall.O_CLOEXEC, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "openat exec fifo")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := syscall.Write(fd, []byte("0")); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "write 0 exec fifo")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {
0000000000000000000000000000000000000000;;			if err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {
0000000000000000000000000000000000000000;;				return newSystemErrorWithCause(err, "init seccomp")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.Exec(name, l.config.Args[0:], os.Environ()); err != nil {
0000000000000000000000000000000000000000;;			return newSystemErrorWithCause(err, "exec user process")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
