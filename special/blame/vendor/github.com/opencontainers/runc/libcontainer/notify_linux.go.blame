0000000000000000000000000000000000000000;;	// +build linux
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/docker/libcontainer/notify_linux.go[Godeps/_workspace/src/github.com/docker/libcontainer/notify_linux.go][vendor/github.com/opencontainers/runc/libcontainer/notify_linux.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const oomCgroupName = "memory"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PressureLevel uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LowPressure PressureLevel = iota
0000000000000000000000000000000000000000;;		MediumPressure
0000000000000000000000000000000000000000;;		CriticalPressure
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func registerMemoryEvent(cgDir string, evName string, arg string) (<-chan struct{}, error) {
0000000000000000000000000000000000000000;;		evFile, err := os.Open(filepath.Join(cgDir, evName))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd, _, syserr := syscall.RawSyscall(syscall.SYS_EVENTFD2, 0, syscall.FD_CLOEXEC, 0)
0000000000000000000000000000000000000000;;		if syserr != 0 {
0000000000000000000000000000000000000000;;			evFile.Close()
0000000000000000000000000000000000000000;;			return nil, syserr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventfd := os.NewFile(fd, "eventfd")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventControlPath := filepath.Join(cgDir, "cgroup.event_control")
0000000000000000000000000000000000000000;;		data := fmt.Sprintf("%d %d %s", eventfd.Fd(), evFile.Fd(), arg)
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(eventControlPath, []byte(data), 0700); err != nil {
0000000000000000000000000000000000000000;;			eventfd.Close()
0000000000000000000000000000000000000000;;			evFile.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				close(ch)
0000000000000000000000000000000000000000;;				eventfd.Close()
0000000000000000000000000000000000000000;;				evFile.Close()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			buf := make([]byte, 8)
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if _, err := eventfd.Read(buf); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// When a cgroup is destroyed, an event is sent to eventfd.
0000000000000000000000000000000000000000;;				// So if the control path is gone, return instead of notifying.
0000000000000000000000000000000000000000;;				if _, err := os.Lstat(eventControlPath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ch <- struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return ch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notifyOnOOM returns channel on which you can expect event about OOM,
0000000000000000000000000000000000000000;;	// if process died without OOM this channel will be closed.
0000000000000000000000000000000000000000;;	func notifyOnOOM(paths map[string]string) (<-chan struct{}, error) {
0000000000000000000000000000000000000000;;		dir := paths[oomCgroupName]
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("path %q missing", oomCgroupName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return registerMemoryEvent(dir, "memory.oom_control", "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func notifyMemoryPressure(paths map[string]string, level PressureLevel) (<-chan struct{}, error) {
0000000000000000000000000000000000000000;;		dir := paths[oomCgroupName]
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("path %q missing", oomCgroupName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if level > CriticalPressure {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid pressure level %d", level)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		levelStr := []string{"low", "medium", "critical"}[level]
0000000000000000000000000000000000000000;;		return registerMemoryEvent(dir, "memory.pressure_level", levelStr)
0000000000000000000000000000000000000000;;	}
