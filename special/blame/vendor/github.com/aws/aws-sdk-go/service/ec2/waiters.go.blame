0000000000000000000000000000000000000000;;	// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/aws/aws-sdk-go/service/ec2/waiters.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/service/ec2/waiters.go][vendor/github.com/aws/aws-sdk-go/service/ec2/waiters.go];	
0000000000000000000000000000000000000000;;	package ec2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/private/waiter"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilBundleTaskComplete uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeBundleTasks to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilBundleTaskComplete(input *DescribeBundleTasksInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeBundleTasks",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "BundleTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "complete",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "BundleTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "failed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilConversionTaskCancelled uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeConversionTasks to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilConversionTaskCancelled(input *DescribeConversionTasksInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeConversionTasks",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "ConversionTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "cancelled",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilConversionTaskCompleted uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeConversionTasks to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilConversionTaskCompleted(input *DescribeConversionTasksInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeConversionTasks",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "ConversionTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "completed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "ConversionTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "cancelled",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "ConversionTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "cancelling",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilConversionTaskDeleted uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeConversionTasks to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilConversionTaskDeleted(input *DescribeConversionTasksInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeConversionTasks",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "ConversionTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilCustomerGatewayAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeCustomerGateways to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilCustomerGatewayAvailable(input *DescribeCustomerGatewaysInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeCustomerGateways",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "CustomerGateways[].State",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "CustomerGateways[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "CustomerGateways[].State",
0000000000000000000000000000000000000000;;					Expected: "deleting",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilExportTaskCancelled uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeExportTasks to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilExportTaskCancelled(input *DescribeExportTasksInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeExportTasks",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "ExportTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "cancelled",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilExportTaskCompleted uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeExportTasks to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilExportTaskCompleted(input *DescribeExportTasksInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeExportTasks",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "ExportTasks[].State",
0000000000000000000000000000000000000000;;					Expected: "completed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilImageAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeImages to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilImageAvailable(input *DescribeImagesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeImages",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Images[].State",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Images[].State",
0000000000000000000000000000000000000000;;					Expected: "failed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilImageExists uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeImages to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilImageExists(input *DescribeImagesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeImages",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "path",
0000000000000000000000000000000000000000;;					Argument: "length(Images[]) > `0`",
0000000000000000000000000000000000000000;;					Expected: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidAMIID.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilInstanceExists uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeInstances to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilInstanceExists(input *DescribeInstancesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstances",
0000000000000000000000000000000000000000;;			Delay:       5,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "path",
0000000000000000000000000000000000000000;;					Argument: "length(Reservations[]) > `0`",
0000000000000000000000000000000000000000;;					Expected: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidInstanceID.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilInstanceRunning uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeInstances to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilInstanceRunning(input *DescribeInstancesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstances",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "running",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "shutting-down",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "terminated",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "stopping",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidInstanceID.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilInstanceStatusOk uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeInstanceStatus to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilInstanceStatusOk(input *DescribeInstanceStatusInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstanceStatus",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "InstanceStatuses[].InstanceStatus.Status",
0000000000000000000000000000000000000000;;					Expected: "ok",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidInstanceID.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilInstanceStopped uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeInstances to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilInstanceStopped(input *DescribeInstancesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstances",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "stopped",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "pending",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "terminated",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilInstanceTerminated uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeInstances to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilInstanceTerminated(input *DescribeInstancesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstances",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "terminated",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "pending",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Reservations[].Instances[].State.Name",
0000000000000000000000000000000000000000;;					Expected: "stopping",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilKeyPairExists uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeKeyPairs to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilKeyPairExists(input *DescribeKeyPairsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeKeyPairs",
0000000000000000000000000000000000000000;;			Delay:       5,
0000000000000000000000000000000000000000;;			MaxAttempts: 6,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "length(KeyPairs[].KeyName) > `0`",
0000000000000000000000000000000000000000;;					Expected: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidKeyPair.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilNatGatewayAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeNatGateways to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilNatGatewayAvailable(input *DescribeNatGatewaysInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeNatGateways",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "NatGateways[].State",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "NatGateways[].State",
0000000000000000000000000000000000000000;;					Expected: "failed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "NatGateways[].State",
0000000000000000000000000000000000000000;;					Expected: "deleting",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "NatGateways[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "NatGatewayNotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilNetworkInterfaceAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeNetworkInterfaces to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilNetworkInterfaceAvailable(input *DescribeNetworkInterfacesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeNetworkInterfaces",
0000000000000000000000000000000000000000;;			Delay:       20,
0000000000000000000000000000000000000000;;			MaxAttempts: 10,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "NetworkInterfaces[].Status",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidNetworkInterfaceID.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilPasswordDataAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// GetPasswordData to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilPasswordDataAvailable(input *GetPasswordDataInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "GetPasswordData",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "path",
0000000000000000000000000000000000000000;;					Argument: "length(PasswordData) > `0`",
0000000000000000000000000000000000000000;;					Expected: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilSnapshotCompleted uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeSnapshots to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilSnapshotCompleted(input *DescribeSnapshotsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeSnapshots",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Snapshots[].State",
0000000000000000000000000000000000000000;;					Expected: "completed",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilSpotInstanceRequestFulfilled uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeSpotInstanceRequests to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilSpotInstanceRequestFulfilled(input *DescribeSpotInstanceRequestsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeSpotInstanceRequests",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "SpotInstanceRequests[].Status.Code",
0000000000000000000000000000000000000000;;					Expected: "fulfilled",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "SpotInstanceRequests[].Status.Code",
0000000000000000000000000000000000000000;;					Expected: "schedule-expired",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "SpotInstanceRequests[].Status.Code",
0000000000000000000000000000000000000000;;					Expected: "canceled-before-fulfillment",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "SpotInstanceRequests[].Status.Code",
0000000000000000000000000000000000000000;;					Expected: "bad-parameters",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "SpotInstanceRequests[].Status.Code",
0000000000000000000000000000000000000000;;					Expected: "system-error",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilSubnetAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeSubnets to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilSubnetAvailable(input *DescribeSubnetsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeSubnets",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Subnets[].State",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilSystemStatusOk uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeInstanceStatus to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilSystemStatusOk(input *DescribeInstanceStatusInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstanceStatus",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "InstanceStatuses[].SystemStatus.Status",
0000000000000000000000000000000000000000;;					Expected: "ok",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVolumeAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVolumes to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVolumeAvailable(input *DescribeVolumesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVolumes",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Volumes[].State",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Volumes[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVolumeDeleted uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVolumes to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVolumeDeleted(input *DescribeVolumesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVolumes",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Volumes[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidVolume.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVolumeInUse uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVolumes to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVolumeInUse(input *DescribeVolumesInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVolumes",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Volumes[].State",
0000000000000000000000000000000000000000;;					Expected: "in-use",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "Volumes[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVpcAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVpcs to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVpcAvailable(input *DescribeVpcsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVpcs",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "Vpcs[].State",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVpcExists uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVpcs to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVpcExists(input *DescribeVpcsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVpcs",
0000000000000000000000000000000000000000;;			Delay:       1,
0000000000000000000000000000000000000000;;			MaxAttempts: 5,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "status",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: 200,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidVpcID.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVpcPeeringConnectionExists uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVpcPeeringConnections to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVpcPeeringConnectionExists(input *DescribeVpcPeeringConnectionsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVpcPeeringConnections",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "status",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: 200,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "retry",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidVpcPeeringConnectionID.NotFound",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVpnConnectionAvailable uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVpnConnections to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVpnConnectionAvailable(input *DescribeVpnConnectionsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVpnConnections",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "VpnConnections[].State",
0000000000000000000000000000000000000000;;					Expected: "available",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "VpnConnections[].State",
0000000000000000000000000000000000000000;;					Expected: "deleting",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "VpnConnections[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilVpnConnectionDeleted uses the Amazon EC2 API operation
0000000000000000000000000000000000000000;;	// DescribeVpnConnections to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *EC2) WaitUntilVpnConnectionDeleted(input *DescribeVpnConnectionsInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeVpnConnections",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "VpnConnections[].State",
0000000000000000000000000000000000000000;;					Expected: "deleted",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "failure",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "VpnConnections[].State",
0000000000000000000000000000000000000000;;					Expected: "pending",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
