0000000000000000000000000000000000000000;;	// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.
7381c378252ae8f66befb472cf056371ba4be46a;Godeps/_workspace/src/github.com/aws/aws-sdk-go/service/elb/waiters.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/service/elb/waiters.go][vendor/github.com/aws/aws-sdk-go/service/elb/waiters.go];	
0000000000000000000000000000000000000000;;	package elb
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/private/waiter"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilAnyInstanceInService uses the Elastic Load Balancing API operation
0000000000000000000000000000000000000000;;	// DescribeInstanceHealth to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *ELB) WaitUntilAnyInstanceInService(input *DescribeInstanceHealthInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstanceHealth",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAny",
0000000000000000000000000000000000000000;;					Argument: "InstanceStates[].State",
0000000000000000000000000000000000000000;;					Expected: "InService",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilInstanceDeregistered uses the Elastic Load Balancing API operation
0000000000000000000000000000000000000000;;	// DescribeInstanceHealth to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *ELB) WaitUntilInstanceDeregistered(input *DescribeInstanceHealthInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstanceHealth",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "InstanceStates[].State",
0000000000000000000000000000000000000000;;					Expected: "OutOfService",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "error",
0000000000000000000000000000000000000000;;					Argument: "",
0000000000000000000000000000000000000000;;					Expected: "InvalidInstance",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitUntilInstanceInService uses the Elastic Load Balancing API operation
0000000000000000000000000000000000000000;;	// DescribeInstanceHealth to wait for a condition to be met before returning.
0000000000000000000000000000000000000000;;	// If the condition is not meet within the max attempt window an error will
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func (c *ELB) WaitUntilInstanceInService(input *DescribeInstanceHealthInput) error {
0000000000000000000000000000000000000000;;		waiterCfg := waiter.Config{
0000000000000000000000000000000000000000;;			Operation:   "DescribeInstanceHealth",
0000000000000000000000000000000000000000;;			Delay:       15,
0000000000000000000000000000000000000000;;			MaxAttempts: 40,
0000000000000000000000000000000000000000;;			Acceptors: []waiter.WaitAcceptor{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					State:    "success",
0000000000000000000000000000000000000000;;					Matcher:  "pathAll",
0000000000000000000000000000000000000000;;					Argument: "InstanceStates[].State",
0000000000000000000000000000000000000000;;					Expected: "InService",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := waiter.Waiter{
0000000000000000000000000000000000000000;;			Client: c,
0000000000000000000000000000000000000000;;			Input:  input,
0000000000000000000000000000000000000000;;			Config: waiterCfg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Wait()
0000000000000000000000000000000000000000;;	}
