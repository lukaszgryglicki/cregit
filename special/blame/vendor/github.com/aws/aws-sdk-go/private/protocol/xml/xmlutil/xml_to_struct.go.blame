0000000000000000000000000000000000000000;;	package xmlutil
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/xml/xmlutil/xml_to_struct.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/xml/xmlutil/xml_to_struct.go][vendor/github.com/aws/aws-sdk-go/private/protocol/xml/xmlutil/xml_to_struct.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A XMLNode contains the values to be encoded or decoded.
0000000000000000000000000000000000000000;;	type XMLNode struct {
0000000000000000000000000000000000000000;;		Name     xml.Name              `json:",omitempty"`
0000000000000000000000000000000000000000;;		Children map[string][]*XMLNode `json:",omitempty"`
0000000000000000000000000000000000000000;;		Text     string                `json:",omitempty"`
0000000000000000000000000000000000000000;;		Attr     []xml.Attr            `json:",omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespaces map[string]string
0000000000000000000000000000000000000000;;		parent     *XMLNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewXMLElement returns a pointer to a new XMLNode initialized to default values.
0000000000000000000000000000000000000000;;	func NewXMLElement(name xml.Name) *XMLNode {
0000000000000000000000000000000000000000;;		return &XMLNode{
0000000000000000000000000000000000000000;;			Name:     name,
0000000000000000000000000000000000000000;;			Children: map[string][]*XMLNode{},
0000000000000000000000000000000000000000;;			Attr:     []xml.Attr{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddChild adds child to the XMLNode.
0000000000000000000000000000000000000000;;	func (n *XMLNode) AddChild(child *XMLNode) {
0000000000000000000000000000000000000000;;		if _, ok := n.Children[child.Name.Local]; !ok {
0000000000000000000000000000000000000000;;			n.Children[child.Name.Local] = []*XMLNode{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.Children[child.Name.Local] = append(n.Children[child.Name.Local], child)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// XMLToStruct converts a xml.Decoder stream to XMLNode with nested values.
0000000000000000000000000000000000000000;;	func XMLToStruct(d *xml.Decoder, s *xml.StartElement) (*XMLNode, error) {
0000000000000000000000000000000000000000;;		out := &XMLNode{}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok, err := d.Token()
0000000000000000000000000000000000000000;;			if tok == nil || err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return out, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch typed := tok.(type) {
0000000000000000000000000000000000000000;;			case xml.CharData:
0000000000000000000000000000000000000000;;				out.Text = string(typed.Copy())
0000000000000000000000000000000000000000;;			case xml.StartElement:
0000000000000000000000000000000000000000;;				el := typed.Copy()
0000000000000000000000000000000000000000;;				out.Attr = el.Attr
0000000000000000000000000000000000000000;;				if out.Children == nil {
0000000000000000000000000000000000000000;;					out.Children = map[string][]*XMLNode{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				name := typed.Name.Local
0000000000000000000000000000000000000000;;				slice := out.Children[name]
0000000000000000000000000000000000000000;;				if slice == nil {
0000000000000000000000000000000000000000;;					slice = []*XMLNode{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				node, e := XMLToStruct(d, &el)
0000000000000000000000000000000000000000;;				out.findNamespaces()
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					return out, e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				node.Name = typed.Name
0000000000000000000000000000000000000000;;				node.findNamespaces()
0000000000000000000000000000000000000000;;				tempOut := *out
0000000000000000000000000000000000000000;;				// Save into a temp variable, simply because out gets squashed during
0000000000000000000000000000000000000000;;				// loop iterations
0000000000000000000000000000000000000000;;				node.parent = &tempOut
0000000000000000000000000000000000000000;;				slice = append(slice, node)
0000000000000000000000000000000000000000;;				out.Children[name] = slice
0000000000000000000000000000000000000000;;			case xml.EndElement:
0000000000000000000000000000000000000000;;				if s != nil && s.Name.Local == typed.Name.Local { // matching end token
0000000000000000000000000000000000000000;;					return out, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out = &XMLNode{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *XMLNode) findNamespaces() {
0000000000000000000000000000000000000000;;		ns := map[string]string{}
0000000000000000000000000000000000000000;;		for _, a := range n.Attr {
0000000000000000000000000000000000000000;;			if a.Name.Space == "xmlns" {
0000000000000000000000000000000000000000;;				ns[a.Value] = a.Name.Local
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.namespaces = ns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *XMLNode) findElem(name string) (string, bool) {
0000000000000000000000000000000000000000;;		for node := n; node != nil; node = node.parent {
0000000000000000000000000000000000000000;;			for _, a := range node.Attr {
0000000000000000000000000000000000000000;;				namespace := a.Name.Space
0000000000000000000000000000000000000000;;				if v, ok := node.namespaces[namespace]; ok {
0000000000000000000000000000000000000000;;					namespace = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if name == fmt.Sprintf("%s:%s", namespace, a.Name.Local) {
0000000000000000000000000000000000000000;;					return a.Value, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StructToXML writes an XMLNode to a xml.Encoder as tokens.
0000000000000000000000000000000000000000;;	func StructToXML(e *xml.Encoder, node *XMLNode, sorted bool) error {
0000000000000000000000000000000000000000;;		e.EncodeToken(xml.StartElement{Name: node.Name, Attr: node.Attr})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if node.Text != "" {
0000000000000000000000000000000000000000;;			e.EncodeToken(xml.CharData([]byte(node.Text)))
0000000000000000000000000000000000000000;;		} else if sorted {
0000000000000000000000000000000000000000;;			sortedNames := []string{}
0000000000000000000000000000000000000000;;			for k := range node.Children {
0000000000000000000000000000000000000000;;				sortedNames = append(sortedNames, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(sortedNames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, k := range sortedNames {
0000000000000000000000000000000000000000;;				for _, v := range node.Children[k] {
0000000000000000000000000000000000000000;;					StructToXML(e, v, sorted)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, c := range node.Children {
0000000000000000000000000000000000000000;;				for _, v := range c {
0000000000000000000000000000000000000000;;					StructToXML(e, v, sorted)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.EncodeToken(xml.EndElement{Name: node.Name})
0000000000000000000000000000000000000000;;		return e.Flush()
0000000000000000000000000000000000000000;;	}
