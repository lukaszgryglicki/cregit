0000000000000000000000000000000000000000;;	// Package jsonutil provides JSON serialization of AWS requests and responses.
0000000000000000000000000000000000000000;;	package jsonutil
837c40a351ee83c902024069c1ae048b6b398947;Godeps/_workspace/src/github.com/aws/aws-sdk-go/private/protocol/json/jsonutil/build.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/private/protocol/json/jsonutil/build.go][vendor/github.com/aws/aws-sdk-go/private/protocol/json/jsonutil/build.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/private/protocol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var timeType = reflect.ValueOf(time.Time{}).Type()
0000000000000000000000000000000000000000;;	var byteSliceType = reflect.ValueOf([]byte{}).Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildJSON builds a JSON string for a given object v.
0000000000000000000000000000000000000000;;	func BuildJSON(v interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := buildAny(reflect.ValueOf(v), &buf, "")
0000000000000000000000000000000000000000;;		return buf.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildAny(value reflect.Value, buf *bytes.Buffer, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		value = reflect.Indirect(value)
0000000000000000000000000000000000000000;;		if !value.IsValid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vtype := value.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := tag.Get("type")
0000000000000000000000000000000000000000;;		if t == "" {
0000000000000000000000000000000000000000;;			switch vtype.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				// also it can't be a time object
0000000000000000000000000000000000000000;;				if value.Type() != timeType {
0000000000000000000000000000000000000000;;					t = "structure"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				// also it can't be a byte slice
0000000000000000000000000000000000000000;;				if _, ok := value.Interface().([]byte); !ok {
0000000000000000000000000000000000000000;;					t = "list"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				t = "map"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case "structure":
0000000000000000000000000000000000000000;;			if field, ok := vtype.FieldByName("_"); ok {
0000000000000000000000000000000000000000;;				tag = field.Tag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return buildStruct(value, buf, tag)
0000000000000000000000000000000000000000;;		case "list":
0000000000000000000000000000000000000000;;			return buildList(value, buf, tag)
0000000000000000000000000000000000000000;;		case "map":
0000000000000000000000000000000000000000;;			return buildMap(value, buf, tag)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return buildScalar(value, buf, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildStruct(value reflect.Value, buf *bytes.Buffer, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if !value.IsValid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unwrap payloads
0000000000000000000000000000000000000000;;		if payload := tag.Get("payload"); payload != "" {
0000000000000000000000000000000000000000;;			field, _ := value.Type().FieldByName(payload)
0000000000000000000000000000000000000000;;			tag = field.Tag
0000000000000000000000000000000000000000;;			value = elemOf(value.FieldByName(payload))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !value.IsValid() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteByte('{')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := value.Type()
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;			member := value.Field(i)
0000000000000000000000000000000000000000;;			field := t.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if field.PkgPath != "" {
0000000000000000000000000000000000000000;;				continue // ignore unexported fields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if field.Tag.Get("json") == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if field.Tag.Get("location") != "" {
0000000000000000000000000000000000000000;;				continue // ignore non-body elements
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if field.Tag.Get("ignore") != "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if protocol.CanSetIdempotencyToken(member, field) {
0000000000000000000000000000000000000000;;				token := protocol.GetIdempotencyToken()
0000000000000000000000000000000000000000;;				member = reflect.ValueOf(&token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if (member.Kind() == reflect.Ptr || member.Kind() == reflect.Slice || member.Kind() == reflect.Map) && member.IsNil() {
0000000000000000000000000000000000000000;;				continue // ignore unset fields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteByte(',')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// figure out what this field is called
0000000000000000000000000000000000000000;;			name := field.Name
0000000000000000000000000000000000000000;;			if locName := field.Tag.Get("locationName"); locName != "" {
0000000000000000000000000000000000000000;;				name = locName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writeString(name, buf)
0000000000000000000000000000000000000000;;			buf.WriteString(`:`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := buildAny(member, buf, field.Tag)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteString("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildList(value reflect.Value, buf *bytes.Buffer, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		buf.WriteString("[")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;			buildAny(value.Index(i), buf, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i < value.Len()-1 {
0000000000000000000000000000000000000000;;				buf.WriteString(",")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteString("]")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortedValues []reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv sortedValues) Len() int           { return len(sv) }
0000000000000000000000000000000000000000;;	func (sv sortedValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }
0000000000000000000000000000000000000000;;	func (sv sortedValues) Less(i, j int) bool { return sv[i].String() < sv[j].String() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildMap(value reflect.Value, buf *bytes.Buffer, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		buf.WriteString("{")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sv := sortedValues(value.MapKeys())
0000000000000000000000000000000000000000;;		sort.Sort(sv)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, k := range sv {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				buf.WriteByte(',')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writeString(k.String(), buf)
0000000000000000000000000000000000000000;;			buf.WriteString(`:`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buildAny(value.MapIndex(k), buf, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteString("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildScalar(value reflect.Value, buf *bytes.Buffer, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		switch value.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			writeString(value.String(), buf)
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			buf.WriteString(strconv.FormatBool(value.Bool()))
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			buf.WriteString(strconv.FormatInt(value.Int(), 10))
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			buf.WriteString(strconv.FormatFloat(value.Float(), 'f', -1, 64))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch value.Type() {
0000000000000000000000000000000000000000;;			case timeType:
0000000000000000000000000000000000000000;;				converted := value.Interface().(time.Time)
0000000000000000000000000000000000000000;;				buf.WriteString(strconv.FormatInt(converted.UTC().Unix(), 10))
0000000000000000000000000000000000000000;;			case byteSliceType:
0000000000000000000000000000000000000000;;				if !value.IsNil() {
0000000000000000000000000000000000000000;;					converted := value.Interface().([]byte)
0000000000000000000000000000000000000000;;					buf.WriteByte('"')
0000000000000000000000000000000000000000;;					if len(converted) < 1024 {
0000000000000000000000000000000000000000;;						// for small buffers, using Encode directly is much faster.
0000000000000000000000000000000000000000;;						dst := make([]byte, base64.StdEncoding.EncodedLen(len(converted)))
0000000000000000000000000000000000000000;;						base64.StdEncoding.Encode(dst, converted)
0000000000000000000000000000000000000000;;						buf.Write(dst)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// for large buffers, avoid unnecessary extra temporary
0000000000000000000000000000000000000000;;						// buffer space.
0000000000000000000000000000000000000000;;						enc := base64.NewEncoder(base64.StdEncoding, buf)
0000000000000000000000000000000000000000;;						enc.Write(converted)
0000000000000000000000000000000000000000;;						enc.Close()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					buf.WriteByte('"')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("unsupported JSON value %v (%s)", value.Interface(), value.Type())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeString(s string, buf *bytes.Buffer) {
0000000000000000000000000000000000000000;;		buf.WriteByte('"')
0000000000000000000000000000000000000000;;		for _, r := range s {
0000000000000000000000000000000000000000;;			if r == '"' {
0000000000000000000000000000000000000000;;				buf.WriteString(`\"`)
0000000000000000000000000000000000000000;;			} else if r == '\\' {
0000000000000000000000000000000000000000;;				buf.WriteString(`\\`)
0000000000000000000000000000000000000000;;			} else if r == '\b' {
0000000000000000000000000000000000000000;;				buf.WriteString(`\b`)
0000000000000000000000000000000000000000;;			} else if r == '\f' {
0000000000000000000000000000000000000000;;				buf.WriteString(`\f`)
0000000000000000000000000000000000000000;;			} else if r == '\r' {
0000000000000000000000000000000000000000;;				buf.WriteString(`\r`)
0000000000000000000000000000000000000000;;			} else if r == '\t' {
0000000000000000000000000000000000000000;;				buf.WriteString(`\t`)
0000000000000000000000000000000000000000;;			} else if r == '\n' {
0000000000000000000000000000000000000000;;				buf.WriteString(`\n`)
0000000000000000000000000000000000000000;;			} else if r < 32 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "\\u%0.4x", r)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteRune(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteByte('"')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the reflection element of a value, if it is a pointer.
0000000000000000000000000000000000000000;;	func elemOf(value reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		for value.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			value = value.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
