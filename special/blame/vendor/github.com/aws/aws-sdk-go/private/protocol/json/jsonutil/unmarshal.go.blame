0000000000000000000000000000000000000000;;	package jsonutil
837c40a351ee83c902024069c1ae048b6b398947;Godeps/_workspace/src/github.com/aws/aws-sdk-go/private/protocol/json/jsonutil/unmarshal.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/private/protocol/json/jsonutil/unmarshal.go][vendor/github.com/aws/aws-sdk-go/private/protocol/json/jsonutil/unmarshal.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON reads a stream and unmarshals the results in object v.
0000000000000000000000000000000000000000;;	func UnmarshalJSON(v interface{}, stream io.Reader) error {
0000000000000000000000000000000000000000;;		var out interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(stream)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &out); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmarshalAny(reflect.ValueOf(v), out, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalAny(value reflect.Value, data interface{}, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		vtype := value.Type()
0000000000000000000000000000000000000000;;		if vtype.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			vtype = vtype.Elem() // check kind of actual element type
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := tag.Get("type")
0000000000000000000000000000000000000000;;		if t == "" {
0000000000000000000000000000000000000000;;			switch vtype.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				// also it can't be a time object
0000000000000000000000000000000000000000;;				if _, ok := value.Interface().(*time.Time); !ok {
0000000000000000000000000000000000000000;;					t = "structure"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				// also it can't be a byte slice
0000000000000000000000000000000000000000;;				if _, ok := value.Interface().([]byte); !ok {
0000000000000000000000000000000000000000;;					t = "list"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				t = "map"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case "structure":
0000000000000000000000000000000000000000;;			if field, ok := vtype.FieldByName("_"); ok {
0000000000000000000000000000000000000000;;				tag = field.Tag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return unmarshalStruct(value, data, tag)
0000000000000000000000000000000000000000;;		case "list":
0000000000000000000000000000000000000000;;			return unmarshalList(value, data, tag)
0000000000000000000000000000000000000000;;		case "map":
0000000000000000000000000000000000000000;;			return unmarshalMap(value, data, tag)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unmarshalScalar(value, data, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalStruct(value reflect.Value, data interface{}, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapData, ok := data.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("JSON value is not a structure (%#v)", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := value.Type()
0000000000000000000000000000000000000000;;		if value.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if value.IsNil() { // create the structure if it's nil
0000000000000000000000000000000000000000;;				s := reflect.New(value.Type().Elem())
0000000000000000000000000000000000000000;;				value.Set(s)
0000000000000000000000000000000000000000;;				value = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			value = value.Elem()
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unwrap any payloads
0000000000000000000000000000000000000000;;		if payload := tag.Get("payload"); payload != "" {
0000000000000000000000000000000000000000;;			field, _ := t.FieldByName(payload)
0000000000000000000000000000000000000000;;			return unmarshalAny(value.FieldByName(payload), data, field.Tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := t.Field(i)
0000000000000000000000000000000000000000;;			if field.PkgPath != "" {
0000000000000000000000000000000000000000;;				continue // ignore unexported fields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// figure out what this field is called
0000000000000000000000000000000000000000;;			name := field.Name
0000000000000000000000000000000000000000;;			if locName := field.Tag.Get("locationName"); locName != "" {
0000000000000000000000000000000000000000;;				name = locName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			member := value.FieldByIndex(field.Index)
0000000000000000000000000000000000000000;;			err := unmarshalAny(member, mapData[name], field.Tag)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalList(value reflect.Value, data interface{}, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listData, ok := data.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("JSON value is not a list (%#v)", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if value.IsNil() {
0000000000000000000000000000000000000000;;			l := len(listData)
0000000000000000000000000000000000000000;;			value.Set(reflect.MakeSlice(value.Type(), l, l))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, c := range listData {
0000000000000000000000000000000000000000;;			err := unmarshalAny(value.Index(i), c, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalMap(value reflect.Value, data interface{}, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapData, ok := data.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("JSON value is not a map (%#v)", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if value.IsNil() {
0000000000000000000000000000000000000000;;			value.Set(reflect.MakeMap(value.Type()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range mapData {
0000000000000000000000000000000000000000;;			kvalue := reflect.ValueOf(k)
0000000000000000000000000000000000000000;;			vvalue := reflect.New(value.Type().Elem()).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			unmarshalAny(vvalue, v, "")
0000000000000000000000000000000000000000;;			value.SetMapIndex(kvalue, vvalue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalScalar(value reflect.Value, data interface{}, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		errf := func() error {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported value: %v (%s)", value.Interface(), value.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch d := data.(type) {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			return nil // nothing to do here
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			switch value.Interface().(type) {
0000000000000000000000000000000000000000;;			case *string:
0000000000000000000000000000000000000000;;				value.Set(reflect.ValueOf(&d))
0000000000000000000000000000000000000000;;			case []byte:
0000000000000000000000000000000000000000;;				b, err := base64.StdEncoding.DecodeString(d)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				value.Set(reflect.ValueOf(b))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return errf()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			switch value.Interface().(type) {
0000000000000000000000000000000000000000;;			case *int64:
0000000000000000000000000000000000000000;;				di := int64(d)
0000000000000000000000000000000000000000;;				value.Set(reflect.ValueOf(&di))
0000000000000000000000000000000000000000;;			case *float64:
0000000000000000000000000000000000000000;;				value.Set(reflect.ValueOf(&d))
0000000000000000000000000000000000000000;;			case *time.Time:
0000000000000000000000000000000000000000;;				t := time.Unix(int64(d), 0).UTC()
0000000000000000000000000000000000000000;;				value.Set(reflect.ValueOf(&t))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return errf()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			switch value.Interface().(type) {
0000000000000000000000000000000000000000;;			case *bool:
0000000000000000000000000000000000000000;;				value.Set(reflect.ValueOf(&d))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return errf()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported JSON value (%v)", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
