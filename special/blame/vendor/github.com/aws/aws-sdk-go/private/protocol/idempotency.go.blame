0000000000000000000000000000000000000000;;	package protocol
7b662bd39f4f8ebe87658b72a7df9da9c5a74c80;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RandReader is the random reader the protocol package will use to read
0000000000000000000000000000000000000000;;	// random bytes from. This is exported for testing, and should not be used.
0000000000000000000000000000000000000000;;	var RandReader = rand.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const idempotencyTokenFillTag = `idempotencyToken`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanSetIdempotencyToken returns true if the struct field should be
0000000000000000000000000000000000000000;;	// automatically populated with a Idempotency token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Only *string and string type fields that are tagged with idempotencyToken
0000000000000000000000000000000000000000;;	// which are not already set can be auto filled.
0000000000000000000000000000000000000000;;	func CanSetIdempotencyToken(v reflect.Value, f reflect.StructField) bool {
0000000000000000000000000000000000000000;;		switch u := v.Interface().(type) {
0000000000000000000000000000000000000000;;		// To auto fill an Idempotency token the field must be a string,
0000000000000000000000000000000000000000;;		// tagged for auto fill, and have a zero value.
0000000000000000000000000000000000000000;;		case *string:
0000000000000000000000000000000000000000;;			return u == nil && len(f.Tag.Get(idempotencyTokenFillTag)) != 0
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return len(u) == 0 && len(f.Tag.Get(idempotencyTokenFillTag)) != 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetIdempotencyToken returns a randomly generated idempotency token.
0000000000000000000000000000000000000000;;	func GetIdempotencyToken() string {
0000000000000000000000000000000000000000;;		b := make([]byte, 16)
0000000000000000000000000000000000000000;;		RandReader.Read(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return UUIDVersion4(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetIdempotencyToken will set the value provided with a Idempotency Token.
0000000000000000000000000000000000000000;;	// Given that the value can be set. Will panic if value is not setable.
0000000000000000000000000000000000000000;;	func SetIdempotencyToken(v reflect.Value) {
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if v.IsNil() && v.CanSet() {
0000000000000000000000000000000000000000;;				v.Set(reflect.New(v.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = v.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = reflect.Indirect(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !v.CanSet() {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unable to set idempotnecy token %v", v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, 16)
0000000000000000000000000000000000000000;;		_, err := rand.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// TODO handle error
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.Set(reflect.ValueOf(UUIDVersion4(b)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UUIDVersion4 returns a Version 4 random UUID from the byte slice provided
0000000000000000000000000000000000000000;;	func UUIDVersion4(u []byte) string {
0000000000000000000000000000000000000000;;		// https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29
0000000000000000000000000000000000000000;;		// 13th character is "4"
0000000000000000000000000000000000000000;;		u[6] = (u[6] | 0x40) & 0x4F
0000000000000000000000000000000000000000;;		// 17th character is "8", "9", "a", or "b"
0000000000000000000000000000000000000000;;		u[8] = (u[8] | 0x80) & 0xBF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(`%X-%X-%X-%X-%X`, u[0:4], u[4:6], u[6:8], u[8:10], u[10:])
0000000000000000000000000000000000000000;;	}
