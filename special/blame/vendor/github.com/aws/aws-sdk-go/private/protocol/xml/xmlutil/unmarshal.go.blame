0000000000000000000000000000000000000000;;	package xmlutil
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/xml/xmlutil/unmarshal.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/xml/xmlutil/unmarshal.go][vendor/github.com/aws/aws-sdk-go/private/protocol/xml/xmlutil/unmarshal.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalXML deserializes an xml.Decoder into the container v. V
0000000000000000000000000000000000000000;;	// needs to match the shape of the XML expected to be decoded.
0000000000000000000000000000000000000000;;	// If the shape doesn't match unmarshaling will fail.
0000000000000000000000000000000000000000;;	func UnmarshalXML(v interface{}, d *xml.Decoder, wrapper string) error {
0000000000000000000000000000000000000000;;		n, _ := XMLToStruct(d, nil)
0000000000000000000000000000000000000000;;		if n.Children != nil {
0000000000000000000000000000000000000000;;			for _, root := range n.Children {
0000000000000000000000000000000000000000;;				for _, c := range root {
0000000000000000000000000000000000000000;;					if wrappedChild, ok := c.Children[wrapper]; ok {
0000000000000000000000000000000000000000;;						c = wrappedChild[0] // pull out wrapped element
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					err := parse(reflect.ValueOf(v), c, "")
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if err == io.EOF {
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse deserializes any value from the XMLNode. The type tag is used to infer the type, or reflect
0000000000000000000000000000000000000000;;	// will be used to determine the type from r.
0000000000000000000000000000000000000000;;	func parse(r reflect.Value, node *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		rtype := r.Type()
0000000000000000000000000000000000000000;;		if rtype.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			rtype = rtype.Elem() // check kind of actual element type
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := tag.Get("type")
0000000000000000000000000000000000000000;;		if t == "" {
0000000000000000000000000000000000000000;;			switch rtype.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				t = "structure"
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				t = "list"
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				t = "map"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case "structure":
0000000000000000000000000000000000000000;;			if field, ok := rtype.FieldByName("_"); ok {
0000000000000000000000000000000000000000;;				tag = field.Tag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return parseStruct(r, node, tag)
0000000000000000000000000000000000000000;;		case "list":
0000000000000000000000000000000000000000;;			return parseList(r, node, tag)
0000000000000000000000000000000000000000;;		case "map":
0000000000000000000000000000000000000000;;			return parseMap(r, node, tag)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return parseScalar(r, node, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseStruct deserializes a structure and its fields from an XMLNode. Any nested
0000000000000000000000000000000000000000;;	// types in the structure will also be deserialized.
0000000000000000000000000000000000000000;;	func parseStruct(r reflect.Value, node *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		t := r.Type()
0000000000000000000000000000000000000000;;		if r.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if r.IsNil() { // create the structure if it's nil
0000000000000000000000000000000000000000;;				s := reflect.New(r.Type().Elem())
0000000000000000000000000000000000000000;;				r.Set(s)
0000000000000000000000000000000000000000;;				r = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r = r.Elem()
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unwrap any payloads
0000000000000000000000000000000000000000;;		if payload := tag.Get("payload"); payload != "" {
0000000000000000000000000000000000000000;;			field, _ := t.FieldByName(payload)
0000000000000000000000000000000000000000;;			return parseStruct(r.FieldByName(payload), node, field.Tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := t.Field(i)
0000000000000000000000000000000000000000;;			if c := field.Name[0:1]; strings.ToLower(c) == c {
0000000000000000000000000000000000000000;;				continue // ignore unexported fields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// figure out what this field is called
0000000000000000000000000000000000000000;;			name := field.Name
0000000000000000000000000000000000000000;;			if field.Tag.Get("flattened") != "" && field.Tag.Get("locationNameList") != "" {
0000000000000000000000000000000000000000;;				name = field.Tag.Get("locationNameList")
0000000000000000000000000000000000000000;;			} else if locName := field.Tag.Get("locationName"); locName != "" {
0000000000000000000000000000000000000000;;				name = locName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// try to find the field by name in elements
0000000000000000000000000000000000000000;;			elems := node.Children[name]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if elems == nil { // try to find the field in attributes
0000000000000000000000000000000000000000;;				if val, ok := node.findElem(name); ok {
0000000000000000000000000000000000000000;;					elems = []*XMLNode{{Text: val}}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			member := r.FieldByName(field.Name)
0000000000000000000000000000000000000000;;			for _, elem := range elems {
0000000000000000000000000000000000000000;;				err := parse(member, elem, field.Tag)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseList deserializes a list of values from an XML node. Each list entry
0000000000000000000000000000000000000000;;	// will also be deserialized.
0000000000000000000000000000000000000000;;	func parseList(r reflect.Value, node *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		t := r.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tag.Get("flattened") == "" { // look at all item entries
0000000000000000000000000000000000000000;;			mname := "member"
0000000000000000000000000000000000000000;;			if name := tag.Get("locationNameList"); name != "" {
0000000000000000000000000000000000000000;;				mname = name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if Children, ok := node.Children[mname]; ok {
0000000000000000000000000000000000000000;;				if r.IsNil() {
0000000000000000000000000000000000000000;;					r.Set(reflect.MakeSlice(t, len(Children), len(Children)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i, c := range Children {
0000000000000000000000000000000000000000;;					err := parse(r.Index(i), c, "")
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else { // flattened list means this is a single element
0000000000000000000000000000000000000000;;			if r.IsNil() {
0000000000000000000000000000000000000000;;				r.Set(reflect.MakeSlice(t, 0, 0))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			childR := reflect.Zero(t.Elem())
0000000000000000000000000000000000000000;;			r.Set(reflect.Append(r, childR))
0000000000000000000000000000000000000000;;			err := parse(r.Index(r.Len()-1), node, "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseMap deserializes a map from an XMLNode. The direct children of the XMLNode
0000000000000000000000000000000000000000;;	// will also be deserialized as map entries.
0000000000000000000000000000000000000000;;	func parseMap(r reflect.Value, node *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if r.IsNil() {
0000000000000000000000000000000000000000;;			r.Set(reflect.MakeMap(r.Type()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tag.Get("flattened") == "" { // look at all child entries
0000000000000000000000000000000000000000;;			for _, entry := range node.Children["entry"] {
0000000000000000000000000000000000000000;;				parseMapEntry(r, entry, tag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else { // this element is itself an entry
0000000000000000000000000000000000000000;;			parseMapEntry(r, node, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseMapEntry deserializes a map entry from a XML node.
0000000000000000000000000000000000000000;;	func parseMapEntry(r reflect.Value, node *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		kname, vname := "key", "value"
0000000000000000000000000000000000000000;;		if n := tag.Get("locationNameKey"); n != "" {
0000000000000000000000000000000000000000;;			kname = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n := tag.Get("locationNameValue"); n != "" {
0000000000000000000000000000000000000000;;			vname = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys, ok := node.Children[kname]
0000000000000000000000000000000000000000;;		values := node.Children[vname]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			for i, key := range keys {
0000000000000000000000000000000000000000;;				keyR := reflect.ValueOf(key.Text)
0000000000000000000000000000000000000000;;				value := values[i]
0000000000000000000000000000000000000000;;				valueR := reflect.New(r.Type().Elem()).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				parse(valueR, value, "")
0000000000000000000000000000000000000000;;				r.SetMapIndex(keyR, valueR)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseScaller deserializes an XMLNode value into a concrete type based on the
0000000000000000000000000000000000000000;;	// interface type of r.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Error is returned if the deserialization fails due to invalid type conversion,
0000000000000000000000000000000000000000;;	// or unsupported interface type.
0000000000000000000000000000000000000000;;	func parseScalar(r reflect.Value, node *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		switch r.Interface().(type) {
0000000000000000000000000000000000000000;;		case *string:
0000000000000000000000000000000000000000;;			r.Set(reflect.ValueOf(&node.Text))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			b, err := base64.StdEncoding.DecodeString(node.Text)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Set(reflect.ValueOf(b))
0000000000000000000000000000000000000000;;		case *bool:
0000000000000000000000000000000000000000;;			v, err := strconv.ParseBool(node.Text)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Set(reflect.ValueOf(&v))
0000000000000000000000000000000000000000;;		case *int64:
0000000000000000000000000000000000000000;;			v, err := strconv.ParseInt(node.Text, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Set(reflect.ValueOf(&v))
0000000000000000000000000000000000000000;;		case *float64:
0000000000000000000000000000000000000000;;			v, err := strconv.ParseFloat(node.Text, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Set(reflect.ValueOf(&v))
0000000000000000000000000000000000000000;;		case *time.Time:
0000000000000000000000000000000000000000;;			const ISO8601UTC = "2006-01-02T15:04:05Z"
0000000000000000000000000000000000000000;;			t, err := time.Parse(ISO8601UTC, node.Text)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Set(reflect.ValueOf(&t))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported value: %v (%s)", r.Interface(), r.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
