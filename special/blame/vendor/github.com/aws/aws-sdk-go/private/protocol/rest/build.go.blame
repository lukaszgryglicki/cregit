0000000000000000000000000000000000000000;;	// Package rest provides RESTful serialization of AWS requests and responses.
0000000000000000000000000000000000000000;;	package rest
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/query/queryutil/queryutil.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/query/queryutil/queryutil.go][vendor/github.com/aws/aws-sdk-go/private/protocol/rest/build.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC822 returns an RFC822 formatted timestamp for AWS protocols
0000000000000000000000000000000000000000;;	const RFC822 = "Mon, 2 Jan 2006 15:04:05 GMT"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Whether the byte value can be sent without escaping in AWS URLs
0000000000000000000000000000000000000000;;	var noEscape [256]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errValueNotSet = fmt.Errorf("value not set")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for i := 0; i < len(noEscape); i++ {
0000000000000000000000000000000000000000;;			// AWS expects every character except these to be escaped
0000000000000000000000000000000000000000;;			noEscape[i] = (i >= 'A' && i <= 'Z') ||
0000000000000000000000000000000000000000;;				(i >= 'a' && i <= 'z') ||
0000000000000000000000000000000000000000;;				(i >= '0' && i <= '9') ||
0000000000000000000000000000000000000000;;				i == '-' ||
0000000000000000000000000000000000000000;;				i == '.' ||
0000000000000000000000000000000000000000;;				i == '_' ||
0000000000000000000000000000000000000000;;				i == '~'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildHandler is a named request handler for building rest protocol requests
0000000000000000000000000000000000000000;;	var BuildHandler = request.NamedHandler{Name: "awssdk.rest.Build", Fn: Build}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build builds the REST component of a service request.
0000000000000000000000000000000000000000;;	func Build(r *request.Request) {
0000000000000000000000000000000000000000;;		if r.ParamsFilled() {
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(r.Params).Elem()
0000000000000000000000000000000000000000;;			buildLocationElements(r, v, false)
0000000000000000000000000000000000000000;;			buildBody(r, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildAsGET builds the REST component of a service request with the ability to hoist
0000000000000000000000000000000000000000;;	// data from the body.
0000000000000000000000000000000000000000;;	func BuildAsGET(r *request.Request) {
0000000000000000000000000000000000000000;;		if r.ParamsFilled() {
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(r.Params).Elem()
0000000000000000000000000000000000000000;;			buildLocationElements(r, v, true)
0000000000000000000000000000000000000000;;			buildBody(r, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildLocationElements(r *request.Request, v reflect.Value, buildGETQuery bool) {
0000000000000000000000000000000000000000;;		query := r.HTTPRequest.URL.Query()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup the raw path to match the base path pattern. This is needed
0000000000000000000000000000000000000000;;		// so that when the path is mutated a custom escaped version can be
0000000000000000000000000000000000000000;;		// stored in RawPath that will be used by the Go client.
0000000000000000000000000000000000000000;;		r.HTTPRequest.URL.RawPath = r.HTTPRequest.URL.Path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;			m := v.Field(i)
0000000000000000000000000000000000000000;;			if n := v.Type().Field(i).Name; n[0:1] == strings.ToLower(n[0:1]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m.IsValid() {
0000000000000000000000000000000000000000;;				field := v.Type().Field(i)
0000000000000000000000000000000000000000;;				name := field.Tag.Get("locationName")
0000000000000000000000000000000000000000;;				if name == "" {
0000000000000000000000000000000000000000;;					name = field.Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if m.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;					m = m.Elem()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !m.IsValid() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if field.Tag.Get("ignore") != "" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				switch field.Tag.Get("location") {
0000000000000000000000000000000000000000;;				case "headers": // header maps
0000000000000000000000000000000000000000;;					err = buildHeaderMap(&r.HTTPRequest.Header, m, field.Tag.Get("locationName"))
0000000000000000000000000000000000000000;;				case "header":
0000000000000000000000000000000000000000;;					err = buildHeader(&r.HTTPRequest.Header, m, name)
0000000000000000000000000000000000000000;;				case "uri":
0000000000000000000000000000000000000000;;					err = buildURI(r.HTTPRequest.URL, m, name)
0000000000000000000000000000000000000000;;				case "querystring":
0000000000000000000000000000000000000000;;					err = buildQueryString(query, m, name)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					if buildGETQuery {
0000000000000000000000000000000000000000;;						err = buildQueryString(query, m, name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.Error = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.HTTPRequest.URL.RawQuery = query.Encode()
0000000000000000000000000000000000000000;;		if !aws.BoolValue(r.Config.DisableRestProtocolURICleaning) {
0000000000000000000000000000000000000000;;			cleanPath(r.HTTPRequest.URL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildBody(r *request.Request, v reflect.Value) {
0000000000000000000000000000000000000000;;		if field, ok := v.Type().FieldByName("_"); ok {
0000000000000000000000000000000000000000;;			if payloadName := field.Tag.Get("payload"); payloadName != "" {
0000000000000000000000000000000000000000;;				pfield, _ := v.Type().FieldByName(payloadName)
0000000000000000000000000000000000000000;;				if ptag := pfield.Tag.Get("type"); ptag != "" && ptag != "structure" {
0000000000000000000000000000000000000000;;					payload := reflect.Indirect(v.FieldByName(payloadName))
0000000000000000000000000000000000000000;;					if payload.IsValid() && payload.Interface() != nil {
0000000000000000000000000000000000000000;;						switch reader := payload.Interface().(type) {
0000000000000000000000000000000000000000;;						case io.ReadSeeker:
0000000000000000000000000000000000000000;;							r.SetReaderBody(reader)
0000000000000000000000000000000000000000;;						case []byte:
0000000000000000000000000000000000000000;;							r.SetBufferBody(reader)
0000000000000000000000000000000000000000;;						case string:
0000000000000000000000000000000000000000;;							r.SetStringBody(reader)
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;							r.Error = awserr.New("SerializationError",
0000000000000000000000000000000000000000;;								"failed to encode REST request",
0000000000000000000000000000000000000000;;								fmt.Errorf("unknown payload type %s", payload.Type()))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildHeader(header *http.Header, v reflect.Value, name string) error {
0000000000000000000000000000000000000000;;		str, err := convertType(v)
0000000000000000000000000000000000000000;;		if err == errValueNotSet {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return awserr.New("SerializationError", "failed to encode REST request", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header.Add(name, str)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildHeaderMap(header *http.Header, v reflect.Value, prefix string) error {
0000000000000000000000000000000000000000;;		for _, key := range v.MapKeys() {
0000000000000000000000000000000000000000;;			str, err := convertType(v.MapIndex(key))
0000000000000000000000000000000000000000;;			if err == errValueNotSet {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return awserr.New("SerializationError", "failed to encode REST request", err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			header.Add(prefix+key.String(), str)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildURI(u *url.URL, v reflect.Value, name string) error {
0000000000000000000000000000000000000000;;		value, err := convertType(v)
0000000000000000000000000000000000000000;;		if err == errValueNotSet {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return awserr.New("SerializationError", "failed to encode REST request", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.Path = strings.Replace(u.Path, "{"+name+"}", value, -1)
0000000000000000000000000000000000000000;;		u.Path = strings.Replace(u.Path, "{"+name+"+}", value, -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.RawPath = strings.Replace(u.RawPath, "{"+name+"}", EscapePath(value, true), -1)
0000000000000000000000000000000000000000;;		u.RawPath = strings.Replace(u.RawPath, "{"+name+"+}", EscapePath(value, false), -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildQueryString(query url.Values, v reflect.Value, name string) error {
0000000000000000000000000000000000000000;;		switch value := v.Interface().(type) {
0000000000000000000000000000000000000000;;		case []*string:
0000000000000000000000000000000000000000;;			for _, item := range value {
0000000000000000000000000000000000000000;;				query.Add(name, *item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case map[string]*string:
0000000000000000000000000000000000000000;;			for key, item := range value {
0000000000000000000000000000000000000000;;				query.Add(key, *item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case map[string][]*string:
0000000000000000000000000000000000000000;;			for key, items := range value {
0000000000000000000000000000000000000000;;				for _, item := range items {
0000000000000000000000000000000000000000;;					query.Add(key, *item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			str, err := convertType(v)
0000000000000000000000000000000000000000;;			if err == errValueNotSet {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return awserr.New("SerializationError", "failed to encode REST request", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			query.Set(name, str)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cleanPath(u *url.URL) {
0000000000000000000000000000000000000000;;		hasSlash := strings.HasSuffix(u.Path, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clean up path, removing duplicate `/`
0000000000000000000000000000000000000000;;		u.Path = path.Clean(u.Path)
0000000000000000000000000000000000000000;;		u.RawPath = path.Clean(u.RawPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasSlash && !strings.HasSuffix(u.Path, "/") {
0000000000000000000000000000000000000000;;			u.Path += "/"
0000000000000000000000000000000000000000;;			u.RawPath += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapePath escapes part of a URL path in Amazon style
0000000000000000000000000000000000000000;;	func EscapePath(path string, encodeSep bool) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		for i := 0; i < len(path); i++ {
0000000000000000000000000000000000000000;;			c := path[i]
0000000000000000000000000000000000000000;;			if noEscape[c] || (c == '/' && !encodeSep) {
0000000000000000000000000000000000000000;;				buf.WriteByte(c)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, "%%%02X", c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertType(v reflect.Value) (string, error) {
0000000000000000000000000000000000000000;;		v = reflect.Indirect(v)
0000000000000000000000000000000000000000;;		if !v.IsValid() {
0000000000000000000000000000000000000000;;			return "", errValueNotSet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var str string
0000000000000000000000000000000000000000;;		switch value := v.Interface().(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			str = value
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			str = base64.StdEncoding.EncodeToString(value)
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			str = strconv.FormatBool(value)
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			str = strconv.FormatInt(value, 10)
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			str = strconv.FormatFloat(value, 'f', -1, 64)
0000000000000000000000000000000000000000;;		case time.Time:
0000000000000000000000000000000000000000;;			str = value.UTC().Format(RFC822)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err := fmt.Errorf("Unsupported value for param %v (%s)", v.Interface(), v.Type())
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str, nil
0000000000000000000000000000000000000000;;	}
