0000000000000000000000000000000000000000;;	// Package xmlutil provides XML serialization of AWS requests and responses.
0000000000000000000000000000000000000000;;	package xmlutil
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/xml/xmlutil/build.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/xml/xmlutil/build.go][vendor/github.com/aws/aws-sdk-go/private/protocol/xml/xmlutil/build.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/private/protocol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildXML will serialize params into an xml.Encoder.
0000000000000000000000000000000000000000;;	// Error will be returned if the serialization of any of the params or nested values fails.
0000000000000000000000000000000000000000;;	func BuildXML(params interface{}, e *xml.Encoder) error {
0000000000000000000000000000000000000000;;		b := xmlBuilder{encoder: e, namespaces: map[string]string{}}
0000000000000000000000000000000000000000;;		root := NewXMLElement(xml.Name{})
0000000000000000000000000000000000000000;;		if err := b.buildValue(reflect.ValueOf(params), root, ""); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range root.Children {
0000000000000000000000000000000000000000;;			for _, v := range c {
0000000000000000000000000000000000000000;;				return StructToXML(e, v, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the reflection element of a value, if it is a pointer.
0000000000000000000000000000000000000000;;	func elemOf(value reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		for value.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			value = value.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A xmlBuilder serializes values from Go code to XML
0000000000000000000000000000000000000000;;	type xmlBuilder struct {
0000000000000000000000000000000000000000;;		encoder    *xml.Encoder
0000000000000000000000000000000000000000;;		namespaces map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildValue generic XMLNode builder for any type. Will build value for their specific type
0000000000000000000000000000000000000000;;	// struct, list, map, scalar.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Also takes a "type" tag value to set what type a value should be converted to XMLNode as. If
0000000000000000000000000000000000000000;;	// type is not provided reflect will be used to determine the value's type.
0000000000000000000000000000000000000000;;	func (b *xmlBuilder) buildValue(value reflect.Value, current *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		value = elemOf(value)
0000000000000000000000000000000000000000;;		if !value.IsValid() { // no need to handle zero values
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if tag.Get("location") != "" { // don't handle non-body location values
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := tag.Get("type")
0000000000000000000000000000000000000000;;		if t == "" {
0000000000000000000000000000000000000000;;			switch value.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				t = "structure"
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				t = "list"
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				t = "map"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case "structure":
0000000000000000000000000000000000000000;;			if field, ok := value.Type().FieldByName("_"); ok {
0000000000000000000000000000000000000000;;				tag = tag + reflect.StructTag(" ") + field.Tag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return b.buildStruct(value, current, tag)
0000000000000000000000000000000000000000;;		case "list":
0000000000000000000000000000000000000000;;			return b.buildList(value, current, tag)
0000000000000000000000000000000000000000;;		case "map":
0000000000000000000000000000000000000000;;			return b.buildMap(value, current, tag)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return b.buildScalar(value, current, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildStruct adds a struct and its fields to the current XMLNode. All fields any any nested
0000000000000000000000000000000000000000;;	// types are converted to XMLNodes also.
0000000000000000000000000000000000000000;;	func (b *xmlBuilder) buildStruct(value reflect.Value, current *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if !value.IsValid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldAdded := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unwrap payloads
0000000000000000000000000000000000000000;;		if payload := tag.Get("payload"); payload != "" {
0000000000000000000000000000000000000000;;			field, _ := value.Type().FieldByName(payload)
0000000000000000000000000000000000000000;;			tag = field.Tag
0000000000000000000000000000000000000000;;			value = elemOf(value.FieldByName(payload))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !value.IsValid() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		child := NewXMLElement(xml.Name{Local: tag.Get("locationName")})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// there is an xmlNamespace associated with this struct
0000000000000000000000000000000000000000;;		if prefix, uri := tag.Get("xmlPrefix"), tag.Get("xmlURI"); uri != "" {
0000000000000000000000000000000000000000;;			ns := xml.Attr{
0000000000000000000000000000000000000000;;				Name:  xml.Name{Local: "xmlns"},
0000000000000000000000000000000000000000;;				Value: uri,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if prefix != "" {
0000000000000000000000000000000000000000;;				b.namespaces[prefix] = uri // register the namespace
0000000000000000000000000000000000000000;;				ns.Name.Local = "xmlns:" + prefix
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			child.Attr = append(child.Attr, ns)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := value.Type()
0000000000000000000000000000000000000000;;		for i := 0; i < value.NumField(); i++ {
0000000000000000000000000000000000000000;;			member := elemOf(value.Field(i))
0000000000000000000000000000000000000000;;			field := t.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if field.PkgPath != "" {
0000000000000000000000000000000000000000;;				continue // ignore unexported fields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if field.Tag.Get("ignore") != "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mTag := field.Tag
0000000000000000000000000000000000000000;;			if mTag.Get("location") != "" { // skip non-body members
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if protocol.CanSetIdempotencyToken(value.Field(i), field) {
0000000000000000000000000000000000000000;;				token := protocol.GetIdempotencyToken()
0000000000000000000000000000000000000000;;				member = reflect.ValueOf(token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			memberName := mTag.Get("locationName")
0000000000000000000000000000000000000000;;			if memberName == "" {
0000000000000000000000000000000000000000;;				memberName = field.Name
0000000000000000000000000000000000000000;;				mTag = reflect.StructTag(string(mTag) + ` locationName:"` + memberName + `"`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := b.buildValue(member, child, mTag); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fieldAdded = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fieldAdded { // only append this child if we have one ore more valid members
0000000000000000000000000000000000000000;;			current.AddChild(child)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildList adds the value's list items to the current XMLNode as children nodes. All
0000000000000000000000000000000000000000;;	// nested values in the list are converted to XMLNodes also.
0000000000000000000000000000000000000000;;	func (b *xmlBuilder) buildList(value reflect.Value, current *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if value.IsNil() { // don't build omitted lists
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for unflattened list member
0000000000000000000000000000000000000000;;		flattened := tag.Get("flattened") != ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xname := xml.Name{Local: tag.Get("locationName")}
0000000000000000000000000000000000000000;;		if flattened {
0000000000000000000000000000000000000000;;			for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;				child := NewXMLElement(xname)
0000000000000000000000000000000000000000;;				current.AddChild(child)
0000000000000000000000000000000000000000;;				if err := b.buildValue(value.Index(i), child, ""); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			list := NewXMLElement(xname)
0000000000000000000000000000000000000000;;			current.AddChild(list)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;				iname := tag.Get("locationNameList")
0000000000000000000000000000000000000000;;				if iname == "" {
0000000000000000000000000000000000000000;;					iname = "member"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				child := NewXMLElement(xml.Name{Local: iname})
0000000000000000000000000000000000000000;;				list.AddChild(child)
0000000000000000000000000000000000000000;;				if err := b.buildValue(value.Index(i), child, ""); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildMap adds the value's key/value pairs to the current XMLNode as children nodes. All
0000000000000000000000000000000000000000;;	// nested values in the map are converted to XMLNodes also.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Error will be returned if it is unable to build the map's values into XMLNodes
0000000000000000000000000000000000000000;;	func (b *xmlBuilder) buildMap(value reflect.Value, current *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		if value.IsNil() { // don't build omitted maps
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maproot := NewXMLElement(xml.Name{Local: tag.Get("locationName")})
0000000000000000000000000000000000000000;;		current.AddChild(maproot)
0000000000000000000000000000000000000000;;		current = maproot
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kname, vname := "key", "value"
0000000000000000000000000000000000000000;;		if n := tag.Get("locationNameKey"); n != "" {
0000000000000000000000000000000000000000;;			kname = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n := tag.Get("locationNameValue"); n != "" {
0000000000000000000000000000000000000000;;			vname = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sorting is not required for compliance, but it makes testing easier
0000000000000000000000000000000000000000;;		keys := make([]string, value.Len())
0000000000000000000000000000000000000000;;		for i, k := range value.MapKeys() {
0000000000000000000000000000000000000000;;			keys[i] = k.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			v := value.MapIndex(reflect.ValueOf(k))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapcur := current
0000000000000000000000000000000000000000;;			if tag.Get("flattened") == "" { // add "entry" tag to non-flat maps
0000000000000000000000000000000000000000;;				child := NewXMLElement(xml.Name{Local: "entry"})
0000000000000000000000000000000000000000;;				mapcur.AddChild(child)
0000000000000000000000000000000000000000;;				mapcur = child
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kchild := NewXMLElement(xml.Name{Local: kname})
0000000000000000000000000000000000000000;;			kchild.Text = k
0000000000000000000000000000000000000000;;			vchild := NewXMLElement(xml.Name{Local: vname})
0000000000000000000000000000000000000000;;			mapcur.AddChild(kchild)
0000000000000000000000000000000000000000;;			mapcur.AddChild(vchild)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := b.buildValue(v, vchild, ""); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildScalar will convert the value into a string and append it as a attribute or child
0000000000000000000000000000000000000000;;	// of the current XMLNode.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The value will be added as an attribute if tag contains a "xmlAttribute" attribute value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Error will be returned if the value type is unsupported.
0000000000000000000000000000000000000000;;	func (b *xmlBuilder) buildScalar(value reflect.Value, current *XMLNode, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		var str string
0000000000000000000000000000000000000000;;		switch converted := value.Interface().(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			str = converted
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			if !value.IsNil() {
0000000000000000000000000000000000000000;;				str = base64.StdEncoding.EncodeToString(converted)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			str = strconv.FormatBool(converted)
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			str = strconv.FormatInt(converted, 10)
0000000000000000000000000000000000000000;;		case int:
0000000000000000000000000000000000000000;;			str = strconv.Itoa(converted)
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			str = strconv.FormatFloat(converted, 'f', -1, 64)
0000000000000000000000000000000000000000;;		case float32:
0000000000000000000000000000000000000000;;			str = strconv.FormatFloat(float64(converted), 'f', -1, 32)
0000000000000000000000000000000000000000;;		case time.Time:
0000000000000000000000000000000000000000;;			const ISO8601UTC = "2006-01-02T15:04:05Z"
0000000000000000000000000000000000000000;;			str = converted.UTC().Format(ISO8601UTC)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported value for param %s: %v (%s)",
0000000000000000000000000000000000000000;;				tag.Get("locationName"), value.Interface(), value.Type().Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xname := xml.Name{Local: tag.Get("locationName")}
0000000000000000000000000000000000000000;;		if tag.Get("xmlAttribute") != "" { // put into current node's attribute list
0000000000000000000000000000000000000000;;			attr := xml.Attr{Name: xname, Value: str}
0000000000000000000000000000000000000000;;			current.Attr = append(current.Attr, attr)
0000000000000000000000000000000000000000;;		} else { // regular text node
0000000000000000000000000000000000000000;;			current.AddChild(&XMLNode{Name: xname, Text: str})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
