0000000000000000000000000000000000000000;;	package queryutil
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/query/queryutil/queryutil.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/internal/protocol/query/queryutil/queryutil.go][vendor/github.com/aws/aws-sdk-go/private/protocol/query/queryutil/queryutil.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/private/protocol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parses an object i and fills a url.Values object. The isEC2 flag
0000000000000000000000000000000000000000;;	// indicates if this is the EC2 Query sub-protocol.
0000000000000000000000000000000000000000;;	func Parse(body url.Values, i interface{}, isEC2 bool) error {
0000000000000000000000000000000000000000;;		q := queryParser{isEC2: isEC2}
0000000000000000000000000000000000000000;;		return q.parseValue(body, reflect.ValueOf(i), "", "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func elemOf(value reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		for value.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			value = value.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type queryParser struct {
0000000000000000000000000000000000000000;;		isEC2 bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *queryParser) parseValue(v url.Values, value reflect.Value, prefix string, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		value = elemOf(value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no need to handle zero values
0000000000000000000000000000000000000000;;		if !value.IsValid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := tag.Get("type")
0000000000000000000000000000000000000000;;		if t == "" {
0000000000000000000000000000000000000000;;			switch value.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				t = "structure"
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				t = "list"
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				t = "map"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case "structure":
0000000000000000000000000000000000000000;;			return q.parseStruct(v, value, prefix)
0000000000000000000000000000000000000000;;		case "list":
0000000000000000000000000000000000000000;;			return q.parseList(v, value, prefix, tag)
0000000000000000000000000000000000000000;;		case "map":
0000000000000000000000000000000000000000;;			return q.parseMap(v, value, prefix, tag)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return q.parseScalar(v, value, prefix, tag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *queryParser) parseStruct(v url.Values, value reflect.Value, prefix string) error {
0000000000000000000000000000000000000000;;		if !value.IsValid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := value.Type()
0000000000000000000000000000000000000000;;		for i := 0; i < value.NumField(); i++ {
0000000000000000000000000000000000000000;;			elemValue := elemOf(value.Field(i))
0000000000000000000000000000000000000000;;			field := t.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if field.PkgPath != "" {
0000000000000000000000000000000000000000;;				continue // ignore unexported fields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if field.Tag.Get("ignore") != "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if protocol.CanSetIdempotencyToken(value.Field(i), field) {
0000000000000000000000000000000000000000;;				token := protocol.GetIdempotencyToken()
0000000000000000000000000000000000000000;;				elemValue = reflect.ValueOf(token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var name string
0000000000000000000000000000000000000000;;			if q.isEC2 {
0000000000000000000000000000000000000000;;				name = field.Tag.Get("queryName")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				if field.Tag.Get("flattened") != "" && field.Tag.Get("locationNameList") != "" {
0000000000000000000000000000000000000000;;					name = field.Tag.Get("locationNameList")
0000000000000000000000000000000000000000;;				} else if locName := field.Tag.Get("locationName"); locName != "" {
0000000000000000000000000000000000000000;;					name = locName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if name != "" && q.isEC2 {
0000000000000000000000000000000000000000;;					name = strings.ToUpper(name[0:1]) + name[1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				name = field.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if prefix != "" {
0000000000000000000000000000000000000000;;				name = prefix + "." + name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := q.parseValue(v, elemValue, name, field.Tag); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *queryParser) parseList(v url.Values, value reflect.Value, prefix string, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		// If it's empty, generate an empty value
0000000000000000000000000000000000000000;;		if !value.IsNil() && value.Len() == 0 {
0000000000000000000000000000000000000000;;			v.Set(prefix, "")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for unflattened list member
0000000000000000000000000000000000000000;;		if !q.isEC2 && tag.Get("flattened") == "" {
0000000000000000000000000000000000000000;;			prefix += ".member"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;			slicePrefix := prefix
0000000000000000000000000000000000000000;;			if slicePrefix == "" {
0000000000000000000000000000000000000000;;				slicePrefix = strconv.Itoa(i + 1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				slicePrefix = slicePrefix + "." + strconv.Itoa(i+1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := q.parseValue(v, value.Index(i), slicePrefix, ""); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *queryParser) parseMap(v url.Values, value reflect.Value, prefix string, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		// If it's empty, generate an empty value
0000000000000000000000000000000000000000;;		if !value.IsNil() && value.Len() == 0 {
0000000000000000000000000000000000000000;;			v.Set(prefix, "")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for unflattened list member
0000000000000000000000000000000000000000;;		if !q.isEC2 && tag.Get("flattened") == "" {
0000000000000000000000000000000000000000;;			prefix += ".entry"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sort keys for improved serialization consistency.
0000000000000000000000000000000000000000;;		// this is not strictly necessary for protocol support.
0000000000000000000000000000000000000000;;		mapKeyValues := value.MapKeys()
0000000000000000000000000000000000000000;;		mapKeys := map[string]reflect.Value{}
0000000000000000000000000000000000000000;;		mapKeyNames := make([]string, len(mapKeyValues))
0000000000000000000000000000000000000000;;		for i, mapKey := range mapKeyValues {
0000000000000000000000000000000000000000;;			name := mapKey.String()
0000000000000000000000000000000000000000;;			mapKeys[name] = mapKey
0000000000000000000000000000000000000000;;			mapKeyNames[i] = name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(mapKeyNames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, mapKeyName := range mapKeyNames {
0000000000000000000000000000000000000000;;			mapKey := mapKeys[mapKeyName]
0000000000000000000000000000000000000000;;			mapValue := value.MapIndex(mapKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kname := tag.Get("locationNameKey")
0000000000000000000000000000000000000000;;			if kname == "" {
0000000000000000000000000000000000000000;;				kname = "key"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vname := tag.Get("locationNameValue")
0000000000000000000000000000000000000000;;			if vname == "" {
0000000000000000000000000000000000000000;;				vname = "value"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// serialize key
0000000000000000000000000000000000000000;;			var keyName string
0000000000000000000000000000000000000000;;			if prefix == "" {
0000000000000000000000000000000000000000;;				keyName = strconv.Itoa(i+1) + "." + kname
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				keyName = prefix + "." + strconv.Itoa(i+1) + "." + kname
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := q.parseValue(v, mapKey, keyName, ""); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// serialize value
0000000000000000000000000000000000000000;;			var valueName string
0000000000000000000000000000000000000000;;			if prefix == "" {
0000000000000000000000000000000000000000;;				valueName = strconv.Itoa(i+1) + "." + vname
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				valueName = prefix + "." + strconv.Itoa(i+1) + "." + vname
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := q.parseValue(v, mapValue, valueName, ""); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *queryParser) parseScalar(v url.Values, r reflect.Value, name string, tag reflect.StructTag) error {
0000000000000000000000000000000000000000;;		switch value := r.Interface().(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			v.Set(name, value)
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			if !r.IsNil() {
0000000000000000000000000000000000000000;;				v.Set(name, base64.StdEncoding.EncodeToString(value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			v.Set(name, strconv.FormatBool(value))
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			v.Set(name, strconv.FormatInt(value, 10))
0000000000000000000000000000000000000000;;		case int:
0000000000000000000000000000000000000000;;			v.Set(name, strconv.Itoa(value))
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			v.Set(name, strconv.FormatFloat(value, 'f', -1, 64))
0000000000000000000000000000000000000000;;		case float32:
0000000000000000000000000000000000000000;;			v.Set(name, strconv.FormatFloat(float64(value), 'f', -1, 32))
0000000000000000000000000000000000000000;;		case time.Time:
0000000000000000000000000000000000000000;;			const ISO8601UTC = "2006-01-02T15:04:05Z"
0000000000000000000000000000000000000000;;			v.Set(name, value.UTC().Format(ISO8601UTC))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported value for param %s: %v (%s)", name, r.Interface(), r.Type().Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
