0000000000000000000000000000000000000000;;	package awsutil
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/awsutil/copy.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/awsutil/copy.go][vendor/github.com/aws/aws-sdk-go/aws/awsutil/copy.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy deeply copies a src structure to dst. Useful for copying request and
0000000000000000000000000000000000000000;;	// response structures.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Can copy between structs of different type, but will only copy fields which
0000000000000000000000000000000000000000;;	// are assignable, and exist in both structs. Fields which are not assignable,
0000000000000000000000000000000000000000;;	// or do not exist in both structs are ignored.
0000000000000000000000000000000000000000;;	func Copy(dst, src interface{}) {
0000000000000000000000000000000000000000;;		dstval := reflect.ValueOf(dst)
0000000000000000000000000000000000000000;;		if !dstval.IsValid() {
0000000000000000000000000000000000000000;;			panic("Copy dst cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rcopy(dstval, reflect.ValueOf(src), true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyOf returns a copy of src while also allocating the memory for dst.
0000000000000000000000000000000000000000;;	// src must be a pointer type or this operation will fail.
0000000000000000000000000000000000000000;;	func CopyOf(src interface{}) (dst interface{}) {
0000000000000000000000000000000000000000;;		dsti := reflect.New(reflect.TypeOf(src).Elem())
0000000000000000000000000000000000000000;;		dst = dsti.Interface()
0000000000000000000000000000000000000000;;		rcopy(dsti, reflect.ValueOf(src), true)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rcopy performs a recursive copy of values from the source to destination.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// root is used to skip certain aspects of the copy which are not valid
0000000000000000000000000000000000000000;;	// for the root node of a object.
0000000000000000000000000000000000000000;;	func rcopy(dst, src reflect.Value, root bool) {
0000000000000000000000000000000000000000;;		if !src.IsValid() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch src.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if _, ok := src.Interface().(io.Reader); ok {
0000000000000000000000000000000000000000;;				if dst.Kind() == reflect.Ptr && dst.Elem().CanSet() {
0000000000000000000000000000000000000000;;					dst.Elem().Set(src)
0000000000000000000000000000000000000000;;				} else if dst.CanSet() {
0000000000000000000000000000000000000000;;					dst.Set(src)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e := src.Type().Elem()
0000000000000000000000000000000000000000;;				if dst.CanSet() && !src.IsNil() {
0000000000000000000000000000000000000000;;					if _, ok := src.Interface().(*time.Time); !ok {
0000000000000000000000000000000000000000;;						dst.Set(reflect.New(e))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						tempValue := reflect.New(e)
0000000000000000000000000000000000000000;;						tempValue.Elem().Set(src.Elem())
0000000000000000000000000000000000000000;;						// Sets time.Time's unexported values
0000000000000000000000000000000000000000;;						dst.Set(tempValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if src.Elem().IsValid() {
0000000000000000000000000000000000000000;;					// Keep the current root state since the depth hasn't changed
0000000000000000000000000000000000000000;;					rcopy(dst.Elem(), src.Elem(), root)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			t := dst.Type()
0000000000000000000000000000000000000000;;			for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;				name := t.Field(i).Name
0000000000000000000000000000000000000000;;				srcVal := src.FieldByName(name)
0000000000000000000000000000000000000000;;				dstVal := dst.FieldByName(name)
0000000000000000000000000000000000000000;;				if srcVal.IsValid() && dstVal.CanSet() {
0000000000000000000000000000000000000000;;					rcopy(dstVal, srcVal, false)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s := reflect.MakeSlice(src.Type(), src.Len(), src.Cap())
0000000000000000000000000000000000000000;;			dst.Set(s)
0000000000000000000000000000000000000000;;			for i := 0; i < src.Len(); i++ {
0000000000000000000000000000000000000000;;				rcopy(dst.Index(i), src.Index(i), false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s := reflect.MakeMap(src.Type())
0000000000000000000000000000000000000000;;			dst.Set(s)
0000000000000000000000000000000000000000;;			for _, k := range src.MapKeys() {
0000000000000000000000000000000000000000;;				v := src.MapIndex(k)
0000000000000000000000000000000000000000;;				v2 := reflect.New(v.Type()).Elem()
0000000000000000000000000000000000000000;;				rcopy(v2, v, false)
0000000000000000000000000000000000000000;;				dst.SetMapIndex(k, v2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Assign the value if possible. If its not assignable, the value would
0000000000000000000000000000000000000000;;			// need to be converted and the impact of that may be unexpected, or is
0000000000000000000000000000000000000000;;			// not compatible with the dst type.
0000000000000000000000000000000000000000;;			if src.Type().AssignableTo(dst.Type()) {
0000000000000000000000000000000000000000;;				dst.Set(src)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
