0000000000000000000000000000000000000000;;	package awsutil
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/awsutil/path_value.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/awsutil/path_value.go][vendor/github.com/aws/aws-sdk-go/aws/awsutil/path_value.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/jmespath/go-jmespath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var indexRe = regexp.MustCompile(`(.+)\[(-?\d+)?\]$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rValuesAtPath returns a slice of values found in value v. The values
0000000000000000000000000000000000000000;;	// in v are explored recursively so all nested values are collected.
0000000000000000000000000000000000000000;;	func rValuesAtPath(v interface{}, path string, createPath, caseSensitive, nilTerm bool) []reflect.Value {
0000000000000000000000000000000000000000;;		pathparts := strings.Split(path, "||")
0000000000000000000000000000000000000000;;		if len(pathparts) > 1 {
0000000000000000000000000000000000000000;;			for _, pathpart := range pathparts {
0000000000000000000000000000000000000000;;				vals := rValuesAtPath(v, pathpart, createPath, caseSensitive, nilTerm)
0000000000000000000000000000000000000000;;				if len(vals) > 0 {
0000000000000000000000000000000000000000;;					return vals
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		values := []reflect.Value{reflect.Indirect(reflect.ValueOf(v))}
0000000000000000000000000000000000000000;;		components := strings.Split(path, ".")
0000000000000000000000000000000000000000;;		for len(values) > 0 && len(components) > 0 {
0000000000000000000000000000000000000000;;			var index *int64
0000000000000000000000000000000000000000;;			var indexStar bool
0000000000000000000000000000000000000000;;			c := strings.TrimSpace(components[0])
0000000000000000000000000000000000000000;;			if c == "" { // no actual component, illegal syntax
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if caseSensitive && c != "*" && strings.ToLower(c[0:1]) == c[0:1] {
0000000000000000000000000000000000000000;;				// TODO normalize case for user
0000000000000000000000000000000000000000;;				return nil // don't support unexported fields
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// parse this component
0000000000000000000000000000000000000000;;			if m := indexRe.FindStringSubmatch(c); m != nil {
0000000000000000000000000000000000000000;;				c = m[1]
0000000000000000000000000000000000000000;;				if m[2] == "" {
0000000000000000000000000000000000000000;;					index = nil
0000000000000000000000000000000000000000;;					indexStar = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					i, _ := strconv.ParseInt(m[2], 10, 32)
0000000000000000000000000000000000000000;;					index = &i
0000000000000000000000000000000000000000;;					indexStar = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nextvals := []reflect.Value{}
0000000000000000000000000000000000000000;;			for _, value := range values {
0000000000000000000000000000000000000000;;				// pull component name out of struct member
0000000000000000000000000000000000000000;;				if value.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if c == "*" { // pull all members
0000000000000000000000000000000000000000;;					for i := 0; i < value.NumField(); i++ {
0000000000000000000000000000000000000000;;						if f := reflect.Indirect(value.Field(i)); f.IsValid() {
0000000000000000000000000000000000000000;;							nextvals = append(nextvals, f)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				value = value.FieldByNameFunc(func(name string) bool {
0000000000000000000000000000000000000000;;					if c == name {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					} else if !caseSensitive && strings.ToLower(name) == strings.ToLower(c) {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if nilTerm && value.Kind() == reflect.Ptr && len(components[1:]) == 0 {
0000000000000000000000000000000000000000;;					if !value.IsNil() {
0000000000000000000000000000000000000000;;						value.Set(reflect.Zero(value.Type()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return []reflect.Value{value}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if createPath && value.Kind() == reflect.Ptr && value.IsNil() {
0000000000000000000000000000000000000000;;					// TODO if the value is the terminus it should not be created
0000000000000000000000000000000000000000;;					// if the value to be set to its position is nil.
0000000000000000000000000000000000000000;;					value.Set(reflect.New(value.Type().Elem()))
0000000000000000000000000000000000000000;;					value = value.Elem()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value = reflect.Indirect(value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if value.Kind() == reflect.Slice || value.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;					if !createPath && value.IsNil() {
0000000000000000000000000000000000000000;;						value = reflect.ValueOf(nil)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if value.IsValid() {
0000000000000000000000000000000000000000;;					nextvals = append(nextvals, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			values = nextvals
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if indexStar || index != nil {
0000000000000000000000000000000000000000;;				nextvals = []reflect.Value{}
0000000000000000000000000000000000000000;;				for _, valItem := range values {
0000000000000000000000000000000000000000;;					value := reflect.Indirect(valItem)
0000000000000000000000000000000000000000;;					if value.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if indexStar { // grab all indices
0000000000000000000000000000000000000000;;						for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;							idx := reflect.Indirect(value.Index(i))
0000000000000000000000000000000000000000;;							if idx.IsValid() {
0000000000000000000000000000000000000000;;								nextvals = append(nextvals, idx)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// pull out index
0000000000000000000000000000000000000000;;					i := int(*index)
0000000000000000000000000000000000000000;;					if i >= value.Len() { // check out of bounds
0000000000000000000000000000000000000000;;						if createPath {
0000000000000000000000000000000000000000;;							// TODO resize slice
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if i < 0 { // support negative indexing
0000000000000000000000000000000000000000;;						i = value.Len() + i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					value = reflect.Indirect(value.Index(i))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if value.Kind() == reflect.Slice || value.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;						if !createPath && value.IsNil() {
0000000000000000000000000000000000000000;;							value = reflect.ValueOf(nil)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if value.IsValid() {
0000000000000000000000000000000000000000;;						nextvals = append(nextvals, value)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				values = nextvals
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			components = components[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return values
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValuesAtPath returns a list of values at the case insensitive lexical
0000000000000000000000000000000000000000;;	// path inside of a structure.
0000000000000000000000000000000000000000;;	func ValuesAtPath(i interface{}, path string) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		result, err := jmespath.Search(path, i)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(result)
0000000000000000000000000000000000000000;;		if !v.IsValid() || (v.Kind() == reflect.Ptr && v.IsNil()) {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s, ok := result.([]interface{}); ok {
0000000000000000000000000000000000000000;;			return s, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Map && v.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;			out := make([]interface{}, v.Len())
0000000000000000000000000000000000000000;;			for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;				out[i] = v.Index(i).Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []interface{}{result}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetValueAtPath sets a value at the case insensitive lexical path inside
0000000000000000000000000000000000000000;;	// of a structure.
0000000000000000000000000000000000000000;;	func SetValueAtPath(i interface{}, path string, v interface{}) {
0000000000000000000000000000000000000000;;		if rvals := rValuesAtPath(i, path, true, false, v == nil); rvals != nil {
0000000000000000000000000000000000000000;;			for _, rval := range rvals {
0000000000000000000000000000000000000000;;				if rval.Kind() == reflect.Ptr && rval.IsNil() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				setValue(rval, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setValue(dstVal reflect.Value, src interface{}) {
0000000000000000000000000000000000000000;;		if dstVal.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			dstVal = reflect.Indirect(dstVal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srcVal := reflect.ValueOf(src)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !srcVal.IsValid() { // src is literal nil
0000000000000000000000000000000000000000;;			if dstVal.CanAddr() {
0000000000000000000000000000000000000000;;				// Convert to pointer so that pointer's value can be nil'ed
0000000000000000000000000000000000000000;;				//                     dstVal = dstVal.Addr()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dstVal.Set(reflect.Zero(dstVal.Type()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else if srcVal.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if srcVal.IsNil() {
0000000000000000000000000000000000000000;;				srcVal = reflect.Zero(dstVal.Type())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				srcVal = reflect.ValueOf(src).Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dstVal.Set(srcVal)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dstVal.Set(srcVal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
