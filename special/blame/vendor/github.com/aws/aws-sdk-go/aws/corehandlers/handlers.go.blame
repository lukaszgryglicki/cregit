0000000000000000000000000000000000000000;;	package corehandlers
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/handler_functions.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/handler_functions.go][vendor/github.com/aws/aws-sdk-go/aws/corehandlers/handlers.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/credentials"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface for matching types which also have a Len method.
0000000000000000000000000000000000000000;;	type lener interface {
0000000000000000000000000000000000000000;;		Len() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildContentLengthHandler builds the content length of a request based on the body,
0000000000000000000000000000000000000000;;	// or will use the HTTPRequest.Header's "Content-Length" if defined. If unable
0000000000000000000000000000000000000000;;	// to determine request body length and no "Content-Length" was specified it will panic.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Content-Length will only be aded to the request if the length of the body
0000000000000000000000000000000000000000;;	// is greater than 0. If the body is empty or the current `Content-Length`
0000000000000000000000000000000000000000;;	// header is <= 0, the header will also be stripped.
0000000000000000000000000000000000000000;;	var BuildContentLengthHandler = request.NamedHandler{Name: "core.BuildContentLengthHandler", Fn: func(r *request.Request) {
0000000000000000000000000000000000000000;;		var length int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if slength := r.HTTPRequest.Header.Get("Content-Length"); slength != "" {
0000000000000000000000000000000000000000;;			length, _ = strconv.ParseInt(slength, 10, 64)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			switch body := r.Body.(type) {
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				length = 0
0000000000000000000000000000000000000000;;			case lener:
0000000000000000000000000000000000000000;;				length = int64(body.Len())
0000000000000000000000000000000000000000;;			case io.Seeker:
0000000000000000000000000000000000000000;;				r.BodyStart, _ = body.Seek(0, 1)
0000000000000000000000000000000000000000;;				end, _ := body.Seek(0, 2)
0000000000000000000000000000000000000000;;				body.Seek(r.BodyStart, 0) // make sure to seek back to original location
0000000000000000000000000000000000000000;;				length = end - r.BodyStart
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("Cannot get length of body, must provide `ContentLength`")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if length > 0 {
0000000000000000000000000000000000000000;;			r.HTTPRequest.ContentLength = length
0000000000000000000000000000000000000000;;			r.HTTPRequest.Header.Set("Content-Length", fmt.Sprintf("%d", length))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.HTTPRequest.ContentLength = 0
0000000000000000000000000000000000000000;;			r.HTTPRequest.Header.Del("Content-Length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SDKVersionUserAgentHandler is a request handler for adding the SDK Version to the user agent.
0000000000000000000000000000000000000000;;	var SDKVersionUserAgentHandler = request.NamedHandler{
0000000000000000000000000000000000000000;;		Name: "core.SDKVersionUserAgentHandler",
0000000000000000000000000000000000000000;;		Fn: request.MakeAddToUserAgentHandler(aws.SDKName, aws.SDKVersion,
0000000000000000000000000000000000000000;;			runtime.Version(), runtime.GOOS, runtime.GOARCH),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var reStatusCode = regexp.MustCompile(`^(\d{3})`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateReqSigHandler is a request handler to ensure that the request's
0000000000000000000000000000000000000000;;	// signature doesn't expire before it is sent. This can happen when a request
0000000000000000000000000000000000000000;;	// is built and signed signficantly before it is sent. Or significant delays
0000000000000000000000000000000000000000;;	// occur whne retrying requests that would cause the signature to expire.
0000000000000000000000000000000000000000;;	var ValidateReqSigHandler = request.NamedHandler{
0000000000000000000000000000000000000000;;		Name: "core.ValidateReqSigHandler",
0000000000000000000000000000000000000000;;		Fn: func(r *request.Request) {
0000000000000000000000000000000000000000;;			// Unsigned requests are not signed
0000000000000000000000000000000000000000;;			if r.Config.Credentials == credentials.AnonymousCredentials {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			signedTime := r.Time
0000000000000000000000000000000000000000;;			if !r.LastSignedAt.IsZero() {
0000000000000000000000000000000000000000;;				signedTime = r.LastSignedAt
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// 10 minutes to allow for some clock skew/delays in transmission.
0000000000000000000000000000000000000000;;			// Would be improved with aws/aws-sdk-go#423
0000000000000000000000000000000000000000;;			if signedTime.Add(10 * time.Minute).After(time.Now()) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Println("request expired, resigning")
0000000000000000000000000000000000000000;;			r.Sign()
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendHandler is a request handler to send service request using HTTP client.
0000000000000000000000000000000000000000;;	var SendHandler = request.NamedHandler{Name: "core.SendHandler", Fn: func(r *request.Request) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		r.HTTPResponse, err = r.Config.HTTPClient.Do(r.HTTPRequest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Prevent leaking if an HTTPResponse was returned. Clean up
0000000000000000000000000000000000000000;;			// the body.
0000000000000000000000000000000000000000;;			if r.HTTPResponse != nil {
0000000000000000000000000000000000000000;;				r.HTTPResponse.Body.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Capture the case where url.Error is returned for error processing
0000000000000000000000000000000000000000;;			// response. e.g. 301 without location header comes back as string
0000000000000000000000000000000000000000;;			// error and r.HTTPResponse is nil. Other url redirect errors will
0000000000000000000000000000000000000000;;			// comeback in a similar method.
0000000000000000000000000000000000000000;;			if e, ok := err.(*url.Error); ok && e.Err != nil {
0000000000000000000000000000000000000000;;				if s := reStatusCode.FindStringSubmatch(e.Err.Error()); s != nil {
0000000000000000000000000000000000000000;;					code, _ := strconv.ParseInt(s[1], 10, 64)
0000000000000000000000000000000000000000;;					r.HTTPResponse = &http.Response{
0000000000000000000000000000000000000000;;						StatusCode: int(code),
0000000000000000000000000000000000000000;;						Status:     http.StatusText(int(code)),
0000000000000000000000000000000000000000;;						Body:       ioutil.NopCloser(bytes.NewReader([]byte{})),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.HTTPResponse == nil {
0000000000000000000000000000000000000000;;				// Add a dummy request response object to ensure the HTTPResponse
0000000000000000000000000000000000000000;;				// value is consistent.
0000000000000000000000000000000000000000;;				r.HTTPResponse = &http.Response{
0000000000000000000000000000000000000000;;					StatusCode: int(0),
0000000000000000000000000000000000000000;;					Status:     http.StatusText(int(0)),
0000000000000000000000000000000000000000;;					Body:       ioutil.NopCloser(bytes.NewReader([]byte{})),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Catch all other request errors.
0000000000000000000000000000000000000000;;			r.Error = awserr.New("RequestError", "send request failed", err)
0000000000000000000000000000000000000000;;			r.Retryable = aws.Bool(true) // network errors are retryable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateResponseHandler is a request handler to validate service response.
0000000000000000000000000000000000000000;;	var ValidateResponseHandler = request.NamedHandler{Name: "core.ValidateResponseHandler", Fn: func(r *request.Request) {
0000000000000000000000000000000000000000;;		if r.HTTPResponse.StatusCode == 0 || r.HTTPResponse.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			// this may be replaced by an UnmarshalError handler
0000000000000000000000000000000000000000;;			r.Error = awserr.New("UnknownError", "unknown error", nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AfterRetryHandler performs final checks to determine if the request should
0000000000000000000000000000000000000000;;	// be retried and how long to delay.
0000000000000000000000000000000000000000;;	var AfterRetryHandler = request.NamedHandler{Name: "core.AfterRetryHandler", Fn: func(r *request.Request) {
0000000000000000000000000000000000000000;;		// If one of the other handlers already set the retry state
0000000000000000000000000000000000000000;;		// we don't want to override it based on the service's state
0000000000000000000000000000000000000000;;		if r.Retryable == nil {
0000000000000000000000000000000000000000;;			r.Retryable = aws.Bool(r.ShouldRetry(r))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.WillRetry() {
0000000000000000000000000000000000000000;;			r.RetryDelay = r.RetryRules(r)
0000000000000000000000000000000000000000;;			r.Config.SleepDelay(r.RetryDelay)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// when the expired token exception occurs the credentials
0000000000000000000000000000000000000000;;			// need to be expired locally so that the next request to
0000000000000000000000000000000000000000;;			// get credentials will trigger a credentials refresh.
0000000000000000000000000000000000000000;;			if r.IsErrorExpired() {
0000000000000000000000000000000000000000;;				r.Config.Credentials.Expire()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.RetryCount++
0000000000000000000000000000000000000000;;			r.Error = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateEndpointHandler is a request handler to validate a request had the
0000000000000000000000000000000000000000;;	// appropriate Region and Endpoint set. Will set r.Error if the endpoint or
0000000000000000000000000000000000000000;;	// region is not valid.
0000000000000000000000000000000000000000;;	var ValidateEndpointHandler = request.NamedHandler{Name: "core.ValidateEndpointHandler", Fn: func(r *request.Request) {
0000000000000000000000000000000000000000;;		if r.ClientInfo.SigningRegion == "" && aws.StringValue(r.Config.Region) == "" {
0000000000000000000000000000000000000000;;			r.Error = aws.ErrMissingRegion
0000000000000000000000000000000000000000;;		} else if r.ClientInfo.Endpoint == "" {
0000000000000000000000000000000000000000;;			r.Error = aws.ErrMissingEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}}
