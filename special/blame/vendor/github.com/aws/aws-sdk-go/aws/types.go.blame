0000000000000000000000000000000000000000;;	package aws
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/types.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/types.go][vendor/github.com/aws/aws-sdk-go/aws/types.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadSeekCloser wraps a io.Reader returning a ReaderSeekerCloser. Should
0000000000000000000000000000000000000000;;	// only be used with an io.Reader that is also an io.Seeker. Doing so may
0000000000000000000000000000000000000000;;	// cause request signature errors, or request body's not sent for GET, HEAD
0000000000000000000000000000000000000000;;	// and DELETE HTTP methods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: Should only be used with io.ReadSeeker. If using for
0000000000000000000000000000000000000000;;	// S3 PutObject to stream content use s3manager.Uploader instead.
0000000000000000000000000000000000000000;;	func ReadSeekCloser(r io.Reader) ReaderSeekerCloser {
0000000000000000000000000000000000000000;;		return ReaderSeekerCloser{r}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReaderSeekerCloser represents a reader that can also delegate io.Seeker and
0000000000000000000000000000000000000000;;	// io.Closer interfaces to the underlying object if they are available.
0000000000000000000000000000000000000000;;	type ReaderSeekerCloser struct {
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads from the reader up to size of p. The number of bytes read, and
0000000000000000000000000000000000000000;;	// error if it occurred will be returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the reader is not an io.Reader zero bytes read, and nil error will be returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Performs the same functionality as io.Reader Read
0000000000000000000000000000000000000000;;	func (r ReaderSeekerCloser) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		switch t := r.r.(type) {
0000000000000000000000000000000000000000;;		case io.Reader:
0000000000000000000000000000000000000000;;			return t.Read(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seek sets the offset for the next Read to offset, interpreted according to
0000000000000000000000000000000000000000;;	// whence: 0 means relative to the origin of the file, 1 means relative to the
0000000000000000000000000000000000000000;;	// current offset, and 2 means relative to the end. Seek returns the new offset
0000000000000000000000000000000000000000;;	// and an error, if any.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the ReaderSeekerCloser is not an io.Seeker nothing will be done.
0000000000000000000000000000000000000000;;	func (r ReaderSeekerCloser) Seek(offset int64, whence int) (int64, error) {
0000000000000000000000000000000000000000;;		switch t := r.r.(type) {
0000000000000000000000000000000000000000;;		case io.Seeker:
0000000000000000000000000000000000000000;;			return t.Seek(offset, whence)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(0), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSeeker returns if the underlying reader is also a seeker.
0000000000000000000000000000000000000000;;	func (r ReaderSeekerCloser) IsSeeker() bool {
0000000000000000000000000000000000000000;;		_, ok := r.r.(io.Seeker)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the ReaderSeekerCloser.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the ReaderSeekerCloser is not an io.Closer nothing will be done.
0000000000000000000000000000000000000000;;	func (r ReaderSeekerCloser) Close() error {
0000000000000000000000000000000000000000;;		switch t := r.r.(type) {
0000000000000000000000000000000000000000;;		case io.Closer:
0000000000000000000000000000000000000000;;			return t.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A WriteAtBuffer provides a in memory buffer supporting the io.WriterAt interface
0000000000000000000000000000000000000000;;	// Can be used with the s3manager.Downloader to download content to a buffer
0000000000000000000000000000000000000000;;	// in memory. Safe to use concurrently.
0000000000000000000000000000000000000000;;	type WriteAtBuffer struct {
0000000000000000000000000000000000000000;;		buf []byte
0000000000000000000000000000000000000000;;		m   sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GrowthCoeff defines the growth rate of the internal buffer. By
0000000000000000000000000000000000000000;;		// default, the growth rate is 1, where expanding the internal
0000000000000000000000000000000000000000;;		// buffer will allocate only enough capacity to fit the new expected
0000000000000000000000000000000000000000;;		// length.
0000000000000000000000000000000000000000;;		GrowthCoeff float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWriteAtBuffer creates a WriteAtBuffer with an internal buffer
0000000000000000000000000000000000000000;;	// provided by buf.
0000000000000000000000000000000000000000;;	func NewWriteAtBuffer(buf []byte) *WriteAtBuffer {
0000000000000000000000000000000000000000;;		return &WriteAtBuffer{buf: buf}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteAt writes a slice of bytes to a buffer starting at the position provided
0000000000000000000000000000000000000000;;	// The number of bytes written will be returned, or error. Can overwrite previous
0000000000000000000000000000000000000000;;	// written slices if the write ats overlap.
0000000000000000000000000000000000000000;;	func (b *WriteAtBuffer) WriteAt(p []byte, pos int64) (n int, err error) {
0000000000000000000000000000000000000000;;		pLen := len(p)
0000000000000000000000000000000000000000;;		expLen := pos + int64(pLen)
0000000000000000000000000000000000000000;;		b.m.Lock()
0000000000000000000000000000000000000000;;		defer b.m.Unlock()
0000000000000000000000000000000000000000;;		if int64(len(b.buf)) < expLen {
0000000000000000000000000000000000000000;;			if int64(cap(b.buf)) < expLen {
0000000000000000000000000000000000000000;;				if b.GrowthCoeff < 1 {
0000000000000000000000000000000000000000;;					b.GrowthCoeff = 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newBuf := make([]byte, expLen, int64(b.GrowthCoeff*float64(expLen)))
0000000000000000000000000000000000000000;;				copy(newBuf, b.buf)
0000000000000000000000000000000000000000;;				b.buf = newBuf
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.buf = b.buf[:expLen]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(b.buf[pos:], p)
0000000000000000000000000000000000000000;;		return pLen, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns a slice of bytes written to the buffer.
0000000000000000000000000000000000000000;;	func (b *WriteAtBuffer) Bytes() []byte {
0000000000000000000000000000000000000000;;		b.m.Lock()
0000000000000000000000000000000000000000;;		defer b.m.Unlock()
0000000000000000000000000000000000000000;;		return b.buf[:len(b.buf):len(b.buf)]
0000000000000000000000000000000000000000;;	}
