0000000000000000000000000000000000000000;;	// Package ec2metadata provides the client for making API calls to the
0000000000000000000000000000000000000000;;	// EC2 Metadata service.
0000000000000000000000000000000000000000;;	package ec2metadata
ba8371b1ad4f58d6c37fa3b43b005c306f9f2d92;Godeps/_workspace/src/github.com/aws/aws-sdk-go/aws/ec2metadata/service.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/aws/ec2metadata/service.go][vendor/github.com/aws/aws-sdk-go/aws/ec2metadata/service.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/client"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/client/metadata"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceName is the name of the service.
0000000000000000000000000000000000000000;;	const ServiceName = "ec2metadata"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A EC2Metadata is an EC2 Metadata service Client.
0000000000000000000000000000000000000000;;	type EC2Metadata struct {
0000000000000000000000000000000000000000;;		*client.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new instance of the EC2Metadata client with a session.
0000000000000000000000000000000000000000;;	// This client is safe to use across multiple goroutines.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	//     // Create a EC2Metadata client from just a session.
0000000000000000000000000000000000000000;;	//     svc := ec2metadata.New(mySession)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Create a EC2Metadata client with additional configuration
0000000000000000000000000000000000000000;;	//     svc := ec2metadata.New(mySession, aws.NewConfig().WithLogLevel(aws.LogDebugHTTPBody))
0000000000000000000000000000000000000000;;	func New(p client.ConfigProvider, cfgs ...*aws.Config) *EC2Metadata {
0000000000000000000000000000000000000000;;		c := p.ClientConfig(ServiceName, cfgs...)
0000000000000000000000000000000000000000;;		return NewClient(*c.Config, c.Handlers, c.Endpoint, c.SigningRegion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient returns a new EC2Metadata client. Should be used to create
0000000000000000000000000000000000000000;;	// a client when not using a session. Generally using just New with a session
0000000000000000000000000000000000000000;;	// is preferred.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If an unmodified HTTP client is provided from the stdlib default, or no client
0000000000000000000000000000000000000000;;	// the EC2RoleProvider's EC2Metadata HTTP client's timeout will be shortened.
0000000000000000000000000000000000000000;;	// To disable this set Config.EC2MetadataDisableTimeoutOverride to false. Enabled by default.
0000000000000000000000000000000000000000;;	func NewClient(cfg aws.Config, handlers request.Handlers, endpoint, signingRegion string, opts ...func(*client.Client)) *EC2Metadata {
0000000000000000000000000000000000000000;;		if !aws.BoolValue(cfg.EC2MetadataDisableTimeoutOverride) && httpClientZero(cfg.HTTPClient) {
0000000000000000000000000000000000000000;;			// If the http client is unmodified and this feature is not disabled
0000000000000000000000000000000000000000;;			// set custom timeouts for EC2Metadata requests.
0000000000000000000000000000000000000000;;			cfg.HTTPClient = &http.Client{
0000000000000000000000000000000000000000;;				// use a shorter timeout than default because the metadata
0000000000000000000000000000000000000000;;				// service is local if it is running, and to fail faster
0000000000000000000000000000000000000000;;				// if not running on an ec2 instance.
0000000000000000000000000000000000000000;;				Timeout: 5 * time.Second,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc := &EC2Metadata{
0000000000000000000000000000000000000000;;			Client: client.New(
0000000000000000000000000000000000000000;;				cfg,
0000000000000000000000000000000000000000;;				metadata.ClientInfo{
0000000000000000000000000000000000000000;;					ServiceName: ServiceName,
0000000000000000000000000000000000000000;;					Endpoint:    endpoint,
0000000000000000000000000000000000000000;;					APIVersion:  "latest",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handlers,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		svc.Handlers.Unmarshal.PushBack(unmarshalHandler)
0000000000000000000000000000000000000000;;		svc.Handlers.UnmarshalError.PushBack(unmarshalError)
0000000000000000000000000000000000000000;;		svc.Handlers.Validate.Clear()
0000000000000000000000000000000000000000;;		svc.Handlers.Validate.PushBack(validateEndpointHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add additional options to the service config
0000000000000000000000000000000000000000;;		for _, option := range opts {
0000000000000000000000000000000000000000;;			option(svc.Client)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return svc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func httpClientZero(c *http.Client) bool {
0000000000000000000000000000000000000000;;		return c == nil || (c.Transport == nil && c.CheckRedirect == nil && c.Jar == nil && c.Timeout == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type metadataOutput struct {
0000000000000000000000000000000000000000;;		Content string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalHandler(r *request.Request) {
0000000000000000000000000000000000000000;;		defer r.HTTPResponse.Body.Close()
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if _, err := io.Copy(b, r.HTTPResponse.Body); err != nil {
0000000000000000000000000000000000000000;;			r.Error = awserr.New("SerializationError", "unable to unmarshal EC2 metadata respose", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if data, ok := r.Data.(*metadataOutput); ok {
0000000000000000000000000000000000000000;;			data.Content = b.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalError(r *request.Request) {
0000000000000000000000000000000000000000;;		defer r.HTTPResponse.Body.Close()
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if _, err := io.Copy(b, r.HTTPResponse.Body); err != nil {
0000000000000000000000000000000000000000;;			r.Error = awserr.New("SerializationError", "unable to unmarshal EC2 metadata error respose", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Response body format is not consistent between metadata endpoints.
0000000000000000000000000000000000000000;;		// Grab the error message as a string and include that as the source error
0000000000000000000000000000000000000000;;		r.Error = awserr.New("EC2MetadataError", "failed to make EC2Metadata request", errors.New(b.String()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEndpointHandler(r *request.Request) {
0000000000000000000000000000000000000000;;		if r.ClientInfo.Endpoint == "" {
0000000000000000000000000000000000000000;;			r.Error = aws.ErrMissingEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
