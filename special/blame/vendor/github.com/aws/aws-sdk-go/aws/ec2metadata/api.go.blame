0000000000000000000000000000000000000000;;	package ec2metadata
ba8371b1ad4f58d6c37fa3b43b005c306f9f2d92;Godeps/_workspace/src/github.com/aws/aws-sdk-go/aws/ec2metadata/api.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/aws/ec2metadata/api.go][vendor/github.com/aws/aws-sdk-go/aws/ec2metadata/api.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetadata uses the path provided to request information from the EC2
0000000000000000000000000000000000000000;;	// instance metdata service. The content will be returned as a string, or
0000000000000000000000000000000000000000;;	// error if the request failed.
0000000000000000000000000000000000000000;;	func (c *EC2Metadata) GetMetadata(p string) (string, error) {
0000000000000000000000000000000000000000;;		op := &request.Operation{
0000000000000000000000000000000000000000;;			Name:       "GetMetadata",
0000000000000000000000000000000000000000;;			HTTPMethod: "GET",
0000000000000000000000000000000000000000;;			HTTPPath:   path.Join("/", "meta-data", p),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := &metadataOutput{}
0000000000000000000000000000000000000000;;		req := c.NewRequest(op, nil, output)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output.Content, req.Send()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUserData returns the userdata that was configured for the service. If
0000000000000000000000000000000000000000;;	// there is no user-data setup for the EC2 instance a "NotFoundError" error
0000000000000000000000000000000000000000;;	// code will be returned.
0000000000000000000000000000000000000000;;	func (c *EC2Metadata) GetUserData() (string, error) {
0000000000000000000000000000000000000000;;		op := &request.Operation{
0000000000000000000000000000000000000000;;			Name:       "GetUserData",
0000000000000000000000000000000000000000;;			HTTPMethod: "GET",
0000000000000000000000000000000000000000;;			HTTPPath:   path.Join("/", "user-data"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := &metadataOutput{}
0000000000000000000000000000000000000000;;		req := c.NewRequest(op, nil, output)
0000000000000000000000000000000000000000;;		req.Handlers.UnmarshalError.PushBack(func(r *request.Request) {
0000000000000000000000000000000000000000;;			if r.HTTPResponse.StatusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				r.Error = awserr.New("NotFoundError", "user-data not found", r.Error)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output.Content, req.Send()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDynamicData uses the path provided to request information from the EC2
0000000000000000000000000000000000000000;;	// instance metadata service for dynamic data. The content will be returned
0000000000000000000000000000000000000000;;	// as a string, or error if the request failed.
0000000000000000000000000000000000000000;;	func (c *EC2Metadata) GetDynamicData(p string) (string, error) {
0000000000000000000000000000000000000000;;		op := &request.Operation{
0000000000000000000000000000000000000000;;			Name:       "GetDynamicData",
0000000000000000000000000000000000000000;;			HTTPMethod: "GET",
0000000000000000000000000000000000000000;;			HTTPPath:   path.Join("/", "dynamic", p),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := &metadataOutput{}
0000000000000000000000000000000000000000;;		req := c.NewRequest(op, nil, output)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output.Content, req.Send()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetInstanceIdentityDocument retrieves an identity document describing an
0000000000000000000000000000000000000000;;	// instance. Error is returned if the request fails or is unable to parse
0000000000000000000000000000000000000000;;	// the response.
0000000000000000000000000000000000000000;;	func (c *EC2Metadata) GetInstanceIdentityDocument() (EC2InstanceIdentityDocument, error) {
0000000000000000000000000000000000000000;;		resp, err := c.GetDynamicData("instance-identity/document")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return EC2InstanceIdentityDocument{},
0000000000000000000000000000000000000000;;				awserr.New("EC2MetadataRequestError",
0000000000000000000000000000000000000000;;					"failed to get EC2 instance identity document", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doc := EC2InstanceIdentityDocument{}
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(strings.NewReader(resp)).Decode(&doc); err != nil {
0000000000000000000000000000000000000000;;			return EC2InstanceIdentityDocument{},
0000000000000000000000000000000000000000;;				awserr.New("SerializationError",
0000000000000000000000000000000000000000;;					"failed to decode EC2 instance identity document", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return doc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IAMInfo retrieves IAM info from the metadata API
0000000000000000000000000000000000000000;;	func (c *EC2Metadata) IAMInfo() (EC2IAMInfo, error) {
0000000000000000000000000000000000000000;;		resp, err := c.GetMetadata("iam/info")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return EC2IAMInfo{},
0000000000000000000000000000000000000000;;				awserr.New("EC2MetadataRequestError",
0000000000000000000000000000000000000000;;					"failed to get EC2 IAM info", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info := EC2IAMInfo{}
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(strings.NewReader(resp)).Decode(&info); err != nil {
0000000000000000000000000000000000000000;;			return EC2IAMInfo{},
0000000000000000000000000000000000000000;;				awserr.New("SerializationError",
0000000000000000000000000000000000000000;;					"failed to decode EC2 IAM info", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if info.Code != "Success" {
0000000000000000000000000000000000000000;;			errMsg := fmt.Sprintf("failed to get EC2 IAM Info (%s)", info.Code)
0000000000000000000000000000000000000000;;			return EC2IAMInfo{},
0000000000000000000000000000000000000000;;				awserr.New("EC2MetadataError", errMsg, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return info, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Region returns the region the instance is running in.
0000000000000000000000000000000000000000;;	func (c *EC2Metadata) Region() (string, error) {
0000000000000000000000000000000000000000;;		resp, err := c.GetMetadata("placement/availability-zone")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// returns region without the suffix. Eg: us-west-2a becomes us-west-2
0000000000000000000000000000000000000000;;		return resp[:len(resp)-1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Available returns if the application has access to the EC2 Metadata service.
0000000000000000000000000000000000000000;;	// Can be used to determine if application is running within an EC2 Instance and
0000000000000000000000000000000000000000;;	// the metadata service is available.
0000000000000000000000000000000000000000;;	func (c *EC2Metadata) Available() bool {
0000000000000000000000000000000000000000;;		if _, err := c.GetMetadata("instance-id"); err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An EC2IAMInfo provides the shape for unmarshaling
0000000000000000000000000000000000000000;;	// an IAM info from the metadata API
0000000000000000000000000000000000000000;;	type EC2IAMInfo struct {
0000000000000000000000000000000000000000;;		Code               string
0000000000000000000000000000000000000000;;		LastUpdated        time.Time
0000000000000000000000000000000000000000;;		InstanceProfileArn string
0000000000000000000000000000000000000000;;		InstanceProfileID  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An EC2InstanceIdentityDocument provides the shape for unmarshaling
0000000000000000000000000000000000000000;;	// an instance identity document
0000000000000000000000000000000000000000;;	type EC2InstanceIdentityDocument struct {
0000000000000000000000000000000000000000;;		DevpayProductCodes []string  `json:"devpayProductCodes"`
0000000000000000000000000000000000000000;;		AvailabilityZone   string    `json:"availabilityZone"`
0000000000000000000000000000000000000000;;		PrivateIP          string    `json:"privateIp"`
0000000000000000000000000000000000000000;;		Version            string    `json:"version"`
0000000000000000000000000000000000000000;;		Region             string    `json:"region"`
0000000000000000000000000000000000000000;;		InstanceID         string    `json:"instanceId"`
0000000000000000000000000000000000000000;;		BillingProducts    []string  `json:"billingProducts"`
0000000000000000000000000000000000000000;;		InstanceType       string    `json:"instanceType"`
0000000000000000000000000000000000000000;;		AccountID          string    `json:"accountId"`
0000000000000000000000000000000000000000;;		PendingTime        time.Time `json:"pendingTime"`
0000000000000000000000000000000000000000;;		ImageID            string    `json:"imageId"`
0000000000000000000000000000000000000000;;		KernelID           string    `json:"kernelId"`
0000000000000000000000000000000000000000;;		RamdiskID          string    `json:"ramdiskId"`
0000000000000000000000000000000000000000;;		Architecture       string    `json:"architecture"`
0000000000000000000000000000000000000000;;	}
