0000000000000000000000000000000000000000;;	package endpoints
7b662bd39f4f8ebe87658b72a7df9da9c5a74c80;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type partitions []partition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps partitions) EndpointFor(service, region string, opts ...func(*Options)) (ResolvedEndpoint, error) {
0000000000000000000000000000000000000000;;		var opt Options
0000000000000000000000000000000000000000;;		opt.Set(opts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(ps); i++ {
0000000000000000000000000000000000000000;;			if !ps[i].canResolveEndpoint(service, region, opt.StrictMatching) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ps[i].EndpointFor(service, region, opts...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If loose matching fallback to first partition format to use
0000000000000000000000000000000000000000;;		// when resolving the endpoint.
0000000000000000000000000000000000000000;;		if !opt.StrictMatching && len(ps) > 0 {
0000000000000000000000000000000000000000;;			return ps[0].EndpointFor(service, region, opts...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ResolvedEndpoint{}, NewUnknownEndpointError("all partitions", service, region, []string{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Partitions satisfies the EnumPartitions interface and returns a list
0000000000000000000000000000000000000000;;	// of Partitions representing each partition represented in the SDK's
0000000000000000000000000000000000000000;;	// endpoints model.
0000000000000000000000000000000000000000;;	func (ps partitions) Partitions() []Partition {
0000000000000000000000000000000000000000;;		parts := make([]Partition, 0, len(ps))
0000000000000000000000000000000000000000;;		for i := 0; i < len(ps); i++ {
0000000000000000000000000000000000000000;;			parts = append(parts, ps[i].Partition())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type partition struct {
0000000000000000000000000000000000000000;;		ID          string      `json:"partition"`
0000000000000000000000000000000000000000;;		Name        string      `json:"partitionName"`
0000000000000000000000000000000000000000;;		DNSSuffix   string      `json:"dnsSuffix"`
0000000000000000000000000000000000000000;;		RegionRegex regionRegex `json:"regionRegex"`
0000000000000000000000000000000000000000;;		Defaults    endpoint    `json:"defaults"`
0000000000000000000000000000000000000000;;		Regions     regions     `json:"regions"`
0000000000000000000000000000000000000000;;		Services    services    `json:"services"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p partition) Partition() Partition {
0000000000000000000000000000000000000000;;		return Partition{
0000000000000000000000000000000000000000;;			id: p.ID,
0000000000000000000000000000000000000000;;			p:  &p,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p partition) canResolveEndpoint(service, region string, strictMatch bool) bool {
0000000000000000000000000000000000000000;;		s, hasService := p.Services[service]
0000000000000000000000000000000000000000;;		_, hasEndpoint := s.Endpoints[region]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasEndpoint && hasService {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strictMatch {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.RegionRegex.MatchString(region)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p partition) EndpointFor(service, region string, opts ...func(*Options)) (resolved ResolvedEndpoint, err error) {
0000000000000000000000000000000000000000;;		var opt Options
0000000000000000000000000000000000000000;;		opt.Set(opts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, hasService := p.Services[service]
0000000000000000000000000000000000000000;;		if !hasService {
0000000000000000000000000000000000000000;;			return resolved, NewUnknownServiceError(p.ID, service, serviceList(p.Services))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e, hasEndpoint := s.endpointForRegion(region)
0000000000000000000000000000000000000000;;		if !hasEndpoint && opt.StrictMatching {
0000000000000000000000000000000000000000;;			return resolved, NewUnknownEndpointError(p.ID, service, region, endpointList(s.Endpoints))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defs := []endpoint{p.Defaults, s.Defaults}
0000000000000000000000000000000000000000;;		return e.resolve(service, region, p.DNSSuffix, defs, opt), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serviceList(ss services) []string {
0000000000000000000000000000000000000000;;		list := make([]string, 0, len(ss))
0000000000000000000000000000000000000000;;		for k := range ss {
0000000000000000000000000000000000000000;;			list = append(list, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func endpointList(es endpoints) []string {
0000000000000000000000000000000000000000;;		list := make([]string, 0, len(es))
0000000000000000000000000000000000000000;;		for k := range es {
0000000000000000000000000000000000000000;;			list = append(list, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type regionRegex struct {
0000000000000000000000000000000000000000;;		*regexp.Regexp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *regionRegex) UnmarshalJSON(b []byte) (err error) {
0000000000000000000000000000000000000000;;		// Strip leading and trailing quotes
0000000000000000000000000000000000000000;;		regex, err := strconv.Unquote(string(b))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to strip quotes from regex, %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Regexp, err = regexp.Compile(regex)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to unmarshal region regex, %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type regions map[string]region
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type region struct {
0000000000000000000000000000000000000000;;		Description string `json:"description"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type services map[string]service
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type service struct {
0000000000000000000000000000000000000000;;		PartitionEndpoint string    `json:"partitionEndpoint"`
0000000000000000000000000000000000000000;;		IsRegionalized    boxedBool `json:"isRegionalized,omitempty"`
0000000000000000000000000000000000000000;;		Defaults          endpoint  `json:"defaults"`
0000000000000000000000000000000000000000;;		Endpoints         endpoints `json:"endpoints"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *service) endpointForRegion(region string) (endpoint, bool) {
0000000000000000000000000000000000000000;;		if s.IsRegionalized == boxedFalse {
0000000000000000000000000000000000000000;;			return s.Endpoints[s.PartitionEndpoint], region == s.PartitionEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, ok := s.Endpoints[region]; ok {
0000000000000000000000000000000000000000;;			return e, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unable to find any matching endpoint, return
0000000000000000000000000000000000000000;;		// blank that will be used for generic endpoint creation.
0000000000000000000000000000000000000000;;		return endpoint{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type endpoints map[string]endpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type endpoint struct {
0000000000000000000000000000000000000000;;		Hostname        string          `json:"hostname"`
0000000000000000000000000000000000000000;;		Protocols       []string        `json:"protocols"`
0000000000000000000000000000000000000000;;		CredentialScope credentialScope `json:"credentialScope"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Custom fields not modeled
0000000000000000000000000000000000000000;;		HasDualStack      boxedBool `json:"-"`
0000000000000000000000000000000000000000;;		DualStackHostname string    `json:"-"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Signature Version not used
0000000000000000000000000000000000000000;;		SignatureVersions []string `json:"signatureVersions"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SSLCommonName not used.
0000000000000000000000000000000000000000;;		SSLCommonName string `json:"sslCommonName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultProtocol = "https"
0000000000000000000000000000000000000000;;		defaultSigner   = "v4"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		protocolPriority = []string{"https", "http"}
0000000000000000000000000000000000000000;;		signerPriority   = []string{"v4", "v2"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getByPriority(s []string, p []string, def string) string {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(p); i++ {
0000000000000000000000000000000000000000;;			for j := 0; j < len(s); j++ {
0000000000000000000000000000000000000000;;				if s[j] == p[i] {
0000000000000000000000000000000000000000;;					return s[j]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e endpoint) resolve(service, region, dnsSuffix string, defs []endpoint, opts Options) ResolvedEndpoint {
0000000000000000000000000000000000000000;;		var merged endpoint
0000000000000000000000000000000000000000;;		for _, def := range defs {
0000000000000000000000000000000000000000;;			merged.mergeIn(def)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		merged.mergeIn(e)
0000000000000000000000000000000000000000;;		e = merged
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostname := e.Hostname
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Offset the hostname for dualstack if enabled
0000000000000000000000000000000000000000;;		if opts.UseDualStack && e.HasDualStack == boxedTrue {
0000000000000000000000000000000000000000;;			hostname = e.DualStackHostname
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u := strings.Replace(hostname, "{service}", service, 1)
0000000000000000000000000000000000000000;;		u = strings.Replace(u, "{region}", region, 1)
0000000000000000000000000000000000000000;;		u = strings.Replace(u, "{dnsSuffix}", dnsSuffix, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := getEndpointScheme(e.Protocols, opts.DisableSSL)
0000000000000000000000000000000000000000;;		u = fmt.Sprintf("%s://%s", scheme, u)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signingRegion := e.CredentialScope.Region
0000000000000000000000000000000000000000;;		if len(signingRegion) == 0 {
0000000000000000000000000000000000000000;;			signingRegion = region
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signingName := e.CredentialScope.Service
0000000000000000000000000000000000000000;;		if len(signingName) == 0 {
0000000000000000000000000000000000000000;;			signingName = service
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ResolvedEndpoint{
0000000000000000000000000000000000000000;;			URL:           u,
0000000000000000000000000000000000000000;;			SigningRegion: signingRegion,
0000000000000000000000000000000000000000;;			SigningName:   signingName,
0000000000000000000000000000000000000000;;			SigningMethod: getByPriority(e.SignatureVersions, signerPriority, defaultSigner),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEndpointScheme(protocols []string, disableSSL bool) string {
0000000000000000000000000000000000000000;;		if disableSSL {
0000000000000000000000000000000000000000;;			return "http"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getByPriority(protocols, protocolPriority, defaultProtocol)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *endpoint) mergeIn(other endpoint) {
0000000000000000000000000000000000000000;;		if len(other.Hostname) > 0 {
0000000000000000000000000000000000000000;;			e.Hostname = other.Hostname
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(other.Protocols) > 0 {
0000000000000000000000000000000000000000;;			e.Protocols = other.Protocols
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(other.SignatureVersions) > 0 {
0000000000000000000000000000000000000000;;			e.SignatureVersions = other.SignatureVersions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(other.CredentialScope.Region) > 0 {
0000000000000000000000000000000000000000;;			e.CredentialScope.Region = other.CredentialScope.Region
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(other.CredentialScope.Service) > 0 {
0000000000000000000000000000000000000000;;			e.CredentialScope.Service = other.CredentialScope.Service
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(other.SSLCommonName) > 0 {
0000000000000000000000000000000000000000;;			e.SSLCommonName = other.SSLCommonName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if other.HasDualStack != boxedBoolUnset {
0000000000000000000000000000000000000000;;			e.HasDualStack = other.HasDualStack
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(other.DualStackHostname) > 0 {
0000000000000000000000000000000000000000;;			e.DualStackHostname = other.DualStackHostname
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type credentialScope struct {
0000000000000000000000000000000000000000;;		Region  string `json:"region"`
0000000000000000000000000000000000000000;;		Service string `json:"service"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type boxedBool int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *boxedBool) UnmarshalJSON(buf []byte) error {
0000000000000000000000000000000000000000;;		v, err := strconv.ParseBool(string(buf))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v {
0000000000000000000000000000000000000000;;			*b = boxedTrue
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			*b = boxedFalse
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		boxedBoolUnset boxedBool = iota
0000000000000000000000000000000000000000;;		boxedFalse
0000000000000000000000000000000000000000;;		boxedTrue
0000000000000000000000000000000000000000;;	)
