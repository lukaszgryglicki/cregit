0000000000000000000000000000000000000000;;	package endpoints
7b662bd39f4f8ebe87658b72a7df9da9c5a74c80;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options provide the configuration needed to direct how the
0000000000000000000000000000000000000000;;	// endpoints will be resolved.
0000000000000000000000000000000000000000;;	type Options struct {
0000000000000000000000000000000000000000;;		// DisableSSL forces the endpoint to be resolved as HTTP.
0000000000000000000000000000000000000000;;		// instead of HTTPS if the service supports it.
0000000000000000000000000000000000000000;;		DisableSSL bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sets the resolver to resolve the endpoint as a dualstack endpoint
0000000000000000000000000000000000000000;;		// for the service. If dualstack support for a service is not known and
0000000000000000000000000000000000000000;;		// StrictMatching is not enabled a dualstack endpoint for the service will
0000000000000000000000000000000000000000;;		// be returned. This endpoint may not be valid. If StrictMatching is
0000000000000000000000000000000000000000;;		// enabled only services that are known to support dualstack will return
0000000000000000000000000000000000000000;;		// dualstack endpoints.
0000000000000000000000000000000000000000;;		UseDualStack bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enables strict matching of services and regions resolved endpoints.
0000000000000000000000000000000000000000;;		// If the partition doesn't enumerate the exact service and region an
0000000000000000000000000000000000000000;;		// error will be returned. This option will prevent returning endpoints
0000000000000000000000000000000000000000;;		// that look valid, but may not resolve to any real endpoint.
0000000000000000000000000000000000000000;;		StrictMatching bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set combines all of the option functions together.
0000000000000000000000000000000000000000;;	func (o *Options) Set(optFns ...func(*Options)) {
0000000000000000000000000000000000000000;;		for _, fn := range optFns {
0000000000000000000000000000000000000000;;			fn(o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisableSSLOption sets the DisableSSL options. Can be used as a functional
0000000000000000000000000000000000000000;;	// option when resolving endpoints.
0000000000000000000000000000000000000000;;	func DisableSSLOption(o *Options) {
0000000000000000000000000000000000000000;;		o.DisableSSL = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UseDualStackOption sets the UseDualStack option. Can be used as a functional
0000000000000000000000000000000000000000;;	// option when resolving endpoints.
0000000000000000000000000000000000000000;;	func UseDualStackOption(o *Options) {
0000000000000000000000000000000000000000;;		o.UseDualStack = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrictMatchingOption sets the StrictMatching option. Can be used as a functional
0000000000000000000000000000000000000000;;	// option when resolving endpoints.
0000000000000000000000000000000000000000;;	func StrictMatchingOption(o *Options) {
0000000000000000000000000000000000000000;;		o.StrictMatching = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Resolver provides the interface for functionality to resolve endpoints.
0000000000000000000000000000000000000000;;	// The build in Partition and DefaultResolver return value satisfy this interface.
0000000000000000000000000000000000000000;;	type Resolver interface {
0000000000000000000000000000000000000000;;		EndpointFor(service, region string, opts ...func(*Options)) (ResolvedEndpoint, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolverFunc is a helper utility that wraps a function so it satisfies the
0000000000000000000000000000000000000000;;	// Resolver interface. This is useful when you want to add additional endpoint
0000000000000000000000000000000000000000;;	// resolving logic, or stub out specific endpoints with custom values.
0000000000000000000000000000000000000000;;	type ResolverFunc func(service, region string, opts ...func(*Options)) (ResolvedEndpoint, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointFor wraps the ResolverFunc function to satisfy the Resolver interface.
0000000000000000000000000000000000000000;;	func (fn ResolverFunc) EndpointFor(service, region string, opts ...func(*Options)) (ResolvedEndpoint, error) {
0000000000000000000000000000000000000000;;		return fn(service, region, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var schemeRE = regexp.MustCompile("^([^:]+)://")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddScheme adds the HTTP or HTTPS schemes to a endpoint URL if there is no
0000000000000000000000000000000000000000;;	// scheme. If disableSSL is true HTTP will set HTTP instead of the default HTTPS.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If disableSSL is set, it will only set the URL's scheme if the URL does not
0000000000000000000000000000000000000000;;	// contain a scheme.
0000000000000000000000000000000000000000;;	func AddScheme(endpoint string, disableSSL bool) string {
0000000000000000000000000000000000000000;;		if !schemeRE.MatchString(endpoint) {
0000000000000000000000000000000000000000;;			scheme := "https"
0000000000000000000000000000000000000000;;			if disableSSL {
0000000000000000000000000000000000000000;;				scheme = "http"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			endpoint = fmt.Sprintf("%s://%s", scheme, endpoint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return endpoint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnumPartitions a provides a way to retrieve the underlying partitions that
0000000000000000000000000000000000000000;;	// make up the SDK's default Resolver, or any resolver decoded from a model
0000000000000000000000000000000000000000;;	// file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use this interface with DefaultResolver and DecodeModels to get the list of
0000000000000000000000000000000000000000;;	// Partitions.
0000000000000000000000000000000000000000;;	type EnumPartitions interface {
0000000000000000000000000000000000000000;;		Partitions() []Partition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Partition provides the ability to enumerate the partition's regions
0000000000000000000000000000000000000000;;	// and services.
0000000000000000000000000000000000000000;;	type Partition struct {
0000000000000000000000000000000000000000;;		id string
0000000000000000000000000000000000000000;;		p  *partition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ID returns the identifier of the partition.
0000000000000000000000000000000000000000;;	func (p *Partition) ID() string { return p.id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointFor attempts to resolve the endpoint based on service and region.
0000000000000000000000000000000000000000;;	// See Options for information on configuring how the endpoint is resolved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the service cannot be found in the metadata the UnknownServiceError
0000000000000000000000000000000000000000;;	// error will be returned. This validation will occur regardless if
0000000000000000000000000000000000000000;;	// StrictMatching is enabled.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When resolving endpoints you can choose to enable StrictMatching. This will
0000000000000000000000000000000000000000;;	// require the provided service and region to be known by the partition.
0000000000000000000000000000000000000000;;	// If the endpoint cannot be strictly resolved an error will be returned. This
0000000000000000000000000000000000000000;;	// mode is useful to ensure the endpoint resolved is valid. Without
0000000000000000000000000000000000000000;;	// StrictMatching enabled the enpoint returned my look valid but may not work.
0000000000000000000000000000000000000000;;	// StrictMatching requires the SDK to be updated if you want to take advantage
0000000000000000000000000000000000000000;;	// of new regions and services expantions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Errors that can be returned.
0000000000000000000000000000000000000000;;	//   * UnknownServiceError
0000000000000000000000000000000000000000;;	//   * UnknownEndpointError
0000000000000000000000000000000000000000;;	func (p *Partition) EndpointFor(service, region string, opts ...func(*Options)) (ResolvedEndpoint, error) {
0000000000000000000000000000000000000000;;		return p.p.EndpointFor(service, region, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Regions returns a map of Regions indexed by their ID. This is useful for
0000000000000000000000000000000000000000;;	// enumerating over the regions in a partition.
0000000000000000000000000000000000000000;;	func (p *Partition) Regions() map[string]Region {
0000000000000000000000000000000000000000;;		rs := map[string]Region{}
0000000000000000000000000000000000000000;;		for id := range p.p.Regions {
0000000000000000000000000000000000000000;;			rs[id] = Region{
0000000000000000000000000000000000000000;;				id: id,
0000000000000000000000000000000000000000;;				p:  p.p,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Services returns a map of Service indexed by their ID. This is useful for
0000000000000000000000000000000000000000;;	// enumerating over the services in a partition.
0000000000000000000000000000000000000000;;	func (p *Partition) Services() map[string]Service {
0000000000000000000000000000000000000000;;		ss := map[string]Service{}
0000000000000000000000000000000000000000;;		for id := range p.p.Services {
0000000000000000000000000000000000000000;;			ss[id] = Service{
0000000000000000000000000000000000000000;;				id: id,
0000000000000000000000000000000000000000;;				p:  p.p,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Region provides information about a region, and ability to resolve an
0000000000000000000000000000000000000000;;	// endpoint from the context of a region, given a service.
0000000000000000000000000000000000000000;;	type Region struct {
0000000000000000000000000000000000000000;;		id, desc string
0000000000000000000000000000000000000000;;		p        *partition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ID returns the region's identifier.
0000000000000000000000000000000000000000;;	func (r *Region) ID() string { return r.id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveEndpoint resolves an endpoint from the context of the region given
0000000000000000000000000000000000000000;;	// a service. See Partition.EndpointFor for usage and errors that can be returned.
0000000000000000000000000000000000000000;;	func (r *Region) ResolveEndpoint(service string, opts ...func(*Options)) (ResolvedEndpoint, error) {
0000000000000000000000000000000000000000;;		return r.p.EndpointFor(service, r.id, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Services returns a list of all services that are known to be in this region.
0000000000000000000000000000000000000000;;	func (r *Region) Services() map[string]Service {
0000000000000000000000000000000000000000;;		ss := map[string]Service{}
0000000000000000000000000000000000000000;;		for id, s := range r.p.Services {
0000000000000000000000000000000000000000;;			if _, ok := s.Endpoints[r.id]; ok {
0000000000000000000000000000000000000000;;				ss[id] = Service{
0000000000000000000000000000000000000000;;					id: id,
0000000000000000000000000000000000000000;;					p:  r.p,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ss
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Service provides information about a service, and ability to resolve an
0000000000000000000000000000000000000000;;	// endpoint from the context of a service, given a region.
0000000000000000000000000000000000000000;;	type Service struct {
0000000000000000000000000000000000000000;;		id string
0000000000000000000000000000000000000000;;		p  *partition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ID returns the identifier for the service.
0000000000000000000000000000000000000000;;	func (s *Service) ID() string { return s.id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveEndpoint resolves an endpoint from the context of a service given
0000000000000000000000000000000000000000;;	// a region. See Partition.EndpointFor for usage and errors that can be returned.
0000000000000000000000000000000000000000;;	func (s *Service) ResolveEndpoint(region string, opts ...func(*Options)) (ResolvedEndpoint, error) {
0000000000000000000000000000000000000000;;		return s.p.EndpointFor(s.id, region, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoints returns a map of Endpoints indexed by their ID for all known
0000000000000000000000000000000000000000;;	// endpoints for a service.
0000000000000000000000000000000000000000;;	func (s *Service) Endpoints() map[string]Endpoint {
0000000000000000000000000000000000000000;;		es := map[string]Endpoint{}
0000000000000000000000000000000000000000;;		for id := range s.p.Services[s.id].Endpoints {
0000000000000000000000000000000000000000;;			es[id] = Endpoint{
0000000000000000000000000000000000000000;;				id:        id,
0000000000000000000000000000000000000000;;				serviceID: s.id,
0000000000000000000000000000000000000000;;				p:         s.p,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return es
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Endpoint provides information about endpoints, and provides the ability
0000000000000000000000000000000000000000;;	// to resolve that endpoint for the service, and the region the endpoint
0000000000000000000000000000000000000000;;	// represents.
0000000000000000000000000000000000000000;;	type Endpoint struct {
0000000000000000000000000000000000000000;;		id        string
0000000000000000000000000000000000000000;;		serviceID string
0000000000000000000000000000000000000000;;		p         *partition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ID returns the identifier for an endpoint.
0000000000000000000000000000000000000000;;	func (e *Endpoint) ID() string { return e.id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceID returns the identifier the endpoint belongs to.
0000000000000000000000000000000000000000;;	func (e *Endpoint) ServiceID() string { return e.serviceID }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveEndpoint resolves an endpoint from the context of a service and
0000000000000000000000000000000000000000;;	// region the endpoint represents. See Partition.EndpointFor for usage and
0000000000000000000000000000000000000000;;	// errors that can be returned.
0000000000000000000000000000000000000000;;	func (e *Endpoint) ResolveEndpoint(opts ...func(*Options)) (ResolvedEndpoint, error) {
0000000000000000000000000000000000000000;;		return e.p.EndpointFor(e.serviceID, e.id, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ResolvedEndpoint is an endpoint that has been resolved based on a partition
0000000000000000000000000000000000000000;;	// service, and region.
0000000000000000000000000000000000000000;;	type ResolvedEndpoint struct {
0000000000000000000000000000000000000000;;		// The endpoint URL
0000000000000000000000000000000000000000;;		URL string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The region that should be used for signing requests.
0000000000000000000000000000000000000000;;		SigningRegion string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The service name that should be used for signing requests.
0000000000000000000000000000000000000000;;		SigningName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The signing method that should be used for signing requests.
0000000000000000000000000000000000000000;;		SigningMethod string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// So that the Error interface type can be included as an anonymous field
0000000000000000000000000000000000000000;;	// in the requestError struct and not conflict with the error.Error() method.
0000000000000000000000000000000000000000;;	type awsError awserr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A EndpointNotFoundError is returned when in StrictMatching mode, and the
0000000000000000000000000000000000000000;;	// endpoint for the service and region cannot be found in any of the partitions.
0000000000000000000000000000000000000000;;	type EndpointNotFoundError struct {
0000000000000000000000000000000000000000;;		awsError
0000000000000000000000000000000000000000;;		Partition string
0000000000000000000000000000000000000000;;		Service   string
0000000000000000000000000000000000000000;;		Region    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//// NewEndpointNotFoundError builds and returns NewEndpointNotFoundError.
0000000000000000000000000000000000000000;;	//func NewEndpointNotFoundError(p, s, r string) EndpointNotFoundError {
0000000000000000000000000000000000000000;;	//	return EndpointNotFoundError{
0000000000000000000000000000000000000000;;	//		awsError:  awserr.New("EndpointNotFoundError", "unable to find endpoint", nil),
0000000000000000000000000000000000000000;;	//		Partition: p,
0000000000000000000000000000000000000000;;	//		Service:   s,
0000000000000000000000000000000000000000;;	//		Region:    r,
0000000000000000000000000000000000000000;;	//	}
0000000000000000000000000000000000000000;;	//}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//// Error returns string representation of the error.
0000000000000000000000000000000000000000;;	//func (e EndpointNotFoundError) Error() string {
0000000000000000000000000000000000000000;;	//	extra := fmt.Sprintf("partition: %q, service: %q, region: %q",
0000000000000000000000000000000000000000;;	//		e.Partition, e.Service, e.Region)
0000000000000000000000000000000000000000;;	//	return awserr.SprintError(e.Code(), e.Message(), extra, e.OrigErr())
0000000000000000000000000000000000000000;;	//}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//// String returns the string representation of the error.
0000000000000000000000000000000000000000;;	//func (e EndpointNotFoundError) String() string {
0000000000000000000000000000000000000000;;	//	return e.Error()
0000000000000000000000000000000000000000;;	//}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A UnknownServiceError is returned when the service does not resolve to an
0000000000000000000000000000000000000000;;	// endpoint. Includes a list of all known services for the partition. Returned
0000000000000000000000000000000000000000;;	// when a partition does not support the service.
0000000000000000000000000000000000000000;;	type UnknownServiceError struct {
0000000000000000000000000000000000000000;;		awsError
0000000000000000000000000000000000000000;;		Partition string
0000000000000000000000000000000000000000;;		Service   string
0000000000000000000000000000000000000000;;		Known     []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnknownServiceError builds and returns UnknownServiceError.
0000000000000000000000000000000000000000;;	func NewUnknownServiceError(p, s string, known []string) UnknownServiceError {
0000000000000000000000000000000000000000;;		return UnknownServiceError{
0000000000000000000000000000000000000000;;			awsError: awserr.New("UnknownServiceError",
0000000000000000000000000000000000000000;;				"could not resolve endpoint for unknown service", nil),
0000000000000000000000000000000000000000;;			Partition: p,
0000000000000000000000000000000000000000;;			Service:   s,
0000000000000000000000000000000000000000;;			Known:     known,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the error.
0000000000000000000000000000000000000000;;	func (e UnknownServiceError) Error() string {
0000000000000000000000000000000000000000;;		extra := fmt.Sprintf("partition: %q, service: %q",
0000000000000000000000000000000000000000;;			e.Partition, e.Service)
0000000000000000000000000000000000000000;;		if len(e.Known) > 0 {
0000000000000000000000000000000000000000;;			extra += fmt.Sprintf(", known: %v", e.Known)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return awserr.SprintError(e.Code(), e.Message(), extra, e.OrigErr())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the error.
0000000000000000000000000000000000000000;;	func (e UnknownServiceError) String() string {
0000000000000000000000000000000000000000;;		return e.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A UnknownEndpointError is returned when in StrictMatching mode and the
0000000000000000000000000000000000000000;;	// service is valid, but the region does not resolve to an endpoint. Includes
0000000000000000000000000000000000000000;;	// a list of all known endpoints for the service.
0000000000000000000000000000000000000000;;	type UnknownEndpointError struct {
0000000000000000000000000000000000000000;;		awsError
0000000000000000000000000000000000000000;;		Partition string
0000000000000000000000000000000000000000;;		Service   string
0000000000000000000000000000000000000000;;		Region    string
0000000000000000000000000000000000000000;;		Known     []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnknownEndpointError builds and returns UnknownEndpointError.
0000000000000000000000000000000000000000;;	func NewUnknownEndpointError(p, s, r string, known []string) UnknownEndpointError {
0000000000000000000000000000000000000000;;		return UnknownEndpointError{
0000000000000000000000000000000000000000;;			awsError: awserr.New("UnknownEndpointError",
0000000000000000000000000000000000000000;;				"could not resolve endpoint", nil),
0000000000000000000000000000000000000000;;			Partition: p,
0000000000000000000000000000000000000000;;			Service:   s,
0000000000000000000000000000000000000000;;			Region:    r,
0000000000000000000000000000000000000000;;			Known:     known,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the error.
0000000000000000000000000000000000000000;;	func (e UnknownEndpointError) Error() string {
0000000000000000000000000000000000000000;;		extra := fmt.Sprintf("partition: %q, service: %q, region: %q",
0000000000000000000000000000000000000000;;			e.Partition, e.Service, e.Region)
0000000000000000000000000000000000000000;;		if len(e.Known) > 0 {
0000000000000000000000000000000000000000;;			extra += fmt.Sprintf(", known: %v", e.Known)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return awserr.SprintError(e.Code(), e.Message(), extra, e.OrigErr())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the error.
0000000000000000000000000000000000000000;;	func (e UnknownEndpointError) String() string {
0000000000000000000000000000000000000000;;		return e.Error()
0000000000000000000000000000000000000000;;	}
