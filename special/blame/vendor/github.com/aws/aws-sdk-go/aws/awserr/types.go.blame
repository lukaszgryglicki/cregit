0000000000000000000000000000000000000000;;	package awserr
f49e160748842d0b155b75ebbab6d2b5b6b08571;Godeps/_workspace/src/github.com/aws/aws-sdk-go/internal/apierr/error.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/internal/apierr/error.go][vendor/github.com/aws/aws-sdk-go/aws/awserr/types.go];	
0000000000000000000000000000000000000000;;	import "fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SprintError returns a string of the formatted error code.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Both extra and origErr are optional.  If they are included their lines
0000000000000000000000000000000000000000;;	// will be added, but if they are not included their lines will be ignored.
0000000000000000000000000000000000000000;;	func SprintError(code, message, extra string, origErr error) string {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf("%s: %s", code, message)
0000000000000000000000000000000000000000;;		if extra != "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf("%s\n\t%s", msg, extra)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if origErr != nil {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf("%s\ncaused by: %s", msg, origErr.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A baseError wraps the code and message which defines an error. It also
0000000000000000000000000000000000000000;;	// can be used to wrap an original error object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Should be used as the root for errors satisfying the awserr.Error. Also
0000000000000000000000000000000000000000;;	// for any error which does not fit into a specific error wrapper type.
0000000000000000000000000000000000000000;;	type baseError struct {
0000000000000000000000000000000000000000;;		// Classification of error
0000000000000000000000000000000000000000;;		code string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Detailed information about error
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional original error this error is based off of. Allows building
0000000000000000000000000000000000000000;;		// chained errors.
0000000000000000000000000000000000000000;;		errs []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newBaseError returns an error object for the code, message, and errors.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// code is a short no whitespace phrase depicting the classification of
0000000000000000000000000000000000000000;;	// the error that is being created.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// message is the free flow string containing detailed information about the
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// origErrs is the error objects which will be nested under the new errors to
0000000000000000000000000000000000000000;;	// be returned.
0000000000000000000000000000000000000000;;	func newBaseError(code, message string, origErrs []error) *baseError {
0000000000000000000000000000000000000000;;		b := &baseError{
0000000000000000000000000000000000000000;;			code:    code,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;			errs:    origErrs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the string representation of the error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See ErrorWithExtra for formatting.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Satisfies the error interface.
0000000000000000000000000000000000000000;;	func (b baseError) Error() string {
0000000000000000000000000000000000000000;;		size := len(b.errs)
0000000000000000000000000000000000000000;;		if size > 0 {
0000000000000000000000000000000000000000;;			return SprintError(b.code, b.message, "", errorList(b.errs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return SprintError(b.code, b.message, "", nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the error.
0000000000000000000000000000000000000000;;	// Alias for Error to satisfy the stringer interface.
0000000000000000000000000000000000000000;;	func (b baseError) String() string {
0000000000000000000000000000000000000000;;		return b.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Code returns the short phrase depicting the classification of the error.
0000000000000000000000000000000000000000;;	func (b baseError) Code() string {
0000000000000000000000000000000000000000;;		return b.code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Message returns the error details message.
0000000000000000000000000000000000000000;;	func (b baseError) Message() string {
0000000000000000000000000000000000000000;;		return b.message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OrigErr returns the original error if one was set. Nil is returned if no
0000000000000000000000000000000000000000;;	// error was set. This only returns the first element in the list. If the full
0000000000000000000000000000000000000000;;	// list is needed, use BatchedErrors.
0000000000000000000000000000000000000000;;	func (b baseError) OrigErr() error {
0000000000000000000000000000000000000000;;		switch len(b.errs) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return b.errs[0]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if err, ok := b.errs[0].(Error); ok {
0000000000000000000000000000000000000000;;				return NewBatchError(err.Code(), err.Message(), b.errs[1:])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return NewBatchError("BatchedErrors",
0000000000000000000000000000000000000000;;				"multiple errors occurred", b.errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OrigErrs returns the original errors if one was set. An empty slice is
0000000000000000000000000000000000000000;;	// returned if no error was set.
0000000000000000000000000000000000000000;;	func (b baseError) OrigErrs() []error {
0000000000000000000000000000000000000000;;		return b.errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// So that the Error interface type can be included as an anonymous field
0000000000000000000000000000000000000000;;	// in the requestError struct and not conflict with the error.Error() method.
0000000000000000000000000000000000000000;;	type awsError Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A requestError wraps a request or service error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Composed of baseError for code, message, and original error.
0000000000000000000000000000000000000000;;	type requestError struct {
0000000000000000000000000000000000000000;;		awsError
0000000000000000000000000000000000000000;;		statusCode int
0000000000000000000000000000000000000000;;		requestID  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRequestError returns a wrapped error with additional information for
0000000000000000000000000000000000000000;;	// request status code, and service requestID.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Should be used to wrap all request which involve service requests. Even if
0000000000000000000000000000000000000000;;	// the request failed without a service response, but had an HTTP status code
0000000000000000000000000000000000000000;;	// that may be meaningful.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Also wraps original errors via the baseError.
0000000000000000000000000000000000000000;;	func newRequestError(err Error, statusCode int, requestID string) *requestError {
0000000000000000000000000000000000000000;;		return &requestError{
0000000000000000000000000000000000000000;;			awsError:   err,
0000000000000000000000000000000000000000;;			statusCode: statusCode,
0000000000000000000000000000000000000000;;			requestID:  requestID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the string representation of the error.
0000000000000000000000000000000000000000;;	// Satisfies the error interface.
0000000000000000000000000000000000000000;;	func (r requestError) Error() string {
0000000000000000000000000000000000000000;;		extra := fmt.Sprintf("status code: %d, request id: %s",
0000000000000000000000000000000000000000;;			r.statusCode, r.requestID)
0000000000000000000000000000000000000000;;		return SprintError(r.Code(), r.Message(), extra, r.OrigErr())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the error.
0000000000000000000000000000000000000000;;	// Alias for Error to satisfy the stringer interface.
0000000000000000000000000000000000000000;;	func (r requestError) String() string {
0000000000000000000000000000000000000000;;		return r.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusCode returns the wrapped status code for the error
0000000000000000000000000000000000000000;;	func (r requestError) StatusCode() int {
0000000000000000000000000000000000000000;;		return r.statusCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestID returns the wrapped requestID
0000000000000000000000000000000000000000;;	func (r requestError) RequestID() string {
0000000000000000000000000000000000000000;;		return r.requestID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OrigErrs returns the original errors if one was set. An empty slice is
0000000000000000000000000000000000000000;;	// returned if no error was set.
0000000000000000000000000000000000000000;;	func (r requestError) OrigErrs() []error {
0000000000000000000000000000000000000000;;		if b, ok := r.awsError.(BatchedErrors); ok {
0000000000000000000000000000000000000000;;			return b.OrigErrs()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []error{r.OrigErr()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An error list that satisfies the golang interface
0000000000000000000000000000000000000000;;	type errorList []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns the string representation of the error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Satisfies the error interface.
0000000000000000000000000000000000000000;;	func (e errorList) Error() string {
0000000000000000000000000000000000000000;;		msg := ""
0000000000000000000000000000000000000000;;		// How do we want to handle the array size being zero
0000000000000000000000000000000000000000;;		if size := len(e); size > 0 {
0000000000000000000000000000000000000000;;			for i := 0; i < size; i++ {
0000000000000000000000000000000000000000;;				msg += fmt.Sprintf("%s", e[i].Error())
0000000000000000000000000000000000000000;;				// We check the next index to see if it is within the slice.
0000000000000000000000000000000000000000;;				// If it is, then we append a newline. We do this, because unit tests
0000000000000000000000000000000000000000;;				// could be broken with the additional '\n'
0000000000000000000000000000000000000000;;				if i+1 < size {
0000000000000000000000000000000000000000;;					msg += "\n"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
