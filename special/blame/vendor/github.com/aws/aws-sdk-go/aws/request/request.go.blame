0000000000000000000000000000000000000000;;	package request
b5a369483575c99a3598125e51d2fb065a91c6de;Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/request.go[Godeps/_workspace/src/github.com/awslabs/aws-sdk-go/aws/request.go][vendor/github.com/aws/aws-sdk-go/aws/request/request.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/client/metadata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Request is the service request to be made.
0000000000000000000000000000000000000000;;	type Request struct {
0000000000000000000000000000000000000000;;		Config     aws.Config
0000000000000000000000000000000000000000;;		ClientInfo metadata.ClientInfo
0000000000000000000000000000000000000000;;		Handlers   Handlers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Retryer
0000000000000000000000000000000000000000;;		Time             time.Time
0000000000000000000000000000000000000000;;		ExpireTime       time.Duration
0000000000000000000000000000000000000000;;		Operation        *Operation
0000000000000000000000000000000000000000;;		HTTPRequest      *http.Request
0000000000000000000000000000000000000000;;		HTTPResponse     *http.Response
0000000000000000000000000000000000000000;;		Body             io.ReadSeeker
0000000000000000000000000000000000000000;;		BodyStart        int64 // offset from beginning of Body that the request body starts
0000000000000000000000000000000000000000;;		Params           interface{}
0000000000000000000000000000000000000000;;		Error            error
0000000000000000000000000000000000000000;;		Data             interface{}
0000000000000000000000000000000000000000;;		RequestID        string
0000000000000000000000000000000000000000;;		RetryCount       int
0000000000000000000000000000000000000000;;		Retryable        *bool
0000000000000000000000000000000000000000;;		RetryDelay       time.Duration
0000000000000000000000000000000000000000;;		NotHoist         bool
0000000000000000000000000000000000000000;;		SignedHeaderVals http.Header
0000000000000000000000000000000000000000;;		LastSignedAt     time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		built bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Need to persist an intermideant body betweend the input Body and HTTP
0000000000000000000000000000000000000000;;		// request body because the HTTP Client's transport can maintain a reference
0000000000000000000000000000000000000000;;		// to the HTTP request's body after the client has returned. This value is
0000000000000000000000000000000000000000;;		// safe to use concurrently and rewraps the input Body for each HTTP request.
0000000000000000000000000000000000000000;;		safeBody *offsetReader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Operation is the service API operation to be made.
0000000000000000000000000000000000000000;;	type Operation struct {
0000000000000000000000000000000000000000;;		Name       string
0000000000000000000000000000000000000000;;		HTTPMethod string
0000000000000000000000000000000000000000;;		HTTPPath   string
0000000000000000000000000000000000000000;;		*Paginator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BeforePresignFn func(r *Request) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Paginator keeps track of pagination configuration for an API operation.
0000000000000000000000000000000000000000;;	type Paginator struct {
0000000000000000000000000000000000000000;;		InputTokens     []string
0000000000000000000000000000000000000000;;		OutputTokens    []string
0000000000000000000000000000000000000000;;		LimitToken      string
0000000000000000000000000000000000000000;;		TruncationToken string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Request pointer for the service API
0000000000000000000000000000000000000000;;	// operation and parameters.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Params is any value of input parameters to be the request payload.
0000000000000000000000000000000000000000;;	// Data is pointer value to an object which the request's response
0000000000000000000000000000000000000000;;	// payload will be deserialized to.
0000000000000000000000000000000000000000;;	func New(cfg aws.Config, clientInfo metadata.ClientInfo, handlers Handlers,
0000000000000000000000000000000000000000;;		retryer Retryer, operation *Operation, params interface{}, data interface{}) *Request {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		method := operation.HTTPMethod
0000000000000000000000000000000000000000;;		if method == "" {
0000000000000000000000000000000000000000;;			method = "POST"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		httpReq, _ := http.NewRequest(method, "", nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		httpReq.URL, err = url.Parse(clientInfo.Endpoint + operation.HTTPPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			httpReq.URL = &url.URL{}
0000000000000000000000000000000000000000;;			err = awserr.New("InvalidEndpointURL", "invalid endpoint uri", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := &Request{
0000000000000000000000000000000000000000;;			Config:     cfg,
0000000000000000000000000000000000000000;;			ClientInfo: clientInfo,
0000000000000000000000000000000000000000;;			Handlers:   handlers.Copy(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Retryer:     retryer,
0000000000000000000000000000000000000000;;			Time:        time.Now(),
0000000000000000000000000000000000000000;;			ExpireTime:  0,
0000000000000000000000000000000000000000;;			Operation:   operation,
0000000000000000000000000000000000000000;;			HTTPRequest: httpReq,
0000000000000000000000000000000000000000;;			Body:        nil,
0000000000000000000000000000000000000000;;			Params:      params,
0000000000000000000000000000000000000000;;			Error:       err,
0000000000000000000000000000000000000000;;			Data:        data,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.SetBufferBody([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WillRetry returns if the request's can be retried.
0000000000000000000000000000000000000000;;	func (r *Request) WillRetry() bool {
0000000000000000000000000000000000000000;;		return r.Error != nil && aws.BoolValue(r.Retryable) && r.RetryCount < r.MaxRetries()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParamsFilled returns if the request's parameters have been populated
0000000000000000000000000000000000000000;;	// and the parameters are valid. False is returned if no parameters are
0000000000000000000000000000000000000000;;	// provided or invalid.
0000000000000000000000000000000000000000;;	func (r *Request) ParamsFilled() bool {
0000000000000000000000000000000000000000;;		return r.Params != nil && reflect.ValueOf(r.Params).Elem().IsValid()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DataFilled returns true if the request's data for response deserialization
0000000000000000000000000000000000000000;;	// target has been set and is a valid. False is returned if data is not
0000000000000000000000000000000000000000;;	// set, or is invalid.
0000000000000000000000000000000000000000;;	func (r *Request) DataFilled() bool {
0000000000000000000000000000000000000000;;		return r.Data != nil && reflect.ValueOf(r.Data).Elem().IsValid()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBufferBody will set the request's body bytes that will be sent to
0000000000000000000000000000000000000000;;	// the service API.
0000000000000000000000000000000000000000;;	func (r *Request) SetBufferBody(buf []byte) {
0000000000000000000000000000000000000000;;		r.SetReaderBody(bytes.NewReader(buf))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetStringBody sets the body of the request to be backed by a string.
0000000000000000000000000000000000000000;;	func (r *Request) SetStringBody(s string) {
0000000000000000000000000000000000000000;;		r.SetReaderBody(strings.NewReader(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReaderBody will set the request's body reader.
0000000000000000000000000000000000000000;;	func (r *Request) SetReaderBody(reader io.ReadSeeker) {
0000000000000000000000000000000000000000;;		r.Body = reader
0000000000000000000000000000000000000000;;		r.ResetBody()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Presign returns the request's signed URL. Error will be returned
0000000000000000000000000000000000000000;;	// if the signing fails.
0000000000000000000000000000000000000000;;	func (r *Request) Presign(expireTime time.Duration) (string, error) {
0000000000000000000000000000000000000000;;		r.ExpireTime = expireTime
0000000000000000000000000000000000000000;;		r.NotHoist = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Operation.BeforePresignFn != nil {
0000000000000000000000000000000000000000;;			r = r.copy()
0000000000000000000000000000000000000000;;			err := r.Operation.BeforePresignFn(r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Sign()
0000000000000000000000000000000000000000;;		if r.Error != nil {
0000000000000000000000000000000000000000;;			return "", r.Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.HTTPRequest.URL.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PresignRequest behaves just like presign, but hoists all headers and signs them.
0000000000000000000000000000000000000000;;	// Also returns the signed hash back to the user
0000000000000000000000000000000000000000;;	func (r *Request) PresignRequest(expireTime time.Duration) (string, http.Header, error) {
0000000000000000000000000000000000000000;;		r.ExpireTime = expireTime
0000000000000000000000000000000000000000;;		r.NotHoist = true
0000000000000000000000000000000000000000;;		r.Sign()
0000000000000000000000000000000000000000;;		if r.Error != nil {
0000000000000000000000000000000000000000;;			return "", nil, r.Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.HTTPRequest.URL.String(), r.SignedHeaderVals, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func debugLogReqError(r *Request, stage string, retrying bool, err error) {
0000000000000000000000000000000000000000;;		if !r.Config.LogLevel.Matches(aws.LogDebugWithRequestErrors) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retryStr := "not retrying"
0000000000000000000000000000000000000000;;		if retrying {
0000000000000000000000000000000000000000;;			retryStr = "will retry"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Config.Logger.Log(fmt.Sprintf("DEBUG: %s %s/%s failed, %s, error %v",
0000000000000000000000000000000000000000;;			stage, r.ClientInfo.ServiceName, r.Operation.Name, retryStr, err))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build will build the request's object so it can be signed and sent
0000000000000000000000000000000000000000;;	// to the service. Build will also validate all the request's parameters.
0000000000000000000000000000000000000000;;	// Anny additional build Handlers set on this request will be run
0000000000000000000000000000000000000000;;	// in the order they were set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The request will only be built once. Multiple calls to build will have
0000000000000000000000000000000000000000;;	// no effect.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If any Validate or Build errors occur the build will stop and the error
0000000000000000000000000000000000000000;;	// which occurred will be returned.
0000000000000000000000000000000000000000;;	func (r *Request) Build() error {
0000000000000000000000000000000000000000;;		if !r.built {
0000000000000000000000000000000000000000;;			r.Handlers.Validate.Run(r)
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				debugLogReqError(r, "Validate Request", false, r.Error)
0000000000000000000000000000000000000000;;				return r.Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Handlers.Build.Run(r)
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				debugLogReqError(r, "Build Request", false, r.Error)
0000000000000000000000000000000000000000;;				return r.Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.built = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.Error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign will sign the request returning error if errors are encountered.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Send will build the request prior to signing. All Sign Handlers will
0000000000000000000000000000000000000000;;	// be executed in the order they were set.
0000000000000000000000000000000000000000;;	func (r *Request) Sign() error {
0000000000000000000000000000000000000000;;		r.Build()
0000000000000000000000000000000000000000;;		if r.Error != nil {
0000000000000000000000000000000000000000;;			debugLogReqError(r, "Build Request", false, r.Error)
0000000000000000000000000000000000000000;;			return r.Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Handlers.Sign.Run(r)
0000000000000000000000000000000000000000;;		return r.Error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetBody rewinds the request body backto its starting position, and
0000000000000000000000000000000000000000;;	// set's the HTTP Request body reference. When the body is read prior
0000000000000000000000000000000000000000;;	// to being sent in the HTTP request it will need to be rewound.
0000000000000000000000000000000000000000;;	func (r *Request) ResetBody() {
0000000000000000000000000000000000000000;;		if r.safeBody != nil {
0000000000000000000000000000000000000000;;			r.safeBody.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.safeBody = newOffsetReader(r.Body, r.BodyStart)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Go 1.8 tightened and clarified the rules code needs to use when building
0000000000000000000000000000000000000000;;		// requests with the http package. Go 1.8 removed the automatic detection
0000000000000000000000000000000000000000;;		// of if the Request.Body was empty, or actually had bytes in it. The SDK
0000000000000000000000000000000000000000;;		// always sets the Request.Body even if it is empty and should not actually
0000000000000000000000000000000000000000;;		// be sent. This is incorrect.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Go 1.8 did add a http.NoBody value that the SDK can use to tell the http
0000000000000000000000000000000000000000;;		// client that the request really should be sent without a body. The
0000000000000000000000000000000000000000;;		// Request.Body cannot be set to nil, which is preferable, because the
0000000000000000000000000000000000000000;;		// field is exported and could introduce nil pointer dereferences for users
0000000000000000000000000000000000000000;;		// of the SDK if they used that field.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Related golang/go#18257
0000000000000000000000000000000000000000;;		l, err := computeBodyLength(r.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.Error = awserr.New("SerializationError", "failed to compute request body size", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			r.HTTPRequest.Body = noBodyReader
0000000000000000000000000000000000000000;;		} else if l > 0 {
0000000000000000000000000000000000000000;;			r.HTTPRequest.Body = r.safeBody
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Hack to prevent sending bodies for methods where the body
0000000000000000000000000000000000000000;;			// should be ignored by the server. Sending bodies on these
0000000000000000000000000000000000000000;;			// methods without an associated ContentLength will cause the
0000000000000000000000000000000000000000;;			// request to socket timeout because the server does not handle
0000000000000000000000000000000000000000;;			// Transfer-Encoding: chunked bodies for these methods.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// This would only happen if a aws.ReaderSeekerCloser was used with
0000000000000000000000000000000000000000;;			// a io.Reader that was not also an io.Seeker.
0000000000000000000000000000000000000000;;			switch r.Operation.HTTPMethod {
0000000000000000000000000000000000000000;;			case "GET", "HEAD", "DELETE":
0000000000000000000000000000000000000000;;				r.HTTPRequest.Body = noBodyReader
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				r.HTTPRequest.Body = r.safeBody
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attempts to compute the length of the body of the reader using the
0000000000000000000000000000000000000000;;	// io.Seeker interface. If the value is not seekable because of being
0000000000000000000000000000000000000000;;	// a ReaderSeekerCloser without an unerlying Seeker -1 will be returned.
0000000000000000000000000000000000000000;;	// If no error occurs the length of the body will be returned.
0000000000000000000000000000000000000000;;	func computeBodyLength(r io.ReadSeeker) (int64, error) {
0000000000000000000000000000000000000000;;		seekable := true
0000000000000000000000000000000000000000;;		// Determine if the seeker is actually seekable. ReaderSeekerCloser
0000000000000000000000000000000000000000;;		// hides the fact that a io.Readers might not actually be seekable.
0000000000000000000000000000000000000000;;		switch v := r.(type) {
0000000000000000000000000000000000000000;;		case aws.ReaderSeekerCloser:
0000000000000000000000000000000000000000;;			seekable = v.IsSeeker()
0000000000000000000000000000000000000000;;		case *aws.ReaderSeekerCloser:
0000000000000000000000000000000000000000;;			seekable = v.IsSeeker()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !seekable {
0000000000000000000000000000000000000000;;			return -1, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curOffset, err := r.Seek(0, 1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endOffset, err := r.Seek(0, 2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = r.Seek(curOffset, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return endOffset - curOffset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBody will return an io.ReadSeeker of the Request's underlying
0000000000000000000000000000000000000000;;	// input body with a concurrency safe wrapper.
0000000000000000000000000000000000000000;;	func (r *Request) GetBody() io.ReadSeeker {
0000000000000000000000000000000000000000;;		return r.safeBody
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send will send the request returning error if errors are encountered.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Send will sign the request prior to sending. All Send Handlers will
0000000000000000000000000000000000000000;;	// be executed in the order they were set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Canceling a request is non-deterministic. If a request has been canceled,
0000000000000000000000000000000000000000;;	// then the transport will choose, randomly, one of the state channels during
0000000000000000000000000000000000000000;;	// reads or getting the connection.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// readLoop() and getConn(req *Request, cm connectMethod)
0000000000000000000000000000000000000000;;	// https://github.com/golang/go/blob/master/src/net/http/transport.go
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Send will not close the request.Request's body.
0000000000000000000000000000000000000000;;	func (r *Request) Send() error {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if aws.BoolValue(r.Retryable) {
0000000000000000000000000000000000000000;;				if r.Config.LogLevel.Matches(aws.LogDebugWithRequestRetries) {
0000000000000000000000000000000000000000;;					r.Config.Logger.Log(fmt.Sprintf("DEBUG: Retrying Request %s/%s, attempt %d",
0000000000000000000000000000000000000000;;						r.ClientInfo.ServiceName, r.Operation.Name, r.RetryCount))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// The previous http.Request will have a reference to the r.Body
0000000000000000000000000000000000000000;;				// and the HTTP Client's Transport may still be reading from
0000000000000000000000000000000000000000;;				// the request's body even though the Client's Do returned.
0000000000000000000000000000000000000000;;				r.HTTPRequest = copyHTTPRequest(r.HTTPRequest, nil)
0000000000000000000000000000000000000000;;				r.ResetBody()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Closing response body to ensure that no response body is leaked
0000000000000000000000000000000000000000;;				// between retry attempts.
0000000000000000000000000000000000000000;;				if r.HTTPResponse != nil && r.HTTPResponse.Body != nil {
0000000000000000000000000000000000000000;;					r.HTTPResponse.Body.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.Sign()
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				return r.Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.Retryable = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.Handlers.Send.Run(r)
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				if !shouldRetryCancel(r) {
0000000000000000000000000000000000000000;;					return r.Error
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err := r.Error
0000000000000000000000000000000000000000;;				r.Handlers.Retry.Run(r)
0000000000000000000000000000000000000000;;				r.Handlers.AfterRetry.Run(r)
0000000000000000000000000000000000000000;;				if r.Error != nil {
0000000000000000000000000000000000000000;;					debugLogReqError(r, "Send Request", false, r.Error)
0000000000000000000000000000000000000000;;					return r.Error
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				debugLogReqError(r, "Send Request", true, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Handlers.UnmarshalMeta.Run(r)
0000000000000000000000000000000000000000;;			r.Handlers.ValidateResponse.Run(r)
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				err := r.Error
0000000000000000000000000000000000000000;;				r.Handlers.UnmarshalError.Run(r)
0000000000000000000000000000000000000000;;				r.Handlers.Retry.Run(r)
0000000000000000000000000000000000000000;;				r.Handlers.AfterRetry.Run(r)
0000000000000000000000000000000000000000;;				if r.Error != nil {
0000000000000000000000000000000000000000;;					debugLogReqError(r, "Validate Response", false, r.Error)
0000000000000000000000000000000000000000;;					return r.Error
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				debugLogReqError(r, "Validate Response", true, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.Handlers.Unmarshal.Run(r)
0000000000000000000000000000000000000000;;			if r.Error != nil {
0000000000000000000000000000000000000000;;				err := r.Error
0000000000000000000000000000000000000000;;				r.Handlers.Retry.Run(r)
0000000000000000000000000000000000000000;;				r.Handlers.AfterRetry.Run(r)
0000000000000000000000000000000000000000;;				if r.Error != nil {
0000000000000000000000000000000000000000;;					debugLogReqError(r, "Unmarshal Response", false, r.Error)
0000000000000000000000000000000000000000;;					return r.Error
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				debugLogReqError(r, "Unmarshal Response", true, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copy will copy a request which will allow for local manipulation of the
0000000000000000000000000000000000000000;;	// request.
0000000000000000000000000000000000000000;;	func (r *Request) copy() *Request {
0000000000000000000000000000000000000000;;		req := &Request{}
0000000000000000000000000000000000000000;;		*req = *r
0000000000000000000000000000000000000000;;		req.Handlers = r.Handlers.Copy()
0000000000000000000000000000000000000000;;		op := *r.Operation
0000000000000000000000000000000000000000;;		req.Operation = &op
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddToUserAgent adds the string to the end of the request's current user agent.
0000000000000000000000000000000000000000;;	func AddToUserAgent(r *Request, s string) {
0000000000000000000000000000000000000000;;		curUA := r.HTTPRequest.Header.Get("User-Agent")
0000000000000000000000000000000000000000;;		if len(curUA) > 0 {
0000000000000000000000000000000000000000;;			s = curUA + " " + s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.HTTPRequest.Header.Set("User-Agent", s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shouldRetryCancel(r *Request) bool {
0000000000000000000000000000000000000000;;		awsErr, ok := r.Error.(awserr.Error)
0000000000000000000000000000000000000000;;		timeoutErr := false
0000000000000000000000000000000000000000;;		errStr := r.Error.Error()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			err := awsErr.OrigErr()
0000000000000000000000000000000000000000;;			netErr, netOK := err.(net.Error)
0000000000000000000000000000000000000000;;			timeoutErr = netOK && netErr.Temporary()
0000000000000000000000000000000000000000;;			if urlErr, ok := err.(*url.Error); !timeoutErr && ok {
0000000000000000000000000000000000000000;;				errStr = urlErr.Err.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There can be two types of canceled errors here.
0000000000000000000000000000000000000000;;		// The first being a net.Error and the other being an error.
0000000000000000000000000000000000000000;;		// If the request was timed out, we want to continue the retry
0000000000000000000000000000000000000000;;		// process. Otherwise, return the canceled error.
0000000000000000000000000000000000000000;;		return timeoutErr ||
0000000000000000000000000000000000000000;;			(errStr != "net/http: request canceled" &&
0000000000000000000000000000000000000000;;				errStr != "net/http: request canceled while waiting for connection")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
