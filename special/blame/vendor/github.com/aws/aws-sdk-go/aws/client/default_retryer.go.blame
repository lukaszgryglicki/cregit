0000000000000000000000000000000000000000;;	package client
ba8371b1ad4f58d6c37fa3b43b005c306f9f2d92;Godeps/_workspace/src/github.com/aws/aws-sdk-go/aws/service/default_retryer.go[Godeps/_workspace/src/github.com/aws/aws-sdk-go/aws/service/default_retryer.go][vendor/github.com/aws/aws-sdk-go/aws/client/default_retryer.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultRetryer implements basic retry logic using exponential backoff for
0000000000000000000000000000000000000000;;	// most services. If you want to implement custom retry logic, implement the
0000000000000000000000000000000000000000;;	// request.Retryer interface or create a structure type that composes this
0000000000000000000000000000000000000000;;	// struct and override the specific methods. For example, to override only
0000000000000000000000000000000000000000;;	// the MaxRetries method:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//		type retryer struct {
0000000000000000000000000000000000000000;;	//      service.DefaultRetryer
0000000000000000000000000000000000000000;;	//    }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    // This implementation always has 100 max retries
0000000000000000000000000000000000000000;;	//    func (d retryer) MaxRetries() uint { return 100 }
0000000000000000000000000000000000000000;;	type DefaultRetryer struct {
0000000000000000000000000000000000000000;;		NumMaxRetries int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxRetries returns the number of maximum returns the service will use to make
0000000000000000000000000000000000000000;;	// an individual API request.
0000000000000000000000000000000000000000;;	func (d DefaultRetryer) MaxRetries() int {
0000000000000000000000000000000000000000;;		return d.NumMaxRetries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var seededRand = rand.New(&lockedSource{src: rand.NewSource(time.Now().UnixNano())})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetryRules returns the delay duration before retrying this request again
0000000000000000000000000000000000000000;;	func (d DefaultRetryer) RetryRules(r *request.Request) time.Duration {
0000000000000000000000000000000000000000;;		// Set the upper limit of delay in retrying at ~five minutes
0000000000000000000000000000000000000000;;		minTime := 30
0000000000000000000000000000000000000000;;		throttle := d.shouldThrottle(r)
0000000000000000000000000000000000000000;;		if throttle {
0000000000000000000000000000000000000000;;			minTime = 500
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retryCount := r.RetryCount
0000000000000000000000000000000000000000;;		if retryCount > 13 {
0000000000000000000000000000000000000000;;			retryCount = 13
0000000000000000000000000000000000000000;;		} else if throttle && retryCount > 8 {
0000000000000000000000000000000000000000;;			retryCount = 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delay := (1 << uint(retryCount)) * (seededRand.Intn(minTime) + minTime)
0000000000000000000000000000000000000000;;		return time.Duration(delay) * time.Millisecond
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShouldRetry returns true if the request should be retried.
0000000000000000000000000000000000000000;;	func (d DefaultRetryer) ShouldRetry(r *request.Request) bool {
0000000000000000000000000000000000000000;;		if r.HTTPResponse.StatusCode >= 500 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.IsErrorRetryable() || d.shouldThrottle(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShouldThrottle returns true if the request should be throttled.
0000000000000000000000000000000000000000;;	func (d DefaultRetryer) shouldThrottle(r *request.Request) bool {
0000000000000000000000000000000000000000;;		if r.HTTPResponse.StatusCode == 502 ||
0000000000000000000000000000000000000000;;			r.HTTPResponse.StatusCode == 503 ||
0000000000000000000000000000000000000000;;			r.HTTPResponse.StatusCode == 504 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.IsErrorThrottle()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lockedSource is a thread-safe implementation of rand.Source
0000000000000000000000000000000000000000;;	type lockedSource struct {
0000000000000000000000000000000000000000;;		lk  sync.Mutex
0000000000000000000000000000000000000000;;		src rand.Source
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *lockedSource) Int63() (n int64) {
0000000000000000000000000000000000000000;;		r.lk.Lock()
0000000000000000000000000000000000000000;;		n = r.src.Int63()
0000000000000000000000000000000000000000;;		r.lk.Unlock()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *lockedSource) Seed(seed int64) {
0000000000000000000000000000000000000000;;		r.lk.Lock()
0000000000000000000000000000000000000000;;		r.src.Seed(seed)
0000000000000000000000000000000000000000;;		r.lk.Unlock()
0000000000000000000000000000000000000000;;	}
