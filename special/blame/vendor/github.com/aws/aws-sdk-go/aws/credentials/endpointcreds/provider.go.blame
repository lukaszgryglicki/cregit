0000000000000000000000000000000000000000;;	// Package endpointcreds provides support for retrieving credentials from an
0000000000000000000000000000000000000000;;	// arbitrary HTTP endpoint.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The credentials endpoint Provider can receive both static and refreshable
0000000000000000000000000000000000000000;;	// credentials that will expire. Credentials are static when an "Expiration"
0000000000000000000000000000000000000000;;	// value is not provided in the endpoint's response.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Static credentials will never expire once they have been retrieved. The format
0000000000000000000000000000000000000000;;	// of the static credentials response:
0000000000000000000000000000000000000000;;	//    {
0000000000000000000000000000000000000000;;	//        "AccessKeyId" : "MUA...",
0000000000000000000000000000000000000000;;	//        "SecretAccessKey" : "/7PC5om....",
0000000000000000000000000000000000000000;;	//    }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Refreshable credentials will expire within the "ExpiryWindow" of the Expiration
0000000000000000000000000000000000000000;;	// value in the response. The format of the refreshable credentials response:
0000000000000000000000000000000000000000;;	//    {
0000000000000000000000000000000000000000;;	//        "AccessKeyId" : "MUA...",
0000000000000000000000000000000000000000;;	//        "SecretAccessKey" : "/7PC5om....",
0000000000000000000000000000000000000000;;	//        "Token" : "AQoDY....=",
0000000000000000000000000000000000000000;;	//        "Expiration" : "2016-02-25T06:03:31Z"
0000000000000000000000000000000000000000;;	//    }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Errors should be returned in the following format and only returned with 400
0000000000000000000000000000000000000000;;	// or 500 HTTP status codes.
0000000000000000000000000000000000000000;;	//    {
0000000000000000000000000000000000000000;;	//        "code": "ErrorCode",
0000000000000000000000000000000000000000;;	//        "message": "Helpful error message."
0000000000000000000000000000000000000000;;	//    }
0000000000000000000000000000000000000000;;	package endpointcreds
7b662bd39f4f8ebe87658b72a7df9da9c5a74c80;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/awserr"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/client"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/client/metadata"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/credentials"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName is the name of the credentials provider.
0000000000000000000000000000000000000000;;	const ProviderName = `CredentialsEndpointProvider`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provider satisfies the credentials.Provider interface, and is a client to
0000000000000000000000000000000000000000;;	// retrieve credentials from an arbitrary endpoint.
0000000000000000000000000000000000000000;;	type Provider struct {
0000000000000000000000000000000000000000;;		staticCreds bool
0000000000000000000000000000000000000000;;		credentials.Expiry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Requires a AWS Client to make HTTP requests to the endpoint with.
0000000000000000000000000000000000000000;;		// the Endpoint the request will be made to is provided by the aws.Config's
0000000000000000000000000000000000000000;;		// Endpoint value.
0000000000000000000000000000000000000000;;		Client *client.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExpiryWindow will allow the credentials to trigger refreshing prior to
0000000000000000000000000000000000000000;;		// the credentials actually expiring. This is beneficial so race conditions
0000000000000000000000000000000000000000;;		// with expiring credentials do not cause request to fail unexpectedly
0000000000000000000000000000000000000000;;		// due to ExpiredTokenException exceptions.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// So a ExpiryWindow of 10s would cause calls to IsExpired() to return true
0000000000000000000000000000000000000000;;		// 10 seconds before the credentials are actually expired.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If ExpiryWindow is 0 or less it will be ignored.
0000000000000000000000000000000000000000;;		ExpiryWindow time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProviderClient returns a credentials Provider for retrieving AWS credentials
0000000000000000000000000000000000000000;;	// from arbitrary endpoint.
0000000000000000000000000000000000000000;;	func NewProviderClient(cfg aws.Config, handlers request.Handlers, endpoint string, options ...func(*Provider)) credentials.Provider {
0000000000000000000000000000000000000000;;		p := &Provider{
0000000000000000000000000000000000000000;;			Client: client.New(
0000000000000000000000000000000000000000;;				cfg,
0000000000000000000000000000000000000000;;				metadata.ClientInfo{
0000000000000000000000000000000000000000;;					ServiceName: "CredentialsEndpoint",
0000000000000000000000000000000000000000;;					Endpoint:    endpoint,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				handlers,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.Client.Handlers.Unmarshal.PushBack(unmarshalHandler)
0000000000000000000000000000000000000000;;		p.Client.Handlers.UnmarshalError.PushBack(unmarshalError)
0000000000000000000000000000000000000000;;		p.Client.Handlers.Validate.Clear()
0000000000000000000000000000000000000000;;		p.Client.Handlers.Validate.PushBack(validateEndpointHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			option(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCredentialsClient returns a Credentials wrapper for retrieving credentials
0000000000000000000000000000000000000000;;	// from an arbitrary endpoint concurrently. The client will request the
0000000000000000000000000000000000000000;;	func NewCredentialsClient(cfg aws.Config, handlers request.Handlers, endpoint string, options ...func(*Provider)) *credentials.Credentials {
0000000000000000000000000000000000000000;;		return credentials.NewCredentials(NewProviderClient(cfg, handlers, endpoint, options...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsExpired returns true if the credentials retrieved are expired, or not yet
0000000000000000000000000000000000000000;;	// retrieved.
0000000000000000000000000000000000000000;;	func (p *Provider) IsExpired() bool {
0000000000000000000000000000000000000000;;		if p.staticCreds {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.Expiry.IsExpired()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieve will attempt to request the credentials from the endpoint the Provider
0000000000000000000000000000000000000000;;	// was configured for. And error will be returned if the retrieval fails.
0000000000000000000000000000000000000000;;	func (p *Provider) Retrieve() (credentials.Value, error) {
0000000000000000000000000000000000000000;;		resp, err := p.getCredentials()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return credentials.Value{ProviderName: ProviderName},
0000000000000000000000000000000000000000;;				awserr.New("CredentialsEndpointError", "failed to load credentials", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Expiration != nil {
0000000000000000000000000000000000000000;;			p.SetExpiration(*resp.Expiration, p.ExpiryWindow)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.staticCreds = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return credentials.Value{
0000000000000000000000000000000000000000;;			AccessKeyID:     resp.AccessKeyID,
0000000000000000000000000000000000000000;;			SecretAccessKey: resp.SecretAccessKey,
0000000000000000000000000000000000000000;;			SessionToken:    resp.Token,
0000000000000000000000000000000000000000;;			ProviderName:    ProviderName,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type getCredentialsOutput struct {
0000000000000000000000000000000000000000;;		Expiration      *time.Time
0000000000000000000000000000000000000000;;		AccessKeyID     string
0000000000000000000000000000000000000000;;		SecretAccessKey string
0000000000000000000000000000000000000000;;		Token           string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorOutput struct {
0000000000000000000000000000000000000000;;		Code    string `json:"code"`
0000000000000000000000000000000000000000;;		Message string `json:"message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Provider) getCredentials() (*getCredentialsOutput, error) {
0000000000000000000000000000000000000000;;		op := &request.Operation{
0000000000000000000000000000000000000000;;			Name:       "GetCredentials",
0000000000000000000000000000000000000000;;			HTTPMethod: "GET",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := &getCredentialsOutput{}
0000000000000000000000000000000000000000;;		req := p.Client.NewRequest(op, nil, out)
0000000000000000000000000000000000000000;;		req.HTTPRequest.Header.Set("Accept", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, req.Send()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEndpointHandler(r *request.Request) {
0000000000000000000000000000000000000000;;		if len(r.ClientInfo.Endpoint) == 0 {
0000000000000000000000000000000000000000;;			r.Error = aws.ErrMissingEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalHandler(r *request.Request) {
0000000000000000000000000000000000000000;;		defer r.HTTPResponse.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := r.Data.(*getCredentialsOutput)
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(r.HTTPResponse.Body).Decode(&out); err != nil {
0000000000000000000000000000000000000000;;			r.Error = awserr.New("SerializationError",
0000000000000000000000000000000000000000;;				"failed to decode endpoint credentials",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalError(r *request.Request) {
0000000000000000000000000000000000000000;;		defer r.HTTPResponse.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errOut errorOutput
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(r.HTTPResponse.Body).Decode(&errOut); err != nil {
0000000000000000000000000000000000000000;;			r.Error = awserr.New("SerializationError",
0000000000000000000000000000000000000000;;				"failed to decode endpoint credentials",
0000000000000000000000000000000000000000;;				err,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Response body format is not consistent between metadata endpoints.
0000000000000000000000000000000000000000;;		// Grab the error message as a string and include that as the source error
0000000000000000000000000000000000000000;;		r.Error = awserr.New(errOut.Code, errOut.Message, nil)
0000000000000000000000000000000000000000;;	}
