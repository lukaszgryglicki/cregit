0000000000000000000000000000000000000000;;	// Package stscreds are credential Providers to retrieve STS AWS credentials.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// STS provides multiple ways to retrieve credentials which can be used when making
0000000000000000000000000000000000000000;;	// future AWS service API operation calls.
0000000000000000000000000000000000000000;;	package stscreds
7b662bd39f4f8ebe87658b72a7df9da9c5a74c80;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/client"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/credentials"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/service/sts"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderName provides a name of AssumeRole provider
0000000000000000000000000000000000000000;;	const ProviderName = "AssumeRoleProvider"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssumeRoler represents the minimal subset of the STS client API used by this provider.
0000000000000000000000000000000000000000;;	type AssumeRoler interface {
0000000000000000000000000000000000000000;;		AssumeRole(input *sts.AssumeRoleInput) (*sts.AssumeRoleOutput, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultDuration is the default amount of time in minutes that the credentials
0000000000000000000000000000000000000000;;	// will be valid for.
0000000000000000000000000000000000000000;;	var DefaultDuration = time.Duration(15) * time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssumeRoleProvider retrieves temporary credentials from the STS service, and
0000000000000000000000000000000000000000;;	// keeps track of their expiration time. This provider must be used explicitly,
0000000000000000000000000000000000000000;;	// as it is not included in the credentials chain.
0000000000000000000000000000000000000000;;	type AssumeRoleProvider struct {
0000000000000000000000000000000000000000;;		credentials.Expiry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// STS client to make assume role request with.
0000000000000000000000000000000000000000;;		Client AssumeRoler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Role to be assumed.
0000000000000000000000000000000000000000;;		RoleARN string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Session name, if you wish to reuse the credentials elsewhere.
0000000000000000000000000000000000000000;;		RoleSessionName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expiry duration of the STS credentials. Defaults to 15 minutes if not set.
0000000000000000000000000000000000000000;;		Duration time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional ExternalID to pass along, defaults to nil if not set.
0000000000000000000000000000000000000000;;		ExternalID *string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The policy plain text must be 2048 bytes or shorter. However, an internal
0000000000000000000000000000000000000000;;		// conversion compresses it into a packed binary format with a separate limit.
0000000000000000000000000000000000000000;;		// The PackedPolicySize response element indicates by percentage how close to
0000000000000000000000000000000000000000;;		// the upper size limit the policy is, with 100% equaling the maximum allowed
0000000000000000000000000000000000000000;;		// size.
0000000000000000000000000000000000000000;;		Policy *string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The identification number of the MFA device that is associated with the user
0000000000000000000000000000000000000000;;		// who is making the AssumeRole call. Specify this value if the trust policy
0000000000000000000000000000000000000000;;		// of the role being assumed includes a condition that requires MFA authentication.
0000000000000000000000000000000000000000;;		// The value is either the serial number for a hardware device (such as GAHT12345678)
0000000000000000000000000000000000000000;;		// or an Amazon Resource Name (ARN) for a virtual device (such as arn:aws:iam::123456789012:mfa/user).
0000000000000000000000000000000000000000;;		SerialNumber *string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The value provided by the MFA device, if the trust policy of the role being
0000000000000000000000000000000000000000;;		// assumed requires MFA (that is, if the policy includes a condition that tests
0000000000000000000000000000000000000000;;		// for MFA). If the role being assumed requires MFA and if the TokenCode value
0000000000000000000000000000000000000000;;		// is missing or expired, the AssumeRole call returns an "access denied" error.
0000000000000000000000000000000000000000;;		TokenCode *string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExpiryWindow will allow the credentials to trigger refreshing prior to
0000000000000000000000000000000000000000;;		// the credentials actually expiring. This is beneficial so race conditions
0000000000000000000000000000000000000000;;		// with expiring credentials do not cause request to fail unexpectedly
0000000000000000000000000000000000000000;;		// due to ExpiredTokenException exceptions.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// So a ExpiryWindow of 10s would cause calls to IsExpired() to return true
0000000000000000000000000000000000000000;;		// 10 seconds before the credentials are actually expired.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If ExpiryWindow is 0 or less it will be ignored.
0000000000000000000000000000000000000000;;		ExpiryWindow time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCredentials returns a pointer to a new Credentials object wrapping the
0000000000000000000000000000000000000000;;	// AssumeRoleProvider. The credentials will expire every 15 minutes and the
0000000000000000000000000000000000000000;;	// role will be named after a nanosecond timestamp of this operation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Takes a Config provider to create the STS client. The ConfigProvider is
0000000000000000000000000000000000000000;;	// satisfied by the session.Session type.
0000000000000000000000000000000000000000;;	func NewCredentials(c client.ConfigProvider, roleARN string, options ...func(*AssumeRoleProvider)) *credentials.Credentials {
0000000000000000000000000000000000000000;;		p := &AssumeRoleProvider{
0000000000000000000000000000000000000000;;			Client:   sts.New(c),
0000000000000000000000000000000000000000;;			RoleARN:  roleARN,
0000000000000000000000000000000000000000;;			Duration: DefaultDuration,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			option(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return credentials.NewCredentials(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCredentialsWithClient returns a pointer to a new Credentials object wrapping the
0000000000000000000000000000000000000000;;	// AssumeRoleProvider. The credentials will expire every 15 minutes and the
0000000000000000000000000000000000000000;;	// role will be named after a nanosecond timestamp of this operation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Takes an AssumeRoler which can be satisfiede by the STS client.
0000000000000000000000000000000000000000;;	func NewCredentialsWithClient(svc AssumeRoler, roleARN string, options ...func(*AssumeRoleProvider)) *credentials.Credentials {
0000000000000000000000000000000000000000;;		p := &AssumeRoleProvider{
0000000000000000000000000000000000000000;;			Client:   svc,
0000000000000000000000000000000000000000;;			RoleARN:  roleARN,
0000000000000000000000000000000000000000;;			Duration: DefaultDuration,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			option(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return credentials.NewCredentials(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieve generates a new set of temporary credentials using STS.
0000000000000000000000000000000000000000;;	func (p *AssumeRoleProvider) Retrieve() (credentials.Value, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply defaults where parameters are not set.
0000000000000000000000000000000000000000;;		if p.RoleSessionName == "" {
0000000000000000000000000000000000000000;;			// Try to work out a role name that will hopefully end up unique.
0000000000000000000000000000000000000000;;			p.RoleSessionName = fmt.Sprintf("%d", time.Now().UTC().UnixNano())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Duration == 0 {
0000000000000000000000000000000000000000;;			// Expire as often as AWS permits.
0000000000000000000000000000000000000000;;			p.Duration = DefaultDuration
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		input := &sts.AssumeRoleInput{
0000000000000000000000000000000000000000;;			DurationSeconds: aws.Int64(int64(p.Duration / time.Second)),
0000000000000000000000000000000000000000;;			RoleArn:         aws.String(p.RoleARN),
0000000000000000000000000000000000000000;;			RoleSessionName: aws.String(p.RoleSessionName),
0000000000000000000000000000000000000000;;			ExternalId:      p.ExternalID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Policy != nil {
0000000000000000000000000000000000000000;;			input.Policy = p.Policy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.SerialNumber != nil && p.TokenCode != nil {
0000000000000000000000000000000000000000;;			input.SerialNumber = p.SerialNumber
0000000000000000000000000000000000000000;;			input.TokenCode = p.TokenCode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		roleOutput, err := p.Client.AssumeRole(input)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return credentials.Value{ProviderName: ProviderName}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We will proactively generate new credentials before they expire.
0000000000000000000000000000000000000000;;		p.SetExpiration(*roleOutput.Credentials.Expiration, p.ExpiryWindow)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return credentials.Value{
0000000000000000000000000000000000000000;;			AccessKeyID:     *roleOutput.Credentials.AccessKeyId,
0000000000000000000000000000000000000000;;			SecretAccessKey: *roleOutput.Credentials.SecretAccessKey,
0000000000000000000000000000000000000000;;			SessionToken:    *roleOutput.Credentials.SessionToken,
0000000000000000000000000000000000000000;;			ProviderName:    ProviderName,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
