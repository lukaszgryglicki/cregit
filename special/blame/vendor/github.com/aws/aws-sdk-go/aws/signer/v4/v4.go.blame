0000000000000000000000000000000000000000;;	// Package v4 implements signing for AWS V4 signer
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Provides request signing for request that need to be signed with
0000000000000000000000000000000000000000;;	// AWS V4 Signatures.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Standalone Signer
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Generally using the signer outside of the SDK should not require any additional
0000000000000000000000000000000000000000;;	// logic when using Go v1.5 or higher. The signer does this by taking advantage
0000000000000000000000000000000000000000;;	// of the URL.EscapedPath method. If your request URI requires additional escaping
0000000000000000000000000000000000000000;;	// you many need to use the URL.Opaque to define what the raw URI should be sent
0000000000000000000000000000000000000000;;	// to the service as.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The signer will first check the URL.Opaque field, and use its value if set.
0000000000000000000000000000000000000000;;	// The signer does require the URL.Opaque field to be set in the form of:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     "//<hostname>/<path>"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // e.g.
0000000000000000000000000000000000000000;;	//     "//example.com/some/path"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The leading "//" and hostname are required or the URL.Opaque escaping will
0000000000000000000000000000000000000000;;	// not work correctly.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If URL.Opaque is not set the signer will fallback to the URL.EscapedPath()
0000000000000000000000000000000000000000;;	// method and using the returned value. If you're using Go v1.4 you must set
0000000000000000000000000000000000000000;;	// URL.Opaque if the URI path needs escaping. If URL.Opaque is not set with
0000000000000000000000000000000000000000;;	// Go v1.5 the signer will fallback to URL.Path.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// AWS v4 signature validation requires that the canonical string's URI path
0000000000000000000000000000000000000000;;	// element must be the URI escaped form of the HTTP request's path.
0000000000000000000000000000000000000000;;	// http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Go HTTP client will perform escaping automatically on the request. Some
0000000000000000000000000000000000000000;;	// of these escaping may cause signature validation errors because the HTTP
0000000000000000000000000000000000000000;;	// request differs from the URI path or query that the signature was generated.
0000000000000000000000000000000000000000;;	// https://golang.org/pkg/net/url/#URL.EscapedPath
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Because of this, it is recommended that when using the signer outside of the
0000000000000000000000000000000000000000;;	// SDK that explicitly escaping the request prior to being signed is preferable,
0000000000000000000000000000000000000000;;	// and will help prevent signature validation errors. This can be done by setting
0000000000000000000000000000000000000000;;	// the URL.Opaque or URL.RawPath. The SDK will use URL.Opaque first and then
0000000000000000000000000000000000000000;;	// call URL.EscapedPath() if Opaque is not set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If signing a request intended for HTTP2 server, and you're using Go 1.6.2
0000000000000000000000000000000000000000;;	// through 1.7.4 you should use the URL.RawPath as the pre-escaped form of the
0000000000000000000000000000000000000000;;	// request URL. https://github.com/golang/go/issues/16847 points to a bug in
0000000000000000000000000000000000000000;;	// Go pre 1.8 that failes to make HTTP2 requests using absolute URL in the HTTP
0000000000000000000000000000000000000000;;	// message. URL.Opaque generally will force Go to make requests with absolute URL.
0000000000000000000000000000000000000000;;	// URL.RawPath does not do this, but RawPath must be a valid escaping of Path
0000000000000000000000000000000000000000;;	// or url.EscapedPath will ignore the RawPath escaping.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Test `TestStandaloneSign` provides a complete example of using the signer
0000000000000000000000000000000000000000;;	// outside of the SDK and pre-escaping the URI path.
0000000000000000000000000000000000000000;;	package v4
7b662bd39f4f8ebe87658b72a7df9da9c5a74c80;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/hmac"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/credentials"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/aws/request"
0000000000000000000000000000000000000000;;		"github.com/aws/aws-sdk-go/private/protocol/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		authHeaderPrefix = "AWS4-HMAC-SHA256"
0000000000000000000000000000000000000000;;		timeFormat       = "20060102T150405Z"
0000000000000000000000000000000000000000;;		shortTimeFormat  = "20060102"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// emptyStringSHA256 is a SHA256 of an empty string
0000000000000000000000000000000000000000;;		emptyStringSHA256 = `e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855`
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ignoredHeaders = rules{
0000000000000000000000000000000000000000;;		blacklist{
0000000000000000000000000000000000000000;;			mapRule{
0000000000000000000000000000000000000000;;				"Authorization":   struct{}{},
0000000000000000000000000000000000000000;;				"User-Agent":      struct{}{},
0000000000000000000000000000000000000000;;				"X-Amzn-Trace-Id": struct{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requiredSignedHeaders is a whitelist for build canonical headers.
0000000000000000000000000000000000000000;;	var requiredSignedHeaders = rules{
0000000000000000000000000000000000000000;;		whitelist{
0000000000000000000000000000000000000000;;			mapRule{
0000000000000000000000000000000000000000;;				"Cache-Control":                                               struct{}{},
0000000000000000000000000000000000000000;;				"Content-Disposition":                                         struct{}{},
0000000000000000000000000000000000000000;;				"Content-Encoding":                                            struct{}{},
0000000000000000000000000000000000000000;;				"Content-Language":                                            struct{}{},
0000000000000000000000000000000000000000;;				"Content-Md5":                                                 struct{}{},
0000000000000000000000000000000000000000;;				"Content-Type":                                                struct{}{},
0000000000000000000000000000000000000000;;				"Expires":                                                     struct{}{},
0000000000000000000000000000000000000000;;				"If-Match":                                                    struct{}{},
0000000000000000000000000000000000000000;;				"If-Modified-Since":                                           struct{}{},
0000000000000000000000000000000000000000;;				"If-None-Match":                                               struct{}{},
0000000000000000000000000000000000000000;;				"If-Unmodified-Since":                                         struct{}{},
0000000000000000000000000000000000000000;;				"Range":                                                       struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Acl":                                                   struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source":                                           struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-If-Match":                                  struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-If-Modified-Since":                         struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-If-None-Match":                             struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-If-Unmodified-Since":                       struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-Range":                                     struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Algorithm": struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key":       struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Copy-Source-Server-Side-Encryption-Customer-Key-Md5":   struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Grant-Full-control":                                    struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Grant-Read":                                            struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Grant-Read-Acp":                                        struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Grant-Write":                                           struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Grant-Write-Acp":                                       struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Metadata-Directive":                                    struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Mfa":                                                   struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Request-Payer":                                         struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Server-Side-Encryption":                                struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Server-Side-Encryption-Aws-Kms-Key-Id":                 struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Server-Side-Encryption-Customer-Algorithm":             struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Server-Side-Encryption-Customer-Key":                   struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Server-Side-Encryption-Customer-Key-Md5":               struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Storage-Class":                                         struct{}{},
0000000000000000000000000000000000000000;;				"X-Amz-Website-Redirect-Location":                             struct{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		patterns{"X-Amz-Meta-"},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allowedHoisting is a whitelist for build query headers. The boolean value
0000000000000000000000000000000000000000;;	// represents whether or not it is a pattern.
0000000000000000000000000000000000000000;;	var allowedQueryHoisting = inclusiveRules{
0000000000000000000000000000000000000000;;		blacklist{requiredSignedHeaders},
0000000000000000000000000000000000000000;;		patterns{"X-Amz-"},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signer applies AWS v4 signing to given request. Use this to sign requests
0000000000000000000000000000000000000000;;	// that need to be signed with AWS V4 Signatures.
0000000000000000000000000000000000000000;;	type Signer struct {
0000000000000000000000000000000000000000;;		// The authentication credentials the request will be signed against.
0000000000000000000000000000000000000000;;		// This value must be set to sign requests.
0000000000000000000000000000000000000000;;		Credentials *credentials.Credentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sets the log level the signer should use when reporting information to
0000000000000000000000000000000000000000;;		// the logger. If the logger is nil nothing will be logged. See
0000000000000000000000000000000000000000;;		// aws.LogLevelType for more information on available logging levels
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// By default nothing will be logged.
0000000000000000000000000000000000000000;;		Debug aws.LogLevelType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The logger loging information will be written to. If there the logger
0000000000000000000000000000000000000000;;		// is nil, nothing will be logged.
0000000000000000000000000000000000000000;;		Logger aws.Logger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Disables the Signer's moving HTTP header key/value pairs from the HTTP
0000000000000000000000000000000000000000;;		// request header to the request's query string. This is most commonly used
0000000000000000000000000000000000000000;;		// with pre-signed requests preventing headers from being added to the
0000000000000000000000000000000000000000;;		// request's query string.
0000000000000000000000000000000000000000;;		DisableHeaderHoisting bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Disables the automatic escaping of the URI path of the request for the
0000000000000000000000000000000000000000;;		// siganture's canonical string's path. For services that do not need additional
0000000000000000000000000000000000000000;;		// escaping then use this to disable the signer escaping the path.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// S3 is an example of a service that does not need additional escaping.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// http://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html
0000000000000000000000000000000000000000;;		DisableURIPathEscaping bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Disales the automatical setting of the HTTP request's Body field with the
0000000000000000000000000000000000000000;;		// io.ReadSeeker passed in to the signer. This is useful if you're using a
0000000000000000000000000000000000000000;;		// custom wrapper around the body for the io.ReadSeeker and want to preserve
0000000000000000000000000000000000000000;;		// the Body value on the Request.Body.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This does run the risk of signing a request with a body that will not be
0000000000000000000000000000000000000000;;		// sent in the request. Need to ensure that the underlying data of the Body
0000000000000000000000000000000000000000;;		// values are the same.
0000000000000000000000000000000000000000;;		DisableRequestBodyOverwrite bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// currentTimeFn returns the time value which represents the current time.
0000000000000000000000000000000000000000;;		// This value should only be used for testing. If it is nil the default
0000000000000000000000000000000000000000;;		// time.Now will be used.
0000000000000000000000000000000000000000;;		currentTimeFn func() time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSigner returns a Signer pointer configured with the credentials and optional
0000000000000000000000000000000000000000;;	// option values provided. If not options are provided the Signer will use its
0000000000000000000000000000000000000000;;	// default configuration.
0000000000000000000000000000000000000000;;	func NewSigner(credentials *credentials.Credentials, options ...func(*Signer)) *Signer {
0000000000000000000000000000000000000000;;		v4 := &Signer{
0000000000000000000000000000000000000000;;			Credentials: credentials,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			option(v4)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v4
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type signingCtx struct {
0000000000000000000000000000000000000000;;		ServiceName      string
0000000000000000000000000000000000000000;;		Region           string
0000000000000000000000000000000000000000;;		Request          *http.Request
0000000000000000000000000000000000000000;;		Body             io.ReadSeeker
0000000000000000000000000000000000000000;;		Query            url.Values
0000000000000000000000000000000000000000;;		Time             time.Time
0000000000000000000000000000000000000000;;		ExpireTime       time.Duration
0000000000000000000000000000000000000000;;		SignedHeaderVals http.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DisableURIPathEscaping bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		credValues         credentials.Value
0000000000000000000000000000000000000000;;		isPresign          bool
0000000000000000000000000000000000000000;;		formattedTime      string
0000000000000000000000000000000000000000;;		formattedShortTime string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bodyDigest       string
0000000000000000000000000000000000000000;;		signedHeaders    string
0000000000000000000000000000000000000000;;		canonicalHeaders string
0000000000000000000000000000000000000000;;		canonicalString  string
0000000000000000000000000000000000000000;;		credentialString string
0000000000000000000000000000000000000000;;		stringToSign     string
0000000000000000000000000000000000000000;;		signature        string
0000000000000000000000000000000000000000;;		authorization    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign signs AWS v4 requests with the provided body, service name, region the
0000000000000000000000000000000000000000;;	// request is made to, and time the request is signed at. The signTime allows
0000000000000000000000000000000000000000;;	// you to specify that a request is signed for the future, and cannot be
0000000000000000000000000000000000000000;;	// used until then.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns a list of HTTP headers that were included in the signature or an
0000000000000000000000000000000000000000;;	// error if signing the request failed. Generally for signed requests this value
0000000000000000000000000000000000000000;;	// is not needed as the full request context will be captured by the http.Request
0000000000000000000000000000000000000000;;	// value. It is included for reference though.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Sign will set the request's Body to be the `body` parameter passed in. If
0000000000000000000000000000000000000000;;	// the body is not already an io.ReadCloser, it will be wrapped within one. If
0000000000000000000000000000000000000000;;	// a `nil` body parameter passed to Sign, the request's Body field will be
0000000000000000000000000000000000000000;;	// also set to nil. Its important to note that this functionality will not
0000000000000000000000000000000000000000;;	// change the request's ContentLength of the request.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Sign differs from Presign in that it will sign the request using HTTP
0000000000000000000000000000000000000000;;	// header values. This type of signing is intended for http.Request values that
0000000000000000000000000000000000000000;;	// will not be shared, or are shared in a way the header values on the request
0000000000000000000000000000000000000000;;	// will not be lost.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The requests body is an io.ReadSeeker so the SHA256 of the body can be
0000000000000000000000000000000000000000;;	// generated. To bypass the signer computing the hash you can set the
0000000000000000000000000000000000000000;;	// "X-Amz-Content-Sha256" header with a precomputed value. The signer will
0000000000000000000000000000000000000000;;	// only compute the hash if the request header value is empty.
0000000000000000000000000000000000000000;;	func (v4 Signer) Sign(r *http.Request, body io.ReadSeeker, service, region string, signTime time.Time) (http.Header, error) {
0000000000000000000000000000000000000000;;		return v4.signWithBody(r, body, service, region, 0, signTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Presign signs AWS v4 requests with the provided body, service name, region
0000000000000000000000000000000000000000;;	// the request is made to, and time the request is signed at. The signTime
0000000000000000000000000000000000000000;;	// allows you to specify that a request is signed for the future, and cannot
0000000000000000000000000000000000000000;;	// be used until then.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns a list of HTTP headers that were included in the signature or an
0000000000000000000000000000000000000000;;	// error if signing the request failed. For presigned requests these headers
0000000000000000000000000000000000000000;;	// and their values must be included on the HTTP request when it is made. This
0000000000000000000000000000000000000000;;	// is helpful to know what header values need to be shared with the party the
0000000000000000000000000000000000000000;;	// presigned request will be distributed to.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Presign differs from Sign in that it will sign the request using query string
0000000000000000000000000000000000000000;;	// instead of header values. This allows you to share the Presigned Request's
0000000000000000000000000000000000000000;;	// URL with third parties, or distribute it throughout your system with minimal
0000000000000000000000000000000000000000;;	// dependencies.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Presign also takes an exp value which is the duration the
0000000000000000000000000000000000000000;;	// signed request will be valid after the signing time. This is allows you to
0000000000000000000000000000000000000000;;	// set when the request will expire.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The requests body is an io.ReadSeeker so the SHA256 of the body can be
0000000000000000000000000000000000000000;;	// generated. To bypass the signer computing the hash you can set the
0000000000000000000000000000000000000000;;	// "X-Amz-Content-Sha256" header with a precomputed value. The signer will
0000000000000000000000000000000000000000;;	// only compute the hash if the request header value is empty.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Presigning a S3 request will not compute the body's SHA256 hash by default.
0000000000000000000000000000000000000000;;	// This is done due to the general use case for S3 presigned URLs is to share
0000000000000000000000000000000000000000;;	// PUT/GET capabilities. If you would like to include the body's SHA256 in the
0000000000000000000000000000000000000000;;	// presigned request's signature you can set the "X-Amz-Content-Sha256"
0000000000000000000000000000000000000000;;	// HTTP header and that will be included in the request's signature.
0000000000000000000000000000000000000000;;	func (v4 Signer) Presign(r *http.Request, body io.ReadSeeker, service, region string, exp time.Duration, signTime time.Time) (http.Header, error) {
0000000000000000000000000000000000000000;;		return v4.signWithBody(r, body, service, region, exp, signTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v4 Signer) signWithBody(r *http.Request, body io.ReadSeeker, service, region string, exp time.Duration, signTime time.Time) (http.Header, error) {
0000000000000000000000000000000000000000;;		currentTimeFn := v4.currentTimeFn
0000000000000000000000000000000000000000;;		if currentTimeFn == nil {
0000000000000000000000000000000000000000;;			currentTimeFn = time.Now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := &signingCtx{
0000000000000000000000000000000000000000;;			Request:                r,
0000000000000000000000000000000000000000;;			Body:                   body,
0000000000000000000000000000000000000000;;			Query:                  r.URL.Query(),
0000000000000000000000000000000000000000;;			Time:                   signTime,
0000000000000000000000000000000000000000;;			ExpireTime:             exp,
0000000000000000000000000000000000000000;;			isPresign:              exp != 0,
0000000000000000000000000000000000000000;;			ServiceName:            service,
0000000000000000000000000000000000000000;;			Region:                 region,
0000000000000000000000000000000000000000;;			DisableURIPathEscaping: v4.DisableURIPathEscaping,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key := range ctx.Query {
0000000000000000000000000000000000000000;;			sort.Strings(ctx.Query[key])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.isRequestSigned() {
0000000000000000000000000000000000000000;;			ctx.Time = currentTimeFn()
0000000000000000000000000000000000000000;;			ctx.handlePresignRemoval()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		ctx.credValues, err = v4.Credentials.Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return http.Header{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.assignAmzQueryValues()
0000000000000000000000000000000000000000;;		ctx.build(v4.DisableHeaderHoisting)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the request is not presigned the body should be attached to it. This
0000000000000000000000000000000000000000;;		// prevents the confusion of wanting to send a signed request without
0000000000000000000000000000000000000000;;		// the body the request was signed for attached.
0000000000000000000000000000000000000000;;		if !(v4.DisableRequestBodyOverwrite || ctx.isPresign) {
0000000000000000000000000000000000000000;;			var reader io.ReadCloser
0000000000000000000000000000000000000000;;			if body != nil {
0000000000000000000000000000000000000000;;				var ok bool
0000000000000000000000000000000000000000;;				if reader, ok = body.(io.ReadCloser); !ok {
0000000000000000000000000000000000000000;;					reader = ioutil.NopCloser(body)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Body = reader
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v4.Debug.Matches(aws.LogDebugWithSigning) {
0000000000000000000000000000000000000000;;			v4.logSigningInfo(ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ctx.SignedHeaderVals, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) handlePresignRemoval() {
0000000000000000000000000000000000000000;;		if !ctx.isPresign {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The credentials have expired for this request. The current signing
0000000000000000000000000000000000000000;;		// is invalid, and needs to be request because the request will fail.
0000000000000000000000000000000000000000;;		ctx.removePresign()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the request's query string to ensure the values stays in
0000000000000000000000000000000000000000;;		// sync in the case retrieving the new credentials fails.
0000000000000000000000000000000000000000;;		ctx.Request.URL.RawQuery = ctx.Query.Encode()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) assignAmzQueryValues() {
0000000000000000000000000000000000000000;;		if ctx.isPresign {
0000000000000000000000000000000000000000;;			ctx.Query.Set("X-Amz-Algorithm", authHeaderPrefix)
0000000000000000000000000000000000000000;;			if ctx.credValues.SessionToken != "" {
0000000000000000000000000000000000000000;;				ctx.Query.Set("X-Amz-Security-Token", ctx.credValues.SessionToken)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ctx.Query.Del("X-Amz-Security-Token")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.credValues.SessionToken != "" {
0000000000000000000000000000000000000000;;			ctx.Request.Header.Set("X-Amz-Security-Token", ctx.credValues.SessionToken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignRequestHandler is a named request handler the SDK will use to sign
0000000000000000000000000000000000000000;;	// service client request with using the V4 signature.
0000000000000000000000000000000000000000;;	var SignRequestHandler = request.NamedHandler{
0000000000000000000000000000000000000000;;		Name: "v4.SignRequestHandler", Fn: SignSDKRequest,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignSDKRequest signs an AWS request with the V4 signature. This
0000000000000000000000000000000000000000;;	// request handler is bested used only with the SDK's built in service client's
0000000000000000000000000000000000000000;;	// API operation requests.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function should not be used on its on its own, but in conjunction with
0000000000000000000000000000000000000000;;	// an AWS service client's API operation call. To sign a standalone request
0000000000000000000000000000000000000000;;	// not created by a service client's API operation method use the "Sign" or
0000000000000000000000000000000000000000;;	// "Presign" functions of the "Signer" type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the credentials of the request's config are set to
0000000000000000000000000000000000000000;;	// credentials.AnonymousCredentials the request will not be signed.
0000000000000000000000000000000000000000;;	func SignSDKRequest(req *request.Request) {
0000000000000000000000000000000000000000;;		signSDKRequestWithCurrTime(req, time.Now)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func signSDKRequestWithCurrTime(req *request.Request, curTimeFn func() time.Time) {
0000000000000000000000000000000000000000;;		// If the request does not need to be signed ignore the signing of the
0000000000000000000000000000000000000000;;		// request if the AnonymousCredentials object is used.
0000000000000000000000000000000000000000;;		if req.Config.Credentials == credentials.AnonymousCredentials {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		region := req.ClientInfo.SigningRegion
0000000000000000000000000000000000000000;;		if region == "" {
0000000000000000000000000000000000000000;;			region = aws.StringValue(req.Config.Region)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := req.ClientInfo.SigningName
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			name = req.ClientInfo.ServiceName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v4 := NewSigner(req.Config.Credentials, func(v4 *Signer) {
0000000000000000000000000000000000000000;;			v4.Debug = req.Config.LogLevel.Value()
0000000000000000000000000000000000000000;;			v4.Logger = req.Config.Logger
0000000000000000000000000000000000000000;;			v4.DisableHeaderHoisting = req.NotHoist
0000000000000000000000000000000000000000;;			v4.currentTimeFn = curTimeFn
0000000000000000000000000000000000000000;;			if name == "s3" {
0000000000000000000000000000000000000000;;				// S3 service should not have any escaping applied
0000000000000000000000000000000000000000;;				v4.DisableURIPathEscaping = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Prevents setting the HTTPRequest's Body. Since the Body could be
0000000000000000000000000000000000000000;;			// wrapped in a custom io.Closer that we do not want to be stompped
0000000000000000000000000000000000000000;;			// on top of by the signer.
0000000000000000000000000000000000000000;;			v4.DisableRequestBodyOverwrite = true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signingTime := req.Time
0000000000000000000000000000000000000000;;		if !req.LastSignedAt.IsZero() {
0000000000000000000000000000000000000000;;			signingTime = req.LastSignedAt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signedHeaders, err := v4.signWithBody(req.HTTPRequest, req.GetBody(),
0000000000000000000000000000000000000000;;			name, region, req.ExpireTime, signingTime,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			req.Error = err
0000000000000000000000000000000000000000;;			req.SignedHeaderVals = nil
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.SignedHeaderVals = signedHeaders
0000000000000000000000000000000000000000;;		req.LastSignedAt = curTimeFn()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const logSignInfoMsg = `DEBUG: Request Signature:
0000000000000000000000000000000000000000;;	---[ CANONICAL STRING  ]-----------------------------
0000000000000000000000000000000000000000;;	%s
0000000000000000000000000000000000000000;;	---[ STRING TO SIGN ]--------------------------------
0000000000000000000000000000000000000000;;	%s%s
0000000000000000000000000000000000000000;;	-----------------------------------------------------`
0000000000000000000000000000000000000000;;	const logSignedURLMsg = `
0000000000000000000000000000000000000000;;	---[ SIGNED URL ]------------------------------------
0000000000000000000000000000000000000000;;	%s`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v4 *Signer) logSigningInfo(ctx *signingCtx) {
0000000000000000000000000000000000000000;;		signedURLMsg := ""
0000000000000000000000000000000000000000;;		if ctx.isPresign {
0000000000000000000000000000000000000000;;			signedURLMsg = fmt.Sprintf(logSignedURLMsg, ctx.Request.URL.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(logSignInfoMsg, ctx.canonicalString, ctx.stringToSign, signedURLMsg)
0000000000000000000000000000000000000000;;		v4.Logger.Log(msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) build(disableHeaderHoisting bool) {
0000000000000000000000000000000000000000;;		ctx.buildTime()             // no depends
0000000000000000000000000000000000000000;;		ctx.buildCredentialString() // no depends
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unsignedHeaders := ctx.Request.Header
0000000000000000000000000000000000000000;;		if ctx.isPresign {
0000000000000000000000000000000000000000;;			if !disableHeaderHoisting {
0000000000000000000000000000000000000000;;				urlValues := url.Values{}
0000000000000000000000000000000000000000;;				urlValues, unsignedHeaders = buildQuery(allowedQueryHoisting, unsignedHeaders) // no depends
0000000000000000000000000000000000000000;;				for k := range urlValues {
0000000000000000000000000000000000000000;;					ctx.Query[k] = urlValues[k]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.buildBodyDigest()
0000000000000000000000000000000000000000;;		ctx.buildCanonicalHeaders(ignoredHeaders, unsignedHeaders)
0000000000000000000000000000000000000000;;		ctx.buildCanonicalString() // depends on canon headers / signed headers
0000000000000000000000000000000000000000;;		ctx.buildStringToSign()    // depends on canon string
0000000000000000000000000000000000000000;;		ctx.buildSignature()       // depends on string to sign
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.isPresign {
0000000000000000000000000000000000000000;;			ctx.Request.URL.RawQuery += "&X-Amz-Signature=" + ctx.signature
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			parts := []string{
0000000000000000000000000000000000000000;;				authHeaderPrefix + " Credential=" + ctx.credValues.AccessKeyID + "/" + ctx.credentialString,
0000000000000000000000000000000000000000;;				"SignedHeaders=" + ctx.signedHeaders,
0000000000000000000000000000000000000000;;				"Signature=" + ctx.signature,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx.Request.Header.Set("Authorization", strings.Join(parts, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) buildTime() {
0000000000000000000000000000000000000000;;		ctx.formattedTime = ctx.Time.UTC().Format(timeFormat)
0000000000000000000000000000000000000000;;		ctx.formattedShortTime = ctx.Time.UTC().Format(shortTimeFormat)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.isPresign {
0000000000000000000000000000000000000000;;			duration := int64(ctx.ExpireTime / time.Second)
0000000000000000000000000000000000000000;;			ctx.Query.Set("X-Amz-Date", ctx.formattedTime)
0000000000000000000000000000000000000000;;			ctx.Query.Set("X-Amz-Expires", strconv.FormatInt(duration, 10))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ctx.Request.Header.Set("X-Amz-Date", ctx.formattedTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) buildCredentialString() {
0000000000000000000000000000000000000000;;		ctx.credentialString = strings.Join([]string{
0000000000000000000000000000000000000000;;			ctx.formattedShortTime,
0000000000000000000000000000000000000000;;			ctx.Region,
0000000000000000000000000000000000000000;;			ctx.ServiceName,
0000000000000000000000000000000000000000;;			"aws4_request",
0000000000000000000000000000000000000000;;		}, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.isPresign {
0000000000000000000000000000000000000000;;			ctx.Query.Set("X-Amz-Credential", ctx.credValues.AccessKeyID+"/"+ctx.credentialString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildQuery(r rule, header http.Header) (url.Values, http.Header) {
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		unsignedHeaders := http.Header{}
0000000000000000000000000000000000000000;;		for k, h := range header {
0000000000000000000000000000000000000000;;			if r.IsValid(k) {
0000000000000000000000000000000000000000;;				query[k] = h
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				unsignedHeaders[k] = h
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return query, unsignedHeaders
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) buildCanonicalHeaders(r rule, header http.Header) {
0000000000000000000000000000000000000000;;		var headers []string
0000000000000000000000000000000000000000;;		headers = append(headers, "host")
0000000000000000000000000000000000000000;;		for k, v := range header {
0000000000000000000000000000000000000000;;			canonicalKey := http.CanonicalHeaderKey(k)
0000000000000000000000000000000000000000;;			if !r.IsValid(canonicalKey) {
0000000000000000000000000000000000000000;;				continue // ignored header
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctx.SignedHeaderVals == nil {
0000000000000000000000000000000000000000;;				ctx.SignedHeaderVals = make(http.Header)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lowerCaseKey := strings.ToLower(k)
0000000000000000000000000000000000000000;;			if _, ok := ctx.SignedHeaderVals[lowerCaseKey]; ok {
0000000000000000000000000000000000000000;;				// include additional values
0000000000000000000000000000000000000000;;				ctx.SignedHeaderVals[lowerCaseKey] = append(ctx.SignedHeaderVals[lowerCaseKey], v...)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			headers = append(headers, lowerCaseKey)
0000000000000000000000000000000000000000;;			ctx.SignedHeaderVals[lowerCaseKey] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(headers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.signedHeaders = strings.Join(headers, ";")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.isPresign {
0000000000000000000000000000000000000000;;			ctx.Query.Set("X-Amz-SignedHeaders", ctx.signedHeaders)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerValues := make([]string, len(headers))
0000000000000000000000000000000000000000;;		for i, k := range headers {
0000000000000000000000000000000000000000;;			if k == "host" {
0000000000000000000000000000000000000000;;				headerValues[i] = "host:" + ctx.Request.URL.Host
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				headerValues[i] = k + ":" +
0000000000000000000000000000000000000000;;					strings.Join(ctx.SignedHeaderVals[k], ",")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.canonicalHeaders = strings.Join(stripExcessSpaces(headerValues), "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) buildCanonicalString() {
0000000000000000000000000000000000000000;;		ctx.Request.URL.RawQuery = strings.Replace(ctx.Query.Encode(), "+", "%20", -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := getURIPath(ctx.Request.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ctx.DisableURIPathEscaping {
0000000000000000000000000000000000000000;;			uri = rest.EscapePath(uri, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.canonicalString = strings.Join([]string{
0000000000000000000000000000000000000000;;			ctx.Request.Method,
0000000000000000000000000000000000000000;;			uri,
0000000000000000000000000000000000000000;;			ctx.Request.URL.RawQuery,
0000000000000000000000000000000000000000;;			ctx.canonicalHeaders + "\n",
0000000000000000000000000000000000000000;;			ctx.signedHeaders,
0000000000000000000000000000000000000000;;			ctx.bodyDigest,
0000000000000000000000000000000000000000;;		}, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) buildStringToSign() {
0000000000000000000000000000000000000000;;		ctx.stringToSign = strings.Join([]string{
0000000000000000000000000000000000000000;;			authHeaderPrefix,
0000000000000000000000000000000000000000;;			ctx.formattedTime,
0000000000000000000000000000000000000000;;			ctx.credentialString,
0000000000000000000000000000000000000000;;			hex.EncodeToString(makeSha256([]byte(ctx.canonicalString))),
0000000000000000000000000000000000000000;;		}, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) buildSignature() {
0000000000000000000000000000000000000000;;		secret := ctx.credValues.SecretAccessKey
0000000000000000000000000000000000000000;;		date := makeHmac([]byte("AWS4"+secret), []byte(ctx.formattedShortTime))
0000000000000000000000000000000000000000;;		region := makeHmac(date, []byte(ctx.Region))
0000000000000000000000000000000000000000;;		service := makeHmac(region, []byte(ctx.ServiceName))
0000000000000000000000000000000000000000;;		credentials := makeHmac(service, []byte("aws4_request"))
0000000000000000000000000000000000000000;;		signature := makeHmac(credentials, []byte(ctx.stringToSign))
0000000000000000000000000000000000000000;;		ctx.signature = hex.EncodeToString(signature)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) buildBodyDigest() {
0000000000000000000000000000000000000000;;		hash := ctx.Request.Header.Get("X-Amz-Content-Sha256")
0000000000000000000000000000000000000000;;		if hash == "" {
0000000000000000000000000000000000000000;;			if ctx.isPresign && ctx.ServiceName == "s3" {
0000000000000000000000000000000000000000;;				hash = "UNSIGNED-PAYLOAD"
0000000000000000000000000000000000000000;;			} else if ctx.Body == nil {
0000000000000000000000000000000000000000;;				hash = emptyStringSHA256
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hash = hex.EncodeToString(makeSha256Reader(ctx.Body))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ctx.ServiceName == "s3" || ctx.ServiceName == "glacier" {
0000000000000000000000000000000000000000;;				ctx.Request.Header.Set("X-Amz-Content-Sha256", hash)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx.bodyDigest = hash
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isRequestSigned returns if the request is currently signed or presigned
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) isRequestSigned() bool {
0000000000000000000000000000000000000000;;		if ctx.isPresign && ctx.Query.Get("X-Amz-Signature") != "" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ctx.Request.Header.Get("Authorization") != "" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unsign removes signing flags for both signed and presigned requests.
0000000000000000000000000000000000000000;;	func (ctx *signingCtx) removePresign() {
0000000000000000000000000000000000000000;;		ctx.Query.Del("X-Amz-Algorithm")
0000000000000000000000000000000000000000;;		ctx.Query.Del("X-Amz-Signature")
0000000000000000000000000000000000000000;;		ctx.Query.Del("X-Amz-Security-Token")
0000000000000000000000000000000000000000;;		ctx.Query.Del("X-Amz-Date")
0000000000000000000000000000000000000000;;		ctx.Query.Del("X-Amz-Expires")
0000000000000000000000000000000000000000;;		ctx.Query.Del("X-Amz-Credential")
0000000000000000000000000000000000000000;;		ctx.Query.Del("X-Amz-SignedHeaders")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeHmac(key []byte, data []byte) []byte {
0000000000000000000000000000000000000000;;		hash := hmac.New(sha256.New, key)
0000000000000000000000000000000000000000;;		hash.Write(data)
0000000000000000000000000000000000000000;;		return hash.Sum(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeSha256(data []byte) []byte {
0000000000000000000000000000000000000000;;		hash := sha256.New()
0000000000000000000000000000000000000000;;		hash.Write(data)
0000000000000000000000000000000000000000;;		return hash.Sum(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeSha256Reader(reader io.ReadSeeker) []byte {
0000000000000000000000000000000000000000;;		hash := sha256.New()
0000000000000000000000000000000000000000;;		start, _ := reader.Seek(0, 1)
0000000000000000000000000000000000000000;;		defer reader.Seek(start, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		io.Copy(hash, reader)
0000000000000000000000000000000000000000;;		return hash.Sum(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const doubleSpaces = "  "
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var doubleSpaceBytes = []byte(doubleSpaces)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stripExcessSpaces(headerVals []string) []string {
0000000000000000000000000000000000000000;;		vals := make([]string, len(headerVals))
0000000000000000000000000000000000000000;;		for i, str := range headerVals {
0000000000000000000000000000000000000000;;			// Trim leading and trailing spaces
0000000000000000000000000000000000000000;;			trimmed := strings.TrimSpace(str)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			idx := strings.Index(trimmed, doubleSpaces)
0000000000000000000000000000000000000000;;			var buf []byte
0000000000000000000000000000000000000000;;			for idx > -1 {
0000000000000000000000000000000000000000;;				// Multiple adjacent spaces found
0000000000000000000000000000000000000000;;				if buf == nil {
0000000000000000000000000000000000000000;;					// first time create the buffer
0000000000000000000000000000000000000000;;					buf = []byte(trimmed)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				stripToIdx := -1
0000000000000000000000000000000000000000;;				for j := idx + 1; j < len(buf); j++ {
0000000000000000000000000000000000000000;;					if buf[j] != ' ' {
0000000000000000000000000000000000000000;;						buf = append(buf[:idx+1], buf[j:]...)
0000000000000000000000000000000000000000;;						stripToIdx = j
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if stripToIdx >= 0 {
0000000000000000000000000000000000000000;;					idx = bytes.Index(buf[stripToIdx:], doubleSpaceBytes)
0000000000000000000000000000000000000000;;					if idx >= 0 {
0000000000000000000000000000000000000000;;						idx += stripToIdx
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					idx = -1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if buf != nil {
0000000000000000000000000000000000000000;;				vals[i] = string(buf)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vals[i] = trimmed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vals
0000000000000000000000000000000000000000;;	}
