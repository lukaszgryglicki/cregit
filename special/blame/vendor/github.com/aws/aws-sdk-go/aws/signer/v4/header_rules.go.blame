0000000000000000000000000000000000000000;;	package v4
7b662bd39f4f8ebe87658b72a7df9da9c5a74c80;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validator houses a set of rule needed for validation of a
0000000000000000000000000000000000000000;;	// string value
0000000000000000000000000000000000000000;;	type rules []rule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rule interface allows for more flexible rules and just simply
0000000000000000000000000000000000000000;;	// checks whether or not a value adheres to that rule
0000000000000000000000000000000000000000;;	type rule interface {
0000000000000000000000000000000000000000;;		IsValid(value string) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid will iterate through all rules and see if any rules
0000000000000000000000000000000000000000;;	// apply to the value and supports nested rules
0000000000000000000000000000000000000000;;	func (r rules) IsValid(value string) bool {
0000000000000000000000000000000000000000;;		for _, rule := range r {
0000000000000000000000000000000000000000;;			if rule.IsValid(value) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapRule generic rule for maps
0000000000000000000000000000000000000000;;	type mapRule map[string]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid for the map rule satisfies whether it exists in the map
0000000000000000000000000000000000000000;;	func (m mapRule) IsValid(value string) bool {
0000000000000000000000000000000000000000;;		_, ok := m[value]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// whitelist is a generic rule for whitelisting
0000000000000000000000000000000000000000;;	type whitelist struct {
0000000000000000000000000000000000000000;;		rule
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid for whitelist checks if the value is within the whitelist
0000000000000000000000000000000000000000;;	func (w whitelist) IsValid(value string) bool {
0000000000000000000000000000000000000000;;		return w.rule.IsValid(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// blacklist is a generic rule for blacklisting
0000000000000000000000000000000000000000;;	type blacklist struct {
0000000000000000000000000000000000000000;;		rule
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid for whitelist checks if the value is within the whitelist
0000000000000000000000000000000000000000;;	func (b blacklist) IsValid(value string) bool {
0000000000000000000000000000000000000000;;		return !b.rule.IsValid(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type patterns []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid for patterns checks each pattern and returns if a match has
0000000000000000000000000000000000000000;;	// been found
0000000000000000000000000000000000000000;;	func (p patterns) IsValid(value string) bool {
0000000000000000000000000000000000000000;;		for _, pattern := range p {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(http.CanonicalHeaderKey(value), pattern) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inclusiveRules rules allow for rules to depend on one another
0000000000000000000000000000000000000000;;	type inclusiveRules []rule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid will return true if all rules are true
0000000000000000000000000000000000000000;;	func (r inclusiveRules) IsValid(value string) bool {
0000000000000000000000000000000000000000;;		for _, rule := range r {
0000000000000000000000000000000000000000;;			if !rule.IsValid(value) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
