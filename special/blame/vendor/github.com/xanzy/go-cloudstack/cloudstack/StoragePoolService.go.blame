0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2016, Sander van Harmelen
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
0000000000000000000000000000000000000000;;	//
0a16da49b5158d8aef850f86fc8936f4afa6c64a;;	
0000000000000000000000000000000000000000;;	package cloudstack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ListStorageProvidersParams struct {
0000000000000000000000000000000000000000;;		p map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ListStorageProvidersParams) toURLValues() url.Values {
0000000000000000000000000000000000000000;;		u := url.Values{}
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			return u
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, found := p.p["keyword"]; found {
0000000000000000000000000000000000000000;;			u.Set("keyword", v.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, found := p.p["page"]; found {
0000000000000000000000000000000000000000;;			vv := strconv.Itoa(v.(int))
0000000000000000000000000000000000000000;;			u.Set("page", vv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, found := p.p["pagesize"]; found {
0000000000000000000000000000000000000000;;			vv := strconv.Itoa(v.(int))
0000000000000000000000000000000000000000;;			u.Set("pagesize", vv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, found := p.p["type"]; found {
0000000000000000000000000000000000000000;;			u.Set("type", v.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ListStorageProvidersParams) SetKeyword(v string) {
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.p["keyword"] = v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ListStorageProvidersParams) SetPage(v int) {
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.p["page"] = v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ListStorageProvidersParams) SetPagesize(v int) {
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.p["pagesize"] = v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ListStorageProvidersParams) SetType(v string) {
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.p["storagePoolType"] = v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// You should always use this function to get a new ListStorageProvidersParams instance,
0000000000000000000000000000000000000000;;	// as then you are sure you have configured all required params
0000000000000000000000000000000000000000;;	func (s *StoragePoolService) NewListStorageProvidersParams(storagePoolType string) *ListStorageProvidersParams {
0000000000000000000000000000000000000000;;		p := &ListStorageProvidersParams{}
0000000000000000000000000000000000000000;;		p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		p.p["storagePoolType"] = storagePoolType
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lists storage providers.
0000000000000000000000000000000000000000;;	func (s *StoragePoolService) ListStorageProviders(p *ListStorageProvidersParams) (*ListStorageProvidersResponse, error) {
0000000000000000000000000000000000000000;;		resp, err := s.cs.newRequest("listStorageProviders", p.toURLValues())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r ListStorageProvidersResponse
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(resp, &r); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ListStorageProvidersResponse struct {
0000000000000000000000000000000000000000;;		Count            int                `json:"count"`
0000000000000000000000000000000000000000;;		StorageProviders []*StorageProvider `json:"storageprovider"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StorageProvider struct {
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		Type string `json:"type,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EnableStorageMaintenanceParams struct {
0000000000000000000000000000000000000000;;		p map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *EnableStorageMaintenanceParams) toURLValues() url.Values {
0000000000000000000000000000000000000000;;		u := url.Values{}
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			return u
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, found := p.p["id"]; found {
0000000000000000000000000000000000000000;;			u.Set("id", v.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *EnableStorageMaintenanceParams) SetId(v string) {
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.p["id"] = v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// You should always use this function to get a new EnableStorageMaintenanceParams instance,
0000000000000000000000000000000000000000;;	// as then you are sure you have configured all required params
0000000000000000000000000000000000000000;;	func (s *StoragePoolService) NewEnableStorageMaintenanceParams(id string) *EnableStorageMaintenanceParams {
0000000000000000000000000000000000000000;;		p := &EnableStorageMaintenanceParams{}
0000000000000000000000000000000000000000;;		p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		p.p["id"] = id
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Puts storage pool into maintenance state
0000000000000000000000000000000000000000;;	func (s *StoragePoolService) EnableStorageMaintenance(p *EnableStorageMaintenanceParams) (*EnableStorageMaintenanceResponse, error) {
0000000000000000000000000000000000000000;;		resp, err := s.cs.newRequest("enableStorageMaintenance", p.toURLValues())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r EnableStorageMaintenanceResponse
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(resp, &r); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have a async client, we need to wait for the async result
0000000000000000000000000000000000000000;;		if s.cs.async {
0000000000000000000000000000000000000000;;			b, err := s.cs.GetAsyncJobResult(r.JobID, s.cs.timeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == AsyncTimeoutErr {
0000000000000000000000000000000000000000;;					return &r, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b, err = getRawValue(b)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(b, &r); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EnableStorageMaintenanceResponse struct {
0000000000000000000000000000000000000000;;		JobID                string            `json:"jobid,omitempty"`
0000000000000000000000000000000000000000;;		Capacityiops         int64             `json:"capacityiops,omitempty"`
0000000000000000000000000000000000000000;;		Clusterid            string            `json:"clusterid,omitempty"`
0000000000000000000000000000000000000000;;		Clustername          string            `json:"clustername,omitempty"`
0000000000000000000000000000000000000000;;		Created              string            `json:"created,omitempty"`
0000000000000000000000000000000000000000;;		Disksizeallocated    int64             `json:"disksizeallocated,omitempty"`
0000000000000000000000000000000000000000;;		Disksizetotal        int64             `json:"disksizetotal,omitempty"`
0000000000000000000000000000000000000000;;		Disksizeused         int64             `json:"disksizeused,omitempty"`
0000000000000000000000000000000000000000;;		Hypervisor           string            `json:"hypervisor,omitempty"`
0000000000000000000000000000000000000000;;		Id                   string            `json:"id,omitempty"`
0000000000000000000000000000000000000000;;		Ipaddress            string            `json:"ipaddress,omitempty"`
0000000000000000000000000000000000000000;;		Name                 string            `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		Overprovisionfactor  string            `json:"overprovisionfactor,omitempty"`
0000000000000000000000000000000000000000;;		Path                 string            `json:"path,omitempty"`
0000000000000000000000000000000000000000;;		Podid                string            `json:"podid,omitempty"`
0000000000000000000000000000000000000000;;		Podname              string            `json:"podname,omitempty"`
0000000000000000000000000000000000000000;;		Scope                string            `json:"scope,omitempty"`
0000000000000000000000000000000000000000;;		State                string            `json:"state,omitempty"`
0000000000000000000000000000000000000000;;		Storagecapabilities  map[string]string `json:"storagecapabilities,omitempty"`
0000000000000000000000000000000000000000;;		Suitableformigration bool              `json:"suitableformigration,omitempty"`
0000000000000000000000000000000000000000;;		Tags                 string            `json:"tags,omitempty"`
0000000000000000000000000000000000000000;;		Type                 string            `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		Zoneid               string            `json:"zoneid,omitempty"`
0000000000000000000000000000000000000000;;		Zonename             string            `json:"zonename,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CancelStorageMaintenanceParams struct {
0000000000000000000000000000000000000000;;		p map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *CancelStorageMaintenanceParams) toURLValues() url.Values {
0000000000000000000000000000000000000000;;		u := url.Values{}
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			return u
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, found := p.p["id"]; found {
0000000000000000000000000000000000000000;;			u.Set("id", v.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *CancelStorageMaintenanceParams) SetId(v string) {
0000000000000000000000000000000000000000;;		if p.p == nil {
0000000000000000000000000000000000000000;;			p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.p["id"] = v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// You should always use this function to get a new CancelStorageMaintenanceParams instance,
0000000000000000000000000000000000000000;;	// as then you are sure you have configured all required params
0000000000000000000000000000000000000000;;	func (s *StoragePoolService) NewCancelStorageMaintenanceParams(id string) *CancelStorageMaintenanceParams {
0000000000000000000000000000000000000000;;		p := &CancelStorageMaintenanceParams{}
0000000000000000000000000000000000000000;;		p.p = make(map[string]interface{})
0000000000000000000000000000000000000000;;		p.p["id"] = id
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cancels maintenance for primary storage
0000000000000000000000000000000000000000;;	func (s *StoragePoolService) CancelStorageMaintenance(p *CancelStorageMaintenanceParams) (*CancelStorageMaintenanceResponse, error) {
0000000000000000000000000000000000000000;;		resp, err := s.cs.newRequest("cancelStorageMaintenance", p.toURLValues())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r CancelStorageMaintenanceResponse
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(resp, &r); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have a async client, we need to wait for the async result
0000000000000000000000000000000000000000;;		if s.cs.async {
0000000000000000000000000000000000000000;;			b, err := s.cs.GetAsyncJobResult(r.JobID, s.cs.timeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == AsyncTimeoutErr {
0000000000000000000000000000000000000000;;					return &r, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b, err = getRawValue(b)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(b, &r); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CancelStorageMaintenanceResponse struct {
0000000000000000000000000000000000000000;;		JobID                string            `json:"jobid,omitempty"`
0000000000000000000000000000000000000000;;		Capacityiops         int64             `json:"capacityiops,omitempty"`
0000000000000000000000000000000000000000;;		Clusterid            string            `json:"clusterid,omitempty"`
0000000000000000000000000000000000000000;;		Clustername          string            `json:"clustername,omitempty"`
0000000000000000000000000000000000000000;;		Created              string            `json:"created,omitempty"`
0000000000000000000000000000000000000000;;		Disksizeallocated    int64             `json:"disksizeallocated,omitempty"`
0000000000000000000000000000000000000000;;		Disksizetotal        int64             `json:"disksizetotal,omitempty"`
0000000000000000000000000000000000000000;;		Disksizeused         int64             `json:"disksizeused,omitempty"`
0000000000000000000000000000000000000000;;		Hypervisor           string            `json:"hypervisor,omitempty"`
0000000000000000000000000000000000000000;;		Id                   string            `json:"id,omitempty"`
0000000000000000000000000000000000000000;;		Ipaddress            string            `json:"ipaddress,omitempty"`
0000000000000000000000000000000000000000;;		Name                 string            `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		Overprovisionfactor  string            `json:"overprovisionfactor,omitempty"`
0000000000000000000000000000000000000000;;		Path                 string            `json:"path,omitempty"`
0000000000000000000000000000000000000000;;		Podid                string            `json:"podid,omitempty"`
0000000000000000000000000000000000000000;;		Podname              string            `json:"podname,omitempty"`
0000000000000000000000000000000000000000;;		Scope                string            `json:"scope,omitempty"`
0000000000000000000000000000000000000000;;		State                string            `json:"state,omitempty"`
0000000000000000000000000000000000000000;;		Storagecapabilities  map[string]string `json:"storagecapabilities,omitempty"`
0000000000000000000000000000000000000000;;		Suitableformigration bool              `json:"suitableformigration,omitempty"`
0000000000000000000000000000000000000000;;		Tags                 string            `json:"tags,omitempty"`
0000000000000000000000000000000000000000;;		Type                 string            `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		Zoneid               string            `json:"zoneid,omitempty"`
0000000000000000000000000000000000000000;;		Zonename             string            `json:"zonename,omitempty"`
0000000000000000000000000000000000000000;;	}
