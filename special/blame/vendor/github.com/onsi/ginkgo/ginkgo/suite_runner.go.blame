0000000000000000000000000000000000000000;;	package main
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/suite_runner.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/suite_runner.go][vendor/github.com/onsi/ginkgo/ginkgo/suite_runner.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/interrupthandler"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/testrunner"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/testsuite"
0000000000000000000000000000000000000000;;		colorable "github.com/onsi/ginkgo/reporters/stenographer/support/go-colorable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type compilationInput struct {
0000000000000000000000000000000000000000;;		runner *testrunner.TestRunner
0000000000000000000000000000000000000000;;		result chan compilationOutput
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type compilationOutput struct {
0000000000000000000000000000000000000000;;		runner *testrunner.TestRunner
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SuiteRunner struct {
0000000000000000000000000000000000000000;;		notifier         *Notifier
0000000000000000000000000000000000000000;;		interruptHandler *interrupthandler.InterruptHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSuiteRunner(notifier *Notifier, interruptHandler *interrupthandler.InterruptHandler) *SuiteRunner {
0000000000000000000000000000000000000000;;		return &SuiteRunner{
0000000000000000000000000000000000000000;;			notifier:         notifier,
0000000000000000000000000000000000000000;;			interruptHandler: interruptHandler,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SuiteRunner) compileInParallel(runners []*testrunner.TestRunner, numCompilers int, willCompile func(suite testsuite.TestSuite)) chan compilationOutput {
0000000000000000000000000000000000000000;;		//we return this to the consumer, it will return each runner in order as it compiles
0000000000000000000000000000000000000000;;		compilationOutputs := make(chan compilationOutput, len(runners))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//an array of channels - the nth runner's compilation output is sent to the nth channel in this array
0000000000000000000000000000000000000000;;		//we read from these channels in order to ensure we run the suites in order
0000000000000000000000000000000000000000;;		orderedCompilationOutputs := []chan compilationOutput{}
0000000000000000000000000000000000000000;;		for _ = range runners {
0000000000000000000000000000000000000000;;			orderedCompilationOutputs = append(orderedCompilationOutputs, make(chan compilationOutput, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//we're going to spin up numCompilers compilers - they're going to run concurrently and will consume this channel
0000000000000000000000000000000000000000;;		//we prefill the channel then close it, this ensures we compile things in the correct order
0000000000000000000000000000000000000000;;		workPool := make(chan compilationInput, len(runners))
0000000000000000000000000000000000000000;;		for i, runner := range runners {
0000000000000000000000000000000000000000;;			workPool <- compilationInput{runner, orderedCompilationOutputs[i]}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(workPool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//pick a reasonable numCompilers
0000000000000000000000000000000000000000;;		if numCompilers == 0 {
0000000000000000000000000000000000000000;;			numCompilers = runtime.NumCPU()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//a WaitGroup to help us wait for all compilers to shut down
0000000000000000000000000000000000000000;;		wg := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(numCompilers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//spin up the concurrent compilers
0000000000000000000000000000000000000000;;		for i := 0; i < numCompilers; i++ {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				for input := range workPool {
0000000000000000000000000000000000000000;;					if r.interruptHandler.WasInterrupted() {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if willCompile != nil {
0000000000000000000000000000000000000000;;						willCompile(input.runner.Suite)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					//We retry because Go sometimes steps on itself when multiple compiles happen in parallel.  This is ugly, but should help resolve flakiness...
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					retries := 0
0000000000000000000000000000000000000000;;					for retries <= 5 {
0000000000000000000000000000000000000000;;						if r.interruptHandler.WasInterrupted() {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err = input.runner.Compile(); err == nil {
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						retries++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					input.result <- compilationOutput{input.runner, err}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//read from the compilation output channels *in order* and send them to the caller
0000000000000000000000000000000000000000;;		//close the compilationOutputs channel to tell the caller we're done
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(compilationOutputs)
0000000000000000000000000000000000000000;;			for _, orderedCompilationOutput := range orderedCompilationOutputs {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case compilationOutput := <-orderedCompilationOutput:
0000000000000000000000000000000000000000;;					compilationOutputs <- compilationOutput
0000000000000000000000000000000000000000;;				case <-r.interruptHandler.C:
0000000000000000000000000000000000000000;;					//interrupt detected, wait for the compilers to shut down then bail
0000000000000000000000000000000000000000;;					//this ensure we clean up after ourselves as we don't leave any compilation processes running
0000000000000000000000000000000000000000;;					wg.Wait()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return compilationOutputs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SuiteRunner) RunSuites(runners []*testrunner.TestRunner, numCompilers int, keepGoing bool, willCompile func(suite testsuite.TestSuite)) (testrunner.RunResult, int) {
0000000000000000000000000000000000000000;;		runResult := testrunner.PassingRunResult()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compilationOutputs := r.compileInParallel(runners, numCompilers, willCompile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numSuitesThatRan := 0
0000000000000000000000000000000000000000;;		suitesThatFailed := []testsuite.TestSuite{}
0000000000000000000000000000000000000000;;		for compilationOutput := range compilationOutputs {
0000000000000000000000000000000000000000;;			if compilationOutput.err != nil {
0000000000000000000000000000000000000000;;				fmt.Print(compilationOutput.err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			numSuitesThatRan++
0000000000000000000000000000000000000000;;			suiteRunResult := testrunner.FailingRunResult()
0000000000000000000000000000000000000000;;			if compilationOutput.err == nil {
0000000000000000000000000000000000000000;;				suiteRunResult = compilationOutput.runner.Run()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.notifier.SendSuiteCompletionNotification(compilationOutput.runner.Suite, suiteRunResult.Passed)
0000000000000000000000000000000000000000;;			r.notifier.RunCommand(compilationOutput.runner.Suite, suiteRunResult.Passed)
0000000000000000000000000000000000000000;;			runResult = runResult.Merge(suiteRunResult)
0000000000000000000000000000000000000000;;			if !suiteRunResult.Passed {
0000000000000000000000000000000000000000;;				suitesThatFailed = append(suitesThatFailed, compilationOutput.runner.Suite)
0000000000000000000000000000000000000000;;				if !keepGoing {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numSuitesThatRan < len(runners) && !config.DefaultReporterConfig.Succinct {
0000000000000000000000000000000000000000;;				fmt.Println("")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if keepGoing && !runResult.Passed {
0000000000000000000000000000000000000000;;			r.listFailedSuites(suitesThatFailed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return runResult, numSuitesThatRan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SuiteRunner) listFailedSuites(suitesThatFailed []testsuite.TestSuite) {
0000000000000000000000000000000000000000;;		fmt.Println("")
0000000000000000000000000000000000000000;;		fmt.Println("There were failures detected in the following suites:")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxPackageNameLength := 0
0000000000000000000000000000000000000000;;		for _, suite := range suitesThatFailed {
0000000000000000000000000000000000000000;;			if len(suite.PackageName) > maxPackageNameLength {
0000000000000000000000000000000000000000;;				maxPackageNameLength = len(suite.PackageName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packageNameFormatter := fmt.Sprintf("%%%ds", maxPackageNameLength)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, suite := range suitesThatFailed {
0000000000000000000000000000000000000000;;			if config.DefaultReporterConfig.NoColor {
0000000000000000000000000000000000000000;;				fmt.Printf("\t"+packageNameFormatter+" %s\n", suite.PackageName, suite.Path)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(colorable.NewColorableStdout(), "\t%s"+packageNameFormatter+"%s %s%s%s\n", redColor, suite.PackageName, defaultStyle, lightGrayColor, suite.Path, defaultStyle)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
