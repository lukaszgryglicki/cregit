0000000000000000000000000000000000000000;;	package interrupthandler
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/interrupthandler/interrupt_handler.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/interrupthandler/interrupt_handler.go][vendor/github.com/onsi/ginkgo/ginkgo/interrupthandler/interrupt_handler.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/signal"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InterruptHandler struct {
0000000000000000000000000000000000000000;;		interruptCount int
0000000000000000000000000000000000000000;;		lock           *sync.Mutex
0000000000000000000000000000000000000000;;		C              chan bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewInterruptHandler() *InterruptHandler {
0000000000000000000000000000000000000000;;		h := &InterruptHandler{
0000000000000000000000000000000000000000;;			lock: &sync.Mutex{},
0000000000000000000000000000000000000000;;			C:    make(chan bool, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go h.handleInterrupt()
0000000000000000000000000000000000000000;;		SwallowSigQuit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *InterruptHandler) WasInterrupted() bool {
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		defer h.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return h.interruptCount > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *InterruptHandler) handleInterrupt() {
0000000000000000000000000000000000000000;;		c := make(chan os.Signal, 1)
0000000000000000000000000000000000000000;;		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c
0000000000000000000000000000000000000000;;		signal.Stop(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.lock.Lock()
0000000000000000000000000000000000000000;;		h.interruptCount++
0000000000000000000000000000000000000000;;		if h.interruptCount == 1 {
0000000000000000000000000000000000000000;;			close(h.C)
0000000000000000000000000000000000000000;;		} else if h.interruptCount > 5 {
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go h.handleInterrupt()
0000000000000000000000000000000000000000;;	}
