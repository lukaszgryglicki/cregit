0000000000000000000000000000000000000000;;	package convert
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/convert/test_finder.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/convert/test_finder.go][vendor/github.com/onsi/ginkgo/ginkgo/convert/test_finder.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Given a root node, walks its top level statements and returns
0000000000000000000000000000000000000000;;	 * points to function nodes to rewrite as It statements.
0000000000000000000000000000000000000000;;	 * These functions, according to Go testing convention, must be named
0000000000000000000000000000000000000000;;	 * TestWithCamelCasedName and receive a single *testing.T argument.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func findTestFuncs(rootNode *ast.File) (testsToRewrite []*ast.FuncDecl) {
0000000000000000000000000000000000000000;;		testNameRegexp := regexp.MustCompile("^Test[0-9A-Z].+")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ast.Inspect(rootNode, func(node ast.Node) bool {
0000000000000000000000000000000000000000;;			if node == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch node := node.(type) {
0000000000000000000000000000000000000000;;			case *ast.FuncDecl:
0000000000000000000000000000000000000000;;				matches := testNameRegexp.MatchString(node.Name.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if matches && receivesTestingT(node) {
0000000000000000000000000000000000000000;;					testsToRewrite = append(testsToRewrite, node)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * convenience function that looks at args to a function and determines if its
0000000000000000000000000000000000000000;;	 * params include an argument of type  *testing.T
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func receivesTestingT(node *ast.FuncDecl) bool {
0000000000000000000000000000000000000000;;		if len(node.Type.Params.List) != 1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		base, ok := node.Type.Params.List[0].Type.(*ast.StarExpr)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		intermediate := base.X.(*ast.SelectorExpr)
0000000000000000000000000000000000000000;;		isTestingPackage := intermediate.X.(*ast.Ident).Name == "testing"
0000000000000000000000000000000000000000;;		isTestingT := intermediate.Sel.Name == "T"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return isTestingPackage && isTestingT
0000000000000000000000000000000000000000;;	}
