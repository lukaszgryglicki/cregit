0000000000000000000000000000000000000000;;	package convert
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/convert/ginkgo_ast_nodes.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/convert/ginkgo_ast_nodes.go][vendor/github.com/onsi/ginkgo/ginkgo/convert/ginkgo_ast_nodes.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Creates a func init() node
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func createVarUnderscoreBlock() *ast.ValueSpec {
0000000000000000000000000000000000000000;;		valueSpec := &ast.ValueSpec{}
0000000000000000000000000000000000000000;;		object := &ast.Object{Kind: 4, Name: "_", Decl: valueSpec, Data: 0}
0000000000000000000000000000000000000000;;		ident := &ast.Ident{Name: "_", Obj: object}
0000000000000000000000000000000000000000;;		valueSpec.Names = append(valueSpec.Names, ident)
0000000000000000000000000000000000000000;;		return valueSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Creates a Describe("Testing with ginkgo", func() { }) node
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func createDescribeBlock() *ast.CallExpr {
0000000000000000000000000000000000000000;;		blockStatement := &ast.BlockStmt{List: []ast.Stmt{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldList := &ast.FieldList{}
0000000000000000000000000000000000000000;;		funcType := &ast.FuncType{Params: fieldList}
0000000000000000000000000000000000000000;;		funcLit := &ast.FuncLit{Type: funcType, Body: blockStatement}
0000000000000000000000000000000000000000;;		basicLit := &ast.BasicLit{Kind: 9, Value: "\"Testing with Ginkgo\""}
0000000000000000000000000000000000000000;;		describeIdent := &ast.Ident{Name: "Describe"}
0000000000000000000000000000000000000000;;		return &ast.CallExpr{Fun: describeIdent, Args: []ast.Expr{basicLit, funcLit}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Convenience function to return the name of the *testing.T param
0000000000000000000000000000000000000000;;	 * for a Test function that will be rewritten. This is useful because
0000000000000000000000000000000000000000;;	 * we will want to replace the usage of this named *testing.T inside the
0000000000000000000000000000000000000000;;	 * body of the function with a GinktoT.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func namedTestingTArg(node *ast.FuncDecl) string {
0000000000000000000000000000000000000000;;		return node.Type.Params.List[0].Names[0].Name // *exhale*
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Convenience function to return the block statement node for a Describe statement
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func blockStatementFromDescribe(desc *ast.CallExpr) *ast.BlockStmt {
0000000000000000000000000000000000000000;;		var funcLit *ast.FuncLit
0000000000000000000000000000000000000000;;		var found = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, node := range desc.Args {
0000000000000000000000000000000000000000;;			switch node := node.(type) {
0000000000000000000000000000000000000000;;			case *ast.FuncLit:
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				funcLit = node
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			panic("Error finding ast.FuncLit inside describe statement. Somebody done goofed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return funcLit.Body
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/* convenience function for creating an It("TestNameHere")
0000000000000000000000000000000000000000;;	 * with all the body of the test function inside the anonymous
0000000000000000000000000000000000000000;;	 * func passed to It()
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func createItStatementForTestFunc(testFunc *ast.FuncDecl) *ast.ExprStmt {
0000000000000000000000000000000000000000;;		blockStatement := &ast.BlockStmt{List: testFunc.Body.List}
0000000000000000000000000000000000000000;;		fieldList := &ast.FieldList{}
0000000000000000000000000000000000000000;;		funcType := &ast.FuncType{Params: fieldList}
0000000000000000000000000000000000000000;;		funcLit := &ast.FuncLit{Type: funcType, Body: blockStatement}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testName := rewriteTestName(testFunc.Name.Name)
0000000000000000000000000000000000000000;;		basicLit := &ast.BasicLit{Kind: 9, Value: fmt.Sprintf("\"%s\"", testName)}
0000000000000000000000000000000000000000;;		itBlockIdent := &ast.Ident{Name: "It"}
0000000000000000000000000000000000000000;;		callExpr := &ast.CallExpr{Fun: itBlockIdent, Args: []ast.Expr{basicLit, funcLit}}
0000000000000000000000000000000000000000;;		return &ast.ExprStmt{X: callExpr}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	* rewrite test names to be human readable
0000000000000000000000000000000000000000;;	* eg: rewrites "TestSomethingAmazing" as "something amazing"
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func rewriteTestName(testName string) string {
0000000000000000000000000000000000000000;;		nameComponents := []string{}
0000000000000000000000000000000000000000;;		currentString := ""
0000000000000000000000000000000000000000;;		indexOfTest := strings.Index(testName, "Test")
0000000000000000000000000000000000000000;;		if indexOfTest != 0 {
0000000000000000000000000000000000000000;;			return testName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testName = strings.Replace(testName, "Test", "", 1)
0000000000000000000000000000000000000000;;		first, rest := testName[0], testName[1:]
0000000000000000000000000000000000000000;;		testName = string(unicode.ToLower(rune(first))) + rest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rune := range testName {
0000000000000000000000000000000000000000;;			if unicode.IsUpper(rune) {
0000000000000000000000000000000000000000;;				nameComponents = append(nameComponents, currentString)
0000000000000000000000000000000000000000;;				currentString = string(unicode.ToLower(rune))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				currentString += string(rune)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(append(nameComponents, currentString), " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newGinkgoTFromIdent(ident *ast.Ident) *ast.CallExpr {
0000000000000000000000000000000000000000;;		return &ast.CallExpr{
0000000000000000000000000000000000000000;;			Lparen: ident.NamePos + 1,
0000000000000000000000000000000000000000;;			Rparen: ident.NamePos + 2,
0000000000000000000000000000000000000000;;			Fun:    &ast.Ident{Name: "GinkgoT"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newGinkgoTInterface() *ast.Ident {
0000000000000000000000000000000000000000;;		return &ast.Ident{Name: "GinkgoTInterface"}
0000000000000000000000000000000000000000;;	}
