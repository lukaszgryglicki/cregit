0000000000000000000000000000000000000000;;	package convert
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/convert/package_rewriter.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/convert/package_rewriter.go][vendor/github.com/onsi/ginkgo/ginkgo/convert/package_rewriter.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/build"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * RewritePackage takes a name (eg: my-package/tools), finds its test files using
0000000000000000000000000000000000000000;;	 * Go's build package, and then rewrites them. A ginkgo test suite file will
0000000000000000000000000000000000000000;;	 * also be added for this package, and all of its child packages.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func RewritePackage(packageName string) {
0000000000000000000000000000000000000000;;		pkg, err := packageWithName(packageName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unexpected error reading package: '%s'\n%s\n", packageName, err.Error()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, filename := range findTestsInPackage(pkg) {
0000000000000000000000000000000000000000;;			rewriteTestsInFile(filename)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Given a package, findTestsInPackage reads the test files in the directory,
0000000000000000000000000000000000000000;;	 * and then recurses on each child package, returning a slice of all test files
0000000000000000000000000000000000000000;;	 * found in this process.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func findTestsInPackage(pkg *build.Package) (testfiles []string) {
0000000000000000000000000000000000000000;;		for _, file := range append(pkg.TestGoFiles, pkg.XTestGoFiles...) {
0000000000000000000000000000000000000000;;			testfiles = append(testfiles, filepath.Join(pkg.Dir, file))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirFiles, err := ioutil.ReadDir(pkg.Dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unexpected error reading dir: '%s'\n%s\n", pkg.Dir, err.Error()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(`^[._]`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, file := range dirFiles {
0000000000000000000000000000000000000000;;			if !file.IsDir() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if re.Match([]byte(file.Name())) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			packageName := filepath.Join(pkg.ImportPath, file.Name())
0000000000000000000000000000000000000000;;			subPackage, err := packageWithName(packageName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("unexpected error reading package: '%s'\n%s\n", packageName, err.Error()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			testfiles = append(testfiles, findTestsInPackage(subPackage)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addGinkgoSuiteForPackage(pkg)
0000000000000000000000000000000000000000;;		goFmtPackage(pkg)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Shells out to `ginkgo bootstrap` to create a test suite file
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func addGinkgoSuiteForPackage(pkg *build.Package) {
0000000000000000000000000000000000000000;;		originalDir, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		suite_test_file := filepath.Join(pkg.Dir, pkg.Name+"_suite_test.go")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = os.Stat(suite_test_file)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return // test file already exists, this should be a no-op
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = os.Chdir(pkg.Dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output, err := exec.Command("ginkgo", "bootstrap").Output()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("error running 'ginkgo bootstrap'.\nstdout: %s\n%s\n", output, err.Error()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = os.Chdir(originalDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Shells out to `go fmt` to format the package
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func goFmtPackage(pkg *build.Package) {
0000000000000000000000000000000000000000;;		output, err := exec.Command("go", "fmt", pkg.ImportPath).Output()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Warning: Error running 'go fmt %s'.\nstdout: %s\n%s\n", pkg.ImportPath, output, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Attempts to return a package with its test files already read.
0000000000000000000000000000000000000000;;	 * The ImportMode arg to build.Import lets you specify if you want go to read the
0000000000000000000000000000000000000000;;	 * buildable go files inside the package, but it fails if the package has no go files
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	func packageWithName(name string) (pkg *build.Package, err error) {
0000000000000000000000000000000000000000;;		pkg, err = build.Default.Import(name, ".", build.ImportMode(0))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pkg, err = build.Default.Import(name, ".", build.ImportMode(1))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
