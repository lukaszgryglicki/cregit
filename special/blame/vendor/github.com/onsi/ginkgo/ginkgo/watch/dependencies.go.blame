0000000000000000000000000000000000000000;;	package watch
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/watch/dependencies.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/watch/dependencies.go][vendor/github.com/onsi/ginkgo/ginkgo/watch/dependencies.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"go/build"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ginkgoAndGomegaFilter = regexp.MustCompile(`github\.com/onsi/ginkgo|github\.com/onsi/gomega`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Dependencies struct {
0000000000000000000000000000000000000000;;		deps map[string]int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDependencies(path string, maxDepth int) (Dependencies, error) {
0000000000000000000000000000000000000000;;		d := Dependencies{
0000000000000000000000000000000000000000;;			deps: map[string]int{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if maxDepth == 0 {
0000000000000000000000000000000000000000;;			return d, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := d.seedWithDepsForPackageAtPath(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return d, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for depth := 1; depth < maxDepth; depth++ {
0000000000000000000000000000000000000000;;			n := len(d.deps)
0000000000000000000000000000000000000000;;			d.addDepsForDepth(depth)
0000000000000000000000000000000000000000;;			if n == len(d.deps) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return d, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Dependencies) Dependencies() map[string]int {
0000000000000000000000000000000000000000;;		return d.deps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Dependencies) seedWithDepsForPackageAtPath(path string) error {
0000000000000000000000000000000000000000;;		pkg, err := build.ImportDir(path, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.resolveAndAdd(pkg.Imports, 1)
0000000000000000000000000000000000000000;;		d.resolveAndAdd(pkg.TestImports, 1)
0000000000000000000000000000000000000000;;		d.resolveAndAdd(pkg.XTestImports, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(d.deps, pkg.Dir)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Dependencies) addDepsForDepth(depth int) {
0000000000000000000000000000000000000000;;		for dep, depDepth := range d.deps {
0000000000000000000000000000000000000000;;			if depDepth == depth {
0000000000000000000000000000000000000000;;				d.addDepsForDep(dep, depth+1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Dependencies) addDepsForDep(dep string, depth int) {
0000000000000000000000000000000000000000;;		pkg, err := build.ImportDir(dep, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			println(err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.resolveAndAdd(pkg.Imports, depth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Dependencies) resolveAndAdd(deps []string, depth int) {
0000000000000000000000000000000000000000;;		for _, dep := range deps {
0000000000000000000000000000000000000000;;			pkg, err := build.Import(dep, ".", 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pkg.Goroot == false && !ginkgoAndGomegaFilter.Match([]byte(pkg.Dir)) {
0000000000000000000000000000000000000000;;				d.addDepIfNotPresent(pkg.Dir, depth)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Dependencies) addDepIfNotPresent(dep string, depth int) {
0000000000000000000000000000000000000000;;		_, ok := d.deps[dep]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			d.deps[dep] = depth
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
