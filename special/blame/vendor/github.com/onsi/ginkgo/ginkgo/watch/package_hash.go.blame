0000000000000000000000000000000000000000;;	package watch
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/watch/package_hash.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/watch/package_hash.go][vendor/github.com/onsi/ginkgo/ginkgo/watch/package_hash.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var goRegExp = regexp.MustCompile(`\.go$`)
0000000000000000000000000000000000000000;;	var goTestRegExp = regexp.MustCompile(`_test\.go$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PackageHash struct {
0000000000000000000000000000000000000000;;		CodeModifiedTime time.Time
0000000000000000000000000000000000000000;;		TestModifiedTime time.Time
0000000000000000000000000000000000000000;;		Deleted          bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path     string
0000000000000000000000000000000000000000;;		codeHash string
0000000000000000000000000000000000000000;;		testHash string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPackageHash(path string) *PackageHash {
0000000000000000000000000000000000000000;;		p := &PackageHash{
0000000000000000000000000000000000000000;;			path: path,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.codeHash, _, p.testHash, _, p.Deleted = p.computeHashes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PackageHash) CheckForChanges() bool {
0000000000000000000000000000000000000000;;		codeHash, codeModifiedTime, testHash, testModifiedTime, deleted := p.computeHashes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if deleted {
0000000000000000000000000000000000000000;;			if p.Deleted == false {
0000000000000000000000000000000000000000;;				t := time.Now()
0000000000000000000000000000000000000000;;				p.CodeModifiedTime = t
0000000000000000000000000000000000000000;;				p.TestModifiedTime = t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Deleted = true
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modified := false
0000000000000000000000000000000000000000;;		p.Deleted = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.codeHash != codeHash {
0000000000000000000000000000000000000000;;			p.CodeModifiedTime = codeModifiedTime
0000000000000000000000000000000000000000;;			modified = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.testHash != testHash {
0000000000000000000000000000000000000000;;			p.TestModifiedTime = testModifiedTime
0000000000000000000000000000000000000000;;			modified = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.codeHash = codeHash
0000000000000000000000000000000000000000;;		p.testHash = testHash
0000000000000000000000000000000000000000;;		return modified
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PackageHash) computeHashes() (codeHash string, codeModifiedTime time.Time, testHash string, testModifiedTime time.Time, deleted bool) {
0000000000000000000000000000000000000000;;		infos, err := ioutil.ReadDir(p.path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			deleted = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, info := range infos {
0000000000000000000000000000000000000000;;			if info.IsDir() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if goTestRegExp.Match([]byte(info.Name())) {
0000000000000000000000000000000000000000;;				testHash += p.hashForFileInfo(info)
0000000000000000000000000000000000000000;;				if info.ModTime().After(testModifiedTime) {
0000000000000000000000000000000000000000;;					testModifiedTime = info.ModTime()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if goRegExp.Match([]byte(info.Name())) {
0000000000000000000000000000000000000000;;				codeHash += p.hashForFileInfo(info)
0000000000000000000000000000000000000000;;				if info.ModTime().After(codeModifiedTime) {
0000000000000000000000000000000000000000;;					codeModifiedTime = info.ModTime()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testHash += codeHash
0000000000000000000000000000000000000000;;		if codeModifiedTime.After(testModifiedTime) {
0000000000000000000000000000000000000000;;			testModifiedTime = codeModifiedTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PackageHash) hashForFileInfo(info os.FileInfo) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s_%d_%d", info.Name(), info.Size(), info.ModTime().UnixNano())
0000000000000000000000000000000000000000;;	}
