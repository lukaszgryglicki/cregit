0000000000000000000000000000000000000000;;	package testsuite
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/testsuite/test_suite.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/testsuite/test_suite.go][vendor/github.com/onsi/ginkgo/ginkgo/testsuite/test_suite.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestSuite struct {
0000000000000000000000000000000000000000;;		Path        string
0000000000000000000000000000000000000000;;		PackageName string
0000000000000000000000000000000000000000;;		IsGinkgo    bool
0000000000000000000000000000000000000000;;		Precompiled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PrecompiledTestSuite(path string) (TestSuite, error) {
0000000000000000000000000000000000000000;;		info, err := os.Stat(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return TestSuite{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if info.IsDir() {
0000000000000000000000000000000000000000;;			return TestSuite{}, errors.New("this is a directory, not a file")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if filepath.Ext(path) != ".test" {
0000000000000000000000000000000000000000;;			return TestSuite{}, errors.New("this is not a .test binary")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if info.Mode()&0111 == 0 {
0000000000000000000000000000000000000000;;			return TestSuite{}, errors.New("this is not executable")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dir := relPath(filepath.Dir(path))
0000000000000000000000000000000000000000;;		packageName := strings.TrimSuffix(filepath.Base(path), filepath.Ext(path))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return TestSuite{
0000000000000000000000000000000000000000;;			Path:        dir,
0000000000000000000000000000000000000000;;			PackageName: packageName,
0000000000000000000000000000000000000000;;			IsGinkgo:    true,
0000000000000000000000000000000000000000;;			Precompiled: true,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SuitesInDir(dir string, recurse bool) []TestSuite {
0000000000000000000000000000000000000000;;		suites := []TestSuite{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vendorExperimentCheck(dir) {
0000000000000000000000000000000000000000;;			return suites
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files, _ := ioutil.ReadDir(dir)
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(`_test\.go$`)
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			if !file.IsDir() && re.Match([]byte(file.Name())) {
0000000000000000000000000000000000000000;;				suites = append(suites, New(dir, files))
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if recurse {
0000000000000000000000000000000000000000;;			re = regexp.MustCompile(`^[._]`)
0000000000000000000000000000000000000000;;			for _, file := range files {
0000000000000000000000000000000000000000;;				if file.IsDir() && !re.Match([]byte(file.Name())) {
0000000000000000000000000000000000000000;;					suites = append(suites, SuitesInDir(dir+"/"+file.Name(), recurse)...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return suites
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func relPath(dir string) string {
0000000000000000000000000000000000000000;;		dir, _ = filepath.Abs(dir)
0000000000000000000000000000000000000000;;		cwd, _ := os.Getwd()
0000000000000000000000000000000000000000;;		dir, _ = filepath.Rel(cwd, filepath.Clean(dir))
0000000000000000000000000000000000000000;;		dir = "." + string(filepath.Separator) + dir
0000000000000000000000000000000000000000;;		return dir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(dir string, files []os.FileInfo) TestSuite {
0000000000000000000000000000000000000000;;		return TestSuite{
0000000000000000000000000000000000000000;;			Path:        relPath(dir),
0000000000000000000000000000000000000000;;			PackageName: packageNameForSuite(dir),
0000000000000000000000000000000000000000;;			IsGinkgo:    filesHaveGinkgoSuite(dir, files),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packageNameForSuite(dir string) string {
0000000000000000000000000000000000000000;;		path, _ := filepath.Abs(dir)
0000000000000000000000000000000000000000;;		return filepath.Base(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filesHaveGinkgoSuite(dir string, files []os.FileInfo) bool {
0000000000000000000000000000000000000000;;		reTestFile := regexp.MustCompile(`_test\.go$`)
0000000000000000000000000000000000000000;;		reGinkgo := regexp.MustCompile(`package ginkgo|\/ginkgo"`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			if !file.IsDir() && reTestFile.Match([]byte(file.Name())) {
0000000000000000000000000000000000000000;;				contents, _ := ioutil.ReadFile(dir + "/" + file.Name())
0000000000000000000000000000000000000000;;				if reGinkgo.Match(contents) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
