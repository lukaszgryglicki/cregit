0000000000000000000000000000000000000000;;	package main
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/build_command.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/build_command.go][vendor/github.com/onsi/ginkgo/ginkgo/build_command.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/interrupthandler"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/testrunner"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BuildBuildCommand() *Command {
0000000000000000000000000000000000000000;;		commandFlags := NewBuildCommandFlags(flag.NewFlagSet("build", flag.ExitOnError))
0000000000000000000000000000000000000000;;		interruptHandler := interrupthandler.NewInterruptHandler()
0000000000000000000000000000000000000000;;		builder := &SpecBuilder{
0000000000000000000000000000000000000000;;			commandFlags:     commandFlags,
0000000000000000000000000000000000000000;;			interruptHandler: interruptHandler,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Command{
0000000000000000000000000000000000000000;;			Name:         "build",
0000000000000000000000000000000000000000;;			FlagSet:      commandFlags.FlagSet,
0000000000000000000000000000000000000000;;			UsageCommand: "ginkgo build <FLAGS> <PACKAGES>",
0000000000000000000000000000000000000000;;			Usage: []string{
0000000000000000000000000000000000000000;;				"Build the passed in <PACKAGES> (or the package in the current directory if left blank).",
0000000000000000000000000000000000000000;;				"Accepts the following flags:",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Command: builder.BuildSpecs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecBuilder struct {
0000000000000000000000000000000000000000;;		commandFlags     *RunWatchAndBuildCommandFlags
0000000000000000000000000000000000000000;;		interruptHandler *interrupthandler.InterruptHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SpecBuilder) BuildSpecs(args []string, additionalArgs []string) {
0000000000000000000000000000000000000000;;		r.commandFlags.computeNodes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		suites, _ := findSuites(args, r.commandFlags.Recurse, r.commandFlags.SkipPackage, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(suites) == 0 {
0000000000000000000000000000000000000000;;			complainAndQuit("Found no test suites")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		passed := true
0000000000000000000000000000000000000000;;		for _, suite := range suites {
0000000000000000000000000000000000000000;;			runner := testrunner.New(suite, 1, false, r.commandFlags.GoOpts, nil)
0000000000000000000000000000000000000000;;			fmt.Printf("Compiling %s...\n", suite.PackageName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			path, _ := filepath.Abs(filepath.Join(suite.Path, fmt.Sprintf("%s.test", suite.PackageName)))
0000000000000000000000000000000000000000;;			err := runner.CompileTo(path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Println(err.Error())
0000000000000000000000000000000000000000;;				passed = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Printf("    compiled %s.test\n", suite.PackageName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runner.CleanUp()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if passed {
0000000000000000000000000000000000000000;;			os.Exit(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.Exit(1)
0000000000000000000000000000000000000000;;	}
