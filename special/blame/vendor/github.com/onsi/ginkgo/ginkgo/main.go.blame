0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	The Ginkgo CLI
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/main.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/main.go][vendor/github.com/onsi/ginkgo/ginkgo/main.go];	
0000000000000000000000000000000000000000;;	The Ginkgo CLI is fully documented [here](http://onsi.github.io/ginkgo/#the_ginkgo_cli)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also learn more by running:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo help
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here are some of the more commonly used commands:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To install:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go install github.com/onsi/ginkgo/ginkgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To run tests:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To run tests in all subdirectories:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo -r
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To run tests in particular packages:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo <flags> /path/to/package /path/to/another/package
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To pass arguments/flags to your tests:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo <flags> <packages> -- <pass-throughs>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To run tests in parallel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo -p
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	this will automatically detect the optimal number of nodes to use.  Alternatively, you can specify the number of nodes with:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo -nodes=N
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	(note that you don't need to provide -p in this case).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	By default the Ginkgo CLI will spin up a server that the individual test processes send test output to.  The CLI aggregates this output and then presents coherent test output, one test at a time, as each test completes.
0000000000000000000000000000000000000000;;	An alternative is to have the parallel nodes run and stream interleaved output back.  This useful for debugging, particularly in contexts where tests hang/fail to start.  To get this interleaved output:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo -nodes=N -stream=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	On windows, the default value for stream is true.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	By default, when running multiple tests (with -r or a list of packages) Ginkgo will abort when a test fails.  To have Ginkgo run subsequent test suites instead you can:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo -keepGoing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To monitor packages and rerun tests when changes occur:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo watch <-r> </path/to/package>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	passing `ginkgo watch` the `-r` flag will recursively detect all test suites under the current directory and monitor them.
0000000000000000000000000000000000000000;;	`watch` does not detect *new* packages. Moreover, changes in package X only rerun the tests for package X, tests for packages
0000000000000000000000000000000000000000;;	that depend on X are not rerun.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[OSX & Linux only] To receive (desktop) notifications when a test run completes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo -notify
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	this is particularly useful with `ginkgo watch`.  Notifications are currently only supported on OS X and require that you `brew install terminal-notifier`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Sometimes (to suss out race conditions/flakey tests, for example) you want to keep running a test suite until it fails.  You can do this with:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo -untilItFails
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To bootstrap a test suite:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo bootstrap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To generate a test file:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo generate <test_file_name>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To bootstrap/generate test files without using "." imports:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo bootstrap --nodot
0000000000000000000000000000000000000000;;		ginkgo generate --nodot
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	this will explicitly export all the identifiers in Ginkgo and Gomega allowing you to rename them to avoid collisions.  When you pull to the latest Ginkgo/Gomega you'll want to run
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo nodot
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	to refresh this list and pull in any new identifiers.  In particular, this will pull in any new Gomega matchers that get added.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To convert an existing XUnit style test suite to a Ginkgo-style test suite:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo convert .
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To unfocus tests:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo unfocus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	or
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo blur
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To compile a test suite:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo build <path-to-package>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	will output an executable file named `package.test`.  This can be run directly or by invoking
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo <path-to-package.test>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To print out Ginkgo's version:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To get more help:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ginkgo help
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/testsuite"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const greenColor = "\x1b[32m"
0000000000000000000000000000000000000000;;	const redColor = "\x1b[91m"
0000000000000000000000000000000000000000;;	const defaultStyle = "\x1b[0m"
0000000000000000000000000000000000000000;;	const lightGrayColor = "\x1b[37m"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Command struct {
0000000000000000000000000000000000000000;;		Name                      string
0000000000000000000000000000000000000000;;		AltName                   string
0000000000000000000000000000000000000000;;		FlagSet                   *flag.FlagSet
0000000000000000000000000000000000000000;;		Usage                     []string
0000000000000000000000000000000000000000;;		UsageCommand              string
0000000000000000000000000000000000000000;;		Command                   func(args []string, additionalArgs []string)
0000000000000000000000000000000000000000;;		SuppressFlagDocumentation bool
0000000000000000000000000000000000000000;;		FlagDocSubstitute         []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) Matches(name string) bool {
0000000000000000000000000000000000000000;;		return c.Name == name || (c.AltName != "" && c.AltName == name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) Run(args []string, additionalArgs []string) {
0000000000000000000000000000000000000000;;		c.FlagSet.Parse(args)
0000000000000000000000000000000000000000;;		c.Command(c.FlagSet.Args(), additionalArgs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DefaultCommand *Command
0000000000000000000000000000000000000000;;	var Commands []*Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		DefaultCommand = BuildRunCommand()
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildWatchCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildBuildCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildBootstrapCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildGenerateCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildNodotCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildConvertCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildUnfocusCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildVersionCommand())
0000000000000000000000000000000000000000;;		Commands = append(Commands, BuildHelpCommand())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		args := []string{}
0000000000000000000000000000000000000000;;		additionalArgs := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foundDelimiter := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, arg := range os.Args[1:] {
0000000000000000000000000000000000000000;;			if !foundDelimiter {
0000000000000000000000000000000000000000;;				if arg == "--" {
0000000000000000000000000000000000000000;;					foundDelimiter = true
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if foundDelimiter {
0000000000000000000000000000000000000000;;				additionalArgs = append(additionalArgs, arg)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				args = append(args, arg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(args) > 0 {
0000000000000000000000000000000000000000;;			commandToRun, found := commandMatching(args[0])
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				commandToRun.Run(args[1:], additionalArgs)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DefaultCommand.Run(args, additionalArgs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func commandMatching(name string) (*Command, bool) {
0000000000000000000000000000000000000000;;		for _, command := range Commands {
0000000000000000000000000000000000000000;;			if command.Matches(name) {
0000000000000000000000000000000000000000;;				return command, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func usage() {
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "Ginkgo Version %s\n\n", config.VERSION)
0000000000000000000000000000000000000000;;		usageForCommand(DefaultCommand, false)
0000000000000000000000000000000000000000;;		for _, command := range Commands {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "\n")
0000000000000000000000000000000000000000;;			usageForCommand(command, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func usageForCommand(command *Command, longForm bool) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "%s\n%s\n", command.UsageCommand, strings.Repeat("-", len(command.UsageCommand)))
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "%s\n", strings.Join(command.Usage, "\n"))
0000000000000000000000000000000000000000;;		if command.SuppressFlagDocumentation && !longForm {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "%s\n", strings.Join(command.FlagDocSubstitute, "\n  "))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			command.FlagSet.PrintDefaults()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func complainAndQuit(complaint string) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "%s\nFor usage instructions:\n\tginkgo help\n", complaint)
0000000000000000000000000000000000000000;;		os.Exit(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findSuites(args []string, recurseForAll bool, skipPackage string, allowPrecompiled bool) ([]testsuite.TestSuite, []string) {
0000000000000000000000000000000000000000;;		suites := []testsuite.TestSuite{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(args) > 0 {
0000000000000000000000000000000000000000;;			for _, arg := range args {
0000000000000000000000000000000000000000;;				if allowPrecompiled {
0000000000000000000000000000000000000000;;					suite, err := testsuite.PrecompiledTestSuite(arg)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						suites = append(suites, suite)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				recurseForSuite := recurseForAll
0000000000000000000000000000000000000000;;				if strings.HasSuffix(arg, "/...") && arg != "/..." {
0000000000000000000000000000000000000000;;					arg = arg[:len(arg)-4]
0000000000000000000000000000000000000000;;					recurseForSuite = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				suites = append(suites, testsuite.SuitesInDir(arg, recurseForSuite)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			suites = testsuite.SuitesInDir(".", recurseForAll)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		skippedPackages := []string{}
0000000000000000000000000000000000000000;;		if skipPackage != "" {
0000000000000000000000000000000000000000;;			skipFilters := strings.Split(skipPackage, ",")
0000000000000000000000000000000000000000;;			filteredSuites := []testsuite.TestSuite{}
0000000000000000000000000000000000000000;;			for _, suite := range suites {
0000000000000000000000000000000000000000;;				skip := false
0000000000000000000000000000000000000000;;				for _, skipFilter := range skipFilters {
0000000000000000000000000000000000000000;;					if strings.Contains(suite.Path, skipFilter) {
0000000000000000000000000000000000000000;;						skip = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if skip {
0000000000000000000000000000000000000000;;					skippedPackages = append(skippedPackages, suite.Path)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					filteredSuites = append(filteredSuites, suite)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			suites = filteredSuites
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return suites, skippedPackages
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func goFmt(path string) {
0000000000000000000000000000000000000000;;		err := exec.Command("go", "fmt", path).Run()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			complainAndQuit("Could not fmt: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pluralizedWord(singular, plural string, count int) string {
0000000000000000000000000000000000000000;;		if count == 1 {
0000000000000000000000000000000000000000;;			return singular
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return plural
0000000000000000000000000000000000000000;;	}
