0000000000000000000000000000000000000000;;	package main
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/run_command.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/run_command.go][vendor/github.com/onsi/ginkgo/ginkgo/run_command.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/interrupthandler"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/testrunner"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BuildRunCommand() *Command {
0000000000000000000000000000000000000000;;		commandFlags := NewRunCommandFlags(flag.NewFlagSet("ginkgo", flag.ExitOnError))
0000000000000000000000000000000000000000;;		notifier := NewNotifier(commandFlags)
0000000000000000000000000000000000000000;;		interruptHandler := interrupthandler.NewInterruptHandler()
0000000000000000000000000000000000000000;;		runner := &SpecRunner{
0000000000000000000000000000000000000000;;			commandFlags:     commandFlags,
0000000000000000000000000000000000000000;;			notifier:         notifier,
0000000000000000000000000000000000000000;;			interruptHandler: interruptHandler,
0000000000000000000000000000000000000000;;			suiteRunner:      NewSuiteRunner(notifier, interruptHandler),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Command{
0000000000000000000000000000000000000000;;			Name:         "",
0000000000000000000000000000000000000000;;			FlagSet:      commandFlags.FlagSet,
0000000000000000000000000000000000000000;;			UsageCommand: "ginkgo <FLAGS> <PACKAGES> -- <PASS-THROUGHS>",
0000000000000000000000000000000000000000;;			Usage: []string{
0000000000000000000000000000000000000000;;				"Run the tests in the passed in <PACKAGES> (or the package in the current directory if left blank).",
0000000000000000000000000000000000000000;;				"Any arguments after -- will be passed to the test.",
0000000000000000000000000000000000000000;;				"Accepts the following flags:",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Command: runner.RunSpecs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecRunner struct {
0000000000000000000000000000000000000000;;		commandFlags     *RunWatchAndBuildCommandFlags
0000000000000000000000000000000000000000;;		notifier         *Notifier
0000000000000000000000000000000000000000;;		interruptHandler *interrupthandler.InterruptHandler
0000000000000000000000000000000000000000;;		suiteRunner      *SuiteRunner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SpecRunner) RunSpecs(args []string, additionalArgs []string) {
0000000000000000000000000000000000000000;;		r.commandFlags.computeNodes()
0000000000000000000000000000000000000000;;		r.notifier.VerifyNotificationsAreAvailable()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		suites, skippedPackages := findSuites(args, r.commandFlags.Recurse, r.commandFlags.SkipPackage, true)
0000000000000000000000000000000000000000;;		if len(skippedPackages) > 0 {
0000000000000000000000000000000000000000;;			fmt.Println("Will skip:")
0000000000000000000000000000000000000000;;			for _, skippedPackage := range skippedPackages {
0000000000000000000000000000000000000000;;				fmt.Println("  " + skippedPackage)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(skippedPackages) > 0 && len(suites) == 0 {
0000000000000000000000000000000000000000;;			fmt.Println("All tests skipped!  Exiting...")
0000000000000000000000000000000000000000;;			os.Exit(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(suites) == 0 {
0000000000000000000000000000000000000000;;			complainAndQuit("Found no test suites")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.ComputeSuccinctMode(len(suites))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runners := []*testrunner.TestRunner{}
0000000000000000000000000000000000000000;;		for _, suite := range suites {
0000000000000000000000000000000000000000;;			runners = append(runners, testrunner.New(suite, r.commandFlags.NumCPU, r.commandFlags.ParallelStream, r.commandFlags.GoOpts, additionalArgs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numSuites := 0
0000000000000000000000000000000000000000;;		runResult := testrunner.PassingRunResult()
0000000000000000000000000000000000000000;;		if r.commandFlags.UntilItFails {
0000000000000000000000000000000000000000;;			iteration := 0
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				r.UpdateSeed()
0000000000000000000000000000000000000000;;				randomizedRunners := r.randomizeOrder(runners)
0000000000000000000000000000000000000000;;				runResult, numSuites = r.suiteRunner.RunSuites(randomizedRunners, r.commandFlags.NumCompilers, r.commandFlags.KeepGoing, nil)
0000000000000000000000000000000000000000;;				iteration++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if r.interruptHandler.WasInterrupted() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if runResult.Passed {
0000000000000000000000000000000000000000;;					fmt.Printf("\nAll tests passed...\nWill keep running them until they fail.\nThis was attempt #%d\n%s\n", iteration, orcMessage(iteration))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Printf("\nTests failed on attempt #%d\n\n", iteration)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			randomizedRunners := r.randomizeOrder(runners)
0000000000000000000000000000000000000000;;			runResult, numSuites = r.suiteRunner.RunSuites(randomizedRunners, r.commandFlags.NumCompilers, r.commandFlags.KeepGoing, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, runner := range runners {
0000000000000000000000000000000000000000;;			runner.CleanUp()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Printf("\nGinkgo ran %d %s in %s\n", numSuites, pluralizedWord("suite", "suites", numSuites), time.Since(t))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if runResult.Passed {
0000000000000000000000000000000000000000;;			if runResult.HasProgrammaticFocus {
0000000000000000000000000000000000000000;;				fmt.Printf("Test Suite Passed\n")
0000000000000000000000000000000000000000;;				fmt.Printf("Detected Programmatic Focus - setting exit status to %d\n", types.GINKGO_FOCUS_EXIT_CODE)
0000000000000000000000000000000000000000;;				os.Exit(types.GINKGO_FOCUS_EXIT_CODE)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Printf("Test Suite Passed\n")
0000000000000000000000000000000000000000;;				os.Exit(0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Printf("Test Suite Failed\n")
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SpecRunner) ComputeSuccinctMode(numSuites int) {
0000000000000000000000000000000000000000;;		if config.DefaultReporterConfig.Verbose {
0000000000000000000000000000000000000000;;			config.DefaultReporterConfig.Succinct = false
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numSuites == 1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if numSuites > 1 && !r.commandFlags.wasSet("succinct") {
0000000000000000000000000000000000000000;;			config.DefaultReporterConfig.Succinct = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SpecRunner) UpdateSeed() {
0000000000000000000000000000000000000000;;		if !r.commandFlags.wasSet("seed") {
0000000000000000000000000000000000000000;;			config.GinkgoConfig.RandomSeed = time.Now().Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *SpecRunner) randomizeOrder(runners []*testrunner.TestRunner) []*testrunner.TestRunner {
0000000000000000000000000000000000000000;;		if !r.commandFlags.RandomizeSuites {
0000000000000000000000000000000000000000;;			return runners
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(runners) <= 1 {
0000000000000000000000000000000000000000;;			return runners
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		randomizedRunners := make([]*testrunner.TestRunner, len(runners))
0000000000000000000000000000000000000000;;		randomizer := rand.New(rand.NewSource(config.GinkgoConfig.RandomSeed))
0000000000000000000000000000000000000000;;		permutation := randomizer.Perm(len(runners))
0000000000000000000000000000000000000000;;		for i, j := range permutation {
0000000000000000000000000000000000000000;;			randomizedRunners[i] = runners[j]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return randomizedRunners
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func orcMessage(iteration int) string {
0000000000000000000000000000000000000000;;		if iteration < 10 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		} else if iteration < 30 {
0000000000000000000000000000000000000000;;			return []string{
0000000000000000000000000000000000000000;;				"If at first you succeed...",
0000000000000000000000000000000000000000;;				"...try, try again.",
0000000000000000000000000000000000000000;;				"Looking good!",
0000000000000000000000000000000000000000;;				"Still good...",
0000000000000000000000000000000000000000;;				"I think your tests are fine....",
0000000000000000000000000000000000000000;;				"Yep, still passing",
0000000000000000000000000000000000000000;;				"Here we go again...",
0000000000000000000000000000000000000000;;				"Even the gophers are getting bored",
0000000000000000000000000000000000000000;;				"Did you try -race?",
0000000000000000000000000000000000000000;;				"Maybe you should stop now?",
0000000000000000000000000000000000000000;;				"I'm getting tired...",
0000000000000000000000000000000000000000;;				"What if I just made you a sandwich?",
0000000000000000000000000000000000000000;;				"Hit ^C, hit ^C, please hit ^C",
0000000000000000000000000000000000000000;;				"Make it stop. Please!",
0000000000000000000000000000000000000000;;				"Come on!  Enough is enough!",
0000000000000000000000000000000000000000;;				"Dave, this conversation can serve no purpose anymore. Goodbye.",
0000000000000000000000000000000000000000;;				"Just what do you think you're doing, Dave? ",
0000000000000000000000000000000000000000;;				"I, Sisyphus",
0000000000000000000000000000000000000000;;				"Insanity: doing the same thing over and over again and expecting different results. -Einstein",
0000000000000000000000000000000000000000;;				"I guess Einstein never tried to churn butter",
0000000000000000000000000000000000000000;;			}[iteration-10] + "\n"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "No, seriously... you can probably stop now.\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
