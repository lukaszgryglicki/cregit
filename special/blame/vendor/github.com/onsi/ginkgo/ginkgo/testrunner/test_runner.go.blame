0000000000000000000000000000000000000000;;	package testrunner
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/testrunner/test_runner.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/testrunner/test_runner.go][vendor/github.com/onsi/ginkgo/ginkgo/testrunner/test_runner.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/ginkgo/testsuite"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/remote"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters/stenographer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestRunner struct {
0000000000000000000000000000000000000000;;		Suite testsuite.TestSuite
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		compiled              bool
0000000000000000000000000000000000000000;;		compilationTargetPath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numCPU         int
0000000000000000000000000000000000000000;;		parallelStream bool
0000000000000000000000000000000000000000;;		goOpts         map[string]interface{}
0000000000000000000000000000000000000000;;		additionalArgs []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(suite testsuite.TestSuite, numCPU int, parallelStream bool, goOpts map[string]interface{}, additionalArgs []string) *TestRunner {
0000000000000000000000000000000000000000;;		runner := &TestRunner{
0000000000000000000000000000000000000000;;			Suite:          suite,
0000000000000000000000000000000000000000;;			numCPU:         numCPU,
0000000000000000000000000000000000000000;;			parallelStream: parallelStream,
0000000000000000000000000000000000000000;;			goOpts:         goOpts,
0000000000000000000000000000000000000000;;			additionalArgs: additionalArgs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !suite.Precompiled {
0000000000000000000000000000000000000000;;			dir, err := ioutil.TempDir("", "ginkgo")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("couldn't create temporary directory... might be time to rm -rf:\n%s", err.Error()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			runner.compilationTargetPath = filepath.Join(dir, suite.PackageName+".test")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return runner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) Compile() error {
0000000000000000000000000000000000000000;;		return t.CompileTo(t.compilationTargetPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) BuildArgs(path string) []string {
0000000000000000000000000000000000000000;;		args := []string{"test", "-c", "-i", "-o", path, t.Suite.Path}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *t.goOpts["covermode"].(*string) != "" {
0000000000000000000000000000000000000000;;			args = append(args, "-cover", fmt.Sprintf("-covermode=%s", *t.goOpts["covermode"].(*string)))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if *t.goOpts["cover"].(*bool) || *t.goOpts["coverpkg"].(*string) != "" {
0000000000000000000000000000000000000000;;				args = append(args, "-cover", "-covermode=atomic")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boolOpts := []string{
0000000000000000000000000000000000000000;;			"a",
0000000000000000000000000000000000000000;;			"n",
0000000000000000000000000000000000000000;;			"msan",
0000000000000000000000000000000000000000;;			"race",
0000000000000000000000000000000000000000;;			"x",
0000000000000000000000000000000000000000;;			"work",
0000000000000000000000000000000000000000;;			"linkshared",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, opt := range boolOpts {
0000000000000000000000000000000000000000;;			if s, found := t.goOpts[opt].(*bool); found && *s {
0000000000000000000000000000000000000000;;				args = append(args, fmt.Sprintf("-%s", opt))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		intOpts := []string{
0000000000000000000000000000000000000000;;			"memprofilerate",
0000000000000000000000000000000000000000;;			"blockprofilerate",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, opt := range intOpts {
0000000000000000000000000000000000000000;;			if s, found := t.goOpts[opt].(*int); found {
0000000000000000000000000000000000000000;;				args = append(args, fmt.Sprintf("-%s=%d", opt, *s))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stringOpts := []string{
0000000000000000000000000000000000000000;;			"asmflags",
0000000000000000000000000000000000000000;;			"buildmode",
0000000000000000000000000000000000000000;;			"compiler",
0000000000000000000000000000000000000000;;			"gccgoflags",
0000000000000000000000000000000000000000;;			"installsuffix",
0000000000000000000000000000000000000000;;			"ldflags",
0000000000000000000000000000000000000000;;			"pkgdir",
0000000000000000000000000000000000000000;;			"toolexec",
0000000000000000000000000000000000000000;;			"coverprofile",
0000000000000000000000000000000000000000;;			"cpuprofile",
0000000000000000000000000000000000000000;;			"memprofile",
0000000000000000000000000000000000000000;;			"outputdir",
0000000000000000000000000000000000000000;;			"coverpkg",
0000000000000000000000000000000000000000;;			"tags",
0000000000000000000000000000000000000000;;			"gcflags",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, opt := range stringOpts {
0000000000000000000000000000000000000000;;			if s, found := t.goOpts[opt].(*string); found && *s != "" {
0000000000000000000000000000000000000000;;				args = append(args, fmt.Sprintf("-%s=%s", opt, *s))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) CompileTo(path string) error {
0000000000000000000000000000000000000000;;		if t.compiled {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Suite.Precompiled {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args := t.BuildArgs(path)
0000000000000000000000000000000000000000;;		cmd := exec.Command("go", args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output, err := cmd.CombinedOutput()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fixedOutput := fixCompilationOutput(string(output), t.Suite.Path)
0000000000000000000000000000000000000000;;			if len(output) > 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to compile %s:\n\n%s", t.Suite.PackageName, fixedOutput)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("Failed to compile %s", t.Suite.PackageName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fileExists(path) == false {
0000000000000000000000000000000000000000;;			compiledFile := t.Suite.PackageName + ".test"
0000000000000000000000000000000000000000;;			if fileExists(compiledFile) {
0000000000000000000000000000000000000000;;				// seems like we are on an old go version that does not support the -o flag on go test
0000000000000000000000000000000000000000;;				// move the compiled test file to the desired location by hand
0000000000000000000000000000000000000000;;				err = os.Rename(compiledFile, path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// We cannot move the file, perhaps because the source and destination
0000000000000000000000000000000000000000;;					// are on different partitions. We can copy the file, however.
0000000000000000000000000000000000000000;;					err = copyFile(compiledFile, path)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("Failed to copy compiled file: %s", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to compile %s: output file %q could not be found", t.Suite.PackageName, path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.compiled = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fileExists(path string) bool {
0000000000000000000000000000000000000000;;		_, err := os.Stat(path)
0000000000000000000000000000000000000000;;		return err == nil || os.IsNotExist(err) == false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyFile copies the contents of the file named src to the file named
0000000000000000000000000000000000000000;;	// by dst. The file will be created if it does not already exist. If the
0000000000000000000000000000000000000000;;	// destination file exists, all it's contents will be replaced by the contents
0000000000000000000000000000000000000000;;	// of the source file.
0000000000000000000000000000000000000000;;	func copyFile(src, dst string) error {
0000000000000000000000000000000000000000;;		srcInfo, err := os.Stat(src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mode := srcInfo.Mode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in, err := os.Open(src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer in.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := os.Create(dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			closeErr := out.Close()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = closeErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = io.Copy(out, in)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = out.Sync()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out.Chmod(mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	go test -c -i spits package.test out into the cwd. there's no way to change this.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	to make sure it doesn't generate conflicting .test files in the cwd, Compile() must switch the cwd to the test package.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	unfortunately, this causes go test's compile output to be expressed *relative to the test package* instead of the cwd.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	this makes it hard to reason about what failed, and also prevents iterm's Cmd+click from working.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	fixCompilationOutput..... rewrites the output to fix the paths.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	yeah......
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func fixCompilationOutput(output string, relToPath string) string {
0000000000000000000000000000000000000000;;		relToPath = filepath.Join(relToPath)
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(`^(\S.*\.go)\:\d+\:`)
0000000000000000000000000000000000000000;;		lines := strings.Split(output, "\n")
0000000000000000000000000000000000000000;;		for i, line := range lines {
0000000000000000000000000000000000000000;;			indices := re.FindStringSubmatchIndex(line)
0000000000000000000000000000000000000000;;			if len(indices) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			path := line[indices[2]:indices[3]]
0000000000000000000000000000000000000000;;			if filepath.Dir(path) != relToPath {
0000000000000000000000000000000000000000;;				path = filepath.Join(relToPath, path)
0000000000000000000000000000000000000000;;				lines[i] = path + line[indices[3]:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(lines, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) Run() RunResult {
0000000000000000000000000000000000000000;;		if t.Suite.IsGinkgo {
0000000000000000000000000000000000000000;;			if t.numCPU > 1 {
0000000000000000000000000000000000000000;;				if t.parallelStream {
0000000000000000000000000000000000000000;;					return t.runAndStreamParallelGinkgoSuite()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return t.runParallelGinkgoSuite()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return t.runSerialGinkgoSuite()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return t.runGoTestSuite()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) CleanUp() {
0000000000000000000000000000000000000000;;		if t.Suite.Precompiled {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.RemoveAll(filepath.Dir(t.compilationTargetPath))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) runSerialGinkgoSuite() RunResult {
0000000000000000000000000000000000000000;;		ginkgoArgs := config.BuildFlagArgs("ginkgo", config.GinkgoConfig, config.DefaultReporterConfig)
0000000000000000000000000000000000000000;;		return t.run(t.cmd(ginkgoArgs, os.Stdout, 1), nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) runGoTestSuite() RunResult {
0000000000000000000000000000000000000000;;		return t.run(t.cmd([]string{"-test.v"}, os.Stdout, 1), nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) runAndStreamParallelGinkgoSuite() RunResult {
0000000000000000000000000000000000000000;;		completions := make(chan RunResult)
0000000000000000000000000000000000000000;;		writers := make([]*logWriter, t.numCPU)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server, err := remote.NewServer(t.numCPU)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("Failed to start parallel spec server")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server.Start()
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for cpu := 0; cpu < t.numCPU; cpu++ {
0000000000000000000000000000000000000000;;			config.GinkgoConfig.ParallelNode = cpu + 1
0000000000000000000000000000000000000000;;			config.GinkgoConfig.ParallelTotal = t.numCPU
0000000000000000000000000000000000000000;;			config.GinkgoConfig.SyncHost = server.Address()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ginkgoArgs := config.BuildFlagArgs("ginkgo", config.GinkgoConfig, config.DefaultReporterConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writers[cpu] = newLogWriter(os.Stdout, cpu+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := t.cmd(ginkgoArgs, writers[cpu], cpu+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			server.RegisterAlive(cpu+1, func() bool {
0000000000000000000000000000000000000000;;				if cmd.ProcessState == nil {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return !cmd.ProcessState.Exited()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			go t.run(cmd, completions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := PassingRunResult()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for cpu := 0; cpu < t.numCPU; cpu++ {
0000000000000000000000000000000000000000;;			res = res.Merge(<-completions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, writer := range writers {
0000000000000000000000000000000000000000;;			writer.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		os.Stdout.Sync()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *t.goOpts["cover"].(*bool) || *t.goOpts["coverpkg"].(*string) != "" || *t.goOpts["covermode"].(*string) != "" {
0000000000000000000000000000000000000000;;			t.combineCoverprofiles()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) runParallelGinkgoSuite() RunResult {
0000000000000000000000000000000000000000;;		result := make(chan bool)
0000000000000000000000000000000000000000;;		completions := make(chan RunResult)
0000000000000000000000000000000000000000;;		writers := make([]*logWriter, t.numCPU)
0000000000000000000000000000000000000000;;		reports := make([]*bytes.Buffer, t.numCPU)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stenographer := stenographer.New(!config.DefaultReporterConfig.NoColor, config.GinkgoConfig.FlakeAttempts > 1)
0000000000000000000000000000000000000000;;		aggregator := remote.NewAggregator(t.numCPU, result, config.DefaultReporterConfig, stenographer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server, err := remote.NewServer(t.numCPU)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("Failed to start parallel spec server")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		server.RegisterReporters(aggregator)
0000000000000000000000000000000000000000;;		server.Start()
0000000000000000000000000000000000000000;;		defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for cpu := 0; cpu < t.numCPU; cpu++ {
0000000000000000000000000000000000000000;;			config.GinkgoConfig.ParallelNode = cpu + 1
0000000000000000000000000000000000000000;;			config.GinkgoConfig.ParallelTotal = t.numCPU
0000000000000000000000000000000000000000;;			config.GinkgoConfig.SyncHost = server.Address()
0000000000000000000000000000000000000000;;			config.GinkgoConfig.StreamHost = server.Address()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ginkgoArgs := config.BuildFlagArgs("ginkgo", config.GinkgoConfig, config.DefaultReporterConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reports[cpu] = &bytes.Buffer{}
0000000000000000000000000000000000000000;;			writers[cpu] = newLogWriter(reports[cpu], cpu+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cmd := t.cmd(ginkgoArgs, writers[cpu], cpu+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			server.RegisterAlive(cpu+1, func() bool {
0000000000000000000000000000000000000000;;				if cmd.ProcessState == nil {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return !cmd.ProcessState.Exited()
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			go t.run(cmd, completions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := PassingRunResult()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for cpu := 0; cpu < t.numCPU; cpu++ {
0000000000000000000000000000000000000000;;			res = res.Merge(<-completions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//all test processes are done, at this point
0000000000000000000000000000000000000000;;		//we should be able to wait for the aggregator to tell us that it's done
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-result:
0000000000000000000000000000000000000000;;			fmt.Println("")
0000000000000000000000000000000000000000;;		case <-time.After(time.Second):
0000000000000000000000000000000000000000;;			//the aggregator never got back to us!  something must have gone wrong
0000000000000000000000000000000000000000;;			fmt.Println(`
0000000000000000000000000000000000000000;;		 -------------------------------------------------------------------
0000000000000000000000000000000000000000;;		|                                                                   |
0000000000000000000000000000000000000000;;		|  Ginkgo timed out waiting for all parallel nodes to report back!  |
0000000000000000000000000000000000000000;;		|                                                                   |
0000000000000000000000000000000000000000;;		 -------------------------------------------------------------------
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			os.Stdout.Sync()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, writer := range writers {
0000000000000000000000000000000000000000;;				writer.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, report := range reports {
0000000000000000000000000000000000000000;;				fmt.Print(report.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			os.Stdout.Sync()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *t.goOpts["cover"].(*bool) || *t.goOpts["coverpkg"].(*string) != "" || *t.goOpts["covermode"].(*string) != "" {
0000000000000000000000000000000000000000;;			t.combineCoverprofiles()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) cmd(ginkgoArgs []string, stream io.Writer, node int) *exec.Cmd {
0000000000000000000000000000000000000000;;		args := []string{"--test.timeout=24h"}
0000000000000000000000000000000000000000;;		if *t.goOpts["cover"].(*bool) || *t.goOpts["coverpkg"].(*string) != "" || *t.goOpts["covermode"].(*string) != "" {
0000000000000000000000000000000000000000;;			coverprofile := "--test.coverprofile=" + t.Suite.PackageName + ".coverprofile"
0000000000000000000000000000000000000000;;			if t.numCPU > 1 {
0000000000000000000000000000000000000000;;				coverprofile = fmt.Sprintf("%s.%d", coverprofile, node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			args = append(args, coverprofile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args = append(args, ginkgoArgs...)
0000000000000000000000000000000000000000;;		args = append(args, t.additionalArgs...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := t.compilationTargetPath
0000000000000000000000000000000000000000;;		if t.Suite.Precompiled {
0000000000000000000000000000000000000000;;			path, _ = filepath.Abs(filepath.Join(t.Suite.Path, fmt.Sprintf("%s.test", t.Suite.PackageName)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := exec.Command(path, args...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Dir = t.Suite.Path
0000000000000000000000000000000000000000;;		cmd.Stderr = stream
0000000000000000000000000000000000000000;;		cmd.Stdout = stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) run(cmd *exec.Cmd, completions chan RunResult) RunResult {
0000000000000000000000000000000000000000;;		var res RunResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if completions != nil {
0000000000000000000000000000000000000000;;				completions <- res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := cmd.Start()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Printf("Failed to run test suite!\n\t%s", err.Error())
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd.Wait()
0000000000000000000000000000000000000000;;		exitStatus := cmd.ProcessState.Sys().(syscall.WaitStatus).ExitStatus()
0000000000000000000000000000000000000000;;		res.Passed = (exitStatus == 0) || (exitStatus == types.GINKGO_FOCUS_EXIT_CODE)
0000000000000000000000000000000000000000;;		res.HasProgrammaticFocus = (exitStatus == types.GINKGO_FOCUS_EXIT_CODE)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *TestRunner) combineCoverprofiles() {
0000000000000000000000000000000000000000;;		profiles := []string{}
0000000000000000000000000000000000000000;;		for cpu := 1; cpu <= t.numCPU; cpu++ {
0000000000000000000000000000000000000000;;			coverFile := fmt.Sprintf("%s.coverprofile.%d", t.Suite.PackageName, cpu)
0000000000000000000000000000000000000000;;			coverFile = filepath.Join(t.Suite.Path, coverFile)
0000000000000000000000000000000000000000;;			coverProfile, err := ioutil.ReadFile(coverFile)
0000000000000000000000000000000000000000;;			os.Remove(coverFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				profiles = append(profiles, string(coverProfile))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(profiles) != t.numCPU {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := map[string]int{}
0000000000000000000000000000000000000000;;		lineOrder := []string{}
0000000000000000000000000000000000000000;;		for i, coverProfile := range profiles {
0000000000000000000000000000000000000000;;			for _, line := range strings.Split(string(coverProfile), "\n")[1:] {
0000000000000000000000000000000000000000;;				if len(line) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				components := strings.Split(line, " ")
0000000000000000000000000000000000000000;;				count, _ := strconv.Atoi(components[len(components)-1])
0000000000000000000000000000000000000000;;				prefix := strings.Join(components[0:len(components)-1], " ")
0000000000000000000000000000000000000000;;				lines[prefix] += count
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					lineOrder = append(lineOrder, prefix)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := []string{"mode: atomic"}
0000000000000000000000000000000000000000;;		for _, line := range lineOrder {
0000000000000000000000000000000000000000;;			output = append(output, fmt.Sprintf("%s %d", line, lines[line]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		finalOutput := strings.Join(output, "\n")
0000000000000000000000000000000000000000;;		ioutil.WriteFile(filepath.Join(t.Suite.Path, fmt.Sprintf("%s.coverprofile", t.Suite.PackageName)), []byte(finalOutput), 0666)
0000000000000000000000000000000000000000;;	}
