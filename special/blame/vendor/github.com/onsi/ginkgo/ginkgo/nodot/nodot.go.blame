0000000000000000000000000000000000000000;;	package nodot
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/nodot/nodot.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo/nodot/nodot.go][vendor/github.com/onsi/ginkgo/ginkgo/nodot/nodot.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"go/build"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ApplyNoDot(data []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		sections, err := generateNodotSections()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, section := range sections {
0000000000000000000000000000000000000000;;			data = section.createOrUpdateIn(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodotSection struct {
0000000000000000000000000000000000000000;;		name         string
0000000000000000000000000000000000000000;;		pkg          string
0000000000000000000000000000000000000000;;		declarations []string
0000000000000000000000000000000000000000;;		types        []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s nodotSection) createOrUpdateIn(data []byte) []byte {
0000000000000000000000000000000000000000;;		renames := map[string]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contents := string(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := strings.Split(contents, "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		comment := "// Declarations for " + s.name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newLines := []string{}
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			if line == comment {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			words := strings.Split(line, " ")
0000000000000000000000000000000000000000;;			lastWord := words[len(words)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if s.containsDeclarationOrType(lastWord) {
0000000000000000000000000000000000000000;;				renames[lastWord] = words[1]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newLines = append(newLines, line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(newLines[len(newLines)-1]) > 0 {
0000000000000000000000000000000000000000;;			newLines = append(newLines, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newLines = append(newLines, comment)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, typ := range s.types {
0000000000000000000000000000000000000000;;			name, ok := renames[s.prefix(typ)]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				name = typ
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newLines = append(newLines, fmt.Sprintf("type %s %s", name, s.prefix(typ)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, decl := range s.declarations {
0000000000000000000000000000000000000000;;			name, ok := renames[s.prefix(decl)]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				name = decl
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newLines = append(newLines, fmt.Sprintf("var %s = %s", name, s.prefix(decl)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newLines = append(newLines, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newContents := strings.Join(newLines, "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []byte(newContents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s nodotSection) prefix(declOrType string) string {
0000000000000000000000000000000000000000;;		return s.pkg + "." + declOrType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s nodotSection) containsDeclarationOrType(word string) bool {
0000000000000000000000000000000000000000;;		for _, declaration := range s.declarations {
0000000000000000000000000000000000000000;;			if s.prefix(declaration) == word {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, typ := range s.types {
0000000000000000000000000000000000000000;;			if s.prefix(typ) == word {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func generateNodotSections() ([]nodotSection, error) {
0000000000000000000000000000000000000000;;		sections := []nodotSection{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		declarations, err := getExportedDeclerationsForPackage("github.com/onsi/ginkgo", "ginkgo_dsl.go", "GINKGO_VERSION", "GINKGO_PANIC")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sections = append(sections, nodotSection{
0000000000000000000000000000000000000000;;			name:         "Ginkgo DSL",
0000000000000000000000000000000000000000;;			pkg:          "ginkgo",
0000000000000000000000000000000000000000;;			declarations: declarations,
0000000000000000000000000000000000000000;;			types:        []string{"Done", "Benchmarker"},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		declarations, err = getExportedDeclerationsForPackage("github.com/onsi/gomega", "gomega_dsl.go", "GOMEGA_VERSION")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sections = append(sections, nodotSection{
0000000000000000000000000000000000000000;;			name:         "Gomega DSL",
0000000000000000000000000000000000000000;;			pkg:          "gomega",
0000000000000000000000000000000000000000;;			declarations: declarations,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		declarations, err = getExportedDeclerationsForPackage("github.com/onsi/gomega", "matchers.go")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sections = append(sections, nodotSection{
0000000000000000000000000000000000000000;;			name:         "Gomega Matchers",
0000000000000000000000000000000000000000;;			pkg:          "gomega",
0000000000000000000000000000000000000000;;			declarations: declarations,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sections, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getExportedDeclerationsForPackage(pkgPath string, filename string, blacklist ...string) ([]string, error) {
0000000000000000000000000000000000000000;;		pkg, err := build.Import(pkgPath, ".", 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []string{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		declarations, err := getExportedDeclarationsForFile(filepath.Join(pkg.Dir, filename))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []string{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		blacklistLookup := map[string]bool{}
0000000000000000000000000000000000000000;;		for _, declaration := range blacklist {
0000000000000000000000000000000000000000;;			blacklistLookup[declaration] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filteredDeclarations := []string{}
0000000000000000000000000000000000000000;;		for _, declaration := range declarations {
0000000000000000000000000000000000000000;;			if blacklistLookup[declaration] {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filteredDeclarations = append(filteredDeclarations, declaration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filteredDeclarations, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getExportedDeclarationsForFile(path string) ([]string, error) {
0000000000000000000000000000000000000000;;		fset := token.NewFileSet()
0000000000000000000000000000000000000000;;		tree, err := parser.ParseFile(fset, path, nil, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []string{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		declarations := []string{}
0000000000000000000000000000000000000000;;		ast.FileExports(tree)
0000000000000000000000000000000000000000;;		for _, decl := range tree.Decls {
0000000000000000000000000000000000000000;;			switch x := decl.(type) {
0000000000000000000000000000000000000000;;			case *ast.GenDecl:
0000000000000000000000000000000000000000;;				switch s := x.Specs[0].(type) {
0000000000000000000000000000000000000000;;				case *ast.ValueSpec:
0000000000000000000000000000000000000000;;					declarations = append(declarations, s.Names[0].Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *ast.FuncDecl:
0000000000000000000000000000000000000000;;				declarations = append(declarations, x.Name.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return declarations, nil
0000000000000000000000000000000000000000;;	}
