0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	The stenographer is used by Ginkgo's reporters to generate output.
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/reporters/stenographer/stenographer.go[Godeps/_workspace/src/github.com/onsi/ginkgo/reporters/stenographer/stenographer.go][vendor/github.com/onsi/ginkgo/reporters/stenographer/stenographer.go];	
0000000000000000000000000000000000000000;;	Move along, nothing to see here.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package stenographer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters/stenographer/support/go-colorable"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultStyle = "\x1b[0m"
0000000000000000000000000000000000000000;;	const boldStyle = "\x1b[1m"
0000000000000000000000000000000000000000;;	const redColor = "\x1b[91m"
0000000000000000000000000000000000000000;;	const greenColor = "\x1b[32m"
0000000000000000000000000000000000000000;;	const yellowColor = "\x1b[33m"
0000000000000000000000000000000000000000;;	const cyanColor = "\x1b[36m"
0000000000000000000000000000000000000000;;	const grayColor = "\x1b[90m"
0000000000000000000000000000000000000000;;	const lightGrayColor = "\x1b[37m"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cursorStateType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cursorStateTop cursorStateType = iota
0000000000000000000000000000000000000000;;		cursorStateStreaming
0000000000000000000000000000000000000000;;		cursorStateMidBlock
0000000000000000000000000000000000000000;;		cursorStateEndBlock
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Stenographer interface {
0000000000000000000000000000000000000000;;		AnnounceSuite(description string, randomSeed int64, randomizingAll bool, succinct bool)
0000000000000000000000000000000000000000;;		AnnounceAggregatedParallelRun(nodes int, succinct bool)
0000000000000000000000000000000000000000;;		AnnounceParallelRun(node int, nodes int, succinct bool)
0000000000000000000000000000000000000000;;		AnnounceTotalNumberOfSpecs(total int, succinct bool)
0000000000000000000000000000000000000000;;		AnnounceNumberOfSpecs(specsToRun int, total int, succinct bool)
0000000000000000000000000000000000000000;;		AnnounceSpecRunCompletion(summary *types.SuiteSummary, succinct bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AnnounceSpecWillRun(spec *types.SpecSummary)
0000000000000000000000000000000000000000;;		AnnounceBeforeSuiteFailure(summary *types.SetupSummary, succinct bool, fullTrace bool)
0000000000000000000000000000000000000000;;		AnnounceAfterSuiteFailure(summary *types.SetupSummary, succinct bool, fullTrace bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AnnounceCapturedOutput(output string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AnnounceSuccesfulSpec(spec *types.SpecSummary)
0000000000000000000000000000000000000000;;		AnnounceSuccesfulSlowSpec(spec *types.SpecSummary, succinct bool)
0000000000000000000000000000000000000000;;		AnnounceSuccesfulMeasurement(spec *types.SpecSummary, succinct bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AnnouncePendingSpec(spec *types.SpecSummary, noisy bool)
0000000000000000000000000000000000000000;;		AnnounceSkippedSpec(spec *types.SpecSummary, succinct bool, fullTrace bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AnnounceSpecTimedOut(spec *types.SpecSummary, succinct bool, fullTrace bool)
0000000000000000000000000000000000000000;;		AnnounceSpecPanicked(spec *types.SpecSummary, succinct bool, fullTrace bool)
0000000000000000000000000000000000000000;;		AnnounceSpecFailed(spec *types.SpecSummary, succinct bool, fullTrace bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SummarizeFailures(summaries []*types.SpecSummary)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(color bool, enableFlakes bool) Stenographer {
0000000000000000000000000000000000000000;;		denoter := "•"
0000000000000000000000000000000000000000;;		if runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			denoter = "+"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &consoleStenographer{
0000000000000000000000000000000000000000;;			color:        color,
0000000000000000000000000000000000000000;;			denoter:      denoter,
0000000000000000000000000000000000000000;;			cursorState:  cursorStateTop,
0000000000000000000000000000000000000000;;			enableFlakes: enableFlakes,
0000000000000000000000000000000000000000;;			w:            colorable.NewColorableStdout(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type consoleStenographer struct {
0000000000000000000000000000000000000000;;		color        bool
0000000000000000000000000000000000000000;;		denoter      string
0000000000000000000000000000000000000000;;		cursorState  cursorStateType
0000000000000000000000000000000000000000;;		enableFlakes bool
0000000000000000000000000000000000000000;;		w            io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var alternatingColors = []string{defaultStyle, grayColor}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSuite(description string, randomSeed int64, randomizingAll bool, succinct bool) {
0000000000000000000000000000000000000000;;		if succinct {
0000000000000000000000000000000000000000;;			s.print(0, "[%d] %s ", randomSeed, s.colorize(boldStyle, description))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.printBanner(fmt.Sprintf("Running Suite: %s", description), "=")
0000000000000000000000000000000000000000;;		s.print(0, "Random Seed: %s", s.colorize(boldStyle, "%d", randomSeed))
0000000000000000000000000000000000000000;;		if randomizingAll {
0000000000000000000000000000000000000000;;			s.print(0, " - Will randomize all specs")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceParallelRun(node int, nodes int, succinct bool) {
0000000000000000000000000000000000000000;;		if succinct {
0000000000000000000000000000000000000000;;			s.print(0, "- node #%d ", node)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.println(0,
0000000000000000000000000000000000000000;;			"Parallel test node %s/%s.",
0000000000000000000000000000000000000000;;			s.colorize(boldStyle, "%d", node),
0000000000000000000000000000000000000000;;			s.colorize(boldStyle, "%d", nodes),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceAggregatedParallelRun(nodes int, succinct bool) {
0000000000000000000000000000000000000000;;		if succinct {
0000000000000000000000000000000000000000;;			s.print(0, "- %d nodes ", nodes)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.println(0,
0000000000000000000000000000000000000000;;			"Running in parallel across %s nodes",
0000000000000000000000000000000000000000;;			s.colorize(boldStyle, "%d", nodes),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceNumberOfSpecs(specsToRun int, total int, succinct bool) {
0000000000000000000000000000000000000000;;		if succinct {
0000000000000000000000000000000000000000;;			s.print(0, "- %d/%d specs ", specsToRun, total)
0000000000000000000000000000000000000000;;			s.stream()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.println(0,
0000000000000000000000000000000000000000;;			"Will run %s of %s specs",
0000000000000000000000000000000000000000;;			s.colorize(boldStyle, "%d", specsToRun),
0000000000000000000000000000000000000000;;			s.colorize(boldStyle, "%d", total),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceTotalNumberOfSpecs(total int, succinct bool) {
0000000000000000000000000000000000000000;;		if succinct {
0000000000000000000000000000000000000000;;			s.print(0, "- %d specs ", total)
0000000000000000000000000000000000000000;;			s.stream()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.println(0,
0000000000000000000000000000000000000000;;			"Will run %s specs",
0000000000000000000000000000000000000000;;			s.colorize(boldStyle, "%d", total),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSpecRunCompletion(summary *types.SuiteSummary, succinct bool) {
0000000000000000000000000000000000000000;;		if succinct && summary.SuiteSucceeded {
0000000000000000000000000000000000000000;;			s.print(0, " %s %s ", s.colorize(greenColor, "SUCCESS!"), summary.RunTime)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		color := greenColor
0000000000000000000000000000000000000000;;		if !summary.SuiteSucceeded {
0000000000000000000000000000000000000000;;			color = redColor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.println(0, s.colorize(boldStyle+color, "Ran %d of %d Specs in %.3f seconds", summary.NumberOfSpecsThatWillBeRun, summary.NumberOfTotalSpecs, summary.RunTime.Seconds()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := ""
0000000000000000000000000000000000000000;;		if summary.SuiteSucceeded {
0000000000000000000000000000000000000000;;			status = s.colorize(boldStyle+greenColor, "SUCCESS!")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			status = s.colorize(boldStyle+redColor, "FAIL!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flakes := ""
0000000000000000000000000000000000000000;;		if s.enableFlakes {
0000000000000000000000000000000000000000;;			flakes = " | " + s.colorize(yellowColor+boldStyle, "%d Flaked", summary.NumberOfFlakedSpecs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.print(0,
0000000000000000000000000000000000000000;;			"%s -- %s | %s | %s | %s ",
0000000000000000000000000000000000000000;;			status,
0000000000000000000000000000000000000000;;			s.colorize(greenColor+boldStyle, "%d Passed", summary.NumberOfPassedSpecs),
0000000000000000000000000000000000000000;;			s.colorize(redColor+boldStyle, "%d Failed", summary.NumberOfFailedSpecs)+flakes,
0000000000000000000000000000000000000000;;			s.colorize(yellowColor+boldStyle, "%d Pending", summary.NumberOfPendingSpecs),
0000000000000000000000000000000000000000;;			s.colorize(cyanColor+boldStyle, "%d Skipped", summary.NumberOfSkippedSpecs),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSpecWillRun(spec *types.SpecSummary) {
0000000000000000000000000000000000000000;;		s.startBlock()
0000000000000000000000000000000000000000;;		for i, text := range spec.ComponentTexts[1 : len(spec.ComponentTexts)-1] {
0000000000000000000000000000000000000000;;			s.print(0, s.colorize(alternatingColors[i%2], text)+" ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indentation := 0
0000000000000000000000000000000000000000;;		if len(spec.ComponentTexts) > 2 {
0000000000000000000000000000000000000000;;			indentation = 1
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index := len(spec.ComponentTexts) - 1
0000000000000000000000000000000000000000;;		s.print(indentation, s.colorize(boldStyle, spec.ComponentTexts[index]))
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		s.print(indentation, s.colorize(lightGrayColor, spec.ComponentCodeLocations[index].String()))
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		s.midBlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceBeforeSuiteFailure(summary *types.SetupSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		s.announceSetupFailure("BeforeSuite", summary, succinct, fullTrace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceAfterSuiteFailure(summary *types.SetupSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		s.announceSetupFailure("AfterSuite", summary, succinct, fullTrace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) announceSetupFailure(name string, summary *types.SetupSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		s.startBlock()
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		switch summary.State {
0000000000000000000000000000000000000000;;		case types.SpecStateFailed:
0000000000000000000000000000000000000000;;			message = "Failure"
0000000000000000000000000000000000000000;;		case types.SpecStatePanicked:
0000000000000000000000000000000000000000;;			message = "Panic"
0000000000000000000000000000000000000000;;		case types.SpecStateTimedOut:
0000000000000000000000000000000000000000;;			message = "Timeout"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.println(0, s.colorize(redColor+boldStyle, "%s [%.3f seconds]", message, summary.RunTime.Seconds()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indentation := s.printCodeLocationBlock([]string{name}, []types.CodeLocation{summary.CodeLocation}, summary.ComponentType, 0, summary.State, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		s.printFailure(indentation, summary.State, summary.Failure, fullTrace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.endBlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceCapturedOutput(output string) {
0000000000000000000000000000000000000000;;		if output == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.startBlock()
0000000000000000000000000000000000000000;;		s.println(0, output)
0000000000000000000000000000000000000000;;		s.midBlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSuccesfulSpec(spec *types.SpecSummary) {
0000000000000000000000000000000000000000;;		s.print(0, s.colorize(greenColor, s.denoter))
0000000000000000000000000000000000000000;;		s.stream()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSuccesfulSlowSpec(spec *types.SpecSummary, succinct bool) {
0000000000000000000000000000000000000000;;		s.printBlockWithMessage(
0000000000000000000000000000000000000000;;			s.colorize(greenColor, "%s [SLOW TEST:%.3f seconds]", s.denoter, spec.RunTime.Seconds()),
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			spec,
0000000000000000000000000000000000000000;;			succinct,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSuccesfulMeasurement(spec *types.SpecSummary, succinct bool) {
0000000000000000000000000000000000000000;;		s.printBlockWithMessage(
0000000000000000000000000000000000000000;;			s.colorize(greenColor, "%s [MEASUREMENT]", s.denoter),
0000000000000000000000000000000000000000;;			s.measurementReport(spec, succinct),
0000000000000000000000000000000000000000;;			spec,
0000000000000000000000000000000000000000;;			succinct,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnouncePendingSpec(spec *types.SpecSummary, noisy bool) {
0000000000000000000000000000000000000000;;		if noisy {
0000000000000000000000000000000000000000;;			s.printBlockWithMessage(
0000000000000000000000000000000000000000;;				s.colorize(yellowColor, "P [PENDING]"),
0000000000000000000000000000000000000000;;				"",
0000000000000000000000000000000000000000;;				spec,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.print(0, s.colorize(yellowColor, "P"))
0000000000000000000000000000000000000000;;			s.stream()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSkippedSpec(spec *types.SpecSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		// Skips at runtime will have a non-empty spec.Failure. All others should be succinct.
0000000000000000000000000000000000000000;;		if succinct || spec.Failure == (types.SpecFailure{}) {
0000000000000000000000000000000000000000;;			s.print(0, s.colorize(cyanColor, "S"))
0000000000000000000000000000000000000000;;			s.stream()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.startBlock()
0000000000000000000000000000000000000000;;			s.println(0, s.colorize(cyanColor+boldStyle, "S [SKIPPING]%s [%.3f seconds]", s.failureContext(spec.Failure.ComponentType), spec.RunTime.Seconds()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			indentation := s.printCodeLocationBlock(spec.ComponentTexts, spec.ComponentCodeLocations, spec.Failure.ComponentType, spec.Failure.ComponentIndex, spec.State, succinct)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;			s.printSkip(indentation, spec.Failure)
0000000000000000000000000000000000000000;;			s.endBlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSpecTimedOut(spec *types.SpecSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		s.printSpecFailure(fmt.Sprintf("%s... Timeout", s.denoter), spec, succinct, fullTrace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSpecPanicked(spec *types.SpecSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		s.printSpecFailure(fmt.Sprintf("%s! Panic", s.denoter), spec, succinct, fullTrace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) AnnounceSpecFailed(spec *types.SpecSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		s.printSpecFailure(fmt.Sprintf("%s Failure", s.denoter), spec, succinct, fullTrace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) SummarizeFailures(summaries []*types.SpecSummary) {
0000000000000000000000000000000000000000;;		failingSpecs := []*types.SpecSummary{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, summary := range summaries {
0000000000000000000000000000000000000000;;			if summary.HasFailureState() {
0000000000000000000000000000000000000000;;				failingSpecs = append(failingSpecs, summary)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(failingSpecs) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		plural := "s"
0000000000000000000000000000000000000000;;		if len(failingSpecs) == 1 {
0000000000000000000000000000000000000000;;			plural = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.println(0, s.colorize(redColor+boldStyle, "Summarizing %d Failure%s:", len(failingSpecs), plural))
0000000000000000000000000000000000000000;;		for _, summary := range failingSpecs {
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;			if summary.HasFailureState() {
0000000000000000000000000000000000000000;;				if summary.TimedOut() {
0000000000000000000000000000000000000000;;					s.print(0, s.colorize(redColor+boldStyle, "[Timeout...] "))
0000000000000000000000000000000000000000;;				} else if summary.Panicked() {
0000000000000000000000000000000000000000;;					s.print(0, s.colorize(redColor+boldStyle, "[Panic!] "))
0000000000000000000000000000000000000000;;				} else if summary.Failed() {
0000000000000000000000000000000000000000;;					s.print(0, s.colorize(redColor+boldStyle, "[Fail] "))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.printSpecContext(summary.ComponentTexts, summary.ComponentCodeLocations, summary.Failure.ComponentType, summary.Failure.ComponentIndex, summary.State, true)
0000000000000000000000000000000000000000;;				s.printNewLine()
0000000000000000000000000000000000000000;;				s.println(0, s.colorize(lightGrayColor, summary.Failure.Location.String()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) startBlock() {
0000000000000000000000000000000000000000;;		if s.cursorState == cursorStateStreaming {
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;			s.printDelimiter()
0000000000000000000000000000000000000000;;		} else if s.cursorState == cursorStateMidBlock {
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) midBlock() {
0000000000000000000000000000000000000000;;		s.cursorState = cursorStateMidBlock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) endBlock() {
0000000000000000000000000000000000000000;;		s.printDelimiter()
0000000000000000000000000000000000000000;;		s.cursorState = cursorStateEndBlock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) stream() {
0000000000000000000000000000000000000000;;		s.cursorState = cursorStateStreaming
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) printBlockWithMessage(header string, message string, spec *types.SpecSummary, succinct bool) {
0000000000000000000000000000000000000000;;		s.startBlock()
0000000000000000000000000000000000000000;;		s.println(0, header)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indentation := s.printCodeLocationBlock(spec.ComponentTexts, spec.ComponentCodeLocations, types.SpecComponentTypeInvalid, 0, spec.State, succinct)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if message != "" {
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;			s.println(indentation, message)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.endBlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) printSpecFailure(message string, spec *types.SpecSummary, succinct bool, fullTrace bool) {
0000000000000000000000000000000000000000;;		s.startBlock()
0000000000000000000000000000000000000000;;		s.println(0, s.colorize(redColor+boldStyle, "%s%s [%.3f seconds]", message, s.failureContext(spec.Failure.ComponentType), spec.RunTime.Seconds()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indentation := s.printCodeLocationBlock(spec.ComponentTexts, spec.ComponentCodeLocations, spec.Failure.ComponentType, spec.Failure.ComponentIndex, spec.State, succinct)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		s.printFailure(indentation, spec.State, spec.Failure, fullTrace)
0000000000000000000000000000000000000000;;		s.endBlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) failureContext(failedComponentType types.SpecComponentType) string {
0000000000000000000000000000000000000000;;		switch failedComponentType {
0000000000000000000000000000000000000000;;		case types.SpecComponentTypeBeforeSuite:
0000000000000000000000000000000000000000;;			return " in Suite Setup (BeforeSuite)"
0000000000000000000000000000000000000000;;		case types.SpecComponentTypeAfterSuite:
0000000000000000000000000000000000000000;;			return " in Suite Teardown (AfterSuite)"
0000000000000000000000000000000000000000;;		case types.SpecComponentTypeBeforeEach:
0000000000000000000000000000000000000000;;			return " in Spec Setup (BeforeEach)"
0000000000000000000000000000000000000000;;		case types.SpecComponentTypeJustBeforeEach:
0000000000000000000000000000000000000000;;			return " in Spec Setup (JustBeforeEach)"
0000000000000000000000000000000000000000;;		case types.SpecComponentTypeAfterEach:
0000000000000000000000000000000000000000;;			return " in Spec Teardown (AfterEach)"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) printSkip(indentation int, spec types.SpecFailure) {
0000000000000000000000000000000000000000;;		s.println(indentation, s.colorize(cyanColor, spec.Message))
0000000000000000000000000000000000000000;;		s.printNewLine()
0000000000000000000000000000000000000000;;		s.println(indentation, spec.Location.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) printFailure(indentation int, state types.SpecState, failure types.SpecFailure, fullTrace bool) {
0000000000000000000000000000000000000000;;		if state == types.SpecStatePanicked {
0000000000000000000000000000000000000000;;			s.println(indentation, s.colorize(redColor+boldStyle, failure.Message))
0000000000000000000000000000000000000000;;			s.println(indentation, s.colorize(redColor, failure.ForwardedPanic))
0000000000000000000000000000000000000000;;			s.println(indentation, failure.Location.String())
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;			s.println(indentation, s.colorize(redColor, "Full Stack Trace"))
0000000000000000000000000000000000000000;;			s.println(indentation, failure.Location.FullStackTrace)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.println(indentation, s.colorize(redColor, failure.Message))
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;			s.println(indentation, failure.Location.String())
0000000000000000000000000000000000000000;;			if fullTrace {
0000000000000000000000000000000000000000;;				s.printNewLine()
0000000000000000000000000000000000000000;;				s.println(indentation, s.colorize(redColor, "Full Stack Trace"))
0000000000000000000000000000000000000000;;				s.println(indentation, failure.Location.FullStackTrace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) printSpecContext(componentTexts []string, componentCodeLocations []types.CodeLocation, failedComponentType types.SpecComponentType, failedComponentIndex int, state types.SpecState, succinct bool) int {
0000000000000000000000000000000000000000;;		startIndex := 1
0000000000000000000000000000000000000000;;		indentation := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(componentTexts) == 1 {
0000000000000000000000000000000000000000;;			startIndex = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := startIndex; i < len(componentTexts); i++ {
0000000000000000000000000000000000000000;;			if (state.IsFailure() || state == types.SpecStateSkipped) && i == failedComponentIndex {
0000000000000000000000000000000000000000;;				color := redColor
0000000000000000000000000000000000000000;;				if state == types.SpecStateSkipped {
0000000000000000000000000000000000000000;;					color = cyanColor
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				blockType := ""
0000000000000000000000000000000000000000;;				switch failedComponentType {
0000000000000000000000000000000000000000;;				case types.SpecComponentTypeBeforeSuite:
0000000000000000000000000000000000000000;;					blockType = "BeforeSuite"
0000000000000000000000000000000000000000;;				case types.SpecComponentTypeAfterSuite:
0000000000000000000000000000000000000000;;					blockType = "AfterSuite"
0000000000000000000000000000000000000000;;				case types.SpecComponentTypeBeforeEach:
0000000000000000000000000000000000000000;;					blockType = "BeforeEach"
0000000000000000000000000000000000000000;;				case types.SpecComponentTypeJustBeforeEach:
0000000000000000000000000000000000000000;;					blockType = "JustBeforeEach"
0000000000000000000000000000000000000000;;				case types.SpecComponentTypeAfterEach:
0000000000000000000000000000000000000000;;					blockType = "AfterEach"
0000000000000000000000000000000000000000;;				case types.SpecComponentTypeIt:
0000000000000000000000000000000000000000;;					blockType = "It"
0000000000000000000000000000000000000000;;				case types.SpecComponentTypeMeasure:
0000000000000000000000000000000000000000;;					blockType = "Measurement"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if succinct {
0000000000000000000000000000000000000000;;					s.print(0, s.colorize(color+boldStyle, "[%s] %s ", blockType, componentTexts[i]))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					s.println(indentation, s.colorize(color+boldStyle, "%s [%s]", componentTexts[i], blockType))
0000000000000000000000000000000000000000;;					s.println(indentation, s.colorize(grayColor, "%s", componentCodeLocations[i]))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if succinct {
0000000000000000000000000000000000000000;;					s.print(0, s.colorize(alternatingColors[i%2], "%s ", componentTexts[i]))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					s.println(indentation, componentTexts[i])
0000000000000000000000000000000000000000;;					s.println(indentation, s.colorize(grayColor, "%s", componentCodeLocations[i]))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			indentation++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return indentation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) printCodeLocationBlock(componentTexts []string, componentCodeLocations []types.CodeLocation, failedComponentType types.SpecComponentType, failedComponentIndex int, state types.SpecState, succinct bool) int {
0000000000000000000000000000000000000000;;		indentation := s.printSpecContext(componentTexts, componentCodeLocations, failedComponentType, failedComponentIndex, state, succinct)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if succinct {
0000000000000000000000000000000000000000;;			if len(componentTexts) > 0 {
0000000000000000000000000000000000000000;;				s.printNewLine()
0000000000000000000000000000000000000000;;				s.print(0, s.colorize(lightGrayColor, "%s", componentCodeLocations[len(componentCodeLocations)-1]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.printNewLine()
0000000000000000000000000000000000000000;;			indentation = 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			indentation--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return indentation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) orderedMeasurementKeys(measurements map[string]*types.SpecMeasurement) []string {
0000000000000000000000000000000000000000;;		orderedKeys := make([]string, len(measurements))
0000000000000000000000000000000000000000;;		for key, measurement := range measurements {
0000000000000000000000000000000000000000;;			orderedKeys[measurement.Order] = key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return orderedKeys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *consoleStenographer) measurementReport(spec *types.SpecSummary, succinct bool) string {
0000000000000000000000000000000000000000;;		if len(spec.Measurements) == 0 {
0000000000000000000000000000000000000000;;			return "Found no measurements"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		message := []string{}
0000000000000000000000000000000000000000;;		orderedKeys := s.orderedMeasurementKeys(spec.Measurements)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if succinct {
0000000000000000000000000000000000000000;;			message = append(message, fmt.Sprintf("%s samples:", s.colorize(boldStyle, "%d", spec.NumberOfSamples)))
0000000000000000000000000000000000000000;;			for _, key := range orderedKeys {
0000000000000000000000000000000000000000;;				measurement := spec.Measurements[key]
0000000000000000000000000000000000000000;;				message = append(message, fmt.Sprintf("  %s - %s: %s%s, %s: %s%s ± %s%s, %s: %s%s",
0000000000000000000000000000000000000000;;					s.colorize(boldStyle, "%s", measurement.Name),
0000000000000000000000000000000000000000;;					measurement.SmallestLabel,
0000000000000000000000000000000000000000;;					s.colorize(greenColor, measurement.PrecisionFmt(), measurement.Smallest),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;					measurement.AverageLabel,
0000000000000000000000000000000000000000;;					s.colorize(cyanColor, measurement.PrecisionFmt(), measurement.Average),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;					s.colorize(cyanColor, measurement.PrecisionFmt(), measurement.StdDeviation),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;					measurement.LargestLabel,
0000000000000000000000000000000000000000;;					s.colorize(redColor, measurement.PrecisionFmt(), measurement.Largest),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;				))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			message = append(message, fmt.Sprintf("Ran %s samples:", s.colorize(boldStyle, "%d", spec.NumberOfSamples)))
0000000000000000000000000000000000000000;;			for _, key := range orderedKeys {
0000000000000000000000000000000000000000;;				measurement := spec.Measurements[key]
0000000000000000000000000000000000000000;;				info := ""
0000000000000000000000000000000000000000;;				if measurement.Info != nil {
0000000000000000000000000000000000000000;;					message = append(message, fmt.Sprintf("%v", measurement.Info))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				message = append(message, fmt.Sprintf("%s:\n%s  %s: %s%s\n  %s: %s%s\n  %s: %s%s ± %s%s",
0000000000000000000000000000000000000000;;					s.colorize(boldStyle, "%s", measurement.Name),
0000000000000000000000000000000000000000;;					info,
0000000000000000000000000000000000000000;;					measurement.SmallestLabel,
0000000000000000000000000000000000000000;;					s.colorize(greenColor, measurement.PrecisionFmt(), measurement.Smallest),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;					measurement.LargestLabel,
0000000000000000000000000000000000000000;;					s.colorize(redColor, measurement.PrecisionFmt(), measurement.Largest),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;					measurement.AverageLabel,
0000000000000000000000000000000000000000;;					s.colorize(cyanColor, measurement.PrecisionFmt(), measurement.Average),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;					s.colorize(cyanColor, measurement.PrecisionFmt(), measurement.StdDeviation),
0000000000000000000000000000000000000000;;					measurement.Units,
0000000000000000000000000000000000000000;;				))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(message, "\n")
0000000000000000000000000000000000000000;;	}
