0000000000000000000000000000000000000000;;	package colorable
e07e695c44b94a0d579e53cb32d7781780627e96;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters/stenographer/support/go-isatty"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		foregroundBlue      = 0x1
0000000000000000000000000000000000000000;;		foregroundGreen     = 0x2
0000000000000000000000000000000000000000;;		foregroundRed       = 0x4
0000000000000000000000000000000000000000;;		foregroundIntensity = 0x8
0000000000000000000000000000000000000000;;		foregroundMask      = (foregroundRed | foregroundBlue | foregroundGreen | foregroundIntensity)
0000000000000000000000000000000000000000;;		backgroundBlue      = 0x10
0000000000000000000000000000000000000000;;		backgroundGreen     = 0x20
0000000000000000000000000000000000000000;;		backgroundRed       = 0x40
0000000000000000000000000000000000000000;;		backgroundIntensity = 0x80
0000000000000000000000000000000000000000;;		backgroundMask      = (backgroundRed | backgroundBlue | backgroundGreen | backgroundIntensity)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wchar uint16
0000000000000000000000000000000000000000;;	type short int16
0000000000000000000000000000000000000000;;	type dword uint32
0000000000000000000000000000000000000000;;	type word uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type coord struct {
0000000000000000000000000000000000000000;;		x short
0000000000000000000000000000000000000000;;		y short
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type smallRect struct {
0000000000000000000000000000000000000000;;		left   short
0000000000000000000000000000000000000000;;		top    short
0000000000000000000000000000000000000000;;		right  short
0000000000000000000000000000000000000000;;		bottom short
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type consoleScreenBufferInfo struct {
0000000000000000000000000000000000000000;;		size              coord
0000000000000000000000000000000000000000;;		cursorPosition    coord
0000000000000000000000000000000000000000;;		attributes        word
0000000000000000000000000000000000000000;;		window            smallRect
0000000000000000000000000000000000000000;;		maximumWindowSize coord
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		kernel32                       = syscall.NewLazyDLL("kernel32.dll")
0000000000000000000000000000000000000000;;		procGetConsoleScreenBufferInfo = kernel32.NewProc("GetConsoleScreenBufferInfo")
0000000000000000000000000000000000000000;;		procSetConsoleTextAttribute    = kernel32.NewProc("SetConsoleTextAttribute")
0000000000000000000000000000000000000000;;		procSetConsoleCursorPosition   = kernel32.NewProc("SetConsoleCursorPosition")
0000000000000000000000000000000000000000;;		procFillConsoleOutputCharacter = kernel32.NewProc("FillConsoleOutputCharacterW")
0000000000000000000000000000000000000000;;		procFillConsoleOutputAttribute = kernel32.NewProc("FillConsoleOutputAttribute")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Writer struct {
0000000000000000000000000000000000000000;;		out     io.Writer
0000000000000000000000000000000000000000;;		handle  syscall.Handle
0000000000000000000000000000000000000000;;		lastbuf bytes.Buffer
0000000000000000000000000000000000000000;;		oldattr word
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewColorable(file *os.File) io.Writer {
0000000000000000000000000000000000000000;;		if file == nil {
0000000000000000000000000000000000000000;;			panic("nil passed instead of *os.File to NewColorable()")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isatty.IsTerminal(file.Fd()) {
0000000000000000000000000000000000000000;;			var csbi consoleScreenBufferInfo
0000000000000000000000000000000000000000;;			handle := syscall.Handle(file.Fd())
0000000000000000000000000000000000000000;;			procGetConsoleScreenBufferInfo.Call(uintptr(handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;			return &Writer{out: file, handle: handle, oldattr: csbi.attributes}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return file
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewColorableStdout() io.Writer {
0000000000000000000000000000000000000000;;		return NewColorable(os.Stdout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewColorableStderr() io.Writer {
0000000000000000000000000000000000000000;;		return NewColorable(os.Stderr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var color256 = map[int]int{
0000000000000000000000000000000000000000;;		0:   0x000000,
0000000000000000000000000000000000000000;;		1:   0x800000,
0000000000000000000000000000000000000000;;		2:   0x008000,
0000000000000000000000000000000000000000;;		3:   0x808000,
0000000000000000000000000000000000000000;;		4:   0x000080,
0000000000000000000000000000000000000000;;		5:   0x800080,
0000000000000000000000000000000000000000;;		6:   0x008080,
0000000000000000000000000000000000000000;;		7:   0xc0c0c0,
0000000000000000000000000000000000000000;;		8:   0x808080,
0000000000000000000000000000000000000000;;		9:   0xff0000,
0000000000000000000000000000000000000000;;		10:  0x00ff00,
0000000000000000000000000000000000000000;;		11:  0xffff00,
0000000000000000000000000000000000000000;;		12:  0x0000ff,
0000000000000000000000000000000000000000;;		13:  0xff00ff,
0000000000000000000000000000000000000000;;		14:  0x00ffff,
0000000000000000000000000000000000000000;;		15:  0xffffff,
0000000000000000000000000000000000000000;;		16:  0x000000,
0000000000000000000000000000000000000000;;		17:  0x00005f,
0000000000000000000000000000000000000000;;		18:  0x000087,
0000000000000000000000000000000000000000;;		19:  0x0000af,
0000000000000000000000000000000000000000;;		20:  0x0000d7,
0000000000000000000000000000000000000000;;		21:  0x0000ff,
0000000000000000000000000000000000000000;;		22:  0x005f00,
0000000000000000000000000000000000000000;;		23:  0x005f5f,
0000000000000000000000000000000000000000;;		24:  0x005f87,
0000000000000000000000000000000000000000;;		25:  0x005faf,
0000000000000000000000000000000000000000;;		26:  0x005fd7,
0000000000000000000000000000000000000000;;		27:  0x005fff,
0000000000000000000000000000000000000000;;		28:  0x008700,
0000000000000000000000000000000000000000;;		29:  0x00875f,
0000000000000000000000000000000000000000;;		30:  0x008787,
0000000000000000000000000000000000000000;;		31:  0x0087af,
0000000000000000000000000000000000000000;;		32:  0x0087d7,
0000000000000000000000000000000000000000;;		33:  0x0087ff,
0000000000000000000000000000000000000000;;		34:  0x00af00,
0000000000000000000000000000000000000000;;		35:  0x00af5f,
0000000000000000000000000000000000000000;;		36:  0x00af87,
0000000000000000000000000000000000000000;;		37:  0x00afaf,
0000000000000000000000000000000000000000;;		38:  0x00afd7,
0000000000000000000000000000000000000000;;		39:  0x00afff,
0000000000000000000000000000000000000000;;		40:  0x00d700,
0000000000000000000000000000000000000000;;		41:  0x00d75f,
0000000000000000000000000000000000000000;;		42:  0x00d787,
0000000000000000000000000000000000000000;;		43:  0x00d7af,
0000000000000000000000000000000000000000;;		44:  0x00d7d7,
0000000000000000000000000000000000000000;;		45:  0x00d7ff,
0000000000000000000000000000000000000000;;		46:  0x00ff00,
0000000000000000000000000000000000000000;;		47:  0x00ff5f,
0000000000000000000000000000000000000000;;		48:  0x00ff87,
0000000000000000000000000000000000000000;;		49:  0x00ffaf,
0000000000000000000000000000000000000000;;		50:  0x00ffd7,
0000000000000000000000000000000000000000;;		51:  0x00ffff,
0000000000000000000000000000000000000000;;		52:  0x5f0000,
0000000000000000000000000000000000000000;;		53:  0x5f005f,
0000000000000000000000000000000000000000;;		54:  0x5f0087,
0000000000000000000000000000000000000000;;		55:  0x5f00af,
0000000000000000000000000000000000000000;;		56:  0x5f00d7,
0000000000000000000000000000000000000000;;		57:  0x5f00ff,
0000000000000000000000000000000000000000;;		58:  0x5f5f00,
0000000000000000000000000000000000000000;;		59:  0x5f5f5f,
0000000000000000000000000000000000000000;;		60:  0x5f5f87,
0000000000000000000000000000000000000000;;		61:  0x5f5faf,
0000000000000000000000000000000000000000;;		62:  0x5f5fd7,
0000000000000000000000000000000000000000;;		63:  0x5f5fff,
0000000000000000000000000000000000000000;;		64:  0x5f8700,
0000000000000000000000000000000000000000;;		65:  0x5f875f,
0000000000000000000000000000000000000000;;		66:  0x5f8787,
0000000000000000000000000000000000000000;;		67:  0x5f87af,
0000000000000000000000000000000000000000;;		68:  0x5f87d7,
0000000000000000000000000000000000000000;;		69:  0x5f87ff,
0000000000000000000000000000000000000000;;		70:  0x5faf00,
0000000000000000000000000000000000000000;;		71:  0x5faf5f,
0000000000000000000000000000000000000000;;		72:  0x5faf87,
0000000000000000000000000000000000000000;;		73:  0x5fafaf,
0000000000000000000000000000000000000000;;		74:  0x5fafd7,
0000000000000000000000000000000000000000;;		75:  0x5fafff,
0000000000000000000000000000000000000000;;		76:  0x5fd700,
0000000000000000000000000000000000000000;;		77:  0x5fd75f,
0000000000000000000000000000000000000000;;		78:  0x5fd787,
0000000000000000000000000000000000000000;;		79:  0x5fd7af,
0000000000000000000000000000000000000000;;		80:  0x5fd7d7,
0000000000000000000000000000000000000000;;		81:  0x5fd7ff,
0000000000000000000000000000000000000000;;		82:  0x5fff00,
0000000000000000000000000000000000000000;;		83:  0x5fff5f,
0000000000000000000000000000000000000000;;		84:  0x5fff87,
0000000000000000000000000000000000000000;;		85:  0x5fffaf,
0000000000000000000000000000000000000000;;		86:  0x5fffd7,
0000000000000000000000000000000000000000;;		87:  0x5fffff,
0000000000000000000000000000000000000000;;		88:  0x870000,
0000000000000000000000000000000000000000;;		89:  0x87005f,
0000000000000000000000000000000000000000;;		90:  0x870087,
0000000000000000000000000000000000000000;;		91:  0x8700af,
0000000000000000000000000000000000000000;;		92:  0x8700d7,
0000000000000000000000000000000000000000;;		93:  0x8700ff,
0000000000000000000000000000000000000000;;		94:  0x875f00,
0000000000000000000000000000000000000000;;		95:  0x875f5f,
0000000000000000000000000000000000000000;;		96:  0x875f87,
0000000000000000000000000000000000000000;;		97:  0x875faf,
0000000000000000000000000000000000000000;;		98:  0x875fd7,
0000000000000000000000000000000000000000;;		99:  0x875fff,
0000000000000000000000000000000000000000;;		100: 0x878700,
0000000000000000000000000000000000000000;;		101: 0x87875f,
0000000000000000000000000000000000000000;;		102: 0x878787,
0000000000000000000000000000000000000000;;		103: 0x8787af,
0000000000000000000000000000000000000000;;		104: 0x8787d7,
0000000000000000000000000000000000000000;;		105: 0x8787ff,
0000000000000000000000000000000000000000;;		106: 0x87af00,
0000000000000000000000000000000000000000;;		107: 0x87af5f,
0000000000000000000000000000000000000000;;		108: 0x87af87,
0000000000000000000000000000000000000000;;		109: 0x87afaf,
0000000000000000000000000000000000000000;;		110: 0x87afd7,
0000000000000000000000000000000000000000;;		111: 0x87afff,
0000000000000000000000000000000000000000;;		112: 0x87d700,
0000000000000000000000000000000000000000;;		113: 0x87d75f,
0000000000000000000000000000000000000000;;		114: 0x87d787,
0000000000000000000000000000000000000000;;		115: 0x87d7af,
0000000000000000000000000000000000000000;;		116: 0x87d7d7,
0000000000000000000000000000000000000000;;		117: 0x87d7ff,
0000000000000000000000000000000000000000;;		118: 0x87ff00,
0000000000000000000000000000000000000000;;		119: 0x87ff5f,
0000000000000000000000000000000000000000;;		120: 0x87ff87,
0000000000000000000000000000000000000000;;		121: 0x87ffaf,
0000000000000000000000000000000000000000;;		122: 0x87ffd7,
0000000000000000000000000000000000000000;;		123: 0x87ffff,
0000000000000000000000000000000000000000;;		124: 0xaf0000,
0000000000000000000000000000000000000000;;		125: 0xaf005f,
0000000000000000000000000000000000000000;;		126: 0xaf0087,
0000000000000000000000000000000000000000;;		127: 0xaf00af,
0000000000000000000000000000000000000000;;		128: 0xaf00d7,
0000000000000000000000000000000000000000;;		129: 0xaf00ff,
0000000000000000000000000000000000000000;;		130: 0xaf5f00,
0000000000000000000000000000000000000000;;		131: 0xaf5f5f,
0000000000000000000000000000000000000000;;		132: 0xaf5f87,
0000000000000000000000000000000000000000;;		133: 0xaf5faf,
0000000000000000000000000000000000000000;;		134: 0xaf5fd7,
0000000000000000000000000000000000000000;;		135: 0xaf5fff,
0000000000000000000000000000000000000000;;		136: 0xaf8700,
0000000000000000000000000000000000000000;;		137: 0xaf875f,
0000000000000000000000000000000000000000;;		138: 0xaf8787,
0000000000000000000000000000000000000000;;		139: 0xaf87af,
0000000000000000000000000000000000000000;;		140: 0xaf87d7,
0000000000000000000000000000000000000000;;		141: 0xaf87ff,
0000000000000000000000000000000000000000;;		142: 0xafaf00,
0000000000000000000000000000000000000000;;		143: 0xafaf5f,
0000000000000000000000000000000000000000;;		144: 0xafaf87,
0000000000000000000000000000000000000000;;		145: 0xafafaf,
0000000000000000000000000000000000000000;;		146: 0xafafd7,
0000000000000000000000000000000000000000;;		147: 0xafafff,
0000000000000000000000000000000000000000;;		148: 0xafd700,
0000000000000000000000000000000000000000;;		149: 0xafd75f,
0000000000000000000000000000000000000000;;		150: 0xafd787,
0000000000000000000000000000000000000000;;		151: 0xafd7af,
0000000000000000000000000000000000000000;;		152: 0xafd7d7,
0000000000000000000000000000000000000000;;		153: 0xafd7ff,
0000000000000000000000000000000000000000;;		154: 0xafff00,
0000000000000000000000000000000000000000;;		155: 0xafff5f,
0000000000000000000000000000000000000000;;		156: 0xafff87,
0000000000000000000000000000000000000000;;		157: 0xafffaf,
0000000000000000000000000000000000000000;;		158: 0xafffd7,
0000000000000000000000000000000000000000;;		159: 0xafffff,
0000000000000000000000000000000000000000;;		160: 0xd70000,
0000000000000000000000000000000000000000;;		161: 0xd7005f,
0000000000000000000000000000000000000000;;		162: 0xd70087,
0000000000000000000000000000000000000000;;		163: 0xd700af,
0000000000000000000000000000000000000000;;		164: 0xd700d7,
0000000000000000000000000000000000000000;;		165: 0xd700ff,
0000000000000000000000000000000000000000;;		166: 0xd75f00,
0000000000000000000000000000000000000000;;		167: 0xd75f5f,
0000000000000000000000000000000000000000;;		168: 0xd75f87,
0000000000000000000000000000000000000000;;		169: 0xd75faf,
0000000000000000000000000000000000000000;;		170: 0xd75fd7,
0000000000000000000000000000000000000000;;		171: 0xd75fff,
0000000000000000000000000000000000000000;;		172: 0xd78700,
0000000000000000000000000000000000000000;;		173: 0xd7875f,
0000000000000000000000000000000000000000;;		174: 0xd78787,
0000000000000000000000000000000000000000;;		175: 0xd787af,
0000000000000000000000000000000000000000;;		176: 0xd787d7,
0000000000000000000000000000000000000000;;		177: 0xd787ff,
0000000000000000000000000000000000000000;;		178: 0xd7af00,
0000000000000000000000000000000000000000;;		179: 0xd7af5f,
0000000000000000000000000000000000000000;;		180: 0xd7af87,
0000000000000000000000000000000000000000;;		181: 0xd7afaf,
0000000000000000000000000000000000000000;;		182: 0xd7afd7,
0000000000000000000000000000000000000000;;		183: 0xd7afff,
0000000000000000000000000000000000000000;;		184: 0xd7d700,
0000000000000000000000000000000000000000;;		185: 0xd7d75f,
0000000000000000000000000000000000000000;;		186: 0xd7d787,
0000000000000000000000000000000000000000;;		187: 0xd7d7af,
0000000000000000000000000000000000000000;;		188: 0xd7d7d7,
0000000000000000000000000000000000000000;;		189: 0xd7d7ff,
0000000000000000000000000000000000000000;;		190: 0xd7ff00,
0000000000000000000000000000000000000000;;		191: 0xd7ff5f,
0000000000000000000000000000000000000000;;		192: 0xd7ff87,
0000000000000000000000000000000000000000;;		193: 0xd7ffaf,
0000000000000000000000000000000000000000;;		194: 0xd7ffd7,
0000000000000000000000000000000000000000;;		195: 0xd7ffff,
0000000000000000000000000000000000000000;;		196: 0xff0000,
0000000000000000000000000000000000000000;;		197: 0xff005f,
0000000000000000000000000000000000000000;;		198: 0xff0087,
0000000000000000000000000000000000000000;;		199: 0xff00af,
0000000000000000000000000000000000000000;;		200: 0xff00d7,
0000000000000000000000000000000000000000;;		201: 0xff00ff,
0000000000000000000000000000000000000000;;		202: 0xff5f00,
0000000000000000000000000000000000000000;;		203: 0xff5f5f,
0000000000000000000000000000000000000000;;		204: 0xff5f87,
0000000000000000000000000000000000000000;;		205: 0xff5faf,
0000000000000000000000000000000000000000;;		206: 0xff5fd7,
0000000000000000000000000000000000000000;;		207: 0xff5fff,
0000000000000000000000000000000000000000;;		208: 0xff8700,
0000000000000000000000000000000000000000;;		209: 0xff875f,
0000000000000000000000000000000000000000;;		210: 0xff8787,
0000000000000000000000000000000000000000;;		211: 0xff87af,
0000000000000000000000000000000000000000;;		212: 0xff87d7,
0000000000000000000000000000000000000000;;		213: 0xff87ff,
0000000000000000000000000000000000000000;;		214: 0xffaf00,
0000000000000000000000000000000000000000;;		215: 0xffaf5f,
0000000000000000000000000000000000000000;;		216: 0xffaf87,
0000000000000000000000000000000000000000;;		217: 0xffafaf,
0000000000000000000000000000000000000000;;		218: 0xffafd7,
0000000000000000000000000000000000000000;;		219: 0xffafff,
0000000000000000000000000000000000000000;;		220: 0xffd700,
0000000000000000000000000000000000000000;;		221: 0xffd75f,
0000000000000000000000000000000000000000;;		222: 0xffd787,
0000000000000000000000000000000000000000;;		223: 0xffd7af,
0000000000000000000000000000000000000000;;		224: 0xffd7d7,
0000000000000000000000000000000000000000;;		225: 0xffd7ff,
0000000000000000000000000000000000000000;;		226: 0xffff00,
0000000000000000000000000000000000000000;;		227: 0xffff5f,
0000000000000000000000000000000000000000;;		228: 0xffff87,
0000000000000000000000000000000000000000;;		229: 0xffffaf,
0000000000000000000000000000000000000000;;		230: 0xffffd7,
0000000000000000000000000000000000000000;;		231: 0xffffff,
0000000000000000000000000000000000000000;;		232: 0x080808,
0000000000000000000000000000000000000000;;		233: 0x121212,
0000000000000000000000000000000000000000;;		234: 0x1c1c1c,
0000000000000000000000000000000000000000;;		235: 0x262626,
0000000000000000000000000000000000000000;;		236: 0x303030,
0000000000000000000000000000000000000000;;		237: 0x3a3a3a,
0000000000000000000000000000000000000000;;		238: 0x444444,
0000000000000000000000000000000000000000;;		239: 0x4e4e4e,
0000000000000000000000000000000000000000;;		240: 0x585858,
0000000000000000000000000000000000000000;;		241: 0x626262,
0000000000000000000000000000000000000000;;		242: 0x6c6c6c,
0000000000000000000000000000000000000000;;		243: 0x767676,
0000000000000000000000000000000000000000;;		244: 0x808080,
0000000000000000000000000000000000000000;;		245: 0x8a8a8a,
0000000000000000000000000000000000000000;;		246: 0x949494,
0000000000000000000000000000000000000000;;		247: 0x9e9e9e,
0000000000000000000000000000000000000000;;		248: 0xa8a8a8,
0000000000000000000000000000000000000000;;		249: 0xb2b2b2,
0000000000000000000000000000000000000000;;		250: 0xbcbcbc,
0000000000000000000000000000000000000000;;		251: 0xc6c6c6,
0000000000000000000000000000000000000000;;		252: 0xd0d0d0,
0000000000000000000000000000000000000000;;		253: 0xdadada,
0000000000000000000000000000000000000000;;		254: 0xe4e4e4,
0000000000000000000000000000000000000000;;		255: 0xeeeeee,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *Writer) Write(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		var csbi consoleScreenBufferInfo
0000000000000000000000000000000000000000;;		procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		er := bytes.NewBuffer(data)
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r1, _, err := procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;			if r1 == 0 {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c1, _, err := er.ReadRune()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c1 != 0x1b {
0000000000000000000000000000000000000000;;				fmt.Fprint(w.out, string(c1))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c2, _, err := er.ReadRune()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				w.lastbuf.WriteRune(c1)
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c2 != 0x5b {
0000000000000000000000000000000000000000;;				w.lastbuf.WriteRune(c1)
0000000000000000000000000000000000000000;;				w.lastbuf.WriteRune(c2)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var buf bytes.Buffer
0000000000000000000000000000000000000000;;			var m rune
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				c, _, err := er.ReadRune()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					w.lastbuf.WriteRune(c1)
0000000000000000000000000000000000000000;;					w.lastbuf.WriteRune(c2)
0000000000000000000000000000000000000000;;					w.lastbuf.Write(buf.Bytes())
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || c == '@' {
0000000000000000000000000000000000000000;;					m = c
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.Write([]byte(string(c)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var csbi consoleScreenBufferInfo
0000000000000000000000000000000000000000;;			switch m {
0000000000000000000000000000000000000000;;			case 'A':
0000000000000000000000000000000000000000;;				n, err = strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;				csbi.cursorPosition.y -= short(n)
0000000000000000000000000000000000000000;;				procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;			case 'B':
0000000000000000000000000000000000000000;;				n, err = strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;				csbi.cursorPosition.y += short(n)
0000000000000000000000000000000000000000;;				procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;			case 'C':
0000000000000000000000000000000000000000;;				n, err = strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;				csbi.cursorPosition.x -= short(n)
0000000000000000000000000000000000000000;;				procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;			case 'D':
0000000000000000000000000000000000000000;;				n, err = strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n, err = strconv.Atoi(buf.String()); err == nil {
0000000000000000000000000000000000000000;;					var csbi consoleScreenBufferInfo
0000000000000000000000000000000000000000;;					procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;					csbi.cursorPosition.x += short(n)
0000000000000000000000000000000000000000;;					procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case 'E':
0000000000000000000000000000000000000000;;				n, err = strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;				csbi.cursorPosition.x = 0
0000000000000000000000000000000000000000;;				csbi.cursorPosition.y += short(n)
0000000000000000000000000000000000000000;;				procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;			case 'F':
0000000000000000000000000000000000000000;;				n, err = strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;				csbi.cursorPosition.x = 0
0000000000000000000000000000000000000000;;				csbi.cursorPosition.y -= short(n)
0000000000000000000000000000000000000000;;				procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;			case 'G':
0000000000000000000000000000000000000000;;				n, err = strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))
0000000000000000000000000000000000000000;;				csbi.cursorPosition.x = short(n)
0000000000000000000000000000000000000000;;				procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;			case 'H':
0000000000000000000000000000000000000000;;				token := strings.Split(buf.String(), ";")
0000000000000000000000000000000000000000;;				if len(token) != 2 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n1, err := strconv.Atoi(token[0])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n2, err := strconv.Atoi(token[1])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				csbi.cursorPosition.x = short(n2)
0000000000000000000000000000000000000000;;				csbi.cursorPosition.x = short(n1)
0000000000000000000000000000000000000000;;				procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))
0000000000000000000000000000000000000000;;			case 'J':
0000000000000000000000000000000000000000;;				n, err := strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var cursor coord
0000000000000000000000000000000000000000;;				switch n {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					cursor = coord{x: csbi.cursorPosition.x, y: csbi.cursorPosition.y}
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					cursor = coord{x: csbi.window.left, y: csbi.window.top}
0000000000000000000000000000000000000000;;				case 2:
0000000000000000000000000000000000000000;;					cursor = coord{x: csbi.window.left, y: csbi.window.top}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var count, written dword
0000000000000000000000000000000000000000;;				count = dword(csbi.size.x - csbi.cursorPosition.x + (csbi.size.y-csbi.cursorPosition.y)*csbi.size.x)
0000000000000000000000000000000000000000;;				procFillConsoleOutputCharacter.Call(uintptr(w.handle), uintptr(' '), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))
0000000000000000000000000000000000000000;;				procFillConsoleOutputAttribute.Call(uintptr(w.handle), uintptr(csbi.attributes), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))
0000000000000000000000000000000000000000;;			case 'K':
0000000000000000000000000000000000000000;;				n, err := strconv.Atoi(buf.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var cursor coord
0000000000000000000000000000000000000000;;				switch n {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					cursor = coord{x: csbi.cursorPosition.x, y: csbi.cursorPosition.y}
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					cursor = coord{x: csbi.window.left, y: csbi.window.top + csbi.cursorPosition.y}
0000000000000000000000000000000000000000;;				case 2:
0000000000000000000000000000000000000000;;					cursor = coord{x: csbi.window.left, y: csbi.window.top + csbi.cursorPosition.y}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var count, written dword
0000000000000000000000000000000000000000;;				count = dword(csbi.size.x - csbi.cursorPosition.x)
0000000000000000000000000000000000000000;;				procFillConsoleOutputCharacter.Call(uintptr(w.handle), uintptr(' '), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))
0000000000000000000000000000000000000000;;				procFillConsoleOutputAttribute.Call(uintptr(w.handle), uintptr(csbi.attributes), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))
0000000000000000000000000000000000000000;;			case 'm':
0000000000000000000000000000000000000000;;				attr := csbi.attributes
0000000000000000000000000000000000000000;;				cs := buf.String()
0000000000000000000000000000000000000000;;				if cs == "" {
0000000000000000000000000000000000000000;;					procSetConsoleTextAttribute.Call(uintptr(w.handle), uintptr(w.oldattr))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				token := strings.Split(cs, ";")
0000000000000000000000000000000000000000;;				for i := 0; i < len(token); i += 1 {
0000000000000000000000000000000000000000;;					ns := token[i]
0000000000000000000000000000000000000000;;					if n, err = strconv.Atoi(ns); err == nil {
0000000000000000000000000000000000000000;;						switch {
0000000000000000000000000000000000000000;;						case n == 0 || n == 100:
0000000000000000000000000000000000000000;;							attr = w.oldattr
0000000000000000000000000000000000000000;;						case 1 <= n && n <= 5:
0000000000000000000000000000000000000000;;							attr |= foregroundIntensity
0000000000000000000000000000000000000000;;						case n == 7:
0000000000000000000000000000000000000000;;							attr = ((attr & foregroundMask) << 4) | ((attr & backgroundMask) >> 4)
0000000000000000000000000000000000000000;;						case 22 == n || n == 25 || n == 25:
0000000000000000000000000000000000000000;;							attr |= foregroundIntensity
0000000000000000000000000000000000000000;;						case n == 27:
0000000000000000000000000000000000000000;;							attr = ((attr & foregroundMask) << 4) | ((attr & backgroundMask) >> 4)
0000000000000000000000000000000000000000;;						case 30 <= n && n <= 37:
0000000000000000000000000000000000000000;;							attr = (attr & backgroundMask)
0000000000000000000000000000000000000000;;							if (n-30)&1 != 0 {
0000000000000000000000000000000000000000;;								attr |= foregroundRed
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-30)&2 != 0 {
0000000000000000000000000000000000000000;;								attr |= foregroundGreen
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-30)&4 != 0 {
0000000000000000000000000000000000000000;;								attr |= foregroundBlue
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						case n == 38: // set foreground color.
0000000000000000000000000000000000000000;;							if i < len(token)-2 && (token[i+1] == "5" || token[i+1] == "05") {
0000000000000000000000000000000000000000;;								if n256, err := strconv.Atoi(token[i+2]); err == nil {
0000000000000000000000000000000000000000;;									if n256foreAttr == nil {
0000000000000000000000000000000000000000;;										n256setup()
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;									attr &= backgroundMask
0000000000000000000000000000000000000000;;									attr |= n256foreAttr[n256]
0000000000000000000000000000000000000000;;									i += 2
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								attr = attr & (w.oldattr & backgroundMask)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						case n == 39: // reset foreground color.
0000000000000000000000000000000000000000;;							attr &= backgroundMask
0000000000000000000000000000000000000000;;							attr |= w.oldattr & foregroundMask
0000000000000000000000000000000000000000;;						case 40 <= n && n <= 47:
0000000000000000000000000000000000000000;;							attr = (attr & foregroundMask)
0000000000000000000000000000000000000000;;							if (n-40)&1 != 0 {
0000000000000000000000000000000000000000;;								attr |= backgroundRed
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-40)&2 != 0 {
0000000000000000000000000000000000000000;;								attr |= backgroundGreen
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-40)&4 != 0 {
0000000000000000000000000000000000000000;;								attr |= backgroundBlue
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						case n == 48: // set background color.
0000000000000000000000000000000000000000;;							if i < len(token)-2 && token[i+1] == "5" {
0000000000000000000000000000000000000000;;								if n256, err := strconv.Atoi(token[i+2]); err == nil {
0000000000000000000000000000000000000000;;									if n256backAttr == nil {
0000000000000000000000000000000000000000;;										n256setup()
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;									attr &= foregroundMask
0000000000000000000000000000000000000000;;									attr |= n256backAttr[n256]
0000000000000000000000000000000000000000;;									i += 2
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								attr = attr & (w.oldattr & foregroundMask)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						case n == 49: // reset foreground color.
0000000000000000000000000000000000000000;;							attr &= foregroundMask
0000000000000000000000000000000000000000;;							attr |= w.oldattr & backgroundMask
0000000000000000000000000000000000000000;;						case 90 <= n && n <= 97:
0000000000000000000000000000000000000000;;							attr = (attr & backgroundMask)
0000000000000000000000000000000000000000;;							attr |= foregroundIntensity
0000000000000000000000000000000000000000;;							if (n-90)&1 != 0 {
0000000000000000000000000000000000000000;;								attr |= foregroundRed
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-90)&2 != 0 {
0000000000000000000000000000000000000000;;								attr |= foregroundGreen
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-90)&4 != 0 {
0000000000000000000000000000000000000000;;								attr |= foregroundBlue
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						case 100 <= n && n <= 107:
0000000000000000000000000000000000000000;;							attr = (attr & foregroundMask)
0000000000000000000000000000000000000000;;							attr |= backgroundIntensity
0000000000000000000000000000000000000000;;							if (n-100)&1 != 0 {
0000000000000000000000000000000000000000;;								attr |= backgroundRed
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-100)&2 != 0 {
0000000000000000000000000000000000000000;;								attr |= backgroundGreen
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if (n-100)&4 != 0 {
0000000000000000000000000000000000000000;;								attr |= backgroundBlue
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						procSetConsoleTextAttribute.Call(uintptr(w.handle), uintptr(attr))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(data) - w.lastbuf.Len(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type consoleColor struct {
0000000000000000000000000000000000000000;;		rgb       int
0000000000000000000000000000000000000000;;		red       bool
0000000000000000000000000000000000000000;;		green     bool
0000000000000000000000000000000000000000;;		blue      bool
0000000000000000000000000000000000000000;;		intensity bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c consoleColor) foregroundAttr() (attr word) {
0000000000000000000000000000000000000000;;		if c.red {
0000000000000000000000000000000000000000;;			attr |= foregroundRed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.green {
0000000000000000000000000000000000000000;;			attr |= foregroundGreen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.blue {
0000000000000000000000000000000000000000;;			attr |= foregroundBlue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.intensity {
0000000000000000000000000000000000000000;;			attr |= foregroundIntensity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c consoleColor) backgroundAttr() (attr word) {
0000000000000000000000000000000000000000;;		if c.red {
0000000000000000000000000000000000000000;;			attr |= backgroundRed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.green {
0000000000000000000000000000000000000000;;			attr |= backgroundGreen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.blue {
0000000000000000000000000000000000000000;;			attr |= backgroundBlue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.intensity {
0000000000000000000000000000000000000000;;			attr |= backgroundIntensity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var color16 = []consoleColor{
0000000000000000000000000000000000000000;;		consoleColor{0x000000, false, false, false, false},
0000000000000000000000000000000000000000;;		consoleColor{0x000080, false, false, true, false},
0000000000000000000000000000000000000000;;		consoleColor{0x008000, false, true, false, false},
0000000000000000000000000000000000000000;;		consoleColor{0x008080, false, true, true, false},
0000000000000000000000000000000000000000;;		consoleColor{0x800000, true, false, false, false},
0000000000000000000000000000000000000000;;		consoleColor{0x800080, true, false, true, false},
0000000000000000000000000000000000000000;;		consoleColor{0x808000, true, true, false, false},
0000000000000000000000000000000000000000;;		consoleColor{0xc0c0c0, true, true, true, false},
0000000000000000000000000000000000000000;;		consoleColor{0x808080, false, false, false, true},
0000000000000000000000000000000000000000;;		consoleColor{0x0000ff, false, false, true, true},
0000000000000000000000000000000000000000;;		consoleColor{0x00ff00, false, true, false, true},
0000000000000000000000000000000000000000;;		consoleColor{0x00ffff, false, true, true, true},
0000000000000000000000000000000000000000;;		consoleColor{0xff0000, true, false, false, true},
0000000000000000000000000000000000000000;;		consoleColor{0xff00ff, true, false, true, true},
0000000000000000000000000000000000000000;;		consoleColor{0xffff00, true, true, false, true},
0000000000000000000000000000000000000000;;		consoleColor{0xffffff, true, true, true, true},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hsv struct {
0000000000000000000000000000000000000000;;		h, s, v float32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a hsv) dist(b hsv) float32 {
0000000000000000000000000000000000000000;;		dh := a.h - b.h
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case dh > 0.5:
0000000000000000000000000000000000000000;;			dh = 1 - dh
0000000000000000000000000000000000000000;;		case dh < -0.5:
0000000000000000000000000000000000000000;;			dh = -1 - dh
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds := a.s - b.s
0000000000000000000000000000000000000000;;		dv := a.v - b.v
0000000000000000000000000000000000000000;;		return float32(math.Sqrt(float64(dh*dh + ds*ds + dv*dv)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toHSV(rgb int) hsv {
0000000000000000000000000000000000000000;;		r, g, b := float32((rgb&0xFF0000)>>16)/256.0,
0000000000000000000000000000000000000000;;			float32((rgb&0x00FF00)>>8)/256.0,
0000000000000000000000000000000000000000;;			float32(rgb&0x0000FF)/256.0
0000000000000000000000000000000000000000;;		min, max := minmax3f(r, g, b)
0000000000000000000000000000000000000000;;		h := max - min
0000000000000000000000000000000000000000;;		if h > 0 {
0000000000000000000000000000000000000000;;			if max == r {
0000000000000000000000000000000000000000;;				h = (g - b) / h
0000000000000000000000000000000000000000;;				if h < 0 {
0000000000000000000000000000000000000000;;					h += 6
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if max == g {
0000000000000000000000000000000000000000;;				h = 2 + (b-r)/h
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				h = 4 + (r-g)/h
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h /= 6.0
0000000000000000000000000000000000000000;;		s := max - min
0000000000000000000000000000000000000000;;		if max != 0 {
0000000000000000000000000000000000000000;;			s /= max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := max
0000000000000000000000000000000000000000;;		return hsv{h: h, s: s, v: v}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hsvTable []hsv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toHSVTable(rgbTable []consoleColor) hsvTable {
0000000000000000000000000000000000000000;;		t := make(hsvTable, len(rgbTable))
0000000000000000000000000000000000000000;;		for i, c := range rgbTable {
0000000000000000000000000000000000000000;;			t[i] = toHSV(c.rgb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t hsvTable) find(rgb int) consoleColor {
0000000000000000000000000000000000000000;;		hsv := toHSV(rgb)
0000000000000000000000000000000000000000;;		n := 7
0000000000000000000000000000000000000000;;		l := float32(5.0)
0000000000000000000000000000000000000000;;		for i, p := range t {
0000000000000000000000000000000000000000;;			d := hsv.dist(p)
0000000000000000000000000000000000000000;;			if d < l {
0000000000000000000000000000000000000000;;				l, n = d, i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return color16[n]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func minmax3f(a, b, c float32) (min, max float32) {
0000000000000000000000000000000000000000;;		if a < b {
0000000000000000000000000000000000000000;;			if b < c {
0000000000000000000000000000000000000000;;				return a, c
0000000000000000000000000000000000000000;;			} else if a < c {
0000000000000000000000000000000000000000;;				return a, b
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return c, b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if a < c {
0000000000000000000000000000000000000000;;				return b, c
0000000000000000000000000000000000000000;;			} else if b < c {
0000000000000000000000000000000000000000;;				return b, a
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return c, a
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var n256foreAttr []word
0000000000000000000000000000000000000000;;	var n256backAttr []word
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func n256setup() {
0000000000000000000000000000000000000000;;		n256foreAttr = make([]word, 256)
0000000000000000000000000000000000000000;;		n256backAttr = make([]word, 256)
0000000000000000000000000000000000000000;;		t := toHSVTable(color16)
0000000000000000000000000000000000000000;;		for i, rgb := range color256 {
0000000000000000000000000000000000000000;;			c := t.find(rgb)
0000000000000000000000000000000000000000;;			n256foreAttr[i] = c.foregroundAttr()
0000000000000000000000000000000000000000;;			n256backAttr[i] = c.backgroundAttr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
