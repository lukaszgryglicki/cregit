0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Ginkgo is a BDD-style testing framework for Golang
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo_dsl.go[Godeps/_workspace/src/github.com/onsi/ginkgo/ginkgo_dsl.go][vendor/github.com/onsi/ginkgo/ginkgo_dsl.go];	
0000000000000000000000000000000000000000;;	The godoc documentation describes Ginkgo's API.  More comprehensive documentation (with examples!) is available at http://onsi.github.io/ginkgo/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Ginkgo's preferred matcher library is [Gomega](http://github.com/onsi/gomega)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Ginkgo on Github: http://github.com/onsi/ginkgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Ginkgo is MIT-Licensed
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package ginkgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/codelocation"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/failer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/remote"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/suite"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/testingtproxy"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/writer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters/stenographer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const GINKGO_VERSION = config.VERSION
0000000000000000000000000000000000000000;;	const GINKGO_PANIC = `
0000000000000000000000000000000000000000;;	Your test failed.
0000000000000000000000000000000000000000;;	Ginkgo panics to prevent subsequent assertions from running.
0000000000000000000000000000000000000000;;	Normally Ginkgo rescues this panic so you shouldn't see it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	But, if you make an assertion in a goroutine, Ginkgo can't capture the panic.
0000000000000000000000000000000000000000;;	To circumvent this, you should call
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer GinkgoRecover()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	at the top of the goroutine that caused this panic.
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const defaultTimeout = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var globalSuite *suite.Suite
0000000000000000000000000000000000000000;;	var globalFailer *failer.Failer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		config.Flags(flag.CommandLine, "ginkgo", true)
0000000000000000000000000000000000000000;;		GinkgoWriter = writer.New(os.Stdout)
0000000000000000000000000000000000000000;;		globalFailer = failer.New()
0000000000000000000000000000000000000000;;		globalSuite = suite.New(globalFailer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GinkgoWriter implements an io.Writer
0000000000000000000000000000000000000000;;	//When running in verbose mode any writes to GinkgoWriter will be immediately printed
0000000000000000000000000000000000000000;;	//to stdout.  Otherwise, GinkgoWriter will buffer any writes produced during the current test and flush them to screen
0000000000000000000000000000000000000000;;	//only if the current test fails.
0000000000000000000000000000000000000000;;	var GinkgoWriter io.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//The interface by which Ginkgo receives *testing.T
0000000000000000000000000000000000000000;;	type GinkgoTestingT interface {
0000000000000000000000000000000000000000;;		Fail()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GinkgoRandomSeed returns the seed used to randomize spec execution order.  It is
0000000000000000000000000000000000000000;;	//useful for seeding your own pseudorandom number generators (PRNGs) to ensure
0000000000000000000000000000000000000000;;	//consistent executions from run to run, where your tests contain variability (for
0000000000000000000000000000000000000000;;	//example, when selecting random test data).
0000000000000000000000000000000000000000;;	func GinkgoRandomSeed() int64 {
0000000000000000000000000000000000000000;;		return config.GinkgoConfig.RandomSeed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GinkgoParallelNode returns the parallel node number for the current ginkgo process
0000000000000000000000000000000000000000;;	//The node number is 1-indexed
0000000000000000000000000000000000000000;;	func GinkgoParallelNode() int {
0000000000000000000000000000000000000000;;		return config.GinkgoConfig.ParallelNode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Some matcher libraries or legacy codebases require a *testing.T
0000000000000000000000000000000000000000;;	//GinkgoT implements an interface analogous to *testing.T and can be used if
0000000000000000000000000000000000000000;;	//the library in question accepts *testing.T through an interface
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, with testify:
0000000000000000000000000000000000000000;;	// assert.Equal(GinkgoT(), 123, 123, "they should be equal")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Or with gomock:
0000000000000000000000000000000000000000;;	// gomock.NewController(GinkgoT())
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// GinkgoT() takes an optional offset argument that can be used to get the
0000000000000000000000000000000000000000;;	// correct line number associated with the failure.
0000000000000000000000000000000000000000;;	func GinkgoT(optionalOffset ...int) GinkgoTInterface {
0000000000000000000000000000000000000000;;		offset := 3
0000000000000000000000000000000000000000;;		if len(optionalOffset) > 0 {
0000000000000000000000000000000000000000;;			offset = optionalOffset[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return testingtproxy.New(GinkgoWriter, Fail, offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//The interface returned by GinkgoT().  This covers most of the methods
0000000000000000000000000000000000000000;;	//in the testing package's T.
0000000000000000000000000000000000000000;;	type GinkgoTInterface interface {
0000000000000000000000000000000000000000;;		Fail()
0000000000000000000000000000000000000000;;		Error(args ...interface{})
0000000000000000000000000000000000000000;;		Errorf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		FailNow()
0000000000000000000000000000000000000000;;		Fatal(args ...interface{})
0000000000000000000000000000000000000000;;		Fatalf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Log(args ...interface{})
0000000000000000000000000000000000000000;;		Logf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Failed() bool
0000000000000000000000000000000000000000;;		Parallel()
0000000000000000000000000000000000000000;;		Skip(args ...interface{})
0000000000000000000000000000000000000000;;		Skipf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		SkipNow()
0000000000000000000000000000000000000000;;		Skipped() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Custom Ginkgo test reporters must implement the Reporter interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//The custom reporter is passed in a SuiteSummary when the suite begins and ends,
0000000000000000000000000000000000000000;;	//and a SpecSummary just before a spec begins and just after a spec ends
0000000000000000000000000000000000000000;;	type Reporter reporters.Reporter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Asynchronous specs are given a channel of the Done type.  You must close or write to the channel
0000000000000000000000000000000000000000;;	//to tell Ginkgo that your async test is done.
0000000000000000000000000000000000000000;;	type Done chan<- interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GinkgoTestDescription represents the information about the current running test returned by CurrentGinkgoTestDescription
0000000000000000000000000000000000000000;;	//	FullTestText: a concatenation of ComponentTexts and the TestText
0000000000000000000000000000000000000000;;	//	ComponentTexts: a list of all texts for the Describes & Contexts leading up to the current test
0000000000000000000000000000000000000000;;	//	TestText: the text in the actual It or Measure node
0000000000000000000000000000000000000000;;	//	IsMeasurement: true if the current test is a measurement
0000000000000000000000000000000000000000;;	//	FileName: the name of the file containing the current test
0000000000000000000000000000000000000000;;	//	LineNumber: the line number for the current test
0000000000000000000000000000000000000000;;	//	Failed: if the current test has failed, this will be true (useful in an AfterEach)
0000000000000000000000000000000000000000;;	type GinkgoTestDescription struct {
0000000000000000000000000000000000000000;;		FullTestText   string
0000000000000000000000000000000000000000;;		ComponentTexts []string
0000000000000000000000000000000000000000;;		TestText       string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		IsMeasurement bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FileName   string
0000000000000000000000000000000000000000;;		LineNumber int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Failed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//CurrentGinkgoTestDescripton returns information about the current running test.
0000000000000000000000000000000000000000;;	func CurrentGinkgoTestDescription() GinkgoTestDescription {
0000000000000000000000000000000000000000;;		summary, ok := globalSuite.CurrentRunningSpecSummary()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return GinkgoTestDescription{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subjectCodeLocation := summary.ComponentCodeLocations[len(summary.ComponentCodeLocations)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return GinkgoTestDescription{
0000000000000000000000000000000000000000;;			ComponentTexts: summary.ComponentTexts[1:],
0000000000000000000000000000000000000000;;			FullTestText:   strings.Join(summary.ComponentTexts[1:], " "),
0000000000000000000000000000000000000000;;			TestText:       summary.ComponentTexts[len(summary.ComponentTexts)-1],
0000000000000000000000000000000000000000;;			IsMeasurement:  summary.IsMeasurement,
0000000000000000000000000000000000000000;;			FileName:       subjectCodeLocation.FileName,
0000000000000000000000000000000000000000;;			LineNumber:     subjectCodeLocation.LineNumber,
0000000000000000000000000000000000000000;;			Failed:         summary.HasFailureState(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Measurement tests receive a Benchmarker.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//You use the Time() function to time how long the passed in body function takes to run
0000000000000000000000000000000000000000;;	//You use the RecordValue() function to track arbitrary numerical measurements.
0000000000000000000000000000000000000000;;	//The RecordValueWithPrecision() function can be used alternatively to provide the unit
0000000000000000000000000000000000000000;;	//and resolution of the numeric measurement.
0000000000000000000000000000000000000000;;	//The optional info argument is passed to the test reporter and can be used to
0000000000000000000000000000000000000000;;	// provide the measurement data to a custom reporter with context.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//See http://onsi.github.io/ginkgo/#benchmark_tests for more details
0000000000000000000000000000000000000000;;	type Benchmarker interface {
0000000000000000000000000000000000000000;;		Time(name string, body func(), info ...interface{}) (elapsedTime time.Duration)
0000000000000000000000000000000000000000;;		RecordValue(name string, value float64, info ...interface{})
0000000000000000000000000000000000000000;;		RecordValueWithPrecision(name string, value float64, units string, precision int, info ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//RunSpecs is the entry point for the Ginkgo test runner.
0000000000000000000000000000000000000000;;	//You must call this within a Golang testing TestX(t *testing.T) function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//To bootstrap a test suite you can use the Ginkgo CLI:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	ginkgo bootstrap
0000000000000000000000000000000000000000;;	func RunSpecs(t GinkgoTestingT, description string) bool {
0000000000000000000000000000000000000000;;		specReporters := []Reporter{buildDefaultReporter()}
0000000000000000000000000000000000000000;;		return RunSpecsWithCustomReporters(t, description, specReporters)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//To run your tests with Ginkgo's default reporter and your custom reporter(s), replace
0000000000000000000000000000000000000000;;	//RunSpecs() with this method.
0000000000000000000000000000000000000000;;	func RunSpecsWithDefaultAndCustomReporters(t GinkgoTestingT, description string, specReporters []Reporter) bool {
0000000000000000000000000000000000000000;;		specReporters = append([]Reporter{buildDefaultReporter()}, specReporters...)
0000000000000000000000000000000000000000;;		return RunSpecsWithCustomReporters(t, description, specReporters)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//To run your tests with your custom reporter(s) (and *not* Ginkgo's default reporter), replace
0000000000000000000000000000000000000000;;	//RunSpecs() with this method.  Note that parallel tests will not work correctly without the default reporter
0000000000000000000000000000000000000000;;	func RunSpecsWithCustomReporters(t GinkgoTestingT, description string, specReporters []Reporter) bool {
0000000000000000000000000000000000000000;;		writer := GinkgoWriter.(*writer.Writer)
0000000000000000000000000000000000000000;;		writer.SetStream(config.DefaultReporterConfig.Verbose)
0000000000000000000000000000000000000000;;		reporters := make([]reporters.Reporter, len(specReporters))
0000000000000000000000000000000000000000;;		for i, reporter := range specReporters {
0000000000000000000000000000000000000000;;			reporters[i] = reporter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		passed, hasFocusedTests := globalSuite.Run(t, description, reporters, writer, config.GinkgoConfig)
0000000000000000000000000000000000000000;;		if passed && hasFocusedTests {
0000000000000000000000000000000000000000;;			fmt.Println("PASS | FOCUSED")
0000000000000000000000000000000000000000;;			os.Exit(types.GINKGO_FOCUS_EXIT_CODE)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return passed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildDefaultReporter() Reporter {
0000000000000000000000000000000000000000;;		remoteReportingServer := config.GinkgoConfig.StreamHost
0000000000000000000000000000000000000000;;		if remoteReportingServer == "" {
0000000000000000000000000000000000000000;;			stenographer := stenographer.New(!config.DefaultReporterConfig.NoColor, config.GinkgoConfig.FlakeAttempts > 1)
0000000000000000000000000000000000000000;;			return reporters.NewDefaultReporter(config.DefaultReporterConfig, stenographer)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return remote.NewForwardingReporter(remoteReportingServer, &http.Client{}, remote.NewOutputInterceptor())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Skip notifies Ginkgo that the current spec should be skipped.
0000000000000000000000000000000000000000;;	func Skip(message string, callerSkip ...int) {
0000000000000000000000000000000000000000;;		skip := 0
0000000000000000000000000000000000000000;;		if len(callerSkip) > 0 {
0000000000000000000000000000000000000000;;			skip = callerSkip[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		globalFailer.Skip(message, codelocation.New(skip+1))
0000000000000000000000000000000000000000;;		panic(GINKGO_PANIC)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Fail notifies Ginkgo that the current spec has failed. (Gomega will call Fail for you automatically when an assertion fails.)
0000000000000000000000000000000000000000;;	func Fail(message string, callerSkip ...int) {
0000000000000000000000000000000000000000;;		skip := 0
0000000000000000000000000000000000000000;;		if len(callerSkip) > 0 {
0000000000000000000000000000000000000000;;			skip = callerSkip[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		globalFailer.Fail(message, codelocation.New(skip+1))
0000000000000000000000000000000000000000;;		panic(GINKGO_PANIC)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GinkgoRecover should be deferred at the top of any spawned goroutine that (may) call `Fail`
0000000000000000000000000000000000000000;;	//Since Gomega assertions call fail, you should throw a `defer GinkgoRecover()` at the top of any goroutine that
0000000000000000000000000000000000000000;;	//calls out to Gomega
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Here's why: Ginkgo's `Fail` method records the failure and then panics to prevent
0000000000000000000000000000000000000000;;	//further assertions from running.  This panic must be recovered.  Ginkgo does this for you
0000000000000000000000000000000000000000;;	//if the panic originates in a Ginkgo node (an It, BeforeEach, etc...)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Unfortunately, if a panic originates on a goroutine *launched* from one of these nodes there's no
0000000000000000000000000000000000000000;;	//way for Ginkgo to rescue the panic.  To do this, you must remember to `defer GinkgoRecover()` at the top of such a goroutine.
0000000000000000000000000000000000000000;;	func GinkgoRecover() {
0000000000000000000000000000000000000000;;		e := recover()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			globalFailer.Panic(codelocation.New(1), e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Describe blocks allow you to organize your specs.  A Describe block can contain any number of
0000000000000000000000000000000000000000;;	//BeforeEach, AfterEach, JustBeforeEach, It, and Measurement blocks.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//In addition you can nest Describe and Context blocks.  Describe and Context blocks are functionally
0000000000000000000000000000000000000000;;	//equivalent.  The difference is purely semantic -- you typical Describe the behavior of an object
0000000000000000000000000000000000000000;;	//or method and, within that Describe, outline a number of Contexts.
0000000000000000000000000000000000000000;;	func Describe(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypeNone, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can focus the tests within a describe block using FDescribe
0000000000000000000000000000000000000000;;	func FDescribe(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypeFocused, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark the tests within a describe block as pending using PDescribe
0000000000000000000000000000000000000000;;	func PDescribe(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypePending, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark the tests within a describe block as pending using XDescribe
0000000000000000000000000000000000000000;;	func XDescribe(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypePending, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Context blocks allow you to organize your specs.  A Context block can contain any number of
0000000000000000000000000000000000000000;;	//BeforeEach, AfterEach, JustBeforeEach, It, and Measurement blocks.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//In addition you can nest Describe and Context blocks.  Describe and Context blocks are functionally
0000000000000000000000000000000000000000;;	//equivalent.  The difference is purely semantic -- you typical Describe the behavior of an object
0000000000000000000000000000000000000000;;	//or method and, within that Describe, outline a number of Contexts.
0000000000000000000000000000000000000000;;	func Context(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypeNone, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can focus the tests within a describe block using FContext
0000000000000000000000000000000000000000;;	func FContext(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypeFocused, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark the tests within a describe block as pending using PContext
0000000000000000000000000000000000000000;;	func PContext(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypePending, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark the tests within a describe block as pending using XContext
0000000000000000000000000000000000000000;;	func XContext(text string, body func()) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushContainerNode(text, body, types.FlagTypePending, codelocation.New(1))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//It blocks contain your test code and assertions.  You cannot nest any other Ginkgo blocks
0000000000000000000000000000000000000000;;	//within an It block.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Ginkgo will normally run It blocks synchronously.  To perform asynchronous tests, pass a
0000000000000000000000000000000000000000;;	//function that accepts a Done channel.  When you do this, you can also provide an optional timeout.
0000000000000000000000000000000000000000;;	func It(text string, body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushItNode(text, body, types.FlagTypeNone, codelocation.New(1), parseTimeout(timeout...))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can focus individual Its using FIt
0000000000000000000000000000000000000000;;	func FIt(text string, body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushItNode(text, body, types.FlagTypeFocused, codelocation.New(1), parseTimeout(timeout...))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark Its as pending using PIt
0000000000000000000000000000000000000000;;	func PIt(text string, _ ...interface{}) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushItNode(text, func() {}, types.FlagTypePending, codelocation.New(1), 0)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark Its as pending using XIt
0000000000000000000000000000000000000000;;	func XIt(text string, _ ...interface{}) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushItNode(text, func() {}, types.FlagTypePending, codelocation.New(1), 0)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Specify blocks are aliases for It blocks and allow for more natural wording in situations
0000000000000000000000000000000000000000;;	//which "It" does not fit into a natural sentence flow. All the same protocols apply for Specify blocks
0000000000000000000000000000000000000000;;	//which apply to It blocks.
0000000000000000000000000000000000000000;;	func Specify(text string, body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		return It(text, body, timeout...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can focus individual Specifys using FSpecify
0000000000000000000000000000000000000000;;	func FSpecify(text string, body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		return FIt(text, body, timeout...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark Specifys as pending using PSpecify
0000000000000000000000000000000000000000;;	func PSpecify(text string, is ...interface{}) bool {
0000000000000000000000000000000000000000;;		return PIt(text, is...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark Specifys as pending using XSpecify
0000000000000000000000000000000000000000;;	func XSpecify(text string, is ...interface{}) bool {
0000000000000000000000000000000000000000;;		return XIt(text, is...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//By allows you to better document large Its.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Generally you should try to keep your Its short and to the point.  This is not always possible, however,
0000000000000000000000000000000000000000;;	//especially in the context of integration tests that capture a particular workflow.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//By allows you to document such flows.  By must be called within a runnable node (It, BeforeEach, Measure, etc...)
0000000000000000000000000000000000000000;;	//By will simply log the passed in text to the GinkgoWriter.  If By is handed a function it will immediately run the function.
0000000000000000000000000000000000000000;;	func By(text string, callbacks ...func()) {
0000000000000000000000000000000000000000;;		preamble := "\x1b[1mSTEP\x1b[0m"
0000000000000000000000000000000000000000;;		if config.DefaultReporterConfig.NoColor {
0000000000000000000000000000000000000000;;			preamble = "STEP"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(GinkgoWriter, preamble+": "+text)
0000000000000000000000000000000000000000;;		if len(callbacks) == 1 {
0000000000000000000000000000000000000000;;			callbacks[0]()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(callbacks) > 1 {
0000000000000000000000000000000000000000;;			panic("just one callback per By, please")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Measure blocks run the passed in body function repeatedly (determined by the samples argument)
0000000000000000000000000000000000000000;;	//and accumulate metrics provided to the Benchmarker by the body function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//The body function must have the signature:
0000000000000000000000000000000000000000;;	//	func(b Benchmarker)
0000000000000000000000000000000000000000;;	func Measure(text string, body interface{}, samples int) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushMeasureNode(text, body, types.FlagTypeNone, codelocation.New(1), samples)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can focus individual Measures using FMeasure
0000000000000000000000000000000000000000;;	func FMeasure(text string, body interface{}, samples int) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushMeasureNode(text, body, types.FlagTypeFocused, codelocation.New(1), samples)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark Maeasurements as pending using PMeasure
0000000000000000000000000000000000000000;;	func PMeasure(text string, _ ...interface{}) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushMeasureNode(text, func(b Benchmarker) {}, types.FlagTypePending, codelocation.New(1), 0)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//You can mark Maeasurements as pending using XMeasure
0000000000000000000000000000000000000000;;	func XMeasure(text string, _ ...interface{}) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushMeasureNode(text, func(b Benchmarker) {}, types.FlagTypePending, codelocation.New(1), 0)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeforeSuite blocks are run just once before any specs are run.  When running in parallel, each
0000000000000000000000000000000000000000;;	//parallel node process will call BeforeSuite.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//BeforeSuite blocks can be made asynchronous by providing a body function that accepts a Done channel
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//You may only register *one* BeforeSuite handler per test suite.  You typically do so in your bootstrap file at the top level.
0000000000000000000000000000000000000000;;	func BeforeSuite(body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.SetBeforeSuiteNode(body, codelocation.New(1), parseTimeout(timeout...))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//AfterSuite blocks are *always* run after all the specs regardless of whether specs have passed or failed.
0000000000000000000000000000000000000000;;	//Moreover, if Ginkgo receives an interrupt signal (^C) it will attempt to run the AfterSuite before exiting.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//When running in parallel, each parallel node process will call AfterSuite.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//AfterSuite blocks can be made asynchronous by providing a body function that accepts a Done channel
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//You may only register *one* AfterSuite handler per test suite.  You typically do so in your bootstrap file at the top level.
0000000000000000000000000000000000000000;;	func AfterSuite(body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.SetAfterSuiteNode(body, codelocation.New(1), parseTimeout(timeout...))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//SynchronizedBeforeSuite blocks are primarily meant to solve the problem of setting up singleton external resources shared across
0000000000000000000000000000000000000000;;	//nodes when running tests in parallel.  For example, say you have a shared database that you can only start one instance of that
0000000000000000000000000000000000000000;;	//must be used in your tests.  When running in parallel, only one node should set up the database and all other nodes should wait
0000000000000000000000000000000000000000;;	//until that node is done before running.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//SynchronizedBeforeSuite accomplishes this by taking *two* function arguments.  The first is only run on parallel node #1.  The second is
0000000000000000000000000000000000000000;;	//run on all nodes, but *only* after the first function completes succesfully.  Ginkgo also makes it possible to send data from the first function (on Node 1)
0000000000000000000000000000000000000000;;	//to the second function (on all the other nodes).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//The functions have the following signatures.  The first function (which only runs on node 1) has the signature:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	func() []byte
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//or, to run asynchronously:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	func(done Done) []byte
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//The byte array returned by the first function is then passed to the second function, which has the signature:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	func(data []byte)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//or, to run asynchronously:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	func(data []byte, done Done)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Here's a simple pseudo-code example that starts a shared database on Node 1 and shares the database's address with the other nodes:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	var dbClient db.Client
0000000000000000000000000000000000000000;;	//	var dbRunner db.Runner
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	var _ = SynchronizedBeforeSuite(func() []byte {
0000000000000000000000000000000000000000;;	//		dbRunner = db.NewRunner()
0000000000000000000000000000000000000000;;	//		err := dbRunner.Start()
0000000000000000000000000000000000000000;;	//		Ω(err).ShouldNot(HaveOccurred())
0000000000000000000000000000000000000000;;	//		return []byte(dbRunner.URL)
0000000000000000000000000000000000000000;;	//	}, func(data []byte) {
0000000000000000000000000000000000000000;;	//		dbClient = db.NewClient()
0000000000000000000000000000000000000000;;	//		err := dbClient.Connect(string(data))
0000000000000000000000000000000000000000;;	//		Ω(err).ShouldNot(HaveOccurred())
0000000000000000000000000000000000000000;;	//	})
0000000000000000000000000000000000000000;;	func SynchronizedBeforeSuite(node1Body interface{}, allNodesBody interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.SetSynchronizedBeforeSuiteNode(
0000000000000000000000000000000000000000;;			node1Body,
0000000000000000000000000000000000000000;;			allNodesBody,
0000000000000000000000000000000000000000;;			codelocation.New(1),
0000000000000000000000000000000000000000;;			parseTimeout(timeout...),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//SynchronizedAfterSuite blocks complement the SynchronizedBeforeSuite blocks in solving the problem of setting up
0000000000000000000000000000000000000000;;	//external singleton resources shared across nodes when running tests in parallel.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//SynchronizedAfterSuite accomplishes this by taking *two* function arguments.  The first runs on all nodes.  The second runs only on parallel node #1
0000000000000000000000000000000000000000;;	//and *only* after all other nodes have finished and exited.  This ensures that node 1, and any resources it is running, remain alive until
0000000000000000000000000000000000000000;;	//all other nodes are finished.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Both functions have the same signature: either func() or func(done Done) to run asynchronously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Here's a pseudo-code example that complements that given in SynchronizedBeforeSuite.  Here, SynchronizedAfterSuite is used to tear down the shared database
0000000000000000000000000000000000000000;;	//only after all nodes have finished:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	var _ = SynchronizedAfterSuite(func() {
0000000000000000000000000000000000000000;;	//		dbClient.Cleanup()
0000000000000000000000000000000000000000;;	//	}, func() {
0000000000000000000000000000000000000000;;	//		dbRunner.Stop()
0000000000000000000000000000000000000000;;	//	})
0000000000000000000000000000000000000000;;	func SynchronizedAfterSuite(allNodesBody interface{}, node1Body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.SetSynchronizedAfterSuiteNode(
0000000000000000000000000000000000000000;;			allNodesBody,
0000000000000000000000000000000000000000;;			node1Body,
0000000000000000000000000000000000000000;;			codelocation.New(1),
0000000000000000000000000000000000000000;;			parseTimeout(timeout...),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeforeEach blocks are run before It blocks.  When multiple BeforeEach blocks are defined in nested
0000000000000000000000000000000000000000;;	//Describe and Context blocks the outermost BeforeEach blocks are run first.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Like It blocks, BeforeEach blocks can be made asynchronous by providing a body function that accepts
0000000000000000000000000000000000000000;;	//a Done channel
0000000000000000000000000000000000000000;;	func BeforeEach(body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushBeforeEachNode(body, codelocation.New(1), parseTimeout(timeout...))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//JustBeforeEach blocks are run before It blocks but *after* all BeforeEach blocks.  For more details,
0000000000000000000000000000000000000000;;	//read the [documentation](http://onsi.github.io/ginkgo/#separating_creation_and_configuration_)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Like It blocks, BeforeEach blocks can be made asynchronous by providing a body function that accepts
0000000000000000000000000000000000000000;;	//a Done channel
0000000000000000000000000000000000000000;;	func JustBeforeEach(body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushJustBeforeEachNode(body, codelocation.New(1), parseTimeout(timeout...))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//AfterEach blocks are run after It blocks.   When multiple AfterEach blocks are defined in nested
0000000000000000000000000000000000000000;;	//Describe and Context blocks the innermost AfterEach blocks are run first.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Like It blocks, AfterEach blocks can be made asynchronous by providing a body function that accepts
0000000000000000000000000000000000000000;;	//a Done channel
0000000000000000000000000000000000000000;;	func AfterEach(body interface{}, timeout ...float64) bool {
0000000000000000000000000000000000000000;;		globalSuite.PushAfterEachNode(body, codelocation.New(1), parseTimeout(timeout...))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseTimeout(timeout ...float64) time.Duration {
0000000000000000000000000000000000000000;;		if len(timeout) == 0 {
0000000000000000000000000000000000000000;;			return time.Duration(defaultTimeout * int64(time.Second))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return time.Duration(timeout[0] * float64(time.Second))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
