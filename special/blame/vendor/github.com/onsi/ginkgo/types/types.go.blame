0000000000000000000000000000000000000000;;	package types
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/types/types.go[Godeps/_workspace/src/github.com/onsi/ginkgo/types/types.go][vendor/github.com/onsi/ginkgo/types/types.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const GINKGO_FOCUS_EXIT_CODE = 197
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	SuiteSummary represents the a summary of the test suite and is passed to both
0000000000000000000000000000000000000000;;	Reporter.SpecSuiteWillBegin
0000000000000000000000000000000000000000;;	Reporter.SpecSuiteDidEnd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	this is unfortunate as these two methods should receive different objects.  When running in parallel
0000000000000000000000000000000000000000;;	each node does not deterministically know how many specs it will end up running.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unfortunately making such a change would break backward compatibility.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Until Ginkgo 2.0 comes out we will continue to reuse this struct but populate unkown fields
0000000000000000000000000000000000000000;;	with -1.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type SuiteSummary struct {
0000000000000000000000000000000000000000;;		SuiteDescription string
0000000000000000000000000000000000000000;;		SuiteSucceeded   bool
0000000000000000000000000000000000000000;;		SuiteID          string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		NumberOfSpecsBeforeParallelization int
0000000000000000000000000000000000000000;;		NumberOfTotalSpecs                 int
0000000000000000000000000000000000000000;;		NumberOfSpecsThatWillBeRun         int
0000000000000000000000000000000000000000;;		NumberOfPendingSpecs               int
0000000000000000000000000000000000000000;;		NumberOfSkippedSpecs               int
0000000000000000000000000000000000000000;;		NumberOfPassedSpecs                int
0000000000000000000000000000000000000000;;		NumberOfFailedSpecs                int
0000000000000000000000000000000000000000;;		// Flaked specs are those that failed initially, but then passed on a
0000000000000000000000000000000000000000;;		// subsequent try.
0000000000000000000000000000000000000000;;		NumberOfFlakedSpecs int
0000000000000000000000000000000000000000;;		RunTime             time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecSummary struct {
0000000000000000000000000000000000000000;;		ComponentTexts         []string
0000000000000000000000000000000000000000;;		ComponentCodeLocations []CodeLocation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		State           SpecState
0000000000000000000000000000000000000000;;		RunTime         time.Duration
0000000000000000000000000000000000000000;;		Failure         SpecFailure
0000000000000000000000000000000000000000;;		IsMeasurement   bool
0000000000000000000000000000000000000000;;		NumberOfSamples int
0000000000000000000000000000000000000000;;		Measurements    map[string]*SpecMeasurement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CapturedOutput string
0000000000000000000000000000000000000000;;		SuiteID        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecSummary) HasFailureState() bool {
0000000000000000000000000000000000000000;;		return s.State.IsFailure()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecSummary) TimedOut() bool {
0000000000000000000000000000000000000000;;		return s.State == SpecStateTimedOut
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecSummary) Panicked() bool {
0000000000000000000000000000000000000000;;		return s.State == SpecStatePanicked
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecSummary) Failed() bool {
0000000000000000000000000000000000000000;;		return s.State == SpecStateFailed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecSummary) Passed() bool {
0000000000000000000000000000000000000000;;		return s.State == SpecStatePassed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecSummary) Skipped() bool {
0000000000000000000000000000000000000000;;		return s.State == SpecStateSkipped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecSummary) Pending() bool {
0000000000000000000000000000000000000000;;		return s.State == SpecStatePending
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SetupSummary struct {
0000000000000000000000000000000000000000;;		ComponentType SpecComponentType
0000000000000000000000000000000000000000;;		CodeLocation  CodeLocation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		State   SpecState
0000000000000000000000000000000000000000;;		RunTime time.Duration
0000000000000000000000000000000000000000;;		Failure SpecFailure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CapturedOutput string
0000000000000000000000000000000000000000;;		SuiteID        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecFailure struct {
0000000000000000000000000000000000000000;;		Message        string
0000000000000000000000000000000000000000;;		Location       CodeLocation
0000000000000000000000000000000000000000;;		ForwardedPanic string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ComponentIndex        int
0000000000000000000000000000000000000000;;		ComponentType         SpecComponentType
0000000000000000000000000000000000000000;;		ComponentCodeLocation CodeLocation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecMeasurement struct {
0000000000000000000000000000000000000000;;		Name  string
0000000000000000000000000000000000000000;;		Info  interface{}
0000000000000000000000000000000000000000;;		Order int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Results []float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Smallest     float64
0000000000000000000000000000000000000000;;		Largest      float64
0000000000000000000000000000000000000000;;		Average      float64
0000000000000000000000000000000000000000;;		StdDeviation float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SmallestLabel string
0000000000000000000000000000000000000000;;		LargestLabel  string
0000000000000000000000000000000000000000;;		AverageLabel  string
0000000000000000000000000000000000000000;;		Units         string
0000000000000000000000000000000000000000;;		Precision     int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SpecMeasurement) PrecisionFmt() string {
0000000000000000000000000000000000000000;;		if s.Precision == 0 {
0000000000000000000000000000000000000000;;			return "%f"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		str := strconv.Itoa(s.Precision)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "%." + str + "f"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecState uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SpecStateInvalid SpecState = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SpecStatePending
0000000000000000000000000000000000000000;;		SpecStateSkipped
0000000000000000000000000000000000000000;;		SpecStatePassed
0000000000000000000000000000000000000000;;		SpecStateFailed
0000000000000000000000000000000000000000;;		SpecStatePanicked
0000000000000000000000000000000000000000;;		SpecStateTimedOut
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (state SpecState) IsFailure() bool {
0000000000000000000000000000000000000000;;		return state == SpecStateTimedOut || state == SpecStatePanicked || state == SpecStateFailed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecComponentType uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SpecComponentTypeInvalid SpecComponentType = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SpecComponentTypeContainer
0000000000000000000000000000000000000000;;		SpecComponentTypeBeforeSuite
0000000000000000000000000000000000000000;;		SpecComponentTypeAfterSuite
0000000000000000000000000000000000000000;;		SpecComponentTypeBeforeEach
0000000000000000000000000000000000000000;;		SpecComponentTypeJustBeforeEach
0000000000000000000000000000000000000000;;		SpecComponentTypeAfterEach
0000000000000000000000000000000000000000;;		SpecComponentTypeIt
0000000000000000000000000000000000000000;;		SpecComponentTypeMeasure
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FlagType uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FlagTypeNone FlagType = iota
0000000000000000000000000000000000000000;;		FlagTypeFocused
0000000000000000000000000000000000000000;;		FlagTypePending
0000000000000000000000000000000000000000;;	)
