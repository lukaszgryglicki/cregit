0000000000000000000000000000000000000000;;	package failer
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/failer/failer.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/failer/failer.go][vendor/github.com/onsi/ginkgo/internal/failer/failer.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Failer struct {
0000000000000000000000000000000000000000;;		lock    *sync.Mutex
0000000000000000000000000000000000000000;;		failure types.SpecFailure
0000000000000000000000000000000000000000;;		state   types.SpecState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New() *Failer {
0000000000000000000000000000000000000000;;		return &Failer{
0000000000000000000000000000000000000000;;			lock:  &sync.Mutex{},
0000000000000000000000000000000000000000;;			state: types.SpecStatePassed,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Failer) Panic(location types.CodeLocation, forwardedPanic interface{}) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.state == types.SpecStatePassed {
0000000000000000000000000000000000000000;;			f.state = types.SpecStatePanicked
0000000000000000000000000000000000000000;;			f.failure = types.SpecFailure{
0000000000000000000000000000000000000000;;				Message:        "Test Panicked",
0000000000000000000000000000000000000000;;				Location:       location,
0000000000000000000000000000000000000000;;				ForwardedPanic: fmt.Sprintf("%v", forwardedPanic),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Failer) Timeout(location types.CodeLocation) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.state == types.SpecStatePassed {
0000000000000000000000000000000000000000;;			f.state = types.SpecStateTimedOut
0000000000000000000000000000000000000000;;			f.failure = types.SpecFailure{
0000000000000000000000000000000000000000;;				Message:  "Timed out",
0000000000000000000000000000000000000000;;				Location: location,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Failer) Fail(message string, location types.CodeLocation) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.state == types.SpecStatePassed {
0000000000000000000000000000000000000000;;			f.state = types.SpecStateFailed
0000000000000000000000000000000000000000;;			f.failure = types.SpecFailure{
0000000000000000000000000000000000000000;;				Message:  message,
0000000000000000000000000000000000000000;;				Location: location,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Failer) Drain(componentType types.SpecComponentType, componentIndex int, componentCodeLocation types.CodeLocation) (types.SpecFailure, types.SpecState) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failure := f.failure
0000000000000000000000000000000000000000;;		outcome := f.state
0000000000000000000000000000000000000000;;		if outcome != types.SpecStatePassed {
0000000000000000000000000000000000000000;;			failure.ComponentType = componentType
0000000000000000000000000000000000000000;;			failure.ComponentIndex = componentIndex
0000000000000000000000000000000000000000;;			failure.ComponentCodeLocation = componentCodeLocation
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.state = types.SpecStatePassed
0000000000000000000000000000000000000000;;		f.failure = types.SpecFailure{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return failure, outcome
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Failer) Skip(message string, location types.CodeLocation) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.state == types.SpecStatePassed {
0000000000000000000000000000000000000000;;			f.state = types.SpecStateSkipped
0000000000000000000000000000000000000000;;			f.failure = types.SpecFailure{
0000000000000000000000000000000000000000;;				Message:  message,
0000000000000000000000000000000000000000;;				Location: location,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
