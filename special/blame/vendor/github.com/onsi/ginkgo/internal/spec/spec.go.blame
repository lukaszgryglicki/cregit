0000000000000000000000000000000000000000;;	package spec
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/spec/spec.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/spec/spec.go][vendor/github.com/onsi/ginkgo/internal/spec/spec.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/containernode"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/leafnodes"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Spec struct {
0000000000000000000000000000000000000000;;		subject          leafnodes.SubjectNode
0000000000000000000000000000000000000000;;		focused          bool
0000000000000000000000000000000000000000;;		announceProgress bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containers []*containernode.ContainerNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state            types.SpecState
0000000000000000000000000000000000000000;;		runTime          time.Duration
0000000000000000000000000000000000000000;;		failure          types.SpecFailure
0000000000000000000000000000000000000000;;		previousFailures bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(subject leafnodes.SubjectNode, containers []*containernode.ContainerNode, announceProgress bool) *Spec {
0000000000000000000000000000000000000000;;		spec := &Spec{
0000000000000000000000000000000000000000;;			subject:          subject,
0000000000000000000000000000000000000000;;			containers:       containers,
0000000000000000000000000000000000000000;;			focused:          subject.Flag() == types.FlagTypeFocused,
0000000000000000000000000000000000000000;;			announceProgress: announceProgress,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.processFlag(subject.Flag())
0000000000000000000000000000000000000000;;		for i := len(containers) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			spec.processFlag(containers[i].Flag())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) processFlag(flag types.FlagType) {
0000000000000000000000000000000000000000;;		if flag == types.FlagTypeFocused {
0000000000000000000000000000000000000000;;			spec.focused = true
0000000000000000000000000000000000000000;;		} else if flag == types.FlagTypePending {
0000000000000000000000000000000000000000;;			spec.state = types.SpecStatePending
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Skip() {
0000000000000000000000000000000000000000;;		spec.state = types.SpecStateSkipped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Failed() bool {
0000000000000000000000000000000000000000;;		return spec.state == types.SpecStateFailed || spec.state == types.SpecStatePanicked || spec.state == types.SpecStateTimedOut
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Passed() bool {
0000000000000000000000000000000000000000;;		return spec.state == types.SpecStatePassed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Flaked() bool {
0000000000000000000000000000000000000000;;		return spec.state == types.SpecStatePassed && spec.previousFailures
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Pending() bool {
0000000000000000000000000000000000000000;;		return spec.state == types.SpecStatePending
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Skipped() bool {
0000000000000000000000000000000000000000;;		return spec.state == types.SpecStateSkipped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Focused() bool {
0000000000000000000000000000000000000000;;		return spec.focused
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) IsMeasurement() bool {
0000000000000000000000000000000000000000;;		return spec.subject.Type() == types.SpecComponentTypeMeasure
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Summary(suiteID string) *types.SpecSummary {
0000000000000000000000000000000000000000;;		componentTexts := make([]string, len(spec.containers)+1)
0000000000000000000000000000000000000000;;		componentCodeLocations := make([]types.CodeLocation, len(spec.containers)+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, container := range spec.containers {
0000000000000000000000000000000000000000;;			componentTexts[i] = container.Text()
0000000000000000000000000000000000000000;;			componentCodeLocations[i] = container.CodeLocation()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		componentTexts[len(spec.containers)] = spec.subject.Text()
0000000000000000000000000000000000000000;;		componentCodeLocations[len(spec.containers)] = spec.subject.CodeLocation()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &types.SpecSummary{
0000000000000000000000000000000000000000;;			IsMeasurement:          spec.IsMeasurement(),
0000000000000000000000000000000000000000;;			NumberOfSamples:        spec.subject.Samples(),
0000000000000000000000000000000000000000;;			ComponentTexts:         componentTexts,
0000000000000000000000000000000000000000;;			ComponentCodeLocations: componentCodeLocations,
0000000000000000000000000000000000000000;;			State:        spec.state,
0000000000000000000000000000000000000000;;			RunTime:      spec.runTime,
0000000000000000000000000000000000000000;;			Failure:      spec.failure,
0000000000000000000000000000000000000000;;			Measurements: spec.measurementsReport(),
0000000000000000000000000000000000000000;;			SuiteID:      suiteID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) ConcatenatedString() string {
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		for _, container := range spec.containers {
0000000000000000000000000000000000000000;;			s += container.Text() + " "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s + spec.subject.Text()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) Run(writer io.Writer) {
0000000000000000000000000000000000000000;;		if spec.state == types.SpecStateFailed {
0000000000000000000000000000000000000000;;			spec.previousFailures = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			spec.runTime = time.Since(startTime)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for sample := 0; sample < spec.subject.Samples(); sample++ {
0000000000000000000000000000000000000000;;			spec.runSample(sample, writer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if spec.state != types.SpecStatePassed {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) runSample(sample int, writer io.Writer) {
0000000000000000000000000000000000000000;;		spec.state = types.SpecStatePassed
0000000000000000000000000000000000000000;;		spec.failure = types.SpecFailure{}
0000000000000000000000000000000000000000;;		innerMostContainerIndexToUnwind := -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			for i := innerMostContainerIndexToUnwind; i >= 0; i-- {
0000000000000000000000000000000000000000;;				container := spec.containers[i]
0000000000000000000000000000000000000000;;				for _, afterEach := range container.SetupNodesOfType(types.SpecComponentTypeAfterEach) {
0000000000000000000000000000000000000000;;					spec.announceSetupNode(writer, "AfterEach", container, afterEach)
0000000000000000000000000000000000000000;;					afterEachState, afterEachFailure := afterEach.Run()
0000000000000000000000000000000000000000;;					if afterEachState != types.SpecStatePassed && spec.state == types.SpecStatePassed {
0000000000000000000000000000000000000000;;						spec.state = afterEachState
0000000000000000000000000000000000000000;;						spec.failure = afterEachFailure
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, container := range spec.containers {
0000000000000000000000000000000000000000;;			innerMostContainerIndexToUnwind = i
0000000000000000000000000000000000000000;;			for _, beforeEach := range container.SetupNodesOfType(types.SpecComponentTypeBeforeEach) {
0000000000000000000000000000000000000000;;				spec.announceSetupNode(writer, "BeforeEach", container, beforeEach)
0000000000000000000000000000000000000000;;				spec.state, spec.failure = beforeEach.Run()
0000000000000000000000000000000000000000;;				if spec.state != types.SpecStatePassed {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, container := range spec.containers {
0000000000000000000000000000000000000000;;			for _, justBeforeEach := range container.SetupNodesOfType(types.SpecComponentTypeJustBeforeEach) {
0000000000000000000000000000000000000000;;				spec.announceSetupNode(writer, "JustBeforeEach", container, justBeforeEach)
0000000000000000000000000000000000000000;;				spec.state, spec.failure = justBeforeEach.Run()
0000000000000000000000000000000000000000;;				if spec.state != types.SpecStatePassed {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.announceSubject(writer, spec.subject)
0000000000000000000000000000000000000000;;		spec.state, spec.failure = spec.subject.Run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) announceSetupNode(writer io.Writer, nodeType string, container *containernode.ContainerNode, setupNode leafnodes.BasicNode) {
0000000000000000000000000000000000000000;;		if spec.announceProgress {
0000000000000000000000000000000000000000;;			s := fmt.Sprintf("[%s] %s\n  %s\n", nodeType, container.Text(), setupNode.CodeLocation().String())
0000000000000000000000000000000000000000;;			writer.Write([]byte(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) announceSubject(writer io.Writer, subject leafnodes.SubjectNode) {
0000000000000000000000000000000000000000;;		if spec.announceProgress {
0000000000000000000000000000000000000000;;			nodeType := ""
0000000000000000000000000000000000000000;;			switch subject.Type() {
0000000000000000000000000000000000000000;;			case types.SpecComponentTypeIt:
0000000000000000000000000000000000000000;;				nodeType = "It"
0000000000000000000000000000000000000000;;			case types.SpecComponentTypeMeasure:
0000000000000000000000000000000000000000;;				nodeType = "Measure"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s := fmt.Sprintf("[%s] %s\n  %s\n", nodeType, subject.Text(), subject.CodeLocation().String())
0000000000000000000000000000000000000000;;			writer.Write([]byte(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (spec *Spec) measurementsReport() map[string]*types.SpecMeasurement {
0000000000000000000000000000000000000000;;		if !spec.IsMeasurement() || spec.Failed() {
0000000000000000000000000000000000000000;;			return map[string]*types.SpecMeasurement{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spec.subject.(*leafnodes.MeasureNode).MeasurementsReport()
0000000000000000000000000000000000000000;;	}
