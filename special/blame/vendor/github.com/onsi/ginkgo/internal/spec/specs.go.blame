0000000000000000000000000000000000000000;;	package spec
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/spec/specs.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/spec/specs.go][vendor/github.com/onsi/ginkgo/internal/spec/specs.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Specs struct {
0000000000000000000000000000000000000000;;		specs                []*Spec
0000000000000000000000000000000000000000;;		hasProgrammaticFocus bool
0000000000000000000000000000000000000000;;		RegexScansFilePath   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSpecs(specs []*Spec) *Specs {
0000000000000000000000000000000000000000;;		return &Specs{
0000000000000000000000000000000000000000;;			specs: specs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) Specs() []*Spec {
0000000000000000000000000000000000000000;;		return e.specs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) HasProgrammaticFocus() bool {
0000000000000000000000000000000000000000;;		return e.hasProgrammaticFocus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) Shuffle(r *rand.Rand) {
0000000000000000000000000000000000000000;;		sort.Sort(e)
0000000000000000000000000000000000000000;;		permutation := r.Perm(len(e.specs))
0000000000000000000000000000000000000000;;		shuffledSpecs := make([]*Spec, len(e.specs))
0000000000000000000000000000000000000000;;		for i, j := range permutation {
0000000000000000000000000000000000000000;;			shuffledSpecs[i] = e.specs[j]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.specs = shuffledSpecs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) ApplyFocus(description string, focusString string, skipString string) {
0000000000000000000000000000000000000000;;		if focusString == "" && skipString == "" {
0000000000000000000000000000000000000000;;			e.applyProgrammaticFocus()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.applyRegExpFocusAndSkip(description, focusString, skipString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) applyProgrammaticFocus() {
0000000000000000000000000000000000000000;;		e.hasProgrammaticFocus = false
0000000000000000000000000000000000000000;;		for _, spec := range e.specs {
0000000000000000000000000000000000000000;;			if spec.Focused() && !spec.Pending() {
0000000000000000000000000000000000000000;;				e.hasProgrammaticFocus = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.hasProgrammaticFocus {
0000000000000000000000000000000000000000;;			for _, spec := range e.specs {
0000000000000000000000000000000000000000;;				if !spec.Focused() {
0000000000000000000000000000000000000000;;					spec.Skip()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toMatch returns a byte[] to be used by regex matchers.  When adding new behaviours to the matching function,
0000000000000000000000000000000000000000;;	// this is the place which we append to.
0000000000000000000000000000000000000000;;	func (e *Specs) toMatch(description string, spec *Spec) []byte {
0000000000000000000000000000000000000000;;		if e.RegexScansFilePath {
0000000000000000000000000000000000000000;;			return []byte(
0000000000000000000000000000000000000000;;				description + " " +
0000000000000000000000000000000000000000;;					spec.ConcatenatedString() + " " +
0000000000000000000000000000000000000000;;					spec.subject.CodeLocation().FileName)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return []byte(
0000000000000000000000000000000000000000;;				description + " " +
0000000000000000000000000000000000000000;;					spec.ConcatenatedString())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) applyRegExpFocusAndSkip(description string, focusString string, skipString string) {
0000000000000000000000000000000000000000;;		for _, spec := range e.specs {
0000000000000000000000000000000000000000;;			matchesFocus := true
0000000000000000000000000000000000000000;;			matchesSkip := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			toMatch := e.toMatch(description, spec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if focusString != "" {
0000000000000000000000000000000000000000;;				focusFilter := regexp.MustCompile(focusString)
0000000000000000000000000000000000000000;;				matchesFocus = focusFilter.Match([]byte(toMatch))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if skipString != "" {
0000000000000000000000000000000000000000;;				skipFilter := regexp.MustCompile(skipString)
0000000000000000000000000000000000000000;;				matchesSkip = skipFilter.Match([]byte(toMatch))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !matchesFocus || matchesSkip {
0000000000000000000000000000000000000000;;				spec.Skip()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) SkipMeasurements() {
0000000000000000000000000000000000000000;;		for _, spec := range e.specs {
0000000000000000000000000000000000000000;;			if spec.IsMeasurement() {
0000000000000000000000000000000000000000;;				spec.Skip()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sort.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) Len() int {
0000000000000000000000000000000000000000;;		return len(e.specs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return e.specs[i].ConcatenatedString() < e.specs[j].ConcatenatedString()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Specs) Swap(i, j int) {
0000000000000000000000000000000000000000;;		e.specs[i], e.specs[j] = e.specs[j], e.specs[i]
0000000000000000000000000000000000000000;;	}
