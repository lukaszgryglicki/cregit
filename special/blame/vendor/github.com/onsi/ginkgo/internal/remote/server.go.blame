0000000000000000000000000000000000000000;;	/*
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/remote/server.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/remote/server.go][vendor/github.com/onsi/ginkgo/internal/remote/server.go];	
0000000000000000000000000000000000000000;;	The remote package provides the pieces to allow Ginkgo test suites to report to remote listeners.
0000000000000000000000000000000000000000;;	This is used, primarily, to enable streaming parallel test output but has, in principal, broader applications (e.g. streaming test output to a browser).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/spec_iterator"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Server spins up on an automatically selected port and listens for communication from the forwarding reporter.
0000000000000000000000000000000000000000;;	It then forwards that communication to attached reporters.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		listener        net.Listener
0000000000000000000000000000000000000000;;		reporters       []reporters.Reporter
0000000000000000000000000000000000000000;;		alives          []func() bool
0000000000000000000000000000000000000000;;		lock            *sync.Mutex
0000000000000000000000000000000000000000;;		beforeSuiteData types.RemoteBeforeSuiteData
0000000000000000000000000000000000000000;;		parallelTotal   int
0000000000000000000000000000000000000000;;		counter         int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Create a new server, automatically selecting a port
0000000000000000000000000000000000000000;;	func NewServer(parallelTotal int) (*Server, error) {
0000000000000000000000000000000000000000;;		listener, err := net.Listen("tcp", "127.0.0.1:0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Server{
0000000000000000000000000000000000000000;;			listener:        listener,
0000000000000000000000000000000000000000;;			lock:            &sync.Mutex{},
0000000000000000000000000000000000000000;;			alives:          make([]func() bool, parallelTotal),
0000000000000000000000000000000000000000;;			beforeSuiteData: types.RemoteBeforeSuiteData{nil, types.RemoteBeforeSuiteStatePending},
0000000000000000000000000000000000000000;;			parallelTotal:   parallelTotal,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Start the server.  You don't need to `go s.Start()`, just `s.Start()`
0000000000000000000000000000000000000000;;	func (server *Server) Start() {
0000000000000000000000000000000000000000;;		httpServer := &http.Server{}
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;		httpServer.Handler = mux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//streaming endpoints
0000000000000000000000000000000000000000;;		mux.HandleFunc("/SpecSuiteWillBegin", server.specSuiteWillBegin)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/BeforeSuiteDidRun", server.beforeSuiteDidRun)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/AfterSuiteDidRun", server.afterSuiteDidRun)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/SpecWillRun", server.specWillRun)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/SpecDidComplete", server.specDidComplete)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/SpecSuiteDidEnd", server.specSuiteDidEnd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//synchronization endpoints
0000000000000000000000000000000000000000;;		mux.HandleFunc("/BeforeSuiteState", server.handleBeforeSuiteState)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/RemoteAfterSuiteData", server.handleRemoteAfterSuiteData)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/counter", server.handleCounter)
0000000000000000000000000000000000000000;;		mux.HandleFunc("/has-counter", server.handleHasCounter) //for backward compatibility
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go httpServer.Serve(server.listener)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Stop the server
0000000000000000000000000000000000000000;;	func (server *Server) Close() {
0000000000000000000000000000000000000000;;		server.listener.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//The address the server can be reached it.  Pass this into the `ForwardingReporter`.
0000000000000000000000000000000000000000;;	func (server *Server) Address() string {
0000000000000000000000000000000000000000;;		return "http://" + server.listener.Addr().String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Streaming Endpoints
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//The server will forward all received messages to Ginkgo reporters registered with `RegisterReporters`
0000000000000000000000000000000000000000;;	func (server *Server) readAll(request *http.Request) []byte {
0000000000000000000000000000000000000000;;		defer request.Body.Close()
0000000000000000000000000000000000000000;;		body, _ := ioutil.ReadAll(request.Body)
0000000000000000000000000000000000000000;;		return body
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) RegisterReporters(reporters ...reporters.Reporter) {
0000000000000000000000000000000000000000;;		server.reporters = reporters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) specSuiteWillBegin(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		body := server.readAll(request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var data struct {
0000000000000000000000000000000000000000;;			Config  config.GinkgoConfigType `json:"config"`
0000000000000000000000000000000000000000;;			Summary *types.SuiteSummary     `json:"suite-summary"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		json.Unmarshal(body, &data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reporter := range server.reporters {
0000000000000000000000000000000000000000;;			reporter.SpecSuiteWillBegin(data.Config, data.Summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) beforeSuiteDidRun(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		body := server.readAll(request)
0000000000000000000000000000000000000000;;		var setupSummary *types.SetupSummary
0000000000000000000000000000000000000000;;		json.Unmarshal(body, &setupSummary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reporter := range server.reporters {
0000000000000000000000000000000000000000;;			reporter.BeforeSuiteDidRun(setupSummary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) afterSuiteDidRun(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		body := server.readAll(request)
0000000000000000000000000000000000000000;;		var setupSummary *types.SetupSummary
0000000000000000000000000000000000000000;;		json.Unmarshal(body, &setupSummary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reporter := range server.reporters {
0000000000000000000000000000000000000000;;			reporter.AfterSuiteDidRun(setupSummary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) specWillRun(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		body := server.readAll(request)
0000000000000000000000000000000000000000;;		var specSummary *types.SpecSummary
0000000000000000000000000000000000000000;;		json.Unmarshal(body, &specSummary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reporter := range server.reporters {
0000000000000000000000000000000000000000;;			reporter.SpecWillRun(specSummary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) specDidComplete(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		body := server.readAll(request)
0000000000000000000000000000000000000000;;		var specSummary *types.SpecSummary
0000000000000000000000000000000000000000;;		json.Unmarshal(body, &specSummary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reporter := range server.reporters {
0000000000000000000000000000000000000000;;			reporter.SpecDidComplete(specSummary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) specSuiteDidEnd(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		body := server.readAll(request)
0000000000000000000000000000000000000000;;		var suiteSummary *types.SuiteSummary
0000000000000000000000000000000000000000;;		json.Unmarshal(body, &suiteSummary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reporter := range server.reporters {
0000000000000000000000000000000000000000;;			reporter.SpecSuiteDidEnd(suiteSummary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Synchronization Endpoints
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) RegisterAlive(node int, alive func() bool) {
0000000000000000000000000000000000000000;;		server.lock.Lock()
0000000000000000000000000000000000000000;;		defer server.lock.Unlock()
0000000000000000000000000000000000000000;;		server.alives[node-1] = alive
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) nodeIsAlive(node int) bool {
0000000000000000000000000000000000000000;;		server.lock.Lock()
0000000000000000000000000000000000000000;;		defer server.lock.Unlock()
0000000000000000000000000000000000000000;;		alive := server.alives[node-1]
0000000000000000000000000000000000000000;;		if alive == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return alive()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) handleBeforeSuiteState(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		if request.Method == "POST" {
0000000000000000000000000000000000000000;;			dec := json.NewDecoder(request.Body)
0000000000000000000000000000000000000000;;			dec.Decode(&(server.beforeSuiteData))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			beforeSuiteData := server.beforeSuiteData
0000000000000000000000000000000000000000;;			if beforeSuiteData.State == types.RemoteBeforeSuiteStatePending && !server.nodeIsAlive(1) {
0000000000000000000000000000000000000000;;				beforeSuiteData.State = types.RemoteBeforeSuiteStateDisappeared
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc := json.NewEncoder(writer)
0000000000000000000000000000000000000000;;			enc.Encode(beforeSuiteData)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) handleRemoteAfterSuiteData(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		afterSuiteData := types.RemoteAfterSuiteData{
0000000000000000000000000000000000000000;;			CanRun: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 2; i <= server.parallelTotal; i++ {
0000000000000000000000000000000000000000;;			afterSuiteData.CanRun = afterSuiteData.CanRun && !server.nodeIsAlive(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enc := json.NewEncoder(writer)
0000000000000000000000000000000000000000;;		enc.Encode(afterSuiteData)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) handleCounter(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		c := spec_iterator.Counter{}
0000000000000000000000000000000000000000;;		server.lock.Lock()
0000000000000000000000000000000000000000;;		c.Index = server.counter
0000000000000000000000000000000000000000;;		server.counter = server.counter + 1
0000000000000000000000000000000000000000;;		server.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		json.NewEncoder(writer).Encode(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (server *Server) handleHasCounter(writer http.ResponseWriter, request *http.Request) {
0000000000000000000000000000000000000000;;		writer.Write([]byte(""))
0000000000000000000000000000000000000000;;	}
