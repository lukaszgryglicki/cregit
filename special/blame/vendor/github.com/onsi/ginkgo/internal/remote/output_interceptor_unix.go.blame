0000000000000000000000000000000000000000;;	// +build freebsd openbsd netbsd dragonfly darwin linux solaris
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/remote/output_interceptor_unix.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/remote/output_interceptor_unix.go][vendor/github.com/onsi/ginkgo/internal/remote/output_interceptor_unix.go];	
0000000000000000000000000000000000000000;;	package remote
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOutputInterceptor() OutputInterceptor {
0000000000000000000000000000000000000000;;		return &outputInterceptor{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type outputInterceptor struct {
0000000000000000000000000000000000000000;;		redirectFile *os.File
0000000000000000000000000000000000000000;;		intercepting bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (interceptor *outputInterceptor) StartInterceptingOutput() error {
0000000000000000000000000000000000000000;;		if interceptor.intercepting {
0000000000000000000000000000000000000000;;			return errors.New("Already intercepting output!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		interceptor.intercepting = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		interceptor.redirectFile, err = ioutil.TempFile("", "ginkgo-output")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call a function in ./syscall_dup_*.go
0000000000000000000000000000000000000000;;		// If building for everything other than linux_arm64,
0000000000000000000000000000000000000000;;		// use a "normal" syscall.Dup2(oldfd, newfd) call. If building for linux_arm64 (which doesn't have syscall.Dup2)
0000000000000000000000000000000000000000;;		// call syscall.Dup3(oldfd, newfd, 0). They are nearly identical, see: http://linux.die.net/man/2/dup3
0000000000000000000000000000000000000000;;		syscallDup(int(interceptor.redirectFile.Fd()), 1)
0000000000000000000000000000000000000000;;		syscallDup(int(interceptor.redirectFile.Fd()), 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (interceptor *outputInterceptor) StopInterceptingAndReturnOutput() (string, error) {
0000000000000000000000000000000000000000;;		if !interceptor.intercepting {
0000000000000000000000000000000000000000;;			return "", errors.New("Not intercepting output!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		interceptor.redirectFile.Close()
0000000000000000000000000000000000000000;;		output, err := ioutil.ReadFile(interceptor.redirectFile.Name())
0000000000000000000000000000000000000000;;		os.Remove(interceptor.redirectFile.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		interceptor.intercepting = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(output), err
0000000000000000000000000000000000000000;;	}
