0000000000000000000000000000000000000000;;	package suite
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/suite/suite.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/suite/suite.go][vendor/github.com/onsi/ginkgo/internal/suite/suite.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/spec_iterator"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/containernode"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/failer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/leafnodes"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/spec"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/specrunner"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/writer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ginkgoTestingT interface {
0000000000000000000000000000000000000000;;		Fail()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Suite struct {
0000000000000000000000000000000000000000;;		topLevelContainer *containernode.ContainerNode
0000000000000000000000000000000000000000;;		currentContainer  *containernode.ContainerNode
0000000000000000000000000000000000000000;;		containerIndex    int
0000000000000000000000000000000000000000;;		beforeSuiteNode   leafnodes.SuiteNode
0000000000000000000000000000000000000000;;		afterSuiteNode    leafnodes.SuiteNode
0000000000000000000000000000000000000000;;		runner            *specrunner.SpecRunner
0000000000000000000000000000000000000000;;		failer            *failer.Failer
0000000000000000000000000000000000000000;;		running           bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(failer *failer.Failer) *Suite {
0000000000000000000000000000000000000000;;		topLevelContainer := containernode.New("[Top Level]", types.FlagTypeNone, types.CodeLocation{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Suite{
0000000000000000000000000000000000000000;;			topLevelContainer: topLevelContainer,
0000000000000000000000000000000000000000;;			currentContainer:  topLevelContainer,
0000000000000000000000000000000000000000;;			failer:            failer,
0000000000000000000000000000000000000000;;			containerIndex:    1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) Run(t ginkgoTestingT, description string, reporters []reporters.Reporter, writer writer.WriterInterface, config config.GinkgoConfigType) (bool, bool) {
0000000000000000000000000000000000000000;;		if config.ParallelTotal < 1 {
0000000000000000000000000000000000000000;;			panic("ginkgo.parallel.total must be >= 1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.ParallelNode > config.ParallelTotal || config.ParallelNode < 1 {
0000000000000000000000000000000000000000;;			panic("ginkgo.parallel.node is one-indexed and must be <= ginkgo.parallel.total")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := rand.New(rand.NewSource(config.RandomSeed))
0000000000000000000000000000000000000000;;		suite.topLevelContainer.Shuffle(r)
0000000000000000000000000000000000000000;;		iterator, hasProgrammaticFocus := suite.generateSpecsIterator(description, config)
0000000000000000000000000000000000000000;;		suite.runner = specrunner.New(description, suite.beforeSuiteNode, iterator, suite.afterSuiteNode, reporters, writer, config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		suite.running = true
0000000000000000000000000000000000000000;;		success := suite.runner.Run()
0000000000000000000000000000000000000000;;		if !success {
0000000000000000000000000000000000000000;;			t.Fail()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return success, hasProgrammaticFocus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) generateSpecsIterator(description string, config config.GinkgoConfigType) (spec_iterator.SpecIterator, bool) {
0000000000000000000000000000000000000000;;		specsSlice := []*spec.Spec{}
0000000000000000000000000000000000000000;;		suite.topLevelContainer.BackPropagateProgrammaticFocus()
0000000000000000000000000000000000000000;;		for _, collatedNodes := range suite.topLevelContainer.Collate() {
0000000000000000000000000000000000000000;;			specsSlice = append(specsSlice, spec.New(collatedNodes.Subject, collatedNodes.Containers, config.EmitSpecProgress))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		specs := spec.NewSpecs(specsSlice)
0000000000000000000000000000000000000000;;		specs.RegexScansFilePath = config.RegexScansFilePath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.RandomizeAllSpecs {
0000000000000000000000000000000000000000;;			specs.Shuffle(rand.New(rand.NewSource(config.RandomSeed)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		specs.ApplyFocus(description, config.FocusString, config.SkipString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.SkipMeasurements {
0000000000000000000000000000000000000000;;			specs.SkipMeasurements()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var iterator spec_iterator.SpecIterator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.ParallelTotal > 1 {
0000000000000000000000000000000000000000;;			iterator = spec_iterator.NewParallelIterator(specs.Specs(), config.SyncHost)
0000000000000000000000000000000000000000;;			resp, err := http.Get(config.SyncHost + "/has-counter")
0000000000000000000000000000000000000000;;			if err != nil || resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				iterator = spec_iterator.NewShardedParallelIterator(specs.Specs(), config.ParallelTotal, config.ParallelNode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			iterator = spec_iterator.NewSerialIterator(specs.Specs())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return iterator, specs.HasProgrammaticFocus()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) CurrentRunningSpecSummary() (*types.SpecSummary, bool) {
0000000000000000000000000000000000000000;;		return suite.runner.CurrentSpecSummary()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) SetBeforeSuiteNode(body interface{}, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.beforeSuiteNode != nil {
0000000000000000000000000000000000000000;;			panic("You may only call BeforeSuite once!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.beforeSuiteNode = leafnodes.NewBeforeSuiteNode(body, codeLocation, timeout, suite.failer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) SetAfterSuiteNode(body interface{}, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.afterSuiteNode != nil {
0000000000000000000000000000000000000000;;			panic("You may only call AfterSuite once!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.afterSuiteNode = leafnodes.NewAfterSuiteNode(body, codeLocation, timeout, suite.failer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) SetSynchronizedBeforeSuiteNode(bodyA interface{}, bodyB interface{}, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.beforeSuiteNode != nil {
0000000000000000000000000000000000000000;;			panic("You may only call BeforeSuite once!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.beforeSuiteNode = leafnodes.NewSynchronizedBeforeSuiteNode(bodyA, bodyB, codeLocation, timeout, suite.failer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) SetSynchronizedAfterSuiteNode(bodyA interface{}, bodyB interface{}, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.afterSuiteNode != nil {
0000000000000000000000000000000000000000;;			panic("You may only call AfterSuite once!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.afterSuiteNode = leafnodes.NewSynchronizedAfterSuiteNode(bodyA, bodyB, codeLocation, timeout, suite.failer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) PushContainerNode(text string, body func(), flag types.FlagType, codeLocation types.CodeLocation) {
0000000000000000000000000000000000000000;;		container := containernode.New(text, flag, codeLocation)
0000000000000000000000000000000000000000;;		suite.currentContainer.PushContainerNode(container)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		previousContainer := suite.currentContainer
0000000000000000000000000000000000000000;;		suite.currentContainer = container
0000000000000000000000000000000000000000;;		suite.containerIndex++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		suite.containerIndex--
0000000000000000000000000000000000000000;;		suite.currentContainer = previousContainer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) PushItNode(text string, body interface{}, flag types.FlagType, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.running {
0000000000000000000000000000000000000000;;			suite.failer.Fail("You may only call It from within a Describe or Context", codeLocation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.currentContainer.PushSubjectNode(leafnodes.NewItNode(text, body, flag, codeLocation, timeout, suite.failer, suite.containerIndex))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) PushMeasureNode(text string, body interface{}, flag types.FlagType, codeLocation types.CodeLocation, samples int) {
0000000000000000000000000000000000000000;;		if suite.running {
0000000000000000000000000000000000000000;;			suite.failer.Fail("You may only call Measure from within a Describe or Context", codeLocation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.currentContainer.PushSubjectNode(leafnodes.NewMeasureNode(text, body, flag, codeLocation, samples, suite.failer, suite.containerIndex))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) PushBeforeEachNode(body interface{}, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.running {
0000000000000000000000000000000000000000;;			suite.failer.Fail("You may only call BeforeEach from within a Describe or Context", codeLocation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.currentContainer.PushSetupNode(leafnodes.NewBeforeEachNode(body, codeLocation, timeout, suite.failer, suite.containerIndex))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) PushJustBeforeEachNode(body interface{}, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.running {
0000000000000000000000000000000000000000;;			suite.failer.Fail("You may only call JustBeforeEach from within a Describe or Context", codeLocation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.currentContainer.PushSetupNode(leafnodes.NewJustBeforeEachNode(body, codeLocation, timeout, suite.failer, suite.containerIndex))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (suite *Suite) PushAfterEachNode(body interface{}, codeLocation types.CodeLocation, timeout time.Duration) {
0000000000000000000000000000000000000000;;		if suite.running {
0000000000000000000000000000000000000000;;			suite.failer.Fail("You may only call AfterEach from within a Describe or Context", codeLocation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		suite.currentContainer.PushSetupNode(leafnodes.NewAfterEachNode(body, codeLocation, timeout, suite.failer, suite.containerIndex))
0000000000000000000000000000000000000000;;	}
