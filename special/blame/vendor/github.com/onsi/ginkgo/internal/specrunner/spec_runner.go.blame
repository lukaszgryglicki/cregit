0000000000000000000000000000000000000000;;	package specrunner
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/specrunner/spec_runner.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/specrunner/spec_runner.go][vendor/github.com/onsi/ginkgo/internal/specrunner/spec_runner.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/signal"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/spec_iterator"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/config"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/leafnodes"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/spec"
0000000000000000000000000000000000000000;;		Writer "github.com/onsi/ginkgo/internal/writer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/reporters"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SpecRunner struct {
0000000000000000000000000000000000000000;;		description     string
0000000000000000000000000000000000000000;;		beforeSuiteNode leafnodes.SuiteNode
0000000000000000000000000000000000000000;;		iterator        spec_iterator.SpecIterator
0000000000000000000000000000000000000000;;		afterSuiteNode  leafnodes.SuiteNode
0000000000000000000000000000000000000000;;		reporters       []reporters.Reporter
0000000000000000000000000000000000000000;;		startTime       time.Time
0000000000000000000000000000000000000000;;		suiteID         string
0000000000000000000000000000000000000000;;		runningSpec     *spec.Spec
0000000000000000000000000000000000000000;;		writer          Writer.WriterInterface
0000000000000000000000000000000000000000;;		config          config.GinkgoConfigType
0000000000000000000000000000000000000000;;		interrupted     bool
0000000000000000000000000000000000000000;;		processedSpecs  []*spec.Spec
0000000000000000000000000000000000000000;;		lock            *sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(description string, beforeSuiteNode leafnodes.SuiteNode, iterator spec_iterator.SpecIterator, afterSuiteNode leafnodes.SuiteNode, reporters []reporters.Reporter, writer Writer.WriterInterface, config config.GinkgoConfigType) *SpecRunner {
0000000000000000000000000000000000000000;;		return &SpecRunner{
0000000000000000000000000000000000000000;;			description:     description,
0000000000000000000000000000000000000000;;			beforeSuiteNode: beforeSuiteNode,
0000000000000000000000000000000000000000;;			iterator:        iterator,
0000000000000000000000000000000000000000;;			afterSuiteNode:  afterSuiteNode,
0000000000000000000000000000000000000000;;			reporters:       reporters,
0000000000000000000000000000000000000000;;			writer:          writer,
0000000000000000000000000000000000000000;;			config:          config,
0000000000000000000000000000000000000000;;			suiteID:         randomID(),
0000000000000000000000000000000000000000;;			lock:            &sync.Mutex{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) Run() bool {
0000000000000000000000000000000000000000;;		if runner.config.DryRun {
0000000000000000000000000000000000000000;;			runner.performDryRun()
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.reportSuiteWillBegin()
0000000000000000000000000000000000000000;;		go runner.registerForInterrupts()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		suitePassed := runner.runBeforeSuite()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if suitePassed {
0000000000000000000000000000000000000000;;			suitePassed = runner.runSpecs()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.blockForeverIfInterrupted()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		suitePassed = runner.runAfterSuite() && suitePassed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.reportSuiteDidEnd(suitePassed)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return suitePassed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) performDryRun() {
0000000000000000000000000000000000000000;;		runner.reportSuiteWillBegin()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if runner.beforeSuiteNode != nil {
0000000000000000000000000000000000000000;;			summary := runner.beforeSuiteNode.Summary()
0000000000000000000000000000000000000000;;			summary.State = types.SpecStatePassed
0000000000000000000000000000000000000000;;			runner.reportBeforeSuite(summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			spec, err := runner.iterator.Next()
0000000000000000000000000000000000000000;;			if err == spec_iterator.ErrClosed {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Println("failed to iterate over tests:\n" + err.Error())
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runner.processedSpecs = append(runner.processedSpecs, spec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			summary := spec.Summary(runner.suiteID)
0000000000000000000000000000000000000000;;			runner.reportSpecWillRun(summary)
0000000000000000000000000000000000000000;;			if summary.State == types.SpecStateInvalid {
0000000000000000000000000000000000000000;;				summary.State = types.SpecStatePassed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			runner.reportSpecDidComplete(summary, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if runner.afterSuiteNode != nil {
0000000000000000000000000000000000000000;;			summary := runner.afterSuiteNode.Summary()
0000000000000000000000000000000000000000;;			summary.State = types.SpecStatePassed
0000000000000000000000000000000000000000;;			runner.reportAfterSuite(summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.reportSuiteDidEnd(true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) runBeforeSuite() bool {
0000000000000000000000000000000000000000;;		if runner.beforeSuiteNode == nil || runner.wasInterrupted() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.writer.Truncate()
0000000000000000000000000000000000000000;;		conf := runner.config
0000000000000000000000000000000000000000;;		passed := runner.beforeSuiteNode.Run(conf.ParallelNode, conf.ParallelTotal, conf.SyncHost)
0000000000000000000000000000000000000000;;		if !passed {
0000000000000000000000000000000000000000;;			runner.writer.DumpOut()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner.reportBeforeSuite(runner.beforeSuiteNode.Summary())
0000000000000000000000000000000000000000;;		return passed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) runAfterSuite() bool {
0000000000000000000000000000000000000000;;		if runner.afterSuiteNode == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.writer.Truncate()
0000000000000000000000000000000000000000;;		conf := runner.config
0000000000000000000000000000000000000000;;		passed := runner.afterSuiteNode.Run(conf.ParallelNode, conf.ParallelTotal, conf.SyncHost)
0000000000000000000000000000000000000000;;		if !passed {
0000000000000000000000000000000000000000;;			runner.writer.DumpOut()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner.reportAfterSuite(runner.afterSuiteNode.Summary())
0000000000000000000000000000000000000000;;		return passed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) runSpecs() bool {
0000000000000000000000000000000000000000;;		suiteFailed := false
0000000000000000000000000000000000000000;;		skipRemainingSpecs := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			spec, err := runner.iterator.Next()
0000000000000000000000000000000000000000;;			if err == spec_iterator.ErrClosed {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Println("failed to iterate over tests:\n" + err.Error())
0000000000000000000000000000000000000000;;				suiteFailed = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runner.processedSpecs = append(runner.processedSpecs, spec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if runner.wasInterrupted() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if skipRemainingSpecs {
0000000000000000000000000000000000000000;;				spec.Skip()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !spec.Skipped() && !spec.Pending() {
0000000000000000000000000000000000000000;;				if passed := runner.runSpec(spec); !passed {
0000000000000000000000000000000000000000;;					suiteFailed = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if spec.Pending() && runner.config.FailOnPending {
0000000000000000000000000000000000000000;;				runner.reportSpecWillRun(spec.Summary(runner.suiteID))
0000000000000000000000000000000000000000;;				suiteFailed = true
0000000000000000000000000000000000000000;;				runner.reportSpecDidComplete(spec.Summary(runner.suiteID), spec.Failed())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				runner.reportSpecWillRun(spec.Summary(runner.suiteID))
0000000000000000000000000000000000000000;;				runner.reportSpecDidComplete(spec.Summary(runner.suiteID), spec.Failed())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if spec.Failed() && runner.config.FailFast {
0000000000000000000000000000000000000000;;				skipRemainingSpecs = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return !suiteFailed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) runSpec(spec *spec.Spec) (passed bool) {
0000000000000000000000000000000000000000;;		maxAttempts := 1
0000000000000000000000000000000000000000;;		if runner.config.FlakeAttempts > 0 {
0000000000000000000000000000000000000000;;			// uninitialized configs count as 1
0000000000000000000000000000000000000000;;			maxAttempts = runner.config.FlakeAttempts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < maxAttempts; i++ {
0000000000000000000000000000000000000000;;			runner.reportSpecWillRun(spec.Summary(runner.suiteID))
0000000000000000000000000000000000000000;;			runner.runningSpec = spec
0000000000000000000000000000000000000000;;			spec.Run(runner.writer)
0000000000000000000000000000000000000000;;			runner.runningSpec = nil
0000000000000000000000000000000000000000;;			runner.reportSpecDidComplete(spec.Summary(runner.suiteID), spec.Failed())
0000000000000000000000000000000000000000;;			if !spec.Failed() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) CurrentSpecSummary() (*types.SpecSummary, bool) {
0000000000000000000000000000000000000000;;		if runner.runningSpec == nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return runner.runningSpec.Summary(runner.suiteID), true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) registerForInterrupts() {
0000000000000000000000000000000000000000;;		c := make(chan os.Signal, 1)
0000000000000000000000000000000000000000;;		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c
0000000000000000000000000000000000000000;;		signal.Stop(c)
0000000000000000000000000000000000000000;;		runner.markInterrupted()
0000000000000000000000000000000000000000;;		go runner.registerForHardInterrupts()
0000000000000000000000000000000000000000;;		runner.writer.DumpOutWithHeader(`
0000000000000000000000000000000000000000;;	Received interrupt.  Emitting contents of GinkgoWriter...
0000000000000000000000000000000000000000;;	---------------------------------------------------------
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		if runner.afterSuiteNode != nil {
0000000000000000000000000000000000000000;;			fmt.Fprint(os.Stderr, `
0000000000000000000000000000000000000000;;	---------------------------------------------------------
0000000000000000000000000000000000000000;;	Received interrupt.  Running AfterSuite...
0000000000000000000000000000000000000000;;	^C again to terminate immediately
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;			runner.runAfterSuite()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runner.reportSuiteDidEnd(false)
0000000000000000000000000000000000000000;;		os.Exit(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) registerForHardInterrupts() {
0000000000000000000000000000000000000000;;		c := make(chan os.Signal, 1)
0000000000000000000000000000000000000000;;		signal.Notify(c, os.Interrupt, syscall.SIGTERM)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c
0000000000000000000000000000000000000000;;		fmt.Fprintln(os.Stderr, "\nReceived second interrupt.  Shutting down.")
0000000000000000000000000000000000000000;;		os.Exit(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) blockForeverIfInterrupted() {
0000000000000000000000000000000000000000;;		runner.lock.Lock()
0000000000000000000000000000000000000000;;		interrupted := runner.interrupted
0000000000000000000000000000000000000000;;		runner.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if interrupted {
0000000000000000000000000000000000000000;;			select {}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) markInterrupted() {
0000000000000000000000000000000000000000;;		runner.lock.Lock()
0000000000000000000000000000000000000000;;		defer runner.lock.Unlock()
0000000000000000000000000000000000000000;;		runner.interrupted = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) wasInterrupted() bool {
0000000000000000000000000000000000000000;;		runner.lock.Lock()
0000000000000000000000000000000000000000;;		defer runner.lock.Unlock()
0000000000000000000000000000000000000000;;		return runner.interrupted
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) reportSuiteWillBegin() {
0000000000000000000000000000000000000000;;		runner.startTime = time.Now()
0000000000000000000000000000000000000000;;		summary := runner.suiteWillBeginSummary()
0000000000000000000000000000000000000000;;		for _, reporter := range runner.reporters {
0000000000000000000000000000000000000000;;			reporter.SpecSuiteWillBegin(runner.config, summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) reportBeforeSuite(summary *types.SetupSummary) {
0000000000000000000000000000000000000000;;		for _, reporter := range runner.reporters {
0000000000000000000000000000000000000000;;			reporter.BeforeSuiteDidRun(summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) reportAfterSuite(summary *types.SetupSummary) {
0000000000000000000000000000000000000000;;		for _, reporter := range runner.reporters {
0000000000000000000000000000000000000000;;			reporter.AfterSuiteDidRun(summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) reportSpecWillRun(summary *types.SpecSummary) {
0000000000000000000000000000000000000000;;		runner.writer.Truncate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, reporter := range runner.reporters {
0000000000000000000000000000000000000000;;			reporter.SpecWillRun(summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) reportSpecDidComplete(summary *types.SpecSummary, failed bool) {
0000000000000000000000000000000000000000;;		if failed && len(summary.CapturedOutput) == 0 {
0000000000000000000000000000000000000000;;			summary.CapturedOutput = string(runner.writer.Bytes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := len(runner.reporters) - 1; i >= 1; i-- {
0000000000000000000000000000000000000000;;			runner.reporters[i].SpecDidComplete(summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if failed {
0000000000000000000000000000000000000000;;			runner.writer.DumpOut()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner.reporters[0].SpecDidComplete(summary)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) reportSuiteDidEnd(success bool) {
0000000000000000000000000000000000000000;;		summary := runner.suiteDidEndSummary(success)
0000000000000000000000000000000000000000;;		summary.RunTime = time.Since(runner.startTime)
0000000000000000000000000000000000000000;;		for _, reporter := range runner.reporters {
0000000000000000000000000000000000000000;;			reporter.SpecSuiteDidEnd(summary)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) countSpecsThatRanSatisfying(filter func(ex *spec.Spec) bool) (count int) {
0000000000000000000000000000000000000000;;		count = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, spec := range runner.processedSpecs {
0000000000000000000000000000000000000000;;			if filter(spec) {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return count
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) suiteDidEndSummary(success bool) *types.SuiteSummary {
0000000000000000000000000000000000000000;;		numberOfSpecsThatWillBeRun := runner.countSpecsThatRanSatisfying(func(ex *spec.Spec) bool {
0000000000000000000000000000000000000000;;			return !ex.Skipped() && !ex.Pending()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numberOfPendingSpecs := runner.countSpecsThatRanSatisfying(func(ex *spec.Spec) bool {
0000000000000000000000000000000000000000;;			return ex.Pending()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numberOfSkippedSpecs := runner.countSpecsThatRanSatisfying(func(ex *spec.Spec) bool {
0000000000000000000000000000000000000000;;			return ex.Skipped()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numberOfPassedSpecs := runner.countSpecsThatRanSatisfying(func(ex *spec.Spec) bool {
0000000000000000000000000000000000000000;;			return ex.Passed()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numberOfFlakedSpecs := runner.countSpecsThatRanSatisfying(func(ex *spec.Spec) bool {
0000000000000000000000000000000000000000;;			return ex.Flaked()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numberOfFailedSpecs := runner.countSpecsThatRanSatisfying(func(ex *spec.Spec) bool {
0000000000000000000000000000000000000000;;			return ex.Failed()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if runner.beforeSuiteNode != nil && !runner.beforeSuiteNode.Passed() && !runner.config.DryRun {
0000000000000000000000000000000000000000;;			var known bool
0000000000000000000000000000000000000000;;			numberOfSpecsThatWillBeRun, known = runner.iterator.NumberOfSpecsThatWillBeRunIfKnown()
0000000000000000000000000000000000000000;;			if !known {
0000000000000000000000000000000000000000;;				numberOfSpecsThatWillBeRun = runner.iterator.NumberOfSpecsPriorToIteration()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			numberOfFailedSpecs = numberOfSpecsThatWillBeRun
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &types.SuiteSummary{
0000000000000000000000000000000000000000;;			SuiteDescription: runner.description,
0000000000000000000000000000000000000000;;			SuiteSucceeded:   success,
0000000000000000000000000000000000000000;;			SuiteID:          runner.suiteID,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			NumberOfSpecsBeforeParallelization: runner.iterator.NumberOfSpecsPriorToIteration(),
0000000000000000000000000000000000000000;;			NumberOfTotalSpecs:                 len(runner.processedSpecs),
0000000000000000000000000000000000000000;;			NumberOfSpecsThatWillBeRun:         numberOfSpecsThatWillBeRun,
0000000000000000000000000000000000000000;;			NumberOfPendingSpecs:               numberOfPendingSpecs,
0000000000000000000000000000000000000000;;			NumberOfSkippedSpecs:               numberOfSkippedSpecs,
0000000000000000000000000000000000000000;;			NumberOfPassedSpecs:                numberOfPassedSpecs,
0000000000000000000000000000000000000000;;			NumberOfFailedSpecs:                numberOfFailedSpecs,
0000000000000000000000000000000000000000;;			NumberOfFlakedSpecs:                numberOfFlakedSpecs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (runner *SpecRunner) suiteWillBeginSummary() *types.SuiteSummary {
0000000000000000000000000000000000000000;;		numTotal, known := runner.iterator.NumberOfSpecsToProcessIfKnown()
0000000000000000000000000000000000000000;;		if !known {
0000000000000000000000000000000000000000;;			numTotal = -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numToRun, known := runner.iterator.NumberOfSpecsThatWillBeRunIfKnown()
0000000000000000000000000000000000000000;;		if !known {
0000000000000000000000000000000000000000;;			numToRun = -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &types.SuiteSummary{
0000000000000000000000000000000000000000;;			SuiteDescription: runner.description,
0000000000000000000000000000000000000000;;			SuiteID:          runner.suiteID,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			NumberOfSpecsBeforeParallelization: runner.iterator.NumberOfSpecsPriorToIteration(),
0000000000000000000000000000000000000000;;			NumberOfTotalSpecs:                 numTotal,
0000000000000000000000000000000000000000;;			NumberOfSpecsThatWillBeRun:         numToRun,
0000000000000000000000000000000000000000;;			NumberOfPendingSpecs:               -1,
0000000000000000000000000000000000000000;;			NumberOfSkippedSpecs:               -1,
0000000000000000000000000000000000000000;;			NumberOfPassedSpecs:                -1,
0000000000000000000000000000000000000000;;			NumberOfFailedSpecs:                -1,
0000000000000000000000000000000000000000;;			NumberOfFlakedSpecs:                -1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
