0000000000000000000000000000000000000000;;	package leafnodes
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/synchronized_after_suite_node.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/synchronized_after_suite_node.go][vendor/github.com/onsi/ginkgo/internal/leafnodes/synchronized_after_suite_node.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/failer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type synchronizedAfterSuiteNode struct {
0000000000000000000000000000000000000000;;		runnerA *runner
0000000000000000000000000000000000000000;;		runnerB *runner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outcome types.SpecState
0000000000000000000000000000000000000000;;		failure types.SpecFailure
0000000000000000000000000000000000000000;;		runTime time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSynchronizedAfterSuiteNode(bodyA interface{}, bodyB interface{}, codeLocation types.CodeLocation, timeout time.Duration, failer *failer.Failer) SuiteNode {
0000000000000000000000000000000000000000;;		return &synchronizedAfterSuiteNode{
0000000000000000000000000000000000000000;;			runnerA: newRunner(bodyA, codeLocation, timeout, failer, types.SpecComponentTypeAfterSuite, 0),
0000000000000000000000000000000000000000;;			runnerB: newRunner(bodyB, codeLocation, timeout, failer, types.SpecComponentTypeAfterSuite, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedAfterSuiteNode) Run(parallelNode int, parallelTotal int, syncHost string) bool {
0000000000000000000000000000000000000000;;		node.outcome, node.failure = node.runnerA.run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parallelNode == 1 {
0000000000000000000000000000000000000000;;			if parallelTotal > 1 {
0000000000000000000000000000000000000000;;				node.waitUntilOtherNodesAreDone(syncHost)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			outcome, failure := node.runnerB.run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if node.outcome == types.SpecStatePassed {
0000000000000000000000000000000000000000;;				node.outcome, node.failure = outcome, failure
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return node.outcome == types.SpecStatePassed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedAfterSuiteNode) Passed() bool {
0000000000000000000000000000000000000000;;		return node.outcome == types.SpecStatePassed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedAfterSuiteNode) Summary() *types.SetupSummary {
0000000000000000000000000000000000000000;;		return &types.SetupSummary{
0000000000000000000000000000000000000000;;			ComponentType: node.runnerA.nodeType,
0000000000000000000000000000000000000000;;			CodeLocation:  node.runnerA.codeLocation,
0000000000000000000000000000000000000000;;			State:         node.outcome,
0000000000000000000000000000000000000000;;			RunTime:       node.runTime,
0000000000000000000000000000000000000000;;			Failure:       node.failure,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedAfterSuiteNode) waitUntilOtherNodesAreDone(syncHost string) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if node.canRun(syncHost) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedAfterSuiteNode) canRun(syncHost string) bool {
0000000000000000000000000000000000000000;;		resp, err := http.Get(syncHost + "/RemoteAfterSuiteData")
0000000000000000000000000000000000000000;;		if err != nil || resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		afterSuiteData := types.RemoteAfterSuiteData{}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(body, &afterSuiteData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return afterSuiteData.CanRun
0000000000000000000000000000000000000000;;	}
