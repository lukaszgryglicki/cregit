0000000000000000000000000000000000000000;;	package leafnodes
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/benchmarker.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/benchmarker.go][vendor/github.com/onsi/ginkgo/internal/leafnodes/benchmarker.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type benchmarker struct {
0000000000000000000000000000000000000000;;		mu           sync.Mutex
0000000000000000000000000000000000000000;;		measurements map[string]*types.SpecMeasurement
0000000000000000000000000000000000000000;;		orderCounter int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBenchmarker() *benchmarker {
0000000000000000000000000000000000000000;;		return &benchmarker{
0000000000000000000000000000000000000000;;			measurements: make(map[string]*types.SpecMeasurement, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *benchmarker) Time(name string, body func(), info ...interface{}) (elapsedTime time.Duration) {
0000000000000000000000000000000000000000;;		t := time.Now()
0000000000000000000000000000000000000000;;		body()
0000000000000000000000000000000000000000;;		elapsedTime = time.Since(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		measurement := b.getMeasurement(name, "Fastest Time", "Slowest Time", "Average Time", "s", 3, info...)
0000000000000000000000000000000000000000;;		measurement.Results = append(measurement.Results, elapsedTime.Seconds())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *benchmarker) RecordValue(name string, value float64, info ...interface{}) {
0000000000000000000000000000000000000000;;		measurement := b.getMeasurement(name, "Smallest", " Largest", " Average", "", 3, info...)
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		measurement.Results = append(measurement.Results, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *benchmarker) RecordValueWithPrecision(name string, value float64, units string, precision int, info ...interface{}) {
0000000000000000000000000000000000000000;;		measurement := b.getMeasurement(name, "Smallest", " Largest", " Average", units, precision, info...)
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		measurement.Results = append(measurement.Results, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *benchmarker) getMeasurement(name string, smallestLabel string, largestLabel string, averageLabel string, units string, precision int, info ...interface{}) *types.SpecMeasurement {
0000000000000000000000000000000000000000;;		measurement, ok := b.measurements[name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			var computedInfo interface{}
0000000000000000000000000000000000000000;;			computedInfo = nil
0000000000000000000000000000000000000000;;			if len(info) > 0 {
0000000000000000000000000000000000000000;;				computedInfo = info[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			measurement = &types.SpecMeasurement{
0000000000000000000000000000000000000000;;				Name:          name,
0000000000000000000000000000000000000000;;				Info:          computedInfo,
0000000000000000000000000000000000000000;;				Order:         b.orderCounter,
0000000000000000000000000000000000000000;;				SmallestLabel: smallestLabel,
0000000000000000000000000000000000000000;;				LargestLabel:  largestLabel,
0000000000000000000000000000000000000000;;				AverageLabel:  averageLabel,
0000000000000000000000000000000000000000;;				Units:         units,
0000000000000000000000000000000000000000;;				Precision:     precision,
0000000000000000000000000000000000000000;;				Results:       make([]float64, 0),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.measurements[name] = measurement
0000000000000000000000000000000000000000;;			b.orderCounter++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return measurement
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *benchmarker) measurementsReport() map[string]*types.SpecMeasurement {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		for _, measurement := range b.measurements {
0000000000000000000000000000000000000000;;			measurement.Smallest = math.MaxFloat64
0000000000000000000000000000000000000000;;			measurement.Largest = -math.MaxFloat64
0000000000000000000000000000000000000000;;			sum := float64(0)
0000000000000000000000000000000000000000;;			sumOfSquares := float64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, result := range measurement.Results {
0000000000000000000000000000000000000000;;				if result > measurement.Largest {
0000000000000000000000000000000000000000;;					measurement.Largest = result
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if result < measurement.Smallest {
0000000000000000000000000000000000000000;;					measurement.Smallest = result
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sum += result
0000000000000000000000000000000000000000;;				sumOfSquares += result * result
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n := float64(len(measurement.Results))
0000000000000000000000000000000000000000;;			measurement.Average = sum / n
0000000000000000000000000000000000000000;;			measurement.StdDeviation = math.Sqrt(sumOfSquares/n - (sum/n)*(sum/n))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b.measurements
0000000000000000000000000000000000000000;;	}
