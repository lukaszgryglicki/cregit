0000000000000000000000000000000000000000;;	package leafnodes
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/synchronized_before_suite_node.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/synchronized_before_suite_node.go][vendor/github.com/onsi/ginkgo/internal/leafnodes/synchronized_before_suite_node.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/failer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type synchronizedBeforeSuiteNode struct {
0000000000000000000000000000000000000000;;		runnerA *runner
0000000000000000000000000000000000000000;;		runnerB *runner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outcome types.SpecState
0000000000000000000000000000000000000000;;		failure types.SpecFailure
0000000000000000000000000000000000000000;;		runTime time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSynchronizedBeforeSuiteNode(bodyA interface{}, bodyB interface{}, codeLocation types.CodeLocation, timeout time.Duration, failer *failer.Failer) SuiteNode {
0000000000000000000000000000000000000000;;		node := &synchronizedBeforeSuiteNode{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node.runnerA = newRunner(node.wrapA(bodyA), codeLocation, timeout, failer, types.SpecComponentTypeBeforeSuite, 0)
0000000000000000000000000000000000000000;;		node.runnerB = newRunner(node.wrapB(bodyB), codeLocation, timeout, failer, types.SpecComponentTypeBeforeSuite, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedBeforeSuiteNode) Run(parallelNode int, parallelTotal int, syncHost string) bool {
0000000000000000000000000000000000000000;;		t := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			node.runTime = time.Since(t)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parallelNode == 1 {
0000000000000000000000000000000000000000;;			node.outcome, node.failure = node.runA(parallelTotal, syncHost)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			node.outcome, node.failure = node.waitForA(syncHost)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if node.outcome != types.SpecStatePassed {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node.outcome, node.failure = node.runnerB.run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return node.outcome == types.SpecStatePassed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedBeforeSuiteNode) runA(parallelTotal int, syncHost string) (types.SpecState, types.SpecFailure) {
0000000000000000000000000000000000000000;;		outcome, failure := node.runnerA.run()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parallelTotal > 1 {
0000000000000000000000000000000000000000;;			state := types.RemoteBeforeSuiteStatePassed
0000000000000000000000000000000000000000;;			if outcome != types.SpecStatePassed {
0000000000000000000000000000000000000000;;				state = types.RemoteBeforeSuiteStateFailed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			json := (types.RemoteBeforeSuiteData{
0000000000000000000000000000000000000000;;				Data:  node.data,
0000000000000000000000000000000000000000;;				State: state,
0000000000000000000000000000000000000000;;			}).ToJSON()
0000000000000000000000000000000000000000;;			http.Post(syncHost+"/BeforeSuiteState", "application/json", bytes.NewBuffer(json))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return outcome, failure
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedBeforeSuiteNode) waitForA(syncHost string) (types.SpecState, types.SpecFailure) {
0000000000000000000000000000000000000000;;		failure := func(message string) types.SpecFailure {
0000000000000000000000000000000000000000;;			return types.SpecFailure{
0000000000000000000000000000000000000000;;				Message:               message,
0000000000000000000000000000000000000000;;				Location:              node.runnerA.codeLocation,
0000000000000000000000000000000000000000;;				ComponentType:         node.runnerA.nodeType,
0000000000000000000000000000000000000000;;				ComponentIndex:        node.runnerA.componentIndex,
0000000000000000000000000000000000000000;;				ComponentCodeLocation: node.runnerA.codeLocation,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resp, err := http.Get(syncHost + "/BeforeSuiteState")
0000000000000000000000000000000000000000;;			if err != nil || resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				return types.SpecStateFailed, failure("Failed to fetch BeforeSuite state")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return types.SpecStateFailed, failure("Failed to read BeforeSuite state")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			beforeSuiteData := types.RemoteBeforeSuiteData{}
0000000000000000000000000000000000000000;;			err = json.Unmarshal(body, &beforeSuiteData)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return types.SpecStateFailed, failure("Failed to decode BeforeSuite state")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch beforeSuiteData.State {
0000000000000000000000000000000000000000;;			case types.RemoteBeforeSuiteStatePassed:
0000000000000000000000000000000000000000;;				node.data = beforeSuiteData.Data
0000000000000000000000000000000000000000;;				return types.SpecStatePassed, types.SpecFailure{}
0000000000000000000000000000000000000000;;			case types.RemoteBeforeSuiteStateFailed:
0000000000000000000000000000000000000000;;				return types.SpecStateFailed, failure("BeforeSuite on Node 1 failed")
0000000000000000000000000000000000000000;;			case types.RemoteBeforeSuiteStateDisappeared:
0000000000000000000000000000000000000000;;				return types.SpecStateFailed, failure("Node 1 disappeared before completing BeforeSuite")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return types.SpecStateFailed, failure("Shouldn't get here!")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedBeforeSuiteNode) Passed() bool {
0000000000000000000000000000000000000000;;		return node.outcome == types.SpecStatePassed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedBeforeSuiteNode) Summary() *types.SetupSummary {
0000000000000000000000000000000000000000;;		return &types.SetupSummary{
0000000000000000000000000000000000000000;;			ComponentType: node.runnerA.nodeType,
0000000000000000000000000000000000000000;;			CodeLocation:  node.runnerA.codeLocation,
0000000000000000000000000000000000000000;;			State:         node.outcome,
0000000000000000000000000000000000000000;;			RunTime:       node.runTime,
0000000000000000000000000000000000000000;;			Failure:       node.failure,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedBeforeSuiteNode) wrapA(bodyA interface{}) interface{} {
0000000000000000000000000000000000000000;;		typeA := reflect.TypeOf(bodyA)
0000000000000000000000000000000000000000;;		if typeA.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			panic("SynchronizedBeforeSuite expects a function as its first argument")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		takesNothing := typeA.NumIn() == 0
0000000000000000000000000000000000000000;;		takesADoneChannel := typeA.NumIn() == 1 && typeA.In(0).Kind() == reflect.Chan && typeA.In(0).Elem().Kind() == reflect.Interface
0000000000000000000000000000000000000000;;		returnsBytes := typeA.NumOut() == 1 && typeA.Out(0).Kind() == reflect.Slice && typeA.Out(0).Elem().Kind() == reflect.Uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !((takesNothing || takesADoneChannel) && returnsBytes) {
0000000000000000000000000000000000000000;;			panic("SynchronizedBeforeSuite's first argument should be a function that returns []byte and either takes no arguments or takes a Done channel.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if takesADoneChannel {
0000000000000000000000000000000000000000;;			return func(done chan<- interface{}) {
0000000000000000000000000000000000000000;;				out := reflect.ValueOf(bodyA).Call([]reflect.Value{reflect.ValueOf(done)})
0000000000000000000000000000000000000000;;				node.data = out[0].Interface().([]byte)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() {
0000000000000000000000000000000000000000;;			out := reflect.ValueOf(bodyA).Call([]reflect.Value{})
0000000000000000000000000000000000000000;;			node.data = out[0].Interface().([]byte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *synchronizedBeforeSuiteNode) wrapB(bodyB interface{}) interface{} {
0000000000000000000000000000000000000000;;		typeB := reflect.TypeOf(bodyB)
0000000000000000000000000000000000000000;;		if typeB.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			panic("SynchronizedBeforeSuite expects a function as its second argument")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		returnsNothing := typeB.NumOut() == 0
0000000000000000000000000000000000000000;;		takesBytesOnly := typeB.NumIn() == 1 && typeB.In(0).Kind() == reflect.Slice && typeB.In(0).Elem().Kind() == reflect.Uint8
0000000000000000000000000000000000000000;;		takesBytesAndDone := typeB.NumIn() == 2 &&
0000000000000000000000000000000000000000;;			typeB.In(0).Kind() == reflect.Slice && typeB.In(0).Elem().Kind() == reflect.Uint8 &&
0000000000000000000000000000000000000000;;			typeB.In(1).Kind() == reflect.Chan && typeB.In(1).Elem().Kind() == reflect.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !((takesBytesOnly || takesBytesAndDone) && returnsNothing) {
0000000000000000000000000000000000000000;;			panic("SynchronizedBeforeSuite's second argument should be a function that returns nothing and either takes []byte or ([]byte, Done)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if takesBytesAndDone {
0000000000000000000000000000000000000000;;			return func(done chan<- interface{}) {
0000000000000000000000000000000000000000;;				reflect.ValueOf(bodyB).Call([]reflect.Value{reflect.ValueOf(node.data), reflect.ValueOf(done)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func() {
0000000000000000000000000000000000000000;;			reflect.ValueOf(bodyB).Call([]reflect.Value{reflect.ValueOf(node.data)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
