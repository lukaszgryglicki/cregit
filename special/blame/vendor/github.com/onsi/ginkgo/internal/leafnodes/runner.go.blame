0000000000000000000000000000000000000000;;	package leafnodes
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/runner.go[Godeps/_workspace/src/github.com/onsi/ginkgo/internal/leafnodes/runner.go][vendor/github.com/onsi/ginkgo/internal/leafnodes/runner.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/codelocation"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/internal/failer"
0000000000000000000000000000000000000000;;		"github.com/onsi/ginkgo/types"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type runner struct {
0000000000000000000000000000000000000000;;		isAsync          bool
0000000000000000000000000000000000000000;;		asyncFunc        func(chan<- interface{})
0000000000000000000000000000000000000000;;		syncFunc         func()
0000000000000000000000000000000000000000;;		codeLocation     types.CodeLocation
0000000000000000000000000000000000000000;;		timeoutThreshold time.Duration
0000000000000000000000000000000000000000;;		nodeType         types.SpecComponentType
0000000000000000000000000000000000000000;;		componentIndex   int
0000000000000000000000000000000000000000;;		failer           *failer.Failer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRunner(body interface{}, codeLocation types.CodeLocation, timeout time.Duration, failer *failer.Failer, nodeType types.SpecComponentType, componentIndex int) *runner {
0000000000000000000000000000000000000000;;		bodyType := reflect.TypeOf(body)
0000000000000000000000000000000000000000;;		if bodyType.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Expected a function but got something else at %v", codeLocation))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runner := &runner{
0000000000000000000000000000000000000000;;			codeLocation:     codeLocation,
0000000000000000000000000000000000000000;;			timeoutThreshold: timeout,
0000000000000000000000000000000000000000;;			failer:           failer,
0000000000000000000000000000000000000000;;			nodeType:         nodeType,
0000000000000000000000000000000000000000;;			componentIndex:   componentIndex,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch bodyType.NumIn() {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			runner.syncFunc = body.(func())
0000000000000000000000000000000000000000;;			return runner
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			if !(bodyType.In(0).Kind() == reflect.Chan && bodyType.In(0).Elem().Kind() == reflect.Interface) {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Must pass a Done channel to function at %v", codeLocation))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wrappedBody := func(done chan<- interface{}) {
0000000000000000000000000000000000000000;;				bodyValue := reflect.ValueOf(body)
0000000000000000000000000000000000000000;;				bodyValue.Call([]reflect.Value{reflect.ValueOf(done)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runner.isAsync = true
0000000000000000000000000000000000000000;;			runner.asyncFunc = wrappedBody
0000000000000000000000000000000000000000;;			return runner
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("Too many arguments to function at %v", codeLocation))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *runner) run() (outcome types.SpecState, failure types.SpecFailure) {
0000000000000000000000000000000000000000;;		if r.isAsync {
0000000000000000000000000000000000000000;;			return r.runAsync()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return r.runSync()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *runner) runAsync() (outcome types.SpecState, failure types.SpecFailure) {
0000000000000000000000000000000000000000;;		done := make(chan interface{}, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			finished := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if e := recover(); e != nil || !finished {
0000000000000000000000000000000000000000;;					r.failer.Panic(codelocation.New(2), e)
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case <-done:
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						close(done)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.asyncFunc(done)
0000000000000000000000000000000000000000;;			finished = true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;		case <-time.After(r.timeoutThreshold):
0000000000000000000000000000000000000000;;			r.failer.Timeout(r.codeLocation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failure, outcome = r.failer.Drain(r.nodeType, r.componentIndex, r.codeLocation)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *runner) runSync() (outcome types.SpecState, failure types.SpecFailure) {
0000000000000000000000000000000000000000;;		finished := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if e := recover(); e != nil || !finished {
0000000000000000000000000000000000000000;;				r.failer.Panic(codelocation.New(2), e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			failure, outcome = r.failer.Drain(r.nodeType, r.componentIndex, r.codeLocation)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.syncFunc()
0000000000000000000000000000000000000000;;		finished = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
