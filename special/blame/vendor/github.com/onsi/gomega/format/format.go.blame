0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Gomega's format package pretty-prints objects.  It explores input objects recursively and generates formatted, indented output with type information.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package format
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/format/format.go[Godeps/_workspace/src/github.com/onsi/gomega/format/format.go][vendor/github.com/onsi/gomega/format/format.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Use MaxDepth to set the maximum recursion depth when printing deeply nested objects
0000000000000000000000000000000000000000;;	var MaxDepth = uint(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	By default, all objects (even those that implement fmt.Stringer and fmt.GoStringer) are recursively inspected to generate output.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Set UseStringerRepresentation = true to use GoString (for fmt.GoStringers) or String (for fmt.Stringer) instead.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note that GoString and String don't always have all the information you need to understand why a test failed!
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	var UseStringerRepresentation = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//The default indentation string emitted by the format package
0000000000000000000000000000000000000000;;	var Indent = "    "
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var longFormThreshold = 20
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Generates a formatted matcher success/failure message of the form:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Expected
0000000000000000000000000000000000000000;;			<pretty printed actual>
0000000000000000000000000000000000000000;;		<message>
0000000000000000000000000000000000000000;;			<pretty printed expected>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If expected is omited, then the message looks like:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Expected
0000000000000000000000000000000000000000;;			<pretty printed actual>
0000000000000000000000000000000000000000;;		<message>
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func Message(actual interface{}, message string, expected ...interface{}) string {
0000000000000000000000000000000000000000;;		if len(expected) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Expected\n%s\n%s", Object(actual, 1), message)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Expected\n%s\n%s\n%s", Object(actual, 1), message, Object(expected[0], 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Pretty prints the passed in object at the passed in indentation level.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Object recurses into deeply nested objects emitting pretty-printed representations of their components.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Modify format.MaxDepth to control how deep the recursion is allowed to go
0000000000000000000000000000000000000000;;	Set format.UseStringerRepresentation to true to return object.GoString() or object.String() when available instead of
0000000000000000000000000000000000000000;;	recursing into the object.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func Object(object interface{}, indentation uint) string {
0000000000000000000000000000000000000000;;		indent := strings.Repeat(Indent, int(indentation))
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(object)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s<%s>: %s", indent, formatType(object), formatValue(value, indentation))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	IndentString takes a string and indents each line by the specified amount.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func IndentString(s string, indentation uint) string {
0000000000000000000000000000000000000000;;		components := strings.Split(s, "\n")
0000000000000000000000000000000000000000;;		result := ""
0000000000000000000000000000000000000000;;		indent := strings.Repeat(Indent, int(indentation))
0000000000000000000000000000000000000000;;		for i, component := range components {
0000000000000000000000000000000000000000;;			result += indent + component
0000000000000000000000000000000000000000;;			if i < len(components)-1 {
0000000000000000000000000000000000000000;;				result += "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatType(object interface{}) string {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(object)
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return "nil"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Chan:
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(object)
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%T | len:%d, cap:%d", object, v.Len(), v.Cap())
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%T | %p", object, object)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(object)
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%T | len:%d, cap:%d", object, v.Len(), v.Cap())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(object)
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%T | len:%d", object, v.Len())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%T", object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatValue(value reflect.Value, indentation uint) string {
0000000000000000000000000000000000000000;;		if indentation > MaxDepth {
0000000000000000000000000000000000000000;;			return "..."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isNilValue(value) {
0000000000000000000000000000000000000000;;			return "nil"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if UseStringerRepresentation {
0000000000000000000000000000000000000000;;			if value.CanInterface() {
0000000000000000000000000000000000000000;;				obj := value.Interface()
0000000000000000000000000000000000000000;;				switch x := obj.(type) {
0000000000000000000000000000000000000000;;				case fmt.GoStringer:
0000000000000000000000000000000000000000;;					return x.GoString()
0000000000000000000000000000000000000000;;				case fmt.Stringer:
0000000000000000000000000000000000000000;;					return x.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch value.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v", value.Bool())
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v", value.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v", value.Uint())
0000000000000000000000000000000000000000;;		case reflect.Uintptr:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("0x%x", value.Uint())
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v", value.Float())
0000000000000000000000000000000000000000;;		case reflect.Complex64, reflect.Complex128:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v", value.Complex())
0000000000000000000000000000000000000000;;		case reflect.Chan:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("0x%x", value.Pointer())
0000000000000000000000000000000000000000;;		case reflect.Func:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("0x%x", value.Pointer())
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return formatValue(value.Elem(), indentation)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return formatSlice(value, indentation)
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return formatString(value.String(), indentation)
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			return formatSlice(value, indentation)
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			return formatMap(value, indentation)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return formatStruct(value, indentation)
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			return formatValue(value.Elem(), indentation)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if value.CanInterface() {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("%#v", value.Interface())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("%#v", value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatString(object interface{}, indentation uint) string {
0000000000000000000000000000000000000000;;		if indentation == 1 {
0000000000000000000000000000000000000000;;			s := fmt.Sprintf("%s", object)
0000000000000000000000000000000000000000;;			components := strings.Split(s, "\n")
0000000000000000000000000000000000000000;;			result := ""
0000000000000000000000000000000000000000;;			for i, component := range components {
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					result += component
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					result += Indent + component
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i < len(components)-1 {
0000000000000000000000000000000000000000;;					result += "\n"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s", result)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%q", object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatSlice(v reflect.Value, indentation uint) string {
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Slice && v.Type().Elem().Kind() == reflect.Uint8 && isPrintableString(string(v.Bytes())){
0000000000000000000000000000000000000000;;			return formatString(v.Bytes(), indentation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := v.Len()
0000000000000000000000000000000000000000;;		result := make([]string, l)
0000000000000000000000000000000000000000;;		longest := 0
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			result[i] = formatValue(v.Index(i), indentation+1)
0000000000000000000000000000000000000000;;			if len(result[i]) > longest {
0000000000000000000000000000000000000000;;				longest = len(result[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if longest > longFormThreshold {
0000000000000000000000000000000000000000;;			indenter := strings.Repeat(Indent, int(indentation))
0000000000000000000000000000000000000000;;			return fmt.Sprintf("[\n%s%s,\n%s]", indenter+Indent, strings.Join(result, ",\n"+indenter+Indent), indenter)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("[%s]", strings.Join(result, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatMap(v reflect.Value, indentation uint) string {
0000000000000000000000000000000000000000;;		l := v.Len()
0000000000000000000000000000000000000000;;		result := make([]string, l)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		longest := 0
0000000000000000000000000000000000000000;;		for i, key := range v.MapKeys() {
0000000000000000000000000000000000000000;;			value := v.MapIndex(key)
0000000000000000000000000000000000000000;;			result[i] = fmt.Sprintf("%s: %s", formatValue(key, 0), formatValue(value, indentation+1))
0000000000000000000000000000000000000000;;			if len(result[i]) > longest {
0000000000000000000000000000000000000000;;				longest = len(result[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if longest > longFormThreshold {
0000000000000000000000000000000000000000;;			indenter := strings.Repeat(Indent, int(indentation))
0000000000000000000000000000000000000000;;			return fmt.Sprintf("{\n%s%s,\n%s}", indenter+Indent, strings.Join(result, ",\n"+indenter+Indent), indenter)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("{%s}", strings.Join(result, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func formatStruct(v reflect.Value, indentation uint) string {
0000000000000000000000000000000000000000;;		t := v.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := v.NumField()
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		longest := 0
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			structField := t.Field(i)
0000000000000000000000000000000000000000;;			fieldEntry := v.Field(i)
0000000000000000000000000000000000000000;;			representation := fmt.Sprintf("%s: %s", structField.Name, formatValue(fieldEntry, indentation+1))
0000000000000000000000000000000000000000;;			result = append(result, representation)
0000000000000000000000000000000000000000;;			if len(representation) > longest {
0000000000000000000000000000000000000000;;				longest = len(representation)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if longest > longFormThreshold {
0000000000000000000000000000000000000000;;			indenter := strings.Repeat(Indent, int(indentation))
0000000000000000000000000000000000000000;;			return fmt.Sprintf("{\n%s%s,\n%s}", indenter+Indent, strings.Join(result, ",\n"+indenter+Indent), indenter)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("{%s}", strings.Join(result, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNilValue(a reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch a.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Invalid:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
0000000000000000000000000000000000000000;;			return a.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Returns true when the string is entirely made of printable runes, false otherwise.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func isPrintableString(str string) bool {
0000000000000000000000000000000000000000;;		for _, runeValue := range str {
0000000000000000000000000000000000000000;;			if !strconv.IsPrint(runeValue) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
