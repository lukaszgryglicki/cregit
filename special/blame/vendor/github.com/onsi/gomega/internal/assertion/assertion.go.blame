0000000000000000000000000000000000000000;;	package assertion
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/internal/assertion/assertion.go[Godeps/_workspace/src/github.com/onsi/gomega/internal/assertion/assertion.go][vendor/github.com/onsi/gomega/internal/assertion/assertion.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Assertion struct {
0000000000000000000000000000000000000000;;		actualInput interface{}
0000000000000000000000000000000000000000;;		fail        types.GomegaFailHandler
0000000000000000000000000000000000000000;;		offset      int
0000000000000000000000000000000000000000;;		extra       []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(actualInput interface{}, fail types.GomegaFailHandler, offset int, extra ...interface{}) *Assertion {
0000000000000000000000000000000000000000;;		return &Assertion{
0000000000000000000000000000000000000000;;			actualInput: actualInput,
0000000000000000000000000000000000000000;;			fail:        fail,
0000000000000000000000000000000000000000;;			offset:      offset,
0000000000000000000000000000000000000000;;			extra:       extra,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) Should(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		return assertion.vetExtras(optionalDescription...) && assertion.match(matcher, true, optionalDescription...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) ShouldNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		return assertion.vetExtras(optionalDescription...) && assertion.match(matcher, false, optionalDescription...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) To(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		return assertion.vetExtras(optionalDescription...) && assertion.match(matcher, true, optionalDescription...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) ToNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		return assertion.vetExtras(optionalDescription...) && assertion.match(matcher, false, optionalDescription...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) NotTo(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		return assertion.vetExtras(optionalDescription...) && assertion.match(matcher, false, optionalDescription...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) buildDescription(optionalDescription ...interface{}) string {
0000000000000000000000000000000000000000;;		switch len(optionalDescription) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf(optionalDescription[0].(string), optionalDescription[1:]...) + "\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) match(matcher types.GomegaMatcher, desiredMatch bool, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		matches, err := matcher.Match(assertion.actualInput)
0000000000000000000000000000000000000000;;		description := assertion.buildDescription(optionalDescription...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			assertion.fail(description+err.Error(), 2+assertion.offset)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matches != desiredMatch {
0000000000000000000000000000000000000000;;			var message string
0000000000000000000000000000000000000000;;			if desiredMatch {
0000000000000000000000000000000000000000;;				message = matcher.FailureMessage(assertion.actualInput)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				message = matcher.NegatedFailureMessage(assertion.actualInput)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assertion.fail(description+message, 2+assertion.offset)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *Assertion) vetExtras(optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		success, message := vetExtras(assertion.extra)
0000000000000000000000000000000000000000;;		if success {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		description := assertion.buildDescription(optionalDescription...)
0000000000000000000000000000000000000000;;		assertion.fail(description+message, 2+assertion.offset)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func vetExtras(extras []interface{}) (bool, string) {
0000000000000000000000000000000000000000;;		for i, extra := range extras {
0000000000000000000000000000000000000000;;			if extra != nil {
0000000000000000000000000000000000000000;;				zeroValue := reflect.Zero(reflect.TypeOf(extra)).Interface()
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(zeroValue, extra) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("Unexpected non-nil/non-zero extra argument at index %d:\n\t<%T>: %#v", i+1, extra, extra)
0000000000000000000000000000000000000000;;					return false, message
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, ""
0000000000000000000000000000000000000000;;	}
