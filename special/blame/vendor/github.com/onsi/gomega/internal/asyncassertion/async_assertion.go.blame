0000000000000000000000000000000000000000;;	package asyncassertion
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/internal/asyncassertion/async_assertion.go[Godeps/_workspace/src/github.com/onsi/gomega/internal/asyncassertion/async_assertion.go][vendor/github.com/onsi/gomega/internal/asyncassertion/async_assertion.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/internal/oraclematcher"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AsyncAssertionType uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AsyncAssertionTypeEventually AsyncAssertionType = iota
0000000000000000000000000000000000000000;;		AsyncAssertionTypeConsistently
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AsyncAssertion struct {
0000000000000000000000000000000000000000;;		asyncType       AsyncAssertionType
0000000000000000000000000000000000000000;;		actualInput     interface{}
0000000000000000000000000000000000000000;;		timeoutInterval time.Duration
0000000000000000000000000000000000000000;;		pollingInterval time.Duration
0000000000000000000000000000000000000000;;		fail            types.GomegaFailHandler
0000000000000000000000000000000000000000;;		offset          int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(asyncType AsyncAssertionType, actualInput interface{}, fail types.GomegaFailHandler, timeoutInterval time.Duration, pollingInterval time.Duration, offset int) *AsyncAssertion {
0000000000000000000000000000000000000000;;		actualType := reflect.TypeOf(actualInput)
0000000000000000000000000000000000000000;;		if actualType.Kind() == reflect.Func {
0000000000000000000000000000000000000000;;			if actualType.NumIn() != 0 || actualType.NumOut() == 0 {
0000000000000000000000000000000000000000;;				panic("Expected a function with no arguments and one or more return values.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &AsyncAssertion{
0000000000000000000000000000000000000000;;			asyncType:       asyncType,
0000000000000000000000000000000000000000;;			actualInput:     actualInput,
0000000000000000000000000000000000000000;;			fail:            fail,
0000000000000000000000000000000000000000;;			timeoutInterval: timeoutInterval,
0000000000000000000000000000000000000000;;			pollingInterval: pollingInterval,
0000000000000000000000000000000000000000;;			offset:          offset,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *AsyncAssertion) Should(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		return assertion.match(matcher, true, optionalDescription...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *AsyncAssertion) ShouldNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		return assertion.match(matcher, false, optionalDescription...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *AsyncAssertion) buildDescription(optionalDescription ...interface{}) string {
0000000000000000000000000000000000000000;;		switch len(optionalDescription) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf(optionalDescription[0].(string), optionalDescription[1:]...) + "\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *AsyncAssertion) actualInputIsAFunction() bool {
0000000000000000000000000000000000000000;;		actualType := reflect.TypeOf(assertion.actualInput)
0000000000000000000000000000000000000000;;		return actualType.Kind() == reflect.Func && actualType.NumIn() == 0 && actualType.NumOut() > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *AsyncAssertion) pollActual() (interface{}, error) {
0000000000000000000000000000000000000000;;		if assertion.actualInputIsAFunction() {
0000000000000000000000000000000000000000;;			values := reflect.ValueOf(assertion.actualInput).Call([]reflect.Value{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			extras := []interface{}{}
0000000000000000000000000000000000000000;;			for _, value := range values[1:] {
0000000000000000000000000000000000000000;;				extras = append(extras, value.Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			success, message := vetExtras(extras)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !success {
0000000000000000000000000000000000000000;;				return nil, errors.New(message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return values[0].Interface(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return assertion.actualInput, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *AsyncAssertion) matcherMayChange(matcher types.GomegaMatcher, value interface{}) bool {
0000000000000000000000000000000000000000;;		if assertion.actualInputIsAFunction() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return oraclematcher.MatchMayChangeInTheFuture(matcher, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (assertion *AsyncAssertion) match(matcher types.GomegaMatcher, desiredMatch bool, optionalDescription ...interface{}) bool {
0000000000000000000000000000000000000000;;		timer := time.Now()
0000000000000000000000000000000000000000;;		timeout := time.After(assertion.timeoutInterval)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		description := assertion.buildDescription(optionalDescription...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var matches bool
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		mayChange := true
0000000000000000000000000000000000000000;;		value, err := assertion.pollActual()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			mayChange = assertion.matcherMayChange(matcher, value)
0000000000000000000000000000000000000000;;			matches, err = matcher.Match(value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fail := func(preamble string) {
0000000000000000000000000000000000000000;;			errMsg := ""
0000000000000000000000000000000000000000;;			message := ""
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errMsg = "Error: " + err.Error()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if desiredMatch {
0000000000000000000000000000000000000000;;					message = matcher.FailureMessage(value)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message = matcher.NegatedFailureMessage(value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assertion.fail(fmt.Sprintf("%s after %.3fs.\n%s%s%s", preamble, time.Since(timer).Seconds(), description, message, errMsg), 3+assertion.offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if assertion.asyncType == AsyncAssertionTypeEventually {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if err == nil && matches == desiredMatch {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !mayChange {
0000000000000000000000000000000000000000;;					fail("No future change is possible.  Bailing out early")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-time.After(assertion.pollingInterval):
0000000000000000000000000000000000000000;;					value, err = assertion.pollActual()
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						mayChange = assertion.matcherMayChange(matcher, value)
0000000000000000000000000000000000000000;;						matches, err = matcher.Match(value)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-timeout:
0000000000000000000000000000000000000000;;					fail("Timed out")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if assertion.asyncType == AsyncAssertionTypeConsistently {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if !(err == nil && matches == desiredMatch) {
0000000000000000000000000000000000000000;;					fail("Failed")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !mayChange {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-time.After(assertion.pollingInterval):
0000000000000000000000000000000000000000;;					value, err = assertion.pollActual()
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						mayChange = assertion.matcherMayChange(matcher, value)
0000000000000000000000000000000000000000;;						matches, err = matcher.Match(value)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-timeout:
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func vetExtras(extras []interface{}) (bool, string) {
0000000000000000000000000000000000000000;;		for i, extra := range extras {
0000000000000000000000000000000000000000;;			if extra != nil {
0000000000000000000000000000000000000000;;				zeroValue := reflect.Zero(reflect.TypeOf(extra)).Interface()
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(zeroValue, extra) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("Unexpected non-nil/non-zero extra argument at index %d:\n\t<%T>: %#v", i+1, extra, extra)
0000000000000000000000000000000000000000;;					return false, message
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, ""
0000000000000000000000000000000000000000;;	}
