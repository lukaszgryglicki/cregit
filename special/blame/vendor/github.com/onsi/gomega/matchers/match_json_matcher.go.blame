0000000000000000000000000000000000000000;;	package matchers
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers/match_json_matcher.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/match_json_matcher.go][vendor/github.com/onsi/gomega/matchers/match_json_matcher.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MatchJSONMatcher struct {
0000000000000000000000000000000000000000;;		JSONToMatch interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *MatchJSONMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		actualString, expectedString, err := matcher.prettyPrint(actual)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var aval interface{}
0000000000000000000000000000000000000000;;		var eval interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is guarded by prettyPrint
0000000000000000000000000000000000000000;;		json.Unmarshal([]byte(actualString), &aval)
0000000000000000000000000000000000000000;;		json.Unmarshal([]byte(expectedString), &eval)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(aval, eval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *MatchJSONMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		actualString, expectedString, _ := matcher.prettyPrint(actual)
0000000000000000000000000000000000000000;;		return format.Message(actualString, "to match JSON of", expectedString)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *MatchJSONMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		actualString, expectedString, _ := matcher.prettyPrint(actual)
0000000000000000000000000000000000000000;;		return format.Message(actualString, "not to match JSON of", expectedString)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *MatchJSONMatcher) prettyPrint(actual interface{}) (actualFormatted, expectedFormatted string, err error) {
0000000000000000000000000000000000000000;;		actualString, ok := toString(actual)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("MatchJSONMatcher matcher requires a string, stringer, or []byte.  Got actual:\n%s", format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedString, ok := toString(matcher.JSONToMatch)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("MatchJSONMatcher matcher requires a string, stringer, or []byte.  Got expected:\n%s", format.Object(matcher.JSONToMatch, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		abuf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		ebuf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Indent(abuf, []byte(actualString), "", "  "); err != nil {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("Actual '%s' should be valid JSON, but it is not.\nUnderlying error:%s", actualString, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Indent(ebuf, []byte(expectedString), "", "  "); err != nil {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("Expected '%s' should be valid JSON, but it is not.\nUnderlying error:%s", expectedString, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return abuf.String(), ebuf.String(), nil
0000000000000000000000000000000000000000;;	}
