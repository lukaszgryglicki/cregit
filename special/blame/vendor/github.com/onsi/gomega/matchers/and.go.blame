0000000000000000000000000000000000000000;;	package matchers
bd1ba01e8c3d94f344e03c9790e8df7c23a617c8;Godeps/_workspace/src/github.com/onsi/gomega/matchers/and.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/and.go][vendor/github.com/onsi/gomega/matchers/and.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/internal/oraclematcher"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AndMatcher struct {
0000000000000000000000000000000000000000;;		Matchers []types.GomegaMatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// state
0000000000000000000000000000000000000000;;		firstFailedMatcher types.GomegaMatcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *AndMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		m.firstFailedMatcher = nil
0000000000000000000000000000000000000000;;		for _, matcher := range m.Matchers {
0000000000000000000000000000000000000000;;			success, err := matcher.Match(actual)
0000000000000000000000000000000000000000;;			if !success || err != nil {
0000000000000000000000000000000000000000;;				m.firstFailedMatcher = matcher
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *AndMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return m.firstFailedMatcher.FailureMessage(actual)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *AndMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		// not the most beautiful list of matchers, but not bad either...
0000000000000000000000000000000000000000;;		return format.Message(actual, fmt.Sprintf("To not satisfy all of these matchers: %s", m.Matchers))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *AndMatcher) MatchMayChangeInTheFuture(actual interface{}) bool {
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Example with 3 matchers: A, B, C
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Match evaluates them: T, F, <?>  => F
0000000000000000000000000000000000000000;;			So match is currently F, what should MatchMayChangeInTheFuture() return?
0000000000000000000000000000000000000000;;			Seems like it only depends on B, since currently B MUST change to allow the result to become T
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Match eval: T, T, T  => T
0000000000000000000000000000000000000000;;			So match is currently T, what should MatchMayChangeInTheFuture() return?
0000000000000000000000000000000000000000;;			Seems to depend on ANY of them being able to change to F.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.firstFailedMatcher == nil {
0000000000000000000000000000000000000000;;			// so all matchers succeeded.. Any one of them changing would change the result.
0000000000000000000000000000000000000000;;			for _, matcher := range m.Matchers {
0000000000000000000000000000000000000000;;				if oraclematcher.MatchMayChangeInTheFuture(matcher, actual) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false // none of were going to change
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// one of the matchers failed.. it must be able to change in order to affect the result
0000000000000000000000000000000000000000;;			return oraclematcher.MatchMayChangeInTheFuture(m.firstFailedMatcher, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
