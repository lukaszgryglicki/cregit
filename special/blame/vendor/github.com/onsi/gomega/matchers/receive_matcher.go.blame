0000000000000000000000000000000000000000;;	package matchers
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers/receive_matcher.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/receive_matcher.go][vendor/github.com/onsi/gomega/matchers/receive_matcher.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReceiveMatcher struct {
0000000000000000000000000000000000000000;;		Arg           interface{}
0000000000000000000000000000000000000000;;		receivedValue reflect.Value
0000000000000000000000000000000000000000;;		channelClosed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ReceiveMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		if !isChan(actual) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("ReceiveMatcher expects a channel.  Got:\n%s", format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		channelType := reflect.TypeOf(actual)
0000000000000000000000000000000000000000;;		channelValue := reflect.ValueOf(actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if channelType.ChanDir() == reflect.SendDir {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("ReceiveMatcher matcher cannot be passed a send-only channel.  Got:\n%s", format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var subMatcher omegaMatcher
0000000000000000000000000000000000000000;;		var hasSubMatcher bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if matcher.Arg != nil {
0000000000000000000000000000000000000000;;			subMatcher, hasSubMatcher = (matcher.Arg).(omegaMatcher)
0000000000000000000000000000000000000000;;			if !hasSubMatcher {
0000000000000000000000000000000000000000;;				argType := reflect.TypeOf(matcher.Arg)
0000000000000000000000000000000000000000;;				if argType.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Cannot assign a value from the channel:\n%s\nTo:\n%s\nYou need to pass a pointer!", format.Object(actual, 1), format.Object(matcher.Arg, 1))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				assignable := channelType.Elem().AssignableTo(argType.Elem())
0000000000000000000000000000000000000000;;				if !assignable {
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Cannot assign a value from the channel:\n%s\nTo:\n%s", format.Object(actual, 1), format.Object(matcher.Arg, 1))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		winnerIndex, value, open := reflect.Select([]reflect.SelectCase{
0000000000000000000000000000000000000000;;			reflect.SelectCase{Dir: reflect.SelectRecv, Chan: channelValue},
0000000000000000000000000000000000000000;;			reflect.SelectCase{Dir: reflect.SelectDefault},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var closed bool
0000000000000000000000000000000000000000;;		var didReceive bool
0000000000000000000000000000000000000000;;		if winnerIndex == 0 {
0000000000000000000000000000000000000000;;			closed = !open
0000000000000000000000000000000000000000;;			didReceive = open
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matcher.channelClosed = closed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if closed {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasSubMatcher {
0000000000000000000000000000000000000000;;			if didReceive {
0000000000000000000000000000000000000000;;				matcher.receivedValue = value
0000000000000000000000000000000000000000;;				return subMatcher.Match(matcher.receivedValue.Interface())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if didReceive {
0000000000000000000000000000000000000000;;			if matcher.Arg != nil {
0000000000000000000000000000000000000000;;				outValue := reflect.ValueOf(matcher.Arg)
0000000000000000000000000000000000000000;;				reflect.Indirect(outValue).Set(value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ReceiveMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		subMatcher, hasSubMatcher := (matcher.Arg).(omegaMatcher)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closedAddendum := ""
0000000000000000000000000000000000000000;;		if matcher.channelClosed {
0000000000000000000000000000000000000000;;			closedAddendum = " The channel is closed."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasSubMatcher {
0000000000000000000000000000000000000000;;			if matcher.receivedValue.IsValid() {
0000000000000000000000000000000000000000;;				return subMatcher.FailureMessage(matcher.receivedValue.Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "When passed a matcher, ReceiveMatcher's channel *must* receive something."
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return format.Message(actual, "to receive something."+closedAddendum)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ReceiveMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		subMatcher, hasSubMatcher := (matcher.Arg).(omegaMatcher)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closedAddendum := ""
0000000000000000000000000000000000000000;;		if matcher.channelClosed {
0000000000000000000000000000000000000000;;			closedAddendum = " The channel is closed."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasSubMatcher {
0000000000000000000000000000000000000000;;			if matcher.receivedValue.IsValid() {
0000000000000000000000000000000000000000;;				return subMatcher.NegatedFailureMessage(matcher.receivedValue.Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "When passed a matcher, ReceiveMatcher's channel *must* receive something."
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return format.Message(actual, "not to receive anything."+closedAddendum)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ReceiveMatcher) MatchMayChangeInTheFuture(actual interface{}) bool {
0000000000000000000000000000000000000000;;		if !isChan(actual) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return !matcher.channelClosed
0000000000000000000000000000000000000000;;	}
