0000000000000000000000000000000000000000;;	package matchers
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers/be_sent_matcher.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/be_sent_matcher.go][vendor/github.com/onsi/gomega/matchers/be_sent_matcher.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BeSentMatcher struct {
0000000000000000000000000000000000000000;;		Arg           interface{}
0000000000000000000000000000000000000000;;		channelClosed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *BeSentMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		if !isChan(actual) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("BeSent expects a channel.  Got:\n%s", format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		channelType := reflect.TypeOf(actual)
0000000000000000000000000000000000000000;;		channelValue := reflect.ValueOf(actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if channelType.ChanDir() == reflect.RecvDir {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("BeSent matcher cannot be passed a receive-only channel.  Got:\n%s", format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		argType := reflect.TypeOf(matcher.Arg)
0000000000000000000000000000000000000000;;		assignable := argType.AssignableTo(channelType.Elem())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !assignable {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Cannot pass:\n%s to the channel:\n%s\nThe types don't match.", format.Object(matcher.Arg, 1), format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		argValue := reflect.ValueOf(matcher.Arg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if e := recover(); e != nil {
0000000000000000000000000000000000000000;;				success = false
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Cannot send to a closed channel")
0000000000000000000000000000000000000000;;				matcher.channelClosed = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		winnerIndex, _, _ := reflect.Select([]reflect.SelectCase{
0000000000000000000000000000000000000000;;			reflect.SelectCase{Dir: reflect.SelectSend, Chan: channelValue, Send: argValue},
0000000000000000000000000000000000000000;;			reflect.SelectCase{Dir: reflect.SelectDefault},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var didSend bool
0000000000000000000000000000000000000000;;		if winnerIndex == 0 {
0000000000000000000000000000000000000000;;			didSend = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return didSend, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *BeSentMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "to send:", matcher.Arg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *BeSentMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "not to send:", matcher.Arg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *BeSentMatcher) MatchMayChangeInTheFuture(actual interface{}) bool {
0000000000000000000000000000000000000000;;		if !isChan(actual) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return !matcher.channelClosed
0000000000000000000000000000000000000000;;	}
