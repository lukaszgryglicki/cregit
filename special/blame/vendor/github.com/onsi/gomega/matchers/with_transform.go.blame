0000000000000000000000000000000000000000;;	package matchers
bd1ba01e8c3d94f344e03c9790e8df7c23a617c8;Godeps/_workspace/src/github.com/onsi/gomega/matchers/with_transform.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/with_transform.go][vendor/github.com/onsi/gomega/matchers/with_transform.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/internal/oraclematcher"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WithTransformMatcher struct {
0000000000000000000000000000000000000000;;		// input
0000000000000000000000000000000000000000;;		Transform interface{} // must be a function of one parameter that returns one value
0000000000000000000000000000000000000000;;		Matcher   types.GomegaMatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cached value
0000000000000000000000000000000000000000;;		transformArgType reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// state
0000000000000000000000000000000000000000;;		transformedValue interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewWithTransformMatcher(transform interface{}, matcher types.GomegaMatcher) *WithTransformMatcher {
0000000000000000000000000000000000000000;;		if transform == nil {
0000000000000000000000000000000000000000;;			panic("transform function cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		txType := reflect.TypeOf(transform)
0000000000000000000000000000000000000000;;		if txType.NumIn() != 1 {
0000000000000000000000000000000000000000;;			panic("transform function must have 1 argument")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if txType.NumOut() != 1 {
0000000000000000000000000000000000000000;;			panic("transform function must have 1 return value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &WithTransformMatcher{
0000000000000000000000000000000000000000;;			Transform:        transform,
0000000000000000000000000000000000000000;;			Matcher:          matcher,
0000000000000000000000000000000000000000;;			transformArgType: reflect.TypeOf(transform).In(0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *WithTransformMatcher) Match(actual interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		// return error if actual's type is incompatible with Transform function's argument type
0000000000000000000000000000000000000000;;		actualType := reflect.TypeOf(actual)
0000000000000000000000000000000000000000;;		if !actualType.AssignableTo(m.transformArgType) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("Transform function expects '%s' but we have '%s'", m.transformArgType, actualType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// call the Transform function with `actual`
0000000000000000000000000000000000000000;;		fn := reflect.ValueOf(m.Transform)
0000000000000000000000000000000000000000;;		result := fn.Call([]reflect.Value{reflect.ValueOf(actual)})
0000000000000000000000000000000000000000;;		m.transformedValue = result[0].Interface() // expect exactly one value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.Matcher.Match(m.transformedValue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *WithTransformMatcher) FailureMessage(_ interface{}) (message string) {
0000000000000000000000000000000000000000;;		return m.Matcher.FailureMessage(m.transformedValue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *WithTransformMatcher) NegatedFailureMessage(_ interface{}) (message string) {
0000000000000000000000000000000000000000;;		return m.Matcher.NegatedFailureMessage(m.transformedValue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *WithTransformMatcher) MatchMayChangeInTheFuture(_ interface{}) bool {
0000000000000000000000000000000000000000;;		// TODO: Maybe this should always just return true? (Only an issue for non-deterministic transformers.)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Querying the next matcher is fine if the transformer always will return the same value.
0000000000000000000000000000000000000000;;		// But if the transformer is non-deterministic and returns a different value each time, then there
0000000000000000000000000000000000000000;;		// is no point in querying the next matcher, since it can only comment on the last transformed value.
0000000000000000000000000000000000000000;;		return oraclematcher.MatchMayChangeInTheFuture(m.Matcher, m.transformedValue)
0000000000000000000000000000000000000000;;	}
