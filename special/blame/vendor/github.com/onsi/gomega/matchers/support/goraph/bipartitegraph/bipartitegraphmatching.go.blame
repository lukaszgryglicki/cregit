0000000000000000000000000000000000000000;;	package bipartitegraph
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers/support/goraph/bipartitegraph/bipartitegraphmatching.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/support/goraph/bipartitegraph/bipartitegraphmatching.go][vendor/github.com/onsi/gomega/matchers/support/goraph/bipartitegraph/bipartitegraphmatching.go];	
0000000000000000000000000000000000000000;;	import . "github.com/onsi/gomega/matchers/support/goraph/node"
0000000000000000000000000000000000000000;;	import . "github.com/onsi/gomega/matchers/support/goraph/edge"
0000000000000000000000000000000000000000;;	import "github.com/onsi/gomega/matchers/support/goraph/util"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bg *BipartiteGraph) LargestMatching() (matching EdgeSet) {
0000000000000000000000000000000000000000;;		paths := bg.maximalDisjointSLAPCollection(matching)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(paths) > 0 {
0000000000000000000000000000000000000000;;			for _, path := range paths {
0000000000000000000000000000000000000000;;				matching = matching.SymmetricDifference(path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			paths = bg.maximalDisjointSLAPCollection(matching)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bg *BipartiteGraph) maximalDisjointSLAPCollection(matching EdgeSet) (result []EdgeSet) {
0000000000000000000000000000000000000000;;		guideLayers := bg.createSLAPGuideLayers(matching)
0000000000000000000000000000000000000000;;		if len(guideLayers) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		used := make(map[Node]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, u := range guideLayers[len(guideLayers)-1] {
0000000000000000000000000000000000000000;;			slap, found := bg.findDisjointSLAP(u, matching, guideLayers, used)
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				for _, edge := range slap {
0000000000000000000000000000000000000000;;					used[edge.Node1] = true
0000000000000000000000000000000000000000;;					used[edge.Node2] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = append(result, slap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bg *BipartiteGraph) findDisjointSLAP(
0000000000000000000000000000000000000000;;		start Node,
0000000000000000000000000000000000000000;;		matching EdgeSet,
0000000000000000000000000000000000000000;;		guideLayers []NodeOrderedSet,
0000000000000000000000000000000000000000;;		used map[Node]bool,
0000000000000000000000000000000000000000;;	) ([]Edge, bool) {
0000000000000000000000000000000000000000;;		return bg.findDisjointSLAPHelper(start, EdgeSet{}, len(guideLayers)-1, matching, guideLayers, used)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bg *BipartiteGraph) findDisjointSLAPHelper(
0000000000000000000000000000000000000000;;		currentNode Node,
0000000000000000000000000000000000000000;;		currentSLAP EdgeSet,
0000000000000000000000000000000000000000;;		currentLevel int,
0000000000000000000000000000000000000000;;		matching EdgeSet,
0000000000000000000000000000000000000000;;		guideLayers []NodeOrderedSet,
0000000000000000000000000000000000000000;;		used map[Node]bool,
0000000000000000000000000000000000000000;;	) (EdgeSet, bool) {
0000000000000000000000000000000000000000;;		used[currentNode] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if currentLevel == 0 {
0000000000000000000000000000000000000000;;			return currentSLAP, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, nextNode := range guideLayers[currentLevel-1] {
0000000000000000000000000000000000000000;;			if used[nextNode] {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			edge, found := bg.Edges.FindByNodes(currentNode, nextNode)
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if matching.Contains(edge) == util.Odd(currentLevel) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			currentSLAP = append(currentSLAP, edge)
0000000000000000000000000000000000000000;;			slap, found := bg.findDisjointSLAPHelper(nextNode, currentSLAP, currentLevel-1, matching, guideLayers, used)
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				return slap, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentSLAP = currentSLAP[:len(currentSLAP)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		used[currentNode] = false
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bg *BipartiteGraph) createSLAPGuideLayers(matching EdgeSet) (guideLayers []NodeOrderedSet) {
0000000000000000000000000000000000000000;;		used := make(map[Node]bool)
0000000000000000000000000000000000000000;;		currentLayer := NodeOrderedSet{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, node := range bg.Left {
0000000000000000000000000000000000000000;;			if matching.Free(node) {
0000000000000000000000000000000000000000;;				used[node] = true
0000000000000000000000000000000000000000;;				currentLayer = append(currentLayer, node)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(currentLayer) == 0 {
0000000000000000000000000000000000000000;;			return []NodeOrderedSet{}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			guideLayers = append(guideLayers, currentLayer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for !done {
0000000000000000000000000000000000000000;;			lastLayer := currentLayer
0000000000000000000000000000000000000000;;			currentLayer = NodeOrderedSet{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if util.Odd(len(guideLayers)) {
0000000000000000000000000000000000000000;;				for _, leftNode := range lastLayer {
0000000000000000000000000000000000000000;;					for _, rightNode := range bg.Right {
0000000000000000000000000000000000000000;;						if used[rightNode] {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						edge, found := bg.Edges.FindByNodes(leftNode, rightNode)
0000000000000000000000000000000000000000;;						if !found || matching.Contains(edge) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						currentLayer = append(currentLayer, rightNode)
0000000000000000000000000000000000000000;;						used[rightNode] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if matching.Free(rightNode) {
0000000000000000000000000000000000000000;;							done = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, rightNode := range lastLayer {
0000000000000000000000000000000000000000;;					for _, leftNode := range bg.Left {
0000000000000000000000000000000000000000;;						if used[leftNode] {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						edge, found := bg.Edges.FindByNodes(leftNode, rightNode)
0000000000000000000000000000000000000000;;						if !found || !matching.Contains(edge) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						currentLayer = append(currentLayer, leftNode)
0000000000000000000000000000000000000000;;						used[leftNode] = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(currentLayer) == 0 {
0000000000000000000000000000000000000000;;				return []NodeOrderedSet{}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				guideLayers = append(guideLayers, currentLayer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
