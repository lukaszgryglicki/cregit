0000000000000000000000000000000000000000;;	package bipartitegraph
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers/support/goraph/bipartitegraph/bipartitegraph.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/support/goraph/bipartitegraph/bipartitegraph.go][vendor/github.com/onsi/gomega/matchers/support/goraph/bipartitegraph/bipartitegraph.go];	
0000000000000000000000000000000000000000;;	import "errors"
0000000000000000000000000000000000000000;;	import "fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import . "github.com/onsi/gomega/matchers/support/goraph/node"
0000000000000000000000000000000000000000;;	import . "github.com/onsi/gomega/matchers/support/goraph/edge"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BipartiteGraph struct {
0000000000000000000000000000000000000000;;		Left  NodeOrderedSet
0000000000000000000000000000000000000000;;		Right NodeOrderedSet
0000000000000000000000000000000000000000;;		Edges EdgeSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBipartiteGraph(leftValues, rightValues []interface{}, neighbours func(interface{}, interface{}) (bool, error)) (*BipartiteGraph, error) {
0000000000000000000000000000000000000000;;		left := NodeOrderedSet{}
0000000000000000000000000000000000000000;;		for i, _ := range leftValues {
0000000000000000000000000000000000000000;;			left = append(left, Node{i})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		right := NodeOrderedSet{}
0000000000000000000000000000000000000000;;		for j, _ := range rightValues {
0000000000000000000000000000000000000000;;			right = append(right, Node{j + len(left)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		edges := EdgeSet{}
0000000000000000000000000000000000000000;;		for i, leftValue := range leftValues {
0000000000000000000000000000000000000000;;			for j, rightValue := range rightValues {
0000000000000000000000000000000000000000;;				neighbours, err := neighbours(leftValue, rightValue)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, errors.New(fmt.Sprintf("error determining adjacency for %v and %v: %s", leftValue, rightValue, err.Error()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if neighbours {
0000000000000000000000000000000000000000;;					edges = append(edges, Edge{left[i], right[j]})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &BipartiteGraph{left, right, edges}, nil
0000000000000000000000000000000000000000;;	}
