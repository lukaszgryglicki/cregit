0000000000000000000000000000000000000000;;	package matchers
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers/contain_element_matcher.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/contain_element_matcher.go][vendor/github.com/onsi/gomega/matchers/contain_element_matcher.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainElementMatcher struct {
0000000000000000000000000000000000000000;;		Element interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ContainElementMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		if !isArrayOrSlice(actual) && !isMap(actual) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("ContainElement matcher expects an array/slice/map.  Got:\n%s", format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elemMatcher, elementIsMatcher := matcher.Element.(omegaMatcher)
0000000000000000000000000000000000000000;;		if !elementIsMatcher {
0000000000000000000000000000000000000000;;			elemMatcher = &EqualMatcher{Expected: matcher.Element}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(actual)
0000000000000000000000000000000000000000;;		var keys []reflect.Value
0000000000000000000000000000000000000000;;		if isMap(actual) {
0000000000000000000000000000000000000000;;			keys = value.MapKeys()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var lastError error
0000000000000000000000000000000000000000;;		for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;			var success bool
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if isMap(actual) {
0000000000000000000000000000000000000000;;				success, err = elemMatcher.Match(value.MapIndex(keys[i]).Interface())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				success, err = elemMatcher.Match(value.Index(i).Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				lastError = err
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if success {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, lastError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ContainElementMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "to contain element matching", matcher.Element)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ContainElementMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "not to contain element matching", matcher.Element)
0000000000000000000000000000000000000000;;	}
