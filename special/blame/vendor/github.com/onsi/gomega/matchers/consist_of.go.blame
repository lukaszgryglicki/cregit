0000000000000000000000000000000000000000;;	package matchers
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers/consist_of.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/consist_of.go][vendor/github.com/onsi/gomega/matchers/consist_of.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/matchers/support/goraph/bipartitegraph"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConsistOfMatcher struct {
0000000000000000000000000000000000000000;;		Elements []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ConsistOfMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		if !isArrayOrSlice(actual) && !isMap(actual) {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("ConsistOf matcher expects an array/slice/map.  Got:\n%s", format.Object(actual, 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elements := matcher.Elements
0000000000000000000000000000000000000000;;		if len(matcher.Elements) == 1 && isArrayOrSlice(matcher.Elements[0]) {
0000000000000000000000000000000000000000;;			elements = []interface{}{}
0000000000000000000000000000000000000000;;			value := reflect.ValueOf(matcher.Elements[0])
0000000000000000000000000000000000000000;;			for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;				elements = append(elements, value.Index(i).Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matchers := []interface{}{}
0000000000000000000000000000000000000000;;		for _, element := range elements {
0000000000000000000000000000000000000000;;			matcher, isMatcher := element.(omegaMatcher)
0000000000000000000000000000000000000000;;			if !isMatcher {
0000000000000000000000000000000000000000;;				matcher = &EqualMatcher{Expected: element}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			matchers = append(matchers, matcher)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		values := matcher.valuesOf(actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(values) != len(matchers) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		neighbours := func(v, m interface{}) (bool, error) {
0000000000000000000000000000000000000000;;			match, err := m.(omegaMatcher).Match(v)
0000000000000000000000000000000000000000;;			return match && err == nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bipartiteGraph, err := bipartitegraph.NewBipartiteGraph(values, matchers, neighbours)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(bipartiteGraph.LargestMatching()) == len(values), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ConsistOfMatcher) valuesOf(actual interface{}) []interface{} {
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(actual)
0000000000000000000000000000000000000000;;		values := []interface{}{}
0000000000000000000000000000000000000000;;		if isMap(actual) {
0000000000000000000000000000000000000000;;			keys := value.MapKeys()
0000000000000000000000000000000000000000;;			for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;				values = append(values, value.MapIndex(keys[i]).Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for i := 0; i < value.Len(); i++ {
0000000000000000000000000000000000000000;;				values = append(values, value.Index(i).Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return values
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ConsistOfMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "to consist of", matcher.Elements)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (matcher *ConsistOfMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "not to consist of", matcher.Elements)
0000000000000000000000000000000000000000;;	}
