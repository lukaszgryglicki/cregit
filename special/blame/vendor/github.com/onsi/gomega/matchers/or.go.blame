0000000000000000000000000000000000000000;;	package matchers
bd1ba01e8c3d94f344e03c9790e8df7c23a617c8;Godeps/_workspace/src/github.com/onsi/gomega/matchers/or.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers/or.go][vendor/github.com/onsi/gomega/matchers/or.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/internal/oraclematcher"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OrMatcher struct {
0000000000000000000000000000000000000000;;		Matchers []types.GomegaMatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// state
0000000000000000000000000000000000000000;;		firstSuccessfulMatcher types.GomegaMatcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *OrMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		m.firstSuccessfulMatcher = nil
0000000000000000000000000000000000000000;;		for _, matcher := range m.Matchers {
0000000000000000000000000000000000000000;;			success, err := matcher.Match(actual)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if success {
0000000000000000000000000000000000000000;;				m.firstSuccessfulMatcher = matcher
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *OrMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		// not the most beautiful list of matchers, but not bad either...
0000000000000000000000000000000000000000;;		return format.Message(actual, fmt.Sprintf("To satisfy at least one of these matchers: %s", m.Matchers))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *OrMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return m.firstSuccessfulMatcher.NegatedFailureMessage(actual)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *OrMatcher) MatchMayChangeInTheFuture(actual interface{}) bool {
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Example with 3 matchers: A, B, C
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Match evaluates them: F, T, <?>  => T
0000000000000000000000000000000000000000;;			So match is currently T, what should MatchMayChangeInTheFuture() return?
0000000000000000000000000000000000000000;;			Seems like it only depends on B, since currently B MUST change to allow the result to become F
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Match eval: F, F, F  => F
0000000000000000000000000000000000000000;;			So match is currently F, what should MatchMayChangeInTheFuture() return?
0000000000000000000000000000000000000000;;			Seems to depend on ANY of them being able to change to T.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.firstSuccessfulMatcher != nil {
0000000000000000000000000000000000000000;;			// one of the matchers succeeded.. it must be able to change in order to affect the result
0000000000000000000000000000000000000000;;			return oraclematcher.MatchMayChangeInTheFuture(m.firstSuccessfulMatcher, actual)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// so all matchers failed.. Any one of them changing would change the result.
0000000000000000000000000000000000000000;;			for _, matcher := range m.Matchers {
0000000000000000000000000000000000000000;;				if oraclematcher.MatchMayChangeInTheFuture(matcher, actual) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false // none of were going to change
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
