0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Gomega is the Ginkgo BDD-style testing framework's preferred matcher library.
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/gomega_dsl.go[Godeps/_workspace/src/github.com/onsi/gomega/gomega_dsl.go][vendor/github.com/onsi/gomega/gomega_dsl.go];	
0000000000000000000000000000000000000000;;	The godoc documentation describes Gomega's API.  More comprehensive documentation (with examples!) is available at http://onsi.github.io/gomega/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Gomega on Github: http://github.com/onsi/gomega
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Learn more about Ginkgo online: http://onsi.github.io/ginkgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Ginkgo on Github: http://github.com/onsi/ginkgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Gomega is MIT-Licensed
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package gomega
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/internal/assertion"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/internal/asyncassertion"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/internal/testingtsupport"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const GOMEGA_VERSION = "1.0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const nilFailHandlerPanic = `You are trying to make an assertion, but Gomega's fail handler is nil.
0000000000000000000000000000000000000000;;	If you're using Ginkgo then you probably forgot to put your assertion in an It().
0000000000000000000000000000000000000000;;	Alternatively, you may have forgotten to register a fail handler with RegisterFailHandler() or RegisterTestingT().
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var globalFailHandler types.GomegaFailHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultEventuallyTimeout = time.Second
0000000000000000000000000000000000000000;;	var defaultEventuallyPollingInterval = 10 * time.Millisecond
0000000000000000000000000000000000000000;;	var defaultConsistentlyDuration = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	var defaultConsistentlyPollingInterval = 10 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//RegisterFailHandler connects Ginkgo to Gomega.  When a matcher fails
0000000000000000000000000000000000000000;;	//the fail handler passed into RegisterFailHandler is called.
0000000000000000000000000000000000000000;;	func RegisterFailHandler(handler types.GomegaFailHandler) {
0000000000000000000000000000000000000000;;		globalFailHandler = handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//RegisterTestingT connects Gomega to Golang's XUnit style
0000000000000000000000000000000000000000;;	//Testing.T tests.  You'll need to call this at the top of each XUnit style test:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// func TestFarmHasCow(t *testing.T) {
0000000000000000000000000000000000000000;;	//     RegisterTestingT(t)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	   f := farm.New([]string{"Cow", "Horse"})
0000000000000000000000000000000000000000;;	//     Expect(f.HasCow()).To(BeTrue(), "Farm should have cow")
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that this *testing.T is registered *globally* by Gomega (this is why you don't have to
0000000000000000000000000000000000000000;;	// pass `t` down to the matcher itself).  This means that you cannot run the XUnit style tests
0000000000000000000000000000000000000000;;	// in parallel as the global fail handler cannot point to more than one testing.T at a time.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// (As an aside: Ginkgo gets around this limitation by running parallel tests in different *processes*).
0000000000000000000000000000000000000000;;	func RegisterTestingT(t types.GomegaTestingT) {
0000000000000000000000000000000000000000;;		RegisterFailHandler(testingtsupport.BuildTestingTGomegaFailHandler(t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//InterceptGomegaHandlers runs a given callback and returns an array of
0000000000000000000000000000000000000000;;	//failure messages generated by any Gomega assertions within the callback.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//This is accomplished by temporarily replacing the *global* fail handler
0000000000000000000000000000000000000000;;	//with a fail handler that simply annotates failures.  The original fail handler
0000000000000000000000000000000000000000;;	//is reset when InterceptGomegaFailures returns.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//This is most useful when testing custom matchers, but can also be used to check
0000000000000000000000000000000000000000;;	//on a value using a Gomega assertion without causing a test failure.
0000000000000000000000000000000000000000;;	func InterceptGomegaFailures(f func()) []string {
0000000000000000000000000000000000000000;;		originalHandler := globalFailHandler
0000000000000000000000000000000000000000;;		failures := []string{}
0000000000000000000000000000000000000000;;		RegisterFailHandler(func(message string, callerSkip ...int) {
0000000000000000000000000000000000000000;;			failures = append(failures, message)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		f()
0000000000000000000000000000000000000000;;		RegisterFailHandler(originalHandler)
0000000000000000000000000000000000000000;;		return failures
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Ω wraps an actual value allowing assertions to be made on it:
0000000000000000000000000000000000000000;;	//	Ω("foo").Should(Equal("foo"))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//If Ω is passed more than one argument it will pass the *first* argument to the matcher.
0000000000000000000000000000000000000000;;	//All subsequent arguments will be required to be nil/zero.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//This is convenient if you want to make an assertion on a method/function that returns
0000000000000000000000000000000000000000;;	//a value and an error - a common patter in Go.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//For example, given a function with signature:
0000000000000000000000000000000000000000;;	//  func MyAmazingThing() (int, error)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Then:
0000000000000000000000000000000000000000;;	//    Ω(MyAmazingThing()).Should(Equal(3))
0000000000000000000000000000000000000000;;	//Will succeed only if `MyAmazingThing()` returns `(3, nil)`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Ω and Expect are identical
0000000000000000000000000000000000000000;;	func Ω(actual interface{}, extra ...interface{}) GomegaAssertion {
0000000000000000000000000000000000000000;;		return ExpectWithOffset(0, actual, extra...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Expect wraps an actual value allowing assertions to be made on it:
0000000000000000000000000000000000000000;;	//	Expect("foo").To(Equal("foo"))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//If Expect is passed more than one argument it will pass the *first* argument to the matcher.
0000000000000000000000000000000000000000;;	//All subsequent arguments will be required to be nil/zero.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//This is convenient if you want to make an assertion on a method/function that returns
0000000000000000000000000000000000000000;;	//a value and an error - a common patter in Go.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//For example, given a function with signature:
0000000000000000000000000000000000000000;;	//  func MyAmazingThing() (int, error)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Then:
0000000000000000000000000000000000000000;;	//    Expect(MyAmazingThing()).Should(Equal(3))
0000000000000000000000000000000000000000;;	//Will succeed only if `MyAmazingThing()` returns `(3, nil)`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Expect and Ω are identical
0000000000000000000000000000000000000000;;	func Expect(actual interface{}, extra ...interface{}) GomegaAssertion {
0000000000000000000000000000000000000000;;		return ExpectWithOffset(0, actual, extra...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//ExpectWithOffset wraps an actual value allowing assertions to be made on it:
0000000000000000000000000000000000000000;;	//    ExpectWithOffset(1, "foo").To(Equal("foo"))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Unlike `Expect` and `Ω`, `ExpectWithOffset` takes an additional integer argument
0000000000000000000000000000000000000000;;	//this is used to modify the call-stack offset when computing line numbers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//This is most useful in helper functions that make assertions.  If you want Gomega's
0000000000000000000000000000000000000000;;	//error message to refer to the calling line in the test (as opposed to the line in the helper function)
0000000000000000000000000000000000000000;;	//set the first argument of `ExpectWithOffset` appropriately.
0000000000000000000000000000000000000000;;	func ExpectWithOffset(offset int, actual interface{}, extra ...interface{}) GomegaAssertion {
0000000000000000000000000000000000000000;;		if globalFailHandler == nil {
0000000000000000000000000000000000000000;;			panic(nilFailHandlerPanic)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return assertion.New(actual, globalFailHandler, offset, extra...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Eventually wraps an actual value allowing assertions to be made on it.
0000000000000000000000000000000000000000;;	//The assertion is tried periodically until it passes or a timeout occurs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Both the timeout and polling interval are configurable as optional arguments:
0000000000000000000000000000000000000000;;	//The first optional argument is the timeout
0000000000000000000000000000000000000000;;	//The second optional argument is the polling interval
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Both intervals can either be specified as time.Duration, parsable duration strings or as floats/integers.  In the
0000000000000000000000000000000000000000;;	//last case they are interpreted as seconds.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//If Eventually is passed an actual that is a function taking no arguments and returning at least one value,
0000000000000000000000000000000000000000;;	//then Eventually will call the function periodically and try the matcher against the function's first return value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Eventually(func() int {
0000000000000000000000000000000000000000;;	//        return thingImPolling.Count()
0000000000000000000000000000000000000000;;	//    }).Should(BeNumerically(">=", 17))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Note that this example could be rewritten:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Eventually(thingImPolling.Count).Should(BeNumerically(">=", 17))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//If the function returns more than one value, then Eventually will pass the first value to the matcher and
0000000000000000000000000000000000000000;;	//assert that all other values are nil/zero.
0000000000000000000000000000000000000000;;	//This allows you to pass Eventually a function that returns a value and an error - a common pattern in Go.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//For example, consider a method that returns a value and an error:
0000000000000000000000000000000000000000;;	//    func FetchFromDB() (string, error)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Then
0000000000000000000000000000000000000000;;	//    Eventually(FetchFromDB).Should(Equal("hasselhoff"))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Will pass only if the the returned error is nil and the returned string passes the matcher.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Eventually's default timeout is 1 second, and its default polling interval is 10ms
0000000000000000000000000000000000000000;;	func Eventually(actual interface{}, intervals ...interface{}) GomegaAsyncAssertion {
0000000000000000000000000000000000000000;;		return EventuallyWithOffset(0, actual, intervals...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//EventuallyWithOffset operates like Eventually but takes an additional
0000000000000000000000000000000000000000;;	//initial argument to indicate an offset in the call stack.  This is useful when building helper
0000000000000000000000000000000000000000;;	//functions that contain matchers.  To learn more, read about `ExpectWithOffset`.
0000000000000000000000000000000000000000;;	func EventuallyWithOffset(offset int, actual interface{}, intervals ...interface{}) GomegaAsyncAssertion {
0000000000000000000000000000000000000000;;		if globalFailHandler == nil {
0000000000000000000000000000000000000000;;			panic(nilFailHandlerPanic)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeoutInterval := defaultEventuallyTimeout
0000000000000000000000000000000000000000;;		pollingInterval := defaultEventuallyPollingInterval
0000000000000000000000000000000000000000;;		if len(intervals) > 0 {
0000000000000000000000000000000000000000;;			timeoutInterval = toDuration(intervals[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(intervals) > 1 {
0000000000000000000000000000000000000000;;			pollingInterval = toDuration(intervals[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return asyncassertion.New(asyncassertion.AsyncAssertionTypeEventually, actual, globalFailHandler, timeoutInterval, pollingInterval, offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Consistently wraps an actual value allowing assertions to be made on it.
0000000000000000000000000000000000000000;;	//The assertion is tried periodically and is required to pass for a period of time.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Both the total time and polling interval are configurable as optional arguments:
0000000000000000000000000000000000000000;;	//The first optional argument is the duration that Consistently will run for
0000000000000000000000000000000000000000;;	//The second optional argument is the polling interval
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Both intervals can either be specified as time.Duration, parsable duration strings or as floats/integers.  In the
0000000000000000000000000000000000000000;;	//last case they are interpreted as seconds.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//If Consistently is passed an actual that is a function taking no arguments and returning at least one value,
0000000000000000000000000000000000000000;;	//then Consistently will call the function periodically and try the matcher against the function's first return value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//If the function returns more than one value, then Consistently will pass the first value to the matcher and
0000000000000000000000000000000000000000;;	//assert that all other values are nil/zero.
0000000000000000000000000000000000000000;;	//This allows you to pass Consistently a function that returns a value and an error - a common pattern in Go.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Consistently is useful in cases where you want to assert that something *does not happen* over a period of tiem.
0000000000000000000000000000000000000000;;	//For example, you want to assert that a goroutine does *not* send data down a channel.  In this case, you could:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  Consistently(channel).ShouldNot(Receive())
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Consistently's default duration is 100ms, and its default polling interval is 10ms
0000000000000000000000000000000000000000;;	func Consistently(actual interface{}, intervals ...interface{}) GomegaAsyncAssertion {
0000000000000000000000000000000000000000;;		return ConsistentlyWithOffset(0, actual, intervals...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//ConsistentlyWithOffset operates like Consistnetly but takes an additional
0000000000000000000000000000000000000000;;	//initial argument to indicate an offset in the call stack.  This is useful when building helper
0000000000000000000000000000000000000000;;	//functions that contain matchers.  To learn more, read about `ExpectWithOffset`.
0000000000000000000000000000000000000000;;	func ConsistentlyWithOffset(offset int, actual interface{}, intervals ...interface{}) GomegaAsyncAssertion {
0000000000000000000000000000000000000000;;		if globalFailHandler == nil {
0000000000000000000000000000000000000000;;			panic(nilFailHandlerPanic)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeoutInterval := defaultConsistentlyDuration
0000000000000000000000000000000000000000;;		pollingInterval := defaultConsistentlyPollingInterval
0000000000000000000000000000000000000000;;		if len(intervals) > 0 {
0000000000000000000000000000000000000000;;			timeoutInterval = toDuration(intervals[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(intervals) > 1 {
0000000000000000000000000000000000000000;;			pollingInterval = toDuration(intervals[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return asyncassertion.New(asyncassertion.AsyncAssertionTypeConsistently, actual, globalFailHandler, timeoutInterval, pollingInterval, offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Set the default timeout duration for Eventually.  Eventually will repeatedly poll your condition until it succeeds, or until this timeout elapses.
0000000000000000000000000000000000000000;;	func SetDefaultEventuallyTimeout(t time.Duration) {
0000000000000000000000000000000000000000;;		defaultEventuallyTimeout = t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Set the default polling interval for Eventually.
0000000000000000000000000000000000000000;;	func SetDefaultEventuallyPollingInterval(t time.Duration) {
0000000000000000000000000000000000000000;;		defaultEventuallyPollingInterval = t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Set the default duration for Consistently.  Consistently will verify that your condition is satsified for this long.
0000000000000000000000000000000000000000;;	func SetDefaultConsistentlyDuration(t time.Duration) {
0000000000000000000000000000000000000000;;		defaultConsistentlyDuration = t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Set the default polling interval for Consistently.
0000000000000000000000000000000000000000;;	func SetDefaultConsistentlyPollingInterval(t time.Duration) {
0000000000000000000000000000000000000000;;		defaultConsistentlyPollingInterval = t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GomegaAsyncAssertion is returned by Eventually and Consistently and polls the actual value passed into Eventually against
0000000000000000000000000000000000000000;;	//the matcher passed to the Should and ShouldNot methods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Both Should and ShouldNot take a variadic optionalDescription argument.  This is passed on to
0000000000000000000000000000000000000000;;	//fmt.Sprintf() and is used to annotate failure messages.  This allows you to make your failure messages more
0000000000000000000000000000000000000000;;	//descriptive
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Both Should and ShouldNot return a boolean that is true if the assertion passed and false if it failed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  Eventually(myChannel).Should(Receive(), "Something should have come down the pipe.")
0000000000000000000000000000000000000000;;	//  Consistently(myChannel).ShouldNot(Receive(), "Nothing should have come down the pipe.")
0000000000000000000000000000000000000000;;	type GomegaAsyncAssertion interface {
0000000000000000000000000000000000000000;;		Should(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
0000000000000000000000000000000000000000;;		ShouldNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//GomegaAssertion is returned by Ω and Expect and compares the actual value to the matcher
0000000000000000000000000000000000000000;;	//passed to the Should/ShouldNot and To/ToNot/NotTo methods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Typically Should/ShouldNot are used with Ω and To/ToNot/NotTo are used with Expect
0000000000000000000000000000000000000000;;	//though this is not enforced.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//All methods take a variadic optionalDescription argument.  This is passed on to fmt.Sprintf()
0000000000000000000000000000000000000000;;	//and is used to annotate failure messages.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//All methods return a bool that is true if hte assertion passed and false if it failed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   Ω(farm.HasCow()).Should(BeTrue(), "Farm %v should have a cow", farm)
0000000000000000000000000000000000000000;;	type GomegaAssertion interface {
0000000000000000000000000000000000000000;;		Should(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
0000000000000000000000000000000000000000;;		ShouldNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		To(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
0000000000000000000000000000000000000000;;		ToNot(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
0000000000000000000000000000000000000000;;		NotTo(matcher types.GomegaMatcher, optionalDescription ...interface{}) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//OmegaMatcher is deprecated in favor of the better-named and better-organized types.GomegaMatcher but sticks around to support existing code that uses it
0000000000000000000000000000000000000000;;	type OmegaMatcher types.GomegaMatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toDuration(input interface{}) time.Duration {
0000000000000000000000000000000000000000;;		duration, ok := input.(time.Duration)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return duration
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(input)
0000000000000000000000000000000000000000;;		kind := reflect.TypeOf(input).Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if reflect.Int <= kind && kind <= reflect.Int64 {
0000000000000000000000000000000000000000;;			return time.Duration(value.Int()) * time.Second
0000000000000000000000000000000000000000;;		} else if reflect.Uint <= kind && kind <= reflect.Uint64 {
0000000000000000000000000000000000000000;;			return time.Duration(value.Uint()) * time.Second
0000000000000000000000000000000000000000;;		} else if reflect.Float32 <= kind && kind <= reflect.Float64 {
0000000000000000000000000000000000000000;;			return time.Duration(value.Float() * float64(time.Second))
0000000000000000000000000000000000000000;;		} else if reflect.String == kind {
0000000000000000000000000000000000000000;;			duration, err := time.ParseDuration(value.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("%#v is not a valid parsable duration string.", input))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return duration
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("%v is not a valid interval.  Must be time.Duration, parsable duration string or a number.", input))
0000000000000000000000000000000000000000;;	}
