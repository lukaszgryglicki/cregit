0000000000000000000000000000000000000000;;	package gstruct
7a151748afd13eeb120eb98ff0e07bc6fb6c69b7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;		errorsutil "github.com/onsi/gomega/gstruct/errors"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchAllElements succeeds if every element of a slice matches the element matcher it maps to
0000000000000000000000000000000000000000;;	//through the id function, and every element matcher is matched.
0000000000000000000000000000000000000000;;	//  Expect([]string{"a", "b"}).To(MatchAllElements(idFn, matchers.Elements{
0000000000000000000000000000000000000000;;	//      "a": BeEqual("a"),
0000000000000000000000000000000000000000;;	//      "b": BeEqual("b"),
0000000000000000000000000000000000000000;;	//  })
0000000000000000000000000000000000000000;;	func MatchAllElements(identifier Identifier, elements Elements) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &ElementsMatcher{
0000000000000000000000000000000000000000;;			Identifier: identifier,
0000000000000000000000000000000000000000;;			Elements:   elements,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchElements succeeds if each element of a slice matches the element matcher it maps to
0000000000000000000000000000000000000000;;	//through the id function. It can ignore extra elements and/or missing elements.
0000000000000000000000000000000000000000;;	//  Expect([]string{"a", "c"}).To(MatchElements(idFn, IgnoreMissing|IgnoreExtra, matchers.Elements{
0000000000000000000000000000000000000000;;	//      "a": BeEqual("a")
0000000000000000000000000000000000000000;;	//      "b": BeEqual("b"),
0000000000000000000000000000000000000000;;	//  })
0000000000000000000000000000000000000000;;	func MatchElements(identifier Identifier, options Options, elements Elements) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &ElementsMatcher{
0000000000000000000000000000000000000000;;			Identifier:    identifier,
0000000000000000000000000000000000000000;;			Elements:      elements,
0000000000000000000000000000000000000000;;			IgnoreExtras:  options&IgnoreExtras != 0,
0000000000000000000000000000000000000000;;			IgnoreMissing: options&IgnoreMissing != 0,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ElementsMatcher is a NestingMatcher that applies custom matchers to each element of a slice mapped
0000000000000000000000000000000000000000;;	// by the Identifier function.
0000000000000000000000000000000000000000;;	// TODO: Extend this to work with arrays & maps (map the key) as well.
0000000000000000000000000000000000000000;;	type ElementsMatcher struct {
0000000000000000000000000000000000000000;;		// Matchers for each element.
0000000000000000000000000000000000000000;;		Elements Elements
0000000000000000000000000000000000000000;;		// Function mapping an element to the string key identifying its matcher.
0000000000000000000000000000000000000000;;		Identifier Identifier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether to ignore extra elements or consider it an error.
0000000000000000000000000000000000000000;;		IgnoreExtras bool
0000000000000000000000000000000000000000;;		// Whether to ignore missing elements or consider it an error.
0000000000000000000000000000000000000000;;		IgnoreMissing bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// State.
0000000000000000000000000000000000000000;;		failures []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Element ID to matcher.
0000000000000000000000000000000000000000;;	type Elements map[string]types.GomegaMatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function for identifying (mapping) elements.
0000000000000000000000000000000000000000;;	type Identifier func(element interface{}) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ElementsMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		if reflect.TypeOf(actual).Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("%v is type %T, expected slice", actual, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.failures = m.matchElements(actual)
0000000000000000000000000000000000000000;;		if len(m.failures) > 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ElementsMatcher) matchElements(actual interface{}) (errs []error) {
0000000000000000000000000000000000000000;;		// Provide more useful error messages in the case of a panic.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err := recover(); err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("panic checking %+v: %v\n%s", actual, err, debug.Stack()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(actual)
0000000000000000000000000000000000000000;;		elements := map[string]bool{}
0000000000000000000000000000000000000000;;		for i := 0; i < val.Len(); i++ {
0000000000000000000000000000000000000000;;			element := val.Index(i).Interface()
0000000000000000000000000000000000000000;;			id := m.Identifier(element)
0000000000000000000000000000000000000000;;			// TODO: Add options to ignore & match duplicates.
0000000000000000000000000000000000000000;;			if elements[id] {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("found duplicate element ID %s", id))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			elements[id] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			matcher, expected := m.Elements[id]
0000000000000000000000000000000000000000;;			if !expected {
0000000000000000000000000000000000000000;;				if !m.IgnoreExtras {
0000000000000000000000000000000000000000;;					errs = append(errs, fmt.Errorf("unexpected element %s", id))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			match, err := matcher.Match(element)
0000000000000000000000000000000000000000;;			if match {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if nesting, ok := matcher.(errorsutil.NestingMatcher); ok {
0000000000000000000000000000000000000000;;					err = errorsutil.AggregateError(nesting.Failures())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = errors.New(matcher.FailureMessage(element))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errs = append(errs, errorsutil.Nest(fmt.Sprintf("[%s]", id), err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for id := range m.Elements {
0000000000000000000000000000000000000000;;			if !elements[id] && !m.IgnoreMissing {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("missing expected element %s", id))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ElementsMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		failure := errorsutil.AggregateError(m.failures)
0000000000000000000000000000000000000000;;		return format.Message(actual, fmt.Sprintf("to match elements: %v", failure))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ElementsMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "not to match elements")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ElementsMatcher) Failures() []error {
0000000000000000000000000000000000000000;;		return m.failures
0000000000000000000000000000000000000000;;	}
