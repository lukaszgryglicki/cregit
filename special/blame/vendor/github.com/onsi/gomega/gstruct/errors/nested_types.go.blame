0000000000000000000000000000000000000000;;	package errors
7a151748afd13eeb120eb98ff0e07bc6fb6c69b7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A stateful matcher that nests other matchers within it and preserves the error types of the
0000000000000000000000000000000000000000;;	// nested matcher failures.
0000000000000000000000000000000000000000;;	type NestingMatcher interface {
0000000000000000000000000000000000000000;;		types.GomegaMatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns the failures of nested matchers.
0000000000000000000000000000000000000000;;		Failures() []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An error type for labeling errors on deeply nested matchers.
0000000000000000000000000000000000000000;;	type NestedError struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		Err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *NestedError) Error() string {
0000000000000000000000000000000000000000;;		// Indent Errors.
0000000000000000000000000000000000000000;;		indented := strings.Replace(e.Err.Error(), "\n", "\n\t", -1)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s:\n\t%v", e.Path, indented)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a NestedError with the given path.
0000000000000000000000000000000000000000;;	// If err is a NestedError, prepend the path to it.
0000000000000000000000000000000000000000;;	// If err is an AggregateError, recursively Nest each error.
0000000000000000000000000000000000000000;;	func Nest(path string, err error) error {
0000000000000000000000000000000000000000;;		if ag, ok := err.(AggregateError); ok {
0000000000000000000000000000000000000000;;			var errs AggregateError
0000000000000000000000000000000000000000;;			for _, e := range ag {
0000000000000000000000000000000000000000;;				errs = append(errs, Nest(path, e))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return errs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ne, ok := err.(*NestedError); ok {
0000000000000000000000000000000000000000;;			return &NestedError{
0000000000000000000000000000000000000000;;				Path: path + ne.Path,
0000000000000000000000000000000000000000;;				Err:  ne.Err,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &NestedError{
0000000000000000000000000000000000000000;;			Path: path,
0000000000000000000000000000000000000000;;			Err:  err,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An error type for treating multiple errors as a single error.
0000000000000000000000000000000000000000;;	type AggregateError []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error is part of the error interface.
0000000000000000000000000000000000000000;;	func (err AggregateError) Error() string {
0000000000000000000000000000000000000000;;		if len(err) == 0 {
0000000000000000000000000000000000000000;;			// This should never happen, really.
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(err) == 1 {
0000000000000000000000000000000000000000;;			return err[0].Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := fmt.Sprintf("[%s", err[0].Error())
0000000000000000000000000000000000000000;;		for i := 1; i < len(err); i++ {
0000000000000000000000000000000000000000;;			result += fmt.Sprintf(", %s", err[i].Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result += "]"
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
