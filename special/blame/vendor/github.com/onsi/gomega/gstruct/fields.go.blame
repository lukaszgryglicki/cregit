0000000000000000000000000000000000000000;;	package gstruct
7a151748afd13eeb120eb98ff0e07bc6fb6c69b7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/format"
0000000000000000000000000000000000000000;;		errorsutil "github.com/onsi/gomega/gstruct/errors"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchAllFields succeeds if every field of a struct matches the field matcher associated with
0000000000000000000000000000000000000000;;	//it, and every element matcher is matched.
0000000000000000000000000000000000000000;;	//  Expect([]string{"a", "b"}).To(MatchAllFields(idFn, gstruct.Fields{
0000000000000000000000000000000000000000;;	//      "a": BeEqual("a"),
0000000000000000000000000000000000000000;;	//      "b": BeEqual("b"),
0000000000000000000000000000000000000000;;	//  })
0000000000000000000000000000000000000000;;	func MatchAllFields(fields Fields) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &FieldsMatcher{
0000000000000000000000000000000000000000;;			Fields: fields,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchFields succeeds if each element of a struct matches the field matcher associated with
0000000000000000000000000000000000000000;;	//it. It can ignore extra fields and/or missing fields.
0000000000000000000000000000000000000000;;	//  Expect([]string{"a", "c"}).To(MatchFields(idFn, IgnoreMissing|IgnoreExtra, gstruct.Fields{
0000000000000000000000000000000000000000;;	//      "a": BeEqual("a")
0000000000000000000000000000000000000000;;	//      "b": BeEqual("b"),
0000000000000000000000000000000000000000;;	//  })
0000000000000000000000000000000000000000;;	func MatchFields(options Options, fields Fields) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &FieldsMatcher{
0000000000000000000000000000000000000000;;			Fields:        fields,
0000000000000000000000000000000000000000;;			IgnoreExtras:  options&IgnoreExtras != 0,
0000000000000000000000000000000000000000;;			IgnoreMissing: options&IgnoreMissing != 0,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FieldsMatcher struct {
0000000000000000000000000000000000000000;;		// Matchers for each field.
0000000000000000000000000000000000000000;;		Fields Fields
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether to ignore extra elements or consider it an error.
0000000000000000000000000000000000000000;;		IgnoreExtras bool
0000000000000000000000000000000000000000;;		// Whether to ignore missing elements or consider it an error.
0000000000000000000000000000000000000000;;		IgnoreMissing bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// State.
0000000000000000000000000000000000000000;;		failures []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Field name to matcher.
0000000000000000000000000000000000000000;;	type Fields map[string]types.GomegaMatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *FieldsMatcher) Match(actual interface{}) (success bool, err error) {
0000000000000000000000000000000000000000;;		if reflect.TypeOf(actual).Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("%v is type %T, expected struct", actual, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.failures = m.matchFields(actual)
0000000000000000000000000000000000000000;;		if len(m.failures) > 0 {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *FieldsMatcher) matchFields(actual interface{}) (errs []error) {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(actual)
0000000000000000000000000000000000000000;;		typ := val.Type()
0000000000000000000000000000000000000000;;		fields := map[string]bool{}
0000000000000000000000000000000000000000;;		for i := 0; i < val.NumField(); i++ {
0000000000000000000000000000000000000000;;			fieldName := typ.Field(i).Name
0000000000000000000000000000000000000000;;			fields[fieldName] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := func() (err error) {
0000000000000000000000000000000000000000;;				// This test relies heavily on reflect, which tends to panic.
0000000000000000000000000000000000000000;;				// Recover here to provide more useful error messages in that case.
0000000000000000000000000000000000000000;;				defer func() {
0000000000000000000000000000000000000000;;					if r := recover(); r != nil {
0000000000000000000000000000000000000000;;						err = fmt.Errorf("panic checking %+v: %v\n%s", actual, r, debug.Stack())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				matcher, expected := m.Fields[fieldName]
0000000000000000000000000000000000000000;;				if !expected {
0000000000000000000000000000000000000000;;					if !m.IgnoreExtras {
0000000000000000000000000000000000000000;;						return fmt.Errorf("unexpected field %s: %+v", fieldName, actual)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var field interface{}
0000000000000000000000000000000000000000;;				if val.Field(i).IsValid() {
0000000000000000000000000000000000000000;;					field = val.Field(i).Interface()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					field = reflect.Zero(typ.Field(i).Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				match, err := matcher.Match(field)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				} else if !match {
0000000000000000000000000000000000000000;;					if nesting, ok := matcher.(errorsutil.NestingMatcher); ok {
0000000000000000000000000000000000000000;;						return errorsutil.AggregateError(nesting.Failures())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return errors.New(matcher.FailureMessage(field))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, errorsutil.Nest("."+fieldName, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for field := range m.Fields {
0000000000000000000000000000000000000000;;			if !fields[field] && !m.IgnoreMissing {
0000000000000000000000000000000000000000;;				errs = append(errs, fmt.Errorf("missing expected field %s", field))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *FieldsMatcher) FailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		failures := make([]string, len(m.failures))
0000000000000000000000000000000000000000;;		for i := range m.failures {
0000000000000000000000000000000000000000;;			failures[i] = m.failures[i].Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return format.Message(reflect.TypeOf(actual).Name(),
0000000000000000000000000000000000000000;;			fmt.Sprintf("to match fields: {\n%v\n}\n", strings.Join(failures, "\n")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *FieldsMatcher) NegatedFailureMessage(actual interface{}) (message string) {
0000000000000000000000000000000000000000;;		return format.Message(actual, "not to match fields")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *FieldsMatcher) Failures() []error {
0000000000000000000000000000000000000000;;		return m.failures
0000000000000000000000000000000000000000;;	}
