0000000000000000000000000000000000000000;;	package gomega
b73404a9ae80480b33bb3fbee1057ced8f9e176a;Godeps/_workspace/src/github.com/onsi/gomega/matchers.go[Godeps/_workspace/src/github.com/onsi/gomega/matchers.go][vendor/github.com/onsi/gomega/matchers.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/matchers"
0000000000000000000000000000000000000000;;		"github.com/onsi/gomega/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Equal uses reflect.DeepEqual to compare actual with expected.  Equal is strict about
0000000000000000000000000000000000000000;;	//types when performing comparisons.
0000000000000000000000000000000000000000;;	//It is an error for both actual and expected to be nil.  Use BeNil() instead.
0000000000000000000000000000000000000000;;	func Equal(expected interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.EqualMatcher{
0000000000000000000000000000000000000000;;			Expected: expected,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeEquivalentTo is more lax than Equal, allowing equality between different types.
0000000000000000000000000000000000000000;;	//This is done by converting actual to have the type of expected before
0000000000000000000000000000000000000000;;	//attempting equality with reflect.DeepEqual.
0000000000000000000000000000000000000000;;	//It is an error for actual and expected to be nil.  Use BeNil() instead.
0000000000000000000000000000000000000000;;	func BeEquivalentTo(expected interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeEquivalentToMatcher{
0000000000000000000000000000000000000000;;			Expected: expected,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeIdenticalTo uses the == operator to compare actual with expected.
0000000000000000000000000000000000000000;;	//BeIdenticalTo is strict about types when performing comparisons.
0000000000000000000000000000000000000000;;	//It is an error for both actual and expected to be nil.  Use BeNil() instead.
0000000000000000000000000000000000000000;;	func BeIdenticalTo(expected interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeIdenticalToMatcher{
0000000000000000000000000000000000000000;;			Expected: expected,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeNil succeeds if actual is nil
0000000000000000000000000000000000000000;;	func BeNil() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeNilMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeTrue succeeds if actual is true
0000000000000000000000000000000000000000;;	func BeTrue() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeTrueMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeFalse succeeds if actual is false
0000000000000000000000000000000000000000;;	func BeFalse() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeFalseMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//HaveOccurred succeeds if actual is a non-nil error
0000000000000000000000000000000000000000;;	//The typical Go error checking pattern looks like:
0000000000000000000000000000000000000000;;	//    err := SomethingThatMightFail()
0000000000000000000000000000000000000000;;	//    Ω(err).ShouldNot(HaveOccurred())
0000000000000000000000000000000000000000;;	func HaveOccurred() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.HaveOccurredMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Succeed passes if actual is a nil error
0000000000000000000000000000000000000000;;	//Succeed is intended to be used with functions that return a single error value. Instead of
0000000000000000000000000000000000000000;;	//    err := SomethingThatMightFail()
0000000000000000000000000000000000000000;;	//    Ω(err).ShouldNot(HaveOccurred())
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//You can write:
0000000000000000000000000000000000000000;;	//    Ω(SomethingThatMightFail()).Should(Succeed())
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//It is a mistake to use Succeed with a function that has multiple return values.  Gomega's Ω and Expect
0000000000000000000000000000000000000000;;	//functions automatically trigger failure if any return values after the first return value are non-zero/non-nil.
0000000000000000000000000000000000000000;;	//This means that Ω(MultiReturnFunc()).ShouldNot(Succeed()) can never pass.
0000000000000000000000000000000000000000;;	func Succeed() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.SucceedMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchError succeeds if actual is a non-nil error that matches the passed in string/error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//These are valid use-cases:
0000000000000000000000000000000000000000;;	//  Ω(err).Should(MatchError("an error")) //asserts that err.Error() == "an error"
0000000000000000000000000000000000000000;;	//  Ω(err).Should(MatchError(SomeError)) //asserts that err == SomeError (via reflect.DeepEqual)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//It is an error for err to be nil or an object that does not implement the Error interface
0000000000000000000000000000000000000000;;	func MatchError(expected interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.MatchErrorMatcher{
0000000000000000000000000000000000000000;;			Expected: expected,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeClosed succeeds if actual is a closed channel.
0000000000000000000000000000000000000000;;	//It is an error to pass a non-channel to BeClosed, it is also an error to pass nil
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//In order to check whether or not the channel is closed, Gomega must try to read from the channel
0000000000000000000000000000000000000000;;	//(even in the `ShouldNot(BeClosed())` case).  You should keep this in mind if you wish to make subsequent assertions about
0000000000000000000000000000000000000000;;	//values coming down the channel.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Also, if you are testing that a *buffered* channel is closed you must first read all values out of the channel before
0000000000000000000000000000000000000000;;	//asserting that it is closed (it is not possible to detect that a buffered-channel has been closed until all its buffered values are read).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Finally, as a corollary: it is an error to check whether or not a send-only channel is closed.
0000000000000000000000000000000000000000;;	func BeClosed() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeClosedMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Receive succeeds if there is a value to be received on actual.
0000000000000000000000000000000000000000;;	//Actual must be a channel (and cannot be a send-only channel) -- anything else is an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Receive returns immediately and never blocks:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//- If there is nothing on the channel `c` then Ω(c).Should(Receive()) will fail and Ω(c).ShouldNot(Receive()) will pass.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//- If the channel `c` is closed then Ω(c).Should(Receive()) will fail and Ω(c).ShouldNot(Receive()) will pass.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//- If there is something on the channel `c` ready to be read, then Ω(c).Should(Receive()) will pass and Ω(c).ShouldNot(Receive()) will fail.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//If you have a go-routine running in the background that will write to channel `c` you can:
0000000000000000000000000000000000000000;;	//    Eventually(c).Should(Receive())
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//This will timeout if nothing gets sent to `c` (you can modify the timeout interval as you normally do with `Eventually`)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//A similar use-case is to assert that no go-routine writes to a channel (for a period of time).  You can do this with `Consistently`:
0000000000000000000000000000000000000000;;	//    Consistently(c).ShouldNot(Receive())
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//You can pass `Receive` a matcher.  If you do so, it will match the received object against the matcher.  For example:
0000000000000000000000000000000000000000;;	//    Ω(c).Should(Receive(Equal("foo")))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//When given a matcher, `Receive` will always fail if there is nothing to be received on the channel.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Passing Receive a matcher is especially useful when paired with Eventually:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Eventually(c).Should(Receive(ContainSubstring("bar")))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//will repeatedly attempt to pull values out of `c` until a value matching "bar" is received.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Finally, if you want to have a reference to the value *sent* to the channel you can pass the `Receive` matcher a pointer to a variable of the appropriate type:
0000000000000000000000000000000000000000;;	//    var myThing thing
0000000000000000000000000000000000000000;;	//    Eventually(thingChan).Should(Receive(&myThing))
0000000000000000000000000000000000000000;;	//    Ω(myThing.Sprocket).Should(Equal("foo"))
0000000000000000000000000000000000000000;;	//    Ω(myThing.IsValid()).Should(BeTrue())
0000000000000000000000000000000000000000;;	func Receive(args ...interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		var arg interface{}
0000000000000000000000000000000000000000;;		if len(args) > 0 {
0000000000000000000000000000000000000000;;			arg = args[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &matchers.ReceiveMatcher{
0000000000000000000000000000000000000000;;			Arg: arg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeSent succeeds if a value can be sent to actual.
0000000000000000000000000000000000000000;;	//Actual must be a channel (and cannot be a receive-only channel) that can sent the type of the value passed into BeSent -- anything else is an error.
0000000000000000000000000000000000000000;;	//In addition, actual must not be closed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//BeSent never blocks:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//- If the channel `c` is not ready to receive then Ω(c).Should(BeSent("foo")) will fail immediately
0000000000000000000000000000000000000000;;	//- If the channel `c` is eventually ready to receive then Eventually(c).Should(BeSent("foo")) will succeed.. presuming the channel becomes ready to receive  before Eventually's timeout
0000000000000000000000000000000000000000;;	//- If the channel `c` is closed then Ω(c).Should(BeSent("foo")) and Ω(c).ShouldNot(BeSent("foo")) will both fail immediately
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Of course, the value is actually sent to the channel.  The point of `BeSent` is less to make an assertion about the availability of the channel (which is typically an implementation detail that your test should not be concerned with).
0000000000000000000000000000000000000000;;	//Rather, the point of `BeSent` is to make it possible to easily and expressively write tests that can timeout on blocked channel sends.
0000000000000000000000000000000000000000;;	func BeSent(arg interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeSentMatcher{
0000000000000000000000000000000000000000;;			Arg: arg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchRegexp succeeds if actual is a string or stringer that matches the
0000000000000000000000000000000000000000;;	//passed-in regexp.  Optional arguments can be provided to construct a regexp
0000000000000000000000000000000000000000;;	//via fmt.Sprintf().
0000000000000000000000000000000000000000;;	func MatchRegexp(regexp string, args ...interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.MatchRegexpMatcher{
0000000000000000000000000000000000000000;;			Regexp: regexp,
0000000000000000000000000000000000000000;;			Args:   args,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//ContainSubstring succeeds if actual is a string or stringer that contains the
0000000000000000000000000000000000000000;;	//passed-in regexp.  Optional arguments can be provided to construct the substring
0000000000000000000000000000000000000000;;	//via fmt.Sprintf().
0000000000000000000000000000000000000000;;	func ContainSubstring(substr string, args ...interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.ContainSubstringMatcher{
0000000000000000000000000000000000000000;;			Substr: substr,
0000000000000000000000000000000000000000;;			Args:   args,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//HavePrefix succeeds if actual is a string or stringer that contains the
0000000000000000000000000000000000000000;;	//passed-in string as a prefix.  Optional arguments can be provided to construct
0000000000000000000000000000000000000000;;	//via fmt.Sprintf().
0000000000000000000000000000000000000000;;	func HavePrefix(prefix string, args ...interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.HavePrefixMatcher{
0000000000000000000000000000000000000000;;			Prefix: prefix,
0000000000000000000000000000000000000000;;			Args:   args,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//HaveSuffix succeeds if actual is a string or stringer that contains the
0000000000000000000000000000000000000000;;	//passed-in string as a suffix.  Optional arguments can be provided to construct
0000000000000000000000000000000000000000;;	//via fmt.Sprintf().
0000000000000000000000000000000000000000;;	func HaveSuffix(suffix string, args ...interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.HaveSuffixMatcher{
0000000000000000000000000000000000000000;;			Suffix: suffix,
0000000000000000000000000000000000000000;;			Args:   args,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchJSON succeeds if actual is a string or stringer of JSON that matches
0000000000000000000000000000000000000000;;	//the expected JSON.  The JSONs are decoded and the resulting objects are compared via
0000000000000000000000000000000000000000;;	//reflect.DeepEqual so things like key-ordering and whitespace shouldn't matter.
0000000000000000000000000000000000000000;;	func MatchJSON(json interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.MatchJSONMatcher{
0000000000000000000000000000000000000000;;			JSONToMatch: json,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MatchYAML succeeds if actual is a string or stringer of YAML that matches
0000000000000000000000000000000000000000;;	//the expected YAML.  The YAML's are decoded and the resulting objects are compared via
0000000000000000000000000000000000000000;;	//reflect.DeepEqual so things like key-ordering and whitespace shouldn't matter.
0000000000000000000000000000000000000000;;	func MatchYAML(yaml interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.MatchYAMLMatcher{
0000000000000000000000000000000000000000;;			YAMLToMatch: yaml,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeEmpty succeeds if actual is empty.  Actual must be of type string, array, map, chan, or slice.
0000000000000000000000000000000000000000;;	func BeEmpty() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeEmptyMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//HaveLen succeeds if actual has the passed-in length.  Actual must be of type string, array, map, chan, or slice.
0000000000000000000000000000000000000000;;	func HaveLen(count int) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.HaveLenMatcher{
0000000000000000000000000000000000000000;;			Count: count,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//HaveCap succeeds if actual has the passed-in capacity.  Actual must be of type array, chan, or slice.
0000000000000000000000000000000000000000;;	func HaveCap(count int) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.HaveCapMatcher{
0000000000000000000000000000000000000000;;			Count: count,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeZero succeeds if actual is the zero value for its type or if actual is nil.
0000000000000000000000000000000000000000;;	func BeZero() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeZeroMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//ContainElement succeeds if actual contains the passed in element.
0000000000000000000000000000000000000000;;	//By default ContainElement() uses Equal() to perform the match, however a
0000000000000000000000000000000000000000;;	//matcher can be passed in instead:
0000000000000000000000000000000000000000;;	//    Ω([]string{"Foo", "FooBar"}).Should(ContainElement(ContainSubstring("Bar")))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Actual must be an array, slice or map.
0000000000000000000000000000000000000000;;	//For maps, ContainElement searches through the map's values.
0000000000000000000000000000000000000000;;	func ContainElement(element interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.ContainElementMatcher{
0000000000000000000000000000000000000000;;			Element: element,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//ConsistOf succeeds if actual contains preciely the elements passed into the matcher.  The ordering of the elements does not matter.
0000000000000000000000000000000000000000;;	//By default ConsistOf() uses Equal() to match the elements, however custom matchers can be passed in instead.  Here are some examples:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Ω([]string{"Foo", "FooBar"}).Should(ConsistOf("FooBar", "Foo"))
0000000000000000000000000000000000000000;;	//    Ω([]string{"Foo", "FooBar"}).Should(ConsistOf(ContainSubstring("Bar"), "Foo"))
0000000000000000000000000000000000000000;;	//    Ω([]string{"Foo", "FooBar"}).Should(ConsistOf(ContainSubstring("Foo"), ContainSubstring("Foo")))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Actual must be an array, slice or map.  For maps, ConsistOf matches against the map's values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//You typically pass variadic arguments to ConsistOf (as in the examples above).  However, if you need to pass in a slice you can provided that it
0000000000000000000000000000000000000000;;	//is the only element passed in to ConsistOf:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Ω([]string{"Foo", "FooBar"}).Should(ConsistOf([]string{"FooBar", "Foo"}))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Note that Go's type system does not allow you to write this as ConsistOf([]string{"FooBar", "Foo"}...) as []string and []interface{} are different types - hence the need for this special rule.
0000000000000000000000000000000000000000;;	func ConsistOf(elements ...interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.ConsistOfMatcher{
0000000000000000000000000000000000000000;;			Elements: elements,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//HaveKey succeeds if actual is a map with the passed in key.
0000000000000000000000000000000000000000;;	//By default HaveKey uses Equal() to perform the match, however a
0000000000000000000000000000000000000000;;	//matcher can be passed in instead:
0000000000000000000000000000000000000000;;	//    Ω(map[string]string{"Foo": "Bar", "BazFoo": "Duck"}).Should(HaveKey(MatchRegexp(`.+Foo$`)))
0000000000000000000000000000000000000000;;	func HaveKey(key interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.HaveKeyMatcher{
0000000000000000000000000000000000000000;;			Key: key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//HaveKeyWithValue succeeds if actual is a map with the passed in key and value.
0000000000000000000000000000000000000000;;	//By default HaveKeyWithValue uses Equal() to perform the match, however a
0000000000000000000000000000000000000000;;	//matcher can be passed in instead:
0000000000000000000000000000000000000000;;	//    Ω(map[string]string{"Foo": "Bar", "BazFoo": "Duck"}).Should(HaveKeyWithValue("Foo", "Bar"))
0000000000000000000000000000000000000000;;	//    Ω(map[string]string{"Foo": "Bar", "BazFoo": "Duck"}).Should(HaveKeyWithValue(MatchRegexp(`.+Foo$`), "Bar"))
0000000000000000000000000000000000000000;;	func HaveKeyWithValue(key interface{}, value interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.HaveKeyWithValueMatcher{
0000000000000000000000000000000000000000;;			Key:   key,
0000000000000000000000000000000000000000;;			Value: value,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeNumerically performs numerical assertions in a type-agnostic way.
0000000000000000000000000000000000000000;;	//Actual and expected should be numbers, though the specific type of
0000000000000000000000000000000000000000;;	//number is irrelevant (floa32, float64, uint8, etc...).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//There are six, self-explanatory, supported comparators:
0000000000000000000000000000000000000000;;	//    Ω(1.0).Should(BeNumerically("==", 1))
0000000000000000000000000000000000000000;;	//    Ω(1.0).Should(BeNumerically("~", 0.999, 0.01))
0000000000000000000000000000000000000000;;	//    Ω(1.0).Should(BeNumerically(">", 0.9))
0000000000000000000000000000000000000000;;	//    Ω(1.0).Should(BeNumerically(">=", 1.0))
0000000000000000000000000000000000000000;;	//    Ω(1.0).Should(BeNumerically("<", 3))
0000000000000000000000000000000000000000;;	//    Ω(1.0).Should(BeNumerically("<=", 1.0))
0000000000000000000000000000000000000000;;	func BeNumerically(comparator string, compareTo ...interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeNumericallyMatcher{
0000000000000000000000000000000000000000;;			Comparator: comparator,
0000000000000000000000000000000000000000;;			CompareTo:  compareTo,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeTemporally compares time.Time's like BeNumerically
0000000000000000000000000000000000000000;;	//Actual and expected must be time.Time. The comparators are the same as for BeNumerically
0000000000000000000000000000000000000000;;	//    Ω(time.Now()).Should(BeTemporally(">", time.Time{}))
0000000000000000000000000000000000000000;;	//    Ω(time.Now()).Should(BeTemporally("~", time.Now(), time.Second))
0000000000000000000000000000000000000000;;	func BeTemporally(comparator string, compareTo time.Time, threshold ...time.Duration) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeTemporallyMatcher{
0000000000000000000000000000000000000000;;			Comparator: comparator,
0000000000000000000000000000000000000000;;			CompareTo:  compareTo,
0000000000000000000000000000000000000000;;			Threshold:  threshold,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeAssignableToTypeOf succeeds if actual is assignable to the type of expected.
0000000000000000000000000000000000000000;;	//It will return an error when one of the values is nil.
0000000000000000000000000000000000000000;;	//	  Ω(0).Should(BeAssignableToTypeOf(0))         // Same values
0000000000000000000000000000000000000000;;	//	  Ω(5).Should(BeAssignableToTypeOf(-1))        // different values same type
0000000000000000000000000000000000000000;;	//	  Ω("foo").Should(BeAssignableToTypeOf("bar")) // different values same type
0000000000000000000000000000000000000000;;	//    Ω(struct{ Foo string }{}).Should(BeAssignableToTypeOf(struct{ Foo string }{}))
0000000000000000000000000000000000000000;;	func BeAssignableToTypeOf(expected interface{}) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.AssignableToTypeOfMatcher{
0000000000000000000000000000000000000000;;			Expected: expected,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Panic succeeds if actual is a function that, when invoked, panics.
0000000000000000000000000000000000000000;;	//Actual must be a function that takes no arguments and returns no results.
0000000000000000000000000000000000000000;;	func Panic() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.PanicMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeAnExistingFile succeeds if a file exists.
0000000000000000000000000000000000000000;;	//Actual must be a string representing the abs path to the file being checked.
0000000000000000000000000000000000000000;;	func BeAnExistingFile() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeAnExistingFileMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeARegularFile succeeds iff a file exists and is a regular file.
0000000000000000000000000000000000000000;;	//Actual must be a string representing the abs path to the file being checked.
0000000000000000000000000000000000000000;;	func BeARegularFile() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeARegularFileMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BeADirectory succeeds iff a file exists and is a directory.
0000000000000000000000000000000000000000;;	//Actual must be a string representing the abs path to the file being checked.
0000000000000000000000000000000000000000;;	func BeADirectory() types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.BeADirectoryMatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//And succeeds only if all of the given matchers succeed.
0000000000000000000000000000000000000000;;	//The matchers are tried in order, and will fail-fast if one doesn't succeed.
0000000000000000000000000000000000000000;;	//  Expect("hi").To(And(HaveLen(2), Equal("hi"))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.
0000000000000000000000000000000000000000;;	func And(ms ...types.GomegaMatcher) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.AndMatcher{Matchers: ms}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//SatisfyAll is an alias for And().
0000000000000000000000000000000000000000;;	//  Ω("hi").Should(SatisfyAll(HaveLen(2), Equal("hi")))
0000000000000000000000000000000000000000;;	func SatisfyAll(matchers ...types.GomegaMatcher) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return And(matchers...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Or succeeds if any of the given matchers succeed.
0000000000000000000000000000000000000000;;	//The matchers are tried in order and will return immediately upon the first successful match.
0000000000000000000000000000000000000000;;	//  Expect("hi").To(Or(HaveLen(3), HaveLen(2))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.
0000000000000000000000000000000000000000;;	func Or(ms ...types.GomegaMatcher) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.OrMatcher{Matchers: ms}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//SatisfyAny is an alias for Or().
0000000000000000000000000000000000000000;;	//  Expect("hi").SatisfyAny(Or(HaveLen(3), HaveLen(2))
0000000000000000000000000000000000000000;;	func SatisfyAny(matchers ...types.GomegaMatcher) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return Or(matchers...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//Not negates the given matcher; it succeeds if the given matcher fails.
0000000000000000000000000000000000000000;;	//  Expect(1).To(Not(Equal(2))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.
0000000000000000000000000000000000000000;;	func Not(matcher types.GomegaMatcher) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return &matchers.NotMatcher{Matcher: matcher}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//WithTransform applies the `transform` to the actual value and matches it against `matcher`.
0000000000000000000000000000000000000000;;	//The given transform must be a function of one parameter that returns one value.
0000000000000000000000000000000000000000;;	//  var plus1 = func(i int) int { return i + 1 }
0000000000000000000000000000000000000000;;	//  Expect(1).To(WithTransform(plus1, Equal(2))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//And(), Or(), Not() and WithTransform() allow matchers to be composed into complex expressions.
0000000000000000000000000000000000000000;;	func WithTransform(transform interface{}, matcher types.GomegaMatcher) types.GomegaMatcher {
0000000000000000000000000000000000000000;;		return matchers.NewWithTransformMatcher(transform, matcher)
0000000000000000000000000000000000000000;;	}
