0000000000000000000000000000000000000000;;	package circbuf
79e993adf8a2fecb562434177834558fb4b60a71;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Buffer implements a circular buffer. It is a fixed size,
0000000000000000000000000000000000000000;;	// and new writes overwrite older data, such that for a buffer
0000000000000000000000000000000000000000;;	// of size N, for any amount of writes, only the last N bytes
0000000000000000000000000000000000000000;;	// are retained.
0000000000000000000000000000000000000000;;	type Buffer struct {
0000000000000000000000000000000000000000;;		data        []byte
0000000000000000000000000000000000000000;;		size        int64
0000000000000000000000000000000000000000;;		writeCursor int64
0000000000000000000000000000000000000000;;		written     int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBuffer creates a new buffer of a given size. The size
0000000000000000000000000000000000000000;;	// must be greater than 0.
0000000000000000000000000000000000000000;;	func NewBuffer(size int64) (*Buffer, error) {
0000000000000000000000000000000000000000;;		if size <= 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Size must be positive")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := &Buffer{
0000000000000000000000000000000000000000;;			size: size,
0000000000000000000000000000000000000000;;			data: make([]byte, size),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes up to len(buf) bytes to the internal ring,
0000000000000000000000000000000000000000;;	// overriding older data if necessary.
0000000000000000000000000000000000000000;;	func (b *Buffer) Write(buf []byte) (int, error) {
0000000000000000000000000000000000000000;;		// Account for total bytes written
0000000000000000000000000000000000000000;;		n := len(buf)
0000000000000000000000000000000000000000;;		b.written += int64(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the buffer is larger than ours, then we only care
0000000000000000000000000000000000000000;;		// about the last size bytes anyways
0000000000000000000000000000000000000000;;		if int64(n) > b.size {
0000000000000000000000000000000000000000;;			buf = buf[int64(n)-b.size:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy in place
0000000000000000000000000000000000000000;;		remain := b.size - b.writeCursor
0000000000000000000000000000000000000000;;		copy(b.data[b.writeCursor:], buf)
0000000000000000000000000000000000000000;;		if int64(len(buf)) > remain {
0000000000000000000000000000000000000000;;			copy(b.data, buf[remain:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update location of the cursor
0000000000000000000000000000000000000000;;		b.writeCursor = ((b.writeCursor + int64(len(buf))) % b.size)
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns the size of the buffer
0000000000000000000000000000000000000000;;	func (b *Buffer) Size() int64 {
0000000000000000000000000000000000000000;;		return b.size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TotalWritten provides the total number of bytes written
0000000000000000000000000000000000000000;;	func (b *Buffer) TotalWritten() int64 {
0000000000000000000000000000000000000000;;		return b.written
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes provides a slice of the bytes written. This
0000000000000000000000000000000000000000;;	// slice should not be written to.
0000000000000000000000000000000000000000;;	func (b *Buffer) Bytes() []byte {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b.written >= b.size && b.writeCursor == 0:
0000000000000000000000000000000000000000;;			return b.data
0000000000000000000000000000000000000000;;		case b.written > b.size:
0000000000000000000000000000000000000000;;			out := make([]byte, b.size)
0000000000000000000000000000000000000000;;			copy(out, b.data[b.writeCursor:])
0000000000000000000000000000000000000000;;			copy(out[b.size-b.writeCursor:], b.data[:b.writeCursor])
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return b.data[:b.writeCursor]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the buffer so it has no content.
0000000000000000000000000000000000000000;;	func (b *Buffer) Reset() {
0000000000000000000000000000000000000000;;		b.writeCursor = 0
0000000000000000000000000000000000000000;;		b.written = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the contents of the buffer as a string
0000000000000000000000000000000000000000;;	func (b *Buffer) String() string {
0000000000000000000000000000000000000000;;		return string(b.Bytes())
0000000000000000000000000000000000000000;;	}
