0000000000000000000000000000000000000000;;	package storageos
bed3bbbd20d07cd2188d11c1be163c46f1d22c8d;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/storageos/go-api/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VolumeAPIPrefix is a partial path to the HTTP endpoint.
0000000000000000000000000000000000000000;;		VolumeAPIPrefix = "volumes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNoSuchVolume is the error returned when the volume does not exist.
0000000000000000000000000000000000000000;;		ErrNoSuchVolume = errors.New("no such volume")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrVolumeInUse is the error returned when the volume requested to be removed is still in use.
0000000000000000000000000000000000000000;;		ErrVolumeInUse = errors.New("volume in use and cannot be removed")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeList returns the list of available volumes.
0000000000000000000000000000000000000000;;	func (c *Client) VolumeList(opts types.ListOptions) ([]*types.Volume, error) {
0000000000000000000000000000000000000000;;		listOpts := doOptions{
0000000000000000000000000000000000000000;;			fieldSelector: opts.FieldSelector,
0000000000000000000000000000000000000000;;			labelSelector: opts.LabelSelector,
0000000000000000000000000000000000000000;;			namespace:     opts.Namespace,
0000000000000000000000000000000000000000;;			context:       opts.Context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.LabelSelector != "" {
0000000000000000000000000000000000000000;;			query := url.Values{}
0000000000000000000000000000000000000000;;			query.Add("labelSelector", opts.LabelSelector)
0000000000000000000000000000000000000000;;			listOpts.values = query
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.do("GET", VolumeAPIPrefix, listOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var volumes []*types.Volume
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&volumes); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return volumes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volume returns a volume by its reference.
0000000000000000000000000000000000000000;;	func (c *Client) Volume(namespace string, ref string) (*types.Volume, error) {
0000000000000000000000000000000000000000;;		path, err := namespacedRefPath(namespace, VolumeAPIPrefix, ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("GET", path, doOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok && e.Status == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return nil, ErrNoSuchVolume
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var volume types.Volume
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&volume); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeCreate creates a volume on the server and returns the new object.
0000000000000000000000000000000000000000;;	func (c *Client) VolumeCreate(opts types.VolumeCreateOptions) (*types.Volume, error) {
0000000000000000000000000000000000000000;;		path, err := namespacedPath(opts.Namespace, VolumeAPIPrefix)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("POST", path, doOptions{
0000000000000000000000000000000000000000;;			data:    opts,
0000000000000000000000000000000000000000;;			context: opts.Context,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var volume types.Volume
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&volume); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeUpdate updates a volume on the server.
0000000000000000000000000000000000000000;;	func (c *Client) VolumeUpdate(opts types.VolumeUpdateOptions) (*types.Volume, error) {
0000000000000000000000000000000000000000;;		ref := opts.Name
0000000000000000000000000000000000000000;;		if IsUUID(opts.ID) {
0000000000000000000000000000000000000000;;			ref = opts.ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path, err := namespacedRefPath(opts.Namespace, VolumeAPIPrefix, ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("PUT", path, doOptions{
0000000000000000000000000000000000000000;;			data:    opts,
0000000000000000000000000000000000000000;;			context: opts.Context,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var volume types.Volume
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&volume); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &volume, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeDelete removes a volume by its reference.
0000000000000000000000000000000000000000;;	func (c *Client) VolumeDelete(opts types.DeleteOptions) error {
0000000000000000000000000000000000000000;;		deleteOpts := doOptions{
0000000000000000000000000000000000000000;;			namespace: opts.Namespace,
0000000000000000000000000000000000000000;;			force:     opts.Force,
0000000000000000000000000000000000000000;;			context:   opts.Context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("DELETE", VolumeAPIPrefix+"/"+opts.Name, deleteOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok {
0000000000000000000000000000000000000000;;				if e.Status == http.StatusNotFound {
0000000000000000000000000000000000000000;;					return ErrNoSuchVolume
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e.Status == http.StatusConflict {
0000000000000000000000000000000000000000;;					return ErrVolumeInUse
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeMount updates the volume with the client that mounted it.
0000000000000000000000000000000000000000;;	func (c *Client) VolumeMount(opts types.VolumeMountOptions) error {
0000000000000000000000000000000000000000;;		ref := opts.Name
0000000000000000000000000000000000000000;;		if IsUUID(opts.ID) {
0000000000000000000000000000000000000000;;			ref = opts.ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path, err := namespacedRefPath(opts.Namespace, VolumeAPIPrefix, ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("POST", path+"/mount", doOptions{
0000000000000000000000000000000000000000;;			data:    opts,
0000000000000000000000000000000000000000;;			context: opts.Context,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok {
0000000000000000000000000000000000000000;;				if e.Status == http.StatusNotFound {
0000000000000000000000000000000000000000;;					return ErrNoSuchVolume
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e.Status == http.StatusConflict {
0000000000000000000000000000000000000000;;					return ErrVolumeInUse
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeUnmount removes the client from the mount reference.
0000000000000000000000000000000000000000;;	func (c *Client) VolumeUnmount(opts types.VolumeUnmountOptions) error {
0000000000000000000000000000000000000000;;		ref := opts.Name
0000000000000000000000000000000000000000;;		if IsUUID(opts.ID) {
0000000000000000000000000000000000000000;;			ref = opts.ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path, err := namespacedRefPath(opts.Namespace, VolumeAPIPrefix, ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("POST", path+"/unmount", doOptions{
0000000000000000000000000000000000000000;;			data:    opts,
0000000000000000000000000000000000000000;;			context: opts.Context,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok {
0000000000000000000000000000000000000000;;				if e.Status == http.StatusNotFound {
0000000000000000000000000000000000000000;;					return ErrNoSuchVolume
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e.Status == http.StatusConflict {
0000000000000000000000000000000000000000;;					return ErrVolumeInUse
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
