0000000000000000000000000000000000000000;;	package storageos
bed3bbbd20d07cd2188d11c1be163c46f1d22c8d;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/storageos/go-api/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NamespaceAPIPrefix is a partial path to the HTTP endpoint.
0000000000000000000000000000000000000000;;		NamespaceAPIPrefix = "namespaces"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNoSuchNamespace is the error returned when the namespace does not exist.
0000000000000000000000000000000000000000;;		ErrNoSuchNamespace = errors.New("no such namespace")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNamespaceInUse is the error returned when the namespace requested to be removed is still in use.
0000000000000000000000000000000000000000;;		ErrNamespaceInUse = errors.New("namespace in use and cannot be removed")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceList returns the list of available namespaces.
0000000000000000000000000000000000000000;;	func (c *Client) NamespaceList(opts types.ListOptions) ([]*types.Namespace, error) {
0000000000000000000000000000000000000000;;		listOpts := doOptions{
0000000000000000000000000000000000000000;;			fieldSelector: opts.FieldSelector,
0000000000000000000000000000000000000000;;			labelSelector: opts.LabelSelector,
0000000000000000000000000000000000000000;;			namespace:     opts.Namespace,
0000000000000000000000000000000000000000;;			context:       opts.Context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.LabelSelector != "" {
0000000000000000000000000000000000000000;;			query := url.Values{}
0000000000000000000000000000000000000000;;			query.Add("labelSelector", opts.LabelSelector)
0000000000000000000000000000000000000000;;			listOpts.values = query
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.do("GET", NamespaceAPIPrefix, listOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var namespaces []*types.Namespace
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&namespaces); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return namespaces, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namespace returns a namespace by its reference.
0000000000000000000000000000000000000000;;	func (c *Client) Namespace(ref string) (*types.Namespace, error) {
0000000000000000000000000000000000000000;;		resp, err := c.do("GET", NamespaceAPIPrefix+"/"+ref, doOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok && e.Status == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return nil, ErrNoSuchNamespace
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var namespace types.Namespace
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&namespace); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &namespace, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceCreate creates a namespace on the server and returns the new object.
0000000000000000000000000000000000000000;;	func (c *Client) NamespaceCreate(opts types.NamespaceCreateOptions) (*types.Namespace, error) {
0000000000000000000000000000000000000000;;		resp, err := c.do("POST", NamespaceAPIPrefix, doOptions{
0000000000000000000000000000000000000000;;			data:    opts,
0000000000000000000000000000000000000000;;			context: opts.Context,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var namespace types.Namespace
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&namespace); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &namespace, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceUpdate updates a namespace on the server and returns the updated object.
0000000000000000000000000000000000000000;;	func (c *Client) NamespaceUpdate(opts types.NamespaceCreateOptions) (*types.Namespace, error) {
0000000000000000000000000000000000000000;;		resp, err := c.do("PUT", NamespaceAPIPrefix+"/"+opts.Name, doOptions{
0000000000000000000000000000000000000000;;			data:    opts,
0000000000000000000000000000000000000000;;			context: opts.Context,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var namespace types.Namespace
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&namespace); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &namespace, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceDelete removes a namespace by its reference.
0000000000000000000000000000000000000000;;	func (c *Client) NamespaceDelete(opts types.DeleteOptions) error {
0000000000000000000000000000000000000000;;		deleteOpts := doOptions{
0000000000000000000000000000000000000000;;			force:   opts.Force,
0000000000000000000000000000000000000000;;			context: opts.Context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("DELETE", NamespaceAPIPrefix+"/"+opts.Name, deleteOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok {
0000000000000000000000000000000000000000;;				if e.Status == http.StatusNotFound {
0000000000000000000000000000000000000000;;					return ErrNoSuchNamespace
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e.Status == http.StatusConflict {
0000000000000000000000000000000000000000;;					return ErrNamespaceInUse
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// namespace can't be deleted yet, unless force is supplied
0000000000000000000000000000000000000000;;				if e.Status == http.StatusPreconditionFailed {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
