0000000000000000000000000000000000000000;;	package storageos
bed3bbbd20d07cd2188d11c1be163c46f1d22c8d;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gorilla/websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/storageos/go-api/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EventAPIPrefix is a partial path to the HTTP endpoint.
0000000000000000000000000000000000000000;;		EventAPIPrefix = "event"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNoSuchEvent is the error returned when the event does not exist.
0000000000000000000000000000000000000000;;		ErrNoSuchEvent = errors.New("no such event")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventList returns the list of available events.
0000000000000000000000000000000000000000;;	func (c *Client) EventList(opts types.ListOptions) ([]*types.Event, error) {
0000000000000000000000000000000000000000;;		listOpts := doOptions{
0000000000000000000000000000000000000000;;			fieldSelector: opts.FieldSelector,
0000000000000000000000000000000000000000;;			labelSelector: opts.LabelSelector,
0000000000000000000000000000000000000000;;			context:       opts.Context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := c.do("GET", EventAPIPrefix, listOpts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var events []*types.Event
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&events); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return events, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Events returns a stream of events in the daemon. It's up to the caller to close the stream
0000000000000000000000000000000000000000;;	// by cancelling the context. Once the stream has been completely read an io.EOF error will
0000000000000000000000000000000000000000;;	// be sent over the error channel. If an error is sent all processing will be stopped. It's up
0000000000000000000000000000000000000000;;	// to the caller to reopen the stream in the event of an error by reinvoking this method.
0000000000000000000000000000000000000000;;	func (c *Client) Events(ctx context.Context, opts types.ListOptions) (<-chan types.Request, <-chan error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listOpts := doOptions{
0000000000000000000000000000000000000000;;		// 	fieldSelector: opts.FieldSelector,
0000000000000000000000000000000000000000;;		// 	labelSelector: opts.LabelSelector,
0000000000000000000000000000000000000000;;		// 	context:       ctx,
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		messages := make(chan types.Request)
0000000000000000000000000000000000000000;;		errs := make(chan error, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// started := make(chan struct{})
0000000000000000000000000000000000000000;;		ws, _, err := websocket.DefaultDialer.Dial("ws://10.245.103.2:8000/v1/ws/event", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// close(started)
0000000000000000000000000000000000000000;;			// errs <- err
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer ws.Close()
0000000000000000000000000000000000000000;;			defer close(done)
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				_, message, err := ws.ReadMessage()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					log.Println("read:", err)
0000000000000000000000000000000000000000;;					errs <- err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// log.Printf("recv: %s", message)
0000000000000000000000000000000000000000;;				var request types.Request
0000000000000000000000000000000000000000;;				if err := json.Unmarshal(message, &request); err != nil {
0000000000000000000000000000000000000000;;					log.Printf("decode error: %s", message)
0000000000000000000000000000000000000000;;					errs <- err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				messages <- request
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(time.Second)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case t := <-ticker.C:
0000000000000000000000000000000000000000;;					log.Printf("tick: %s\n", t.String())
0000000000000000000000000000000000000000;;					err := ws.WriteMessage(websocket.TextMessage, []byte(t.String()))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						log.Println("write:", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-ctx.Done():
0000000000000000000000000000000000000000;;					log.Println("done")
0000000000000000000000000000000000000000;;					err := ws.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, ""))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						log.Println("write close:", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					errs <- ctx.Err()
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case <-done:
0000000000000000000000000000000000000000;;					case <-time.After(time.Second):
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ws.Close()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// go func() {
0000000000000000000000000000000000000000;;		// 	defer ws.Close()
0000000000000000000000000000000000000000;;		// 	defer close(errs)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// query, err := buildEventsQueryParams(cli.version, options)
0000000000000000000000000000000000000000;;		// 	// if err != nil {
0000000000000000000000000000000000000000;;		// 	// 	close(started)
0000000000000000000000000000000000000000;;		// 	// 	errs <- err
0000000000000000000000000000000000000000;;		// 	// 	return
0000000000000000000000000000000000000000;;		// 	// }
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// resp, err := cli.get(ctx, "/events", query, nil)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// decoder := json.NewDecoder(resp.Body)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	close(started)
0000000000000000000000000000000000000000;;		// 	for {
0000000000000000000000000000000000000000;;		// 		select {
0000000000000000000000000000000000000000;;		// 		case <-ctx.Done():
0000000000000000000000000000000000000000;;		// 			log.Println("done")
0000000000000000000000000000000000000000;;		// 			errs <- ctx.Err()
0000000000000000000000000000000000000000;;		// 			return
0000000000000000000000000000000000000000;;		// 		default:
0000000000000000000000000000000000000000;;		// 			log.Println("default")
0000000000000000000000000000000000000000;;		// 			_, message, err := ws.ReadMessage()
0000000000000000000000000000000000000000;;		// 			if err != nil {
0000000000000000000000000000000000000000;;		// 				log.Println("read:", err)
0000000000000000000000000000000000000000;;		// 				return
0000000000000000000000000000000000000000;;		// 			}
0000000000000000000000000000000000000000;;		// 			log.Printf("recv: %s", message)
0000000000000000000000000000000000000000;;		// 			var event types.Event
0000000000000000000000000000000000000000;;		// 			if err := json.Unmarshal(message, &event); err != nil {
0000000000000000000000000000000000000000;;		// 				log.Printf("decode error: %s", message)
0000000000000000000000000000000000000000;;		// 				errs <- err
0000000000000000000000000000000000000000;;		// 				return
0000000000000000000000000000000000000000;;		// 			}
0000000000000000000000000000000000000000;;		// 			log.Printf("sent: %v", event)
0000000000000000000000000000000000000000;;		// 			messages <- event
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 			// select {
0000000000000000000000000000000000000000;;		// 			// case messages <- event:
0000000000000000000000000000000000000000;;		// 			// case <-ctx.Done():
0000000000000000000000000000000000000000;;		// 			// 	errs <- ctx.Err()
0000000000000000000000000000000000000000;;		// 			// 	return
0000000000000000000000000000000000000000;;		// 			// }
0000000000000000000000000000000000000000;;		// 		}
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		// }()
0000000000000000000000000000000000000000;;		// <-started
0000000000000000000000000000000000000000;;		log.Println("returning")
0000000000000000000000000000000000000000;;		return messages, errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event returns a event by its reference.
0000000000000000000000000000000000000000;;	func (c *Client) Event(ref string) (*types.Event, error) {
0000000000000000000000000000000000000000;;		resp, err := c.do("GET", EventAPIPrefix+"/"+ref, doOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok && e.Status == http.StatusNotFound {
0000000000000000000000000000000000000000;;				return nil, ErrNoSuchEvent
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		var event types.Event
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&event); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &event, nil
0000000000000000000000000000000000000000;;	}
