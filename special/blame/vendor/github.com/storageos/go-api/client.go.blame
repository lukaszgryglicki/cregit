0000000000000000000000000000000000000000;;	package storageos
bed3bbbd20d07cd2188d11c1be163c46f1d22c8d;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		userAgent         = "go-storageosclient"
0000000000000000000000000000000000000000;;		unixProtocol      = "unix"
0000000000000000000000000000000000000000;;		namedPipeProtocol = "npipe"
0000000000000000000000000000000000000000;;		DefaultVersionStr = "1"
0000000000000000000000000000000000000000;;		DefaultVersion    = 1
0000000000000000000000000000000000000000;;		defaultNamespace  = "default"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrInvalidEndpoint is returned when the endpoint is not a valid HTTP URL.
0000000000000000000000000000000000000000;;		ErrInvalidEndpoint = errors.New("invalid endpoint")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrConnectionRefused is returned when the client cannot connect to the given endpoint.
0000000000000000000000000000000000000000;;		ErrConnectionRefused = errors.New("cannot connect to StorageOS API endpoint")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrInactivityTimeout is returned when a streamable call has been inactive for some time.
0000000000000000000000000000000000000000;;		ErrInactivityTimeout = errors.New("inactivity time exceeded timeout")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrInvalidVersion is returned when a versioned client was requested but no version specified.
0000000000000000000000000000000000000000;;		ErrInvalidVersion = errors.New("invalid version")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultHost is the default API host
0000000000000000000000000000000000000000;;		DefaultHost = "tcp://localhost:5705"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIVersion is an internal representation of a version of the Remote API.
0000000000000000000000000000000000000000;;	type APIVersion int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAPIVersion returns an instance of APIVersion for the given string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The given string must be in the form <major>
0000000000000000000000000000000000000000;;	func NewAPIVersion(input string) (APIVersion, error) {
0000000000000000000000000000000000000000;;		if input == "" {
0000000000000000000000000000000000000000;;			return DefaultVersion, ErrInvalidVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, err := strconv.Atoi(input)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("Unable to parse version %q", input)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return APIVersion(version), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (version APIVersion) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("v%d", version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client is the basic type of this package. It provides methods for
0000000000000000000000000000000000000000;;	// interaction with the API.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		SkipServerVersionCheck bool
0000000000000000000000000000000000000000;;		HTTPClient             *http.Client
0000000000000000000000000000000000000000;;		TLSConfig              *tls.Config
0000000000000000000000000000000000000000;;		Dialer                 Dialer
0000000000000000000000000000000000000000;;		endpoint               string
0000000000000000000000000000000000000000;;		endpointURL            *url.URL
0000000000000000000000000000000000000000;;		username               string
0000000000000000000000000000000000000000;;		secret                 string
0000000000000000000000000000000000000000;;		requestedAPIVersion    APIVersion
0000000000000000000000000000000000000000;;		serverAPIVersion       APIVersion
0000000000000000000000000000000000000000;;		expectedAPIVersion     APIVersion
0000000000000000000000000000000000000000;;		nativeHTTPClient       *http.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientVersion returns the API version of the client
0000000000000000000000000000000000000000;;	func (c *Client) ClientVersion() string {
0000000000000000000000000000000000000000;;		return DefaultVersionStr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dialer is an interface that allows network connections to be dialed
0000000000000000000000000000000000000000;;	// (net.Dialer fulfills this interface) and named pipes (a shim using
0000000000000000000000000000000000000000;;	// winio.DialPipe)
0000000000000000000000000000000000000000;;	type Dialer interface {
0000000000000000000000000000000000000000;;		Dial(network, address string) (net.Conn, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient returns a Client instance ready for communication with the given
0000000000000000000000000000000000000000;;	// server endpoint. It will use the latest remote API version available in the
0000000000000000000000000000000000000000;;	// server.
0000000000000000000000000000000000000000;;	func NewClient(endpoint string) (*Client, error) {
0000000000000000000000000000000000000000;;		client, err := NewVersionedClient(endpoint, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client.SkipServerVersionCheck = true
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTLSClient returns a Client instance ready for TLS communications with the given
0000000000000000000000000000000000000000;;	// server endpoint, key and certificates . It will use the latest remote API version
0000000000000000000000000000000000000000;;	// available in the server.
0000000000000000000000000000000000000000;;	func NewTLSClient(endpoint string, cert, key, ca string) (*Client, error) {
0000000000000000000000000000000000000000;;		client, err := NewVersionedTLSClient(endpoint, cert, key, ca, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client.SkipServerVersionCheck = true
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewVersionedClient returns a Client instance ready for communication with
0000000000000000000000000000000000000000;;	// the given server endpoint, using a specific remote API version.
0000000000000000000000000000000000000000;;	func NewVersionedClient(endpoint string, apiVersionString string) (*Client, error) {
0000000000000000000000000000000000000000;;		u, err := parseEndpoint(endpoint, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &Client{
0000000000000000000000000000000000000000;;			HTTPClient:  defaultClient(),
0000000000000000000000000000000000000000;;			Dialer:      &net.Dialer{},
0000000000000000000000000000000000000000;;			endpoint:    endpoint,
0000000000000000000000000000000000000000;;			endpointURL: u,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if apiVersionString != "" {
0000000000000000000000000000000000000000;;			version, err := strconv.Atoi(apiVersionString)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.requestedAPIVersion = APIVersion(version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.initializeNativeClient()
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewVersionedTLSClient returns a Client instance ready for TLS communications with the givens
0000000000000000000000000000000000000000;;	// server endpoint, key and certificates, using a specific remote API version.
0000000000000000000000000000000000000000;;	func NewVersionedTLSClient(endpoint string, cert, key, ca, apiVersionString string) (*Client, error) {
0000000000000000000000000000000000000000;;		var certPEMBlock []byte
0000000000000000000000000000000000000000;;		var keyPEMBlock []byte
0000000000000000000000000000000000000000;;		var caPEMCert []byte
0000000000000000000000000000000000000000;;		if _, err := os.Stat(cert); !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			certPEMBlock, err = ioutil.ReadFile(cert)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(key); !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			keyPEMBlock, err = ioutil.ReadFile(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := os.Stat(ca); !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			caPEMCert, err = ioutil.ReadFile(ca)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewVersionedTLSClientFromBytes(endpoint, certPEMBlock, keyPEMBlock, caPEMCert, apiVersionString)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewVersionedTLSClientFromBytes returns a Client instance ready for TLS communications with the givens
0000000000000000000000000000000000000000;;	// server endpoint, key and certificates (passed inline to the function as opposed to being
0000000000000000000000000000000000000000;;	// read from a local file), using a specific remote API version.
0000000000000000000000000000000000000000;;	func NewVersionedTLSClientFromBytes(endpoint string, certPEMBlock, keyPEMBlock, caPEMCert []byte, apiVersionString string) (*Client, error) {
0000000000000000000000000000000000000000;;		u, err := parseEndpoint(endpoint, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsConfig := &tls.Config{}
0000000000000000000000000000000000000000;;		if certPEMBlock != nil && keyPEMBlock != nil {
0000000000000000000000000000000000000000;;			tlsCert, err := tls.X509KeyPair(certPEMBlock, keyPEMBlock)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.Certificates = []tls.Certificate{tlsCert}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if caPEMCert == nil {
0000000000000000000000000000000000000000;;			tlsConfig.InsecureSkipVerify = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			caPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;			if !caPool.AppendCertsFromPEM(caPEMCert) {
0000000000000000000000000000000000000000;;				return nil, errors.New("Could not add RootCA pem")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.RootCAs = caPool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tr := defaultTransport()
0000000000000000000000000000000000000000;;		tr.TLSClientConfig = tlsConfig
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &Client{
0000000000000000000000000000000000000000;;			HTTPClient:  &http.Client{Transport: tr},
0000000000000000000000000000000000000000;;			TLSConfig:   tlsConfig,
0000000000000000000000000000000000000000;;			Dialer:      &net.Dialer{},
0000000000000000000000000000000000000000;;			endpoint:    endpoint,
0000000000000000000000000000000000000000;;			endpointURL: u,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if apiVersionString != "" {
0000000000000000000000000000000000000000;;			version, err := strconv.Atoi(apiVersionString)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.requestedAPIVersion = APIVersion(version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.initializeNativeClient()
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAuth sets the API username and secret to be used for all API requests.
0000000000000000000000000000000000000000;;	// It should not be called concurrently with any other Client methods.
0000000000000000000000000000000000000000;;	func (c *Client) SetAuth(username string, secret string) {
0000000000000000000000000000000000000000;;		if username != "" {
0000000000000000000000000000000000000000;;			c.username = username
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if secret != "" {
0000000000000000000000000000000000000000;;			c.secret = secret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTimeout takes a timeout and applies it to both the HTTPClient and
0000000000000000000000000000000000000000;;	// nativeHTTPClient. It should not be called concurrently with any other Client
0000000000000000000000000000000000000000;;	// methods.
0000000000000000000000000000000000000000;;	func (c *Client) SetTimeout(t time.Duration) {
0000000000000000000000000000000000000000;;		if c.HTTPClient != nil {
0000000000000000000000000000000000000000;;			c.HTTPClient.Timeout = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.nativeHTTPClient != nil {
0000000000000000000000000000000000000000;;			c.nativeHTTPClient.Timeout = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) checkAPIVersion() error {
0000000000000000000000000000000000000000;;		serverAPIVersionString, err := c.getServerAPIVersionString()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.serverAPIVersion, err = NewAPIVersion(serverAPIVersionString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.requestedAPIVersion == 0 {
0000000000000000000000000000000000000000;;			c.expectedAPIVersion = c.serverAPIVersion
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.expectedAPIVersion = c.requestedAPIVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoint returns the current endpoint. It's useful for getting the endpoint
0000000000000000000000000000000000000000;;	// when using functions that get this data from the environment (like
0000000000000000000000000000000000000000;;	// NewClientFromEnv.
0000000000000000000000000000000000000000;;	func (c *Client) Endpoint() string {
0000000000000000000000000000000000000000;;		return c.endpoint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ping pings the API server
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://goo.gl/wYfgY1 for more details.
0000000000000000000000000000000000000000;;	func (c *Client) Ping() error {
0000000000000000000000000000000000000000;;		urlpath := "/_ping"
0000000000000000000000000000000000000000;;		resp, err := c.do("GET", urlpath, doOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return newError(resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Body.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) getServerAPIVersionString() (version string, err error) {
0000000000000000000000000000000000000000;;		v, err := c.ServerVersion(context.Background())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.APIVersion, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type doOptions struct {
0000000000000000000000000000000000000000;;		data          interface{}
0000000000000000000000000000000000000000;;		fieldSelector string
0000000000000000000000000000000000000000;;		labelSelector string
0000000000000000000000000000000000000000;;		namespace     string
0000000000000000000000000000000000000000;;		forceJSON     bool
0000000000000000000000000000000000000000;;		force         bool
0000000000000000000000000000000000000000;;		values        url.Values
0000000000000000000000000000000000000000;;		headers       map[string]string
0000000000000000000000000000000000000000;;		unversioned   bool
0000000000000000000000000000000000000000;;		context       context.Context
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) do(method, urlpath string, doOptions doOptions) (*http.Response, error) {
0000000000000000000000000000000000000000;;		var params io.Reader
0000000000000000000000000000000000000000;;		if doOptions.data != nil || doOptions.forceJSON {
0000000000000000000000000000000000000000;;			buf, err := json.Marshal(doOptions.data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			params = bytes.NewBuffer(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prefix the path with the namespace if given.  The caller should only set
0000000000000000000000000000000000000000;;		// the namespace if this is desired.
0000000000000000000000000000000000000000;;		if doOptions.namespace != "" {
0000000000000000000000000000000000000000;;			urlpath = "/" + NamespaceAPIPrefix + "/" + doOptions.namespace + "/" + urlpath
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !c.SkipServerVersionCheck && !doOptions.unversioned {
0000000000000000000000000000000000000000;;			err := c.checkAPIVersion()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		query := url.Values{}
0000000000000000000000000000000000000000;;		if doOptions.values != nil {
0000000000000000000000000000000000000000;;			query = doOptions.values
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if doOptions.force {
0000000000000000000000000000000000000000;;			query.Add("force", "1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		httpClient := c.HTTPClient
0000000000000000000000000000000000000000;;		protocol := c.endpointURL.Scheme
0000000000000000000000000000000000000000;;		var u string
0000000000000000000000000000000000000000;;		switch protocol {
0000000000000000000000000000000000000000;;		case unixProtocol, namedPipeProtocol:
0000000000000000000000000000000000000000;;			httpClient = c.nativeHTTPClient
0000000000000000000000000000000000000000;;			u = c.getFakeNativeURL(urlpath, doOptions.unversioned)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			u = c.getAPIPath(urlpath, query, doOptions.unversioned)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(method, u, params)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", userAgent)
0000000000000000000000000000000000000000;;		if doOptions.data != nil {
0000000000000000000000000000000000000000;;			req.Header.Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		} else if method == "POST" {
0000000000000000000000000000000000000000;;			req.Header.Set("Content-Type", "plain/text")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.username != "" && c.secret != "" {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(c.username, c.secret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range doOptions.headers {
0000000000000000000000000000000000000000;;			req.Header.Set(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := doOptions.context
0000000000000000000000000000000000000000;;		if ctx == nil {
0000000000000000000000000000000000000000;;			ctx = context.Background()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := httpClient.Do(req.WithContext(ctx))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if strings.Contains(err.Error(), "connection refused") {
0000000000000000000000000000000000000000;;				return nil, ErrConnectionRefused
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, chooseError(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode < 200 || resp.StatusCode >= 400 {
0000000000000000000000000000000000000000;;			return nil, newError(resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// if error in context, return that instead of generic http error
0000000000000000000000000000000000000000;;	func chooseError(ctx context.Context, err error) error {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return ctx.Err()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) getURL(path string, unversioned bool) string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		urlStr := strings.TrimRight(c.endpointURL.String(), "/")
0000000000000000000000000000000000000000;;		path = strings.TrimLeft(path, "/")
0000000000000000000000000000000000000000;;		if c.endpointURL.Scheme == unixProtocol || c.endpointURL.Scheme == namedPipeProtocol {
0000000000000000000000000000000000000000;;			urlStr = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unversioned {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s/%s", urlStr, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s/%s", urlStr, c.requestedAPIVersion, path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) getAPIPath(path string, query url.Values, unversioned bool) string {
0000000000000000000000000000000000000000;;		var apiPath string
0000000000000000000000000000000000000000;;		urlStr := strings.TrimRight(c.endpointURL.String(), "/")
0000000000000000000000000000000000000000;;		path = strings.TrimLeft(path, "/")
0000000000000000000000000000000000000000;;		if c.endpointURL.Scheme == unixProtocol || c.endpointURL.Scheme == namedPipeProtocol {
0000000000000000000000000000000000000000;;			urlStr = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if unversioned {
0000000000000000000000000000000000000000;;			apiPath = fmt.Sprintf("%s/%s", urlStr, path)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			apiPath = fmt.Sprintf("%s/%s/%s", urlStr, c.requestedAPIVersion, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(query) > 0 {
0000000000000000000000000000000000000000;;			apiPath = apiPath + "?" + query.Encode()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return apiPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getFakeNativeURL returns the URL needed to make an HTTP request over a UNIX
0000000000000000000000000000000000000000;;	// domain socket to the given path.
0000000000000000000000000000000000000000;;	func (c *Client) getFakeNativeURL(path string, unversioned bool) string {
0000000000000000000000000000000000000000;;		u := *c.endpointURL // Copy.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override URL so that net/http will not complain.
0000000000000000000000000000000000000000;;		u.Scheme = "http"
0000000000000000000000000000000000000000;;		u.Host = "unix.sock" // Doesn't matter what this is - it's not used.
0000000000000000000000000000000000000000;;		u.Path = ""
0000000000000000000000000000000000000000;;		urlStr := strings.TrimRight(u.String(), "/")
0000000000000000000000000000000000000000;;		path = strings.TrimLeft(path, "/")
0000000000000000000000000000000000000000;;		if unversioned {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%s/%s", urlStr, path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s/%s", urlStr, c.requestedAPIVersion, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jsonMessage struct {
0000000000000000000000000000000000000000;;		Status   string `json:"status,omitempty"`
0000000000000000000000000000000000000000;;		Progress string `json:"progress,omitempty"`
0000000000000000000000000000000000000000;;		Error    string `json:"error,omitempty"`
0000000000000000000000000000000000000000;;		Stream   string `json:"stream,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func queryString(opts interface{}) string {
0000000000000000000000000000000000000000;;		if opts == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(opts)
0000000000000000000000000000000000000000;;		if value.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			value = value.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if value.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items := url.Values(map[string][]string{})
0000000000000000000000000000000000000000;;		for i := 0; i < value.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := value.Type().Field(i)
0000000000000000000000000000000000000000;;			if field.PkgPath != "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key := field.Tag.Get("qs")
0000000000000000000000000000000000000000;;			if key == "" {
0000000000000000000000000000000000000000;;				key = strings.ToLower(field.Name)
0000000000000000000000000000000000000000;;			} else if key == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addQueryStringValue(items, key, value.Field(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return items.Encode()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addQueryStringValue(items url.Values, key string, v reflect.Value) {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			if v.Bool() {
0000000000000000000000000000000000000000;;				items.Add(key, "1")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			if v.Int() > 0 {
0000000000000000000000000000000000000000;;				items.Add(key, strconv.FormatInt(v.Int(), 10))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			if v.Float() > 0 {
0000000000000000000000000000000000000000;;				items.Add(key, strconv.FormatFloat(v.Float(), 'f', -1, 64))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if v.String() != "" {
0000000000000000000000000000000000000000;;				items.Add(key, v.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if !v.IsNil() {
0000000000000000000000000000000000000000;;				if b, err := json.Marshal(v.Interface()); err == nil {
0000000000000000000000000000000000000000;;					items.Add(key, string(b))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if len(v.MapKeys()) > 0 {
0000000000000000000000000000000000000000;;				if b, err := json.Marshal(v.Interface()); err == nil {
0000000000000000000000000000000000000000;;					items.Add(key, string(b))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Slice:
0000000000000000000000000000000000000000;;			vLen := v.Len()
0000000000000000000000000000000000000000;;			if vLen > 0 {
0000000000000000000000000000000000000000;;				for i := 0; i < vLen; i++ {
0000000000000000000000000000000000000000;;					addQueryStringValue(items, key, v.Index(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error represents failures in the API. It represents a failure from the API.
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Status  int
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newError(resp *http.Response) *Error {
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return &Error{Status: resp.StatusCode, Message: fmt.Sprintf("cannot read body, err: %v", err)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Error{Status: resp.StatusCode, Message: string(data)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Error) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("API error (%d): %s", e.Status, e.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseEndpoint(endpoint string, tls bool) (*url.URL, error) {
0000000000000000000000000000000000000000;;		if endpoint != "" && !strings.Contains(endpoint, "://") {
0000000000000000000000000000000000000000;;			endpoint = "tcp://" + endpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u, err := url.Parse(endpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, ErrInvalidEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tls && u.Scheme != "unix" {
0000000000000000000000000000000000000000;;			u.Scheme = "https"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch u.Scheme {
0000000000000000000000000000000000000000;;		case unixProtocol, namedPipeProtocol:
0000000000000000000000000000000000000000;;			return u, nil
0000000000000000000000000000000000000000;;		case "http", "https", "tcp":
0000000000000000000000000000000000000000;;			_, port, err := net.SplitHostPort(u.Host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if e, ok := err.(*net.AddrError); ok {
0000000000000000000000000000000000000000;;					if e.Err == "missing port in address" {
0000000000000000000000000000000000000000;;						return u, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, ErrInvalidEndpoint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			number, err := strconv.ParseInt(port, 10, 64)
0000000000000000000000000000000000000000;;			if err == nil && number > 0 && number < 65536 {
0000000000000000000000000000000000000000;;				if u.Scheme == "tcp" {
0000000000000000000000000000000000000000;;					if tls {
0000000000000000000000000000000000000000;;						u.Scheme = "https"
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						u.Scheme = "http"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return u, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, ErrInvalidEndpoint
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrInvalidEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultTransport returns a new http.Transport with the same default values
0000000000000000000000000000000000000000;;	// as http.DefaultTransport, but with idle connections and keepalives disabled.
0000000000000000000000000000000000000000;;	func defaultTransport() *http.Transport {
0000000000000000000000000000000000000000;;		transport := defaultPooledTransport()
0000000000000000000000000000000000000000;;		transport.DisableKeepAlives = true
0000000000000000000000000000000000000000;;		transport.MaxIdleConnsPerHost = -1
0000000000000000000000000000000000000000;;		return transport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultPooledTransport returns a new http.Transport with similar default
0000000000000000000000000000000000000000;;	// values to http.DefaultTransport. Do not use this for transient transports as
0000000000000000000000000000000000000000;;	// it can leak file descriptors over time. Only use this for transports that
0000000000000000000000000000000000000000;;	// will be re-used for the same host(s).
0000000000000000000000000000000000000000;;	func defaultPooledTransport() *http.Transport {
0000000000000000000000000000000000000000;;		transport := &http.Transport{
0000000000000000000000000000000000000000;;			Proxy: http.ProxyFromEnvironment,
0000000000000000000000000000000000000000;;			Dial: (&net.Dialer{
0000000000000000000000000000000000000000;;				Timeout:   30 * time.Second,
0000000000000000000000000000000000000000;;				KeepAlive: 30 * time.Second,
0000000000000000000000000000000000000000;;			}).Dial,
0000000000000000000000000000000000000000;;			TLSHandshakeTimeout: 10 * time.Second,
0000000000000000000000000000000000000000;;			DisableKeepAlives:   false,
0000000000000000000000000000000000000000;;			MaxIdleConnsPerHost: 1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return transport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultClient returns a new http.Client with similar default values to
0000000000000000000000000000000000000000;;	// http.Client, but with a non-shared Transport, idle connections disabled, and
0000000000000000000000000000000000000000;;	// keepalives disabled.
0000000000000000000000000000000000000000;;	func defaultClient() *http.Client {
0000000000000000000000000000000000000000;;		return &http.Client{
0000000000000000000000000000000000000000;;			Transport: defaultTransport(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
