0000000000000000000000000000000000000000;;	![cobra logo](https://cloud.githubusercontent.com/assets/173412/10886352/ad566232-814f-11e5-9cd0-aa101788c117.png)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra is both a library for creating powerful modern CLI applications as well as a program to generate applications and command files.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Many of the most widely used Go projects are built using Cobra including:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [Kubernetes](http://kubernetes.io/)
0000000000000000000000000000000000000000;;	* [Hugo](http://gohugo.io)
0000000000000000000000000000000000000000;;	* [rkt](https://github.com/coreos/rkt)
0000000000000000000000000000000000000000;;	* [etcd](https://github.com/coreos/etcd)
0000000000000000000000000000000000000000;;	* [Docker (distribution)](https://github.com/docker/distribution)
0000000000000000000000000000000000000000;;	* [OpenShift](https://www.openshift.com/)
0000000000000000000000000000000000000000;;	* [Delve](https://github.com/derekparker/delve)
0000000000000000000000000000000000000000;;	* [GopherJS](http://www.gopherjs.org/)
0000000000000000000000000000000000000000;;	* [CockroachDB](http://www.cockroachlabs.com/)
0000000000000000000000000000000000000000;;	* [Bleve](http://www.blevesearch.com/)
0000000000000000000000000000000000000000;;	* [ProjectAtomic (enterprise)](http://www.projectatomic.io/)
0000000000000000000000000000000000000000;;	* [Parse (CLI)](https://parse.com/)
0000000000000000000000000000000000000000;;	* [GiantSwarm's swarm](https://github.com/giantswarm/cli)
0000000000000000000000000000000000000000;;	* [Nanobox](https://github.com/nanobox-io/nanobox)/[Nanopack](https://github.com/nanopack)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![Build Status](https://travis-ci.org/spf13/cobra.svg "Travis CI status")](https://travis-ci.org/spf13/cobra)
0000000000000000000000000000000000000000;;	[![CircleCI status](https://circleci.com/gh/spf13/cobra.png?circle-token=:circle-token "CircleCI status")](https://circleci.com/gh/spf13/cobra)
0000000000000000000000000000000000000000;;	[![GoDoc](https://godoc.org/github.com/spf13/cobra?status.svg)](https://godoc.org/github.com/spf13/cobra) 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	![cobra](https://cloud.githubusercontent.com/assets/173412/10911369/84832a8e-8212-11e5-9f82-cc96660a4794.gif)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Overview
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra is a library providing a simple interface to create powerful modern CLI
0000000000000000000000000000000000000000;;	interfaces similar to git & go tools.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra is also an application that will generate your application scaffolding to rapidly
0000000000000000000000000000000000000000;;	develop a Cobra-based application.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra provides:
0000000000000000000000000000000000000000;;	* Easy subcommand-based CLIs: `app server`, `app fetch`, etc.
0000000000000000000000000000000000000000;;	* Fully POSIX-compliant flags (including short & long versions)
0000000000000000000000000000000000000000;;	* Nested subcommands
0000000000000000000000000000000000000000;;	* Global, local and cascading flags
0000000000000000000000000000000000000000;;	* Easy generation of applications & commands with `cobra create appname` & `cobra add cmdname`
0000000000000000000000000000000000000000;;	* Intelligent suggestions (`app srver`... did you mean `app server`?)
0000000000000000000000000000000000000000;;	* Automatic help generation for commands and flags
0000000000000000000000000000000000000000;;	* Automatic detailed help for `app help [command]`
0000000000000000000000000000000000000000;;	* Automatic help flag recognition of `-h`, `--help`, etc.
0000000000000000000000000000000000000000;;	* Automatically generated bash autocomplete for your application
0000000000000000000000000000000000000000;;	* Automatically generated man pages for your application
0000000000000000000000000000000000000000;;	* Command aliases so you can change things without breaking them
0000000000000000000000000000000000000000;;	* The flexibilty to define your own help, usage, etc.
0000000000000000000000000000000000000000;;	* Optional tight integration with [viper](http://github.com/spf13/viper) for 12-factor apps
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra has an exceptionally clean interface and simple design without needless
0000000000000000000000000000000000000000;;	constructors or initialization methods.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Applications built with Cobra commands are designed to be as user-friendly as
0000000000000000000000000000000000000000;;	possible. Flags can be placed before or after the command (as long as a
0000000000000000000000000000000000000000;;	confusing space isnâ€™t provided). Both short and long flags can be used. A
0000000000000000000000000000000000000000;;	command need not even be fully typed.  Help is automatically generated and
0000000000000000000000000000000000000000;;	available for the application or for a specific command using either the help
0000000000000000000000000000000000000000;;	command or the `--help` flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Concepts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra is built on a structure of commands, arguments & flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Commands** represent actions, **Args** are things and **Flags** are modifiers for those actions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The best applications will read like sentences when used. Users will know how
0000000000000000000000000000000000000000;;	to use the application because they will natively understand how to use it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The pattern to follow is
0000000000000000000000000000000000000000;;	`APPNAME VERB NOUN --ADJECTIVE.`
0000000000000000000000000000000000000000;;	    or
0000000000000000000000000000000000000000;;	`APPNAME COMMAND ARG --FLAG`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A few good real world examples may better illustrate this point.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In the following example, 'server' is a command, and 'port' is a flag:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    > hugo server --port=1313
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In this command we are telling Git to clone the url bare.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    > git clone URL --bare
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Commands
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Command is the central point of the application. Each interaction that
0000000000000000000000000000000000000000;;	the application supports will be contained in a Command. A command can
0000000000000000000000000000000000000000;;	have children commands and optionally run an action.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In the example above, 'server' is the command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A Command has the following structure:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type Command struct {
0000000000000000000000000000000000000000;;	    Use string // The one-line usage message.
0000000000000000000000000000000000000000;;	    Short string // The short description shown in the 'help' output.
0000000000000000000000000000000000000000;;	    Long string // The long message shown in the 'help <this-command>' output.
0000000000000000000000000000000000000000;;	    Run func(cmd *Command, args []string) // Run runs the command.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A Flag is a way to modify the behavior of a command. Cobra supports
0000000000000000000000000000000000000000;;	fully POSIX-compliant flags as well as the Go [flag package](https://golang.org/pkg/flag/).
0000000000000000000000000000000000000000;;	A Cobra command can define flags that persist through to children commands
0000000000000000000000000000000000000000;;	and flags that are only available to that command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In the example above, 'port' is the flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Flag functionality is provided by the [pflag
0000000000000000000000000000000000000000;;	library](https://github.com/ogier/pflag), a fork of the flag standard library
0000000000000000000000000000000000000000;;	which maintains the same interface while adding POSIX compliance.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra works by creating a set of commands and then organizing them into a tree.
0000000000000000000000000000000000000000;;	The tree defines the structure of the application.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Once each command is defined with its corresponding flags, then the
0000000000000000000000000000000000000000;;	tree is assigned to the commander which is finally executed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Installing
0000000000000000000000000000000000000000;;	Using Cobra is easy. First, use `go get` to install the latest version
0000000000000000000000000000000000000000;;	of the library. This command will install the `cobra` generator executible
0000000000000000000000000000000000000000;;	along with the library:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    > go get -v github.com/spf13/cobra/cobra
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Next, include Cobra in your application:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	import "github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Getting Started
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	While you are welcome to provide your own organization, typically a Cobra based
0000000000000000000000000000000000000000;;	application will follow the following organizational structure.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	  â–¾ appName/
0000000000000000000000000000000000000000;;	    â–¾ cmd/
0000000000000000000000000000000000000000;;	        add.go
0000000000000000000000000000000000000000;;	        your.go
0000000000000000000000000000000000000000;;	        commands.go
0000000000000000000000000000000000000000;;	        here.go
0000000000000000000000000000000000000000;;	      main.go
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In a Cobra app, typically the main.go file is very bare. It serves, one purpose, to initialize Cobra.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "{pathToYourApp}/cmd"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		if err := cmd.RootCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Using the Cobra Generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra provides its own program that will create your application and add any
0000000000000000000000000000000000000000;;	commands you want. It's the easiest way to incorporate Cobra into your application.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In order to use the cobra command, compile it using the following command:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    > go install github.com/spf13/cobra/cobra
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This will create the cobra executable under your go path bin directory!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### cobra init
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `cobra init [yourApp]` command will create your initial application code
0000000000000000000000000000000000000000;;	for you. It is a very powerful application that will populate your program with
0000000000000000000000000000000000000000;;	the right structure so you can immediately enjoy all the benefits of Cobra. It
0000000000000000000000000000000000000000;;	will also automatically apply the license you specify to your application.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra init is pretty smart. You can provide it a full path, or simply a path
0000000000000000000000000000000000000000;;	similar to what is expected in the import.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	cobra init github.com/spf13/newAppName
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### cobra add
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Once an application is initialized Cobra can create additional commands for you.
0000000000000000000000000000000000000000;;	Let's say you created an app and you wanted the following commands for it:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* app serve
0000000000000000000000000000000000000000;;	* app config
0000000000000000000000000000000000000000;;	* app config create
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In your project directory (where your main.go file is) you would run the following:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	cobra add serve
0000000000000000000000000000000000000000;;	cobra add config
0000000000000000000000000000000000000000;;	cobra add create -p 'configCmd'
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Once you have run these three commands you would have an app structure that would look like:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	  â–¾ app/
0000000000000000000000000000000000000000;;	    â–¾ cmd/
0000000000000000000000000000000000000000;;	        serve.go
0000000000000000000000000000000000000000;;	        config.go
0000000000000000000000000000000000000000;;	        create.go
0000000000000000000000000000000000000000;;	      main.go
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	at this point you can run `go run main.go` and it would run your app. `go run
0000000000000000000000000000000000000000;;	main.go serve`, `go run main.go config`, `go run main.go config create` along
0000000000000000000000000000000000000000;;	with `go run main.go help serve`, etc would all work.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Obviously you haven't added your own code to these yet, the commands are ready
0000000000000000000000000000000000000000;;	for you to give them their tasks. Have fun.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Configuring the cobra generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The cobra generator will be easier to use if you provide a simple configuration
0000000000000000000000000000000000000000;;	file which will help you eliminate providing a bunch of repeated information in
0000000000000000000000000000000000000000;;	flags over and over.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	An example ~/.cobra.yaml file:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	author: Steve Francia <spf@spf13.com>
0000000000000000000000000000000000000000;;	license: MIT
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can specify no license by setting `license` to `none` or you can specify
0000000000000000000000000000000000000000;;	a custom license:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```yaml
0000000000000000000000000000000000000000;;	license:
0000000000000000000000000000000000000000;;	  header: This file is part of {{ .appName }}.
0000000000000000000000000000000000000000;;	  text: |
0000000000000000000000000000000000000000;;	    {{ .copyright }}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    This is my license. There are many like it, but this one is mine.
0000000000000000000000000000000000000000;;	    My license is my best friend. It is my life. I must master it as I must
0000000000000000000000000000000000000000;;	    master my life.  
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Manually implementing Cobra
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To manually implement cobra you need to create a bare main.go file and a RootCmd file.
0000000000000000000000000000000000000000;;	You will optionally provide additional commands as you see fit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Create the root command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The root command represents your binary itself.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Manually create rootCmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra doesn't require any special constructors. Simply create your commands.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Ideally you place this in app/cmd/root.go:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	var RootCmd = &cobra.Command{
0000000000000000000000000000000000000000;;		Use:   "hugo",
0000000000000000000000000000000000000000;;		Short: "Hugo is a very fast static site generator",
0000000000000000000000000000000000000000;;		Long: `A Fast and Flexible Static Site Generator built with
0000000000000000000000000000000000000000;;	                love by spf13 and friends in Go.
0000000000000000000000000000000000000000;;	                Complete documentation is available at http://hugo.spf13.com`,
0000000000000000000000000000000000000000;;		Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			// Do Stuff Here
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You will additionally define flags and handle configuration in your init() function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	for example cmd/root.go:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		cobra.OnInitialize(initConfig)
0000000000000000000000000000000000000000;;		RootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.cobra.yaml)")
0000000000000000000000000000000000000000;;		RootCmd.PersistentFlags().StringVarP(&projectBase, "projectbase", "b", "", "base project directory eg. github.com/spf13/")
0000000000000000000000000000000000000000;;		RootCmd.PersistentFlags().StringP("author", "a", "YOUR NAME", "Author name for copyright attribution")
0000000000000000000000000000000000000000;;		RootCmd.PersistentFlags().StringVarP(&userLicense, "license", "l", "", "Name of license for the project (can provide `licensetext` in config)")
0000000000000000000000000000000000000000;;		RootCmd.PersistentFlags().Bool("viper", true, "Use Viper for configuration")
0000000000000000000000000000000000000000;;		viper.BindPFlag("author", RootCmd.PersistentFlags().Lookup("author"))
0000000000000000000000000000000000000000;;		viper.BindPFlag("projectbase", RootCmd.PersistentFlags().Lookup("projectbase"))
0000000000000000000000000000000000000000;;		viper.BindPFlag("useViper", RootCmd.PersistentFlags().Lookup("viper"))
0000000000000000000000000000000000000000;;		viper.SetDefault("author", "NAME HERE <EMAIL ADDRESS>")
0000000000000000000000000000000000000000;;		viper.SetDefault("license", "apache")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Create your main.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	With the root command you need to have your main function execute it.
0000000000000000000000000000000000000000;;	Execute should be run on the root for clarity, though it can be called on any command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In a Cobra app, typically the main.go file is very bare. It serves, one purpose, to initialize Cobra.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "{pathToYourApp}/cmd"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		if err := cmd.RootCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			os.Exit(-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Create additional commands
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Additional commands can be defined and typically are each given their own file
0000000000000000000000000000000000000000;;	inside of the cmd/ directory.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you wanted to create a version command you would create cmd/version.go and
0000000000000000000000000000000000000000;;	populate it with the following:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package cmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		RootCmd.AddCommand(versionCmd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var versionCmd = &cobra.Command{
0000000000000000000000000000000000000000;;		Use:   "version",
0000000000000000000000000000000000000000;;		Short: "Print the version number of Hugo",
0000000000000000000000000000000000000000;;		Long:  `All software has versions. This is Hugo's`,
0000000000000000000000000000000000000000;;		Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			fmt.Println("Hugo Static Site Generator v0.9 -- HEAD")
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Attach command to its parent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you notice in the above example we attach the command to its parent. In
0000000000000000000000000000000000000000;;	this case the parent is the rootCmd. In this example we are attaching it to the
0000000000000000000000000000000000000000;;	root, but commands can be attached at any level.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	RootCmd.AddCommand(versionCmd)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Remove a command from its parent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Removing a command is not a common action in simple programs, but it allows 3rd
0000000000000000000000000000000000000000;;	parties to customize an existing command tree.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In this example, we remove the existing `VersionCmd` command of an existing
0000000000000000000000000000000000000000;;	root command, and we replace it with our own version:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	mainlib.RootCmd.RemoveCommand(mainlib.VersionCmd)
0000000000000000000000000000000000000000;;	mainlib.RootCmd.AddCommand(versionCmd)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Working with Flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Flags provide modifiers to control how the action command operates.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Assign flags to a command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Since the flags are defined and used in different locations, we need to
0000000000000000000000000000000000000000;;	define a variable outside with the correct scope to assign the flag to
0000000000000000000000000000000000000000;;	work with.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	var Verbose bool
0000000000000000000000000000000000000000;;	var Source string
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are two different approaches to assign a flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Persistent Flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A flag can be 'persistent' meaning that this flag will be available to the
0000000000000000000000000000000000000000;;	command it's assigned to as well as every command under that command. For
0000000000000000000000000000000000000000;;	global flags, assign a flag as a persistent flag on the root.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	RootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Local Flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A flag can also be assigned locally which will only apply to that specific command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	RootCmd.Flags().StringVarP(&Source, "source", "s", "", "Source directory to read from")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Example
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In the example below, we have defined three commands. Two are at the top level
0000000000000000000000000000000000000000;;	and one (cmdTimes) is a child of one of the top commands. In this case the root
0000000000000000000000000000000000000000;;	is not executable meaning that a subcommand is required. This is accomplished
0000000000000000000000000000000000000000;;	by not providing a 'Run' for the 'rootCmd'.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	We have only defined one flag for a single command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	More documentation about flags is available at https://github.com/spf13/pflag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var echoTimes int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cmdPrint = &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "print [string to print]",
0000000000000000000000000000000000000000;;			Short: "Print anything to the screen",
0000000000000000000000000000000000000000;;			Long: `print is for printing anything back to the screen.
0000000000000000000000000000000000000000;;	            For many years people have printed back to the screen.
0000000000000000000000000000000000000000;;	            `,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Println("Print: " + strings.Join(args, " "))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cmdEcho = &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "echo [string to echo]",
0000000000000000000000000000000000000000;;			Short: "Echo anything to the screen",
0000000000000000000000000000000000000000;;			Long: `echo is for echoing anything back.
0000000000000000000000000000000000000000;;	            Echo works a lot like print, except it has a child command.
0000000000000000000000000000000000000000;;	            `,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Println("Print: " + strings.Join(args, " "))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cmdTimes = &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "times [# times] [string to echo]",
0000000000000000000000000000000000000000;;			Short: "Echo anything to the screen more times",
0000000000000000000000000000000000000000;;			Long: `echo things multiple times back to the user by providing
0000000000000000000000000000000000000000;;	            a count and a string.`,
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				for i := 0; i < echoTimes; i++ {
0000000000000000000000000000000000000000;;					fmt.Println("Echo: " + strings.Join(args, " "))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmdTimes.Flags().IntVarP(&echoTimes, "times", "t", 1, "times to echo the input")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rootCmd = &cobra.Command{Use: "app"}
0000000000000000000000000000000000000000;;		rootCmd.AddCommand(cmdPrint, cmdEcho)
0000000000000000000000000000000000000000;;		cmdEcho.AddCommand(cmdTimes)
0000000000000000000000000000000000000000;;		rootCmd.Execute()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For a more complete example of a larger application, please checkout [Hugo](http://gohugo.io/).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## The Help Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra automatically adds a help command to your application when you have subcommands.
0000000000000000000000000000000000000000;;	This will be called when a user runs 'app help'. Additionally, help will also
0000000000000000000000000000000000000000;;	support all other commands as input. Say, for instance, you have a command called
0000000000000000000000000000000000000000;;	'create' without any additional configuration; Cobra will work when 'app help
0000000000000000000000000000000000000000;;	create' is called.  Every command will automatically have the '--help' flag added.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Example
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following output is automatically generated by Cobra. Nothing beyond the
0000000000000000000000000000000000000000;;	command and flag definitions are needed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    > hugo help
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    hugo is the main command, used to build your Hugo site.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Hugo is a Fast and Flexible Static Site Generator
0000000000000000000000000000000000000000;;	    built with love by spf13 and friends in Go.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Complete documentation is available at http://gohugo.io/.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Usage:
0000000000000000000000000000000000000000;;	      hugo [flags]
0000000000000000000000000000000000000000;;	      hugo [command]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Available Commands:
0000000000000000000000000000000000000000;;	      server          Hugo runs its own webserver to render the files
0000000000000000000000000000000000000000;;	      version         Print the version number of Hugo
0000000000000000000000000000000000000000;;	      config          Print the site configuration
0000000000000000000000000000000000000000;;	      check           Check content in the source directory
0000000000000000000000000000000000000000;;	      benchmark       Benchmark hugo by building a site a number of times.
0000000000000000000000000000000000000000;;	      convert         Convert your content to different formats
0000000000000000000000000000000000000000;;	      new             Create new content for your site
0000000000000000000000000000000000000000;;	      list            Listing out various types of content
0000000000000000000000000000000000000000;;	      undraft         Undraft changes the content's draft status from 'True' to 'False'
0000000000000000000000000000000000000000;;	      genautocomplete Generate shell autocompletion script for Hugo
0000000000000000000000000000000000000000;;	      gendoc          Generate Markdown documentation for the Hugo CLI.
0000000000000000000000000000000000000000;;	      genman          Generate man page for Hugo
0000000000000000000000000000000000000000;;	      import          Import your site from others.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Flags:
0000000000000000000000000000000000000000;;	      -b, --baseURL="": hostname (and path) to the root, e.g. http://spf13.com/
0000000000000000000000000000000000000000;;	      -D, --buildDrafts[=false]: include content marked as draft
0000000000000000000000000000000000000000;;	      -F, --buildFuture[=false]: include content with publishdate in the future
0000000000000000000000000000000000000000;;	          --cacheDir="": filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/
0000000000000000000000000000000000000000;;	          --canonifyURLs[=false]: if true, all relative URLs will be canonicalized using baseURL
0000000000000000000000000000000000000000;;	          --config="": config file (default is path/config.yaml|json|toml)
0000000000000000000000000000000000000000;;	      -d, --destination="": filesystem path to write files to
0000000000000000000000000000000000000000;;	          --disableRSS[=false]: Do not build RSS files
0000000000000000000000000000000000000000;;	          --disableSitemap[=false]: Do not build Sitemap file
0000000000000000000000000000000000000000;;	          --editor="": edit new content with this editor, if provided
0000000000000000000000000000000000000000;;	          --ignoreCache[=false]: Ignores the cache directory for reading but still writes to it
0000000000000000000000000000000000000000;;	          --log[=false]: Enable Logging
0000000000000000000000000000000000000000;;	          --logFile="": Log File path (if set, logging enabled automatically)
0000000000000000000000000000000000000000;;	          --noTimes[=false]: Don't sync modification time of files
0000000000000000000000000000000000000000;;	          --pluralizeListTitles[=true]: Pluralize titles in lists using inflect
0000000000000000000000000000000000000000;;	          --preserveTaxonomyNames[=false]: Preserve taxonomy names as written ("GÃ©rard Depardieu" vs "gerard-depardieu")
0000000000000000000000000000000000000000;;	      -s, --source="": filesystem path to read files relative from
0000000000000000000000000000000000000000;;	          --stepAnalysis[=false]: display memory and timing of different steps of the program
0000000000000000000000000000000000000000;;	      -t, --theme="": theme to use (located in /themes/THEMENAME/)
0000000000000000000000000000000000000000;;	          --uglyURLs[=false]: if true, use /filename.html instead of /filename/
0000000000000000000000000000000000000000;;	      -v, --verbose[=false]: verbose output
0000000000000000000000000000000000000000;;	          --verboseLog[=false]: verbose logging
0000000000000000000000000000000000000000;;	      -w, --watch[=false]: watch filesystem for changes and recreate as needed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Use "hugo [command] --help" for more information about a command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Help is just a command like any other. There is no special logic or behavior
0000000000000000000000000000000000000000;;	around it. In fact, you can provide your own if you want.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Defining your own help
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can provide your own Help command or your own template for the default command to use.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default help command is
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func (c *Command) initHelp() {
0000000000000000000000000000000000000000;;		if c.helpCommand == nil {
0000000000000000000000000000000000000000;;			c.helpCommand = &Command{
0000000000000000000000000000000000000000;;				Use:   "help [command]",
0000000000000000000000000000000000000000;;				Short: "Help about any command",
0000000000000000000000000000000000000000;;				Long: `Help provides help for any command in the application.
0000000000000000000000000000000000000000;;	        Simply type ` + c.Name() + ` help [path to command] for full details.`,
0000000000000000000000000000000000000000;;				Run: c.HelpFunc(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.AddCommand(c.helpCommand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can provide your own command, function or template through the following methods:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	command.SetHelpCommand(cmd *Command)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	command.SetHelpFunc(f func(*Command, []string))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	command.SetHelpTemplate(s string)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The latter two will also apply to any children commands.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When the user provides an invalid flag or invalid command, Cobra responds by
0000000000000000000000000000000000000000;;	showing the user the 'usage'.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Example
0000000000000000000000000000000000000000;;	You may recognize this from the help above. That's because the default help
0000000000000000000000000000000000000000;;	embeds the usage as part of its output.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Usage:
0000000000000000000000000000000000000000;;	      hugo [flags]
0000000000000000000000000000000000000000;;	      hugo [command]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Available Commands:
0000000000000000000000000000000000000000;;	      server          Hugo runs its own webserver to render the files
0000000000000000000000000000000000000000;;	      version         Print the version number of Hugo
0000000000000000000000000000000000000000;;	      config          Print the site configuration
0000000000000000000000000000000000000000;;	      check           Check content in the source directory
0000000000000000000000000000000000000000;;	      benchmark       Benchmark hugo by building a site a number of times.
0000000000000000000000000000000000000000;;	      convert         Convert your content to different formats
0000000000000000000000000000000000000000;;	      new             Create new content for your site
0000000000000000000000000000000000000000;;	      list            Listing out various types of content
0000000000000000000000000000000000000000;;	      undraft         Undraft changes the content's draft status from 'True' to 'False'
0000000000000000000000000000000000000000;;	      genautocomplete Generate shell autocompletion script for Hugo
0000000000000000000000000000000000000000;;	      gendoc          Generate Markdown documentation for the Hugo CLI.
0000000000000000000000000000000000000000;;	      genman          Generate man page for Hugo
0000000000000000000000000000000000000000;;	      import          Import your site from others.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    Flags:
0000000000000000000000000000000000000000;;	      -b, --baseURL="": hostname (and path) to the root, e.g. http://spf13.com/
0000000000000000000000000000000000000000;;	      -D, --buildDrafts[=false]: include content marked as draft
0000000000000000000000000000000000000000;;	      -F, --buildFuture[=false]: include content with publishdate in the future
0000000000000000000000000000000000000000;;	          --cacheDir="": filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/
0000000000000000000000000000000000000000;;	          --canonifyURLs[=false]: if true, all relative URLs will be canonicalized using baseURL
0000000000000000000000000000000000000000;;	          --config="": config file (default is path/config.yaml|json|toml)
0000000000000000000000000000000000000000;;	      -d, --destination="": filesystem path to write files to
0000000000000000000000000000000000000000;;	          --disableRSS[=false]: Do not build RSS files
0000000000000000000000000000000000000000;;	          --disableSitemap[=false]: Do not build Sitemap file
0000000000000000000000000000000000000000;;	          --editor="": edit new content with this editor, if provided
0000000000000000000000000000000000000000;;	          --ignoreCache[=false]: Ignores the cache directory for reading but still writes to it
0000000000000000000000000000000000000000;;	          --log[=false]: Enable Logging
0000000000000000000000000000000000000000;;	          --logFile="": Log File path (if set, logging enabled automatically)
0000000000000000000000000000000000000000;;	          --noTimes[=false]: Don't sync modification time of files
0000000000000000000000000000000000000000;;	          --pluralizeListTitles[=true]: Pluralize titles in lists using inflect
0000000000000000000000000000000000000000;;	          --preserveTaxonomyNames[=false]: Preserve taxonomy names as written ("GÃ©rard Depardieu" vs "gerard-depardieu")
0000000000000000000000000000000000000000;;	      -s, --source="": filesystem path to read files relative from
0000000000000000000000000000000000000000;;	          --stepAnalysis[=false]: display memory and timing of different steps of the program
0000000000000000000000000000000000000000;;	      -t, --theme="": theme to use (located in /themes/THEMENAME/)
0000000000000000000000000000000000000000;;	          --uglyURLs[=false]: if true, use /filename.html instead of /filename/
0000000000000000000000000000000000000000;;	      -v, --verbose[=false]: verbose output
0000000000000000000000000000000000000000;;	          --verboseLog[=false]: verbose logging
0000000000000000000000000000000000000000;;	      -w, --watch[=false]: watch filesystem for changes and recreate as needed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Defining your own usage
0000000000000000000000000000000000000000;;	You can provide your own usage function or template for Cobra to use.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default usage function is:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	return func(c *Command) error {
0000000000000000000000000000000000000000;;		err := tmpl(c.Out(), c.UsageTemplate(), c)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Like help, the function and template are overridable through public methods:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	command.SetUsageFunc(f func(*Command) error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	command.SetUsageTemplate(s string)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## PreRun or PostRun Hooks
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It is possible to run functions before or after the main `Run` function of your command. The `PersistentPreRun` and `PreRun` functions will be executed before `Run`. `PersistentPostRun` and `PostRun` will be executed after `Run`.  The `Persistent*Run` functions will be inherrited by children if they do not declare their own.  These function are run in the following order:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `PersistentPreRun`
0000000000000000000000000000000000000000;;	- `PreRun`
0000000000000000000000000000000000000000;;	- `Run`
0000000000000000000000000000000000000000;;	- `PostRun`
0000000000000000000000000000000000000000;;	- `PersistentPostRun`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	An example of two commands which use all of these features is below.  When the subcommand is executed, it will run the root command's `PersistentPreRun` but not the root command's `PersistentPostRun`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rootCmd = &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "root [sub]",
0000000000000000000000000000000000000000;;			Short: "My root command",
0000000000000000000000000000000000000000;;			PersistentPreRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside rootCmd PersistentPreRun with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PreRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside rootCmd PreRun with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside rootCmd Run with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PostRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside rootCmd PostRun with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PersistentPostRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside rootCmd PersistentPostRun with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var subCmd = &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "sub [no options!]",
0000000000000000000000000000000000000000;;			Short: "My subcommand",
0000000000000000000000000000000000000000;;			PreRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside subCmd PreRun with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside subCmd Run with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PostRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside subCmd PostRun with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			PersistentPostRun: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;				fmt.Printf("Inside subCmd PersistentPostRun with args: %v\n", args)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootCmd.AddCommand(subCmd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootCmd.SetArgs([]string{""})
0000000000000000000000000000000000000000;;		_ = rootCmd.Execute()
0000000000000000000000000000000000000000;;		fmt.Print("\n")
0000000000000000000000000000000000000000;;		rootCmd.SetArgs([]string{"sub", "arg1", "arg2"})
0000000000000000000000000000000000000000;;		_ = rootCmd.Execute()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Alternative Error Handling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra also has functions where the return signature is an error. This allows for errors to bubble up to the top,
0000000000000000000000000000000000000000;;	providing a way to handle the errors in one location. The current list of functions that return an error is:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* PersistentPreRunE
0000000000000000000000000000000000000000;;	* PreRunE
0000000000000000000000000000000000000000;;	* RunE
0000000000000000000000000000000000000000;;	* PostRunE
0000000000000000000000000000000000000000;;	* PersistentPostRunE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you would like to silence the default `error` and `usage` output in favor of your own, you can set `SilenceUsage`
0000000000000000000000000000000000000000;;	and `SilenceErrors` to `false` on the command. A child command respects these flags if they are set on the parent
0000000000000000000000000000000000000000;;	command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Example Usage using RunE:**
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		var rootCmd = &cobra.Command{
0000000000000000000000000000000000000000;;			Use:   "hugo",
0000000000000000000000000000000000000000;;			Short: "Hugo is a very fast static site generator",
0000000000000000000000000000000000000000;;			Long: `A Fast and Flexible Static Site Generator built with
0000000000000000000000000000000000000000;;	                love by spf13 and friends in Go.
0000000000000000000000000000000000000000;;	                Complete documentation is available at http://hugo.spf13.com`,
0000000000000000000000000000000000000000;;			RunE: func(cmd *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;				// Do Stuff Here
0000000000000000000000000000000000000000;;				return errors.New("some random error")
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := rootCmd.Execute(); err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Suggestions when "unknown command" happens
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra will print automatic suggestions when "unknown command" errors happen. This allows Cobra to behave similarly to the `git` command when a typo happens. For example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	$ hugo srever
0000000000000000000000000000000000000000;;	Error: unknown command "srever" for "hugo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Did you mean this?
0000000000000000000000000000000000000000;;	        server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Run 'hugo --help' for usage.
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Suggestions are automatic based on every subcommand registered and use an implementation of [Levenshtein distance](http://en.wikipedia.org/wiki/Levenshtein_distance). Every registered command that matches a minimum distance of 2 (ignoring case) will be displayed as a suggestion.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you need to disable suggestions or tweak the string distance in your command, use:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	command.DisableSuggestions = true
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	or
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	command.SuggestionsMinimumDistance = 1
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also explicitly set names for which a given command will be suggested using the `SuggestFor` attribute. This allows suggestions for strings that are not close in terms of string distance, but makes sense in your set of commands and for some which you don't want aliases. Example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	$ kubectl remove
0000000000000000000000000000000000000000;;	Error: unknown command "remove" for "kubectl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Did you mean this?
0000000000000000000000000000000000000000;;	        delete
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Run 'kubectl help' for usage.
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Generating Markdown-formatted documentation for your command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra can generate a Markdown-formatted document based on the subcommands, flags, etc. A simple example of how to do this for your command can be found in [Markdown Docs](doc/md_docs.md).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Generating man pages for your command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra can generate a man page based on the subcommands, flags, etc. A simple example of how to do this for your command can be found in [Man Docs](doc/man_docs.md).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Generating bash completions for your command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra can generate a bash-completion file. If you add more information to your command, these completions can be amazingly powerful and flexible.  Read more about it in [Bash Completions](bash_completions.md).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Debugging
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra provides a â€˜DebugFlagsâ€™ method on a command which, when called, will print
0000000000000000000000000000000000000000;;	out everything Cobra knows about the flags for each command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Example
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	command.DebugFlags()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Release Notes
0000000000000000000000000000000000000000;;	* **0.9.0** June 17, 2014
0000000000000000000000000000000000000000;;	  * flags can appears anywhere in the args (provided they are unambiguous)
0000000000000000000000000000000000000000;;	  * --help prints usage screen for app or command
0000000000000000000000000000000000000000;;	  * Prefix matching for commands
0000000000000000000000000000000000000000;;	  * Cleaner looking help and usage output
0000000000000000000000000000000000000000;;	  * Extensive test suite
0000000000000000000000000000000000000000;;	* **0.8.0** Nov 5, 2013
0000000000000000000000000000000000000000;;	  * Reworked interface to remove commander completely
0000000000000000000000000000000000000000;;	  * Command now primary structure
0000000000000000000000000000000000000000;;	  * No initialization needed
0000000000000000000000000000000000000000;;	  * Usage & Help templates & functions definable at any level
0000000000000000000000000000000000000000;;	  * Updated Readme
0000000000000000000000000000000000000000;;	* **0.7.0** Sept 24, 2013
0000000000000000000000000000000000000000;;	  * Needs more eyes
0000000000000000000000000000000000000000;;	  * Test suite
0000000000000000000000000000000000000000;;	  * Support for automatic error messages
0000000000000000000000000000000000000000;;	  * Support for help command
0000000000000000000000000000000000000000;;	  * Support for printing to any io.Writer instead of os.Stderr
0000000000000000000000000000000000000000;;	  * Support for persistent flags which cascade down tree
0000000000000000000000000000000000000000;;	  * Ready for integration into Hugo
0000000000000000000000000000000000000000;;	* **0.1.0** Sept 3, 2013
0000000000000000000000000000000000000000;;	  * Implement first draft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Extensions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Libraries for extending Cobra:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [cmdns](https://github.com/gosuri/cmdns): Enables name spacing a command's immediate children. It provides an alternative way to structure subcommands, similar to `heroku apps:create` and `ovrclk clusters:launch`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## ToDo
0000000000000000000000000000000000000000;;	* Launch proper documentation site
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Contributing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. Fork it
0000000000000000000000000000000000000000;;	2. Create your feature branch (`git checkout -b my-new-feature`)
0000000000000000000000000000000000000000;;	3. Commit your changes (`git commit -am 'Add some feature'`)
0000000000000000000000000000000000000000;;	4. Push to the branch (`git push origin my-new-feature`)
0000000000000000000000000000000000000000;;	5. Create new Pull Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Contributors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Names in no particular order:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [spf13](https://github.com/spf13),
0000000000000000000000000000000000000000;;	[eparis](https://github.com/eparis),
0000000000000000000000000000000000000000;;	[bep](https://github.com/bep), and many more!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## License
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cobra is released under the Apache 2.0 license. See [LICENSE.txt](https://github.com/spf13/cobra/blob/master/LICENSE.txt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/spf13/cobra/trend.png)](https://bitdeli.com/free "Bitdeli Badge")
