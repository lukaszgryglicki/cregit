0000000000000000000000000000000000000000;;	// Copyright 2015 Red Hat Inc. All rights reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
92b31656445fa19f3dada8d222903a554478c1d6;Godeps/_workspace/src/github.com/spf13/cobra/man_docs.go[Godeps/_workspace/src/github.com/spf13/cobra/man_docs.go][vendor/github.com/spf13/cobra/doc/man_docs.go];	
0000000000000000000000000000000000000000;;	package doc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mangen "github.com/cpuguy83/go-md2man/md2man"
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenManTree will generate a man page for this command and all descendants
0000000000000000000000000000000000000000;;	// in the directory given. The header may be nil. This function may not work
0000000000000000000000000000000000000000;;	// correctly if your command names have - in them. If you have `cmd` with two
0000000000000000000000000000000000000000;;	// subcmds, `sub` and `sub-third`. And `sub` has a subcommand called `third`
0000000000000000000000000000000000000000;;	// it is undefined which help output will be in the file `cmd-sub-third.1`.
0000000000000000000000000000000000000000;;	func GenManTree(cmd *cobra.Command, header *GenManHeader, dir string) error {
0000000000000000000000000000000000000000;;		return GenManTreeFromOpts(cmd, GenManTreeOptions{
0000000000000000000000000000000000000000;;			Header:           header,
0000000000000000000000000000000000000000;;			Path:             dir,
0000000000000000000000000000000000000000;;			CommandSeparator: "_",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenManTreeFromOpts generates a man page for the command and all descendants.
0000000000000000000000000000000000000000;;	// The pages are written to the opts.Path directory.
0000000000000000000000000000000000000000;;	func GenManTreeFromOpts(cmd *cobra.Command, opts GenManTreeOptions) error {
0000000000000000000000000000000000000000;;		header := opts.Header
0000000000000000000000000000000000000000;;		if header == nil {
0000000000000000000000000000000000000000;;			header = &GenManHeader{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range cmd.Commands() {
0000000000000000000000000000000000000000;;			if !c.IsAvailableCommand() || c.IsHelpCommand() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := GenManTreeFromOpts(c, opts); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		section := "1"
0000000000000000000000000000000000000000;;		if header.Section != "" {
0000000000000000000000000000000000000000;;			section = header.Section
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		separator := "_"
0000000000000000000000000000000000000000;;		if opts.CommandSeparator != "" {
0000000000000000000000000000000000000000;;			separator = opts.CommandSeparator
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		basename := strings.Replace(cmd.CommandPath(), " ", separator, -1)
0000000000000000000000000000000000000000;;		filename := filepath.Join(opts.Path, basename + "." + section)
0000000000000000000000000000000000000000;;		f, err := os.Create(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerCopy := *header
0000000000000000000000000000000000000000;;		return GenMan(cmd, &headerCopy, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GenManTreeOptions struct {
0000000000000000000000000000000000000000;;		Header           *GenManHeader
0000000000000000000000000000000000000000;;		Path             string
0000000000000000000000000000000000000000;;		CommandSeparator string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenManHeader is a lot like the .TH header at the start of man pages. These
0000000000000000000000000000000000000000;;	// include the title, section, date, source, and manual. We will use the
0000000000000000000000000000000000000000;;	// current time if Date if unset and will use "Auto generated by spf13/cobra"
0000000000000000000000000000000000000000;;	// if the Source is unset.
0000000000000000000000000000000000000000;;	type GenManHeader struct {
0000000000000000000000000000000000000000;;		Title   string
0000000000000000000000000000000000000000;;		Section string
0000000000000000000000000000000000000000;;		Date    *time.Time
0000000000000000000000000000000000000000;;		date    string
0000000000000000000000000000000000000000;;		Source  string
0000000000000000000000000000000000000000;;		Manual  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenMan will generate a man page for the given command and write it to
0000000000000000000000000000000000000000;;	// w. The header argument may be nil, however obviously w may not.
0000000000000000000000000000000000000000;;	func GenMan(cmd *cobra.Command, header *GenManHeader, w io.Writer) error {
0000000000000000000000000000000000000000;;		if header == nil {
0000000000000000000000000000000000000000;;			header = &GenManHeader{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fillHeader(header, cmd.CommandPath())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := genMan(cmd, header)
0000000000000000000000000000000000000000;;		_, err := w.Write(mangen.Render(b))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fillHeader(header *GenManHeader, name string) {
0000000000000000000000000000000000000000;;		if header.Title == "" {
0000000000000000000000000000000000000000;;			header.Title = strings.ToUpper(strings.Replace(name, " ", "\\-", -1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if header.Section == "" {
0000000000000000000000000000000000000000;;			header.Section = "1"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if header.Date == nil {
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			header.Date = &now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		header.date = (*header.Date).Format("Jan 2006")
0000000000000000000000000000000000000000;;		if header.Source == "" {
0000000000000000000000000000000000000000;;			header.Source = "Auto generated by spf13/cobra"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func manPreamble(out io.Writer, header *GenManHeader, cmd *cobra.Command, dashedName string) {
0000000000000000000000000000000000000000;;		description := cmd.Long
0000000000000000000000000000000000000000;;		if len(description) == 0 {
0000000000000000000000000000000000000000;;			description = cmd.Short
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, `%% %s(%s)%s
0000000000000000000000000000000000000000;;	%% %s
0000000000000000000000000000000000000000;;	%% %s
0000000000000000000000000000000000000000;;	# NAME
0000000000000000000000000000000000000000;;	`, header.Title, header.Section, header.date, header.Source, header.Manual)
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "%s \\- %s\n\n", dashedName, cmd.Short)
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "# SYNOPSIS\n")
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "**%s**\n\n", cmd.UseLine())
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "# DESCRIPTION\n")
0000000000000000000000000000000000000000;;		fmt.Fprintf(out, "%s\n\n", description)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func manPrintFlags(out io.Writer, flags *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		flags.VisitAll(func(flag *pflag.Flag) {
0000000000000000000000000000000000000000;;			if len(flag.Deprecated) > 0 || flag.Hidden {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			format := ""
0000000000000000000000000000000000000000;;			if len(flag.Shorthand) > 0 && len(flag.ShorthandDeprecated) == 0 {
0000000000000000000000000000000000000000;;				format = fmt.Sprintf("**-%s**, **--%s**", flag.Shorthand, flag.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				format = fmt.Sprintf("**--%s**", flag.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(flag.NoOptDefVal) > 0 {
0000000000000000000000000000000000000000;;				format = format + "["
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if flag.Value.Type() == "string" {
0000000000000000000000000000000000000000;;				// put quotes on the value
0000000000000000000000000000000000000000;;				format = format + "=%q"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				format = format + "=%s"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(flag.NoOptDefVal) > 0 {
0000000000000000000000000000000000000000;;				format = format + "]"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			format = format + "\n\t%s\n\n"
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, format, flag.DefValue, flag.Usage)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func manPrintOptions(out io.Writer, command *cobra.Command) {
0000000000000000000000000000000000000000;;		flags := command.NonInheritedFlags()
0000000000000000000000000000000000000000;;		if flags.HasFlags() {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "# OPTIONS\n")
0000000000000000000000000000000000000000;;			manPrintFlags(out, flags)
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flags = command.InheritedFlags()
0000000000000000000000000000000000000000;;		if flags.HasFlags() {
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "# OPTIONS INHERITED FROM PARENT COMMANDS\n")
0000000000000000000000000000000000000000;;			manPrintFlags(out, flags)
0000000000000000000000000000000000000000;;			fmt.Fprintf(out, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genMan(cmd *cobra.Command, header *GenManHeader) []byte {
0000000000000000000000000000000000000000;;		// something like `rootcmd-subcmd1-subcmd2`
0000000000000000000000000000000000000000;;		dashCommandName := strings.Replace(cmd.CommandPath(), " ", "-", -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		manPreamble(buf, header, cmd, dashCommandName)
0000000000000000000000000000000000000000;;		manPrintOptions(buf, cmd)
0000000000000000000000000000000000000000;;		if len(cmd.Example) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "# EXAMPLE\n")
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "```\n%s\n```\n", cmd.Example)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasSeeAlso(cmd) {
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "# SEE ALSO\n")
0000000000000000000000000000000000000000;;			seealsos := make([]string, 0)
0000000000000000000000000000000000000000;;			if cmd.HasParent() {
0000000000000000000000000000000000000000;;				parentPath := cmd.Parent().CommandPath()
0000000000000000000000000000000000000000;;				dashParentPath := strings.Replace(parentPath, " ", "-", -1)
0000000000000000000000000000000000000000;;				seealso := fmt.Sprintf("**%s(%s)**", dashParentPath, header.Section)
0000000000000000000000000000000000000000;;				seealsos = append(seealsos, seealso)
0000000000000000000000000000000000000000;;				cmd.VisitParents(func(c *cobra.Command) {
0000000000000000000000000000000000000000;;					if c.DisableAutoGenTag {
0000000000000000000000000000000000000000;;						cmd.DisableAutoGenTag = c.DisableAutoGenTag
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			children := cmd.Commands()
0000000000000000000000000000000000000000;;			sort.Sort(byName(children))
0000000000000000000000000000000000000000;;			for _, c := range children {
0000000000000000000000000000000000000000;;				if !c.IsAvailableCommand() || c.IsHelpCommand() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				seealso := fmt.Sprintf("**%s-%s(%s)**", dashCommandName, c.Name(), header.Section)
0000000000000000000000000000000000000000;;				seealsos = append(seealsos, seealso)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "%s\n", strings.Join(seealsos, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cmd.DisableAutoGenTag {
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, "# HISTORY\n%s Auto generated by spf13/cobra\n", header.Date.Format("2-Jan-2006"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Bytes()
0000000000000000000000000000000000000000;;	}
