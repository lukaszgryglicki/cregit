0000000000000000000000000000000000000000;;	# Generating Bash Completions For Your Own cobra.Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Generating bash completions from a cobra command is incredibly easy. An actual program which does so for the kubernetes kubectl binary is as follows:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;	        "io/ioutil"
0000000000000000000000000000000000000000;;	        "os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        "github.com/GoogleCloudPlatform/kubernetes/pkg/kubectl/cmd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;	        kubectl := cmd.NewFactory(nil).NewKubectlCommand(os.Stdin, ioutil.Discard, ioutil.Discard)
0000000000000000000000000000000000000000;;	        kubectl.GenBashCompletionFile("out.sh")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	That will get you completions of subcommands and flags. If you make additional annotations to your code, you can get even more intelligent and flexible behavior.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Creating your own custom functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Some more actual code that works in kubernetes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;	        bash_completion_func = `__kubectl_parse_get()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    local kubectl_output out
0000000000000000000000000000000000000000;;	    if kubectl_output=$(kubectl get --no-headers "$1" 2>/dev/null); then
0000000000000000000000000000000000000000;;	        out=($(echo "${kubectl_output}" | awk '{print $1}'))
0000000000000000000000000000000000000000;;	        COMPREPLY=( $( compgen -W "${out[*]}" -- "$cur" ) )
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__kubectl_get_resource()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    if [[ ${#nouns[@]} -eq 0 ]]; then
0000000000000000000000000000000000000000;;	        return 1
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	    __kubectl_parse_get ${nouns[${#nouns[@]} -1]}
0000000000000000000000000000000000000000;;	    if [[ $? -eq 0 ]]; then
0000000000000000000000000000000000000000;;	        return 0
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	__custom_func() {
0000000000000000000000000000000000000000;;	    case ${last_command} in
0000000000000000000000000000000000000000;;	        kubectl_get | kubectl_describe | kubectl_delete | kubectl_stop)
0000000000000000000000000000000000000000;;	            __kubectl_get_resource
0000000000000000000000000000000000000000;;	            return
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	        *)
0000000000000000000000000000000000000000;;	            ;;
0000000000000000000000000000000000000000;;	    esac
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	And then I set that in my command definition:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cmds := &cobra.Command{
0000000000000000000000000000000000000000;;		Use:   "kubectl",
0000000000000000000000000000000000000000;;		Short: "kubectl controls the Kubernetes cluster manager",
0000000000000000000000000000000000000000;;		Long: `kubectl controls the Kubernetes cluster manager.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Find more information at https://github.com/GoogleCloudPlatform/kubernetes.`,
0000000000000000000000000000000000000000;;		Run: runHelp,
0000000000000000000000000000000000000000;;		BashCompletionFunction: bash_completion_func,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `BashCompletionFunction` option is really only valid/useful on the root command. Doing the above will cause `__custom_func()` to be called when the built in processor was unable to find a solution. In the case of kubernetes a valid command might look something like `kubectl get pod [mypod]`. If you type `kubectl get pod [tab][tab]` the `__customc_func()` will run because the cobra.Command only understood "kubectl" and "get." `__custom_func()` will see that the cobra.Command is "kubectl_get" and will thus call another helper `__kubectl_get_resource()`.  `__kubectl_get_resource` will look at the 'nouns' collected. In our example the only noun will be `pod`.  So it will call `__kubectl_parse_get pod`.  `__kubectl_parse_get` will actually call out to kubernetes and get any pods.  It will then set `COMPREPLY` to valid pods!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Have the completions code complete your 'nouns'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In the above example "pod" was assumed to already be typed. But if you want `kubectl get [tab][tab]` to show a list of valid "nouns" you have to set them. Simplified code from `kubectl get` looks like:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	validArgs []string = { "pod", "node", "service", "replicationcontroller" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	cmd := &cobra.Command{
0000000000000000000000000000000000000000;;		Use:     "get [(-o|--output=)json|yaml|template|...] (RESOURCE [NAME] | RESOURCE/NAME ...)",
0000000000000000000000000000000000000000;;		Short:   "Display one or many resources",
0000000000000000000000000000000000000000;;		Long:    get_long,
0000000000000000000000000000000000000000;;		Example: get_example,
0000000000000000000000000000000000000000;;		Run: func(cmd *cobra.Command, args []string) {
0000000000000000000000000000000000000000;;			err := RunGet(f, out, cmd, args)
0000000000000000000000000000000000000000;;			util.CheckErr(err)
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		ValidArgs: validArgs,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Notice we put the "ValidArgs" on the "get" subcommand. Doing so will give results like
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	# kubectl get [tab][tab]
0000000000000000000000000000000000000000;;	node                 pod                    replicationcontroller  service
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Plural form and shortcuts for nouns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If your nouns have a number of aliases, you can define them alongside `ValidArgs` using `ArgAliases`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go`
0000000000000000000000000000000000000000;;	argAliases []string = { "pods", "nodes", "services", "svc", "replicationcontrollers", "rc" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	cmd := &cobra.Command{
0000000000000000000000000000000000000000;;	    ...
0000000000000000000000000000000000000000;;		ValidArgs:  validArgs,
0000000000000000000000000000000000000000;;		ArgAliases: argAliases
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The aliases are not shown to the user on tab completion, but they are accepted as valid nouns by
0000000000000000000000000000000000000000;;	the completion algorithm if entered manually, e.g. in:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	# kubectl get rc [tab][tab]
0000000000000000000000000000000000000000;;	backend        frontend       database 
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note that without declaring `rc` as an alias, the completion algorithm would show the list of nouns
0000000000000000000000000000000000000000;;	in this example again instead of the replication controllers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Mark flags as required
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Most of the time completions will only show subcommands. But if a flag is required to make a subcommand work, you probably want it to show up when the user types [tab][tab].  Marking a flag as 'Required' is incredibly easy.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cmd.MarkFlagRequired("pod")
0000000000000000000000000000000000000000;;	cmd.MarkFlagRequired("container")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	and you'll get something like
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	# kubectl exec [tab][tab][tab]
0000000000000000000000000000000000000000;;	-c            --container=  -p            --pod=  
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Specify valid filename extensions for flags that take a filename
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In this example we use --filename= and expect to get a json or yaml file as the argument. To make this easier we annotate the --filename flag with valid filename extensions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;		annotations := []string{"json", "yaml", "yml"}
0000000000000000000000000000000000000000;;		annotation := make(map[string][]string)
0000000000000000000000000000000000000000;;		annotation[cobra.BashCompFilenameExt] = annotations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag := &pflag.Flag{
0000000000000000000000000000000000000000;;			Name:        "filename",
0000000000000000000000000000000000000000;;			Shorthand:   "f",
0000000000000000000000000000000000000000;;			Usage:       usage,
0000000000000000000000000000000000000000;;			Value:       value,
0000000000000000000000000000000000000000;;			DefValue:    value.String(),
0000000000000000000000000000000000000000;;			Annotations: annotation,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().AddFlag(flag)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now when you run a command with this filename flag you'll get something like
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	# kubectl create -f 
0000000000000000000000000000000000000000;;	test/                         example/                      rpmbuild/
0000000000000000000000000000000000000000;;	hello.yml                     test.json
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	So while there are many other files in the CWD it only shows me subdirs and those with valid extensions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Specifiy custom flag completion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Similar to the filename completion and filtering using cobra.BashCompFilenameExt, you can specifiy
0000000000000000000000000000000000000000;;	a custom flag completion function with cobra.BashCompCustom:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;		annotation := make(map[string][]string)
0000000000000000000000000000000000000000;;		annotation[cobra.BashCompFilenameExt] = []string{"__kubectl_get_namespaces"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag := &pflag.Flag{
0000000000000000000000000000000000000000;;			Name:        "namespace",
0000000000000000000000000000000000000000;;			Usage:       usage,
0000000000000000000000000000000000000000;;			Annotations: annotation,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd.Flags().AddFlag(flag)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In addition add the `__handle_namespace_flag` implementation in the `BashCompletionFunction`
0000000000000000000000000000000000000000;;	value, e.g.:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	__kubectl_get_namespaces()
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    local template
0000000000000000000000000000000000000000;;	    template="{{ range .items  }}{{ .metadata.name }} {{ end }}"
0000000000000000000000000000000000000000;;	    local kubectl_out
0000000000000000000000000000000000000000;;	    if kubectl_out=$(kubectl get -o template --template="${template}" namespace 2>/dev/null); then
0000000000000000000000000000000000000000;;	        COMPREPLY=( $( compgen -W "${kubectl_out}[*]" -- "$cur" ) )
0000000000000000000000000000000000000000;;	    fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
