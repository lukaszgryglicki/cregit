0000000000000000000000000000000000000000;;	// Copyright Â© 2013 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
0e1ba9a8116c18bfa1975dc7ebd4f015c258b467;Godeps/_workspace/src/github.com/spf13/cobra/command.go[Godeps/_workspace/src/github.com/spf13/cobra/command.go][vendor/github.com/spf13/cobra/command.go];	
0000000000000000000000000000000000000000;;	//Package cobra is a commander providing a simple interface to create powerful modern CLI interfaces.
0000000000000000000000000000000000000000;;	//In addition to providing an interface, Cobra simultaneously provides a controller to organize your application code.
0000000000000000000000000000000000000000;;	package cobra
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Command is just that, a command for your application.
0000000000000000000000000000000000000000;;	// eg.  'go run' ... 'run' is the command. Cobra requires
0000000000000000000000000000000000000000;;	// you to define the usage and description as part of your command
0000000000000000000000000000000000000000;;	// definition to ensure usability.
0000000000000000000000000000000000000000;;	type Command struct {
0000000000000000000000000000000000000000;;		// Name is the command name, usually the executable's name.
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// The one-line usage message.
0000000000000000000000000000000000000000;;		Use string
0000000000000000000000000000000000000000;;		// An array of aliases that can be used instead of the first word in Use.
0000000000000000000000000000000000000000;;		Aliases []string
0000000000000000000000000000000000000000;;		// An array of command names for which this command will be suggested - similar to aliases but only suggests.
0000000000000000000000000000000000000000;;		SuggestFor []string
0000000000000000000000000000000000000000;;		// The short description shown in the 'help' output.
0000000000000000000000000000000000000000;;		Short string
0000000000000000000000000000000000000000;;		// The long message shown in the 'help <this-command>' output.
0000000000000000000000000000000000000000;;		Long string
0000000000000000000000000000000000000000;;		// Examples of how to use the command
0000000000000000000000000000000000000000;;		Example string
0000000000000000000000000000000000000000;;		// List of all valid non-flag arguments that are accepted in bash completions
0000000000000000000000000000000000000000;;		ValidArgs []string
0000000000000000000000000000000000000000;;		// List of aliases for ValidArgs. These are not suggested to the user in the bash
0000000000000000000000000000000000000000;;		// completion, but accepted if entered manually.
0000000000000000000000000000000000000000;;		ArgAliases []string
0000000000000000000000000000000000000000;;		// Custom functions used by the bash autocompletion generator
0000000000000000000000000000000000000000;;		BashCompletionFunction string
0000000000000000000000000000000000000000;;		// Is this command deprecated and should print this string when used?
0000000000000000000000000000000000000000;;		Deprecated string
0000000000000000000000000000000000000000;;		// Is this command hidden and should NOT show up in the list of available commands?
0000000000000000000000000000000000000000;;		Hidden bool
0000000000000000000000000000000000000000;;		// Full set of flags
0000000000000000000000000000000000000000;;		flags *flag.FlagSet
0000000000000000000000000000000000000000;;		// Set of flags childrens of this command will inherit
0000000000000000000000000000000000000000;;		pflags *flag.FlagSet
0000000000000000000000000000000000000000;;		// Flags that are declared specifically by this command (not inherited).
0000000000000000000000000000000000000000;;		lflags *flag.FlagSet
0000000000000000000000000000000000000000;;		// SilenceErrors is an option to quiet errors down stream
0000000000000000000000000000000000000000;;		SilenceErrors bool
0000000000000000000000000000000000000000;;		// Silence Usage is an option to silence usage when an error occurs.
0000000000000000000000000000000000000000;;		SilenceUsage bool
0000000000000000000000000000000000000000;;		// The *Run functions are executed in the following order:
0000000000000000000000000000000000000000;;		//   * PersistentPreRun()
0000000000000000000000000000000000000000;;		//   * PreRun()
0000000000000000000000000000000000000000;;		//   * Run()
0000000000000000000000000000000000000000;;		//   * PostRun()
0000000000000000000000000000000000000000;;		//   * PersistentPostRun()
0000000000000000000000000000000000000000;;		// All functions get the same args, the arguments after the command name
0000000000000000000000000000000000000000;;		// PersistentPreRun: children of this command will inherit and execute
0000000000000000000000000000000000000000;;		PersistentPreRun func(cmd *Command, args []string)
0000000000000000000000000000000000000000;;		// PersistentPreRunE: PersistentPreRun but returns an error
0000000000000000000000000000000000000000;;		PersistentPreRunE func(cmd *Command, args []string) error
0000000000000000000000000000000000000000;;		// PreRun: children of this command will not inherit.
0000000000000000000000000000000000000000;;		PreRun func(cmd *Command, args []string)
0000000000000000000000000000000000000000;;		// PreRunE: PreRun but returns an error
0000000000000000000000000000000000000000;;		PreRunE func(cmd *Command, args []string) error
0000000000000000000000000000000000000000;;		// Run: Typically the actual work function. Most commands will only implement this
0000000000000000000000000000000000000000;;		Run func(cmd *Command, args []string)
0000000000000000000000000000000000000000;;		// RunE: Run but returns an error
0000000000000000000000000000000000000000;;		RunE func(cmd *Command, args []string) error
0000000000000000000000000000000000000000;;		// PostRun: run after the Run command.
0000000000000000000000000000000000000000;;		PostRun func(cmd *Command, args []string)
0000000000000000000000000000000000000000;;		// PostRunE: PostRun but returns an error
0000000000000000000000000000000000000000;;		PostRunE func(cmd *Command, args []string) error
0000000000000000000000000000000000000000;;		// PersistentPostRun: children of this command will inherit and execute after PostRun
0000000000000000000000000000000000000000;;		PersistentPostRun func(cmd *Command, args []string)
0000000000000000000000000000000000000000;;		// PersistentPostRunE: PersistentPostRun but returns an error
0000000000000000000000000000000000000000;;		PersistentPostRunE func(cmd *Command, args []string) error
0000000000000000000000000000000000000000;;		// DisableAutoGenTag remove
0000000000000000000000000000000000000000;;		DisableAutoGenTag bool
0000000000000000000000000000000000000000;;		// Commands is the list of commands supported by this program.
0000000000000000000000000000000000000000;;		commands []*Command
0000000000000000000000000000000000000000;;		// Parent Command for this command
0000000000000000000000000000000000000000;;		parent *Command
0000000000000000000000000000000000000000;;		// max lengths of commands' string lengths for use in padding
0000000000000000000000000000000000000000;;		commandsMaxUseLen         int
0000000000000000000000000000000000000000;;		commandsMaxCommandPathLen int
0000000000000000000000000000000000000000;;		commandsMaxNameLen        int
0000000000000000000000000000000000000000;;		// is commands slice are sorted or not
0000000000000000000000000000000000000000;;		commandsAreSorted bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flagErrorBuf *bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		args          []string                 // actual args parsed from flags
0000000000000000000000000000000000000000;;		output        *io.Writer               // out writer if set in SetOutput(w)
0000000000000000000000000000000000000000;;		usageFunc     func(*Command) error     // Usage can be defined by application
0000000000000000000000000000000000000000;;		usageTemplate string                   // Can be defined by Application
0000000000000000000000000000000000000000;;		helpTemplate  string                   // Can be defined by Application
0000000000000000000000000000000000000000;;		helpFunc      func(*Command, []string) // Help can be defined by application
0000000000000000000000000000000000000000;;		helpCommand   *Command                 // The help command
0000000000000000000000000000000000000000;;		// The global normalization function that we can use on every pFlag set and children commands
0000000000000000000000000000000000000000;;		globNormFunc func(f *flag.FlagSet, name string) flag.NormalizedName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Disable the suggestions based on Levenshtein distance that go along with 'unknown command' messages
0000000000000000000000000000000000000000;;		DisableSuggestions bool
0000000000000000000000000000000000000000;;		// If displaying suggestions, allows to set the minimum levenshtein distance to display, must be > 0
0000000000000000000000000000000000000000;;		SuggestionsMinimumDistance int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Disable the flag parsing. If this is true all flags will be passed to the command as arguments.
0000000000000000000000000000000000000000;;		DisableFlagParsing bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// os.Args[1:] by default, if desired, can be overridden
0000000000000000000000000000000000000000;;	// particularly useful when testing.
0000000000000000000000000000000000000000;;	func (c *Command) SetArgs(a []string) {
0000000000000000000000000000000000000000;;		c.args = a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetOutput sets the destination for usage and error messages.
0000000000000000000000000000000000000000;;	// If output is nil, os.Stderr is used.
0000000000000000000000000000000000000000;;	func (c *Command) SetOutput(output io.Writer) {
0000000000000000000000000000000000000000;;		c.output = &output
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usage can be defined by application
0000000000000000000000000000000000000000;;	func (c *Command) SetUsageFunc(f func(*Command) error) {
0000000000000000000000000000000000000000;;		c.usageFunc = f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Can be defined by Application
0000000000000000000000000000000000000000;;	func (c *Command) SetUsageTemplate(s string) {
0000000000000000000000000000000000000000;;		c.usageTemplate = s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Can be defined by Application
0000000000000000000000000000000000000000;;	func (c *Command) SetHelpFunc(f func(*Command, []string)) {
0000000000000000000000000000000000000000;;		c.helpFunc = f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) SetHelpCommand(cmd *Command) {
0000000000000000000000000000000000000000;;		c.helpCommand = cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Can be defined by Application
0000000000000000000000000000000000000000;;	func (c *Command) SetHelpTemplate(s string) {
0000000000000000000000000000000000000000;;		c.helpTemplate = s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetGlobalNormalizationFunc sets a normalization function to all flag sets and also to child commands.
0000000000000000000000000000000000000000;;	// The user should not have a cyclic dependency on commands.
0000000000000000000000000000000000000000;;	func (c *Command) SetGlobalNormalizationFunc(n func(f *flag.FlagSet, name string) flag.NormalizedName) {
0000000000000000000000000000000000000000;;		c.Flags().SetNormalizeFunc(n)
0000000000000000000000000000000000000000;;		c.PersistentFlags().SetNormalizeFunc(n)
0000000000000000000000000000000000000000;;		c.globNormFunc = n
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, command := range c.commands {
0000000000000000000000000000000000000000;;			command.SetGlobalNormalizationFunc(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) OutOrStdout() io.Writer {
0000000000000000000000000000000000000000;;		return c.getOut(os.Stdout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) OutOrStderr() io.Writer {
0000000000000000000000000000000000000000;;		return c.getOut(os.Stderr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) getOut(def io.Writer) io.Writer {
0000000000000000000000000000000000000000;;		if c.output != nil {
0000000000000000000000000000000000000000;;			return *c.output
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.HasParent() {
0000000000000000000000000000000000000000;;			return c.parent.getOut(def)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return def
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UsageFunc returns either the function set by SetUsageFunc for this command
0000000000000000000000000000000000000000;;	// or a parent, or it returns a default usage function
0000000000000000000000000000000000000000;;	func (c *Command) UsageFunc() (f func(*Command) error) {
0000000000000000000000000000000000000000;;		if c.usageFunc != nil {
0000000000000000000000000000000000000000;;			return c.usageFunc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HasParent() {
0000000000000000000000000000000000000000;;			return c.parent.UsageFunc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(c *Command) error {
0000000000000000000000000000000000000000;;			c.mergePersistentFlags()
0000000000000000000000000000000000000000;;			err := tmpl(c.OutOrStderr(), c.UsageTemplate(), c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				c.Println(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Output the usage for the command
0000000000000000000000000000000000000000;;	// Used when a user provides invalid input
0000000000000000000000000000000000000000;;	// Can be defined by user by overriding UsageFunc
0000000000000000000000000000000000000000;;	func (c *Command) Usage() error {
0000000000000000000000000000000000000000;;		return c.UsageFunc()(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HelpFunc returns either the function set by SetHelpFunc for this command
0000000000000000000000000000000000000000;;	// or a parent, or it returns a function with default help behavior
0000000000000000000000000000000000000000;;	func (c *Command) HelpFunc() func(*Command, []string) {
0000000000000000000000000000000000000000;;		cmd := c
0000000000000000000000000000000000000000;;		for cmd != nil {
0000000000000000000000000000000000000000;;			if cmd.helpFunc != nil {
0000000000000000000000000000000000000000;;				return cmd.helpFunc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmd = cmd.parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(*Command, []string) {
0000000000000000000000000000000000000000;;			c.mergePersistentFlags()
0000000000000000000000000000000000000000;;			err := tmpl(c.OutOrStdout(), c.HelpTemplate(), c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				c.Println(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Output the help for the command
0000000000000000000000000000000000000000;;	// Used when a user calls help [command]
0000000000000000000000000000000000000000;;	// Can be defined by user by overriding HelpFunc
0000000000000000000000000000000000000000;;	func (c *Command) Help() error {
0000000000000000000000000000000000000000;;		c.HelpFunc()(c, []string{})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) UsageString() string {
0000000000000000000000000000000000000000;;		tmpOutput := c.output
0000000000000000000000000000000000000000;;		bb := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		c.SetOutput(bb)
0000000000000000000000000000000000000000;;		c.Usage()
0000000000000000000000000000000000000000;;		c.output = tmpOutput
0000000000000000000000000000000000000000;;		return bb.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var minUsagePadding = 25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) UsagePadding() int {
0000000000000000000000000000000000000000;;		if c.parent == nil || minUsagePadding > c.parent.commandsMaxUseLen {
0000000000000000000000000000000000000000;;			return minUsagePadding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.parent.commandsMaxUseLen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var minCommandPathPadding = 11
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (c *Command) CommandPathPadding() int {
0000000000000000000000000000000000000000;;		if c.parent == nil || minCommandPathPadding > c.parent.commandsMaxCommandPathLen {
0000000000000000000000000000000000000000;;			return minCommandPathPadding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.parent.commandsMaxCommandPathLen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var minNamePadding = 11
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) NamePadding() int {
0000000000000000000000000000000000000000;;		if c.parent == nil || minNamePadding > c.parent.commandsMaxNameLen {
0000000000000000000000000000000000000000;;			return minNamePadding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.parent.commandsMaxNameLen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) UsageTemplate() string {
0000000000000000000000000000000000000000;;		if c.usageTemplate != "" {
0000000000000000000000000000000000000000;;			return c.usageTemplate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HasParent() {
0000000000000000000000000000000000000000;;			return c.parent.UsageTemplate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return `Usage:{{if .Runnable}}
0000000000000000000000000000000000000000;;	  {{if .HasAvailableFlags}}{{appendIfNotPresent .UseLine "[flags]"}}{{else}}{{.UseLine}}{{end}}{{end}}{{if .HasAvailableSubCommands}}
0000000000000000000000000000000000000000;;	  {{ .CommandPath}} [command]{{end}}{{if gt .Aliases 0}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Aliases:
0000000000000000000000000000000000000000;;	  {{.NameAndAliases}}
0000000000000000000000000000000000000000;;	{{end}}{{if .HasExample}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Examples:
0000000000000000000000000000000000000000;;	{{ .Example }}{{end}}{{ if .HasAvailableSubCommands}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Available Commands:{{range .Commands}}{{if .IsAvailableCommand}}
0000000000000000000000000000000000000000;;	  {{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{ if .HasAvailableLocalFlags}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Flags:
0000000000000000000000000000000000000000;;	{{.LocalFlags.FlagUsages | trimRightSpace}}{{end}}{{ if .HasAvailableInheritedFlags}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Global Flags:
0000000000000000000000000000000000000000;;	{{.InheritedFlags.FlagUsages | trimRightSpace}}{{end}}{{if .HasHelpSubCommands}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Additional help topics:{{range .Commands}}{{if .IsHelpCommand}}
0000000000000000000000000000000000000000;;	  {{rpad .CommandPath .CommandPathPadding}} {{.Short}}{{end}}{{end}}{{end}}{{ if .HasAvailableSubCommands }}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Use "{{.CommandPath}} [command] --help" for more information about a command.{{end}}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) HelpTemplate() string {
0000000000000000000000000000000000000000;;		if c.helpTemplate != "" {
0000000000000000000000000000000000000000;;			return c.helpTemplate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HasParent() {
0000000000000000000000000000000000000000;;			return c.parent.HelpTemplate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return `{{with or .Long .Short }}{{. | trim}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{end}}{{if or .Runnable .HasSubCommands}}{{.UsageString}}{{end}}`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Really only used when casting a command to a commander
0000000000000000000000000000000000000000;;	func (c *Command) resetChildrensParents() {
0000000000000000000000000000000000000000;;		for _, x := range c.commands {
0000000000000000000000000000000000000000;;			x.parent = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if the named flag is a boolean flag.
0000000000000000000000000000000000000000;;	func isBooleanFlag(name string, f *flag.FlagSet) bool {
0000000000000000000000000000000000000000;;		flag := f.Lookup(name)
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return flag.Value.Type() == "bool"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if the named flag is a boolean flag.
0000000000000000000000000000000000000000;;	func isBooleanShortFlag(name string, f *flag.FlagSet) bool {
0000000000000000000000000000000000000000;;		result := false
0000000000000000000000000000000000000000;;		f.VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;			if f.Shorthand == name && f.Value.Type() == "bool" {
0000000000000000000000000000000000000000;;				result = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stripFlags(args []string, c *Command) []string {
0000000000000000000000000000000000000000;;		if len(args) < 1 {
0000000000000000000000000000000000000000;;			return args
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mergePersistentFlags()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commands := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inQuote := false
0000000000000000000000000000000000000000;;		inFlag := false
0000000000000000000000000000000000000000;;		for _, y := range args {
0000000000000000000000000000000000000000;;			if !inQuote {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case strings.HasPrefix(y, "\""):
0000000000000000000000000000000000000000;;					inQuote = true
0000000000000000000000000000000000000000;;				case strings.Contains(y, "=\""):
0000000000000000000000000000000000000000;;					inQuote = true
0000000000000000000000000000000000000000;;				case strings.HasPrefix(y, "--") && !strings.Contains(y, "="):
0000000000000000000000000000000000000000;;					// TODO: this isn't quite right, we should really check ahead for 'true' or 'false'
0000000000000000000000000000000000000000;;					inFlag = !isBooleanFlag(y[2:], c.Flags())
0000000000000000000000000000000000000000;;				case strings.HasPrefix(y, "-") && !strings.Contains(y, "=") && len(y) == 2 && !isBooleanShortFlag(y[1:], c.Flags()):
0000000000000000000000000000000000000000;;					inFlag = true
0000000000000000000000000000000000000000;;				case inFlag:
0000000000000000000000000000000000000000;;					inFlag = false
0000000000000000000000000000000000000000;;				case y == "":
0000000000000000000000000000000000000000;;					// strip empty commands, as the go tests expect this to be ok....
0000000000000000000000000000000000000000;;				case !strings.HasPrefix(y, "-"):
0000000000000000000000000000000000000000;;					commands = append(commands, y)
0000000000000000000000000000000000000000;;					inFlag = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.HasSuffix(y, "\"") && !strings.HasSuffix(y, "\\\"") {
0000000000000000000000000000000000000000;;				inQuote = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return commands
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// argsMinusFirstX removes only the first x from args.  Otherwise, commands that look like
0000000000000000000000000000000000000000;;	// openshift admin policy add-role-to-user admin my-user, lose the admin argument (arg[4]).
0000000000000000000000000000000000000000;;	func argsMinusFirstX(args []string, x string) []string {
0000000000000000000000000000000000000000;;		for i, y := range args {
0000000000000000000000000000000000000000;;			if x == y {
0000000000000000000000000000000000000000;;				ret := []string{}
0000000000000000000000000000000000000000;;				ret = append(ret, args[:i]...)
0000000000000000000000000000000000000000;;				ret = append(ret, args[i+1:]...)
0000000000000000000000000000000000000000;;				return ret
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return args
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// find the target command given the args and command tree
0000000000000000000000000000000000000000;;	// Meant to be run on the highest node. Only searches down.
0000000000000000000000000000000000000000;;	func (c *Command) Find(args []string) (*Command, []string, error) {
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("Called find() on a nil Command")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var innerfind func(*Command, []string) (*Command, []string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		innerfind = func(c *Command, innerArgs []string) (*Command, []string) {
0000000000000000000000000000000000000000;;			argsWOflags := stripFlags(innerArgs, c)
0000000000000000000000000000000000000000;;			if len(argsWOflags) == 0 {
0000000000000000000000000000000000000000;;				return c, innerArgs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nextSubCmd := argsWOflags[0]
0000000000000000000000000000000000000000;;			matches := make([]*Command, 0)
0000000000000000000000000000000000000000;;			for _, cmd := range c.commands {
0000000000000000000000000000000000000000;;				if cmd.Name() == nextSubCmd || cmd.HasAlias(nextSubCmd) { // exact name or alias match
0000000000000000000000000000000000000000;;					return innerfind(cmd, argsMinusFirstX(innerArgs, nextSubCmd))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if EnablePrefixMatching {
0000000000000000000000000000000000000000;;					if strings.HasPrefix(cmd.Name(), nextSubCmd) { // prefix match
0000000000000000000000000000000000000000;;						matches = append(matches, cmd)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, x := range cmd.Aliases {
0000000000000000000000000000000000000000;;						if strings.HasPrefix(x, nextSubCmd) {
0000000000000000000000000000000000000000;;							matches = append(matches, cmd)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// only accept a single prefix match - multiple matches would be ambiguous
0000000000000000000000000000000000000000;;			if len(matches) == 1 {
0000000000000000000000000000000000000000;;				return innerfind(matches[0], argsMinusFirstX(innerArgs, argsWOflags[0]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return c, innerArgs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commandFound, a := innerfind(c, args)
0000000000000000000000000000000000000000;;		argsWOflags := stripFlags(a, commandFound)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no subcommand, always take args
0000000000000000000000000000000000000000;;		if !commandFound.HasSubCommands() {
0000000000000000000000000000000000000000;;			return commandFound, a, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// root command with subcommands, do subcommand checking
0000000000000000000000000000000000000000;;		if commandFound == c && len(argsWOflags) > 0 {
0000000000000000000000000000000000000000;;			suggestionsString := ""
0000000000000000000000000000000000000000;;			if !c.DisableSuggestions {
0000000000000000000000000000000000000000;;				if c.SuggestionsMinimumDistance <= 0 {
0000000000000000000000000000000000000000;;					c.SuggestionsMinimumDistance = 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if suggestions := c.SuggestionsFor(argsWOflags[0]); len(suggestions) > 0 {
0000000000000000000000000000000000000000;;					suggestionsString += "\n\nDid you mean this?\n"
0000000000000000000000000000000000000000;;					for _, s := range suggestions {
0000000000000000000000000000000000000000;;						suggestionsString += fmt.Sprintf("\t%v\n", s)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return commandFound, a, fmt.Errorf("unknown command %q for %q%s", argsWOflags[0], commandFound.CommandPath(), suggestionsString)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return commandFound, a, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) SuggestionsFor(typedName string) []string {
0000000000000000000000000000000000000000;;		suggestions := []string{}
0000000000000000000000000000000000000000;;		for _, cmd := range c.commands {
0000000000000000000000000000000000000000;;			if cmd.IsAvailableCommand() {
0000000000000000000000000000000000000000;;				levenshteinDistance := ld(typedName, cmd.Name(), true)
0000000000000000000000000000000000000000;;				suggestByLevenshtein := levenshteinDistance <= c.SuggestionsMinimumDistance
0000000000000000000000000000000000000000;;				suggestByPrefix := strings.HasPrefix(strings.ToLower(cmd.Name()), strings.ToLower(typedName))
0000000000000000000000000000000000000000;;				if suggestByLevenshtein || suggestByPrefix {
0000000000000000000000000000000000000000;;					suggestions = append(suggestions, cmd.Name())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, explicitSuggestion := range cmd.SuggestFor {
0000000000000000000000000000000000000000;;					if strings.EqualFold(typedName, explicitSuggestion) {
0000000000000000000000000000000000000000;;						suggestions = append(suggestions, cmd.Name())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return suggestions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) VisitParents(fn func(*Command)) {
0000000000000000000000000000000000000000;;		var traverse func(*Command) *Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		traverse = func(x *Command) *Command {
0000000000000000000000000000000000000000;;			if x != c {
0000000000000000000000000000000000000000;;				fn(x)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.HasParent() {
0000000000000000000000000000000000000000;;				return traverse(x.parent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		traverse(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) Root() *Command {
0000000000000000000000000000000000000000;;		var findRoot func(*Command) *Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		findRoot = func(x *Command) *Command {
0000000000000000000000000000000000000000;;			if x.HasParent() {
0000000000000000000000000000000000000000;;				return findRoot(x.parent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return findRoot(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ArgsLenAtDash will return the length of f.Args at the moment when a -- was
0000000000000000000000000000000000000000;;	// found during arg parsing. This allows your program to know which args were
0000000000000000000000000000000000000000;;	// before the -- and which came after. (Description from
0000000000000000000000000000000000000000;;	// https://godoc.org/github.com/spf13/pflag#FlagSet.ArgsLenAtDash).
0000000000000000000000000000000000000000;;	func (c *Command) ArgsLenAtDash() int {
0000000000000000000000000000000000000000;;		return c.Flags().ArgsLenAtDash()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) execute(a []string) (err error) {
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Called Execute() on a nil Command")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.Deprecated) > 0 {
0000000000000000000000000000000000000000;;			c.Printf("Command %q is deprecated, %s\n", c.Name(), c.Deprecated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialize help flag as the last point possible to allow for user
0000000000000000000000000000000000000000;;		// overriding
0000000000000000000000000000000000000000;;		c.initHelpFlag()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.ParseFlags(a)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If help is called, regardless of other flags, return we want help
0000000000000000000000000000000000000000;;		// Also say we need help if the command isn't runnable.
0000000000000000000000000000000000000000;;		helpVal, err := c.Flags().GetBool("help")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// should be impossible to get here as we always declare a help
0000000000000000000000000000000000000000;;			// flag in initHelpFlag()
0000000000000000000000000000000000000000;;			c.Println("\"help\" flag declared as non-bool. Please correct your code")
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if helpVal || !c.Runnable() {
0000000000000000000000000000000000000000;;			return flag.ErrHelp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.preRun()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		argWoFlags := c.Flags().Args()
0000000000000000000000000000000000000000;;		if c.DisableFlagParsing {
0000000000000000000000000000000000000000;;			argWoFlags = a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for p := c; p != nil; p = p.Parent() {
0000000000000000000000000000000000000000;;			if p.PersistentPreRunE != nil {
0000000000000000000000000000000000000000;;				if err := p.PersistentPreRunE(c, argWoFlags); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if p.PersistentPreRun != nil {
0000000000000000000000000000000000000000;;				p.PersistentPreRun(c, argWoFlags)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.PreRunE != nil {
0000000000000000000000000000000000000000;;			if err := c.PreRunE(c, argWoFlags); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c.PreRun != nil {
0000000000000000000000000000000000000000;;			c.PreRun(c, argWoFlags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.RunE != nil {
0000000000000000000000000000000000000000;;			if err := c.RunE(c, argWoFlags); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.Run(c, argWoFlags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.PostRunE != nil {
0000000000000000000000000000000000000000;;			if err := c.PostRunE(c, argWoFlags); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c.PostRun != nil {
0000000000000000000000000000000000000000;;			c.PostRun(c, argWoFlags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for p := c; p != nil; p = p.Parent() {
0000000000000000000000000000000000000000;;			if p.PersistentPostRunE != nil {
0000000000000000000000000000000000000000;;				if err := p.PersistentPostRunE(c, argWoFlags); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if p.PersistentPostRun != nil {
0000000000000000000000000000000000000000;;				p.PersistentPostRun(c, argWoFlags)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) preRun() {
0000000000000000000000000000000000000000;;		for _, x := range initializers {
0000000000000000000000000000000000000000;;			x()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) errorMsgFromParse() string {
0000000000000000000000000000000000000000;;		s := c.flagErrorBuf.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := strings.Split(s, "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(x) > 0 {
0000000000000000000000000000000000000000;;			return x[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call execute to use the args (os.Args[1:] by default)
0000000000000000000000000000000000000000;;	// and run through the command tree finding appropriate matches
0000000000000000000000000000000000000000;;	// for commands and then corresponding flags.
0000000000000000000000000000000000000000;;	func (c *Command) Execute() error {
0000000000000000000000000000000000000000;;		_, err := c.ExecuteC()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) ExecuteC() (cmd *Command, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Regardless of what command execute is called on, run on Root only
0000000000000000000000000000000000000000;;		if c.HasParent() {
0000000000000000000000000000000000000000;;			return c.Root().ExecuteC()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// windows hook
0000000000000000000000000000000000000000;;		if preExecHookFn != nil {
0000000000000000000000000000000000000000;;			preExecHookFn(c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialize help as the last point possible to allow for user
0000000000000000000000000000000000000000;;		// overriding
0000000000000000000000000000000000000000;;		c.initHelpCmd()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var args []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Workaround FAIL with "go test -v" or "cobra.test -test.v", see #155
0000000000000000000000000000000000000000;;		if c.args == nil && filepath.Base(os.Args[0]) != "cobra.test" {
0000000000000000000000000000000000000000;;			args = os.Args[1:]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			args = c.args
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd, flags, err := c.Find(args)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If found parse to a subcommand and then failed, talk about the subcommand
0000000000000000000000000000000000000000;;			if cmd != nil {
0000000000000000000000000000000000000000;;				c = cmd
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !c.SilenceErrors {
0000000000000000000000000000000000000000;;				c.Println("Error:", err.Error())
0000000000000000000000000000000000000000;;				c.Printf("Run '%v --help' for usage.\n", c.CommandPath())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = cmd.execute(flags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Always show help if requested, even if SilenceErrors is in
0000000000000000000000000000000000000000;;			// effect
0000000000000000000000000000000000000000;;			if err == flag.ErrHelp {
0000000000000000000000000000000000000000;;				cmd.HelpFunc()(cmd, args)
0000000000000000000000000000000000000000;;				return cmd, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If root command has SilentErrors flagged,
0000000000000000000000000000000000000000;;			// all subcommands should respect it
0000000000000000000000000000000000000000;;			if !cmd.SilenceErrors && !c.SilenceErrors {
0000000000000000000000000000000000000000;;				c.Println("Error:", err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If root command has SilentUsage flagged,
0000000000000000000000000000000000000000;;			// all subcommands should respect it
0000000000000000000000000000000000000000;;			if !cmd.SilenceUsage && !c.SilenceUsage {
0000000000000000000000000000000000000000;;				c.Println(cmd.UsageString())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cmd, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cmd, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) initHelpFlag() {
0000000000000000000000000000000000000000;;		if c.Flags().Lookup("help") == nil {
0000000000000000000000000000000000000000;;			c.Flags().BoolP("help", "h", false, "help for "+c.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) initHelpCmd() {
0000000000000000000000000000000000000000;;		if c.helpCommand == nil {
0000000000000000000000000000000000000000;;			if !c.HasSubCommands() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.helpCommand = &Command{
0000000000000000000000000000000000000000;;				Use:   "help [command]",
0000000000000000000000000000000000000000;;				Short: "Help about any command",
0000000000000000000000000000000000000000;;				Long: `Help provides help for any command in the application.
0000000000000000000000000000000000000000;;	    Simply type ` + c.Name() + ` help [path to command] for full details.`,
0000000000000000000000000000000000000000;;				PersistentPreRun:  func(cmd *Command, args []string) {},
0000000000000000000000000000000000000000;;				PersistentPostRun: func(cmd *Command, args []string) {},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Run: func(c *Command, args []string) {
0000000000000000000000000000000000000000;;					cmd, _, e := c.Root().Find(args)
0000000000000000000000000000000000000000;;					if cmd == nil || e != nil {
0000000000000000000000000000000000000000;;						c.Printf("Unknown help topic %#q.", args)
0000000000000000000000000000000000000000;;						c.Root().Usage()
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						cmd.Help()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.AddCommand(c.helpCommand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used for testing
0000000000000000000000000000000000000000;;	func (c *Command) ResetCommands() {
0000000000000000000000000000000000000000;;		c.commands = nil
0000000000000000000000000000000000000000;;		c.helpCommand = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sorts commands by their names
0000000000000000000000000000000000000000;;	type commandSorterByName []*Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c commandSorterByName) Len() int           { return len(c) }
0000000000000000000000000000000000000000;;	func (c commandSorterByName) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }
0000000000000000000000000000000000000000;;	func (c commandSorterByName) Less(i, j int) bool { return c[i].Name() < c[j].Name() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Commands returns a sorted slice of child commands.
0000000000000000000000000000000000000000;;	func (c *Command) Commands() []*Command {
0000000000000000000000000000000000000000;;		// do not sort commands if it already sorted or sorting was disabled
0000000000000000000000000000000000000000;;		if EnableCommandSorting && !c.commandsAreSorted {
0000000000000000000000000000000000000000;;			sort.Sort(commandSorterByName(c.commands))
0000000000000000000000000000000000000000;;			c.commandsAreSorted = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.commands
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddCommand adds one or more commands to this parent command.
0000000000000000000000000000000000000000;;	func (c *Command) AddCommand(cmds ...*Command) {
0000000000000000000000000000000000000000;;		for i, x := range cmds {
0000000000000000000000000000000000000000;;			if cmds[i] == c {
0000000000000000000000000000000000000000;;				panic("Command can't be a child of itself")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cmds[i].parent = c
0000000000000000000000000000000000000000;;			// update max lengths
0000000000000000000000000000000000000000;;			usageLen := len(x.Use)
0000000000000000000000000000000000000000;;			if usageLen > c.commandsMaxUseLen {
0000000000000000000000000000000000000000;;				c.commandsMaxUseLen = usageLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			commandPathLen := len(x.CommandPath())
0000000000000000000000000000000000000000;;			if commandPathLen > c.commandsMaxCommandPathLen {
0000000000000000000000000000000000000000;;				c.commandsMaxCommandPathLen = commandPathLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nameLen := len(x.Name())
0000000000000000000000000000000000000000;;			if nameLen > c.commandsMaxNameLen {
0000000000000000000000000000000000000000;;				c.commandsMaxNameLen = nameLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If global normalization function exists, update all children
0000000000000000000000000000000000000000;;			if c.globNormFunc != nil {
0000000000000000000000000000000000000000;;				x.SetGlobalNormalizationFunc(c.globNormFunc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.commands = append(c.commands, x)
0000000000000000000000000000000000000000;;			c.commandsAreSorted = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveCommand removes one or more commands from a parent command.
0000000000000000000000000000000000000000;;	func (c *Command) RemoveCommand(cmds ...*Command) {
0000000000000000000000000000000000000000;;		commands := []*Command{}
0000000000000000000000000000000000000000;;	main:
0000000000000000000000000000000000000000;;		for _, command := range c.commands {
0000000000000000000000000000000000000000;;			for _, cmd := range cmds {
0000000000000000000000000000000000000000;;				if command == cmd {
0000000000000000000000000000000000000000;;					command.parent = nil
0000000000000000000000000000000000000000;;					continue main
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			commands = append(commands, command)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.commands = commands
0000000000000000000000000000000000000000;;		// recompute all lengths
0000000000000000000000000000000000000000;;		c.commandsMaxUseLen = 0
0000000000000000000000000000000000000000;;		c.commandsMaxCommandPathLen = 0
0000000000000000000000000000000000000000;;		c.commandsMaxNameLen = 0
0000000000000000000000000000000000000000;;		for _, command := range c.commands {
0000000000000000000000000000000000000000;;			usageLen := len(command.Use)
0000000000000000000000000000000000000000;;			if usageLen > c.commandsMaxUseLen {
0000000000000000000000000000000000000000;;				c.commandsMaxUseLen = usageLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			commandPathLen := len(command.CommandPath())
0000000000000000000000000000000000000000;;			if commandPathLen > c.commandsMaxCommandPathLen {
0000000000000000000000000000000000000000;;				c.commandsMaxCommandPathLen = commandPathLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nameLen := len(command.Name())
0000000000000000000000000000000000000000;;			if nameLen > c.commandsMaxNameLen {
0000000000000000000000000000000000000000;;				c.commandsMaxNameLen = nameLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Print is a convenience method to Print to the defined output, fallback to Stderr if not set
0000000000000000000000000000000000000000;;	func (c *Command) Print(i ...interface{}) {
0000000000000000000000000000000000000000;;		fmt.Fprint(c.OutOrStderr(), i...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Println is a convenience method to Println to the defined output, fallback to Stderr if not set
0000000000000000000000000000000000000000;;	func (c *Command) Println(i ...interface{}) {
0000000000000000000000000000000000000000;;		str := fmt.Sprintln(i...)
0000000000000000000000000000000000000000;;		c.Print(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Printf is a convenience method to Printf to the defined output, fallback to Stderr if not set
0000000000000000000000000000000000000000;;	func (c *Command) Printf(format string, i ...interface{}) {
0000000000000000000000000000000000000000;;		str := fmt.Sprintf(format, i...)
0000000000000000000000000000000000000000;;		c.Print(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CommandPath returns the full path to this command.
0000000000000000000000000000000000000000;;	func (c *Command) CommandPath() string {
0000000000000000000000000000000000000000;;		str := c.Name()
0000000000000000000000000000000000000000;;		x := c
0000000000000000000000000000000000000000;;		for x.HasParent() {
0000000000000000000000000000000000000000;;			str = x.parent.Name() + " " + str
0000000000000000000000000000000000000000;;			x = x.parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//The full usage for a given command (including parents)
0000000000000000000000000000000000000000;;	func (c *Command) UseLine() string {
0000000000000000000000000000000000000000;;		str := ""
0000000000000000000000000000000000000000;;		if c.HasParent() {
0000000000000000000000000000000000000000;;			str = c.parent.CommandPath() + " "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str + c.Use
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For use in determining which flags have been assigned to which commands
0000000000000000000000000000000000000000;;	// and which persist
0000000000000000000000000000000000000000;;	func (c *Command) DebugFlags() {
0000000000000000000000000000000000000000;;		c.Println("DebugFlags called on", c.Name())
0000000000000000000000000000000000000000;;		var debugflags func(*Command)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debugflags = func(x *Command) {
0000000000000000000000000000000000000000;;			if x.HasFlags() || x.HasPersistentFlags() {
0000000000000000000000000000000000000000;;				c.Println(x.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.HasFlags() {
0000000000000000000000000000000000000000;;				x.flags.VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;					if x.HasPersistentFlags() {
0000000000000000000000000000000000000000;;						if x.persistentFlag(f.Name) == nil {
0000000000000000000000000000000000000000;;							c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [L]")
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [LP]")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [L]")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.HasPersistentFlags() {
0000000000000000000000000000000000000000;;				x.pflags.VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;					if x.HasFlags() {
0000000000000000000000000000000000000000;;						if x.flags.Lookup(f.Name) == nil {
0000000000000000000000000000000000000000;;							c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [P]")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						c.Println("  -"+f.Shorthand+",", "--"+f.Name, "["+f.DefValue+"]", "", f.Value, "  [P]")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.Println(x.flagErrorBuf)
0000000000000000000000000000000000000000;;			if x.HasSubCommands() {
0000000000000000000000000000000000000000;;				for _, y := range x.commands {
0000000000000000000000000000000000000000;;					debugflags(y)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debugflags(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the command's name: the first word in the use line.
0000000000000000000000000000000000000000;;	func (c *Command) Name() string {
0000000000000000000000000000000000000000;;		if c.name != "" {
0000000000000000000000000000000000000000;;			return c.name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := c.Use
0000000000000000000000000000000000000000;;		i := strings.Index(name, " ")
0000000000000000000000000000000000000000;;		if i >= 0 {
0000000000000000000000000000000000000000;;			name = name[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAlias determines if a given string is an alias of the command.
0000000000000000000000000000000000000000;;	func (c *Command) HasAlias(s string) bool {
0000000000000000000000000000000000000000;;		for _, a := range c.Aliases {
0000000000000000000000000000000000000000;;			if a == s {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) NameAndAliases() string {
0000000000000000000000000000000000000000;;		return strings.Join(append([]string{c.Name()}, c.Aliases...), ", ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) HasExample() bool {
0000000000000000000000000000000000000000;;		return len(c.Example) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Runnable determines if the command is itself runnable
0000000000000000000000000000000000000000;;	func (c *Command) Runnable() bool {
0000000000000000000000000000000000000000;;		return c.Run != nil || c.RunE != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasSubCommands determines if the command has children commands
0000000000000000000000000000000000000000;;	func (c *Command) HasSubCommands() bool {
0000000000000000000000000000000000000000;;		return len(c.commands) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAvailableCommand determines if a command is available as a non-help command
0000000000000000000000000000000000000000;;	// (this includes all non deprecated/hidden commands)
0000000000000000000000000000000000000000;;	func (c *Command) IsAvailableCommand() bool {
0000000000000000000000000000000000000000;;		if len(c.Deprecated) != 0 || c.Hidden {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HasParent() && c.Parent().helpCommand == c {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Runnable() || c.HasAvailableSubCommands() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHelpCommand determines if a command is a 'help' command; a help command is
0000000000000000000000000000000000000000;;	// determined by the fact that it is NOT runnable/hidden/deprecated, and has no
0000000000000000000000000000000000000000;;	// sub commands that are runnable/hidden/deprecated
0000000000000000000000000000000000000000;;	func (c *Command) IsHelpCommand() bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if a command is runnable, deprecated, or hidden it is not a 'help' command
0000000000000000000000000000000000000000;;		if c.Runnable() || len(c.Deprecated) != 0 || c.Hidden {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if any non-help sub commands are found, the command is not a 'help' command
0000000000000000000000000000000000000000;;		for _, sub := range c.commands {
0000000000000000000000000000000000000000;;			if !sub.IsHelpCommand() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the command either has no sub commands, or no non-help sub commands
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasHelpSubCommands determines if a command has any avilable 'help' sub commands
0000000000000000000000000000000000000000;;	// that need to be shown in the usage/help default template under 'additional help
0000000000000000000000000000000000000000;;	// topics'
0000000000000000000000000000000000000000;;	func (c *Command) HasHelpSubCommands() bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return true on the first found available 'help' sub command
0000000000000000000000000000000000000000;;		for _, sub := range c.commands {
0000000000000000000000000000000000000000;;			if sub.IsHelpCommand() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the command either has no sub commands, or no available 'help' sub commands
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAvailableSubCommands determines if a command has available sub commands that
0000000000000000000000000000000000000000;;	// need to be shown in the usage/help default template under 'available commands'
0000000000000000000000000000000000000000;;	func (c *Command) HasAvailableSubCommands() bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return true on the first found available (non deprecated/help/hidden)
0000000000000000000000000000000000000000;;		// sub command
0000000000000000000000000000000000000000;;		for _, sub := range c.commands {
0000000000000000000000000000000000000000;;			if sub.IsAvailableCommand() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the command either has no sub comamnds, or no available (non deprecated/help/hidden)
0000000000000000000000000000000000000000;;		// sub commands
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determine if the command is a child command
0000000000000000000000000000000000000000;;	func (c *Command) HasParent() bool {
0000000000000000000000000000000000000000;;		return c.parent != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GlobalNormalizationFunc returns the global normalization function or nil if doesn't exists
0000000000000000000000000000000000000000;;	func (c *Command) GlobalNormalizationFunc() func(f *flag.FlagSet, name string) flag.NormalizedName {
0000000000000000000000000000000000000000;;		return c.globNormFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the complete FlagSet that applies to this command (local and persistent declared here and by all parents)
0000000000000000000000000000000000000000;;	func (c *Command) Flags() *flag.FlagSet {
0000000000000000000000000000000000000000;;		if c.flags == nil {
0000000000000000000000000000000000000000;;			c.flags = flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;			if c.flagErrorBuf == nil {
0000000000000000000000000000000000000000;;				c.flagErrorBuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.flags.SetOutput(c.flagErrorBuf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.flags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalNonPersistentFlags are flags specific to this command which will NOT persist to subcommands
0000000000000000000000000000000000000000;;	func (c *Command) LocalNonPersistentFlags() *flag.FlagSet {
0000000000000000000000000000000000000000;;		persistentFlags := c.PersistentFlags()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;		c.LocalFlags().VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;			if persistentFlags.Lookup(f.Name) == nil {
0000000000000000000000000000000000000000;;				out.AddFlag(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the local FlagSet specifically set in the current command
0000000000000000000000000000000000000000;;	func (c *Command) LocalFlags() *flag.FlagSet {
0000000000000000000000000000000000000000;;		c.mergePersistentFlags()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		local := flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;		c.lflags.VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;			local.AddFlag(f)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if !c.HasParent() {
0000000000000000000000000000000000000000;;			flag.CommandLine.VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;				if local.Lookup(f.Name) == nil {
0000000000000000000000000000000000000000;;					local.AddFlag(f)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return local
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All Flags which were inherited from parents commands
0000000000000000000000000000000000000000;;	func (c *Command) InheritedFlags() *flag.FlagSet {
0000000000000000000000000000000000000000;;		c.mergePersistentFlags()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inherited := flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;		local := c.LocalFlags()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rmerge func(x *Command)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rmerge = func(x *Command) {
0000000000000000000000000000000000000000;;			if x.HasPersistentFlags() {
0000000000000000000000000000000000000000;;				x.PersistentFlags().VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;					if inherited.Lookup(f.Name) == nil && local.Lookup(f.Name) == nil {
0000000000000000000000000000000000000000;;						inherited.AddFlag(f)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.HasParent() {
0000000000000000000000000000000000000000;;				rmerge(x.parent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HasParent() {
0000000000000000000000000000000000000000;;			rmerge(c.parent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return inherited
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All Flags which were not inherited from parent commands
0000000000000000000000000000000000000000;;	func (c *Command) NonInheritedFlags() *flag.FlagSet {
0000000000000000000000000000000000000000;;		return c.LocalFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the Persistent FlagSet specifically set in the current command
0000000000000000000000000000000000000000;;	func (c *Command) PersistentFlags() *flag.FlagSet {
0000000000000000000000000000000000000000;;		if c.pflags == nil {
0000000000000000000000000000000000000000;;			c.pflags = flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;			if c.flagErrorBuf == nil {
0000000000000000000000000000000000000000;;				c.flagErrorBuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.pflags.SetOutput(c.flagErrorBuf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.pflags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For use in testing
0000000000000000000000000000000000000000;;	func (c *Command) ResetFlags() {
0000000000000000000000000000000000000000;;		c.flagErrorBuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		c.flagErrorBuf.Reset()
0000000000000000000000000000000000000000;;		c.flags = flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;		c.flags.SetOutput(c.flagErrorBuf)
0000000000000000000000000000000000000000;;		c.pflags = flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;		c.pflags.SetOutput(c.flagErrorBuf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command contain any flags (local plus persistent from the entire structure)
0000000000000000000000000000000000000000;;	func (c *Command) HasFlags() bool {
0000000000000000000000000000000000000000;;		return c.Flags().HasFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command contain persistent flags
0000000000000000000000000000000000000000;;	func (c *Command) HasPersistentFlags() bool {
0000000000000000000000000000000000000000;;		return c.PersistentFlags().HasFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command has flags specifically declared locally
0000000000000000000000000000000000000000;;	func (c *Command) HasLocalFlags() bool {
0000000000000000000000000000000000000000;;		return c.LocalFlags().HasFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command have flags inherited from its parent command
0000000000000000000000000000000000000000;;	func (c *Command) HasInheritedFlags() bool {
0000000000000000000000000000000000000000;;		return c.InheritedFlags().HasFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command contain any flags (local plus persistent from the entire
0000000000000000000000000000000000000000;;	// structure) which are not hidden or deprecated
0000000000000000000000000000000000000000;;	func (c *Command) HasAvailableFlags() bool {
0000000000000000000000000000000000000000;;		return c.Flags().HasAvailableFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command contain persistent flags which are not hidden or deprecated
0000000000000000000000000000000000000000;;	func (c *Command) HasAvailablePersistentFlags() bool {
0000000000000000000000000000000000000000;;		return c.PersistentFlags().HasAvailableFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command has flags specifically declared locally which are not hidden
0000000000000000000000000000000000000000;;	// or deprecated
0000000000000000000000000000000000000000;;	func (c *Command) HasAvailableLocalFlags() bool {
0000000000000000000000000000000000000000;;		return c.LocalFlags().HasAvailableFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Does the command have flags inherited from its parent command which are
0000000000000000000000000000000000000000;;	// not hidden or deprecated
0000000000000000000000000000000000000000;;	func (c *Command) HasAvailableInheritedFlags() bool {
0000000000000000000000000000000000000000;;		return c.InheritedFlags().HasAvailableFlags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flag climbs up the command tree looking for matching flag
0000000000000000000000000000000000000000;;	func (c *Command) Flag(name string) (flag *flag.Flag) {
0000000000000000000000000000000000000000;;		flag = c.Flags().Lookup(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			flag = c.persistentFlag(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recursively find matching persistent flag
0000000000000000000000000000000000000000;;	func (c *Command) persistentFlag(name string) (flag *flag.Flag) {
0000000000000000000000000000000000000000;;		if c.HasPersistentFlags() {
0000000000000000000000000000000000000000;;			flag = c.PersistentFlags().Lookup(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flag == nil && c.HasParent() {
0000000000000000000000000000000000000000;;			flag = c.parent.persistentFlag(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseFlags parses persistent flag tree & local flags
0000000000000000000000000000000000000000;;	func (c *Command) ParseFlags(args []string) (err error) {
0000000000000000000000000000000000000000;;		if c.DisableFlagParsing {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mergePersistentFlags()
0000000000000000000000000000000000000000;;		err = c.Flags().Parse(args)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parent returns a commands parent command
0000000000000000000000000000000000000000;;	func (c *Command) Parent() *Command {
0000000000000000000000000000000000000000;;		return c.parent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Command) mergePersistentFlags() {
0000000000000000000000000000000000000000;;		var rmerge func(x *Command)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the set of local flags
0000000000000000000000000000000000000000;;		if c.lflags == nil {
0000000000000000000000000000000000000000;;			c.lflags = flag.NewFlagSet(c.Name(), flag.ContinueOnError)
0000000000000000000000000000000000000000;;			if c.flagErrorBuf == nil {
0000000000000000000000000000000000000000;;				c.flagErrorBuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.lflags.SetOutput(c.flagErrorBuf)
0000000000000000000000000000000000000000;;			addtolocal := func(f *flag.Flag) {
0000000000000000000000000000000000000000;;				c.lflags.AddFlag(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.Flags().VisitAll(addtolocal)
0000000000000000000000000000000000000000;;			c.PersistentFlags().VisitAll(addtolocal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rmerge = func(x *Command) {
0000000000000000000000000000000000000000;;			if !x.HasParent() {
0000000000000000000000000000000000000000;;				flag.CommandLine.VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;					if x.PersistentFlags().Lookup(f.Name) == nil {
0000000000000000000000000000000000000000;;						x.PersistentFlags().AddFlag(f)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.HasPersistentFlags() {
0000000000000000000000000000000000000000;;				x.PersistentFlags().VisitAll(func(f *flag.Flag) {
0000000000000000000000000000000000000000;;					if c.Flags().Lookup(f.Name) == nil {
0000000000000000000000000000000000000000;;						c.Flags().AddFlag(f)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.HasParent() {
0000000000000000000000000000000000000000;;				rmerge(x.parent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rmerge(c)
0000000000000000000000000000000000000000;;	}
