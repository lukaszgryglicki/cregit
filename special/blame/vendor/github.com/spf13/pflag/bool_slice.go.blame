0000000000000000000000000000000000000000;;	package pflag
937aedc1ba701ed4ffc2a1bf689b91ab13bf9c0e;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -- boolSlice Value
0000000000000000000000000000000000000000;;	type boolSliceValue struct {
0000000000000000000000000000000000000000;;		value   *[]bool
0000000000000000000000000000000000000000;;		changed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBoolSliceValue(val []bool, p *[]bool) *boolSliceValue {
0000000000000000000000000000000000000000;;		bsv := new(boolSliceValue)
0000000000000000000000000000000000000000;;		bsv.value = p
0000000000000000000000000000000000000000;;		*bsv.value = val
0000000000000000000000000000000000000000;;		return bsv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set converts, and assigns, the comma-separated boolean argument string representation as the []bool value of this flag.
0000000000000000000000000000000000000000;;	// If Set is called on a flag that already has a []bool assigned, the newly converted values will be appended.
0000000000000000000000000000000000000000;;	func (s *boolSliceValue) Set(val string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove all quote characters
0000000000000000000000000000000000000000;;		rmQuote := strings.NewReplacer(`"`, "", `'`, "", "`", "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// read flag arguments with CSV parser
0000000000000000000000000000000000000000;;		boolStrSlice, err := readAsCSV(rmQuote.Replace(val))
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse boolean values into slice
0000000000000000000000000000000000000000;;		out := make([]bool, 0, len(boolStrSlice))
0000000000000000000000000000000000000000;;		for _, boolStr := range boolStrSlice {
0000000000000000000000000000000000000000;;			b, err := strconv.ParseBool(strings.TrimSpace(boolStr))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.changed {
0000000000000000000000000000000000000000;;			*s.value = out
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			*s.value = append(*s.value, out...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.changed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns a string that uniquely represents this flag's type.
0000000000000000000000000000000000000000;;	func (s *boolSliceValue) Type() string {
0000000000000000000000000000000000000000;;		return "boolSlice"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String defines a "native" format for this boolean slice flag value.
0000000000000000000000000000000000000000;;	func (s *boolSliceValue) String() string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boolStrSlice := make([]string, len(*s.value))
0000000000000000000000000000000000000000;;		for i, b := range *s.value {
0000000000000000000000000000000000000000;;			boolStrSlice[i] = strconv.FormatBool(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, _ := writeAsCSV(boolStrSlice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "[" + out + "]"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func boolSliceConv(val string) (interface{}, error) {
0000000000000000000000000000000000000000;;		val = strings.Trim(val, "[]")
0000000000000000000000000000000000000000;;		// Empty string would cause a slice with one (empty) entry
0000000000000000000000000000000000000000;;		if len(val) == 0 {
0000000000000000000000000000000000000000;;			return []bool{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := strings.Split(val, ",")
0000000000000000000000000000000000000000;;		out := make([]bool, len(ss))
0000000000000000000000000000000000000000;;		for i, t := range ss {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			out[i], err = strconv.ParseBool(t)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBoolSlice returns the []bool value of a flag with the given name.
0000000000000000000000000000000000000000;;	func (f *FlagSet) GetBoolSlice(name string) ([]bool, error) {
0000000000000000000000000000000000000000;;		val, err := f.getFlagType(name, "boolSlice", boolSliceConv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []bool{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val.([]bool), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSliceVar defines a boolSlice flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to a []bool variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) BoolSliceVar(p *[]bool, name string, value []bool, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newBoolSliceValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSliceVarP is like BoolSliceVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) BoolSliceVarP(p *[]bool, name, shorthand string, value []bool, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newBoolSliceValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSliceVar defines a []bool flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to a []bool variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func BoolSliceVar(p *[]bool, name string, value []bool, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newBoolSliceValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSliceVarP is like BoolSliceVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func BoolSliceVarP(p *[]bool, name, shorthand string, value []bool, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newBoolSliceValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSlice defines a []bool flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of a []bool variable that stores the value of the flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) BoolSlice(name string, value []bool, usage string) *[]bool {
0000000000000000000000000000000000000000;;		p := []bool{}
0000000000000000000000000000000000000000;;		f.BoolSliceVarP(&p, name, "", value, usage)
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSliceP is like BoolSlice, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) BoolSliceP(name, shorthand string, value []bool, usage string) *[]bool {
0000000000000000000000000000000000000000;;		p := []bool{}
0000000000000000000000000000000000000000;;		f.BoolSliceVarP(&p, name, shorthand, value, usage)
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSlice defines a []bool flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of a []bool variable that stores the value of the flag.
0000000000000000000000000000000000000000;;	func BoolSlice(name string, value []bool, usage string) *[]bool {
0000000000000000000000000000000000000000;;		return CommandLine.BoolSliceP(name, "", value, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSliceP is like BoolSlice, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func BoolSliceP(name, shorthand string, value []bool, usage string) *[]bool {
0000000000000000000000000000000000000000;;		return CommandLine.BoolSliceP(name, shorthand, value, usage)
0000000000000000000000000000000000000000;;	}
