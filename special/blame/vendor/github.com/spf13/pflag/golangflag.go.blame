0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
866e484982563b40365236e7a6a802cf7e6d4e8e;Godeps/_workspace/src/github.com/spf13/pflag/golangflag.go[Godeps/_workspace/src/github.com/spf13/pflag/golangflag.go][vendor/github.com/spf13/pflag/golangflag.go];	
0000000000000000000000000000000000000000;;	package pflag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		goflag "flag"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flagValueWrapper implements pflag.Value around a flag.Value.  The main
0000000000000000000000000000000000000000;;	// difference here is the addition of the Type method that returns a string
0000000000000000000000000000000000000000;;	// name of the type.  As this is generally unknown, we approximate that with
0000000000000000000000000000000000000000;;	// reflection.
0000000000000000000000000000000000000000;;	type flagValueWrapper struct {
0000000000000000000000000000000000000000;;		inner    goflag.Value
0000000000000000000000000000000000000000;;		flagType string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We are just copying the boolFlag interface out of goflag as that is what
0000000000000000000000000000000000000000;;	// they use to decide if a flag should get "true" when no arg is given.
0000000000000000000000000000000000000000;;	type goBoolFlag interface {
0000000000000000000000000000000000000000;;		goflag.Value
0000000000000000000000000000000000000000;;		IsBoolFlag() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrapFlagValue(v goflag.Value) Value {
0000000000000000000000000000000000000000;;		// If the flag.Value happens to also be a pflag.Value, just use it directly.
0000000000000000000000000000000000000000;;		if pv, ok := v.(Value); ok {
0000000000000000000000000000000000000000;;			return pv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := &flagValueWrapper{
0000000000000000000000000000000000000000;;			inner: v,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(v)
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Interface || t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv.flagType = strings.TrimSuffix(t.Name(), "Value")
0000000000000000000000000000000000000000;;		return pv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *flagValueWrapper) String() string {
0000000000000000000000000000000000000000;;		return v.inner.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *flagValueWrapper) Set(s string) error {
0000000000000000000000000000000000000000;;		return v.inner.Set(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *flagValueWrapper) Type() string {
0000000000000000000000000000000000000000;;		return v.flagType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PFlagFromGoFlag will return a *pflag.Flag given a *flag.Flag
0000000000000000000000000000000000000000;;	// If the *flag.Flag.Name was a single character (ex: `v`) it will be accessiblei
0000000000000000000000000000000000000000;;	// with both `-v` and `--v` in flags. If the golang flag was more than a single
0000000000000000000000000000000000000000;;	// character (ex: `verbose`) it will only be accessible via `--verbose`
0000000000000000000000000000000000000000;;	func PFlagFromGoFlag(goflag *goflag.Flag) *Flag {
0000000000000000000000000000000000000000;;		// Remember the default value as a string; it won't change.
0000000000000000000000000000000000000000;;		flag := &Flag{
0000000000000000000000000000000000000000;;			Name:  goflag.Name,
0000000000000000000000000000000000000000;;			Usage: goflag.Usage,
0000000000000000000000000000000000000000;;			Value: wrapFlagValue(goflag.Value),
0000000000000000000000000000000000000000;;			// Looks like golang flags don't set DefValue correctly  :-(
0000000000000000000000000000000000000000;;			//DefValue: goflag.DefValue,
0000000000000000000000000000000000000000;;			DefValue: goflag.Value.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Ex: if the golang flag was -v, allow both -v and --v to work
0000000000000000000000000000000000000000;;		if len(flag.Name) == 1 {
0000000000000000000000000000000000000000;;			flag.Shorthand = flag.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fv, ok := goflag.Value.(goBoolFlag); ok && fv.IsBoolFlag() {
0000000000000000000000000000000000000000;;			flag.NoOptDefVal = "true"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return flag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddGoFlag will add the given *flag.Flag to the pflag.FlagSet
0000000000000000000000000000000000000000;;	func (f *FlagSet) AddGoFlag(goflag *goflag.Flag) {
0000000000000000000000000000000000000000;;		if f.Lookup(goflag.Name) != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newflag := PFlagFromGoFlag(goflag)
0000000000000000000000000000000000000000;;		f.AddFlag(newflag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddGoFlagSet will add the given *flag.FlagSet to the pflag.FlagSet
0000000000000000000000000000000000000000;;	func (f *FlagSet) AddGoFlagSet(newSet *goflag.FlagSet) {
0000000000000000000000000000000000000000;;		if newSet == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newSet.VisitAll(func(goflag *goflag.Flag) {
0000000000000000000000000000000000000000;;			f.AddGoFlag(goflag)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
