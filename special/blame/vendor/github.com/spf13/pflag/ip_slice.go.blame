0000000000000000000000000000000000000000;;	package pflag
937aedc1ba701ed4ffc2a1bf689b91ab13bf9c0e;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -- ipSlice Value
0000000000000000000000000000000000000000;;	type ipSliceValue struct {
0000000000000000000000000000000000000000;;		value   *[]net.IP
0000000000000000000000000000000000000000;;		changed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newIPSliceValue(val []net.IP, p *[]net.IP) *ipSliceValue {
0000000000000000000000000000000000000000;;		ipsv := new(ipSliceValue)
0000000000000000000000000000000000000000;;		ipsv.value = p
0000000000000000000000000000000000000000;;		*ipsv.value = val
0000000000000000000000000000000000000000;;		return ipsv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set converts, and assigns, the comma-separated IP argument string representation as the []net.IP value of this flag.
0000000000000000000000000000000000000000;;	// If Set is called on a flag that already has a []net.IP assigned, the newly converted values will be appended.
0000000000000000000000000000000000000000;;	func (s *ipSliceValue) Set(val string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove all quote characters
0000000000000000000000000000000000000000;;		rmQuote := strings.NewReplacer(`"`, "", `'`, "", "`", "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// read flag arguments with CSV parser
0000000000000000000000000000000000000000;;		ipStrSlice, err := readAsCSV(rmQuote.Replace(val))
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse ip values into slice
0000000000000000000000000000000000000000;;		out := make([]net.IP, 0, len(ipStrSlice))
0000000000000000000000000000000000000000;;		for _, ipStr := range ipStrSlice {
0000000000000000000000000000000000000000;;			ip := net.ParseIP(strings.TrimSpace(ipStr))
0000000000000000000000000000000000000000;;			if ip == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid string being converted to IP address: %s", ipStr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, ip)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.changed {
0000000000000000000000000000000000000000;;			*s.value = out
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			*s.value = append(*s.value, out...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.changed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns a string that uniquely represents this flag's type.
0000000000000000000000000000000000000000;;	func (s *ipSliceValue) Type() string {
0000000000000000000000000000000000000000;;		return "ipSlice"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String defines a "native" format for this net.IP slice flag value.
0000000000000000000000000000000000000000;;	func (s *ipSliceValue) String() string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipStrSlice := make([]string, len(*s.value))
0000000000000000000000000000000000000000;;		for i, ip := range *s.value {
0000000000000000000000000000000000000000;;			ipStrSlice[i] = ip.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, _ := writeAsCSV(ipStrSlice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "[" + out + "]"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ipSliceConv(val string) (interface{}, error) {
0000000000000000000000000000000000000000;;		val = strings.Trim(val, "[]")
0000000000000000000000000000000000000000;;		// Emtpy string would cause a slice with one (empty) entry
0000000000000000000000000000000000000000;;		if len(val) == 0 {
0000000000000000000000000000000000000000;;			return []net.IP{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := strings.Split(val, ",")
0000000000000000000000000000000000000000;;		out := make([]net.IP, len(ss))
0000000000000000000000000000000000000000;;		for i, sval := range ss {
0000000000000000000000000000000000000000;;			ip := net.ParseIP(strings.TrimSpace(sval))
0000000000000000000000000000000000000000;;			if ip == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid string being converted to IP address: %s", sval)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out[i] = ip
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetIPSlice returns the []net.IP value of a flag with the given name
0000000000000000000000000000000000000000;;	func (f *FlagSet) GetIPSlice(name string) ([]net.IP, error) {
0000000000000000000000000000000000000000;;		val, err := f.getFlagType(name, "ipSlice", ipSliceConv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []net.IP{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val.([]net.IP), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSliceVar defines a ipSlice flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to a []net.IP variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IPSliceVar(p *[]net.IP, name string, value []net.IP, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newIPSliceValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSliceVarP is like IPSliceVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IPSliceVarP(p *[]net.IP, name, shorthand string, value []net.IP, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newIPSliceValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSliceVar defines a []net.IP flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to a []net.IP variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func IPSliceVar(p *[]net.IP, name string, value []net.IP, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newIPSliceValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSliceVarP is like IPSliceVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func IPSliceVarP(p *[]net.IP, name, shorthand string, value []net.IP, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newIPSliceValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSlice defines a []net.IP flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of a []net.IP variable that stores the value of that flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IPSlice(name string, value []net.IP, usage string) *[]net.IP {
0000000000000000000000000000000000000000;;		p := []net.IP{}
0000000000000000000000000000000000000000;;		f.IPSliceVarP(&p, name, "", value, usage)
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSliceP is like IPSlice, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IPSliceP(name, shorthand string, value []net.IP, usage string) *[]net.IP {
0000000000000000000000000000000000000000;;		p := []net.IP{}
0000000000000000000000000000000000000000;;		f.IPSliceVarP(&p, name, shorthand, value, usage)
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSlice defines a []net.IP flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of a []net.IP variable that stores the value of the flag.
0000000000000000000000000000000000000000;;	func IPSlice(name string, value []net.IP, usage string) *[]net.IP {
0000000000000000000000000000000000000000;;		return CommandLine.IPSliceP(name, "", value, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPSliceP is like IPSlice, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func IPSliceP(name, shorthand string, value []net.IP, usage string) *[]net.IP {
0000000000000000000000000000000000000000;;		return CommandLine.IPSliceP(name, shorthand, value, usage)
0000000000000000000000000000000000000000;;	}
