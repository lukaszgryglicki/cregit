0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0e1ba9a8116c18bfa1975dc7ebd4f015c258b467;Godeps/_workspace/src/github.com/spf13/pflag/flag.go[Godeps/_workspace/src/github.com/spf13/pflag/flag.go][vendor/github.com/spf13/pflag/flag.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package pflag is a drop-in replacement for Go's flag package, implementing
0000000000000000000000000000000000000000;;	POSIX/GNU-style --flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	pflag is compatible with the GNU extensions to the POSIX recommendations
0000000000000000000000000000000000000000;;	for command-line options. See
0000000000000000000000000000000000000000;;	http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Usage:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	pflag is a drop-in replacement of Go's native flag package. If you import
0000000000000000000000000000000000000000;;	pflag under the name "flag" then all code should continue to function
0000000000000000000000000000000000000000;;	with no changes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		import flag "github.com/ogier/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		There is one exception to this: if you directly instantiate the Flag struct
0000000000000000000000000000000000000000;;	there is one more field "Shorthand" that you will need to set.
0000000000000000000000000000000000000000;;	Most code never instantiates this struct directly, and instead uses
0000000000000000000000000000000000000000;;	functions such as String(), BoolVar(), and Var(), and is therefore
0000000000000000000000000000000000000000;;	unaffected.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Define flags using flag.String(), Bool(), Int(), etc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This declares an integer flag, -flagname, stored in the pointer ip, with type *int.
0000000000000000000000000000000000000000;;		var ip = flag.Int("flagname", 1234, "help message for flagname")
0000000000000000000000000000000000000000;;	If you like, you can bind the flag to a variable using the Var() functions.
0000000000000000000000000000000000000000;;		var flagvar int
0000000000000000000000000000000000000000;;		func init() {
0000000000000000000000000000000000000000;;			flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	Or you can create custom flags that satisfy the Value interface (with
0000000000000000000000000000000000000000;;	pointer receivers) and couple them to flag parsing by
0000000000000000000000000000000000000000;;		flag.Var(&flagVal, "name", "help message for flagname")
0000000000000000000000000000000000000000;;	For such flags, the default value is just the initial value of the variable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After all flags are defined, call
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	to parse the command line into the defined flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Flags may then be used directly. If you're using the flags themselves,
0000000000000000000000000000000000000000;;	they are all pointers; if you bind to variables, they're values.
0000000000000000000000000000000000000000;;		fmt.Println("ip has value ", *ip)
0000000000000000000000000000000000000000;;		fmt.Println("flagvar has value ", flagvar)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After parsing, the arguments after the flag are available as the
0000000000000000000000000000000000000000;;	slice flag.Args() or individually as flag.Arg(i).
0000000000000000000000000000000000000000;;	The arguments are indexed from 0 through flag.NArg()-1.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The pflag package also defines some new functions that are not in flag,
0000000000000000000000000000000000000000;;	that give one-letter shorthands for flags. You can use these by appending
0000000000000000000000000000000000000000;;	'P' to the name of any function that defines a flag.
0000000000000000000000000000000000000000;;		var ip = flag.IntP("flagname", "f", 1234, "help message")
0000000000000000000000000000000000000000;;		var flagvar bool
0000000000000000000000000000000000000000;;		func init() {
0000000000000000000000000000000000000000;;			flag.BoolVarP("boolname", "b", true, "help message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flag.VarP(&flagVar, "varname", "v", 1234, "help message")
0000000000000000000000000000000000000000;;	Shorthand letters can be used with single dashes on the command line.
0000000000000000000000000000000000000000;;	Boolean shorthand flags can be combined with other shorthand flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Command line flag syntax:
0000000000000000000000000000000000000000;;		--flag    // boolean flags only
0000000000000000000000000000000000000000;;		--flag=x
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unlike the flag package, a single dash before an option means something
0000000000000000000000000000000000000000;;	different than a double dash. Single dashes signify a series of shorthand
0000000000000000000000000000000000000000;;	letters for flags. All but the last shorthand letter must be boolean flags.
0000000000000000000000000000000000000000;;		// boolean flags
0000000000000000000000000000000000000000;;		-f
0000000000000000000000000000000000000000;;		-abc
0000000000000000000000000000000000000000;;		// non-boolean flags
0000000000000000000000000000000000000000;;		-n 1234
0000000000000000000000000000000000000000;;		-Ifile
0000000000000000000000000000000000000000;;		// mixed
0000000000000000000000000000000000000000;;		-abcs "hello"
0000000000000000000000000000000000000000;;		-abcn1234
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Flag parsing stops after the terminator "--". Unlike the flag package,
0000000000000000000000000000000000000000;;	flags can be interspersed with arguments anywhere on the command line
0000000000000000000000000000000000000000;;	before this terminator.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Integer flags accept 1234, 0664, 0x1234 and may be negative.
0000000000000000000000000000000000000000;;	Boolean flags (in their long form) accept 1, 0, t, f, true, false,
0000000000000000000000000000000000000000;;	TRUE, FALSE, True, False.
0000000000000000000000000000000000000000;;	Duration flags accept any input valid for time.ParseDuration.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default set of command-line flags is controlled by
0000000000000000000000000000000000000000;;	top-level functions.  The FlagSet type allows one to define
0000000000000000000000000000000000000000;;	independent sets of flags, such as to implement subcommands
0000000000000000000000000000000000000000;;	in a command-line interface. The methods of FlagSet are
0000000000000000000000000000000000000000;;	analogous to the top-level functions for the command-line
0000000000000000000000000000000000000000;;	flag set.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package pflag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrHelp is the error returned if the flag -help is invoked but no such flag is defined.
0000000000000000000000000000000000000000;;	var ErrHelp = errors.New("pflag: help requested")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorHandling defines how to handle flag parsing errors.
0000000000000000000000000000000000000000;;	type ErrorHandling int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ContinueOnError will return an err from Parse() if an error is found
0000000000000000000000000000000000000000;;		ContinueOnError ErrorHandling = iota
0000000000000000000000000000000000000000;;		// ExitOnError will call os.Exit(2) if an error is found when parsing
0000000000000000000000000000000000000000;;		ExitOnError
0000000000000000000000000000000000000000;;		// PanicOnError will panic() if an error is found when parsing flags
0000000000000000000000000000000000000000;;		PanicOnError
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NormalizedName is a flag name that has been normalized according to rules
0000000000000000000000000000000000000000;;	// for the FlagSet (e.g. making '-' and '_' equivalent).
0000000000000000000000000000000000000000;;	type NormalizedName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A FlagSet represents a set of defined flags.
0000000000000000000000000000000000000000;;	type FlagSet struct {
0000000000000000000000000000000000000000;;		// Usage is the function called when an error occurs while parsing flags.
0000000000000000000000000000000000000000;;		// The field is a function (not a method) that may be changed to point to
0000000000000000000000000000000000000000;;		// a custom error handler.
0000000000000000000000000000000000000000;;		Usage func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name              string
0000000000000000000000000000000000000000;;		parsed            bool
0000000000000000000000000000000000000000;;		actual            map[NormalizedName]*Flag
0000000000000000000000000000000000000000;;		formal            map[NormalizedName]*Flag
0000000000000000000000000000000000000000;;		shorthands        map[byte]*Flag
0000000000000000000000000000000000000000;;		args              []string // arguments after flags
0000000000000000000000000000000000000000;;		argsLenAtDash     int      // len(args) when a '--' was located when parsing, or -1 if no --
0000000000000000000000000000000000000000;;		exitOnError       bool     // does the program exit if there's an error?
0000000000000000000000000000000000000000;;		errorHandling     ErrorHandling
0000000000000000000000000000000000000000;;		output            io.Writer // nil means stderr; use out() accessor
0000000000000000000000000000000000000000;;		interspersed      bool      // allow interspersed option/non-option args
0000000000000000000000000000000000000000;;		normalizeNameFunc func(f *FlagSet, name string) NormalizedName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Flag represents the state of a flag.
0000000000000000000000000000000000000000;;	type Flag struct {
0000000000000000000000000000000000000000;;		Name                string              // name as it appears on command line
0000000000000000000000000000000000000000;;		Shorthand           string              // one-letter abbreviated flag
0000000000000000000000000000000000000000;;		Usage               string              // help message
0000000000000000000000000000000000000000;;		Value               Value               // value as set
0000000000000000000000000000000000000000;;		DefValue            string              // default value (as text); for usage message
0000000000000000000000000000000000000000;;		Changed             bool                // If the user set the value (or if left to default)
0000000000000000000000000000000000000000;;		NoOptDefVal         string              //default value (as text); if the flag is on the command line without any options
0000000000000000000000000000000000000000;;		Deprecated          string              // If this flag is deprecated, this string is the new or now thing to use
0000000000000000000000000000000000000000;;		Hidden              bool                // used by cobra.Command to allow flags to be hidden from help/usage text
0000000000000000000000000000000000000000;;		ShorthandDeprecated string              // If the shorthand of this flag is deprecated, this string is the new or now thing to use
0000000000000000000000000000000000000000;;		Annotations         map[string][]string // used by cobra.Command bash autocomple code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value is the interface to the dynamic value stored in a flag.
0000000000000000000000000000000000000000;;	// (The default value is represented as a string.)
0000000000000000000000000000000000000000;;	type Value interface {
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;		Set(string) error
0000000000000000000000000000000000000000;;		Type() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sortFlags returns the flags as a slice in lexicographical sorted order.
0000000000000000000000000000000000000000;;	func sortFlags(flags map[NormalizedName]*Flag) []*Flag {
0000000000000000000000000000000000000000;;		list := make(sort.StringSlice, len(flags))
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for k := range flags {
0000000000000000000000000000000000000000;;			list[i] = string(k)
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list.Sort()
0000000000000000000000000000000000000000;;		result := make([]*Flag, len(list))
0000000000000000000000000000000000000000;;		for i, name := range list {
0000000000000000000000000000000000000000;;			result[i] = flags[NormalizedName(name)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetNormalizeFunc allows you to add a function which can translate flag names.
0000000000000000000000000000000000000000;;	// Flags added to the FlagSet will be translated and then when anything tries to
0000000000000000000000000000000000000000;;	// look up the flag that will also be translated. So it would be possible to create
0000000000000000000000000000000000000000;;	// a flag named "getURL" and have it translated to "geturl".  A user could then pass
0000000000000000000000000000000000000000;;	// "--getUrl" which may also be translated to "geturl" and everything will work.
0000000000000000000000000000000000000000;;	func (f *FlagSet) SetNormalizeFunc(n func(f *FlagSet, name string) NormalizedName) {
0000000000000000000000000000000000000000;;		f.normalizeNameFunc = n
0000000000000000000000000000000000000000;;		for k, v := range f.formal {
0000000000000000000000000000000000000000;;			delete(f.formal, k)
0000000000000000000000000000000000000000;;			nname := f.normalizeFlagName(string(k))
0000000000000000000000000000000000000000;;			f.formal[nname] = v
0000000000000000000000000000000000000000;;			v.Name = string(nname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetNormalizeFunc returns the previously set NormalizeFunc of a function which
0000000000000000000000000000000000000000;;	// does no translation, if not set previously.
0000000000000000000000000000000000000000;;	func (f *FlagSet) GetNormalizeFunc() func(f *FlagSet, name string) NormalizedName {
0000000000000000000000000000000000000000;;		if f.normalizeNameFunc != nil {
0000000000000000000000000000000000000000;;			return f.normalizeNameFunc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(f *FlagSet, name string) NormalizedName { return NormalizedName(name) }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FlagSet) normalizeFlagName(name string) NormalizedName {
0000000000000000000000000000000000000000;;		n := f.GetNormalizeFunc()
0000000000000000000000000000000000000000;;		return n(f, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FlagSet) out() io.Writer {
0000000000000000000000000000000000000000;;		if f.output == nil {
0000000000000000000000000000000000000000;;			return os.Stderr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.output
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetOutput sets the destination for usage and error messages.
0000000000000000000000000000000000000000;;	// If output is nil, os.Stderr is used.
0000000000000000000000000000000000000000;;	func (f *FlagSet) SetOutput(output io.Writer) {
0000000000000000000000000000000000000000;;		f.output = output
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitAll visits the flags in lexicographical order, calling fn for each.
0000000000000000000000000000000000000000;;	// It visits all flags, even those not set.
0000000000000000000000000000000000000000;;	func (f *FlagSet) VisitAll(fn func(*Flag)) {
0000000000000000000000000000000000000000;;		for _, flag := range sortFlags(f.formal) {
0000000000000000000000000000000000000000;;			fn(flag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasFlags returns a bool to indicate if the FlagSet has any flags definied.
0000000000000000000000000000000000000000;;	func (f *FlagSet) HasFlags() bool {
0000000000000000000000000000000000000000;;		return len(f.formal) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAvailableFlags returns a bool to indicate if the FlagSet has any flags
0000000000000000000000000000000000000000;;	// definied that are not hidden or deprecated.
0000000000000000000000000000000000000000;;	func (f *FlagSet) HasAvailableFlags() bool {
0000000000000000000000000000000000000000;;		for _, flag := range f.formal {
0000000000000000000000000000000000000000;;			if !flag.Hidden && len(flag.Deprecated) == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VisitAll visits the command-line flags in lexicographical order, calling
0000000000000000000000000000000000000000;;	// fn for each.  It visits all flags, even those not set.
0000000000000000000000000000000000000000;;	func VisitAll(fn func(*Flag)) {
0000000000000000000000000000000000000000;;		CommandLine.VisitAll(fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit visits the flags in lexicographical order, calling fn for each.
0000000000000000000000000000000000000000;;	// It visits only those flags that have been set.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Visit(fn func(*Flag)) {
0000000000000000000000000000000000000000;;		for _, flag := range sortFlags(f.actual) {
0000000000000000000000000000000000000000;;			fn(flag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit visits the command-line flags in lexicographical order, calling fn
0000000000000000000000000000000000000000;;	// for each.  It visits only those flags that have been set.
0000000000000000000000000000000000000000;;	func Visit(fn func(*Flag)) {
0000000000000000000000000000000000000000;;		CommandLine.Visit(fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup returns the Flag structure of the named flag, returning nil if none exists.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Lookup(name string) *Flag {
0000000000000000000000000000000000000000;;		return f.lookup(f.normalizeFlagName(name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lookup returns the Flag structure of the named flag, returning nil if none exists.
0000000000000000000000000000000000000000;;	func (f *FlagSet) lookup(name NormalizedName) *Flag {
0000000000000000000000000000000000000000;;		return f.formal[name]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func to return a given type for a given flag name
0000000000000000000000000000000000000000;;	func (f *FlagSet) getFlagType(name string, ftype string, convFunc func(sval string) (interface{}, error)) (interface{}, error) {
0000000000000000000000000000000000000000;;		flag := f.Lookup(name)
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("flag accessed but not defined: %s", name)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flag.Value.Type() != ftype {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("trying to get %s value of flag of type %s", ftype, flag.Value.Type())
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sval := flag.Value.String()
0000000000000000000000000000000000000000;;		result, err := convFunc(sval)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ArgsLenAtDash will return the length of f.Args at the moment when a -- was
0000000000000000000000000000000000000000;;	// found during arg parsing. This allows your program to know which args were
0000000000000000000000000000000000000000;;	// before the -- and which came after.
0000000000000000000000000000000000000000;;	func (f *FlagSet) ArgsLenAtDash() int {
0000000000000000000000000000000000000000;;		return f.argsLenAtDash
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarkDeprecated indicated that a flag is deprecated in your program. It will
0000000000000000000000000000000000000000;;	// continue to function but will not show up in help or usage messages. Using
0000000000000000000000000000000000000000;;	// this flag will also print the given usageMessage.
0000000000000000000000000000000000000000;;	func (f *FlagSet) MarkDeprecated(name string, usageMessage string) error {
0000000000000000000000000000000000000000;;		flag := f.Lookup(name)
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("flag %q does not exist", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(usageMessage) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("deprecated message for flag %q must be set", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flag.Deprecated = usageMessage
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarkShorthandDeprecated will mark the shorthand of a flag deprecated in your
0000000000000000000000000000000000000000;;	// program. It will continue to function but will not show up in help or usage
0000000000000000000000000000000000000000;;	// messages. Using this flag will also print the given usageMessage.
0000000000000000000000000000000000000000;;	func (f *FlagSet) MarkShorthandDeprecated(name string, usageMessage string) error {
0000000000000000000000000000000000000000;;		flag := f.Lookup(name)
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("flag %q does not exist", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(usageMessage) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("deprecated message for flag %q must be set", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flag.ShorthandDeprecated = usageMessage
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarkHidden sets a flag to 'hidden' in your program. It will continue to
0000000000000000000000000000000000000000;;	// function but will not show up in help or usage messages.
0000000000000000000000000000000000000000;;	func (f *FlagSet) MarkHidden(name string) error {
0000000000000000000000000000000000000000;;		flag := f.Lookup(name)
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("flag %q does not exist", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flag.Hidden = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup returns the Flag structure of the named command-line flag,
0000000000000000000000000000000000000000;;	// returning nil if none exists.
0000000000000000000000000000000000000000;;	func Lookup(name string) *Flag {
0000000000000000000000000000000000000000;;		return CommandLine.Lookup(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets the value of the named flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Set(name, value string) error {
0000000000000000000000000000000000000000;;		normalName := f.normalizeFlagName(name)
0000000000000000000000000000000000000000;;		flag, ok := f.formal[normalName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no such flag -%v", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := flag.Value.Set(value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.actual == nil {
0000000000000000000000000000000000000000;;			f.actual = make(map[NormalizedName]*Flag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.actual[normalName] = flag
0000000000000000000000000000000000000000;;		flag.Changed = true
0000000000000000000000000000000000000000;;		if len(flag.Deprecated) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Flag --%s has been deprecated, %s\n", flag.Name, flag.Deprecated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAnnotation allows one to set arbitrary annotations on a flag in the FlagSet.
0000000000000000000000000000000000000000;;	// This is sometimes used by spf13/cobra programs which want to generate additional
0000000000000000000000000000000000000000;;	// bash completion information.
0000000000000000000000000000000000000000;;	func (f *FlagSet) SetAnnotation(name, key string, values []string) error {
0000000000000000000000000000000000000000;;		normalName := f.normalizeFlagName(name)
0000000000000000000000000000000000000000;;		flag, ok := f.formal[normalName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no such flag -%v", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flag.Annotations == nil {
0000000000000000000000000000000000000000;;			flag.Annotations = map[string][]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flag.Annotations[key] = values
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Changed returns true if the flag was explicitly set during Parse() and false
0000000000000000000000000000000000000000;;	// otherwise
0000000000000000000000000000000000000000;;	func (f *FlagSet) Changed(name string) bool {
0000000000000000000000000000000000000000;;		flag := f.Lookup(name)
0000000000000000000000000000000000000000;;		// If a flag doesn't exist, it wasn't changed....
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return flag.Changed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets the value of the named command-line flag.
0000000000000000000000000000000000000000;;	func Set(name, value string) error {
0000000000000000000000000000000000000000;;		return CommandLine.Set(name, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintDefaults prints, to standard error unless configured
0000000000000000000000000000000000000000;;	// otherwise, the default values of all defined flags in the set.
0000000000000000000000000000000000000000;;	func (f *FlagSet) PrintDefaults() {
0000000000000000000000000000000000000000;;		usages := f.FlagUsages()
0000000000000000000000000000000000000000;;		fmt.Fprint(f.out(), usages)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultIsZeroValue returns true if the default value for this flag represents
0000000000000000000000000000000000000000;;	// a zero value.
0000000000000000000000000000000000000000;;	func (f *Flag) defaultIsZeroValue() bool {
0000000000000000000000000000000000000000;;		switch f.Value.(type) {
0000000000000000000000000000000000000000;;		case boolFlag:
0000000000000000000000000000000000000000;;			return f.DefValue == "false"
0000000000000000000000000000000000000000;;		case *durationValue:
0000000000000000000000000000000000000000;;			// Beginning in Go 1.7, duration zero values are "0s"
0000000000000000000000000000000000000000;;			return f.DefValue == "0" || f.DefValue == "0s"
0000000000000000000000000000000000000000;;		case *intValue, *int8Value, *int32Value, *int64Value, *uintValue, *uint8Value, *uint16Value, *uint32Value, *uint64Value, *countValue, *float32Value, *float64Value:
0000000000000000000000000000000000000000;;			return f.DefValue == "0"
0000000000000000000000000000000000000000;;		case *stringValue:
0000000000000000000000000000000000000000;;			return f.DefValue == ""
0000000000000000000000000000000000000000;;		case *ipValue, *ipMaskValue, *ipNetValue:
0000000000000000000000000000000000000000;;			return f.DefValue == "<nil>"
0000000000000000000000000000000000000000;;		case *intSliceValue, *stringSliceValue, *stringArrayValue:
0000000000000000000000000000000000000000;;			return f.DefValue == "[]"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch f.Value.String() {
0000000000000000000000000000000000000000;;			case "false":
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case "<nil>":
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case "":
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case "0":
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnquoteUsage extracts a back-quoted name from the usage
0000000000000000000000000000000000000000;;	// string for a flag and returns it and the un-quoted usage.
0000000000000000000000000000000000000000;;	// Given "a `name` to show" it returns ("name", "a name to show").
0000000000000000000000000000000000000000;;	// If there are no back quotes, the name is an educated guess of the
0000000000000000000000000000000000000000;;	// type of the flag's value, or the empty string if the flag is boolean.
0000000000000000000000000000000000000000;;	func UnquoteUsage(flag *Flag) (name string, usage string) {
0000000000000000000000000000000000000000;;		// Look for a back-quoted name, but avoid the strings package.
0000000000000000000000000000000000000000;;		usage = flag.Usage
0000000000000000000000000000000000000000;;		for i := 0; i < len(usage); i++ {
0000000000000000000000000000000000000000;;			if usage[i] == '`' {
0000000000000000000000000000000000000000;;				for j := i + 1; j < len(usage); j++ {
0000000000000000000000000000000000000000;;					if usage[j] == '`' {
0000000000000000000000000000000000000000;;						name = usage[i+1 : j]
0000000000000000000000000000000000000000;;						usage = usage[:i] + name + usage[j+1:]
0000000000000000000000000000000000000000;;						return name, usage
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break // Only one back quote; use type name.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name = flag.Value.Type()
0000000000000000000000000000000000000000;;		switch name {
0000000000000000000000000000000000000000;;		case "bool":
0000000000000000000000000000000000000000;;			name = ""
0000000000000000000000000000000000000000;;		case "float64":
0000000000000000000000000000000000000000;;			name = "float"
0000000000000000000000000000000000000000;;		case "int64":
0000000000000000000000000000000000000000;;			name = "int"
0000000000000000000000000000000000000000;;		case "uint64":
0000000000000000000000000000000000000000;;			name = "uint"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Splits the string `s` on whitespace into an initial substring up to
0000000000000000000000000000000000000000;;	// `i` runes in length and the remainder. Will go `slop` over `i` if
0000000000000000000000000000000000000000;;	// that encompasses the entire string (which allows the caller to
0000000000000000000000000000000000000000;;	// avoid short orphan words on the final line).
0000000000000000000000000000000000000000;;	func wrapN(i, slop int, s string) (string, string) {
0000000000000000000000000000000000000000;;		if i+slop > len(s) {
0000000000000000000000000000000000000000;;			return s, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := strings.LastIndexAny(s[:i], " \t")
0000000000000000000000000000000000000000;;		if w <= 0 {
0000000000000000000000000000000000000000;;			return s, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s[:w], s[w+1:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wraps the string `s` to a maximum width `w` with leading indent
0000000000000000000000000000000000000000;;	// `i`. The first line is not indented (this is assumed to be done by
0000000000000000000000000000000000000000;;	// caller). Pass `w` == 0 to do no wrapping
0000000000000000000000000000000000000000;;	func wrap(i, w int, s string) string {
0000000000000000000000000000000000000000;;		if w == 0 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// space between indent i and end of line width w into which
0000000000000000000000000000000000000000;;		// we should wrap the text.
0000000000000000000000000000000000000000;;		wrap := w - i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r, l string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Not enough space for sensible wrapping. Wrap as a block on
0000000000000000000000000000000000000000;;		// the next line instead.
0000000000000000000000000000000000000000;;		if wrap < 24 {
0000000000000000000000000000000000000000;;			i = 16
0000000000000000000000000000000000000000;;			wrap = w - i
0000000000000000000000000000000000000000;;			r += "\n" + strings.Repeat(" ", i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If still not enough space then don't even try to wrap.
0000000000000000000000000000000000000000;;		if wrap < 24 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to avoid short orphan words on the final line, by
0000000000000000000000000000000000000000;;		// allowing wrapN to go a bit over if that would fit in the
0000000000000000000000000000000000000000;;		// remainder of the line.
0000000000000000000000000000000000000000;;		slop := 5
0000000000000000000000000000000000000000;;		wrap = wrap - slop
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle first line, which is indented by the caller (or the
0000000000000000000000000000000000000000;;		// special case above)
0000000000000000000000000000000000000000;;		l, s = wrapN(wrap, slop, s)
0000000000000000000000000000000000000000;;		r = r + l
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now wrap the rest
0000000000000000000000000000000000000000;;		for s != "" {
0000000000000000000000000000000000000000;;			var t string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t, s = wrapN(wrap, slop, s)
0000000000000000000000000000000000000000;;			r = r + "\n" + strings.Repeat(" ", i) + t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlagUsagesWrapped returns a string containing the usage information
0000000000000000000000000000000000000000;;	// for all flags in the FlagSet. Wrapped to `cols` columns (0 for no
0000000000000000000000000000000000000000;;	// wrapping)
0000000000000000000000000000000000000000;;	func (f *FlagSet) FlagUsagesWrapped(cols int) string {
0000000000000000000000000000000000000000;;		x := new(bytes.Buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := make([]string, 0, len(f.formal))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxlen := 0
0000000000000000000000000000000000000000;;		f.VisitAll(func(flag *Flag) {
0000000000000000000000000000000000000000;;			if len(flag.Deprecated) > 0 || flag.Hidden {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			line := ""
0000000000000000000000000000000000000000;;			if len(flag.Shorthand) > 0 && len(flag.ShorthandDeprecated) == 0 {
0000000000000000000000000000000000000000;;				line = fmt.Sprintf("  -%s, --%s", flag.Shorthand, flag.Name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				line = fmt.Sprintf("      --%s", flag.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			varname, usage := UnquoteUsage(flag)
0000000000000000000000000000000000000000;;			if len(varname) > 0 {
0000000000000000000000000000000000000000;;				line += " " + varname
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(flag.NoOptDefVal) > 0 {
0000000000000000000000000000000000000000;;				switch flag.Value.Type() {
0000000000000000000000000000000000000000;;				case "string":
0000000000000000000000000000000000000000;;					line += fmt.Sprintf("[=\"%s\"]", flag.NoOptDefVal)
0000000000000000000000000000000000000000;;				case "bool":
0000000000000000000000000000000000000000;;					if flag.NoOptDefVal != "true" {
0000000000000000000000000000000000000000;;						line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This special character will be replaced with spacing once the
0000000000000000000000000000000000000000;;			// correct alignment is calculated
0000000000000000000000000000000000000000;;			line += "\x00"
0000000000000000000000000000000000000000;;			if len(line) > maxlen {
0000000000000000000000000000000000000000;;				maxlen = len(line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			line += usage
0000000000000000000000000000000000000000;;			if !flag.defaultIsZeroValue() {
0000000000000000000000000000000000000000;;				if flag.Value.Type() == "string" {
0000000000000000000000000000000000000000;;					line += fmt.Sprintf(" (default \"%s\")", flag.DefValue)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					line += fmt.Sprintf(" (default %s)", flag.DefValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lines = append(lines, line)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			sidx := strings.Index(line, "\x00")
0000000000000000000000000000000000000000;;			spacing := strings.Repeat(" ", maxlen-sidx)
0000000000000000000000000000000000000000;;			// maxlen + 2 comes from + 1 for the \x00 and + 1 for the (deliberate) off-by-one in maxlen-sidx
0000000000000000000000000000000000000000;;			fmt.Fprintln(x, line[:sidx], spacing, wrap(maxlen+2, cols, line[sidx+1:]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return x.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlagUsages returns a string containing the usage information for all flags in
0000000000000000000000000000000000000000;;	// the FlagSet
0000000000000000000000000000000000000000;;	func (f *FlagSet) FlagUsages() string {
0000000000000000000000000000000000000000;;		return f.FlagUsagesWrapped(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintDefaults prints to standard error the default values of all defined command-line flags.
0000000000000000000000000000000000000000;;	func PrintDefaults() {
0000000000000000000000000000000000000000;;		CommandLine.PrintDefaults()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultUsage is the default function to print a usage message.
0000000000000000000000000000000000000000;;	func defaultUsage(f *FlagSet) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(f.out(), "Usage of %s:\n", f.name)
0000000000000000000000000000000000000000;;		f.PrintDefaults()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NOTE: Usage is not just defaultUsage(CommandLine)
0000000000000000000000000000000000000000;;	// because it serves (via godoc flag Usage) as the example
0000000000000000000000000000000000000000;;	// for how to write your own usage function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usage prints to standard error a usage message documenting all defined command-line flags.
0000000000000000000000000000000000000000;;	// The function is a variable that may be changed to point to a custom function.
0000000000000000000000000000000000000000;;	// By default it prints a simple header and calls PrintDefaults; for details about the
0000000000000000000000000000000000000000;;	// format of the output and how to control it, see the documentation for PrintDefaults.
0000000000000000000000000000000000000000;;	var Usage = func() {
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
0000000000000000000000000000000000000000;;		PrintDefaults()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NFlag returns the number of flags that have been set.
0000000000000000000000000000000000000000;;	func (f *FlagSet) NFlag() int { return len(f.actual) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NFlag returns the number of command-line flags that have been set.
0000000000000000000000000000000000000000;;	func NFlag() int { return len(CommandLine.actual) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Arg returns the i'th argument.  Arg(0) is the first remaining argument
0000000000000000000000000000000000000000;;	// after flags have been processed.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Arg(i int) string {
0000000000000000000000000000000000000000;;		if i < 0 || i >= len(f.args) {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.args[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Arg returns the i'th command-line argument.  Arg(0) is the first remaining argument
0000000000000000000000000000000000000000;;	// after flags have been processed.
0000000000000000000000000000000000000000;;	func Arg(i int) string {
0000000000000000000000000000000000000000;;		return CommandLine.Arg(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NArg is the number of arguments remaining after flags have been processed.
0000000000000000000000000000000000000000;;	func (f *FlagSet) NArg() int { return len(f.args) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NArg is the number of arguments remaining after flags have been processed.
0000000000000000000000000000000000000000;;	func NArg() int { return len(CommandLine.args) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Args returns the non-flag arguments.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Args() []string { return f.args }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Args returns the non-flag command-line arguments.
0000000000000000000000000000000000000000;;	func Args() []string { return CommandLine.args }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Var defines a flag with the specified name and usage string. The type and
0000000000000000000000000000000000000000;;	// value of the flag are represented by the first argument, of type Value, which
0000000000000000000000000000000000000000;;	// typically holds a user-defined implementation of Value. For instance, the
0000000000000000000000000000000000000000;;	// caller could create a flag that turns a comma-separated string into a slice
0000000000000000000000000000000000000000;;	// of strings by giving the slice the methods of Value; in particular, Set would
0000000000000000000000000000000000000000;;	// decompose the comma-separated string into the slice.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Var(value Value, name string, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(value, name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VarPF is like VarP, but returns the flag created
0000000000000000000000000000000000000000;;	func (f *FlagSet) VarPF(value Value, name, shorthand, usage string) *Flag {
0000000000000000000000000000000000000000;;		// Remember the default value as a string; it won't change.
0000000000000000000000000000000000000000;;		flag := &Flag{
0000000000000000000000000000000000000000;;			Name:      name,
0000000000000000000000000000000000000000;;			Shorthand: shorthand,
0000000000000000000000000000000000000000;;			Usage:     usage,
0000000000000000000000000000000000000000;;			Value:     value,
0000000000000000000000000000000000000000;;			DefValue:  value.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.AddFlag(flag)
0000000000000000000000000000000000000000;;		return flag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VarP is like Var, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) VarP(value Value, name, shorthand, usage string) {
0000000000000000000000000000000000000000;;		f.VarPF(value, name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlag will add the flag to the FlagSet
0000000000000000000000000000000000000000;;	func (f *FlagSet) AddFlag(flag *Flag) {
0000000000000000000000000000000000000000;;		// Call normalizeFlagName function only once
0000000000000000000000000000000000000000;;		normalizedFlagName := f.normalizeFlagName(flag.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, alreadythere := f.formal[normalizedFlagName]
0000000000000000000000000000000000000000;;		if alreadythere {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("%s flag redefined: %s", f.name, flag.Name)
0000000000000000000000000000000000000000;;			fmt.Fprintln(f.out(), msg)
0000000000000000000000000000000000000000;;			panic(msg) // Happens only if flags are declared with identical names
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.formal == nil {
0000000000000000000000000000000000000000;;			f.formal = make(map[NormalizedName]*Flag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag.Name = string(normalizedFlagName)
0000000000000000000000000000000000000000;;		f.formal[normalizedFlagName] = flag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(flag.Shorthand) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(flag.Shorthand) > 1 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(f.out(), "%s shorthand more than ASCII character: %s\n", f.name, flag.Shorthand)
0000000000000000000000000000000000000000;;			panic("shorthand is more than one character")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.shorthands == nil {
0000000000000000000000000000000000000000;;			f.shorthands = make(map[byte]*Flag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := flag.Shorthand[0]
0000000000000000000000000000000000000000;;		old, alreadythere := f.shorthands[c]
0000000000000000000000000000000000000000;;		if alreadythere {
0000000000000000000000000000000000000000;;			fmt.Fprintf(f.out(), "%s shorthand reused: %q for %s already used for %s\n", f.name, c, flag.Name, old.Name)
0000000000000000000000000000000000000000;;			panic("shorthand redefinition")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.shorthands[c] = flag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlagSet adds one FlagSet to another. If a flag is already present in f
0000000000000000000000000000000000000000;;	// the flag from newSet will be ignored
0000000000000000000000000000000000000000;;	func (f *FlagSet) AddFlagSet(newSet *FlagSet) {
0000000000000000000000000000000000000000;;		if newSet == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newSet.VisitAll(func(flag *Flag) {
0000000000000000000000000000000000000000;;			if f.Lookup(flag.Name) == nil {
0000000000000000000000000000000000000000;;				f.AddFlag(flag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Var defines a flag with the specified name and usage string. The type and
0000000000000000000000000000000000000000;;	// value of the flag are represented by the first argument, of type Value, which
0000000000000000000000000000000000000000;;	// typically holds a user-defined implementation of Value. For instance, the
0000000000000000000000000000000000000000;;	// caller could create a flag that turns a comma-separated string into a slice
0000000000000000000000000000000000000000;;	// of strings by giving the slice the methods of Value; in particular, Set would
0000000000000000000000000000000000000000;;	// decompose the comma-separated string into the slice.
0000000000000000000000000000000000000000;;	func Var(value Value, name string, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(value, name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VarP is like Var, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func VarP(value Value, name, shorthand, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(value, name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// failf prints to standard error a formatted error and usage message and
0000000000000000000000000000000000000000;;	// returns the error.
0000000000000000000000000000000000000000;;	func (f *FlagSet) failf(format string, a ...interface{}) error {
0000000000000000000000000000000000000000;;		err := fmt.Errorf(format, a...)
0000000000000000000000000000000000000000;;		fmt.Fprintln(f.out(), err)
0000000000000000000000000000000000000000;;		f.usage()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// usage calls the Usage method for the flag set, or the usage function if
0000000000000000000000000000000000000000;;	// the flag set is CommandLine.
0000000000000000000000000000000000000000;;	func (f *FlagSet) usage() {
0000000000000000000000000000000000000000;;		if f == CommandLine {
0000000000000000000000000000000000000000;;			Usage()
0000000000000000000000000000000000000000;;		} else if f.Usage == nil {
0000000000000000000000000000000000000000;;			defaultUsage(f)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f.Usage()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FlagSet) setFlag(flag *Flag, value string, origArg string) error {
0000000000000000000000000000000000000000;;		if err := flag.Value.Set(value); err != nil {
0000000000000000000000000000000000000000;;			return f.failf("invalid argument %q for %s: %v", value, origArg, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// mark as visited for Visit()
0000000000000000000000000000000000000000;;		if f.actual == nil {
0000000000000000000000000000000000000000;;			f.actual = make(map[NormalizedName]*Flag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.actual[f.normalizeFlagName(flag.Name)] = flag
0000000000000000000000000000000000000000;;		flag.Changed = true
0000000000000000000000000000000000000000;;		if len(flag.Deprecated) > 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Flag --%s has been deprecated, %s\n", flag.Name, flag.Deprecated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(flag.ShorthandDeprecated) > 0 && containsShorthand(origArg, flag.Shorthand) {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Flag shorthand -%s has been deprecated, %s\n", flag.Shorthand, flag.ShorthandDeprecated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containsShorthand(arg, shorthand string) bool {
0000000000000000000000000000000000000000;;		// filter out flags --<flag_name>
0000000000000000000000000000000000000000;;		if strings.HasPrefix(arg, "-") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		arg = strings.SplitN(arg, "=", 2)[0]
0000000000000000000000000000000000000000;;		return strings.Contains(arg, shorthand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FlagSet) parseLongArg(s string, args []string, fn parseFunc) (a []string, err error) {
0000000000000000000000000000000000000000;;		a = args
0000000000000000000000000000000000000000;;		name := s[2:]
0000000000000000000000000000000000000000;;		if len(name) == 0 || name[0] == '-' || name[0] == '=' {
0000000000000000000000000000000000000000;;			err = f.failf("bad flag syntax: %s", s)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		split := strings.SplitN(name, "=", 2)
0000000000000000000000000000000000000000;;		name = split[0]
0000000000000000000000000000000000000000;;		flag, alreadythere := f.formal[f.normalizeFlagName(name)]
0000000000000000000000000000000000000000;;		if !alreadythere {
0000000000000000000000000000000000000000;;			if name == "help" { // special case for nice help message.
0000000000000000000000000000000000000000;;				f.usage()
0000000000000000000000000000000000000000;;				return a, ErrHelp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = f.failf("unknown flag: --%s", name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var value string
0000000000000000000000000000000000000000;;		if len(split) == 2 {
0000000000000000000000000000000000000000;;			// '--flag=arg'
0000000000000000000000000000000000000000;;			value = split[1]
0000000000000000000000000000000000000000;;		} else if len(flag.NoOptDefVal) > 0 {
0000000000000000000000000000000000000000;;			// '--flag' (arg was optional)
0000000000000000000000000000000000000000;;			value = flag.NoOptDefVal
0000000000000000000000000000000000000000;;		} else if len(a) > 0 {
0000000000000000000000000000000000000000;;			// '--flag arg'
0000000000000000000000000000000000000000;;			value = a[0]
0000000000000000000000000000000000000000;;			a = a[1:]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// '--flag' (arg was required)
0000000000000000000000000000000000000000;;			err = f.failf("flag needs an argument: %s", s)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = fn(flag, value, s)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FlagSet) parseSingleShortArg(shorthands string, args []string, fn parseFunc) (outShorts string, outArgs []string, err error) {
0000000000000000000000000000000000000000;;		if strings.HasPrefix(shorthands, "test.") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outArgs = args
0000000000000000000000000000000000000000;;		outShorts = shorthands[1:]
0000000000000000000000000000000000000000;;		c := shorthands[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag, alreadythere := f.shorthands[c]
0000000000000000000000000000000000000000;;		if !alreadythere {
0000000000000000000000000000000000000000;;			if c == 'h' { // special case for nice help message.
0000000000000000000000000000000000000000;;				f.usage()
0000000000000000000000000000000000000000;;				err = ErrHelp
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//TODO continue on error
0000000000000000000000000000000000000000;;			err = f.failf("unknown shorthand flag: %q in -%s", c, shorthands)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var value string
0000000000000000000000000000000000000000;;		if len(shorthands) > 2 && shorthands[1] == '=' {
0000000000000000000000000000000000000000;;			value = shorthands[2:]
0000000000000000000000000000000000000000;;			outShorts = ""
0000000000000000000000000000000000000000;;		} else if len(flag.NoOptDefVal) > 0 {
0000000000000000000000000000000000000000;;			value = flag.NoOptDefVal
0000000000000000000000000000000000000000;;		} else if len(shorthands) > 1 {
0000000000000000000000000000000000000000;;			value = shorthands[1:]
0000000000000000000000000000000000000000;;			outShorts = ""
0000000000000000000000000000000000000000;;		} else if len(args) > 0 {
0000000000000000000000000000000000000000;;			value = args[0]
0000000000000000000000000000000000000000;;			outArgs = args[1:]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = f.failf("flag needs an argument: %q in -%s", c, shorthands)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = fn(flag, value, shorthands)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FlagSet) parseShortArg(s string, args []string, fn parseFunc) (a []string, err error) {
0000000000000000000000000000000000000000;;		a = args
0000000000000000000000000000000000000000;;		shorthands := s[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(shorthands) > 0 {
0000000000000000000000000000000000000000;;			shorthands, a, err = f.parseSingleShortArg(shorthands, args, fn)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FlagSet) parseArgs(args []string, fn parseFunc) (err error) {
0000000000000000000000000000000000000000;;		for len(args) > 0 {
0000000000000000000000000000000000000000;;			s := args[0]
0000000000000000000000000000000000000000;;			args = args[1:]
0000000000000000000000000000000000000000;;			if len(s) == 0 || s[0] != '-' || len(s) == 1 {
0000000000000000000000000000000000000000;;				if !f.interspersed {
0000000000000000000000000000000000000000;;					f.args = append(f.args, s)
0000000000000000000000000000000000000000;;					f.args = append(f.args, args...)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f.args = append(f.args, s)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if s[1] == '-' {
0000000000000000000000000000000000000000;;				if len(s) == 2 { // "--" terminates the flags
0000000000000000000000000000000000000000;;					f.argsLenAtDash = len(f.args)
0000000000000000000000000000000000000000;;					f.args = append(f.args, args...)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				args, err = f.parseLongArg(s, args, fn)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				args, err = f.parseShortArg(s, args, fn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parses flag definitions from the argument list, which should not
0000000000000000000000000000000000000000;;	// include the command name.  Must be called after all flags in the FlagSet
0000000000000000000000000000000000000000;;	// are defined and before flags are accessed by the program.
0000000000000000000000000000000000000000;;	// The return value will be ErrHelp if -help was set but not defined.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Parse(arguments []string) error {
0000000000000000000000000000000000000000;;		f.parsed = true
0000000000000000000000000000000000000000;;		f.args = make([]string, 0, len(arguments))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assign := func(flag *Flag, value, origArg string) error {
0000000000000000000000000000000000000000;;			return f.setFlag(flag, value, origArg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := f.parseArgs(arguments, assign)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			switch f.errorHandling {
0000000000000000000000000000000000000000;;			case ContinueOnError:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			case ExitOnError:
0000000000000000000000000000000000000000;;				os.Exit(2)
0000000000000000000000000000000000000000;;			case PanicOnError:
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parseFunc func(flag *Flag, value, origArg string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseAll parses flag definitions from the argument list, which should not
0000000000000000000000000000000000000000;;	// include the command name. The arguments for fn are flag and value. Must be
0000000000000000000000000000000000000000;;	// called after all flags in the FlagSet are defined and before flags are
0000000000000000000000000000000000000000;;	// accessed by the program. The return value will be ErrHelp if -help was set
0000000000000000000000000000000000000000;;	// but not defined.
0000000000000000000000000000000000000000;;	func (f *FlagSet) ParseAll(arguments []string, fn func(flag *Flag, value string) error) error {
0000000000000000000000000000000000000000;;		f.parsed = true
0000000000000000000000000000000000000000;;		f.args = make([]string, 0, len(arguments))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assign := func(flag *Flag, value, origArg string) error {
0000000000000000000000000000000000000000;;			return fn(flag, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := f.parseArgs(arguments, assign)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			switch f.errorHandling {
0000000000000000000000000000000000000000;;			case ContinueOnError:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			case ExitOnError:
0000000000000000000000000000000000000000;;				os.Exit(2)
0000000000000000000000000000000000000000;;			case PanicOnError:
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parsed reports whether f.Parse has been called.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Parsed() bool {
0000000000000000000000000000000000000000;;		return f.parsed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parses the command-line flags from os.Args[1:].  Must be called
0000000000000000000000000000000000000000;;	// after all flags are defined and before flags are accessed by the program.
0000000000000000000000000000000000000000;;	func Parse() {
0000000000000000000000000000000000000000;;		// Ignore errors; CommandLine is set for ExitOnError.
0000000000000000000000000000000000000000;;		CommandLine.Parse(os.Args[1:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseAll parses the command-line flags from os.Args[1:] and called fn for each.
0000000000000000000000000000000000000000;;	// The arguments for fn are flag and value. Must be called after all flags are
0000000000000000000000000000000000000000;;	// defined and before flags are accessed by the program.
0000000000000000000000000000000000000000;;	func ParseAll(fn func(flag *Flag, value string) error) {
0000000000000000000000000000000000000000;;		// Ignore errors; CommandLine is set for ExitOnError.
0000000000000000000000000000000000000000;;		CommandLine.ParseAll(os.Args[1:], fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetInterspersed sets whether to support interspersed option/non-option arguments.
0000000000000000000000000000000000000000;;	func SetInterspersed(interspersed bool) {
0000000000000000000000000000000000000000;;		CommandLine.SetInterspersed(interspersed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parsed returns true if the command-line flags have been parsed.
0000000000000000000000000000000000000000;;	func Parsed() bool {
0000000000000000000000000000000000000000;;		return CommandLine.Parsed()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CommandLine is the default set of command-line flags, parsed from os.Args.
0000000000000000000000000000000000000000;;	var CommandLine = NewFlagSet(os.Args[0], ExitOnError)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFlagSet returns a new, empty flag set with the specified name and
0000000000000000000000000000000000000000;;	// error handling property.
0000000000000000000000000000000000000000;;	func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet {
0000000000000000000000000000000000000000;;		f := &FlagSet{
0000000000000000000000000000000000000000;;			name:          name,
0000000000000000000000000000000000000000;;			errorHandling: errorHandling,
0000000000000000000000000000000000000000;;			argsLenAtDash: -1,
0000000000000000000000000000000000000000;;			interspersed:  true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetInterspersed sets whether to support interspersed option/non-option arguments.
0000000000000000000000000000000000000000;;	func (f *FlagSet) SetInterspersed(interspersed bool) {
0000000000000000000000000000000000000000;;		f.interspersed = interspersed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init sets the name and error handling property for a flag set.
0000000000000000000000000000000000000000;;	// By default, the zero FlagSet uses an empty name and the
0000000000000000000000000000000000000000;;	// ContinueOnError error handling policy.
0000000000000000000000000000000000000000;;	func (f *FlagSet) Init(name string, errorHandling ErrorHandling) {
0000000000000000000000000000000000000000;;		f.name = name
0000000000000000000000000000000000000000;;		f.errorHandling = errorHandling
0000000000000000000000000000000000000000;;		f.argsLenAtDash = -1
0000000000000000000000000000000000000000;;	}
