0000000000000000000000000000000000000000;;	[![Build Status](https://travis-ci.org/spf13/pflag.svg?branch=master)](https://travis-ci.org/spf13/pflag)
0000000000000000000000000000000000000000;;	[![Go Report Card](https://goreportcard.com/badge/github.com/spf13/pflag)](https://goreportcard.com/report/github.com/spf13/pflag)
0000000000000000000000000000000000000000;;	[![GoDoc](https://godoc.org/github.com/spf13/pflag?status.svg)](https://godoc.org/github.com/spf13/pflag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Description
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	pflag is a drop-in replacement for Go's flag package, implementing
0000000000000000000000000000000000000000;;	POSIX/GNU-style --flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	pflag is compatible with the [GNU extensions to the POSIX recommendations
0000000000000000000000000000000000000000;;	for command-line options][1]. For a more precise description, see the
0000000000000000000000000000000000000000;;	"Command-line flag syntax" section below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[1]: http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	pflag is available under the same style of BSD license as the Go language,
0000000000000000000000000000000000000000;;	which can be found in the LICENSE file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Installation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	pflag is available using the standard `go get` command.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Install by running:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    go get github.com/spf13/pflag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Run tests by running:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    go test github.com/spf13/pflag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	pflag is a drop-in replacement of Go's native flag package. If you import
0000000000000000000000000000000000000000;;	pflag under the name "flag" then all code should continue to function
0000000000000000000000000000000000000000;;	with no changes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	import flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There is one exception to this: if you directly instantiate the Flag struct
0000000000000000000000000000000000000000;;	there is one more field "Shorthand" that you will need to set.
0000000000000000000000000000000000000000;;	Most code never instantiates this struct directly, and instead uses
0000000000000000000000000000000000000000;;	functions such as String(), BoolVar(), and Var(), and is therefore
0000000000000000000000000000000000000000;;	unaffected.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Define flags using flag.String(), Bool(), Int(), etc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This declares an integer flag, -flagname, stored in the pointer ip, with type *int.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	var ip *int = flag.Int("flagname", 1234, "help message for flagname")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you like, you can bind the flag to a variable using the Var() functions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	var flagvar int
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;	    flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Or you can create custom flags that satisfy the Value interface (with
0000000000000000000000000000000000000000;;	pointer receivers) and couple them to flag parsing by
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	flag.Var(&flagVal, "name", "help message for flagname")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For such flags, the default value is just the initial value of the variable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After all flags are defined, call
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	flag.Parse()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	to parse the command line into the defined flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Flags may then be used directly. If you're using the flags themselves,
0000000000000000000000000000000000000000;;	they are all pointers; if you bind to variables, they're values.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	fmt.Println("ip has value ", *ip)
0000000000000000000000000000000000000000;;	fmt.Println("flagvar has value ", flagvar)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are helpers function to get values later if you have the FlagSet but
0000000000000000000000000000000000000000;;	it was difficult to keep up with all of the flag pointers in your code.
0000000000000000000000000000000000000000;;	If you have a pflag.FlagSet with a flag called 'flagname' of type int you
0000000000000000000000000000000000000000;;	can use GetInt() to get the int value. But notice that 'flagname' must exist
0000000000000000000000000000000000000000;;	and it must be an int. GetString("flagname") will fail.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	i, err := flagset.GetInt("flagname")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After parsing, the arguments after the flag are available as the
0000000000000000000000000000000000000000;;	slice flag.Args() or individually as flag.Arg(i).
0000000000000000000000000000000000000000;;	The arguments are indexed from 0 through flag.NArg()-1.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The pflag package also defines some new functions that are not in flag,
0000000000000000000000000000000000000000;;	that give one-letter shorthands for flags. You can use these by appending
0000000000000000000000000000000000000000;;	'P' to the name of any function that defines a flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	var ip = flag.IntP("flagname", "f", 1234, "help message")
0000000000000000000000000000000000000000;;	var flagvar bool
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		flag.BoolVarP(&flagvar, "boolname", "b", true, "help message")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	flag.VarP(&flagVal, "varname", "v", "help message")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Shorthand letters can be used with single dashes on the command line.
0000000000000000000000000000000000000000;;	Boolean shorthand flags can be combined with other shorthand flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default set of command-line flags is controlled by
0000000000000000000000000000000000000000;;	top-level functions.  The FlagSet type allows one to define
0000000000000000000000000000000000000000;;	independent sets of flags, such as to implement subcommands
0000000000000000000000000000000000000000;;	in a command-line interface. The methods of FlagSet are
0000000000000000000000000000000000000000;;	analogous to the top-level functions for the command-line
0000000000000000000000000000000000000000;;	flag set.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Setting no option default values for flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After you create a flag it is possible to set the pflag.NoOptDefVal for
0000000000000000000000000000000000000000;;	the given flag. Doing this changes the meaning of the flag slightly. If
0000000000000000000000000000000000000000;;	a flag has a NoOptDefVal and the flag is set on the command line without
0000000000000000000000000000000000000000;;	an option the flag will be set to the NoOptDefVal. For example given:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	var ip = flag.IntP("flagname", "f", 1234, "help message")
0000000000000000000000000000000000000000;;	flag.Lookup("flagname").NoOptDefVal = "4321"
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Would result in something like
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	| Parsed Arguments | Resulting Value |
0000000000000000000000000000000000000000;;	| -------------    | -------------   |
0000000000000000000000000000000000000000;;	| --flagname=1357  | ip=1357         |
0000000000000000000000000000000000000000;;	| --flagname       | ip=4321         |
0000000000000000000000000000000000000000;;	| [nothing]        | ip=1234         |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Command line flag syntax
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	--flag    // boolean flags, or flags with no option default values
0000000000000000000000000000000000000000;;	--flag x  // only on flags without a default value
0000000000000000000000000000000000000000;;	--flag=x
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unlike the flag package, a single dash before an option means something
0000000000000000000000000000000000000000;;	different than a double dash. Single dashes signify a series of shorthand
0000000000000000000000000000000000000000;;	letters for flags. All but the last shorthand letter must be boolean flags
0000000000000000000000000000000000000000;;	or a flag with a default value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	// boolean or flags where the 'no option default value' is set
0000000000000000000000000000000000000000;;	-f
0000000000000000000000000000000000000000;;	-f=true
0000000000000000000000000000000000000000;;	-abc
0000000000000000000000000000000000000000;;	but
0000000000000000000000000000000000000000;;	-b true is INVALID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// non-boolean and flags without a 'no option default value'
0000000000000000000000000000000000000000;;	-n 1234
0000000000000000000000000000000000000000;;	-n=1234
0000000000000000000000000000000000000000;;	-n1234
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mixed
0000000000000000000000000000000000000000;;	-abcs "hello"
0000000000000000000000000000000000000000;;	-absd="hello"
0000000000000000000000000000000000000000;;	-abcs1234
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Flag parsing stops after the terminator "--". Unlike the flag package,
0000000000000000000000000000000000000000;;	flags can be interspersed with arguments anywhere on the command line
0000000000000000000000000000000000000000;;	before this terminator.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Integer flags accept 1234, 0664, 0x1234 and may be negative.
0000000000000000000000000000000000000000;;	Boolean flags (in their long form) accept 1, 0, t, f, true, false,
0000000000000000000000000000000000000000;;	TRUE, FALSE, True, False.
0000000000000000000000000000000000000000;;	Duration flags accept any input valid for time.ParseDuration.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Mutating or "Normalizing" Flag names
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It is possible to set a custom flag name 'normalization function.' It allows flag names to be mutated both when created in the code and when used on the command line to some 'normalized' form. The 'normalized' form is used for comparison. Two examples of using the custom normalization func follow.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Example #1**: You want -, _, and . in flags to compare the same. aka --my-flag == --my_flag == --my.flag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	func wordSepNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName {
0000000000000000000000000000000000000000;;		from := []string{"-", "_"}
0000000000000000000000000000000000000000;;		to := "."
0000000000000000000000000000000000000000;;		for _, sep := range from {
0000000000000000000000000000000000000000;;			name = strings.Replace(name, sep, to, -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pflag.NormalizedName(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	myFlagSet.SetNormalizeFunc(wordSepNormalizeFunc)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Example #2**: You want to alias two flags. aka --old-flag-name == --new-flag-name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	``` go
0000000000000000000000000000000000000000;;	func aliasNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName {
0000000000000000000000000000000000000000;;		switch name {
0000000000000000000000000000000000000000;;		case "old-flag-name":
0000000000000000000000000000000000000000;;			name = "new-flag-name"
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pflag.NormalizedName(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	myFlagSet.SetNormalizeFunc(aliasNormalizeFunc)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Deprecating a flag or its shorthand
0000000000000000000000000000000000000000;;	It is possible to deprecate a flag, or just its shorthand. Deprecating a flag/shorthand hides it from help text and prints a usage message when the deprecated flag/shorthand is used.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Example #1**: You want to deprecate a flag named "badflag" as well as inform the users what flag they should use instead.
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// deprecate a flag by specifying its name and a usage message
0000000000000000000000000000000000000000;;	flags.MarkDeprecated("badflag", "please use --good-flag instead")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	This hides "badflag" from help text, and prints `Flag --badflag has been deprecated, please use --good-flag instead` when "badflag" is used.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Example #2**: You want to keep a flag name "noshorthandflag" but deprecate its shortname "n".
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// deprecate a flag shorthand by specifying its flag name and a usage message
0000000000000000000000000000000000000000;;	flags.MarkShorthandDeprecated("noshorthandflag", "please use --noshorthandflag only")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	This hides the shortname "n" from help text, and prints `Flag shorthand -n has been deprecated, please use --noshorthandflag only` when the shorthand "n" is used.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note that usage message is essential here, and it should not be empty.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Hidden flags
0000000000000000000000000000000000000000;;	It is possible to mark a flag as hidden, meaning it will still function as normal, however will not show up in usage/help text.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Example**: You have a flag named "secretFlag" that you need for internal use only and don't want it showing up in help text, or for its usage text to be available.
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// hide a flag by specifying its name
0000000000000000000000000000000000000000;;	flags.MarkHidden("secretFlag")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Supporting Go flags when using pflag
0000000000000000000000000000000000000000;;	In order to support flags defined using Go's `flag` package, they must be added to the `pflag` flagset. This is usually necessary
0000000000000000000000000000000000000000;;	to support flags defined by third-party dependencies (e.g. `golang/glog`).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Example**: You want to add the Go flags to the `CommandLine` flagset
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		goflag "flag"
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ip *int = flag.Int("flagname", 1234, "help message for flagname")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		flag.CommandLine.AddGoFlagSet(goflag.CommandLine)
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## More info
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can see the full reference documentation of the pflag package
0000000000000000000000000000000000000000;;	[at godoc.org][3], or through go's standard documentation system by
0000000000000000000000000000000000000000;;	running `godoc -http=:6060` and browsing to
0000000000000000000000000000000000000000;;	[http://localhost:6060/pkg/github.com/ogier/pflag][2] after
0000000000000000000000000000000000000000;;	installation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[2]: http://localhost:6060/pkg/github.com/ogier/pflag
0000000000000000000000000000000000000000;;	[3]: http://godoc.org/github.com/ogier/pflag
