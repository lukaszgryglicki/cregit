0000000000000000000000000000000000000000;;	package pflag
7a97d9072bfd4e553f690bdd2a67c515984455da;Godeps/_workspace/src/github.com/spf13/pflag/string_slice.go[Godeps/_workspace/src/github.com/spf13/pflag/string_slice.go][vendor/github.com/spf13/pflag/string_slice.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/csv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -- stringSlice Value
0000000000000000000000000000000000000000;;	type stringSliceValue struct {
0000000000000000000000000000000000000000;;		value   *[]string
0000000000000000000000000000000000000000;;		changed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStringSliceValue(val []string, p *[]string) *stringSliceValue {
0000000000000000000000000000000000000000;;		ssv := new(stringSliceValue)
0000000000000000000000000000000000000000;;		ssv.value = p
0000000000000000000000000000000000000000;;		*ssv.value = val
0000000000000000000000000000000000000000;;		return ssv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readAsCSV(val string) ([]string, error) {
0000000000000000000000000000000000000000;;		if val == "" {
0000000000000000000000000000000000000000;;			return []string{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stringReader := strings.NewReader(val)
0000000000000000000000000000000000000000;;		csvReader := csv.NewReader(stringReader)
0000000000000000000000000000000000000000;;		return csvReader.Read()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeAsCSV(vals []string) (string, error) {
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		w := csv.NewWriter(b)
0000000000000000000000000000000000000000;;		err := w.Write(vals)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Flush()
0000000000000000000000000000000000000000;;		return strings.TrimSuffix(b.String(), "\n"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stringSliceValue) Set(val string) error {
0000000000000000000000000000000000000000;;		v, err := readAsCSV(val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !s.changed {
0000000000000000000000000000000000000000;;			*s.value = v
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			*s.value = append(*s.value, v...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.changed = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stringSliceValue) Type() string {
0000000000000000000000000000000000000000;;		return "stringSlice"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stringSliceValue) String() string {
0000000000000000000000000000000000000000;;		str, _ := writeAsCSV(*s.value)
0000000000000000000000000000000000000000;;		return "[" + str + "]"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stringSliceConv(sval string) (interface{}, error) {
0000000000000000000000000000000000000000;;		sval = sval[1 : len(sval)-1]
0000000000000000000000000000000000000000;;		// An empty string would cause a slice with one (empty) string
0000000000000000000000000000000000000000;;		if len(sval) == 0 {
0000000000000000000000000000000000000000;;			return []string{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return readAsCSV(sval)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStringSlice return the []string value of a flag with the given name
0000000000000000000000000000000000000000;;	func (f *FlagSet) GetStringSlice(name string) ([]string, error) {
0000000000000000000000000000000000000000;;		val, err := f.getFlagType(name, "stringSlice", stringSliceConv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []string{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val.([]string), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSliceVar defines a string flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to a []string variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) StringSliceVar(p *[]string, name string, value []string, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newStringSliceValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSliceVarP is like StringSliceVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) StringSliceVarP(p *[]string, name, shorthand string, value []string, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newStringSliceValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSliceVar defines a string flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to a []string variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func StringSliceVar(p *[]string, name string, value []string, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newStringSliceValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSliceVarP is like StringSliceVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func StringSliceVarP(p *[]string, name, shorthand string, value []string, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newStringSliceValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSlice defines a string flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of a []string variable that stores the value of the flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) StringSlice(name string, value []string, usage string) *[]string {
0000000000000000000000000000000000000000;;		p := []string{}
0000000000000000000000000000000000000000;;		f.StringSliceVarP(&p, name, "", value, usage)
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSliceP is like StringSlice, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) StringSliceP(name, shorthand string, value []string, usage string) *[]string {
0000000000000000000000000000000000000000;;		p := []string{}
0000000000000000000000000000000000000000;;		f.StringSliceVarP(&p, name, shorthand, value, usage)
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSlice defines a string flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of a []string variable that stores the value of the flag.
0000000000000000000000000000000000000000;;	func StringSlice(name string, value []string, usage string) *[]string {
0000000000000000000000000000000000000000;;		return CommandLine.StringSliceP(name, "", value, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSliceP is like StringSlice, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func StringSliceP(name, shorthand string, value []string, usage string) *[]string {
0000000000000000000000000000000000000000;;		return CommandLine.StringSliceP(name, shorthand, value, usage)
0000000000000000000000000000000000000000;;	}
