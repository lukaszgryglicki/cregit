0000000000000000000000000000000000000000;;	package pflag
0e1ba9a8116c18bfa1975dc7ebd4f015c258b467;Godeps/_workspace/src/github.com/spf13/pflag/ip.go[Godeps/_workspace/src/github.com/spf13/pflag/ip.go][vendor/github.com/spf13/pflag/ip.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -- net.IP value
0000000000000000000000000000000000000000;;	type ipValue net.IP
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newIPValue(val net.IP, p *net.IP) *ipValue {
0000000000000000000000000000000000000000;;		*p = val
0000000000000000000000000000000000000000;;		return (*ipValue)(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *ipValue) String() string { return net.IP(*i).String() }
0000000000000000000000000000000000000000;;	func (i *ipValue) Set(s string) error {
0000000000000000000000000000000000000000;;		ip := net.ParseIP(strings.TrimSpace(s))
0000000000000000000000000000000000000000;;		if ip == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to parse IP: %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*i = ipValue(ip)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *ipValue) Type() string {
0000000000000000000000000000000000000000;;		return "ip"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ipConv(sval string) (interface{}, error) {
0000000000000000000000000000000000000000;;		ip := net.ParseIP(sval)
0000000000000000000000000000000000000000;;		if ip != nil {
0000000000000000000000000000000000000000;;			return ip, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("invalid string being converted to IP address: %s", sval)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetIP return the net.IP value of a flag with the given name
0000000000000000000000000000000000000000;;	func (f *FlagSet) GetIP(name string) (net.IP, error) {
0000000000000000000000000000000000000000;;		val, err := f.getFlagType(name, "ip", ipConv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val.(net.IP), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPVar defines an net.IP flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to an net.IP variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IPVar(p *net.IP, name string, value net.IP, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newIPValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPVarP is like IPVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IPVarP(p *net.IP, name, shorthand string, value net.IP, usage string) {
0000000000000000000000000000000000000000;;		f.VarP(newIPValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPVar defines an net.IP flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The argument p points to an net.IP variable in which to store the value of the flag.
0000000000000000000000000000000000000000;;	func IPVar(p *net.IP, name string, value net.IP, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newIPValue(value, p), name, "", usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPVarP is like IPVar, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func IPVarP(p *net.IP, name, shorthand string, value net.IP, usage string) {
0000000000000000000000000000000000000000;;		CommandLine.VarP(newIPValue(value, p), name, shorthand, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IP defines an net.IP flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of an net.IP variable that stores the value of the flag.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IP(name string, value net.IP, usage string) *net.IP {
0000000000000000000000000000000000000000;;		p := new(net.IP)
0000000000000000000000000000000000000000;;		f.IPVarP(p, name, "", value, usage)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPP is like IP, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func (f *FlagSet) IPP(name, shorthand string, value net.IP, usage string) *net.IP {
0000000000000000000000000000000000000000;;		p := new(net.IP)
0000000000000000000000000000000000000000;;		f.IPVarP(p, name, shorthand, value, usage)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IP defines an net.IP flag with specified name, default value, and usage string.
0000000000000000000000000000000000000000;;	// The return value is the address of an net.IP variable that stores the value of the flag.
0000000000000000000000000000000000000000;;	func IP(name string, value net.IP, usage string) *net.IP {
0000000000000000000000000000000000000000;;		return CommandLine.IPP(name, "", value, usage)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPP is like IP, but accepts a shorthand letter that can be used after a single dash.
0000000000000000000000000000000000000000;;	func IPP(name, shorthand string, value net.IP, usage string) *net.IP {
0000000000000000000000000000000000000000;;		return CommandLine.IPP(name, shorthand, value, usage)
0000000000000000000000000000000000000000;;	}
