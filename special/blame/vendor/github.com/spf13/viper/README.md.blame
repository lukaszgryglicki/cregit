0000000000000000000000000000000000000000;;	![viper logo](https://cloud.githubusercontent.com/assets/173412/10886745/998df88a-8151-11e5-9448-4736db51020d.png)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Go configuration with fangs!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Many Go projects are built using Viper including:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [Hugo](http://gohugo.io)
0000000000000000000000000000000000000000;;	* [EMC RexRay](http://rexray.readthedocs.org/en/stable/)
0000000000000000000000000000000000000000;;	* [Imgur's Incus](https://github.com/Imgur/incus)
0000000000000000000000000000000000000000;;	* [Nanobox](https://github.com/nanobox-io/nanobox)/[Nanopack](https://github.com/nanopack)
0000000000000000000000000000000000000000;;	* [Docker Notary](https://github.com/docker/Notary)
0000000000000000000000000000000000000000;;	* [BloomApi](https://www.bloomapi.com/)
0000000000000000000000000000000000000000;;	* [doctl(https://github.com/digitalocean/doctl)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 [![Build Status](https://travis-ci.org/spf13/viper.svg)](https://travis-ci.org/spf13/viper) [![Join the chat at https://gitter.im/spf13/viper](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/spf13/viper?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## What is Viper?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper is a complete configuration solution for go applications including 12 factor apps. It is designed
0000000000000000000000000000000000000000;;	to work within an application, and can handle all types of configuration needs
0000000000000000000000000000000000000000;;	and formats. It supports:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* setting defaults
0000000000000000000000000000000000000000;;	* reading from JSON, TOML, YAML, HCL, and Java properties config files
0000000000000000000000000000000000000000;;	* live watching and re-reading of config files (optional)
0000000000000000000000000000000000000000;;	* reading from environment variables
0000000000000000000000000000000000000000;;	* reading from remote config systems (etcd or Consul), and watching changes
0000000000000000000000000000000000000000;;	* reading from command line flags
0000000000000000000000000000000000000000;;	* reading from buffer
0000000000000000000000000000000000000000;;	* setting explicit values
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper can be thought of as a registry for all of your applications
0000000000000000000000000000000000000000;;	configuration needs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Why Viper?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When building a modern application, you don’t want to worry about
0000000000000000000000000000000000000000;;	configuration file formats; you want to focus on building awesome software.
0000000000000000000000000000000000000000;;	Viper is here to help with that.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper does the following for you:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. Find, load, and unmarshal a configuration file in JSON, TOML, YAML, HCL, or Java properties formats.
0000000000000000000000000000000000000000;;	2. Provide a mechanism to set default values for your different
0000000000000000000000000000000000000000;;	   configuration options.
0000000000000000000000000000000000000000;;	3. Provide a mechanism to set override values for options specified through
0000000000000000000000000000000000000000;;	   command line flags.
0000000000000000000000000000000000000000;;	4. Provide an alias system to easily rename parameters without breaking existing
0000000000000000000000000000000000000000;;	   code.
0000000000000000000000000000000000000000;;	5. Make it easy to tell the difference between when a user has provided a
0000000000000000000000000000000000000000;;	   command line or config file which is the same as the default.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper uses the following precedence order. Each item takes precedence over the
0000000000000000000000000000000000000000;;	item below it:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 * explicit call to Set
0000000000000000000000000000000000000000;;	 * flag
0000000000000000000000000000000000000000;;	 * env
0000000000000000000000000000000000000000;;	 * config
0000000000000000000000000000000000000000;;	 * key/value store
0000000000000000000000000000000000000000;;	 * default
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper configuration keys are case insensitive.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Putting Values into Viper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Establishing Defaults
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A good configuration system will support default values. A default value is not
0000000000000000000000000000000000000000;;	required for a key, but it's useful in the event that a key hasn’t been set via
0000000000000000000000000000000000000000;;	config file, environment variable, remote configuration or flag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Examples:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.SetDefault("ContentDir", "content")
0000000000000000000000000000000000000000;;	viper.SetDefault("LayoutDir", "layouts")
0000000000000000000000000000000000000000;;	viper.SetDefault("Taxonomies", map[string]string{"tag": "tags", "category": "categories"})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Reading Config Files
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper requires minimal configuration so it knows where to look for config files.
0000000000000000000000000000000000000000;;	Viper supports JSON, TOML, YAML, HCL, and Java Properties files. Viper can search multiple paths, but
0000000000000000000000000000000000000000;;	currently a single Viper instance only supports a single configuration file.
0000000000000000000000000000000000000000;;	Viper does not default to any configuration search paths leaving defaults decision
0000000000000000000000000000000000000000;;	to an application.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here is an example of how to use Viper to search for and read a configuration file.
0000000000000000000000000000000000000000;;	None of the specific paths are required, but at least one path should be provided
0000000000000000000000000000000000000000;;	where a configuration file is expected.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.SetConfigName("config") // name of config file (without extension)
0000000000000000000000000000000000000000;;	viper.AddConfigPath("/etc/appname/")   // path to look for the config file in
0000000000000000000000000000000000000000;;	viper.AddConfigPath("$HOME/.appname")  // call multiple times to add many search paths
0000000000000000000000000000000000000000;;	viper.AddConfigPath(".")               // optionally look for config in the working directory
0000000000000000000000000000000000000000;;	err := viper.ReadInConfig() // Find and read the config file
0000000000000000000000000000000000000000;;	if err != nil { // Handle errors reading the config file
0000000000000000000000000000000000000000;;		panic(fmt.Errorf("Fatal error config file: %s \n", err))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Watching and re-reading config files
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper supports the ability to have your application live read a config file while running.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Gone are the days of needing to restart a server to have a config take effect,
0000000000000000000000000000000000000000;;	viper powered applications can read an update to a config file while running and
0000000000000000000000000000000000000000;;	not miss a beat.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Simply tell the viper instance to watchConfig. 
0000000000000000000000000000000000000000;;	Optionally you can provide a function for Viper to run each time a change occurs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Make sure you add all of the configPaths prior to calling `WatchConfig()`**
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;			viper.WatchConfig()
0000000000000000000000000000000000000000;;			viper.OnConfigChange(func(e fsnotify.Event) {
0000000000000000000000000000000000000000;;				fmt.Println("Config file changed:", e.Name)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Reading Config from io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper predefines many configuration sources such as files, environment
0000000000000000000000000000000000000000;;	variables, flags, and remote K/V store, but you are not bound to them. You can
0000000000000000000000000000000000000000;;	also implement your own required configuration source and feed it to viper.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.SetConfigType("yaml") // or viper.SetConfigType("YAML")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// any approach to require this configuration into your program.
0000000000000000000000000000000000000000;;	var yamlExample = []byte(`
0000000000000000000000000000000000000000;;	Hacker: true
0000000000000000000000000000000000000000;;	name: steve
0000000000000000000000000000000000000000;;	hobbies:
0000000000000000000000000000000000000000;;	- skateboarding
0000000000000000000000000000000000000000;;	- snowboarding
0000000000000000000000000000000000000000;;	- go
0000000000000000000000000000000000000000;;	clothing:
0000000000000000000000000000000000000000;;	  jacket: leather
0000000000000000000000000000000000000000;;	  trousers: denim
0000000000000000000000000000000000000000;;	age: 35
0000000000000000000000000000000000000000;;	eyes : brown
0000000000000000000000000000000000000000;;	beard: true
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	viper.ReadConfig(bytes.NewBuffer(yamlExample))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	viper.Get("name") // this would be "steve"
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Setting Overrides
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	These could be from a command line flag, or from your own application logic.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.Set("Verbose", true)
0000000000000000000000000000000000000000;;	viper.Set("LogFile", LogFile)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Registering and Using Aliases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Aliases permit a single value to be referenced by multiple keys
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.RegisterAlias("loud", "Verbose")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	viper.Set("verbose", true) // same result as next line
0000000000000000000000000000000000000000;;	viper.Set("loud", true)   // same result as prior line
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	viper.GetBool("loud") // true
0000000000000000000000000000000000000000;;	viper.GetBool("verbose") // true
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Working with Environment Variables
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper has full support for environment variables. This enables 12 factor
0000000000000000000000000000000000000000;;	applications out of the box. There are four methods that exist to aid working
0000000000000000000000000000000000000000;;	with ENV:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 * `AutomaticEnv()`
0000000000000000000000000000000000000000;;	 * `BindEnv(string...) : error`
0000000000000000000000000000000000000000;;	 * `SetEnvPrefix(string)`
0000000000000000000000000000000000000000;;	 * `SetEnvReplacer(string...) *strings.Replacer`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	_When working with ENV variables, it’s important to recognize that Viper
0000000000000000000000000000000000000000;;	treats ENV variables as case sensitive._
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper provides a mechanism to try to ensure that ENV variables are unique. By
0000000000000000000000000000000000000000;;	using `SetEnvPrefix`, you can tell Viper to use add a prefix while reading from
0000000000000000000000000000000000000000;;	the environment variables. Both `BindEnv` and `AutomaticEnv` will use this
0000000000000000000000000000000000000000;;	prefix.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`BindEnv` takes one or two parameters. The first parameter is the key name, the
0000000000000000000000000000000000000000;;	second is the name of the environment variable. The name of the environment
0000000000000000000000000000000000000000;;	variable is case sensitive. If the ENV variable name is not provided, then
0000000000000000000000000000000000000000;;	Viper will automatically assume that the key name matches the ENV variable name,
0000000000000000000000000000000000000000;;	but the ENV variable is IN ALL CAPS. When you explicitly provide the ENV
0000000000000000000000000000000000000000;;	variable name, it **does not** automatically add the prefix.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	One important thing to recognize when working with ENV variables is that the
0000000000000000000000000000000000000000;;	value will be read each time it is accessed. Viper does not fix the value when
0000000000000000000000000000000000000000;;	the `BindEnv` is called.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`AutomaticEnv` is a powerful helper especially when combined with
0000000000000000000000000000000000000000;;	`SetEnvPrefix`. When called, Viper will check for an environment variable any
0000000000000000000000000000000000000000;;	time a `viper.Get` request is made. It will apply the following rules. It will
0000000000000000000000000000000000000000;;	check for a environment variable with a name matching the key uppercased and
0000000000000000000000000000000000000000;;	prefixed with the `EnvPrefix` if set.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`SetEnvReplacer` allows you to use a `strings.Replacer` object to rewrite Env
0000000000000000000000000000000000000000;;	keys to an extent. This is useful if you want to use `-` or something in your
0000000000000000000000000000000000000000;;	`Get()` calls, but want your environmental variables to use `_` delimiters. An
0000000000000000000000000000000000000000;;	example of using it can be found in `viper_test.go`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Env example
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	SetEnvPrefix("spf") // will be uppercased automatically
0000000000000000000000000000000000000000;;	BindEnv("id")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	os.Setenv("SPF_ID", "13") // typically done outside of the app
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	id := Get("id") // 13
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Working with Flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper has the ability to bind to flags. Specifically, Viper supports `Pflags`
0000000000000000000000000000000000000000;;	as used in the [Cobra](https://github.com/spf13/cobra) library.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Like `BindEnv`, the value is not set when the binding method is called, but when
0000000000000000000000000000000000000000;;	it is accessed. This means you can bind as early as you want, even in an
0000000000000000000000000000000000000000;;	`init()` function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `BindPFlag()` method provides this functionality.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	serverCmd.Flags().Int("port", 1138, "Port to run Application server on")
0000000000000000000000000000000000000000;;	viper.BindPFlag("port", serverCmd.Flags().Lookup("port"))
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The use of [pflag](https://github.com/spf13/pflag/) in Viper does not preclude
0000000000000000000000000000000000000000;;	the use of other packages that use the [flag](https://golang.org/pkg/flag/)
0000000000000000000000000000000000000000;;	package from the standard library. The pflag package can handle the flags
0000000000000000000000000000000000000000;;	defined for the flag package by importing these flags. This is accomplished
0000000000000000000000000000000000000000;;	by a calling a convenience function provided by the pflag package called
0000000000000000000000000000000000000000;;	AddGoFlagSet().
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		pflag.CommandLine.AddGoFlagSet(flag.CommandLine)
0000000000000000000000000000000000000000;;		pflag.Parse()
0000000000000000000000000000000000000000;;	    ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Flag interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper provides two Go interfaces to bind other flag systems if you don't use `Pflags`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`FlagValue` represents a single flag. This is a very simple example on how to implement this interface:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type myFlag struct {}
0000000000000000000000000000000000000000;;	func (f myFlag) IsChanged() { return false }
0000000000000000000000000000000000000000;;	func (f myFlag) Name() { return "my-flag-name" }
0000000000000000000000000000000000000000;;	func (f myFlag) ValueString() { return "my-flag-value" }
0000000000000000000000000000000000000000;;	func (f myFlag) ValueType() { return "string" }
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Once your flag implements this interface, you can simply tell Viper to bind it:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.BindFlagValue("my-flag-name", myFlag{})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`FlagValueSet` represents a group of flags. This is a very simple example on how to implement this interface:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type myFlagSet struct {
0000000000000000000000000000000000000000;;		flags []myFlag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f myFlagSet) VisitAll(fn func(FlagValue)) {
0000000000000000000000000000000000000000;;		for _, flag := range flags {
0000000000000000000000000000000000000000;;			fn(flag)	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Once your flag set implements this interface, you can simply tell Viper to bind it:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	fSet := myFlagSet{
0000000000000000000000000000000000000000;;		flags: []myFlag{myFlag{}, myFlag{}},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	viper.BindFlagValues("my-flags", fSet)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Remote Key/Value Store Support
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To enable remote support in Viper, do a blank import of the `viper/remote`
0000000000000000000000000000000000000000;;	package:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`import _ "github.com/spf13/viper/remote"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper will read a config string (as JSON, TOML, YAML or HCL) retrieved from a path
0000000000000000000000000000000000000000;;	in a Key/Value store such as etcd or Consul.  These values take precedence over
0000000000000000000000000000000000000000;;	default values, but are overridden by configuration values retrieved from disk,
0000000000000000000000000000000000000000;;	flags, or environment variables.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper uses [crypt](https://github.com/xordataexchange/crypt) to retrieve
0000000000000000000000000000000000000000;;	configuration from the K/V store, which means that you can store your
0000000000000000000000000000000000000000;;	configuration values encrypted and have them automatically decrypted if you have
0000000000000000000000000000000000000000;;	the correct gpg keyring.  Encryption is optional.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can use remote configuration in conjunction with local configuration, or
0000000000000000000000000000000000000000;;	independently of it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`crypt` has a command-line helper that you can use to put configurations in your
0000000000000000000000000000000000000000;;	K/V store. `crypt` defaults to etcd on http://127.0.0.1:4001.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	$ go get github.com/xordataexchange/crypt/bin/crypt
0000000000000000000000000000000000000000;;	$ crypt set -plaintext /config/hugo.json /Users/hugo/settings/config.json
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Confirm that your value was set:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	$ crypt get -plaintext /config/hugo.json
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the `crypt` documentation for examples of how to set encrypted values, or
0000000000000000000000000000000000000000;;	how to use Consul.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Remote Key/Value Store Example - Unencrypted
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.AddRemoteProvider("etcd", "http://127.0.0.1:4001","/config/hugo.json")
0000000000000000000000000000000000000000;;	viper.SetConfigType("json") // because there is no file extension in a stream of bytes, supported extensions are "json", "toml", "yaml", "yml", "properties", "props", "prop"
0000000000000000000000000000000000000000;;	err := viper.ReadRemoteConfig()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Remote Key/Value Store Example - Encrypted
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.AddSecureRemoteProvider("etcd","http://127.0.0.1:4001","/config/hugo.json","/etc/secrets/mykeyring.gpg")
0000000000000000000000000000000000000000;;	viper.SetConfigType("json") // because there is no file extension in a stream of bytes,  supported extensions are "json", "toml", "yaml", "yml", "properties", "props", "prop"
0000000000000000000000000000000000000000;;	err := viper.ReadRemoteConfig()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Watching Changes in etcd - Unencrypted
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// alternatively, you can create a new viper instance.
0000000000000000000000000000000000000000;;	var runtime_viper = viper.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	runtime_viper.AddRemoteProvider("etcd", "http://127.0.0.1:4001", "/config/hugo.yml")
0000000000000000000000000000000000000000;;	runtime_viper.SetConfigType("yaml") // because there is no file extension in a stream of bytes, supported extensions are "json", "toml", "yaml", "yml", "properties", "props", "prop"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// read from remote config the first time.
0000000000000000000000000000000000000000;;	err := runtime_viper.ReadRemoteConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshal config
0000000000000000000000000000000000000000;;	runtime_viper.Unmarshal(&runtime_conf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// open a goroutine to watch remote changes forever
0000000000000000000000000000000000000000;;	go func(){
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;		    time.Sleep(time.Second * 5) // delay after each request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		    // currently, only tested with etcd support
0000000000000000000000000000000000000000;;		    err := runtime_viper.WatchRemoteConfig()
0000000000000000000000000000000000000000;;		    if err != nil {
0000000000000000000000000000000000000000;;		        log.Errorf("unable to read remote config: %v", err)
0000000000000000000000000000000000000000;;		        continue
0000000000000000000000000000000000000000;;		    }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		    // unmarshal new config into our runtime config struct. you can also use channel
0000000000000000000000000000000000000000;;		    // to implement a signal to notify the system of the changes
0000000000000000000000000000000000000000;;		    runtime_viper.Unmarshal(&runtime_conf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Getting Values From Viper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In Viper, there are a few ways to get a value depending on the value's type.
0000000000000000000000000000000000000000;;	The following functions and methods exist:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 * `Get(key string) : interface{}`
0000000000000000000000000000000000000000;;	 * `GetBool(key string) : bool`
0000000000000000000000000000000000000000;;	 * `GetFloat64(key string) : float64`
0000000000000000000000000000000000000000;;	 * `GetInt(key string) : int`
0000000000000000000000000000000000000000;;	 * `GetString(key string) : string`
0000000000000000000000000000000000000000;;	 * `GetStringMap(key string) : map[string]interface{}`
0000000000000000000000000000000000000000;;	 * `GetStringMapString(key string) : map[string]string`
0000000000000000000000000000000000000000;;	 * `GetStringSlice(key string) : []string`
0000000000000000000000000000000000000000;;	 * `GetTime(key string) : time.Time`
0000000000000000000000000000000000000000;;	 * `GetDuration(key string) : time.Duration`
0000000000000000000000000000000000000000;;	 * `IsSet(key string) : bool`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	One important thing to recognize is that each Get function will return a zero
0000000000000000000000000000000000000000;;	value if it’s not found. To check if a given key exists, the `IsSet()` method
0000000000000000000000000000000000000000;;	has been provided.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	viper.GetString("logfile") // case-insensitive Setting & Getting
0000000000000000000000000000000000000000;;	if viper.GetBool("verbose") {
0000000000000000000000000000000000000000;;	    fmt.Println("verbose enabled")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	### Accessing nested keys
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The accessor methods also accept formatted paths to deeply nested keys. For
0000000000000000000000000000000000000000;;	example, if the following JSON file is loaded:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```json
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    "host": {
0000000000000000000000000000000000000000;;	        "address": "localhost",
0000000000000000000000000000000000000000;;	        "port": 5799
0000000000000000000000000000000000000000;;	    },
0000000000000000000000000000000000000000;;	    "datastore": {
0000000000000000000000000000000000000000;;	        "metric": {
0000000000000000000000000000000000000000;;	            "host": "127.0.0.1",
0000000000000000000000000000000000000000;;	            "port": 3099
0000000000000000000000000000000000000000;;	        },
0000000000000000000000000000000000000000;;	        "warehouse": {
0000000000000000000000000000000000000000;;	            "host": "198.0.0.1",
0000000000000000000000000000000000000000;;	            "port": 2112
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper can access a nested field by passing a `.` delimited path of keys:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	GetString("datastore.metric.host") // (returns "127.0.0.1")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This obeys the precedence rules established above; the search for the root key
0000000000000000000000000000000000000000;;	(in this example, `datastore`) will cascade through the remaining configuration
0000000000000000000000000000000000000000;;	registries until found. The search for the sub-keys (`metric` and `host`),
0000000000000000000000000000000000000000;;	however, will not.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example, if the `metric` key was not defined in the configuration loaded
0000000000000000000000000000000000000000;;	from file, but was defined in the defaults, Viper would return the zero value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	On the other hand, if the primary key was not defined, Viper would go through
0000000000000000000000000000000000000000;;	the remaining registries looking for it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Lastly, if there exists a key that matches the delimited key path, its value
0000000000000000000000000000000000000000;;	will be returned instead. E.g.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```json
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    "datastore.metric.host": "0.0.0.0",
0000000000000000000000000000000000000000;;	    "host": {
0000000000000000000000000000000000000000;;	        "address": "localhost",
0000000000000000000000000000000000000000;;	        "port": 5799
0000000000000000000000000000000000000000;;	    },
0000000000000000000000000000000000000000;;	    "datastore": {
0000000000000000000000000000000000000000;;	        "metric": {
0000000000000000000000000000000000000000;;	            "host": "127.0.0.1",
0000000000000000000000000000000000000000;;	            "port": 3099
0000000000000000000000000000000000000000;;	        },
0000000000000000000000000000000000000000;;	        "warehouse": {
0000000000000000000000000000000000000000;;	            "host": "198.0.0.1",
0000000000000000000000000000000000000000;;	            "port": 2112
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	GetString("datastore.metric.host") //returns "0.0.0.0"
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Extract sub-tree
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Extract sub-tree from Viper.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example, `viper` represents:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```json
0000000000000000000000000000000000000000;;	app:
0000000000000000000000000000000000000000;;	  cache1:
0000000000000000000000000000000000000000;;	    max-items: 100
0000000000000000000000000000000000000000;;	    item-size: 64
0000000000000000000000000000000000000000;;	  cache2:
0000000000000000000000000000000000000000;;	    max-items: 200
0000000000000000000000000000000000000000;;	    item-size: 80
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After executing:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	subv := viper.Sub("app.cache1")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`subv` represents:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```json
0000000000000000000000000000000000000000;;	max-items: 100
0000000000000000000000000000000000000000;;	item-size: 64
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Suppose we have:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func NewCache(cfg *Viper) *Cache {...}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	which creates a cache based on config information formatted as `subv`.
0000000000000000000000000000000000000000;;	Now it's easy to create these 2 caches separately as:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg1 := viper.Sub("app.cache1")
0000000000000000000000000000000000000000;;	cache1 := NewCache(cfg1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	cfg2 := viper.Sub("app.cache2")
0000000000000000000000000000000000000000;;	cache2 := NewCache(cfg2)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Unmarshaling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You also have the option of Unmarshaling all or a specific value to a struct, map,
0000000000000000000000000000000000000000;;	etc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are two methods to do this:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 * `Unmarshal(rawVal interface{}) : error`
0000000000000000000000000000000000000000;;	 * `UnmarshalKey(key string, rawVal interface{}) : error`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type config struct {
0000000000000000000000000000000000000000;;		Port int
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		PathMap string `mapstructure:"path_map"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var C config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	err := Unmarshal(&C)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		t.Fatalf("unable to decode into struct, %v", err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Viper or Vipers?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Viper comes ready to use out of the box. There is no configuration or
0000000000000000000000000000000000000000;;	initialization needed to begin using Viper. Since most applications will want
0000000000000000000000000000000000000000;;	to use a single central repository for their configuration, the viper package
0000000000000000000000000000000000000000;;	provides this. It is similar to a singleton.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In all of the examples above, they demonstrate using viper in it's singleton
0000000000000000000000000000000000000000;;	style approach.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Working with multiple vipers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also create many different vipers for use in your application. Each will
0000000000000000000000000000000000000000;;	have it’s own unique set of configurations and values. Each can read from a
0000000000000000000000000000000000000000;;	different config file, key value store, etc. All of the functions that viper
0000000000000000000000000000000000000000;;	package supports are mirrored as methods on a viper.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	x := viper.New()
0000000000000000000000000000000000000000;;	y := viper.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	x.SetDefault("ContentDir", "content")
0000000000000000000000000000000000000000;;	y.SetDefault("ContentDir", "foobar")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//...
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When working with multiple vipers, it is up to the user to keep track of the
0000000000000000000000000000000000000000;;	different vipers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Q & A
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Q: Why not INI files?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A: Ini files are pretty awful. There’s no standard format, and they are hard to
0000000000000000000000000000000000000000;;	validate. Viper is designed to work with JSON, TOML or YAML files. If someone
0000000000000000000000000000000000000000;;	really wants to add this feature, I’d be happy to merge it. It’s easy to specify
0000000000000000000000000000000000000000;;	which formats your application will permit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Q: Why is it called “Viper”?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A: Viper is designed to be a [companion](http://en.wikipedia.org/wiki/Viper_(G.I._Joe))
0000000000000000000000000000000000000000;;	to [Cobra](https://github.com/spf13/cobra). While both can operate completely
0000000000000000000000000000000000000000;;	independently, together they make a powerful pair to handle much of your
0000000000000000000000000000000000000000;;	application foundation needs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Q: Why is it called “Cobra”?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A: Is there a better name for a [commander](http://en.wikipedia.org/wiki/Cobra_Commander)?
