0000000000000000000000000000000000000000;;	// Copyright Â© 2014 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use of this source code is governed by an MIT-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// Viper is a application configuration system.
0000000000000000000000000000000000000000;;	// It believes that applications can be configured a variety of ways
0000000000000000000000000000000000000000;;	// via flags, ENVIRONMENT variables, configuration files retrieved
0000000000000000000000000000000000000000;;	// from the file system, or a remote key/value store.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Each item takes precedence over the item below it:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// overrides
0000000000000000000000000000000000000000;;	// flag
0000000000000000000000000000000000000000;;	// env
0000000000000000000000000000000000000000;;	// config
0000000000000000000000000000000000000000;;	// key/value store
0000000000000000000000000000000000000000;;	// default
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package viper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/fsnotify/fsnotify"
0000000000000000000000000000000000000000;;		"github.com/mitchellh/mapstructure"
0000000000000000000000000000000000000000;;		"github.com/spf13/afero"
0000000000000000000000000000000000000000;;		"github.com/spf13/cast"
0000000000000000000000000000000000000000;;		jww "github.com/spf13/jwalterweatherman"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var v *Viper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		v = New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type remoteConfigFactory interface {
0000000000000000000000000000000000000000;;		Get(rp RemoteProvider) (io.Reader, error)
0000000000000000000000000000000000000000;;		Watch(rp RemoteProvider) (io.Reader, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteConfig is optional, see the remote package
0000000000000000000000000000000000000000;;	var RemoteConfig remoteConfigFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Denotes encountering an unsupported
0000000000000000000000000000000000000000;;	// configuration filetype.
0000000000000000000000000000000000000000;;	type UnsupportedConfigError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the formatted configuration error.
0000000000000000000000000000000000000000;;	func (str UnsupportedConfigError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Unsupported Config Type %q", string(str))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Denotes encountering an unsupported remote
0000000000000000000000000000000000000000;;	// provider. Currently only etcd and Consul are
0000000000000000000000000000000000000000;;	// supported.
0000000000000000000000000000000000000000;;	type UnsupportedRemoteProviderError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the formatted remote provider error.
0000000000000000000000000000000000000000;;	func (str UnsupportedRemoteProviderError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Unsupported Remote Provider Type %q", string(str))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Denotes encountering an error while trying to
0000000000000000000000000000000000000000;;	// pull the configuration from the remote provider.
0000000000000000000000000000000000000000;;	type RemoteConfigError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the formatted remote provider error
0000000000000000000000000000000000000000;;	func (rce RemoteConfigError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Remote Configurations Error: %s", string(rce))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Denotes failing to find configuration file.
0000000000000000000000000000000000000000;;	type ConfigFileNotFoundError struct {
0000000000000000000000000000000000000000;;		name, locations string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the formatted configuration error.
0000000000000000000000000000000000000000;;	func (fnfe ConfigFileNotFoundError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Config File %q Not Found in %q", fnfe.name, fnfe.locations)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Viper is a prioritized configuration registry. It
0000000000000000000000000000000000000000;;	// maintains a set of configuration sources, fetches
0000000000000000000000000000000000000000;;	// values to populate those, and provides them according
0000000000000000000000000000000000000000;;	// to the source's priority.
0000000000000000000000000000000000000000;;	// The priority of the sources is the following:
0000000000000000000000000000000000000000;;	// 1. overrides
0000000000000000000000000000000000000000;;	// 2. flags
0000000000000000000000000000000000000000;;	// 3. env. variables
0000000000000000000000000000000000000000;;	// 4. config file
0000000000000000000000000000000000000000;;	// 5. key/value store
0000000000000000000000000000000000000000;;	// 6. defaults
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, if values from the following sources were loaded:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  Defaults : {
0000000000000000000000000000000000000000;;	//  	"secret": "",
0000000000000000000000000000000000000000;;	//  	"user": "default",
0000000000000000000000000000000000000000;;	// 	"endpoint": "https://localhost"
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//  Config : {
0000000000000000000000000000000000000000;;	//  	"user": "root"
0000000000000000000000000000000000000000;;	//	"secret": "defaultsecret"
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//  Env : {
0000000000000000000000000000000000000000;;	//  	"secret": "somesecretkey"
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The resulting config will have the following values:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	{
0000000000000000000000000000000000000000;;	//		"secret": "somesecretkey",
0000000000000000000000000000000000000000;;	//		"user": "root",
0000000000000000000000000000000000000000;;	//		"endpoint": "https://localhost"
0000000000000000000000000000000000000000;;	//	}
0000000000000000000000000000000000000000;;	type Viper struct {
0000000000000000000000000000000000000000;;		// Delimiter that separates a list of keys
0000000000000000000000000000000000000000;;		// used to access a nested value in one go
0000000000000000000000000000000000000000;;		keyDelim string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A set of paths to look for the config file in
0000000000000000000000000000000000000000;;		configPaths []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The filesystem to read config from.
0000000000000000000000000000000000000000;;		fs afero.Fs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A set of remote providers to search for the configuration
0000000000000000000000000000000000000000;;		remoteProviders []*defaultRemoteProvider
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of file to look for inside the path
0000000000000000000000000000000000000000;;		configName string
0000000000000000000000000000000000000000;;		configFile string
0000000000000000000000000000000000000000;;		configType string
0000000000000000000000000000000000000000;;		envPrefix  string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		automaticEnvApplied bool
0000000000000000000000000000000000000000;;		envKeyReplacer      *strings.Replacer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config         map[string]interface{}
0000000000000000000000000000000000000000;;		override       map[string]interface{}
0000000000000000000000000000000000000000;;		defaults       map[string]interface{}
0000000000000000000000000000000000000000;;		kvstore        map[string]interface{}
0000000000000000000000000000000000000000;;		pflags         map[string]FlagValue
0000000000000000000000000000000000000000;;		env            map[string]string
0000000000000000000000000000000000000000;;		aliases        map[string]string
0000000000000000000000000000000000000000;;		typeByDefValue bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		onConfigChange func(fsnotify.Event)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns an initialized Viper instance.
0000000000000000000000000000000000000000;;	func New() *Viper {
0000000000000000000000000000000000000000;;		v := new(Viper)
0000000000000000000000000000000000000000;;		v.keyDelim = "."
0000000000000000000000000000000000000000;;		v.configName = "config"
0000000000000000000000000000000000000000;;		v.fs = afero.NewOsFs()
0000000000000000000000000000000000000000;;		v.config = make(map[string]interface{})
0000000000000000000000000000000000000000;;		v.override = make(map[string]interface{})
0000000000000000000000000000000000000000;;		v.defaults = make(map[string]interface{})
0000000000000000000000000000000000000000;;		v.kvstore = make(map[string]interface{})
0000000000000000000000000000000000000000;;		v.pflags = make(map[string]FlagValue)
0000000000000000000000000000000000000000;;		v.env = make(map[string]string)
0000000000000000000000000000000000000000;;		v.aliases = make(map[string]string)
0000000000000000000000000000000000000000;;		v.typeByDefValue = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Intended for testing, will reset all to default settings.
0000000000000000000000000000000000000000;;	// In the public interface for the viper package so applications
0000000000000000000000000000000000000000;;	// can use it in their testing as well.
0000000000000000000000000000000000000000;;	func Reset() {
0000000000000000000000000000000000000000;;		v = New()
0000000000000000000000000000000000000000;;		SupportedExts = []string{"json", "toml", "yaml", "yml", "hcl"}
0000000000000000000000000000000000000000;;		SupportedRemoteProviders = []string{"etcd", "consul"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultRemoteProvider struct {
0000000000000000000000000000000000000000;;		provider      string
0000000000000000000000000000000000000000;;		endpoint      string
0000000000000000000000000000000000000000;;		path          string
0000000000000000000000000000000000000000;;		secretKeyring string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rp defaultRemoteProvider) Provider() string {
0000000000000000000000000000000000000000;;		return rp.provider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rp defaultRemoteProvider) Endpoint() string {
0000000000000000000000000000000000000000;;		return rp.endpoint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rp defaultRemoteProvider) Path() string {
0000000000000000000000000000000000000000;;		return rp.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rp defaultRemoteProvider) SecretKeyring() string {
0000000000000000000000000000000000000000;;		return rp.secretKeyring
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteProvider stores the configuration necessary
0000000000000000000000000000000000000000;;	// to connect to a remote key/value store.
0000000000000000000000000000000000000000;;	// Optional secretKeyring to unencrypt encrypted values
0000000000000000000000000000000000000000;;	// can be provided.
0000000000000000000000000000000000000000;;	type RemoteProvider interface {
0000000000000000000000000000000000000000;;		Provider() string
0000000000000000000000000000000000000000;;		Endpoint() string
0000000000000000000000000000000000000000;;		Path() string
0000000000000000000000000000000000000000;;		SecretKeyring() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Universally supported extensions.
0000000000000000000000000000000000000000;;	var SupportedExts []string = []string{"json", "toml", "yaml", "yml", "properties", "props", "prop", "hcl"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Universally supported remote providers.
0000000000000000000000000000000000000000;;	var SupportedRemoteProviders []string = []string{"etcd", "consul"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func OnConfigChange(run func(in fsnotify.Event)) { v.OnConfigChange(run) }
0000000000000000000000000000000000000000;;	func (v *Viper) OnConfigChange(run func(in fsnotify.Event)) {
0000000000000000000000000000000000000000;;		v.onConfigChange = run
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WatchConfig() { v.WatchConfig() }
0000000000000000000000000000000000000000;;	func (v *Viper) WatchConfig() {
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			watcher, err := fsnotify.NewWatcher()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer watcher.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we have to watch the entire directory to pick up renames/atomic saves in a cross-platform way
0000000000000000000000000000000000000000;;			configFile := filepath.Clean(v.getConfigFile())
0000000000000000000000000000000000000000;;			configDir, _ := filepath.Split(configFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			done := make(chan bool)
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case event := <-watcher.Events:
0000000000000000000000000000000000000000;;						// we only care about the config file
0000000000000000000000000000000000000000;;						if filepath.Clean(event.Name) == configFile {
0000000000000000000000000000000000000000;;							if event.Op&fsnotify.Write == fsnotify.Write || event.Op&fsnotify.Create == fsnotify.Create {
0000000000000000000000000000000000000000;;								err := v.ReadInConfig()
0000000000000000000000000000000000000000;;								if err != nil {
0000000000000000000000000000000000000000;;									log.Println("error:", err)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								v.onConfigChange(event)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case err := <-watcher.Errors:
0000000000000000000000000000000000000000;;						log.Println("error:", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			watcher.Add(configDir)
0000000000000000000000000000000000000000;;			<-done
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Explicitly define the path, name and extension of the config file
0000000000000000000000000000000000000000;;	// Viper will use this and not check any of the config paths
0000000000000000000000000000000000000000;;	func SetConfigFile(in string) { v.SetConfigFile(in) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetConfigFile(in string) {
0000000000000000000000000000000000000000;;		if in != "" {
0000000000000000000000000000000000000000;;			v.configFile = in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Define a prefix that ENVIRONMENT variables will use.
0000000000000000000000000000000000000000;;	// E.g. if your prefix is "spf", the env registry
0000000000000000000000000000000000000000;;	// will look for env. variables that start with "SPF_"
0000000000000000000000000000000000000000;;	func SetEnvPrefix(in string) { v.SetEnvPrefix(in) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetEnvPrefix(in string) {
0000000000000000000000000000000000000000;;		if in != "" {
0000000000000000000000000000000000000000;;			v.envPrefix = in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) mergeWithEnvPrefix(in string) string {
0000000000000000000000000000000000000000;;		if v.envPrefix != "" {
0000000000000000000000000000000000000000;;			return strings.ToUpper(v.envPrefix + "_" + in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.ToUpper(in)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: should getEnv logic be moved into find(). Can generalize the use of
0000000000000000000000000000000000000000;;	// rewriting keys many things, Ex: Get('someKey') -> some_key
0000000000000000000000000000000000000000;;	// (cammel case to snake case for JSON keys perhaps)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getEnv s a wrapper around os.Getenv which replaces characters in the original
0000000000000000000000000000000000000000;;	// key. This allows env vars which have different keys then the config object
0000000000000000000000000000000000000000;;	// keys
0000000000000000000000000000000000000000;;	func (v *Viper) getEnv(key string) string {
0000000000000000000000000000000000000000;;		if v.envKeyReplacer != nil {
0000000000000000000000000000000000000000;;			key = v.envKeyReplacer.Replace(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.Getenv(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the file used to populate the config registry
0000000000000000000000000000000000000000;;	func ConfigFileUsed() string            { return v.ConfigFileUsed() }
0000000000000000000000000000000000000000;;	func (v *Viper) ConfigFileUsed() string { return v.configFile }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a path for Viper to search for the config file in.
0000000000000000000000000000000000000000;;	// Can be called multiple times to define multiple search paths.
0000000000000000000000000000000000000000;;	func AddConfigPath(in string) { v.AddConfigPath(in) }
0000000000000000000000000000000000000000;;	func (v *Viper) AddConfigPath(in string) {
0000000000000000000000000000000000000000;;		if in != "" {
0000000000000000000000000000000000000000;;			absin := absPathify(in)
0000000000000000000000000000000000000000;;			jww.INFO.Println("adding", absin, "to paths to search")
0000000000000000000000000000000000000000;;			if !stringInSlice(absin, v.configPaths) {
0000000000000000000000000000000000000000;;				v.configPaths = append(v.configPaths, absin)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddRemoteProvider adds a remote configuration source.
0000000000000000000000000000000000000000;;	// Remote Providers are searched in the order they are added.
0000000000000000000000000000000000000000;;	// provider is a string value, "etcd" or "consul" are currently supported.
0000000000000000000000000000000000000000;;	// endpoint is the url.  etcd requires http://ip:port  consul requires ip:port
0000000000000000000000000000000000000000;;	// path is the path in the k/v store to retrieve configuration
0000000000000000000000000000000000000000;;	// To retrieve a config file called myapp.json from /configs/myapp.json
0000000000000000000000000000000000000000;;	// you should set path to /configs and set config name (SetConfigName()) to
0000000000000000000000000000000000000000;;	// "myapp"
0000000000000000000000000000000000000000;;	func AddRemoteProvider(provider, endpoint, path string) error {
0000000000000000000000000000000000000000;;		return v.AddRemoteProvider(provider, endpoint, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (v *Viper) AddRemoteProvider(provider, endpoint, path string) error {
0000000000000000000000000000000000000000;;		if !stringInSlice(provider, SupportedRemoteProviders) {
0000000000000000000000000000000000000000;;			return UnsupportedRemoteProviderError(provider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if provider != "" && endpoint != "" {
0000000000000000000000000000000000000000;;			jww.INFO.Printf("adding %s:%s to remote provider list", provider, endpoint)
0000000000000000000000000000000000000000;;			rp := &defaultRemoteProvider{
0000000000000000000000000000000000000000;;				endpoint: endpoint,
0000000000000000000000000000000000000000;;				provider: provider,
0000000000000000000000000000000000000000;;				path:     path,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !v.providerPathExists(rp) {
0000000000000000000000000000000000000000;;				v.remoteProviders = append(v.remoteProviders, rp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddSecureRemoteProvider adds a remote configuration source.
0000000000000000000000000000000000000000;;	// Secure Remote Providers are searched in the order they are added.
0000000000000000000000000000000000000000;;	// provider is a string value, "etcd" or "consul" are currently supported.
0000000000000000000000000000000000000000;;	// endpoint is the url.  etcd requires http://ip:port  consul requires ip:port
0000000000000000000000000000000000000000;;	// secretkeyring is the filepath to your openpgp secret keyring.  e.g. /etc/secrets/myring.gpg
0000000000000000000000000000000000000000;;	// path is the path in the k/v store to retrieve configuration
0000000000000000000000000000000000000000;;	// To retrieve a config file called myapp.json from /configs/myapp.json
0000000000000000000000000000000000000000;;	// you should set path to /configs and set config name (SetConfigName()) to
0000000000000000000000000000000000000000;;	// "myapp"
0000000000000000000000000000000000000000;;	// Secure Remote Providers are implemented with github.com/xordataexchange/crypt
0000000000000000000000000000000000000000;;	func AddSecureRemoteProvider(provider, endpoint, path, secretkeyring string) error {
0000000000000000000000000000000000000000;;		return v.AddSecureRemoteProvider(provider, endpoint, path, secretkeyring)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) AddSecureRemoteProvider(provider, endpoint, path, secretkeyring string) error {
0000000000000000000000000000000000000000;;		if !stringInSlice(provider, SupportedRemoteProviders) {
0000000000000000000000000000000000000000;;			return UnsupportedRemoteProviderError(provider)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if provider != "" && endpoint != "" {
0000000000000000000000000000000000000000;;			jww.INFO.Printf("adding %s:%s to remote provider list", provider, endpoint)
0000000000000000000000000000000000000000;;			rp := &defaultRemoteProvider{
0000000000000000000000000000000000000000;;				endpoint:      endpoint,
0000000000000000000000000000000000000000;;				provider:      provider,
0000000000000000000000000000000000000000;;				path:          path,
0000000000000000000000000000000000000000;;				secretKeyring: secretkeyring,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !v.providerPathExists(rp) {
0000000000000000000000000000000000000000;;				v.remoteProviders = append(v.remoteProviders, rp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) providerPathExists(p *defaultRemoteProvider) bool {
0000000000000000000000000000000000000000;;		for _, y := range v.remoteProviders {
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(y, p) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) searchMap(source map[string]interface{}, path []string) interface{} {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			return source
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		var next interface{}
0000000000000000000000000000000000000000;;		for k, v := range source {
0000000000000000000000000000000000000000;;			if strings.ToLower(k) == strings.ToLower(path[0]) {
0000000000000000000000000000000000000000;;				ok = true
0000000000000000000000000000000000000000;;				next = v
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			switch next.(type) {
0000000000000000000000000000000000000000;;			case map[interface{}]interface{}:
0000000000000000000000000000000000000000;;				return v.searchMap(cast.ToStringMap(next), path[1:])
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				// Type assertion is safe here since it is only reached
0000000000000000000000000000000000000000;;				// if the type of `next` is the same as the type being asserted
0000000000000000000000000000000000000000;;				return v.searchMap(next.(map[string]interface{}), path[1:])
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTypeByDefaultValue enables or disables the inference of a key value's
0000000000000000000000000000000000000000;;	// type when the Get function is used based upon a key's default value as
0000000000000000000000000000000000000000;;	// opposed to the value returned based on the normal fetch logic.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, if a key has a default value of []string{} and the same key
0000000000000000000000000000000000000000;;	// is set via an environment variable to "a b c", a call to the Get function
0000000000000000000000000000000000000000;;	// would return a string slice for the key if the key's type is inferred by
0000000000000000000000000000000000000000;;	// the default value and the Get function would return:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   []string {"a", "b", "c"}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Otherwise the Get function would return:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   "a b c"
0000000000000000000000000000000000000000;;	func SetTypeByDefaultValue(enable bool) { v.SetTypeByDefaultValue(enable) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetTypeByDefaultValue(enable bool) {
0000000000000000000000000000000000000000;;		v.typeByDefValue = enable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetViper gets the global Viper instance.
0000000000000000000000000000000000000000;;	func GetViper() *Viper {
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Viper is essentially repository for configurations
0000000000000000000000000000000000000000;;	// Get can retrieve any value given the key to use
0000000000000000000000000000000000000000;;	// Get has the behavior of returning the value associated with the first
0000000000000000000000000000000000000000;;	// place from where it is set. Viper will check in the following order:
0000000000000000000000000000000000000000;;	// override, flag, env, config file, key/value store, default
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Get returns an interface. For a specific value use one of the Get____ methods.
0000000000000000000000000000000000000000;;	func Get(key string) interface{} { return v.Get(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) Get(key string) interface{} {
0000000000000000000000000000000000000000;;		path := strings.Split(key, v.keyDelim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lcaseKey := strings.ToLower(key)
0000000000000000000000000000000000000000;;		val := v.find(lcaseKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val == nil {
0000000000000000000000000000000000000000;;			source := v.find(strings.ToLower(path[0]))
0000000000000000000000000000000000000000;;			if source != nil {
0000000000000000000000000000000000000000;;				if reflect.TypeOf(source).Kind() == reflect.Map {
0000000000000000000000000000000000000000;;					val = v.searchMap(cast.ToStringMap(source), path[1:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if no other value is returned and a flag does exist for the value,
0000000000000000000000000000000000000000;;		// get the flag's value even if the flag's value has not changed
0000000000000000000000000000000000000000;;		if val == nil {
0000000000000000000000000000000000000000;;			if flag, exists := v.pflags[lcaseKey]; exists {
0000000000000000000000000000000000000000;;				jww.TRACE.Println(key, "get pflag default", val)
0000000000000000000000000000000000000000;;				switch flag.ValueType() {
0000000000000000000000000000000000000000;;				case "int", "int8", "int16", "int32", "int64":
0000000000000000000000000000000000000000;;					val = cast.ToInt(flag.ValueString())
0000000000000000000000000000000000000000;;				case "bool":
0000000000000000000000000000000000000000;;					val = cast.ToBool(flag.ValueString())
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					val = flag.ValueString()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var valType interface{}
0000000000000000000000000000000000000000;;		if !v.typeByDefValue {
0000000000000000000000000000000000000000;;			valType = val
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			defVal, defExists := v.defaults[lcaseKey]
0000000000000000000000000000000000000000;;			if defExists {
0000000000000000000000000000000000000000;;				valType = defVal
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				valType = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch valType.(type) {
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			return cast.ToBool(val)
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return cast.ToString(val)
0000000000000000000000000000000000000000;;		case int64, int32, int16, int8, int:
0000000000000000000000000000000000000000;;			return cast.ToInt(val)
0000000000000000000000000000000000000000;;		case float64, float32:
0000000000000000000000000000000000000000;;			return cast.ToFloat64(val)
0000000000000000000000000000000000000000;;		case time.Time:
0000000000000000000000000000000000000000;;			return cast.ToTime(val)
0000000000000000000000000000000000000000;;		case time.Duration:
0000000000000000000000000000000000000000;;			return cast.ToDuration(val)
0000000000000000000000000000000000000000;;		case []string:
0000000000000000000000000000000000000000;;			return cast.ToStringSlice(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns new Viper instance representing a sub tree of this instance
0000000000000000000000000000000000000000;;	func Sub(key string) *Viper { return v.Sub(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) Sub(key string) *Viper {
0000000000000000000000000000000000000000;;		subv := New()
0000000000000000000000000000000000000000;;		data := v.Get(key)
0000000000000000000000000000000000000000;;		if reflect.TypeOf(data).Kind() == reflect.Map {
0000000000000000000000000000000000000000;;			subv.config = cast.ToStringMap(data)
0000000000000000000000000000000000000000;;			return subv
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a string
0000000000000000000000000000000000000000;;	func GetString(key string) string { return v.GetString(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetString(key string) string {
0000000000000000000000000000000000000000;;		return cast.ToString(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a boolean
0000000000000000000000000000000000000000;;	func GetBool(key string) bool { return v.GetBool(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetBool(key string) bool {
0000000000000000000000000000000000000000;;		return cast.ToBool(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as an integer
0000000000000000000000000000000000000000;;	func GetInt(key string) int { return v.GetInt(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetInt(key string) int {
0000000000000000000000000000000000000000;;		return cast.ToInt(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as an integer
0000000000000000000000000000000000000000;;	func GetInt64(key string) int64 { return v.GetInt64(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetInt64(key string) int64 {
0000000000000000000000000000000000000000;;		return cast.ToInt64(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a float64
0000000000000000000000000000000000000000;;	func GetFloat64(key string) float64 { return v.GetFloat64(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetFloat64(key string) float64 {
0000000000000000000000000000000000000000;;		return cast.ToFloat64(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as time
0000000000000000000000000000000000000000;;	func GetTime(key string) time.Time { return v.GetTime(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetTime(key string) time.Time {
0000000000000000000000000000000000000000;;		return cast.ToTime(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a duration
0000000000000000000000000000000000000000;;	func GetDuration(key string) time.Duration { return v.GetDuration(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetDuration(key string) time.Duration {
0000000000000000000000000000000000000000;;		return cast.ToDuration(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a slice of strings
0000000000000000000000000000000000000000;;	func GetStringSlice(key string) []string { return v.GetStringSlice(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetStringSlice(key string) []string {
0000000000000000000000000000000000000000;;		return cast.ToStringSlice(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a map of interfaces
0000000000000000000000000000000000000000;;	func GetStringMap(key string) map[string]interface{} { return v.GetStringMap(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetStringMap(key string) map[string]interface{} {
0000000000000000000000000000000000000000;;		return cast.ToStringMap(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a map of strings
0000000000000000000000000000000000000000;;	func GetStringMapString(key string) map[string]string { return v.GetStringMapString(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetStringMapString(key string) map[string]string {
0000000000000000000000000000000000000000;;		return cast.ToStringMapString(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the value associated with the key as a map to a slice of strings.
0000000000000000000000000000000000000000;;	func GetStringMapStringSlice(key string) map[string][]string { return v.GetStringMapStringSlice(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetStringMapStringSlice(key string) map[string][]string {
0000000000000000000000000000000000000000;;		return cast.ToStringMapStringSlice(v.Get(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the size of the value associated with the given key
0000000000000000000000000000000000000000;;	// in bytes.
0000000000000000000000000000000000000000;;	func GetSizeInBytes(key string) uint { return v.GetSizeInBytes(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) GetSizeInBytes(key string) uint {
0000000000000000000000000000000000000000;;		sizeStr := cast.ToString(v.Get(key))
0000000000000000000000000000000000000000;;		return parseSizeInBytes(sizeStr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Takes a single key and unmarshals it into a Struct
0000000000000000000000000000000000000000;;	func UnmarshalKey(key string, rawVal interface{}) error { return v.UnmarshalKey(key, rawVal) }
0000000000000000000000000000000000000000;;	func (v *Viper) UnmarshalKey(key string, rawVal interface{}) error {
0000000000000000000000000000000000000000;;		return mapstructure.Decode(v.Get(key), rawVal)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshals the config into a Struct. Make sure that the tags
0000000000000000000000000000000000000000;;	// on the fields of the structure are properly set.
0000000000000000000000000000000000000000;;	func Unmarshal(rawVal interface{}) error { return v.Unmarshal(rawVal) }
0000000000000000000000000000000000000000;;	func (v *Viper) Unmarshal(rawVal interface{}) error {
0000000000000000000000000000000000000000;;		err := mapstructure.WeakDecode(v.AllSettings(), rawVal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.insensitiviseMaps()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A wrapper around mapstructure.Decode that mimics the WeakDecode functionality
0000000000000000000000000000000000000000;;	// while erroring on non existing vals in the destination struct
0000000000000000000000000000000000000000;;	func weakDecodeExact(input, output interface{}) error {
0000000000000000000000000000000000000000;;		config := &mapstructure.DecoderConfig{
0000000000000000000000000000000000000000;;			ErrorUnused:      true,
0000000000000000000000000000000000000000;;			Metadata:         nil,
0000000000000000000000000000000000000000;;			Result:           output,
0000000000000000000000000000000000000000;;			WeaklyTypedInput: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder, err := mapstructure.NewDecoder(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decoder.Decode(input)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshals the config into a Struct, erroring if a field is non-existant
0000000000000000000000000000000000000000;;	// in the destination struct
0000000000000000000000000000000000000000;;	func (v *Viper) UnmarshalExact(rawVal interface{}) error {
0000000000000000000000000000000000000000;;		err := weakDecodeExact(v.AllSettings(), rawVal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.insensitiviseMaps()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bind a full flag set to the configuration, using each flag's long
0000000000000000000000000000000000000000;;	// name as the config key.
0000000000000000000000000000000000000000;;	func BindPFlags(flags *pflag.FlagSet) (err error) { return v.BindPFlags(flags) }
0000000000000000000000000000000000000000;;	func (v *Viper) BindPFlags(flags *pflag.FlagSet) (err error) {
0000000000000000000000000000000000000000;;		return v.BindFlagValues(pflagValueSet{flags})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bind a specific key to a pflag (as used by cobra).
0000000000000000000000000000000000000000;;	// Example (where serverCmd is a Cobra instance):
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	 serverCmd.Flags().Int("port", 1138, "Port to run Application server on")
0000000000000000000000000000000000000000;;	//	 Viper.BindPFlag("port", serverCmd.Flags().Lookup("port"))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func BindPFlag(key string, flag *pflag.Flag) (err error) { return v.BindPFlag(key, flag) }
0000000000000000000000000000000000000000;;	func (v *Viper) BindPFlag(key string, flag *pflag.Flag) (err error) {
0000000000000000000000000000000000000000;;		return v.BindFlagValue(key, pflagValue{flag})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bind a full FlagValue set to the configuration, using each flag's long
0000000000000000000000000000000000000000;;	// name as the config key.
0000000000000000000000000000000000000000;;	func BindFlagValues(flags FlagValueSet) (err error) { return v.BindFlagValues(flags) }
0000000000000000000000000000000000000000;;	func (v *Viper) BindFlagValues(flags FlagValueSet) (err error) {
0000000000000000000000000000000000000000;;		flags.VisitAll(func(flag FlagValue) {
0000000000000000000000000000000000000000;;			if err = v.BindFlagValue(flag.Name(), flag); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bind a specific key to a FlagValue.
0000000000000000000000000000000000000000;;	// Example(where serverCmd is a Cobra instance):
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	 serverCmd.Flags().Int("port", 1138, "Port to run Application server on")
0000000000000000000000000000000000000000;;	//	 Viper.BindFlagValue("port", serverCmd.Flags().Lookup("port"))
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func BindFlagValue(key string, flag FlagValue) (err error) { return v.BindFlagValue(key, flag) }
0000000000000000000000000000000000000000;;	func (v *Viper) BindFlagValue(key string, flag FlagValue) (err error) {
0000000000000000000000000000000000000000;;		if flag == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("flag for %q is nil", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v.pflags[strings.ToLower(key)] = flag
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Binds a Viper key to a ENV variable
0000000000000000000000000000000000000000;;	// ENV variables are case sensitive
0000000000000000000000000000000000000000;;	// If only a key is provided, it will use the env key matching the key, uppercased.
0000000000000000000000000000000000000000;;	// EnvPrefix will be used when set when env name is not provided.
0000000000000000000000000000000000000000;;	func BindEnv(input ...string) (err error) { return v.BindEnv(input...) }
0000000000000000000000000000000000000000;;	func (v *Viper) BindEnv(input ...string) (err error) {
0000000000000000000000000000000000000000;;		var key, envkey string
0000000000000000000000000000000000000000;;		if len(input) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("BindEnv missing key to bind to")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key = strings.ToLower(input[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(input) == 1 {
0000000000000000000000000000000000000000;;			envkey = v.mergeWithEnvPrefix(key)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			envkey = input[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.env[key] = envkey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Given a key, find the value
0000000000000000000000000000000000000000;;	// Viper will check in the following order:
0000000000000000000000000000000000000000;;	// flag, env, config file, key/value store, default
0000000000000000000000000000000000000000;;	// Viper will check to see if an alias exists first
0000000000000000000000000000000000000000;;	func (v *Viper) find(key string) interface{} {
0000000000000000000000000000000000000000;;		var val interface{}
0000000000000000000000000000000000000000;;		var exists bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the requested key is an alias, then return the proper key
0000000000000000000000000000000000000000;;		key = v.realKey(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PFlag Override first
0000000000000000000000000000000000000000;;		flag, exists := v.pflags[key]
0000000000000000000000000000000000000000;;		if exists && flag.HasChanged() {
0000000000000000000000000000000000000000;;			jww.TRACE.Println(key, "found in override (via pflag):", flag.ValueString())
0000000000000000000000000000000000000000;;			switch flag.ValueType() {
0000000000000000000000000000000000000000;;			case "int", "int8", "int16", "int32", "int64":
0000000000000000000000000000000000000000;;				return cast.ToInt(flag.ValueString())
0000000000000000000000000000000000000000;;			case "bool":
0000000000000000000000000000000000000000;;				return cast.ToBool(flag.ValueString())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return flag.ValueString()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, exists = v.override[key]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			jww.TRACE.Println(key, "found in override:", val)
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v.automaticEnvApplied {
0000000000000000000000000000000000000000;;			// even if it hasn't been registered, if automaticEnv is used,
0000000000000000000000000000000000000000;;			// check any Get request
0000000000000000000000000000000000000000;;			if val = v.getEnv(v.mergeWithEnvPrefix(key)); val != "" {
0000000000000000000000000000000000000000;;				jww.TRACE.Println(key, "found in environment with val:", val)
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		envkey, exists := v.env[key]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			jww.TRACE.Println(key, "registered as env var", envkey)
0000000000000000000000000000000000000000;;			if val = v.getEnv(envkey); val != "" {
0000000000000000000000000000000000000000;;				jww.TRACE.Println(envkey, "found in environment with val:", val)
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				jww.TRACE.Println(envkey, "env value unset:")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, exists = v.config[key]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			jww.TRACE.Println(key, "found in config:", val)
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test for nested config parameter
0000000000000000000000000000000000000000;;		if strings.Contains(key, v.keyDelim) {
0000000000000000000000000000000000000000;;			path := strings.Split(key, v.keyDelim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			source := v.find(path[0])
0000000000000000000000000000000000000000;;			if source != nil {
0000000000000000000000000000000000000000;;				if reflect.TypeOf(source).Kind() == reflect.Map {
0000000000000000000000000000000000000000;;					val := v.searchMap(cast.ToStringMap(source), path[1:])
0000000000000000000000000000000000000000;;					jww.TRACE.Println(key, "found in nested config:", val)
0000000000000000000000000000000000000000;;					return val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, exists = v.kvstore[key]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			jww.TRACE.Println(key, "found in key/value store:", val)
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, exists = v.defaults[key]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			jww.TRACE.Println(key, "found in defaults:", val)
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check to see if the key has been set in any of the data locations
0000000000000000000000000000000000000000;;	func IsSet(key string) bool { return v.IsSet(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) IsSet(key string) bool {
0000000000000000000000000000000000000000;;		path := strings.Split(key, v.keyDelim)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lcaseKey := strings.ToLower(key)
0000000000000000000000000000000000000000;;		val := v.find(lcaseKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val == nil {
0000000000000000000000000000000000000000;;			source := v.find(strings.ToLower(path[0]))
0000000000000000000000000000000000000000;;			if source != nil {
0000000000000000000000000000000000000000;;				if reflect.TypeOf(source).Kind() == reflect.Map {
0000000000000000000000000000000000000000;;					val = v.searchMap(cast.ToStringMap(source), path[1:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return val != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Have Viper check ENV variables for all
0000000000000000000000000000000000000000;;	// keys set in config, default & flags
0000000000000000000000000000000000000000;;	func AutomaticEnv() { v.AutomaticEnv() }
0000000000000000000000000000000000000000;;	func (v *Viper) AutomaticEnv() {
0000000000000000000000000000000000000000;;		v.automaticEnvApplied = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEnvKeyReplacer sets the strings.Replacer on the viper object
0000000000000000000000000000000000000000;;	// Useful for mapping an environmental variable to a key that does
0000000000000000000000000000000000000000;;	// not match it.
0000000000000000000000000000000000000000;;	func SetEnvKeyReplacer(r *strings.Replacer) { v.SetEnvKeyReplacer(r) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetEnvKeyReplacer(r *strings.Replacer) {
0000000000000000000000000000000000000000;;		v.envKeyReplacer = r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Aliases provide another accessor for the same key.
0000000000000000000000000000000000000000;;	// This enables one to change a name without breaking the application
0000000000000000000000000000000000000000;;	func RegisterAlias(alias string, key string) { v.RegisterAlias(alias, key) }
0000000000000000000000000000000000000000;;	func (v *Viper) RegisterAlias(alias string, key string) {
0000000000000000000000000000000000000000;;		v.registerAlias(alias, strings.ToLower(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) registerAlias(alias string, key string) {
0000000000000000000000000000000000000000;;		alias = strings.ToLower(alias)
0000000000000000000000000000000000000000;;		if alias != key && alias != v.realKey(key) {
0000000000000000000000000000000000000000;;			_, exists := v.aliases[alias]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				// if we alias something that exists in one of the maps to another
0000000000000000000000000000000000000000;;				// name, we'll never be able to get that value using the original
0000000000000000000000000000000000000000;;				// name, so move the config value to the new realkey.
0000000000000000000000000000000000000000;;				if val, ok := v.config[alias]; ok {
0000000000000000000000000000000000000000;;					delete(v.config, alias)
0000000000000000000000000000000000000000;;					v.config[key] = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if val, ok := v.kvstore[alias]; ok {
0000000000000000000000000000000000000000;;					delete(v.kvstore, alias)
0000000000000000000000000000000000000000;;					v.kvstore[key] = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if val, ok := v.defaults[alias]; ok {
0000000000000000000000000000000000000000;;					delete(v.defaults, alias)
0000000000000000000000000000000000000000;;					v.defaults[key] = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if val, ok := v.override[alias]; ok {
0000000000000000000000000000000000000000;;					delete(v.override, alias)
0000000000000000000000000000000000000000;;					v.override[key] = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.aliases[alias] = key
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			jww.WARN.Println("Creating circular reference alias", alias, key, v.realKey(key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) realKey(key string) string {
0000000000000000000000000000000000000000;;		newkey, exists := v.aliases[key]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			jww.DEBUG.Println("Alias", key, "to", newkey)
0000000000000000000000000000000000000000;;			return v.realKey(newkey)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check to see if the given key (or an alias) is in the config file
0000000000000000000000000000000000000000;;	func InConfig(key string) bool { return v.InConfig(key) }
0000000000000000000000000000000000000000;;	func (v *Viper) InConfig(key string) bool {
0000000000000000000000000000000000000000;;		// if the requested key is an alias, then return the proper key
0000000000000000000000000000000000000000;;		key = v.realKey(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, exists := v.config[key]
0000000000000000000000000000000000000000;;		return exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the default value for this key.
0000000000000000000000000000000000000000;;	// Default only used when no value is provided by the user via flag, config or ENV.
0000000000000000000000000000000000000000;;	func SetDefault(key string, value interface{}) { v.SetDefault(key, value) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetDefault(key string, value interface{}) {
0000000000000000000000000000000000000000;;		// If alias passed in, then set the proper default
0000000000000000000000000000000000000000;;		key = v.realKey(strings.ToLower(key))
0000000000000000000000000000000000000000;;		v.defaults[key] = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sets the value for the key in the override regiser.
0000000000000000000000000000000000000000;;	// Will be used instead of values obtained via
0000000000000000000000000000000000000000;;	// flags, config file, ENV, default, or key/value store
0000000000000000000000000000000000000000;;	func Set(key string, value interface{}) { v.Set(key, value) }
0000000000000000000000000000000000000000;;	func (v *Viper) Set(key string, value interface{}) {
0000000000000000000000000000000000000000;;		// If alias passed in, then set the proper override
0000000000000000000000000000000000000000;;		key = v.realKey(strings.ToLower(key))
0000000000000000000000000000000000000000;;		v.override[key] = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Viper will discover and load the configuration file from disk
0000000000000000000000000000000000000000;;	// and key/value stores, searching in one of the defined paths.
0000000000000000000000000000000000000000;;	func ReadInConfig() error { return v.ReadInConfig() }
0000000000000000000000000000000000000000;;	func (v *Viper) ReadInConfig() error {
0000000000000000000000000000000000000000;;		jww.INFO.Println("Attempting to read in config file")
0000000000000000000000000000000000000000;;		if !stringInSlice(v.getConfigType(), SupportedExts) {
0000000000000000000000000000000000000000;;			return UnsupportedConfigError(v.getConfigType())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := afero.ReadFile(v.fs, v.getConfigFile())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.config = make(map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v.unmarshalReader(bytes.NewReader(file), v.config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeInConfig merges a new configuration with an existing config.
0000000000000000000000000000000000000000;;	func MergeInConfig() error { return v.MergeInConfig() }
0000000000000000000000000000000000000000;;	func (v *Viper) MergeInConfig() error {
0000000000000000000000000000000000000000;;		jww.INFO.Println("Attempting to merge in config file")
0000000000000000000000000000000000000000;;		if !stringInSlice(v.getConfigType(), SupportedExts) {
0000000000000000000000000000000000000000;;			return UnsupportedConfigError(v.getConfigType())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := afero.ReadFile(v.fs, v.getConfigFile())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v.MergeConfig(bytes.NewReader(file))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Viper will read a configuration file, setting existing keys to nil if the
0000000000000000000000000000000000000000;;	// key does not exist in the file.
0000000000000000000000000000000000000000;;	func ReadConfig(in io.Reader) error { return v.ReadConfig(in) }
0000000000000000000000000000000000000000;;	func (v *Viper) ReadConfig(in io.Reader) error {
0000000000000000000000000000000000000000;;		v.config = make(map[string]interface{})
0000000000000000000000000000000000000000;;		return v.unmarshalReader(in, v.config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeConfig merges a new configuration with an existing config.
0000000000000000000000000000000000000000;;	func MergeConfig(in io.Reader) error { return v.MergeConfig(in) }
0000000000000000000000000000000000000000;;	func (v *Viper) MergeConfig(in io.Reader) error {
0000000000000000000000000000000000000000;;		if v.config == nil {
0000000000000000000000000000000000000000;;			v.config = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := v.unmarshalReader(in, cfg); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergeMaps(cfg, v.config, nil)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func keyExists(k string, m map[string]interface{}) string {
0000000000000000000000000000000000000000;;		lk := strings.ToLower(k)
0000000000000000000000000000000000000000;;		for mk := range m {
0000000000000000000000000000000000000000;;			lmk := strings.ToLower(mk)
0000000000000000000000000000000000000000;;			if lmk == lk {
0000000000000000000000000000000000000000;;				return mk
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func castToMapStringInterface(
0000000000000000000000000000000000000000;;		src map[interface{}]interface{}) map[string]interface{} {
0000000000000000000000000000000000000000;;		tgt := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for k, v := range src {
0000000000000000000000000000000000000000;;			tgt[fmt.Sprintf("%v", k)] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tgt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeMaps merges two maps. The `itgt` parameter is for handling go-yaml's
0000000000000000000000000000000000000000;;	// insistence on parsing nested structures as `map[interface{}]interface{}`
0000000000000000000000000000000000000000;;	// instead of using a `string` as the key for nest structures beyond one level
0000000000000000000000000000000000000000;;	// deep. Both map types are supported as there is a go-yaml fork that uses
0000000000000000000000000000000000000000;;	// `map[string]interface{}` instead.
0000000000000000000000000000000000000000;;	func mergeMaps(
0000000000000000000000000000000000000000;;		src, tgt map[string]interface{}, itgt map[interface{}]interface{}) {
0000000000000000000000000000000000000000;;		for sk, sv := range src {
0000000000000000000000000000000000000000;;			tk := keyExists(sk, tgt)
0000000000000000000000000000000000000000;;			if tk == "" {
0000000000000000000000000000000000000000;;				jww.TRACE.Printf("tk=\"\", tgt[%s]=%v", sk, sv)
0000000000000000000000000000000000000000;;				tgt[sk] = sv
0000000000000000000000000000000000000000;;				if itgt != nil {
0000000000000000000000000000000000000000;;					itgt[sk] = sv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tv, ok := tgt[tk]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				jww.TRACE.Printf("tgt[%s] != ok, tgt[%s]=%v", tk, sk, sv)
0000000000000000000000000000000000000000;;				tgt[sk] = sv
0000000000000000000000000000000000000000;;				if itgt != nil {
0000000000000000000000000000000000000000;;					itgt[sk] = sv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			svType := reflect.TypeOf(sv)
0000000000000000000000000000000000000000;;			tvType := reflect.TypeOf(tv)
0000000000000000000000000000000000000000;;			if svType != tvType {
0000000000000000000000000000000000000000;;				jww.ERROR.Printf(
0000000000000000000000000000000000000000;;					"svType != tvType; key=%s, st=%v, tt=%v, sv=%v, tv=%v",
0000000000000000000000000000000000000000;;					sk, svType, tvType, sv, tv)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jww.TRACE.Printf("processing key=%s, st=%v, tt=%v, sv=%v, tv=%v",
0000000000000000000000000000000000000000;;				sk, svType, tvType, sv, tv)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch ttv := tv.(type) {
0000000000000000000000000000000000000000;;			case map[interface{}]interface{}:
0000000000000000000000000000000000000000;;				jww.TRACE.Printf("merging maps (must convert)")
0000000000000000000000000000000000000000;;				tsv := sv.(map[interface{}]interface{})
0000000000000000000000000000000000000000;;				ssv := castToMapStringInterface(tsv)
0000000000000000000000000000000000000000;;				stv := castToMapStringInterface(ttv)
0000000000000000000000000000000000000000;;				mergeMaps(ssv, stv, ttv)
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				jww.TRACE.Printf("merging maps")
0000000000000000000000000000000000000000;;				mergeMaps(sv.(map[string]interface{}), ttv, nil)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				jww.TRACE.Printf("setting value")
0000000000000000000000000000000000000000;;				tgt[tk] = sv
0000000000000000000000000000000000000000;;				if itgt != nil {
0000000000000000000000000000000000000000;;					itgt[tk] = sv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func ReadBufConfig(buf *bytes.Buffer) error { return v.ReadBufConfig(buf) }
0000000000000000000000000000000000000000;;	// func (v *Viper) ReadBufConfig(buf *bytes.Buffer) error {
0000000000000000000000000000000000000000;;	// 	v.config = make(map[string]interface{})
0000000000000000000000000000000000000000;;	// 	return v.unmarshalReader(buf, v.config)
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attempts to get configuration from a remote source
0000000000000000000000000000000000000000;;	// and read it in the remote configuration registry.
0000000000000000000000000000000000000000;;	func ReadRemoteConfig() error { return v.ReadRemoteConfig() }
0000000000000000000000000000000000000000;;	func (v *Viper) ReadRemoteConfig() error {
0000000000000000000000000000000000000000;;		err := v.getKeyValueConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WatchRemoteConfig() error { return v.WatchRemoteConfig() }
0000000000000000000000000000000000000000;;	func (v *Viper) WatchRemoteConfig() error {
0000000000000000000000000000000000000000;;		err := v.watchKeyValueConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshall a Reader into a map
0000000000000000000000000000000000000000;;	// Should probably be an unexported function
0000000000000000000000000000000000000000;;	func unmarshalReader(in io.Reader, c map[string]interface{}) error {
0000000000000000000000000000000000000000;;		return v.unmarshalReader(in, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) unmarshalReader(in io.Reader, c map[string]interface{}) error {
0000000000000000000000000000000000000000;;		return unmarshallConfigReader(in, c, v.getConfigType())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) insensitiviseMaps() {
0000000000000000000000000000000000000000;;		insensitiviseMap(v.config)
0000000000000000000000000000000000000000;;		insensitiviseMap(v.defaults)
0000000000000000000000000000000000000000;;		insensitiviseMap(v.override)
0000000000000000000000000000000000000000;;		insensitiviseMap(v.kvstore)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// retrieve the first found remote configuration
0000000000000000000000000000000000000000;;	func (v *Viper) getKeyValueConfig() error {
0000000000000000000000000000000000000000;;		if RemoteConfig == nil {
0000000000000000000000000000000000000000;;			return RemoteConfigError("Enable the remote features by doing a blank import of the viper/remote package: '_ github.com/spf13/viper/remote'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rp := range v.remoteProviders {
0000000000000000000000000000000000000000;;			val, err := v.getRemoteConfig(rp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.kvstore = val
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RemoteConfigError("No Files Found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) getRemoteConfig(provider *defaultRemoteProvider) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader, err := RemoteConfig.Get(provider)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = v.unmarshalReader(reader, v.kvstore)
0000000000000000000000000000000000000000;;		return v.kvstore, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// retrieve the first found remote configuration
0000000000000000000000000000000000000000;;	func (v *Viper) watchKeyValueConfig() error {
0000000000000000000000000000000000000000;;		for _, rp := range v.remoteProviders {
0000000000000000000000000000000000000000;;			val, err := v.watchRemoteConfig(rp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.kvstore = val
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RemoteConfigError("No Files Found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) watchRemoteConfig(provider *defaultRemoteProvider) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		reader, err := RemoteConfig.Watch(provider)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = v.unmarshalReader(reader, v.kvstore)
0000000000000000000000000000000000000000;;		return v.kvstore, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return all keys regardless where they are set
0000000000000000000000000000000000000000;;	func AllKeys() []string { return v.AllKeys() }
0000000000000000000000000000000000000000;;	func (v *Viper) AllKeys() []string {
0000000000000000000000000000000000000000;;		m := map[string]struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, _ := range v.defaults {
0000000000000000000000000000000000000000;;			m[strings.ToLower(key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, _ := range v.pflags {
0000000000000000000000000000000000000000;;			m[strings.ToLower(key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, _ := range v.env {
0000000000000000000000000000000000000000;;			m[strings.ToLower(key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, _ := range v.config {
0000000000000000000000000000000000000000;;			m[strings.ToLower(key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, _ := range v.kvstore {
0000000000000000000000000000000000000000;;			m[strings.ToLower(key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, _ := range v.override {
0000000000000000000000000000000000000000;;			m[strings.ToLower(key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, _ := range v.aliases {
0000000000000000000000000000000000000000;;			m[strings.ToLower(key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := []string{}
0000000000000000000000000000000000000000;;		for x, _ := range m {
0000000000000000000000000000000000000000;;			a = append(a, x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return all settings as a map[string]interface{}
0000000000000000000000000000000000000000;;	func AllSettings() map[string]interface{} { return v.AllSettings() }
0000000000000000000000000000000000000000;;	func (v *Viper) AllSettings() map[string]interface{} {
0000000000000000000000000000000000000000;;		m := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, x := range v.AllKeys() {
0000000000000000000000000000000000000000;;			m[x] = v.Get(x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Se the filesystem to use to read configuration.
0000000000000000000000000000000000000000;;	func SetFs(fs afero.Fs) { v.SetFs(fs) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetFs(fs afero.Fs) {
0000000000000000000000000000000000000000;;		v.fs = fs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name for the config file.
0000000000000000000000000000000000000000;;	// Does not include extension.
0000000000000000000000000000000000000000;;	func SetConfigName(in string) { v.SetConfigName(in) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetConfigName(in string) {
0000000000000000000000000000000000000000;;		if in != "" {
0000000000000000000000000000000000000000;;			v.configName = in
0000000000000000000000000000000000000000;;			v.configFile = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sets the type of the configuration returned by the
0000000000000000000000000000000000000000;;	// remote source, e.g. "json".
0000000000000000000000000000000000000000;;	func SetConfigType(in string) { v.SetConfigType(in) }
0000000000000000000000000000000000000000;;	func (v *Viper) SetConfigType(in string) {
0000000000000000000000000000000000000000;;		if in != "" {
0000000000000000000000000000000000000000;;			v.configType = in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) getConfigType() string {
0000000000000000000000000000000000000000;;		if v.configType != "" {
0000000000000000000000000000000000000000;;			return v.configType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cf := v.getConfigFile()
0000000000000000000000000000000000000000;;		ext := filepath.Ext(cf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ext) > 1 {
0000000000000000000000000000000000000000;;			return ext[1:]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) getConfigFile() string {
0000000000000000000000000000000000000000;;		// if explicitly set, then use it
0000000000000000000000000000000000000000;;		if v.configFile != "" {
0000000000000000000000000000000000000000;;			return v.configFile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cf, err := v.findConfigFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.configFile = cf
0000000000000000000000000000000000000000;;		return v.getConfigFile()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Viper) searchInPath(in string) (filename string) {
0000000000000000000000000000000000000000;;		jww.DEBUG.Println("Searching for config in ", in)
0000000000000000000000000000000000000000;;		for _, ext := range SupportedExts {
0000000000000000000000000000000000000000;;			jww.DEBUG.Println("Checking for", filepath.Join(in, v.configName+"."+ext))
0000000000000000000000000000000000000000;;			if b, _ := exists(filepath.Join(in, v.configName+"."+ext)); b {
0000000000000000000000000000000000000000;;				jww.DEBUG.Println("Found: ", filepath.Join(in, v.configName+"."+ext))
0000000000000000000000000000000000000000;;				return filepath.Join(in, v.configName+"."+ext)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// search all configPaths for any config file.
0000000000000000000000000000000000000000;;	// Returns the first path that exists (and is a config file)
0000000000000000000000000000000000000000;;	func (v *Viper) findConfigFile() (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jww.INFO.Println("Searching for config in ", v.configPaths)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cp := range v.configPaths {
0000000000000000000000000000000000000000;;			file := v.searchInPath(cp)
0000000000000000000000000000000000000000;;			if file != "" {
0000000000000000000000000000000000000000;;				return file, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", ConfigFileNotFoundError{v.configName, fmt.Sprintf("%s", v.configPaths)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prints all configuration registries for debugging
0000000000000000000000000000000000000000;;	// purposes.
0000000000000000000000000000000000000000;;	func Debug() { v.Debug() }
0000000000000000000000000000000000000000;;	func (v *Viper) Debug() {
0000000000000000000000000000000000000000;;		fmt.Println("Aliases:")
0000000000000000000000000000000000000000;;		fmt.Printf("Aliases:\n%#v\n", v.aliases)
0000000000000000000000000000000000000000;;		fmt.Printf("Override:\n%#v\n", v.override)
0000000000000000000000000000000000000000;;		fmt.Printf("PFlags:\n%#v\n", v.pflags)
0000000000000000000000000000000000000000;;		fmt.Printf("Env:\n%#v\n", v.env)
0000000000000000000000000000000000000000;;		fmt.Printf("Key/Value Store:\n%#v\n", v.kvstore)
0000000000000000000000000000000000000000;;		fmt.Printf("Config:\n%#v\n", v.config)
0000000000000000000000000000000000000000;;		fmt.Printf("Defaults:\n%#v\n", v.defaults)
0000000000000000000000000000000000000000;;	}
