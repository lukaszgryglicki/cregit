0000000000000000000000000000000000000000;;	// Copyright Â© 2014 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use of this source code is governed by an MIT-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// Viper is a application configuration system.
0000000000000000000000000000000000000000;;	// It believes that applications can be configured a variety of ways
0000000000000000000000000000000000000000;;	// via flags, ENVIRONMENT variables, configuration files retrieved
0000000000000000000000000000000000000000;;	// from the file system, or a remote key/value store.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package viper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl"
0000000000000000000000000000000000000000;;		"github.com/magiconair/properties"
0000000000000000000000000000000000000000;;		toml "github.com/pelletier/go-toml"
0000000000000000000000000000000000000000;;		"github.com/spf13/cast"
0000000000000000000000000000000000000000;;		jww "github.com/spf13/jwalterweatherman"
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Denotes failing to parse configuration file.
0000000000000000000000000000000000000000;;	type ConfigParseError struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the formatted configuration error.
0000000000000000000000000000000000000000;;	func (pe ConfigParseError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("While parsing config: %s", pe.err.Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func insensitiviseMap(m map[string]interface{}) {
0000000000000000000000000000000000000000;;		for key, val := range m {
0000000000000000000000000000000000000000;;			lower := strings.ToLower(key)
0000000000000000000000000000000000000000;;			if key != lower {
0000000000000000000000000000000000000000;;				delete(m, key)
0000000000000000000000000000000000000000;;				m[lower] = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func absPathify(inPath string) string {
0000000000000000000000000000000000000000;;		jww.INFO.Println("Trying to resolve absolute path to", inPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasPrefix(inPath, "$HOME") {
0000000000000000000000000000000000000000;;			inPath = userHomeDir() + inPath[5:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasPrefix(inPath, "$") {
0000000000000000000000000000000000000000;;			end := strings.Index(inPath, string(os.PathSeparator))
0000000000000000000000000000000000000000;;			inPath = os.Getenv(inPath[1:end]) + inPath[end:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if filepath.IsAbs(inPath) {
0000000000000000000000000000000000000000;;			return filepath.Clean(inPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := filepath.Abs(inPath)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return filepath.Clean(p)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			jww.ERROR.Println("Couldn't discover absolute path")
0000000000000000000000000000000000000000;;			jww.ERROR.Println(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if File / Directory Exists
0000000000000000000000000000000000000000;;	func exists(path string) (bool, error) {
0000000000000000000000000000000000000000;;		_, err := v.fs.Stat(path)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stringInSlice(a string, list []string) bool {
0000000000000000000000000000000000000000;;		for _, b := range list {
0000000000000000000000000000000000000000;;			if b == a {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func userHomeDir() string {
0000000000000000000000000000000000000000;;		if runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			home := os.Getenv("HOMEDRIVE") + os.Getenv("HOMEPATH")
0000000000000000000000000000000000000000;;			if home == "" {
0000000000000000000000000000000000000000;;				home = os.Getenv("USERPROFILE")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return home
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.Getenv("HOME")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findCWD() (string, error) {
0000000000000000000000000000000000000000;;		serverFile, err := filepath.Abs(os.Args[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Can't get absolute path for executable: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := filepath.Dir(serverFile)
0000000000000000000000000000000000000000;;		realFile, err := filepath.EvalSymlinks(serverFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, err = os.Stat(serverFile + ".exe"); err == nil {
0000000000000000000000000000000000000000;;				realFile = filepath.Clean(serverFile + ".exe")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil && realFile != serverFile {
0000000000000000000000000000000000000000;;			path = filepath.Dir(realFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshallConfigReader(in io.Reader, c map[string]interface{}, configType string) error {
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		buf.ReadFrom(in)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch strings.ToLower(configType) {
0000000000000000000000000000000000000000;;		case "yaml", "yml":
0000000000000000000000000000000000000000;;			if err := yaml.Unmarshal(buf.Bytes(), &c); err != nil {
0000000000000000000000000000000000000000;;				return ConfigParseError{err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "json":
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(buf.Bytes(), &c); err != nil {
0000000000000000000000000000000000000000;;				return ConfigParseError{err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "hcl":
0000000000000000000000000000000000000000;;			obj, err := hcl.Parse(string(buf.Bytes()))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ConfigParseError{err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = hcl.DecodeObject(&c, obj); err != nil {
0000000000000000000000000000000000000000;;				return ConfigParseError{err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "toml":
0000000000000000000000000000000000000000;;			tree, err := toml.LoadReader(buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ConfigParseError{err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tmap := tree.ToMap()
0000000000000000000000000000000000000000;;			for k, v := range tmap {
0000000000000000000000000000000000000000;;				c[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "properties", "props", "prop":
0000000000000000000000000000000000000000;;			var p *properties.Properties
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if p, err = properties.Load(buf.Bytes(), properties.UTF8); err != nil {
0000000000000000000000000000000000000000;;				return ConfigParseError{err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, key := range p.Keys() {
0000000000000000000000000000000000000000;;				value, _ := p.Get(key)
0000000000000000000000000000000000000000;;				c[key] = value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		insensitiviseMap(c)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func safeMul(a, b uint) uint {
0000000000000000000000000000000000000000;;		c := a * b
0000000000000000000000000000000000000000;;		if a > 1 && b > 1 && c/b != a {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseSizeInBytes converts strings like 1GB or 12 mb into an unsigned integer number of bytes
0000000000000000000000000000000000000000;;	func parseSizeInBytes(sizeStr string) uint {
0000000000000000000000000000000000000000;;		sizeStr = strings.TrimSpace(sizeStr)
0000000000000000000000000000000000000000;;		lastChar := len(sizeStr) - 1
0000000000000000000000000000000000000000;;		multiplier := uint(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lastChar > 0 {
0000000000000000000000000000000000000000;;			if sizeStr[lastChar] == 'b' || sizeStr[lastChar] == 'B' {
0000000000000000000000000000000000000000;;				if lastChar > 1 {
0000000000000000000000000000000000000000;;					switch unicode.ToLower(rune(sizeStr[lastChar-1])) {
0000000000000000000000000000000000000000;;					case 'k':
0000000000000000000000000000000000000000;;						multiplier = 1 << 10
0000000000000000000000000000000000000000;;						sizeStr = strings.TrimSpace(sizeStr[:lastChar-1])
0000000000000000000000000000000000000000;;					case 'm':
0000000000000000000000000000000000000000;;						multiplier = 1 << 20
0000000000000000000000000000000000000000;;						sizeStr = strings.TrimSpace(sizeStr[:lastChar-1])
0000000000000000000000000000000000000000;;					case 'g':
0000000000000000000000000000000000000000;;						multiplier = 1 << 30
0000000000000000000000000000000000000000;;						sizeStr = strings.TrimSpace(sizeStr[:lastChar-1])
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						multiplier = 1
0000000000000000000000000000000000000000;;						sizeStr = strings.TrimSpace(sizeStr[:lastChar])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size := cast.ToInt(sizeStr)
0000000000000000000000000000000000000000;;		if size < 0 {
0000000000000000000000000000000000000000;;			size = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return safeMul(uint(size), multiplier)
0000000000000000000000000000000000000000;;	}
