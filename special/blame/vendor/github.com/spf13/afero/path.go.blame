0000000000000000000000000000000000000000;;	// Copyright ©2015 The Go Authors
0000000000000000000000000000000000000000;;	// Copyright ©2015 Steve Francia <spf@spf13.com>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readDirNames reads the directory named by dirname and returns
0000000000000000000000000000000000000000;;	// a sorted list of directory entries.
0000000000000000000000000000000000000000;;	// adapted from https://golang.org/src/path/filepath/path.go
0000000000000000000000000000000000000000;;	func readDirNames(fs Fs, dirname string) ([]string, error) {
0000000000000000000000000000000000000000;;		f, err := fs.Open(dirname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		names, err := f.Readdirnames(-1)
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(names)
0000000000000000000000000000000000000000;;		return names, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// walk recursively descends path, calling walkFn
0000000000000000000000000000000000000000;;	// adapted from https://golang.org/src/path/filepath/path.go
0000000000000000000000000000000000000000;;	func walk(fs Fs, path string, info os.FileInfo, walkFn filepath.WalkFunc) error {
0000000000000000000000000000000000000000;;		err := walkFn(path, info, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if info.IsDir() && err == filepath.SkipDir {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !info.IsDir() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		names, err := readDirNames(fs, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return walkFn(path, info, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			filename := filepath.Join(path, name)
0000000000000000000000000000000000000000;;			fileInfo, err := lstatIfOs(fs, filename)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err := walkFn(filename, fileInfo, err); err != nil && err != filepath.SkipDir {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = walk(fs, filename, fileInfo, walkFn)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !fileInfo.IsDir() || err != filepath.SkipDir {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// if the filesystem is OsFs use Lstat, else use fs.Stat
0000000000000000000000000000000000000000;;	func lstatIfOs(fs Fs, path string) (info os.FileInfo, err error) {
0000000000000000000000000000000000000000;;		_, ok := fs.(*OsFs)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			info, err = os.Lstat(path)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			info, err = fs.Stat(path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Walk walks the file tree rooted at root, calling walkFn for each file or
0000000000000000000000000000000000000000;;	// directory in the tree, including root. All errors that arise visiting files
0000000000000000000000000000000000000000;;	// and directories are filtered by walkFn. The files are walked in lexical
0000000000000000000000000000000000000000;;	// order, which makes the output deterministic but means that for very
0000000000000000000000000000000000000000;;	// large directories Walk can be inefficient.
0000000000000000000000000000000000000000;;	// Walk does not follow symbolic links.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) Walk(root string, walkFn filepath.WalkFunc) error {
0000000000000000000000000000000000000000;;		return Walk(a.Fs, root, walkFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Walk(fs Fs, root string, walkFn filepath.WalkFunc) error {
0000000000000000000000000000000000000000;;		info, err := lstatIfOs(fs, root)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return walkFn(root, nil, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return walk(fs, root, info, walkFn)
0000000000000000000000000000000000000000;;	}
