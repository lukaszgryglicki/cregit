0000000000000000000000000000000000000000;;	// Copyright Â© 2014 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/afero/mem"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MemMapFs struct {
0000000000000000000000000000000000000000;;		mu   sync.RWMutex
0000000000000000000000000000000000000000;;		data map[string]*mem.FileData
0000000000000000000000000000000000000000;;		init sync.Once
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMemMapFs() Fs {
0000000000000000000000000000000000000000;;		return &MemMapFs{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var memfsInit sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) getData() map[string]*mem.FileData {
0000000000000000000000000000000000000000;;		m.init.Do(func() {
0000000000000000000000000000000000000000;;			m.data = make(map[string]*mem.FileData)
0000000000000000000000000000000000000000;;			// Root should always exist, right?
0000000000000000000000000000000000000000;;			// TODO: what about windows?
0000000000000000000000000000000000000000;;			m.data[FilePathSeparator] = mem.CreateDir(FilePathSeparator)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return m.data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (MemMapFs) Name() string { return "MemMapFS" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Create(name string) (File, error) {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		file := mem.CreateFile(name)
0000000000000000000000000000000000000000;;		m.getData()[name] = file
0000000000000000000000000000000000000000;;		m.registerWithParent(file)
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;		return mem.NewFileHandle(file), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) unRegisterWithParent(fileName string) error {
0000000000000000000000000000000000000000;;		f, err := m.lockfreeOpen(fileName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parent := m.findParent(f)
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			log.Panic("parent of ", f.Name(), " is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mem.RemoveFromMemDir(parent, f)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) findParent(f *mem.FileData) *mem.FileData {
0000000000000000000000000000000000000000;;		pdir, _ := filepath.Split(f.Name())
0000000000000000000000000000000000000000;;		pdir = filepath.Clean(pdir)
0000000000000000000000000000000000000000;;		pfile, err := m.lockfreeOpen(pdir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pfile
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) registerWithParent(f *mem.FileData) {
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parent := m.findParent(f)
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			pdir := filepath.Dir(filepath.Clean(f.Name()))
0000000000000000000000000000000000000000;;			err := m.lockfreeMkdir(pdir, 0777)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				//log.Println("Mkdir error:", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parent, err = m.lockfreeOpen(pdir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				//log.Println("Open after Mkdir error:", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mem.InitializeDir(parent)
0000000000000000000000000000000000000000;;		mem.AddToMemDir(parent, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) lockfreeMkdir(name string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;		x, ok := m.getData()[name]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			// Only return ErrFileExists if it's a file, not a directory.
0000000000000000000000000000000000000000;;			i := mem.FileInfo{x}
0000000000000000000000000000000000000000;;			if !i.IsDir() {
0000000000000000000000000000000000000000;;				return ErrFileExists
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			item := mem.CreateDir(name)
0000000000000000000000000000000000000000;;			m.getData()[name] = item
0000000000000000000000000000000000000000;;			m.registerWithParent(item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Mkdir(name string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mu.RLock()
0000000000000000000000000000000000000000;;		_, ok := m.getData()[name]
0000000000000000000000000000000000000000;;		m.mu.RUnlock()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return &os.PathError{"mkdir", name, ErrFileExists}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m.mu.Lock()
0000000000000000000000000000000000000000;;			item := mem.CreateDir(name)
0000000000000000000000000000000000000000;;			m.getData()[name] = item
0000000000000000000000000000000000000000;;			m.registerWithParent(item)
0000000000000000000000000000000000000000;;			m.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) MkdirAll(path string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		err := m.Mkdir(path, perm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err.(*os.PathError).Err == ErrFileExists {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle some relative paths
0000000000000000000000000000000000000000;;	func normalizePath(path string) string {
0000000000000000000000000000000000000000;;		path = filepath.Clean(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch path {
0000000000000000000000000000000000000000;;		case ".":
0000000000000000000000000000000000000000;;			return FilePathSeparator
0000000000000000000000000000000000000000;;		case "..":
0000000000000000000000000000000000000000;;			return FilePathSeparator
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Open(name string) (File, error) {
0000000000000000000000000000000000000000;;		f, err := m.open(name)
0000000000000000000000000000000000000000;;		if f != nil {
0000000000000000000000000000000000000000;;			return mem.NewReadOnlyFileHandle(f), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) openWrite(name string) (File, error) {
0000000000000000000000000000000000000000;;		f, err := m.open(name)
0000000000000000000000000000000000000000;;		if f != nil {
0000000000000000000000000000000000000000;;			return mem.NewFileHandle(f), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) open(name string) (*mem.FileData, error) {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mu.RLock()
0000000000000000000000000000000000000000;;		f, ok := m.getData()[name]
0000000000000000000000000000000000000000;;		m.mu.RUnlock()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{"open", name, ErrFileNotFound}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) lockfreeOpen(name string) (*mem.FileData, error) {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;		f, ok := m.getData()[name]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return f, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, ErrFileNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {
0000000000000000000000000000000000000000;;		file, err := m.openWrite(name)
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) && (flag&os.O_CREATE > 0) {
0000000000000000000000000000000000000000;;			file, err = m.Create(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flag == os.O_RDONLY {
0000000000000000000000000000000000000000;;			file = mem.NewReadOnlyFileHandle(file.(*mem.File).Data())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flag&os.O_APPEND > 0 {
0000000000000000000000000000000000000000;;			_, err = file.Seek(0, os.SEEK_END)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				file.Close()
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flag&os.O_TRUNC > 0 && flag&(os.O_RDWR|os.O_WRONLY) > 0 {
0000000000000000000000000000000000000000;;			err = file.Truncate(0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				file.Close()
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return file, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Remove(name string) error {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		defer m.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := m.getData()[name]; ok {
0000000000000000000000000000000000000000;;			err := m.unRegisterWithParent(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return &os.PathError{"remove", name, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(m.getData(), name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return &os.PathError{"remove", name, os.ErrNotExist}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) RemoveAll(path string) error {
0000000000000000000000000000000000000000;;		path = normalizePath(path)
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		m.unRegisterWithParent(path)
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mu.RLock()
0000000000000000000000000000000000000000;;		defer m.mu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for p, _ := range m.getData() {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(p, path) {
0000000000000000000000000000000000000000;;				m.mu.RUnlock()
0000000000000000000000000000000000000000;;				m.mu.Lock()
0000000000000000000000000000000000000000;;				delete(m.getData(), p)
0000000000000000000000000000000000000000;;				m.mu.Unlock()
0000000000000000000000000000000000000000;;				m.mu.RLock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Rename(oldname, newname string) error {
0000000000000000000000000000000000000000;;		oldname = normalizePath(oldname)
0000000000000000000000000000000000000000;;		newname = normalizePath(newname)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldname == newname {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mu.RLock()
0000000000000000000000000000000000000000;;		defer m.mu.RUnlock()
0000000000000000000000000000000000000000;;		if _, ok := m.getData()[oldname]; ok {
0000000000000000000000000000000000000000;;			m.mu.RUnlock()
0000000000000000000000000000000000000000;;			m.mu.Lock()
0000000000000000000000000000000000000000;;			m.unRegisterWithParent(oldname)
0000000000000000000000000000000000000000;;			fileData := m.getData()[oldname]
0000000000000000000000000000000000000000;;			delete(m.getData(), oldname)
0000000000000000000000000000000000000000;;			mem.ChangeFileName(fileData, newname)
0000000000000000000000000000000000000000;;			m.getData()[newname] = fileData
0000000000000000000000000000000000000000;;			m.registerWithParent(fileData)
0000000000000000000000000000000000000000;;			m.mu.Unlock()
0000000000000000000000000000000000000000;;			m.mu.RLock()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return &os.PathError{"rename", oldname, ErrFileNotFound}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Stat(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		f, err := m.Open(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fi := mem.GetFileInfo(f.(*mem.File).Data())
0000000000000000000000000000000000000000;;		return fi, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Chmod(name string, mode os.FileMode) error {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;		f, ok := m.getData()[name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return &os.PathError{"chmod", name, ErrFileNotFound}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		mem.SetMode(f, mode)
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) Chtimes(name string, atime time.Time, mtime time.Time) error {
0000000000000000000000000000000000000000;;		name = normalizePath(name)
0000000000000000000000000000000000000000;;		f, ok := m.getData()[name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return &os.PathError{"chtimes", name, ErrFileNotFound}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		mem.SetModTime(f, mtime)
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MemMapFs) List() {
0000000000000000000000000000000000000000;;		for _, x := range m.data {
0000000000000000000000000000000000000000;;			y := mem.FileInfo{x}
0000000000000000000000000000000000000000;;			fmt.Println(x.Name(), y.Size())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func debugMemMapList(fs Fs) {
0000000000000000000000000000000000000000;;		if x, ok := fs.(*MemMapFs); ok {
0000000000000000000000000000000000000000;;			x.List()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
