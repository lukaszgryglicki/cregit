0000000000000000000000000000000000000000;;	package afero
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The UnionFile implements the afero.File interface and will be returned
0000000000000000000000000000000000000000;;	// when reading a directory present at least in the overlay or opening a file
0000000000000000000000000000000000000000;;	// for writing.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The calls to
0000000000000000000000000000000000000000;;	// Readdir() and Readdirnames() merge the file os.FileInfo / names from the
0000000000000000000000000000000000000000;;	// base and the overlay - for files present in both layers, only those
0000000000000000000000000000000000000000;;	// from the overlay will be used.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When opening files for writing (Create() / OpenFile() with the right flags)
0000000000000000000000000000000000000000;;	// the operations will be done in both layers, starting with the overlay. A
0000000000000000000000000000000000000000;;	// successful read in the overlay will move the cursor position in the base layer
0000000000000000000000000000000000000000;;	// by the number of bytes read.
0000000000000000000000000000000000000000;;	type UnionFile struct {
0000000000000000000000000000000000000000;;		base  File
0000000000000000000000000000000000000000;;		layer File
0000000000000000000000000000000000000000;;		off   int
0000000000000000000000000000000000000000;;		files []os.FileInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Close() error {
0000000000000000000000000000000000000000;;		// first close base, so we have a newer timestamp in the overlay. If we'd close
0000000000000000000000000000000000000000;;		// the overlay first, we'd get a cacheStale the next time we access this file
0000000000000000000000000000000000000000;;		// -> cache would be useless ;-)
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			f.base.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			return f.layer.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Read(s []byte) (int, error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			n, err := f.layer.Read(s)
0000000000000000000000000000000000000000;;			if (err == nil || err == io.EOF) && f.base != nil {
0000000000000000000000000000000000000000;;				// advance the file position also in the base file, the next
0000000000000000000000000000000000000000;;				// call may be a write at this position (or a seek with SEEK_CUR)
0000000000000000000000000000000000000000;;				if _, seekErr := f.base.Seek(int64(n), os.SEEK_CUR); seekErr != nil {
0000000000000000000000000000000000000000;;					// only overwrite err in case the seek fails: we need to
0000000000000000000000000000000000000000;;					// report an eventual io.EOF to the caller
0000000000000000000000000000000000000000;;					err = seekErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.Read(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) ReadAt(s []byte, o int64) (int, error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			n, err := f.layer.ReadAt(s, o)
0000000000000000000000000000000000000000;;			if (err == nil || err == io.EOF) && f.base != nil {
0000000000000000000000000000000000000000;;				_, err = f.base.Seek(o+int64(n), os.SEEK_SET)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.ReadAt(s, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Seek(o int64, w int) (pos int64, err error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			pos, err = f.layer.Seek(o, w)
0000000000000000000000000000000000000000;;			if (err == nil || err == io.EOF) && f.base != nil {
0000000000000000000000000000000000000000;;				_, err = f.base.Seek(o, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pos, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.Seek(o, w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Write(s []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			n, err = f.layer.Write(s)
0000000000000000000000000000000000000000;;			if err == nil && f.base != nil { // hmm, do we have fixed size files where a write may hit the EOF mark?
0000000000000000000000000000000000000000;;				_, err = f.base.Write(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.Write(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) WriteAt(s []byte, o int64) (n int, err error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			n, err = f.layer.WriteAt(s, o)
0000000000000000000000000000000000000000;;			if err == nil && f.base != nil {
0000000000000000000000000000000000000000;;				_, err = f.base.WriteAt(s, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.WriteAt(s, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Name() string {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			return f.layer.Name()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.base.Name()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Readdir will weave the two directories together and
0000000000000000000000000000000000000000;;	// return a single view of the overlayed directories
0000000000000000000000000000000000000000;;	func (f *UnionFile) Readdir(c int) (ofi []os.FileInfo, err error) {
0000000000000000000000000000000000000000;;		if f.off == 0 {
0000000000000000000000000000000000000000;;			var files = make(map[string]os.FileInfo)
0000000000000000000000000000000000000000;;			var rfi []os.FileInfo
0000000000000000000000000000000000000000;;			if f.layer != nil {
0000000000000000000000000000000000000000;;				rfi, err = f.layer.Readdir(-1)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, fi := range rfi {
0000000000000000000000000000000000000000;;					files[fi.Name()] = fi
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if f.base != nil {
0000000000000000000000000000000000000000;;				rfi, err = f.base.Readdir(-1)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, fi := range rfi {
0000000000000000000000000000000000000000;;					if _, exists := files[fi.Name()]; !exists {
0000000000000000000000000000000000000000;;						files[fi.Name()] = fi
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, fi := range files {
0000000000000000000000000000000000000000;;				f.files = append(f.files, fi)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == -1 {
0000000000000000000000000000000000000000;;			return f.files[f.off:], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() { f.off += c }()
0000000000000000000000000000000000000000;;		return f.files[f.off:c], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Readdirnames(c int) ([]string, error) {
0000000000000000000000000000000000000000;;		rfi, err := f.Readdir(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var names []string
0000000000000000000000000000000000000000;;		for _, fi := range rfi {
0000000000000000000000000000000000000000;;			names = append(names, fi.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Stat() (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			return f.layer.Stat()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.Stat()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Sync() (err error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			err = f.layer.Sync()
0000000000000000000000000000000000000000;;			if err == nil && f.base != nil {
0000000000000000000000000000000000000000;;				err = f.base.Sync()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.Sync()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) Truncate(s int64) (err error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			err = f.layer.Truncate(s)
0000000000000000000000000000000000000000;;			if err == nil && f.base != nil {
0000000000000000000000000000000000000000;;				err = f.base.Truncate(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.Truncate(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *UnionFile) WriteString(s string) (n int, err error) {
0000000000000000000000000000000000000000;;		if f.layer != nil {
0000000000000000000000000000000000000000;;			n, err = f.layer.WriteString(s)
0000000000000000000000000000000000000000;;			if err == nil && f.base != nil {
0000000000000000000000000000000000000000;;				_, err = f.base.WriteString(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.base != nil {
0000000000000000000000000000000000000000;;			return f.base.WriteString(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, BADFD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyToLayer(base Fs, layer Fs, name string) error {
0000000000000000000000000000000000000000;;		bfh, err := base.Open(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer bfh.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First make sure the directory exists
0000000000000000000000000000000000000000;;		exists, err := Exists(layer, filepath.Dir(name))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			err = layer.MkdirAll(filepath.Dir(name), 0777) // FIXME?
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the file on the overlay
0000000000000000000000000000000000000000;;		lfh, err := layer.Create(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := io.Copy(lfh, bfh)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If anything fails, clean up the file
0000000000000000000000000000000000000000;;			layer.Remove(name)
0000000000000000000000000000000000000000;;			lfh.Close()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bfi, err := bfh.Stat()
0000000000000000000000000000000000000000;;		if err != nil || bfi.Size() != n {
0000000000000000000000000000000000000000;;			layer.Remove(name)
0000000000000000000000000000000000000000;;			lfh.Close()
0000000000000000000000000000000000000000;;			return syscall.EIO
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = lfh.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			layer.Remove(name)
0000000000000000000000000000000000000000;;			lfh.Close()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return layer.Chtimes(name, bfi.ModTime(), bfi.ModTime())
0000000000000000000000000000000000000000;;	}
