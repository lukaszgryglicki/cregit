0000000000000000000000000000000000000000;;	package afero
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The BasePathFs restricts all operations to a given path within an Fs.
0000000000000000000000000000000000000000;;	// The given file name to the operations on this Fs will be prepended with
0000000000000000000000000000000000000000;;	// the base path before calling the base Fs.
0000000000000000000000000000000000000000;;	// Any file name (after filepath.Clean()) outside this base path will be
0000000000000000000000000000000000000000;;	// treated as non existing file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that it does not clean the error messages on return, so you may
0000000000000000000000000000000000000000;;	// reveal the real path on errors.
0000000000000000000000000000000000000000;;	type BasePathFs struct {
0000000000000000000000000000000000000000;;		source Fs
0000000000000000000000000000000000000000;;		path   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBasePathFs(source Fs, path string) Fs {
0000000000000000000000000000000000000000;;		return &BasePathFs{source: source, path: path}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// on a file outside the base path it returns the given file name and an error,
0000000000000000000000000000000000000000;;	// else the given file with the base path prepended
0000000000000000000000000000000000000000;;	func (b *BasePathFs) RealPath(name string) (path string, err error) {
0000000000000000000000000000000000000000;;		if err := validateBasePathName(name); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bpath := filepath.Clean(b.path)
0000000000000000000000000000000000000000;;		path = filepath.Clean(filepath.Join(bpath, name))
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(path, bpath) {
0000000000000000000000000000000000000000;;			return name, os.ErrNotExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateBasePathName(name string) error {
0000000000000000000000000000000000000000;;		if runtime.GOOS != "windows" {
0000000000000000000000000000000000000000;;			// Not much to do here;
0000000000000000000000000000000000000000;;			// the virtual file paths all look absolute on *nix.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// On Windows a common mistake would be to provide an absolute OS path
0000000000000000000000000000000000000000;;		// We could strip out the base part, but that would not be very portable.
0000000000000000000000000000000000000000;;		if filepath.IsAbs(name) {
0000000000000000000000000000000000000000;;			return &os.PathError{"realPath", name, errors.New("got a real OS path instead of a virtual")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Chtimes(name string, atime, mtime time.Time) (err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"chtimes", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Chtimes(name, atime, mtime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Chmod(name string, mode os.FileMode) (err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"chmod", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Chmod(name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Name() string {
0000000000000000000000000000000000000000;;		return "BasePathFs"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Stat(name string) (fi os.FileInfo, err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{"stat", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Stat(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Rename(oldname, newname string) (err error) {
0000000000000000000000000000000000000000;;		if oldname, err = b.RealPath(oldname); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"rename", oldname, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newname, err = b.RealPath(newname); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"rename", newname, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Rename(oldname, newname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) RemoveAll(name string) (err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"remove_all", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.RemoveAll(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Remove(name string) (err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"remove", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Remove(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) OpenFile(name string, flag int, mode os.FileMode) (f File, err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{"openfile", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.OpenFile(name, flag, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Open(name string) (f File, err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{"open", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Open(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Mkdir(name string, mode os.FileMode) (err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"mkdir", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Mkdir(name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) MkdirAll(name string, mode os.FileMode) (err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return &os.PathError{"mkdir", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.MkdirAll(name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BasePathFs) Create(name string) (f File, err error) {
0000000000000000000000000000000000000000;;		if name, err = b.RealPath(name); err != nil {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{"create", name, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.source.Create(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// vim: ts=4 sw=4 noexpandtab nolist syn=go
