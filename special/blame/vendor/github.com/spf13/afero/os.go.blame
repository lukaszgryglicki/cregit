0000000000000000000000000000000000000000;;	// Copyright Â© 2014 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	// Copyright 2013 tsuru authors. All rights reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OsFs is a Fs implementation that uses functions provided by the os package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For details in any method, check the documentation of the os package
0000000000000000000000000000000000000000;;	// (http://golang.org/pkg/os/).
0000000000000000000000000000000000000000;;	type OsFs struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOsFs() Fs {
0000000000000000000000000000000000000000;;		return &OsFs{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Name() string { return "OsFs" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Create(name string) (File, error) {
0000000000000000000000000000000000000000;;		f, e := os.Create(name)
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			// while this looks strange, we need to return a bare nil (of type nil) not
0000000000000000000000000000000000000000;;			// a nil value of type *os.File or nil won't be nil
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Mkdir(name string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return os.Mkdir(name, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) MkdirAll(path string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return os.MkdirAll(path, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Open(name string) (File, error) {
0000000000000000000000000000000000000000;;		f, e := os.Open(name)
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			// while this looks strange, we need to return a bare nil (of type nil) not
0000000000000000000000000000000000000000;;			// a nil value of type *os.File or nil won't be nil
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {
0000000000000000000000000000000000000000;;		f, e := os.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			// while this looks strange, we need to return a bare nil (of type nil) not
0000000000000000000000000000000000000000;;			// a nil value of type *os.File or nil won't be nil
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Remove(name string) error {
0000000000000000000000000000000000000000;;		return os.Remove(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) RemoveAll(path string) error {
0000000000000000000000000000000000000000;;		return os.RemoveAll(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Rename(oldname, newname string) error {
0000000000000000000000000000000000000000;;		return os.Rename(oldname, newname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Stat(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return os.Stat(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Chmod(name string, mode os.FileMode) error {
0000000000000000000000000000000000000000;;		return os.Chmod(name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (OsFs) Chtimes(name string, atime time.Time, mtime time.Time) error {
0000000000000000000000000000000000000000;;		return os.Chtimes(name, atime, mtime)
0000000000000000000000000000000000000000;;	}
