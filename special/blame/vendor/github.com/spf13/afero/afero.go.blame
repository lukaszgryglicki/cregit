0000000000000000000000000000000000000000;;	// Copyright Â© 2014 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	// Copyright 2013 tsuru authors. All rights reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// Package afero provides types and methods for interacting with the filesystem,
0000000000000000000000000000000000000000;;	// as an abstraction layer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Afero also provides a few implementations that are mostly interoperable. One that
0000000000000000000000000000000000000000;;	// uses the operating system filesystem, one that uses memory to store files
0000000000000000000000000000000000000000;;	// (cross platform) and an interface that should be implemented if you want to
0000000000000000000000000000000000000000;;	// provide your own filesystem.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Afero struct {
0000000000000000000000000000000000000000;;		Fs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File represents a file in the filesystem.
0000000000000000000000000000000000000000;;	type File interface {
0000000000000000000000000000000000000000;;		io.Closer
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;		io.ReaderAt
0000000000000000000000000000000000000000;;		io.Seeker
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;		io.WriterAt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		Readdir(count int) ([]os.FileInfo, error)
0000000000000000000000000000000000000000;;		Readdirnames(n int) ([]string, error)
0000000000000000000000000000000000000000;;		Stat() (os.FileInfo, error)
0000000000000000000000000000000000000000;;		Sync() error
0000000000000000000000000000000000000000;;		Truncate(size int64) error
0000000000000000000000000000000000000000;;		WriteString(s string) (ret int, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fs is the filesystem interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Any simulated or real filesystem should implement this interface.
0000000000000000000000000000000000000000;;	type Fs interface {
0000000000000000000000000000000000000000;;		// Create creates a file in the filesystem, returning the file and an
0000000000000000000000000000000000000000;;		// error, if any happens.
0000000000000000000000000000000000000000;;		Create(name string) (File, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mkdir creates a directory in the filesystem, return an error if any
0000000000000000000000000000000000000000;;		// happens.
0000000000000000000000000000000000000000;;		Mkdir(name string, perm os.FileMode) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MkdirAll creates a directory path and all parents that does not exist
0000000000000000000000000000000000000000;;		// yet.
0000000000000000000000000000000000000000;;		MkdirAll(path string, perm os.FileMode) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Open opens a file, returning it or an error, if any happens.
0000000000000000000000000000000000000000;;		Open(name string) (File, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OpenFile opens a file using the given flags and the given mode.
0000000000000000000000000000000000000000;;		OpenFile(name string, flag int, perm os.FileMode) (File, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove removes a file identified by name, returning an error, if any
0000000000000000000000000000000000000000;;		// happens.
0000000000000000000000000000000000000000;;		Remove(name string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RemoveAll removes a directory path and all any children it contains. It
0000000000000000000000000000000000000000;;		// does not fail if the path does not exist (return nil).
0000000000000000000000000000000000000000;;		RemoveAll(path string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rename renames a file.
0000000000000000000000000000000000000000;;		Rename(oldname, newname string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stat returns a FileInfo describing the named file, or an error, if any
0000000000000000000000000000000000000000;;		// happens.
0000000000000000000000000000000000000000;;		Stat(name string) (os.FileInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The name of this FileSystem
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//Chmod changes the mode of the named file to mode.
0000000000000000000000000000000000000000;;		Chmod(name string, mode os.FileMode) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//Chtimes changes the access and modification times of the named file
0000000000000000000000000000000000000000;;		Chtimes(name string, atime time.Time, mtime time.Time) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrFileClosed        = errors.New("File is closed")
0000000000000000000000000000000000000000;;		ErrOutOfRange        = errors.New("Out of range")
0000000000000000000000000000000000000000;;		ErrTooLarge          = errors.New("Too large")
0000000000000000000000000000000000000000;;		ErrFileNotFound      = os.ErrNotExist
0000000000000000000000000000000000000000;;		ErrFileExists        = os.ErrExist
0000000000000000000000000000000000000000;;		ErrDestinationExists = os.ErrExist
0000000000000000000000000000000000000000;;	)
