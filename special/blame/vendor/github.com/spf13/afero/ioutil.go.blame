0000000000000000000000000000000000000000;;	// Copyright ©2015 The Go Authors
0000000000000000000000000000000000000000;;	// Copyright ©2015 Steve Francia <spf@spf13.com>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byName implements sort.Interface.
0000000000000000000000000000000000000000;;	type byName []os.FileInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f byName) Len() int           { return len(f) }
0000000000000000000000000000000000000000;;	func (f byName) Less(i, j int) bool { return f[i].Name() < f[j].Name() }
0000000000000000000000000000000000000000;;	func (f byName) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadDir reads the directory named by dirname and returns
0000000000000000000000000000000000000000;;	// a list of sorted directory entries.
0000000000000000000000000000000000000000;;	func (a Afero) ReadDir(dirname string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return ReadDir(a.Fs, dirname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadDir(fs Fs, dirname string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		f, err := fs.Open(dirname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list, err := f.Readdir(-1)
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(byName(list))
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadFile reads the file named by filename and returns the contents.
0000000000000000000000000000000000000000;;	// A successful call returns err == nil, not err == EOF. Because ReadFile
0000000000000000000000000000000000000000;;	// reads the whole file, it does not treat an EOF from Read as an error
0000000000000000000000000000000000000000;;	// to be reported.
0000000000000000000000000000000000000000;;	func (a Afero) ReadFile(filename string) ([]byte, error) {
0000000000000000000000000000000000000000;;		return ReadFile(a.Fs, filename)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadFile(fs Fs, filename string) ([]byte, error) {
0000000000000000000000000000000000000000;;		f, err := fs.Open(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		// It's a good but not certain bet that FileInfo will tell us exactly how much to
0000000000000000000000000000000000000000;;		// read, so let's try it but be prepared for the answer to be wrong.
0000000000000000000000000000000000000000;;		var n int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fi, err := f.Stat(); err == nil {
0000000000000000000000000000000000000000;;			// Don't preallocate a huge buffer, just in case.
0000000000000000000000000000000000000000;;			if size := fi.Size(); size < 1e9 {
0000000000000000000000000000000000000000;;				n = size
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// As initial capacity for readAll, use n + a little extra in case Size is zero,
0000000000000000000000000000000000000000;;		// and to avoid another allocation after Read has filled the buffer.  The readAll
0000000000000000000000000000000000000000;;		// call will read into its allocated internal buffer cheaply.  If the size was
0000000000000000000000000000000000000000;;		// wrong, we'll either waste some space off the end or reallocate as needed, but
0000000000000000000000000000000000000000;;		// in the overwhelmingly common case we'll get it just right.
0000000000000000000000000000000000000000;;		return readAll(f, n+bytes.MinRead)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readAll reads from r until an error or EOF and returns the data it read
0000000000000000000000000000000000000000;;	// from the internal buffer allocated with a specified capacity.
0000000000000000000000000000000000000000;;	func readAll(r io.Reader, capacity int64) (b []byte, err error) {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(make([]byte, 0, capacity))
0000000000000000000000000000000000000000;;		// If the buffer overflows, we will get bytes.ErrTooLarge.
0000000000000000000000000000000000000000;;		// Return that as an error. Any other panic remains.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			e := recover()
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if panicErr, ok := e.(error); ok && panicErr == bytes.ErrTooLarge {
0000000000000000000000000000000000000000;;				err = panicErr
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		_, err = buf.ReadFrom(r)
0000000000000000000000000000000000000000;;		return buf.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadAll reads from r until an error or EOF and returns the data it read.
0000000000000000000000000000000000000000;;	// A successful call returns err == nil, not err == EOF. Because ReadAll is
0000000000000000000000000000000000000000;;	// defined to read from src until EOF, it does not treat an EOF from Read
0000000000000000000000000000000000000000;;	// as an error to be reported.
0000000000000000000000000000000000000000;;	func ReadAll(r io.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		return readAll(r, bytes.MinRead)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteFile writes data to a file named by filename.
0000000000000000000000000000000000000000;;	// If the file does not exist, WriteFile creates it with permissions perm;
0000000000000000000000000000000000000000;;	// otherwise WriteFile truncates it before writing.
0000000000000000000000000000000000000000;;	func (a Afero) WriteFile(filename string, data []byte, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		return WriteFile(a.Fs, filename, data, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WriteFile(fs Fs, filename string, data []byte, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		f, err := fs.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := f.Write(data)
0000000000000000000000000000000000000000;;		if err == nil && n < len(data) {
0000000000000000000000000000000000000000;;			err = io.ErrShortWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err1 := f.Close(); err == nil {
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Random number state.
0000000000000000000000000000000000000000;;	// We generate random temporary file names so that there's a good
0000000000000000000000000000000000000000;;	// chance the file doesn't exist yet - keeps the number of tries in
0000000000000000000000000000000000000000;;	// TempFile to a minimum.
0000000000000000000000000000000000000000;;	var rand uint32
0000000000000000000000000000000000000000;;	var randmu sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reseed() uint32 {
0000000000000000000000000000000000000000;;		return uint32(time.Now().UnixNano() + int64(os.Getpid()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextSuffix() string {
0000000000000000000000000000000000000000;;		randmu.Lock()
0000000000000000000000000000000000000000;;		r := rand
0000000000000000000000000000000000000000;;		if r == 0 {
0000000000000000000000000000000000000000;;			r = reseed()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r = r*1664525 + 1013904223 // constants from Numerical Recipes
0000000000000000000000000000000000000000;;		rand = r
0000000000000000000000000000000000000000;;		randmu.Unlock()
0000000000000000000000000000000000000000;;		return strconv.Itoa(int(1e9 + r%1e9))[1:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TempFile creates a new temporary file in the directory dir
0000000000000000000000000000000000000000;;	// with a name beginning with prefix, opens the file for reading
0000000000000000000000000000000000000000;;	// and writing, and returns the resulting *File.
0000000000000000000000000000000000000000;;	// If dir is the empty string, TempFile uses the default directory
0000000000000000000000000000000000000000;;	// for temporary files (see os.TempDir).
0000000000000000000000000000000000000000;;	// Multiple programs calling TempFile simultaneously
0000000000000000000000000000000000000000;;	// will not choose the same file.  The caller can use f.Name()
0000000000000000000000000000000000000000;;	// to find the pathname of the file.  It is the caller's responsibility
0000000000000000000000000000000000000000;;	// to remove the file when no longer needed.
0000000000000000000000000000000000000000;;	func (a Afero) TempFile(dir, prefix string) (f File, err error) {
0000000000000000000000000000000000000000;;		return TempFile(a.Fs, dir, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TempFile(fs Fs, dir, prefix string) (f File, err error) {
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			dir = os.TempDir()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nconflict := 0
0000000000000000000000000000000000000000;;		for i := 0; i < 10000; i++ {
0000000000000000000000000000000000000000;;			name := filepath.Join(dir, prefix+nextSuffix())
0000000000000000000000000000000000000000;;			f, err = fs.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)
0000000000000000000000000000000000000000;;			if os.IsExist(err) {
0000000000000000000000000000000000000000;;				if nconflict++; nconflict > 10 {
0000000000000000000000000000000000000000;;					randmu.Lock()
0000000000000000000000000000000000000000;;					rand = reseed()
0000000000000000000000000000000000000000;;					randmu.Unlock()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TempDir creates a new temporary directory in the directory dir
0000000000000000000000000000000000000000;;	// with a name beginning with prefix and returns the path of the
0000000000000000000000000000000000000000;;	// new directory.  If dir is the empty string, TempDir uses the
0000000000000000000000000000000000000000;;	// default directory for temporary files (see os.TempDir).
0000000000000000000000000000000000000000;;	// Multiple programs calling TempDir simultaneously
0000000000000000000000000000000000000000;;	// will not choose the same directory.  It is the caller's responsibility
0000000000000000000000000000000000000000;;	// to remove the directory when no longer needed.
0000000000000000000000000000000000000000;;	func (a Afero) TempDir(dir, prefix string) (name string, err error) {
0000000000000000000000000000000000000000;;		return TempDir(a.Fs, dir, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TempDir(fs Fs, dir, prefix string) (name string, err error) {
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			dir = os.TempDir()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nconflict := 0
0000000000000000000000000000000000000000;;		for i := 0; i < 10000; i++ {
0000000000000000000000000000000000000000;;			try := filepath.Join(dir, prefix+nextSuffix())
0000000000000000000000000000000000000000;;			err = fs.Mkdir(try, 0700)
0000000000000000000000000000000000000000;;			if os.IsExist(err) {
0000000000000000000000000000000000000000;;				if nconflict++; nconflict > 10 {
0000000000000000000000000000000000000000;;					randmu.Lock()
0000000000000000000000000000000000000000;;					rand = reseed()
0000000000000000000000000000000000000000;;					randmu.Unlock()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				name = try
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
