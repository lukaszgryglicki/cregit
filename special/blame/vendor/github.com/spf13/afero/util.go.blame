0000000000000000000000000000000000000000;;	// Copyright ©2015 Steve Francia <spf@spf13.com>
0000000000000000000000000000000000000000;;	// Portions Copyright ©2015 The Hugo Authors
0000000000000000000000000000000000000000;;	// Portions Copyright 2016-present Bjørn Erik Pedersen <bjorn.erik.pedersen@gmail.com>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/norm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filepath separator defined by os.Separator.
0000000000000000000000000000000000000000;;	const FilePathSeparator = string(filepath.Separator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Takes a reader and a path and writes the content
0000000000000000000000000000000000000000;;	func (a Afero) WriteReader(path string, r io.Reader) (err error) {
0000000000000000000000000000000000000000;;		return WriteReader(a.Fs, path, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WriteReader(fs Fs, path string, r io.Reader) (err error) {
0000000000000000000000000000000000000000;;		dir, _ := filepath.Split(path)
0000000000000000000000000000000000000000;;		ospath := filepath.FromSlash(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ospath != "" {
0000000000000000000000000000000000000000;;			err = fs.MkdirAll(ospath, 0777) // rwx, rw, r
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != os.ErrExist {
0000000000000000000000000000000000000000;;					log.Panicln(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := fs.Create(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = io.Copy(file, r)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Same as WriteReader but checks to see if file/directory already exists.
0000000000000000000000000000000000000000;;	func (a Afero) SafeWriteReader(path string, r io.Reader) (err error) {
0000000000000000000000000000000000000000;;		return SafeWriteReader(a.Fs, path, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SafeWriteReader(fs Fs, path string, r io.Reader) (err error) {
0000000000000000000000000000000000000000;;		dir, _ := filepath.Split(path)
0000000000000000000000000000000000000000;;		ospath := filepath.FromSlash(dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ospath != "" {
0000000000000000000000000000000000000000;;			err = fs.MkdirAll(ospath, 0777) // rwx, rw, r
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exists, err := Exists(fs, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%v already exists", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := fs.Create(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = io.Copy(file, r)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) GetTempDir(subPath string) string {
0000000000000000000000000000000000000000;;		return GetTempDir(a.Fs, subPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTempDir returns the default temp directory with trailing slash
0000000000000000000000000000000000000000;;	// if subPath is not empty then it will be created recursively with mode 777 rwx rwx rwx
0000000000000000000000000000000000000000;;	func GetTempDir(fs Fs, subPath string) string {
0000000000000000000000000000000000000000;;		addSlash := func(p string) string {
0000000000000000000000000000000000000000;;			if FilePathSeparator != p[len(p)-1:] {
0000000000000000000000000000000000000000;;				p = p + FilePathSeparator
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dir := addSlash(os.TempDir())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if subPath != "" {
0000000000000000000000000000000000000000;;			// preserve windows backslash :-(
0000000000000000000000000000000000000000;;			if FilePathSeparator == "\\" {
0000000000000000000000000000000000000000;;				subPath = strings.Replace(subPath, "\\", "____", -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dir = dir + UnicodeSanitize((subPath))
0000000000000000000000000000000000000000;;			if FilePathSeparator == "\\" {
0000000000000000000000000000000000000000;;				dir = strings.Replace(dir, "____", "\\", -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if exists, _ := Exists(fs, dir); exists {
0000000000000000000000000000000000000000;;				return addSlash(dir)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := fs.MkdirAll(dir, 0777)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dir = addSlash(dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rewrite string to remove non-standard path characters
0000000000000000000000000000000000000000;;	func UnicodeSanitize(s string) string {
0000000000000000000000000000000000000000;;		source := []rune(s)
0000000000000000000000000000000000000000;;		target := make([]rune, 0, len(source))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range source {
0000000000000000000000000000000000000000;;			if unicode.IsLetter(r) ||
0000000000000000000000000000000000000000;;				unicode.IsDigit(r) ||
0000000000000000000000000000000000000000;;				unicode.IsMark(r) ||
0000000000000000000000000000000000000000;;				r == '.' ||
0000000000000000000000000000000000000000;;				r == '/' ||
0000000000000000000000000000000000000000;;				r == '\\' ||
0000000000000000000000000000000000000000;;				r == '_' ||
0000000000000000000000000000000000000000;;				r == '-' ||
0000000000000000000000000000000000000000;;				r == '%' ||
0000000000000000000000000000000000000000;;				r == ' ' ||
0000000000000000000000000000000000000000;;				r == '#' {
0000000000000000000000000000000000000000;;				target = append(target, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform characters with accents into plan forms
0000000000000000000000000000000000000000;;	func NeuterAccents(s string) string {
0000000000000000000000000000000000000000;;		t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.NFC)
0000000000000000000000000000000000000000;;		result, _, _ := transform.String(t, string(s))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isMn(r rune) bool {
0000000000000000000000000000000000000000;;		return unicode.Is(unicode.Mn, r) // Mn: nonspacing marks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) FileContainsBytes(filename string, subslice []byte) (bool, error) {
0000000000000000000000000000000000000000;;		return FileContainsBytes(a.Fs, filename, subslice)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a file contains a specified byte slice.
0000000000000000000000000000000000000000;;	func FileContainsBytes(fs Fs, filename string, subslice []byte) (bool, error) {
0000000000000000000000000000000000000000;;		f, err := fs.Open(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return readerContainsAny(f, subslice), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) FileContainsAnyBytes(filename string, subslices [][]byte) (bool, error) {
0000000000000000000000000000000000000000;;		return FileContainsAnyBytes(a.Fs, filename, subslices)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a file contains any of the specified byte slices.
0000000000000000000000000000000000000000;;	func FileContainsAnyBytes(fs Fs, filename string, subslices [][]byte) (bool, error) {
0000000000000000000000000000000000000000;;		f, err := fs.Open(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return readerContainsAny(f, subslices...), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readerContains reports whether any of the subslices is within r.
0000000000000000000000000000000000000000;;	func readerContainsAny(r io.Reader, subslices ...[]byte) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r == nil || len(subslices) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		largestSlice := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sl := range subslices {
0000000000000000000000000000000000000000;;			if len(sl) > largestSlice {
0000000000000000000000000000000000000000;;				largestSlice = len(sl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if largestSlice == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bufflen := largestSlice * 4
0000000000000000000000000000000000000000;;		halflen := bufflen / 2
0000000000000000000000000000000000000000;;		buff := make([]byte, bufflen)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var n, i int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			if i == 1 {
0000000000000000000000000000000000000000;;				n, err = io.ReadAtLeast(r, buff[:halflen], halflen)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if i != 2 {
0000000000000000000000000000000000000000;;					// shift left to catch overlapping matches
0000000000000000000000000000000000000000;;					copy(buff[:], buff[halflen:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err = io.ReadAtLeast(r, buff[halflen:], halflen)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				for _, sl := range subslices {
0000000000000000000000000000000000000000;;					if bytes.Contains(buff, sl) {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) DirExists(path string) (bool, error) {
0000000000000000000000000000000000000000;;		return DirExists(a.Fs, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirExists checks if a path exists and is a directory.
0000000000000000000000000000000000000000;;	func DirExists(fs Fs, path string) (bool, error) {
0000000000000000000000000000000000000000;;		fi, err := fs.Stat(path)
0000000000000000000000000000000000000000;;		if err == nil && fi.IsDir() {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) IsDir(path string) (bool, error) {
0000000000000000000000000000000000000000;;		return IsDir(a.Fs, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDir checks if a given path is a directory.
0000000000000000000000000000000000000000;;	func IsDir(fs Fs, path string) (bool, error) {
0000000000000000000000000000000000000000;;		fi, err := fs.Stat(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fi.IsDir(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) IsEmpty(path string) (bool, error) {
0000000000000000000000000000000000000000;;		return IsEmpty(a.Fs, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty checks if a given file or directory is empty.
0000000000000000000000000000000000000000;;	func IsEmpty(fs Fs, path string) (bool, error) {
0000000000000000000000000000000000000000;;		if b, _ := Exists(fs, path); !b {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("%q path does not exist", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fi, err := fs.Stat(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fi.IsDir() {
0000000000000000000000000000000000000000;;			f, err := fs.Open(path)
0000000000000000000000000000000000000000;;			defer f.Close()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list, err := f.Readdir(-1)
0000000000000000000000000000000000000000;;			return len(list) == 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fi.Size() == 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Afero) Exists(path string) (bool, error) {
0000000000000000000000000000000000000000;;		return Exists(a.Fs, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a file or directory exists.
0000000000000000000000000000000000000000;;	func Exists(fs Fs, path string) (bool, error) {
0000000000000000000000000000000000000000;;		_, err := fs.Stat(path)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FullBaseFsPath(basePathFs *BasePathFs, relativePath string) string {
0000000000000000000000000000000000000000;;		combinedPath := filepath.Join(basePathFs.path, relativePath)
0000000000000000000000000000000000000000;;		if parent, ok := basePathFs.source.(*BasePathFs); ok {
0000000000000000000000000000000000000000;;			return FullBaseFsPath(parent, combinedPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return combinedPath
0000000000000000000000000000000000000000;;	}
