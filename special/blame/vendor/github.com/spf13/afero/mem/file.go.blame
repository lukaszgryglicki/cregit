0000000000000000000000000000000000000000;;	// Copyright Â© 2015 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	// Copyright 2013 tsuru authors. All rights reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package mem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const FilePathSeparator = string(filepath.Separator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		// atomic requires 64-bit alignment for struct field access
0000000000000000000000000000000000000000;;		at           int64
0000000000000000000000000000000000000000;;		readDirCount int64
0000000000000000000000000000000000000000;;		closed       bool
0000000000000000000000000000000000000000;;		readOnly     bool
0000000000000000000000000000000000000000;;		fileData     *FileData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFileHandle(data *FileData) *File {
0000000000000000000000000000000000000000;;		return &File{fileData: data}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewReadOnlyFileHandle(data *FileData) *File {
0000000000000000000000000000000000000000;;		return &File{fileData: data, readOnly: true}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f File) Data() *FileData {
0000000000000000000000000000000000000000;;		return f.fileData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FileData struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		name    string
0000000000000000000000000000000000000000;;		data    []byte
0000000000000000000000000000000000000000;;		memDir  Dir
0000000000000000000000000000000000000000;;		dir     bool
0000000000000000000000000000000000000000;;		mode    os.FileMode
0000000000000000000000000000000000000000;;		modtime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d FileData) Name() string {
0000000000000000000000000000000000000000;;		return d.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateFile(name string) *FileData {
0000000000000000000000000000000000000000;;		return &FileData{name: name, mode: os.ModeTemporary, modtime: time.Now()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateDir(name string) *FileData {
0000000000000000000000000000000000000000;;		return &FileData{name: name, memDir: &DirMap{}, dir: true}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ChangeFileName(f *FileData, newname string) {
0000000000000000000000000000000000000000;;		f.name = newname
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetMode(f *FileData, mode os.FileMode) {
0000000000000000000000000000000000000000;;		f.mode = mode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetModTime(f *FileData, mtime time.Time) {
0000000000000000000000000000000000000000;;		f.modtime = mtime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetFileInfo(f *FileData) *FileInfo {
0000000000000000000000000000000000000000;;		return &FileInfo{f}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Open() error {
0000000000000000000000000000000000000000;;		atomic.StoreInt64(&f.at, 0)
0000000000000000000000000000000000000000;;		atomic.StoreInt64(&f.readDirCount, 0)
0000000000000000000000000000000000000000;;		f.fileData.Lock()
0000000000000000000000000000000000000000;;		f.closed = false
0000000000000000000000000000000000000000;;		f.fileData.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Close() error {
0000000000000000000000000000000000000000;;		f.fileData.Lock()
0000000000000000000000000000000000000000;;		f.closed = true
0000000000000000000000000000000000000000;;		if !f.readOnly {
0000000000000000000000000000000000000000;;			SetModTime(f.fileData, time.Now())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.fileData.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Name() string {
0000000000000000000000000000000000000000;;		return f.fileData.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Stat() (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return &FileInfo{f.fileData}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Sync() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Readdir(count int) (res []os.FileInfo, err error) {
0000000000000000000000000000000000000000;;		var outLength int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.fileData.Lock()
0000000000000000000000000000000000000000;;		files := f.fileData.memDir.Files()[f.readDirCount:]
0000000000000000000000000000000000000000;;		if count > 0 {
0000000000000000000000000000000000000000;;			if len(files) < count {
0000000000000000000000000000000000000000;;				outLength = int64(len(files))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				outLength = int64(count)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(files) == 0 {
0000000000000000000000000000000000000000;;				err = io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			outLength = int64(len(files))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.readDirCount += outLength
0000000000000000000000000000000000000000;;		f.fileData.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res = make([]os.FileInfo, outLength)
0000000000000000000000000000000000000000;;		for i := range res {
0000000000000000000000000000000000000000;;			res[i] = &FileInfo{files[i]}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Readdirnames(n int) (names []string, err error) {
0000000000000000000000000000000000000000;;		fi, err := f.Readdir(n)
0000000000000000000000000000000000000000;;		names = make([]string, len(fi))
0000000000000000000000000000000000000000;;		for i, f := range fi {
0000000000000000000000000000000000000000;;			_, names[i] = filepath.Split(f.Name())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Read(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		f.fileData.Lock()
0000000000000000000000000000000000000000;;		defer f.fileData.Unlock()
0000000000000000000000000000000000000000;;		if f.closed == true {
0000000000000000000000000000000000000000;;			return 0, ErrFileClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b) > 0 && int(f.at) == len(f.fileData.data) {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(f.fileData.data)-int(f.at) >= len(b) {
0000000000000000000000000000000000000000;;			n = len(b)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n = len(f.fileData.data) - int(f.at)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(b, f.fileData.data[f.at:f.at+int64(n)])
0000000000000000000000000000000000000000;;		atomic.AddInt64(&f.at, int64(n))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) ReadAt(b []byte, off int64) (n int, err error) {
0000000000000000000000000000000000000000;;		atomic.StoreInt64(&f.at, off)
0000000000000000000000000000000000000000;;		return f.Read(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Truncate(size int64) error {
0000000000000000000000000000000000000000;;		if f.closed == true {
0000000000000000000000000000000000000000;;			return ErrFileClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.readOnly {
0000000000000000000000000000000000000000;;			return &os.PathError{"truncate", f.fileData.name, errors.New("file handle is read only")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if size < 0 {
0000000000000000000000000000000000000000;;			return ErrOutOfRange
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if size > int64(len(f.fileData.data)) {
0000000000000000000000000000000000000000;;			diff := size - int64(len(f.fileData.data))
0000000000000000000000000000000000000000;;			f.fileData.data = append(f.fileData.data, bytes.Repeat([]byte{00}, int(diff))...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f.fileData.data = f.fileData.data[0:size]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		SetModTime(f.fileData, time.Now())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Seek(offset int64, whence int) (int64, error) {
0000000000000000000000000000000000000000;;		if f.closed == true {
0000000000000000000000000000000000000000;;			return 0, ErrFileClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch whence {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			atomic.StoreInt64(&f.at, offset)
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			atomic.AddInt64(&f.at, int64(offset))
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			atomic.StoreInt64(&f.at, int64(len(f.fileData.data))+offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.at, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Write(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if f.readOnly {
0000000000000000000000000000000000000000;;			return 0, &os.PathError{"write", f.fileData.name, errors.New("file handle is read only")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n = len(b)
0000000000000000000000000000000000000000;;		cur := atomic.LoadInt64(&f.at)
0000000000000000000000000000000000000000;;		f.fileData.Lock()
0000000000000000000000000000000000000000;;		defer f.fileData.Unlock()
0000000000000000000000000000000000000000;;		diff := cur - int64(len(f.fileData.data))
0000000000000000000000000000000000000000;;		var tail []byte
0000000000000000000000000000000000000000;;		if n+int(cur) < len(f.fileData.data) {
0000000000000000000000000000000000000000;;			tail = f.fileData.data[n+int(cur):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if diff > 0 {
0000000000000000000000000000000000000000;;			f.fileData.data = append(bytes.Repeat([]byte{00}, int(diff)), b...)
0000000000000000000000000000000000000000;;			f.fileData.data = append(f.fileData.data, tail...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f.fileData.data = append(f.fileData.data[:cur], b...)
0000000000000000000000000000000000000000;;			f.fileData.data = append(f.fileData.data, tail...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		SetModTime(f.fileData, time.Now())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		atomic.StoreInt64(&f.at, int64(len(f.fileData.data)))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) WriteAt(b []byte, off int64) (n int, err error) {
0000000000000000000000000000000000000000;;		atomic.StoreInt64(&f.at, off)
0000000000000000000000000000000000000000;;		return f.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) WriteString(s string) (ret int, err error) {
0000000000000000000000000000000000000000;;		return f.Write([]byte(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Info() *FileInfo {
0000000000000000000000000000000000000000;;		return &FileInfo{f.fileData}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FileInfo struct {
0000000000000000000000000000000000000000;;		*FileData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements os.FileInfo
0000000000000000000000000000000000000000;;	func (s *FileInfo) Name() string {
0000000000000000000000000000000000000000;;		_, name := filepath.Split(s.name)
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s *FileInfo) Mode() os.FileMode  { return s.mode }
0000000000000000000000000000000000000000;;	func (s *FileInfo) ModTime() time.Time { return s.modtime }
0000000000000000000000000000000000000000;;	func (s *FileInfo) IsDir() bool        { return s.dir }
0000000000000000000000000000000000000000;;	func (s *FileInfo) Sys() interface{}   { return nil }
0000000000000000000000000000000000000000;;	func (s *FileInfo) Size() int64 {
0000000000000000000000000000000000000000;;		if s.IsDir() {
0000000000000000000000000000000000000000;;			return int64(42)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(len(s.data))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrFileClosed        = errors.New("File is closed")
0000000000000000000000000000000000000000;;		ErrOutOfRange        = errors.New("Out of range")
0000000000000000000000000000000000000000;;		ErrTooLarge          = errors.New("Too large")
0000000000000000000000000000000000000000;;		ErrFileNotFound      = os.ErrNotExist
0000000000000000000000000000000000000000;;		ErrFileExists        = os.ErrExist
0000000000000000000000000000000000000000;;		ErrDestinationExists = os.ErrExist
0000000000000000000000000000000000000000;;	)
