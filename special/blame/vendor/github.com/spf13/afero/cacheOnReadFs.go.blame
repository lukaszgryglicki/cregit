0000000000000000000000000000000000000000;;	package afero
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If the cache duration is 0, cache time will be unlimited, i.e. once
0000000000000000000000000000000000000000;;	// a file is in the layer, the base will never be read again for this file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For cache times greater than 0, the modification time of a file is
0000000000000000000000000000000000000000;;	// checked. Note that a lot of file system implementations only allow a
0000000000000000000000000000000000000000;;	// resolution of a second for timestamps... or as the godoc for os.Chtimes()
0000000000000000000000000000000000000000;;	// states: "The underlying filesystem may truncate or round the values to a
0000000000000000000000000000000000000000;;	// less precise time unit."
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This caching union will forward all write calls also to the base file
0000000000000000000000000000000000000000;;	// system first. To prevent writing to the base Fs, wrap it in a read-only
0000000000000000000000000000000000000000;;	// filter - Note: this will also make the overlay read-only, for writing files
0000000000000000000000000000000000000000;;	// in the overlay, use the overlay Fs directly, not via the union Fs.
0000000000000000000000000000000000000000;;	type CacheOnReadFs struct {
0000000000000000000000000000000000000000;;		base      Fs
0000000000000000000000000000000000000000;;		layer     Fs
0000000000000000000000000000000000000000;;		cacheTime time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCacheOnReadFs(base Fs, layer Fs, cacheTime time.Duration) Fs {
0000000000000000000000000000000000000000;;		return &CacheOnReadFs{base: base, layer: layer, cacheTime: cacheTime}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cacheState int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cacheUnknown cacheState = iota
0000000000000000000000000000000000000000;;		// not present in the overlay, unknown if it exists in the base:
0000000000000000000000000000000000000000;;		cacheMiss
0000000000000000000000000000000000000000;;		// present in the overlay and in base, base file is newer:
0000000000000000000000000000000000000000;;		cacheStale
0000000000000000000000000000000000000000;;		// present in the overlay - with cache time == 0 it may exist in the base,
0000000000000000000000000000000000000000;;		// with cacheTime > 0 it exists in the base and is same age or newer in the
0000000000000000000000000000000000000000;;		// overlay
0000000000000000000000000000000000000000;;		cacheHit
0000000000000000000000000000000000000000;;		// happens if someone writes directly to the overlay without
0000000000000000000000000000000000000000;;		// going through this union
0000000000000000000000000000000000000000;;		cacheLocal
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) cacheStatus(name string) (state cacheState, fi os.FileInfo, err error) {
0000000000000000000000000000000000000000;;		var lfi, bfi os.FileInfo
0000000000000000000000000000000000000000;;		lfi, err = u.layer.Stat(name)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if u.cacheTime == 0 {
0000000000000000000000000000000000000000;;				return cacheHit, lfi, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lfi.ModTime().Add(u.cacheTime).Before(time.Now()) {
0000000000000000000000000000000000000000;;				bfi, err = u.base.Stat(name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return cacheLocal, lfi, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if bfi.ModTime().After(lfi.ModTime()) {
0000000000000000000000000000000000000000;;					return cacheStale, bfi, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cacheHit, lfi, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == syscall.ENOENT {
0000000000000000000000000000000000000000;;			return cacheMiss, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if err, ok = err.(*os.PathError); ok {
0000000000000000000000000000000000000000;;			if err == os.ErrNotExist {
0000000000000000000000000000000000000000;;				return cacheMiss, nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cacheMiss, nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) copyToLayer(name string) error {
0000000000000000000000000000000000000000;;		return copyToLayer(u.base, u.layer, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Chtimes(name string, atime, mtime time.Time) error {
0000000000000000000000000000000000000000;;		st, _, err := u.cacheStatus(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheLocal:
0000000000000000000000000000000000000000;;		case cacheHit:
0000000000000000000000000000000000000000;;			err = u.base.Chtimes(name, atime, mtime)
0000000000000000000000000000000000000000;;		case cacheStale, cacheMiss:
0000000000000000000000000000000000000000;;			if err := u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = u.base.Chtimes(name, atime, mtime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.Chtimes(name, atime, mtime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Chmod(name string, mode os.FileMode) error {
0000000000000000000000000000000000000000;;		st, _, err := u.cacheStatus(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheLocal:
0000000000000000000000000000000000000000;;		case cacheHit:
0000000000000000000000000000000000000000;;			err = u.base.Chmod(name, mode)
0000000000000000000000000000000000000000;;		case cacheStale, cacheMiss:
0000000000000000000000000000000000000000;;			if err := u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = u.base.Chmod(name, mode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.Chmod(name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Stat(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		st, fi, err := u.cacheStatus(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheMiss:
0000000000000000000000000000000000000000;;			return u.base.Stat(name)
0000000000000000000000000000000000000000;;		default: // cacheStale has base, cacheHit and cacheLocal the layer os.FileInfo
0000000000000000000000000000000000000000;;			return fi, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Rename(oldname, newname string) error {
0000000000000000000000000000000000000000;;		st, _, err := u.cacheStatus(oldname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheLocal:
0000000000000000000000000000000000000000;;		case cacheHit:
0000000000000000000000000000000000000000;;			err = u.base.Rename(oldname, newname)
0000000000000000000000000000000000000000;;		case cacheStale, cacheMiss:
0000000000000000000000000000000000000000;;			if err := u.copyToLayer(oldname); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = u.base.Rename(oldname, newname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.Rename(oldname, newname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Remove(name string) error {
0000000000000000000000000000000000000000;;		st, _, err := u.cacheStatus(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheLocal:
0000000000000000000000000000000000000000;;		case cacheHit, cacheStale, cacheMiss:
0000000000000000000000000000000000000000;;			err = u.base.Remove(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.Remove(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) RemoveAll(name string) error {
0000000000000000000000000000000000000000;;		st, _, err := u.cacheStatus(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheLocal:
0000000000000000000000000000000000000000;;		case cacheHit, cacheStale, cacheMiss:
0000000000000000000000000000000000000000;;			err = u.base.RemoveAll(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.RemoveAll(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {
0000000000000000000000000000000000000000;;		st, _, err := u.cacheStatus(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheLocal, cacheHit:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if err := u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flag&(os.O_WRONLY|syscall.O_RDWR|os.O_APPEND|os.O_CREATE|os.O_TRUNC) != 0 {
0000000000000000000000000000000000000000;;			bfi, err := u.base.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lfi, err := u.layer.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				bfi.Close() // oops, what if O_TRUNC was set and file opening in the layer failed...?
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &UnionFile{base: bfi, layer: lfi}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Open(name string) (File, error) {
0000000000000000000000000000000000000000;;		st, fi, err := u.cacheStatus(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case cacheLocal:
0000000000000000000000000000000000000000;;			return u.layer.Open(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case cacheMiss:
0000000000000000000000000000000000000000;;			bfi, err := u.base.Stat(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bfi.IsDir() {
0000000000000000000000000000000000000000;;				return u.base.Open(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return u.layer.Open(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case cacheStale:
0000000000000000000000000000000000000000;;			if !fi.IsDir() {
0000000000000000000000000000000000000000;;				if err := u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return u.layer.Open(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case cacheHit:
0000000000000000000000000000000000000000;;			if !fi.IsDir() {
0000000000000000000000000000000000000000;;				return u.layer.Open(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the dirs from cacheHit, cacheStale fall down here:
0000000000000000000000000000000000000000;;		bfile, _ := u.base.Open(name)
0000000000000000000000000000000000000000;;		lfile, err := u.layer.Open(name)
0000000000000000000000000000000000000000;;		if err != nil && bfile == nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &UnionFile{base: bfile, layer: lfile}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Mkdir(name string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		err := u.base.Mkdir(name, perm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.MkdirAll(name, perm) // yes, MkdirAll... we cannot assume it exists in the cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Name() string {
0000000000000000000000000000000000000000;;		return "CacheOnReadFs"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) MkdirAll(name string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		err := u.base.MkdirAll(name, perm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.MkdirAll(name, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CacheOnReadFs) Create(name string) (File, error) {
0000000000000000000000000000000000000000;;		bfh, err := u.base.Create(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lfh, err := u.layer.Create(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// oops, see comment about OS_TRUNC above, should we remove? then we have to
0000000000000000000000000000000000000000;;			// remember if the file did not exist before
0000000000000000000000000000000000000000;;			bfh.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &UnionFile{base: bfh, layer: lfh}, nil
0000000000000000000000000000000000000000;;	}
