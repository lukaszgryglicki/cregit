0000000000000000000000000000000000000000;;	package afero
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The CopyOnWriteFs is a union filesystem: a read only base file system with
0000000000000000000000000000000000000000;;	// a possibly writeable layer on top. Changes to the file system will only
0000000000000000000000000000000000000000;;	// be made in the overlay: Changing an existing file in the base layer which
0000000000000000000000000000000000000000;;	// is not present in the overlay will copy the file to the overlay ("changing"
0000000000000000000000000000000000000000;;	// includes also calls to e.g. Chtimes() and Chmod()).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Reading directories is currently only supported via Open(), not OpenFile().
0000000000000000000000000000000000000000;;	type CopyOnWriteFs struct {
0000000000000000000000000000000000000000;;		base  Fs
0000000000000000000000000000000000000000;;		layer Fs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCopyOnWriteFs(base Fs, layer Fs) Fs {
0000000000000000000000000000000000000000;;		return &CopyOnWriteFs{base: base, layer: layer}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if the file is not in the overlay
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) isBaseFile(name string) (bool, error) {
0000000000000000000000000000000000000000;;		if _, err := u.layer.Stat(name); err == nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := u.base.Stat(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if oerr, ok := err.(*os.PathError); ok {
0000000000000000000000000000000000000000;;				if oerr.Err == os.ErrNotExist || oerr.Err == syscall.ENOENT || oerr.Err == syscall.ENOTDIR {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == syscall.ENOENT {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) copyToLayer(name string) error {
0000000000000000000000000000000000000000;;		return copyToLayer(u.base, u.layer, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Chtimes(name string, atime, mtime time.Time) error {
0000000000000000000000000000000000000000;;		b, err := u.isBaseFile(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			if err := u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.Chtimes(name, atime, mtime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Chmod(name string, mode os.FileMode) error {
0000000000000000000000000000000000000000;;		b, err := u.isBaseFile(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			if err := u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.Chmod(name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Stat(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		fi, err := u.layer.Stat(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			origErr := err
0000000000000000000000000000000000000000;;			if e, ok := err.(*os.PathError); ok {
0000000000000000000000000000000000000000;;				err = e.Err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == syscall.ENOENT || err == syscall.ENOTDIR {
0000000000000000000000000000000000000000;;				return u.base.Stat(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, origErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fi, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Renaming files present only in the base layer is not permitted
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Rename(oldname, newname string) error {
0000000000000000000000000000000000000000;;		b, err := u.isBaseFile(oldname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			return syscall.EPERM
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.Rename(oldname, newname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removing files present only in the base layer is not permitted. If
0000000000000000000000000000000000000000;;	// a file is present in the base layer and the overlay, only the overlay
0000000000000000000000000000000000000000;;	// will be removed.
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Remove(name string) error {
0000000000000000000000000000000000000000;;		err := u.layer.Remove(name)
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case syscall.ENOENT:
0000000000000000000000000000000000000000;;			_, err = u.base.Stat(name)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return syscall.EPERM
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return syscall.ENOENT
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) RemoveAll(name string) error {
0000000000000000000000000000000000000000;;		err := u.layer.RemoveAll(name)
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case syscall.ENOENT:
0000000000000000000000000000000000000000;;			_, err = u.base.Stat(name)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return syscall.EPERM
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return syscall.ENOENT
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) OpenFile(name string, flag int, perm os.FileMode) (File, error) {
0000000000000000000000000000000000000000;;		b, err := u.isBaseFile(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flag&(os.O_WRONLY|os.O_RDWR|os.O_APPEND|os.O_CREATE|os.O_TRUNC) != 0 {
0000000000000000000000000000000000000000;;			if b {
0000000000000000000000000000000000000000;;				if err = u.copyToLayer(name); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return u.layer.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dir := filepath.Dir(name)
0000000000000000000000000000000000000000;;			isaDir, err := IsDir(u.base, dir)
0000000000000000000000000000000000000000;;			if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isaDir {
0000000000000000000000000000000000000000;;				if err = u.layer.MkdirAll(dir, 0777); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return u.layer.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isaDir, err = IsDir(u.layer, dir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isaDir {
0000000000000000000000000000000000000000;;				return u.layer.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, &os.PathError{Op: "open", Path: name, Err: syscall.ENOTDIR} // ...or os.ErrNotExist?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			return u.base.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.OpenFile(name, flag, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function handles the 9 different possibilities caused
0000000000000000000000000000000000000000;;	// by the union which are the intersection of the following...
0000000000000000000000000000000000000000;;	//  layer: doesn't exist, exists as a file, and exists as a directory
0000000000000000000000000000000000000000;;	//  base:  doesn't exist, exists as a file, and exists as a directory
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Open(name string) (File, error) {
0000000000000000000000000000000000000000;;		// Since the overlay overrides the base we check that first
0000000000000000000000000000000000000000;;		b, err := u.isBaseFile(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If overlay doesn't exist, return the base (base state irrelevant)
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			return u.base.Open(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If overlay is a file, return it (base state irrelevant)
0000000000000000000000000000000000000000;;		dir, err := IsDir(u.layer, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dir {
0000000000000000000000000000000000000000;;			return u.layer.Open(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Overlay is a directory, base state now matters.
0000000000000000000000000000000000000000;;		// Base state has 3 states to check but 2 outcomes:
0000000000000000000000000000000000000000;;		// A. It's a file or non-readable in the base (return just the overlay)
0000000000000000000000000000000000000000;;		// B. It's an accessible directory in the base (return a UnionFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If base is file or nonreadable, return overlay
0000000000000000000000000000000000000000;;		dir, err = IsDir(u.base, name)
0000000000000000000000000000000000000000;;		if !dir || err != nil {
0000000000000000000000000000000000000000;;			return u.layer.Open(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Both base & layer are directories
0000000000000000000000000000000000000000;;		// Return union file (if opens are without error)
0000000000000000000000000000000000000000;;		bfile, bErr := u.base.Open(name)
0000000000000000000000000000000000000000;;		lfile, lErr := u.layer.Open(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If either have errors at this point something is very wrong. Return nil and the errors
0000000000000000000000000000000000000000;;		if bErr != nil || lErr != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("BaseErr: %v\nOverlayErr: %v", bErr, lErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &UnionFile{base: bfile, layer: lfile}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Mkdir(name string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		dir, err := IsDir(u.base, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return u.layer.MkdirAll(name, perm)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dir {
0000000000000000000000000000000000000000;;			return syscall.EEXIST
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.MkdirAll(name, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Name() string {
0000000000000000000000000000000000000000;;		return "CopyOnWriteFs"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) MkdirAll(name string, perm os.FileMode) error {
0000000000000000000000000000000000000000;;		dir, err := IsDir(u.base, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return u.layer.MkdirAll(name, perm)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dir {
0000000000000000000000000000000000000000;;			return syscall.EEXIST
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.layer.MkdirAll(name, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *CopyOnWriteFs) Create(name string) (File, error) {
0000000000000000000000000000000000000000;;		return u.OpenFile(name, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0666)
0000000000000000000000000000000000000000;;	}
