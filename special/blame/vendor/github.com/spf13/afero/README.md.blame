0000000000000000000000000000000000000000;;	![afero logo-sm](https://cloud.githubusercontent.com/assets/173412/11490338/d50e16dc-97a5-11e5-8b12-019a300d0fcb.png)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A FileSystem Abstraction System for Go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![Build Status](https://travis-ci.org/spf13/afero.svg)](https://travis-ci.org/spf13/afero) [![Build status](https://ci.appveyor.com/api/projects/status/github/spf13/afero?branch=master&svg=true)](https://ci.appveyor.com/project/spf13/afero) [![GoDoc](https://godoc.org/github.com/spf13/afero?status.svg)](https://godoc.org/github.com/spf13/afero) [![Join the chat at https://gitter.im/spf13/afero](https://badges.gitter.im/Dev%20Chat.svg)](https://gitter.im/spf13/afero?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Overview
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero is an filesystem framework providing a simple, uniform and universal API
0000000000000000000000000000000000000000;;	interacting with any filesystem, as an abstraction layer providing interfaces,
0000000000000000000000000000000000000000;;	types and methods. Afero has an exceptionally clean interface and simple design
0000000000000000000000000000000000000000;;	without needless constructors or initialization methods.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero is also a library providing a base set of interoperable backend
0000000000000000000000000000000000000000;;	filesystems that make it easy to work with afero while retaining all the power
0000000000000000000000000000000000000000;;	and benefit of the os and ioutil packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero provides significant improvements over using the os package alone, most
0000000000000000000000000000000000000000;;	notably the ability to create mock and testing filesystems without relying on the disk.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It is suitable for use in a any situation where you would consider using the OS
0000000000000000000000000000000000000000;;	package as it provides an additional abstraction that makes it easy to use a
0000000000000000000000000000000000000000;;	memory backed file system during testing. It also adds support for the http
0000000000000000000000000000000000000000;;	filesystem for full interoperability.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Afero Features
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* A single consistent API for accessing a variety of filesystems
0000000000000000000000000000000000000000;;	* Interoperation between a variety of file system types
0000000000000000000000000000000000000000;;	* A set of interfaces to encourage and enforce interoperability between backends
0000000000000000000000000000000000000000;;	* An atomic cross platform memory backed file system
0000000000000000000000000000000000000000;;	* Support for compositional (union) file systems by combining multiple file systems acting as one
0000000000000000000000000000000000000000;;	* Specialized backends which modify existing filesystems (Read Only, Regexp filtered)
0000000000000000000000000000000000000000;;	* A set of utility functions ported from io, ioutil & hugo to be afero aware
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Using Afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero is easy to use and easier to adopt.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A few different ways you could use Afero:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Use the interfaces alone to define you own file system.
0000000000000000000000000000000000000000;;	* Wrap for the OS packages.
0000000000000000000000000000000000000000;;	* Define different filesystems for different parts of your application.
0000000000000000000000000000000000000000;;	* Use Afero for mock filesystems while testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Step 1: Install Afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	First use go get to install the latest version of the library.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    $ go get github.com/spf13/afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Next include Afero in your application.
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	import "github.com/spf13/afero"
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Step 2: Declare a backend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	First define a package variable and set it to a pointer to a filesystem.
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	var AppFs afero.Fs = afero.NewMemMapFs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	or
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var AppFs afero.Fs = afero.NewOsFs()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	It is important to note that if you repeat the composite literal you
0000000000000000000000000000000000000000;;	will be using a completely new and isolated filesystem. In the case of
0000000000000000000000000000000000000000;;	OsFs it will still use the same underlying filesystem but will reduce
0000000000000000000000000000000000000000;;	the ability to drop in other filesystems as desired.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Step 3: Use it like you would the OS package
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Throughout your application use any function and method like you normally
0000000000000000000000000000000000000000;;	would.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	So if my application before had:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	os.Open('/tmp/foo')
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	We would replace it with a call to `AppFs.Open('/tmp/foo')`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`AppFs` being the variable we defined above.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## List of all available functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	File System Methods Available:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	Chmod(name string, mode os.FileMode) : error
0000000000000000000000000000000000000000;;	Chtimes(name string, atime time.Time, mtime time.Time) : error
0000000000000000000000000000000000000000;;	Create(name string) : File, error
0000000000000000000000000000000000000000;;	Mkdir(name string, perm os.FileMode) : error
0000000000000000000000000000000000000000;;	MkdirAll(path string, perm os.FileMode) : error
0000000000000000000000000000000000000000;;	Name() : string
0000000000000000000000000000000000000000;;	Open(name string) : File, error
0000000000000000000000000000000000000000;;	OpenFile(name string, flag int, perm os.FileMode) : File, error
0000000000000000000000000000000000000000;;	Remove(name string) : error
0000000000000000000000000000000000000000;;	RemoveAll(path string) : error
0000000000000000000000000000000000000000;;	Rename(oldname, newname string) : error
0000000000000000000000000000000000000000;;	Stat(name string) : os.FileInfo, error
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	File Interfaces and Methods Available:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	io.Closer
0000000000000000000000000000000000000000;;	io.Reader
0000000000000000000000000000000000000000;;	io.ReaderAt
0000000000000000000000000000000000000000;;	io.Seeker
0000000000000000000000000000000000000000;;	io.Writer
0000000000000000000000000000000000000000;;	io.WriterAt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Name() : string
0000000000000000000000000000000000000000;;	Readdir(count int) : []os.FileInfo, error
0000000000000000000000000000000000000000;;	Readdirnames(n int) : []string, error
0000000000000000000000000000000000000000;;	Stat() : os.FileInfo, error
0000000000000000000000000000000000000000;;	Sync() : error
0000000000000000000000000000000000000000;;	Truncate(size int64) : error
0000000000000000000000000000000000000000;;	WriteString(s string) : ret int, err error
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	In some applications it may make sense to define a new package that
0000000000000000000000000000000000000000;;	simply exports the file system variable for easy access from anywhere.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Using Afero's utility functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero provides a set of functions to make it easier to use the underlying file systems.
0000000000000000000000000000000000000000;;	These functions have been primarily ported from io & ioutil with some developed for Hugo.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The afero utilities support all afero compatible backends.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The list of utilities includes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	DirExists(path string) (bool, error)
0000000000000000000000000000000000000000;;	Exists(path string) (bool, error)
0000000000000000000000000000000000000000;;	FileContainsBytes(filename string, subslice []byte) (bool, error)
0000000000000000000000000000000000000000;;	GetTempDir(subPath string) string
0000000000000000000000000000000000000000;;	IsDir(path string) (bool, error)
0000000000000000000000000000000000000000;;	IsEmpty(path string) (bool, error)
0000000000000000000000000000000000000000;;	ReadDir(dirname string) ([]os.FileInfo, error)
0000000000000000000000000000000000000000;;	ReadFile(filename string) ([]byte, error)
0000000000000000000000000000000000000000;;	SafeWriteReader(path string, r io.Reader) (err error)
0000000000000000000000000000000000000000;;	TempDir(dir, prefix string) (name string, err error)
0000000000000000000000000000000000000000;;	TempFile(dir, prefix string) (f File, err error)
0000000000000000000000000000000000000000;;	Walk(root string, walkFn filepath.WalkFunc) error
0000000000000000000000000000000000000000;;	WriteFile(filename string, data []byte, perm os.FileMode) error
0000000000000000000000000000000000000000;;	WriteReader(path string, r io.Reader) (err error)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	For a complete list see [Afero's GoDoc](https://godoc.org/github.com/spf13/afero)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	They are available under two different approaches to use. You can either call
0000000000000000000000000000000000000000;;	them directly where the first parameter of each function will be the file
0000000000000000000000000000000000000000;;	system, or you can declare a new `Afero`, a custom type used to bind these
0000000000000000000000000000000000000000;;	functions as methods to a given filesystem.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Calling utilities directly
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	fs := new(afero.MemMapFs)
0000000000000000000000000000000000000000;;	f, err := afero.TempFile(fs,"", "ioutil-test")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Calling via Afero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	fs := afero.NewMemMapFs
0000000000000000000000000000000000000000;;	afs := &Afero{Fs: fs}
0000000000000000000000000000000000000000;;	f, err := afs.TempFile("", "ioutil-test")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Using Afero for Testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There is a large benefit to using a mock filesystem for testing. It has a
0000000000000000000000000000000000000000;;	completely blank state every time it is initialized and can be easily
0000000000000000000000000000000000000000;;	reproducible regardless of OS. You could create files to your heart’s content
0000000000000000000000000000000000000000;;	and the file access would be fast while also saving you from all the annoying
0000000000000000000000000000000000000000;;	issues with deleting temporary files, Windows file locking, etc. The MemMapFs
0000000000000000000000000000000000000000;;	backend is perfect for testing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Much faster than performing I/O operations on disk
0000000000000000000000000000000000000000;;	* Avoid security issues and permissions
0000000000000000000000000000000000000000;;	* Far more control. 'rm -rf /' with confidence
0000000000000000000000000000000000000000;;	* Test setup is far more easier to do
0000000000000000000000000000000000000000;;	* No test cleanup needed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	One way to accomplish this is to define a variable as mentioned above.
0000000000000000000000000000000000000000;;	In your application this will be set to afero.NewOsFs() during testing you
0000000000000000000000000000000000000000;;	can set it to afero.NewMemMapFs().
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It wouldn't be uncommon to have each test initialize a blank slate memory
0000000000000000000000000000000000000000;;	backend. To do this I would define my `appFS = afero.NewOsFs()` somewhere
0000000000000000000000000000000000000000;;	appropriate in my application code. This approach ensures that Tests are order
0000000000000000000000000000000000000000;;	independent, with no test relying on the state left by an earlier test.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then in my tests I would initialize a new MemMapFs for each test:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func TestExist(t *testing.T) {
0000000000000000000000000000000000000000;;		appFS = afero.NewMemMapFs()
0000000000000000000000000000000000000000;;		// create test files and directories
0000000000000000000000000000000000000000;;		appFS.MkdirAll("src/a", 0755))
0000000000000000000000000000000000000000;;		afero.WriteFile(appFS, "src/a/b", []byte("file b"), 0644)
0000000000000000000000000000000000000000;;		afero.WriteFile(appFS, "src/c", []byte("file c"), 0644)
0000000000000000000000000000000000000000;;		_, err := appFS.Stat("src/c")
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;	        t.Errorf("file \"%s\" does not exist.\n", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Available Backends
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Operating System Native
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### OsFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The first is simply a wrapper around the native OS calls. This makes it
0000000000000000000000000000000000000000;;	very easy to use as all of the calls are the same as the existing OS
0000000000000000000000000000000000000000;;	calls. It also makes it trivial to have your code use the OS during
0000000000000000000000000000000000000000;;	operation and a mock filesystem during testing or as needed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	appfs := afero.NewOsFs()
0000000000000000000000000000000000000000;;	appfs.MkdirAll("src/a", 0755))
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Memory Backed Storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### MemMapFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero also provides a fully atomic memory backed filesystem perfect for use in
0000000000000000000000000000000000000000;;	mocking and to speed up unnecessary disk io when persistence isn’t
0000000000000000000000000000000000000000;;	necessary. It is fully concurrent and will work within go routines
0000000000000000000000000000000000000000;;	safely.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	mm := afero.NewMemMapFs()
0000000000000000000000000000000000000000;;	mm.MkdirAll("src/a", 0755))
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### InMemoryFile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	As part of MemMapFs, Afero also provides an atomic, fully concurrent memory
0000000000000000000000000000000000000000;;	backed file implementation. This can be used in other memory backed file
0000000000000000000000000000000000000000;;	systems with ease. Plans are to add a radix tree memory stored file
0000000000000000000000000000000000000000;;	system using InMemoryFile.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Network Interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### SftpFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero has experimental support for secure file transfer protocol (sftp). Which can
0000000000000000000000000000000000000000;;	be used to perform file operations over a encrypted channel.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Filtering Backends
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### BasePathFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The BasePathFs restricts all operations to a given path within an Fs.
0000000000000000000000000000000000000000;;	The given file name to the operations on this Fs will be prepended with
0000000000000000000000000000000000000000;;	the base path before calling the source Fs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	bp := afero.NewBasePathFs(afero.NewOsFs(), "/base/path")
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### ReadOnlyFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A thin wrapper around the source Fs providing a read only view.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	fs := afero.NewReadOnlyFs(afero.NewOsFs())
0000000000000000000000000000000000000000;;	_, err := fs.Create("/file.txt")
0000000000000000000000000000000000000000;;	// err = syscall.EPERM
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# RegexpFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A filtered view on file names, any file NOT matching
0000000000000000000000000000000000000000;;	the passed regexp will be treated as non-existing.
0000000000000000000000000000000000000000;;	Files not matching the regexp provided will not be created.
0000000000000000000000000000000000000000;;	Directories are not filtered.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	fs := afero.NewRegexpFs(afero.NewMemMapFs(), regexp.MustCompile(`\.txt$`))
0000000000000000000000000000000000000000;;	_, err := fs.Create("/file.html")
0000000000000000000000000000000000000000;;	// err = syscall.ENOENT
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### HttpFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero provides an http compatible backend which can wrap any of the existing
0000000000000000000000000000000000000000;;	backends.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The Http package requires a slightly specific version of Open which
0000000000000000000000000000000000000000;;	returns an http.File type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero provides an httpFs file system which satisfies this requirement.
0000000000000000000000000000000000000000;;	Any Afero FileSystem can be used as an httpFs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	httpFs := afero.NewHttpFs(<ExistingFS>)
0000000000000000000000000000000000000000;;	fileserver := http.FileServer(httpFs.Dir(<PATH>)))
0000000000000000000000000000000000000000;;	http.Handle("/", fileserver)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Composite Backends
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero provides the ability have two filesystems (or more) act as a single
0000000000000000000000000000000000000000;;	file system.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### CacheOnReadFs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The CacheOnReadFs will lazily make copies of any accessed files from the base
0000000000000000000000000000000000000000;;	layer into the overlay. Subsequent reads will be pulled from the overlay
0000000000000000000000000000000000000000;;	directly permitting the request is within the cache duration of when it was
0000000000000000000000000000000000000000;;	created in the overlay.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If the base filesystem is writeable, any changes to files will be
0000000000000000000000000000000000000000;;	done first to the base, then to the overlay layer. Write calls to open file
0000000000000000000000000000000000000000;;	handles like `Write()` or `Truncate()` to the overlay first.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To writing files to the overlay only, you can use the overlay Fs directly (not
0000000000000000000000000000000000000000;;	via the union Fs).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Cache files in the layer for the given time.Duration, a cache duration of 0
0000000000000000000000000000000000000000;;	means "forever" meaning the file will not be re-requested from the base ever.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A read-only base will make the overlay also read-only but still copy files
0000000000000000000000000000000000000000;;	from the base to the overlay when they're not present (or outdated) in the
0000000000000000000000000000000000000000;;	caching layer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	base := afero.NewOsFs()
0000000000000000000000000000000000000000;;	layer := afero.NewMemMapFs()
0000000000000000000000000000000000000000;;	ufs := afero.NewCacheOnReadFs(base, layer, 100 * time.Second)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### CopyOnWriteFs()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The CopyOnWriteFs is a read only base file system with a potentially
0000000000000000000000000000000000000000;;	writeable layer on top.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Read operations will first look in the overlay and if not found there, will
0000000000000000000000000000000000000000;;	serve the file from the base.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Changes to the file system will only be made in the overlay.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Any attempt to modify a file found only in the base will copy the file to the
0000000000000000000000000000000000000000;;	overlay layer before modification (including opening a file with a writable
0000000000000000000000000000000000000000;;	handle).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Removing and Renaming files present only in the base layer is not currently
0000000000000000000000000000000000000000;;	permitted. If a file is present in the base layer and the overlay, only the
0000000000000000000000000000000000000000;;	overlay will be removed/renamed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;		base := afero.NewOsFs()
0000000000000000000000000000000000000000;;		roBase := afero.NewReadOnlyFs(base)
0000000000000000000000000000000000000000;;		ufs := afero.NewCopyOnWriteFs(roBase, afero.NewMemMapFs())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fh, _ = ufs.Create("/home/test/file2.txt")
0000000000000000000000000000000000000000;;		fh.WriteString("This is a test")
0000000000000000000000000000000000000000;;		fh.Close()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In this example all write operations will only occur in memory (MemMapFs)
0000000000000000000000000000000000000000;;	leaving the base filesystem (OsFs) untouched.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Desired/possible backends
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following is a short list of possible backends we hope someone will
0000000000000000000000000000000000000000;;	implement:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* SSH
0000000000000000000000000000000000000000;;	* ZIP
0000000000000000000000000000000000000000;;	* TAR
0000000000000000000000000000000000000000;;	* S3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# About the project
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## What's in the name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero comes from the latin roots Ad-Facere.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**"Ad"** is a prefix meaning "to".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**"Facere"** is a form of the root "faciō" making "make or do".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The literal meaning of afero is "to make" or "to do" which seems very fitting
0000000000000000000000000000000000000000;;	for a library that allows one to make files and directories and do things with them.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The English word that shares the same roots as Afero is "affair". Affair shares
0000000000000000000000000000000000000000;;	the same concept but as a noun it means "something that is made or done" or "an
0000000000000000000000000000000000000000;;	object of a particular type".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It's also nice that unlike some of my other libraries (hugo, cobra, viper) it
0000000000000000000000000000000000000000;;	Googles very well.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Release Notes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* **0.10.0** 2015.12.10
0000000000000000000000000000000000000000;;	  * Full compatibility with Windows
0000000000000000000000000000000000000000;;	  * Introduction of afero utilities
0000000000000000000000000000000000000000;;	  * Test suite rewritten to work cross platform
0000000000000000000000000000000000000000;;	  * Normalize paths for MemMapFs
0000000000000000000000000000000000000000;;	  * Adding Sync to the file interface
0000000000000000000000000000000000000000;;	  * **Breaking Change** Walk and ReadDir have changed parameter order
0000000000000000000000000000000000000000;;	  * Moving types used by MemMapFs to a subpackage
0000000000000000000000000000000000000000;;	  * General bugfixes and improvements
0000000000000000000000000000000000000000;;	* **0.9.0** 2015.11.05
0000000000000000000000000000000000000000;;	  * New Walk function similar to filepath.Walk
0000000000000000000000000000000000000000;;	  * MemMapFs.OpenFile handles O_CREATE, O_APPEND, O_TRUNC
0000000000000000000000000000000000000000;;	  * MemMapFs.Remove now really deletes the file
0000000000000000000000000000000000000000;;	  * InMemoryFile.Readdir and Readdirnames work correctly
0000000000000000000000000000000000000000;;	  * InMemoryFile functions lock it for concurrent access
0000000000000000000000000000000000000000;;	  * Test suite improvements
0000000000000000000000000000000000000000;;	* **0.8.0** 2014.10.28
0000000000000000000000000000000000000000;;	  * First public version
0000000000000000000000000000000000000000;;	  * Interfaces feel ready for people to build using
0000000000000000000000000000000000000000;;	  * Interfaces satisfy all known uses
0000000000000000000000000000000000000000;;	  * MemMapFs passes the majority of the OS test suite
0000000000000000000000000000000000000000;;	  * OsFs passes the majority of the OS test suite
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Contributing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. Fork it
0000000000000000000000000000000000000000;;	2. Create your feature branch (`git checkout -b my-new-feature`)
0000000000000000000000000000000000000000;;	3. Commit your changes (`git commit -am 'Add some feature'`)
0000000000000000000000000000000000000000;;	4. Push to the branch (`git push origin my-new-feature`)
0000000000000000000000000000000000000000;;	5. Create new Pull Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Contributors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Names in no particular order:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [spf13](https://github.com/spf13)
0000000000000000000000000000000000000000;;	* [jaqx0r](https://github.com/jaqx0r)
0000000000000000000000000000000000000000;;	* [mbertschler](https://github.com/mbertschler)
0000000000000000000000000000000000000000;;	* [xor-gate](https://github.com/xor-gate)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## License
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Afero is released under the Apache 2.0 license. See
0000000000000000000000000000000000000000;;	[LICENSE.txt](https://github.com/spf13/afero/blob/master/LICENSE.txt)
