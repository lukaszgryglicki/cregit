0000000000000000000000000000000000000000;;	// Copyright Â© 2016 Steve Francia <spf@spf13.com>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use of this source code is governed by an MIT-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package jwalterweatherman
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Level describes the chosen log level between
0000000000000000000000000000000000000000;;	// debug and critical.
0000000000000000000000000000000000000000;;	type Level int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NotePad struct {
0000000000000000000000000000000000000000;;		Handle  io.Writer
0000000000000000000000000000000000000000;;		Level   Level
0000000000000000000000000000000000000000;;		Prefix  string
0000000000000000000000000000000000000000;;		Logger  **log.Logger
0000000000000000000000000000000000000000;;		counter uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NotePad) incr() {
0000000000000000000000000000000000000000;;		atomic.AddUint64(&n.counter, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NotePad) resetCounter() {
0000000000000000000000000000000000000000;;		atomic.StoreUint64(&n.counter, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NotePad) getCount() uint64 {
0000000000000000000000000000000000000000;;		return atomic.LoadUint64(&n.counter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type countingWriter struct {
0000000000000000000000000000000000000000;;		incrFunc func()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw *countingWriter) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		cw.incrFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Feedback is special. It writes plainly to the output while
0000000000000000000000000000000000000000;;	// logging with the standard extra information (date, file, etc)
0000000000000000000000000000000000000000;;	// Only Println and Printf are currently provided for this
0000000000000000000000000000000000000000;;	type Feedback struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LevelTrace Level = iota
0000000000000000000000000000000000000000;;		LevelDebug
0000000000000000000000000000000000000000;;		LevelInfo
0000000000000000000000000000000000000000;;		LevelWarn
0000000000000000000000000000000000000000;;		LevelError
0000000000000000000000000000000000000000;;		LevelCritical
0000000000000000000000000000000000000000;;		LevelFatal
0000000000000000000000000000000000000000;;		DefaultLogThreshold    = LevelWarn
0000000000000000000000000000000000000000;;		DefaultStdoutThreshold = LevelError
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		TRACE      *log.Logger
0000000000000000000000000000000000000000;;		DEBUG      *log.Logger
0000000000000000000000000000000000000000;;		INFO       *log.Logger
0000000000000000000000000000000000000000;;		WARN       *log.Logger
0000000000000000000000000000000000000000;;		ERROR      *log.Logger
0000000000000000000000000000000000000000;;		CRITICAL   *log.Logger
0000000000000000000000000000000000000000;;		FATAL      *log.Logger
0000000000000000000000000000000000000000;;		LOG        *log.Logger
0000000000000000000000000000000000000000;;		FEEDBACK   Feedback
0000000000000000000000000000000000000000;;		LogHandle  io.Writer  = ioutil.Discard
0000000000000000000000000000000000000000;;		OutHandle  io.Writer  = os.Stdout
0000000000000000000000000000000000000000;;		BothHandle io.Writer  = io.MultiWriter(LogHandle, OutHandle)
0000000000000000000000000000000000000000;;		NotePads   []*NotePad = []*NotePad{trace, debug, info, warn, err, critical, fatal}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trace           *NotePad = &NotePad{Level: LevelTrace, Handle: os.Stdout, Logger: &TRACE, Prefix: "TRACE: "}
0000000000000000000000000000000000000000;;		debug           *NotePad = &NotePad{Level: LevelDebug, Handle: os.Stdout, Logger: &DEBUG, Prefix: "DEBUG: "}
0000000000000000000000000000000000000000;;		info            *NotePad = &NotePad{Level: LevelInfo, Handle: os.Stdout, Logger: &INFO, Prefix: "INFO: "}
0000000000000000000000000000000000000000;;		warn            *NotePad = &NotePad{Level: LevelWarn, Handle: os.Stdout, Logger: &WARN, Prefix: "WARN: "}
0000000000000000000000000000000000000000;;		err             *NotePad = &NotePad{Level: LevelError, Handle: os.Stdout, Logger: &ERROR, Prefix: "ERROR: "}
0000000000000000000000000000000000000000;;		critical        *NotePad = &NotePad{Level: LevelCritical, Handle: os.Stdout, Logger: &CRITICAL, Prefix: "CRITICAL: "}
0000000000000000000000000000000000000000;;		fatal           *NotePad = &NotePad{Level: LevelFatal, Handle: os.Stdout, Logger: &FATAL, Prefix: "FATAL: "}
0000000000000000000000000000000000000000;;		logThreshold    Level    = DefaultLogThreshold
0000000000000000000000000000000000000000;;		outputThreshold Level    = DefaultStdoutThreshold
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DATE  = log.Ldate
0000000000000000000000000000000000000000;;		TIME  = log.Ltime
0000000000000000000000000000000000000000;;		SFILE = log.Lshortfile
0000000000000000000000000000000000000000;;		LFILE = log.Llongfile
0000000000000000000000000000000000000000;;		MSEC  = log.Lmicroseconds
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var logFlags = DATE | TIME | SFILE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		SetStdoutThreshold(DefaultStdoutThreshold)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// initialize will setup the jWalterWeatherman standard approach of providing the user
0000000000000000000000000000000000000000;;	// some feedback and logging a potentially different amount based on independent log and output thresholds.
0000000000000000000000000000000000000000;;	// By default the output has a lower threshold than logged
0000000000000000000000000000000000000000;;	// Don't use if you have manually set the Handles of the different levels as it will overwrite them.
0000000000000000000000000000000000000000;;	func initialize() {
0000000000000000000000000000000000000000;;		BothHandle = io.MultiWriter(LogHandle, OutHandle)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range NotePads {
0000000000000000000000000000000000000000;;			if n.Level < outputThreshold && n.Level < logThreshold {
0000000000000000000000000000000000000000;;				n.Handle = ioutil.Discard
0000000000000000000000000000000000000000;;			} else if n.Level >= outputThreshold && n.Level >= logThreshold {
0000000000000000000000000000000000000000;;				n.Handle = BothHandle
0000000000000000000000000000000000000000;;			} else if n.Level >= outputThreshold && n.Level < logThreshold {
0000000000000000000000000000000000000000;;				n.Handle = OutHandle
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n.Handle = LogHandle
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, n := range NotePads {
0000000000000000000000000000000000000000;;			n.Handle = io.MultiWriter(n.Handle, &countingWriter{n.incr})
0000000000000000000000000000000000000000;;			*n.Logger = log.New(n.Handle, n.Prefix, logFlags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LOG = log.New(LogHandle,
0000000000000000000000000000000000000000;;			"LOG:   ",
0000000000000000000000000000000000000000;;			logFlags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the log Flags (Available flag: DATE, TIME, SFILE, LFILE and MSEC)
0000000000000000000000000000000000000000;;	func SetLogFlag(flags int) {
0000000000000000000000000000000000000000;;		logFlags = flags
0000000000000000000000000000000000000000;;		initialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Level returns the current global log threshold.
0000000000000000000000000000000000000000;;	func LogThreshold() Level {
0000000000000000000000000000000000000000;;		return logThreshold
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Level returns the current global output threshold.
0000000000000000000000000000000000000000;;	func StdoutThreshold() Level {
0000000000000000000000000000000000000000;;		return outputThreshold
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensures that the level provided is within the bounds of available levels
0000000000000000000000000000000000000000;;	func levelCheck(level Level) Level {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case level <= LevelTrace:
0000000000000000000000000000000000000000;;			return LevelTrace
0000000000000000000000000000000000000000;;		case level >= LevelFatal:
0000000000000000000000000000000000000000;;			return LevelFatal
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return level
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Establishes a threshold where anything matching or above will be logged
0000000000000000000000000000000000000000;;	func SetLogThreshold(level Level) {
0000000000000000000000000000000000000000;;		logThreshold = levelCheck(level)
0000000000000000000000000000000000000000;;		initialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Establishes a threshold where anything matching or above will be output
0000000000000000000000000000000000000000;;	func SetStdoutThreshold(level Level) {
0000000000000000000000000000000000000000;;		outputThreshold = levelCheck(level)
0000000000000000000000000000000000000000;;		initialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conveniently Sets the Log Handle to a io.writer created for the file behind the given filepath
0000000000000000000000000000000000000000;;	// Will only append to this file
0000000000000000000000000000000000000000;;	func SetLogFile(path string) {
0000000000000000000000000000000000000000;;		file, err := os.OpenFile(path, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			CRITICAL.Println("Failed to open log file:", path, err)
0000000000000000000000000000000000000000;;			os.Exit(-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		INFO.Println("Logging to", file.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LogHandle = file
0000000000000000000000000000000000000000;;		initialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conveniently Creates a temporary file and sets the Log Handle to a io.writer created for it
0000000000000000000000000000000000000000;;	func UseTempLogFile(prefix string) {
0000000000000000000000000000000000000000;;		file, err := ioutil.TempFile(os.TempDir(), prefix)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			CRITICAL.Println(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		INFO.Println("Logging to", file.Name())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LogHandle = file
0000000000000000000000000000000000000000;;		initialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogCountForLevel returns the number of log invocations for a given level.
0000000000000000000000000000000000000000;;	func LogCountForLevel(l Level) uint64 {
0000000000000000000000000000000000000000;;		for _, np := range NotePads {
0000000000000000000000000000000000000000;;			if np.Level == l {
0000000000000000000000000000000000000000;;				return np.getCount()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogCountForLevelsGreaterThanorEqualTo returns the number of log invocations
0000000000000000000000000000000000000000;;	// greater than or equal to a given level threshold.
0000000000000000000000000000000000000000;;	func LogCountForLevelsGreaterThanorEqualTo(threshold Level) uint64 {
0000000000000000000000000000000000000000;;		var cnt uint64
0000000000000000000000000000000000000000;;		for _, np := range NotePads {
0000000000000000000000000000000000000000;;			if np.Level >= threshold {
0000000000000000000000000000000000000000;;				cnt += np.getCount()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cnt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetLogCounters resets the invocation counters for all levels.
0000000000000000000000000000000000000000;;	func ResetLogCounters() {
0000000000000000000000000000000000000000;;		for _, np := range NotePads {
0000000000000000000000000000000000000000;;			np.resetCounter()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Disables logging for the entire JWW system
0000000000000000000000000000000000000000;;	func DiscardLogging() {
0000000000000000000000000000000000000000;;		LogHandle = ioutil.Discard
0000000000000000000000000000000000000000;;		initialize()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Feedback is special. It writes plainly to the output while
0000000000000000000000000000000000000000;;	// logging with the standard extra information (date, file, etc)
0000000000000000000000000000000000000000;;	// Only Println and Printf are currently provided for this
0000000000000000000000000000000000000000;;	func (fb *Feedback) Println(v ...interface{}) {
0000000000000000000000000000000000000000;;		s := fmt.Sprintln(v...)
0000000000000000000000000000000000000000;;		fmt.Print(s)
0000000000000000000000000000000000000000;;		LOG.Output(2, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Feedback is special. It writes plainly to the output while
0000000000000000000000000000000000000000;;	// logging with the standard extra information (date, file, etc)
0000000000000000000000000000000000000000;;	// Only Println and Printf are currently provided for this
0000000000000000000000000000000000000000;;	func (fb *Feedback) Printf(format string, v ...interface{}) {
0000000000000000000000000000000000000000;;		s := fmt.Sprintf(format, v...)
0000000000000000000000000000000000000000;;		fmt.Print(s)
0000000000000000000000000000000000000000;;		LOG.Output(2, s)
0000000000000000000000000000000000000000;;	}
