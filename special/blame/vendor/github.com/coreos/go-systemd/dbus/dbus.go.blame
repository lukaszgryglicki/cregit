0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/coreos/go-systemd/dbus/dbus.go[Godeps/_workspace/src/github.com/coreos/go-systemd/dbus/dbus.go][vendor/github.com/coreos/go-systemd/dbus/dbus.go];	
0000000000000000000000000000000000000000;;	// Integration with the systemd D-Bus API.  See http://www.freedesktop.org/wiki/Software/systemd/dbus/
0000000000000000000000000000000000000000;;	package dbus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/godbus/dbus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		alpha        = `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`
0000000000000000000000000000000000000000;;		num          = `0123456789`
0000000000000000000000000000000000000000;;		alphanum     = alpha + num
0000000000000000000000000000000000000000;;		signalBuffer = 100
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// needsEscape checks whether a byte in a potential dbus ObjectPath needs to be escaped
0000000000000000000000000000000000000000;;	func needsEscape(i int, b byte) bool {
0000000000000000000000000000000000000000;;		// Escape everything that is not a-z-A-Z-0-9
0000000000000000000000000000000000000000;;		// Also escape 0-9 if it's the first character
0000000000000000000000000000000000000000;;		return strings.IndexByte(alphanum, b) == -1 ||
0000000000000000000000000000000000000000;;			(i == 0 && strings.IndexByte(num, b) != -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathBusEscape sanitizes a constituent string of a dbus ObjectPath using the
0000000000000000000000000000000000000000;;	// rules that systemd uses for serializing special characters.
0000000000000000000000000000000000000000;;	func PathBusEscape(path string) string {
0000000000000000000000000000000000000000;;		// Special case the empty string
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			return "_"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := []byte{}
0000000000000000000000000000000000000000;;		for i := 0; i < len(path); i++ {
0000000000000000000000000000000000000000;;			c := path[i]
0000000000000000000000000000000000000000;;			if needsEscape(i, c) {
0000000000000000000000000000000000000000;;				e := fmt.Sprintf("_%x", c)
0000000000000000000000000000000000000000;;				n = append(n, []byte(e)...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n = append(n, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conn is a connection to systemd's dbus endpoint.
0000000000000000000000000000000000000000;;	type Conn struct {
0000000000000000000000000000000000000000;;		// sysconn/sysobj are only used to call dbus methods
0000000000000000000000000000000000000000;;		sysconn *dbus.Conn
0000000000000000000000000000000000000000;;		sysobj  dbus.BusObject
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sigconn/sigobj are only used to receive dbus signals
0000000000000000000000000000000000000000;;		sigconn *dbus.Conn
0000000000000000000000000000000000000000;;		sigobj  dbus.BusObject
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jobListener struct {
0000000000000000000000000000000000000000;;			jobs map[dbus.ObjectPath]chan<- string
0000000000000000000000000000000000000000;;			sync.Mutex
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		subscriber struct {
0000000000000000000000000000000000000000;;			updateCh chan<- *SubStateUpdate
0000000000000000000000000000000000000000;;			errCh    chan<- error
0000000000000000000000000000000000000000;;			sync.Mutex
0000000000000000000000000000000000000000;;			ignore      map[dbus.ObjectPath]int64
0000000000000000000000000000000000000000;;			cleanIgnore int64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New establishes a connection to any available bus and authenticates.
0000000000000000000000000000000000000000;;	// Callers should call Close() when done with the connection.
0000000000000000000000000000000000000000;;	func New() (*Conn, error) {
0000000000000000000000000000000000000000;;		conn, err := NewSystemConnection()
0000000000000000000000000000000000000000;;		if err != nil && os.Geteuid() == 0 {
0000000000000000000000000000000000000000;;			return NewSystemdConnection()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSystemConnection establishes a connection to the system bus and authenticates.
0000000000000000000000000000000000000000;;	// Callers should call Close() when done with the connection
0000000000000000000000000000000000000000;;	func NewSystemConnection() (*Conn, error) {
0000000000000000000000000000000000000000;;		return NewConnection(func() (*dbus.Conn, error) {
0000000000000000000000000000000000000000;;			return dbusAuthHelloConnection(dbus.SystemBusPrivate)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUserConnection establishes a connection to the session bus and
0000000000000000000000000000000000000000;;	// authenticates. This can be used to connect to systemd user instances.
0000000000000000000000000000000000000000;;	// Callers should call Close() when done with the connection.
0000000000000000000000000000000000000000;;	func NewUserConnection() (*Conn, error) {
0000000000000000000000000000000000000000;;		return NewConnection(func() (*dbus.Conn, error) {
0000000000000000000000000000000000000000;;			return dbusAuthHelloConnection(dbus.SessionBusPrivate)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSystemdConnection establishes a private, direct connection to systemd.
0000000000000000000000000000000000000000;;	// This can be used for communicating with systemd without a dbus daemon.
0000000000000000000000000000000000000000;;	// Callers should call Close() when done with the connection.
0000000000000000000000000000000000000000;;	func NewSystemdConnection() (*Conn, error) {
0000000000000000000000000000000000000000;;		return NewConnection(func() (*dbus.Conn, error) {
0000000000000000000000000000000000000000;;			// We skip Hello when talking directly to systemd.
0000000000000000000000000000000000000000;;			return dbusAuthConnection(func() (*dbus.Conn, error) {
0000000000000000000000000000000000000000;;				return dbus.Dial("unix:path=/run/systemd/private")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes an established connection
0000000000000000000000000000000000000000;;	func (c *Conn) Close() {
0000000000000000000000000000000000000000;;		c.sysconn.Close()
0000000000000000000000000000000000000000;;		c.sigconn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConnection establishes a connection to a bus using a caller-supplied function.
0000000000000000000000000000000000000000;;	// This allows connecting to remote buses through a user-supplied mechanism.
0000000000000000000000000000000000000000;;	// The supplied function may be called multiple times, and should return independent connections.
0000000000000000000000000000000000000000;;	// The returned connection must be fully initialised: the org.freedesktop.DBus.Hello call must have succeeded,
0000000000000000000000000000000000000000;;	// and any authentication should be handled by the function.
0000000000000000000000000000000000000000;;	func NewConnection(dialBus func() (*dbus.Conn, error)) (*Conn, error) {
0000000000000000000000000000000000000000;;		sysconn, err := dialBus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sigconn, err := dialBus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			sysconn.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &Conn{
0000000000000000000000000000000000000000;;			sysconn: sysconn,
0000000000000000000000000000000000000000;;			sysobj:  systemdObject(sysconn),
0000000000000000000000000000000000000000;;			sigconn: sigconn,
0000000000000000000000000000000000000000;;			sigobj:  systemdObject(sigconn),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.subscriber.ignore = make(map[dbus.ObjectPath]int64)
0000000000000000000000000000000000000000;;		c.jobListener.jobs = make(map[dbus.ObjectPath]chan<- string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup the listeners on jobs so that we can get completions
0000000000000000000000000000000000000000;;		c.sigconn.BusObject().Call("org.freedesktop.DBus.AddMatch", 0,
0000000000000000000000000000000000000000;;			"type='signal', interface='org.freedesktop.systemd1.Manager', member='JobRemoved'")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.dispatch()
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetManagerProperty returns the value of a property on the org.freedesktop.systemd1.Manager
0000000000000000000000000000000000000000;;	// interface. The value is returned in its string representation, as defined at
0000000000000000000000000000000000000000;;	// https://developer.gnome.org/glib/unstable/gvariant-text.html
0000000000000000000000000000000000000000;;	func (c *Conn) GetManagerProperty(prop string) (string, error) {
0000000000000000000000000000000000000000;;		variant, err := c.sysobj.GetProperty("org.freedesktop.systemd1.Manager." + prop)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return variant.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dbusAuthConnection(createBus func() (*dbus.Conn, error)) (*dbus.Conn, error) {
0000000000000000000000000000000000000000;;		conn, err := createBus()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only use EXTERNAL method, and hardcode the uid (not username)
0000000000000000000000000000000000000000;;		// to avoid a username lookup (which requires a dynamically linked
0000000000000000000000000000000000000000;;		// libc)
0000000000000000000000000000000000000000;;		methods := []dbus.Auth{dbus.AuthExternal(strconv.Itoa(os.Getuid()))}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = conn.Auth(methods)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dbusAuthHelloConnection(createBus func() (*dbus.Conn, error)) (*dbus.Conn, error) {
0000000000000000000000000000000000000000;;		conn, err := dbusAuthConnection(createBus)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = conn.Hello(); err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func systemdObject(conn *dbus.Conn) dbus.BusObject {
0000000000000000000000000000000000000000;;		return conn.Object("org.freedesktop.systemd1", dbus.ObjectPath("/org/freedesktop/systemd1"))
0000000000000000000000000000000000000000;;	}
