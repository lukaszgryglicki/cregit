0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/coreos/go-systemd/dbus/subscription.go[Godeps/_workspace/src/github.com/coreos/go-systemd/dbus/subscription.go][vendor/github.com/coreos/go-systemd/dbus/subscription.go];	
0000000000000000000000000000000000000000;;	package dbus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/godbus/dbus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cleanIgnoreInterval = int64(10 * time.Second)
0000000000000000000000000000000000000000;;		ignoreInterval      = int64(30 * time.Millisecond)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subscribe sets up this connection to subscribe to all systemd dbus events.
0000000000000000000000000000000000000000;;	// This is required before calling SubscribeUnits. When the connection closes
0000000000000000000000000000000000000000;;	// systemd will automatically stop sending signals so there is no need to
0000000000000000000000000000000000000000;;	// explicitly call Unsubscribe().
0000000000000000000000000000000000000000;;	func (c *Conn) Subscribe() error {
0000000000000000000000000000000000000000;;		c.sigconn.BusObject().Call("org.freedesktop.DBus.AddMatch", 0,
0000000000000000000000000000000000000000;;			"type='signal',interface='org.freedesktop.systemd1.Manager',member='UnitNew'")
0000000000000000000000000000000000000000;;		c.sigconn.BusObject().Call("org.freedesktop.DBus.AddMatch", 0,
0000000000000000000000000000000000000000;;			"type='signal',interface='org.freedesktop.DBus.Properties',member='PropertiesChanged'")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.sigobj.Call("org.freedesktop.systemd1.Manager.Subscribe", 0).Store()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unsubscribe this connection from systemd dbus events.
0000000000000000000000000000000000000000;;	func (c *Conn) Unsubscribe() error {
0000000000000000000000000000000000000000;;		err := c.sigobj.Call("org.freedesktop.systemd1.Manager.Unsubscribe", 0).Store()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) dispatch() {
0000000000000000000000000000000000000000;;		ch := make(chan *dbus.Signal, signalBuffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.sigconn.Signal(ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				signal, ok := <-ch
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if signal.Name == "org.freedesktop.systemd1.Manager.JobRemoved" {
0000000000000000000000000000000000000000;;					c.jobComplete(signal)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if c.subscriber.updateCh == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var unitPath dbus.ObjectPath
0000000000000000000000000000000000000000;;				switch signal.Name {
0000000000000000000000000000000000000000;;				case "org.freedesktop.systemd1.Manager.JobRemoved":
0000000000000000000000000000000000000000;;					unitName := signal.Body[2].(string)
0000000000000000000000000000000000000000;;					c.sysobj.Call("org.freedesktop.systemd1.Manager.GetUnit", 0, unitName).Store(&unitPath)
0000000000000000000000000000000000000000;;				case "org.freedesktop.systemd1.Manager.UnitNew":
0000000000000000000000000000000000000000;;					unitPath = signal.Body[1].(dbus.ObjectPath)
0000000000000000000000000000000000000000;;				case "org.freedesktop.DBus.Properties.PropertiesChanged":
0000000000000000000000000000000000000000;;					if signal.Body[0].(string) == "org.freedesktop.systemd1.Unit" {
0000000000000000000000000000000000000000;;						unitPath = signal.Path
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if unitPath == dbus.ObjectPath("") {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				c.sendSubStateUpdate(unitPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns two unbuffered channels which will receive all changed units every
0000000000000000000000000000000000000000;;	// interval.  Deleted units are sent as nil.
0000000000000000000000000000000000000000;;	func (c *Conn) SubscribeUnits(interval time.Duration) (<-chan map[string]*UnitStatus, <-chan error) {
0000000000000000000000000000000000000000;;		return c.SubscribeUnitsCustom(interval, 0, func(u1, u2 *UnitStatus) bool { return *u1 != *u2 }, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubscribeUnitsCustom is like SubscribeUnits but lets you specify the buffer
0000000000000000000000000000000000000000;;	// size of the channels, the comparison function for detecting changes and a filter
0000000000000000000000000000000000000000;;	// function for cutting down on the noise that your channel receives.
0000000000000000000000000000000000000000;;	func (c *Conn) SubscribeUnitsCustom(interval time.Duration, buffer int, isChanged func(*UnitStatus, *UnitStatus) bool, filterUnit func(string) bool) (<-chan map[string]*UnitStatus, <-chan error) {
0000000000000000000000000000000000000000;;		old := make(map[string]*UnitStatus)
0000000000000000000000000000000000000000;;		statusChan := make(chan map[string]*UnitStatus, buffer)
0000000000000000000000000000000000000000;;		errChan := make(chan error, buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				timerChan := time.After(interval)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				units, err := c.ListUnits()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					cur := make(map[string]*UnitStatus)
0000000000000000000000000000000000000000;;					for i := range units {
0000000000000000000000000000000000000000;;						if filterUnit != nil && filterUnit(units[i].Name) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						cur[units[i].Name] = &units[i]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// add all new or changed units
0000000000000000000000000000000000000000;;					changed := make(map[string]*UnitStatus)
0000000000000000000000000000000000000000;;					for n, u := range cur {
0000000000000000000000000000000000000000;;						if oldU, ok := old[n]; !ok || isChanged(oldU, u) {
0000000000000000000000000000000000000000;;							changed[n] = u
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						delete(old, n)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// add all deleted units
0000000000000000000000000000000000000000;;					for oldN := range old {
0000000000000000000000000000000000000000;;						changed[oldN] = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					old = cur
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if len(changed) != 0 {
0000000000000000000000000000000000000000;;						statusChan <- changed
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errChan <- err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				<-timerChan
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return statusChan, errChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SubStateUpdate struct {
0000000000000000000000000000000000000000;;		UnitName string
0000000000000000000000000000000000000000;;		SubState string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetSubStateSubscriber writes to updateCh when any unit's substate changes.
0000000000000000000000000000000000000000;;	// Although this writes to updateCh on every state change, the reported state
0000000000000000000000000000000000000000;;	// may be more recent than the change that generated it (due to an unavoidable
0000000000000000000000000000000000000000;;	// race in the systemd dbus interface).  That is, this method provides a good
0000000000000000000000000000000000000000;;	// way to keep a current view of all units' states, but is not guaranteed to
0000000000000000000000000000000000000000;;	// show every state transition they go through.  Furthermore, state changes
0000000000000000000000000000000000000000;;	// will only be written to the channel with non-blocking writes.  If updateCh
0000000000000000000000000000000000000000;;	// is full, it attempts to write an error to errCh; if errCh is full, the error
0000000000000000000000000000000000000000;;	// passes silently.
0000000000000000000000000000000000000000;;	func (c *Conn) SetSubStateSubscriber(updateCh chan<- *SubStateUpdate, errCh chan<- error) {
0000000000000000000000000000000000000000;;		c.subscriber.Lock()
0000000000000000000000000000000000000000;;		defer c.subscriber.Unlock()
0000000000000000000000000000000000000000;;		c.subscriber.updateCh = updateCh
0000000000000000000000000000000000000000;;		c.subscriber.errCh = errCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) sendSubStateUpdate(path dbus.ObjectPath) {
0000000000000000000000000000000000000000;;		c.subscriber.Lock()
0000000000000000000000000000000000000000;;		defer c.subscriber.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.shouldIgnore(path) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := c.GetUnitProperties(string(path))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case c.subscriber.errCh <- err:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := info["Id"].(string)
0000000000000000000000000000000000000000;;		substate := info["SubState"].(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		update := &SubStateUpdate{name, substate}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case c.subscriber.updateCh <- update:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case c.subscriber.errCh <- errors.New("update channel full!"):
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.updateIgnore(path, info)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The ignore functions work around a wart in the systemd dbus interface.
0000000000000000000000000000000000000000;;	// Requesting the properties of an unloaded unit will cause systemd to send a
0000000000000000000000000000000000000000;;	// pair of UnitNew/UnitRemoved signals.  Because we need to get a unit's
0000000000000000000000000000000000000000;;	// properties on UnitNew (as that's the only indication of a new unit coming up
0000000000000000000000000000000000000000;;	// for the first time), we would enter an infinite loop if we did not attempt
0000000000000000000000000000000000000000;;	// to detect and ignore these spurious signals.  The signal themselves are
0000000000000000000000000000000000000000;;	// indistinguishable from relevant ones, so we (somewhat hackishly) ignore an
0000000000000000000000000000000000000000;;	// unloaded unit's signals for a short time after requesting its properties.
0000000000000000000000000000000000000000;;	// This means that we will miss e.g. a transient unit being restarted
0000000000000000000000000000000000000000;;	// *immediately* upon failure and also a transient unit being started
0000000000000000000000000000000000000000;;	// immediately after requesting its status (with systemctl status, for example,
0000000000000000000000000000000000000000;;	// because this causes a UnitNew signal to be sent which then causes us to fetch
0000000000000000000000000000000000000000;;	// the properties).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) shouldIgnore(path dbus.ObjectPath) bool {
0000000000000000000000000000000000000000;;		t, ok := c.subscriber.ignore[path]
0000000000000000000000000000000000000000;;		return ok && t >= time.Now().UnixNano()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) updateIgnore(path dbus.ObjectPath, info map[string]interface{}) {
0000000000000000000000000000000000000000;;		c.cleanIgnore()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unit is unloaded - it will trigger bad systemd dbus behavior
0000000000000000000000000000000000000000;;		if info["LoadState"].(string) == "not-found" {
0000000000000000000000000000000000000000;;			c.subscriber.ignore[path] = time.Now().UnixNano() + ignoreInterval
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// without this, ignore would grow unboundedly over time
0000000000000000000000000000000000000000;;	func (c *Conn) cleanIgnore() {
0000000000000000000000000000000000000000;;		now := time.Now().UnixNano()
0000000000000000000000000000000000000000;;		if c.subscriber.cleanIgnore < now {
0000000000000000000000000000000000000000;;			c.subscriber.cleanIgnore = now + cleanIgnoreInterval
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for p, t := range c.subscriber.ignore {
0000000000000000000000000000000000000000;;				if t < now {
0000000000000000000000000000000000000000;;					delete(c.subscriber.ignore, p)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
