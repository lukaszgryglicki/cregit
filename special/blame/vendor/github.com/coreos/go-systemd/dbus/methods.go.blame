0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/coreos/go-systemd/dbus/methods.go[Godeps/_workspace/src/github.com/coreos/go-systemd/dbus/methods.go][vendor/github.com/coreos/go-systemd/dbus/methods.go];	
0000000000000000000000000000000000000000;;	package dbus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/godbus/dbus"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) jobComplete(signal *dbus.Signal) {
0000000000000000000000000000000000000000;;		var id uint32
0000000000000000000000000000000000000000;;		var job dbus.ObjectPath
0000000000000000000000000000000000000000;;		var unit string
0000000000000000000000000000000000000000;;		var result string
0000000000000000000000000000000000000000;;		dbus.Store(signal.Body, &id, &job, &unit, &result)
0000000000000000000000000000000000000000;;		c.jobListener.Lock()
0000000000000000000000000000000000000000;;		out, ok := c.jobListener.jobs[job]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			out <- result
0000000000000000000000000000000000000000;;			delete(c.jobListener.jobs, job)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.jobListener.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) startJob(ch chan<- string, job string, args ...interface{}) (int, error) {
0000000000000000000000000000000000000000;;		if ch != nil {
0000000000000000000000000000000000000000;;			c.jobListener.Lock()
0000000000000000000000000000000000000000;;			defer c.jobListener.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var p dbus.ObjectPath
0000000000000000000000000000000000000000;;		err := c.sysobj.Call(job, 0, args...).Store(&p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ch != nil {
0000000000000000000000000000000000000000;;			c.jobListener.jobs[p] = ch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ignore error since 0 is fine if conversion fails
0000000000000000000000000000000000000000;;		jobID, _ := strconv.Atoi(path.Base(string(p)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jobID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartUnit enqueues a start job and depending jobs, if any (unless otherwise
0000000000000000000000000000000000000000;;	// specified by the mode string).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Takes the unit to activate, plus a mode string. The mode needs to be one of
0000000000000000000000000000000000000000;;	// replace, fail, isolate, ignore-dependencies, ignore-requirements. If
0000000000000000000000000000000000000000;;	// "replace" the call will start the unit and its dependencies, possibly
0000000000000000000000000000000000000000;;	// replacing already queued jobs that conflict with this. If "fail" the call
0000000000000000000000000000000000000000;;	// will start the unit and its dependencies, but will fail if this would change
0000000000000000000000000000000000000000;;	// an already queued job. If "isolate" the call will start the unit in question
0000000000000000000000000000000000000000;;	// and terminate all units that aren't dependencies of it. If
0000000000000000000000000000000000000000;;	// "ignore-dependencies" it will start a unit but ignore all its dependencies.
0000000000000000000000000000000000000000;;	// If "ignore-requirements" it will start a unit but only ignore the
0000000000000000000000000000000000000000;;	// requirement dependencies. It is not recommended to make use of the latter
0000000000000000000000000000000000000000;;	// two options.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the provided channel is non-nil, a result string will be sent to it upon
0000000000000000000000000000000000000000;;	// job completion: one of done, canceled, timeout, failed, dependency, skipped.
0000000000000000000000000000000000000000;;	// done indicates successful execution of a job. canceled indicates that a job
0000000000000000000000000000000000000000;;	// has been canceled  before it finished execution. timeout indicates that the
0000000000000000000000000000000000000000;;	// job timeout was reached. failed indicates that the job failed. dependency
0000000000000000000000000000000000000000;;	// indicates that a job this job has been depending on failed and the job hence
0000000000000000000000000000000000000000;;	// has been removed too. skipped indicates that a job was skipped because it
0000000000000000000000000000000000000000;;	// didn't apply to the units current state.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If no error occurs, the ID of the underlying systemd job will be returned. There
0000000000000000000000000000000000000000;;	// does exist the possibility for no error to be returned, but for the returned job
0000000000000000000000000000000000000000;;	// ID to be 0. In this case, the actual underlying ID is not 0 and this datapoint
0000000000000000000000000000000000000000;;	// should not be considered authoritative.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If an error does occur, it will be returned to the user alongside a job ID of 0.
0000000000000000000000000000000000000000;;	func (c *Conn) StartUnit(name string, mode string, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.StartUnit", name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopUnit is similar to StartUnit but stops the specified unit rather
0000000000000000000000000000000000000000;;	// than starting it.
0000000000000000000000000000000000000000;;	func (c *Conn) StopUnit(name string, mode string, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.StopUnit", name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReloadUnit reloads a unit.  Reloading is done only if the unit is already running and fails otherwise.
0000000000000000000000000000000000000000;;	func (c *Conn) ReloadUnit(name string, mode string, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.ReloadUnit", name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestartUnit restarts a service.  If a service is restarted that isn't
0000000000000000000000000000000000000000;;	// running it will be started.
0000000000000000000000000000000000000000;;	func (c *Conn) RestartUnit(name string, mode string, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.RestartUnit", name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TryRestartUnit is like RestartUnit, except that a service that isn't running
0000000000000000000000000000000000000000;;	// is not affected by the restart.
0000000000000000000000000000000000000000;;	func (c *Conn) TryRestartUnit(name string, mode string, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.TryRestartUnit", name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReloadOrRestart attempts a reload if the unit supports it and use a restart
0000000000000000000000000000000000000000;;	// otherwise.
0000000000000000000000000000000000000000;;	func (c *Conn) ReloadOrRestartUnit(name string, mode string, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.ReloadOrRestartUnit", name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReloadOrTryRestart attempts a reload if the unit supports it and use a "Try"
0000000000000000000000000000000000000000;;	// flavored restart otherwise.
0000000000000000000000000000000000000000;;	func (c *Conn) ReloadOrTryRestartUnit(name string, mode string, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.ReloadOrTryRestartUnit", name, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartTransientUnit() may be used to create and start a transient unit, which
0000000000000000000000000000000000000000;;	// will be released as soon as it is not running or referenced anymore or the
0000000000000000000000000000000000000000;;	// system is rebooted. name is the unit name including suffix, and must be
0000000000000000000000000000000000000000;;	// unique. mode is the same as in StartUnit(), properties contains properties
0000000000000000000000000000000000000000;;	// of the unit.
0000000000000000000000000000000000000000;;	func (c *Conn) StartTransientUnit(name string, mode string, properties []Property, ch chan<- string) (int, error) {
0000000000000000000000000000000000000000;;		return c.startJob(ch, "org.freedesktop.systemd1.Manager.StartTransientUnit", name, mode, properties, make([]PropertyCollection, 0))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KillUnit takes the unit name and a UNIX signal number to send.  All of the unit's
0000000000000000000000000000000000000000;;	// processes are killed.
0000000000000000000000000000000000000000;;	func (c *Conn) KillUnit(name string, signal int32) {
0000000000000000000000000000000000000000;;		c.sysobj.Call("org.freedesktop.systemd1.Manager.KillUnit", 0, name, "all", signal).Store()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetFailedUnit resets the "failed" state of a specific unit.
0000000000000000000000000000000000000000;;	func (c *Conn) ResetFailedUnit(name string) error {
0000000000000000000000000000000000000000;;		return c.sysobj.Call("org.freedesktop.systemd1.Manager.ResetFailedUnit", 0, name).Store()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getProperties takes the unit name and returns all of its dbus object properties, for the given dbus interface
0000000000000000000000000000000000000000;;	func (c *Conn) getProperties(unit string, dbusInterface string) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var props map[string]dbus.Variant
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := unitPath(unit)
0000000000000000000000000000000000000000;;		if !path.IsValid() {
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid unit name: " + unit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := c.sysconn.Object("org.freedesktop.systemd1", path)
0000000000000000000000000000000000000000;;		err = obj.Call("org.freedesktop.DBus.Properties.GetAll", 0, dbusInterface).Store(&props)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := make(map[string]interface{}, len(props))
0000000000000000000000000000000000000000;;		for k, v := range props {
0000000000000000000000000000000000000000;;			out[k] = v.Value()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUnitProperties takes the unit name and returns all of its dbus object properties.
0000000000000000000000000000000000000000;;	func (c *Conn) GetUnitProperties(unit string) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		return c.getProperties(unit, "org.freedesktop.systemd1.Unit")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) getProperty(unit string, dbusInterface string, propertyName string) (*Property, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var prop dbus.Variant
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := unitPath(unit)
0000000000000000000000000000000000000000;;		if !path.IsValid() {
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid unit name: " + unit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := c.sysconn.Object("org.freedesktop.systemd1", path)
0000000000000000000000000000000000000000;;		err = obj.Call("org.freedesktop.DBus.Properties.Get", 0, dbusInterface, propertyName).Store(&prop)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Property{Name: propertyName, Value: prop}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) GetUnitProperty(unit string, propertyName string) (*Property, error) {
0000000000000000000000000000000000000000;;		return c.getProperty(unit, "org.freedesktop.systemd1.Unit", propertyName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetServiceProperty returns property for given service name and property name
0000000000000000000000000000000000000000;;	func (c *Conn) GetServiceProperty(service string, propertyName string) (*Property, error) {
0000000000000000000000000000000000000000;;		return c.getProperty(service, "org.freedesktop.systemd1.Service", propertyName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUnitTypeProperties returns the extra properties for a unit, specific to the unit type.
0000000000000000000000000000000000000000;;	// Valid values for unitType: Service, Socket, Target, Device, Mount, Automount, Snapshot, Timer, Swap, Path, Slice, Scope
0000000000000000000000000000000000000000;;	// return "dbus.Error: Unknown interface" if the unitType is not the correct type of the unit
0000000000000000000000000000000000000000;;	func (c *Conn) GetUnitTypeProperties(unit string, unitType string) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		return c.getProperties(unit, "org.freedesktop.systemd1."+unitType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUnitProperties() may be used to modify certain unit properties at runtime.
0000000000000000000000000000000000000000;;	// Not all properties may be changed at runtime, but many resource management
0000000000000000000000000000000000000000;;	// settings (primarily those in systemd.cgroup(5)) may. The changes are applied
0000000000000000000000000000000000000000;;	// instantly, and stored on disk for future boots, unless runtime is true, in which
0000000000000000000000000000000000000000;;	// case the settings only apply until the next reboot. name is the name of the unit
0000000000000000000000000000000000000000;;	// to modify. properties are the settings to set, encoded as an array of property
0000000000000000000000000000000000000000;;	// name and value pairs.
0000000000000000000000000000000000000000;;	func (c *Conn) SetUnitProperties(name string, runtime bool, properties ...Property) error {
0000000000000000000000000000000000000000;;		return c.sysobj.Call("org.freedesktop.systemd1.Manager.SetUnitProperties", 0, name, runtime, properties).Store()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) GetUnitTypeProperty(unit string, unitType string, propertyName string) (*Property, error) {
0000000000000000000000000000000000000000;;		return c.getProperty(unit, "org.freedesktop.systemd1."+unitType, propertyName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UnitStatus struct {
0000000000000000000000000000000000000000;;		Name        string          // The primary unit name as string
0000000000000000000000000000000000000000;;		Description string          // The human readable description string
0000000000000000000000000000000000000000;;		LoadState   string          // The load state (i.e. whether the unit file has been loaded successfully)
0000000000000000000000000000000000000000;;		ActiveState string          // The active state (i.e. whether the unit is currently started or not)
0000000000000000000000000000000000000000;;		SubState    string          // The sub state (a more fine-grained version of the active state that is specific to the unit type, which the active state is not)
0000000000000000000000000000000000000000;;		Followed    string          // A unit that is being followed in its state by this unit, if there is any, otherwise the empty string.
0000000000000000000000000000000000000000;;		Path        dbus.ObjectPath // The unit object path
0000000000000000000000000000000000000000;;		JobId       uint32          // If there is a job queued for the job unit the numeric job id, 0 otherwise
0000000000000000000000000000000000000000;;		JobType     string          // The job type as string
0000000000000000000000000000000000000000;;		JobPath     dbus.ObjectPath // The job object path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storeFunc func(retvalues ...interface{}) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) listUnitsInternal(f storeFunc) ([]UnitStatus, error) {
0000000000000000000000000000000000000000;;		result := make([][]interface{}, 0)
0000000000000000000000000000000000000000;;		err := f(&result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultInterface := make([]interface{}, len(result))
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			resultInterface[i] = result[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := make([]UnitStatus, len(result))
0000000000000000000000000000000000000000;;		statusInterface := make([]interface{}, len(status))
0000000000000000000000000000000000000000;;		for i := range status {
0000000000000000000000000000000000000000;;			statusInterface[i] = &status[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = dbus.Store(resultInterface, statusInterface...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return status, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListUnits returns an array with all currently loaded units. Note that
0000000000000000000000000000000000000000;;	// units may be known by multiple names at the same time, and hence there might
0000000000000000000000000000000000000000;;	// be more unit names loaded than actual units behind them.
0000000000000000000000000000000000000000;;	func (c *Conn) ListUnits() ([]UnitStatus, error) {
0000000000000000000000000000000000000000;;		return c.listUnitsInternal(c.sysobj.Call("org.freedesktop.systemd1.Manager.ListUnits", 0).Store)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListUnitsFiltered returns an array with units filtered by state.
0000000000000000000000000000000000000000;;	// It takes a list of units' statuses to filter.
0000000000000000000000000000000000000000;;	func (c *Conn) ListUnitsFiltered(states []string) ([]UnitStatus, error) {
0000000000000000000000000000000000000000;;		return c.listUnitsInternal(c.sysobj.Call("org.freedesktop.systemd1.Manager.ListUnitsFiltered", 0, states).Store)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListUnitsByPatterns returns an array with units.
0000000000000000000000000000000000000000;;	// It takes a list of units' statuses and names to filter.
0000000000000000000000000000000000000000;;	// Note that units may be known by multiple names at the same time,
0000000000000000000000000000000000000000;;	// and hence there might be more unit names loaded than actual units behind them.
0000000000000000000000000000000000000000;;	func (c *Conn) ListUnitsByPatterns(states []string, patterns []string) ([]UnitStatus, error) {
0000000000000000000000000000000000000000;;		return c.listUnitsInternal(c.sysobj.Call("org.freedesktop.systemd1.Manager.ListUnitsByPatterns", 0, states, patterns).Store)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListUnitsByNames returns an array with units. It takes a list of units'
0000000000000000000000000000000000000000;;	// names and returns an UnitStatus array. Comparing to ListUnitsByPatterns
0000000000000000000000000000000000000000;;	// method, this method returns statuses even for inactive or non-existing
0000000000000000000000000000000000000000;;	// units. Input array should contain exact unit names, but not patterns.
0000000000000000000000000000000000000000;;	func (c *Conn) ListUnitsByNames(units []string) ([]UnitStatus, error) {
0000000000000000000000000000000000000000;;		return c.listUnitsInternal(c.sysobj.Call("org.freedesktop.systemd1.Manager.ListUnitsByNames", 0, units).Store)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UnitFile struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) listUnitFilesInternal(f storeFunc) ([]UnitFile, error) {
0000000000000000000000000000000000000000;;		result := make([][]interface{}, 0)
0000000000000000000000000000000000000000;;		err := f(&result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultInterface := make([]interface{}, len(result))
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			resultInterface[i] = result[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files := make([]UnitFile, len(result))
0000000000000000000000000000000000000000;;		fileInterface := make([]interface{}, len(files))
0000000000000000000000000000000000000000;;		for i := range files {
0000000000000000000000000000000000000000;;			fileInterface[i] = &files[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = dbus.Store(resultInterface, fileInterface...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return files, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListUnitFiles returns an array of all available units on disk.
0000000000000000000000000000000000000000;;	func (c *Conn) ListUnitFiles() ([]UnitFile, error) {
0000000000000000000000000000000000000000;;		return c.listUnitFilesInternal(c.sysobj.Call("org.freedesktop.systemd1.Manager.ListUnitFiles", 0).Store)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListUnitFilesByPatterns returns an array of all available units on disk matched the patterns.
0000000000000000000000000000000000000000;;	func (c *Conn) ListUnitFilesByPatterns(states []string, patterns []string) ([]UnitFile, error) {
0000000000000000000000000000000000000000;;		return c.listUnitFilesInternal(c.sysobj.Call("org.freedesktop.systemd1.Manager.ListUnitFilesByPatterns", 0, states, patterns).Store)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LinkUnitFileChange EnableUnitFileChange
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LinkUnitFiles() links unit files (that are located outside of the
0000000000000000000000000000000000000000;;	// usual unit search paths) into the unit search path.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It takes a list of absolute paths to unit files to link and two
0000000000000000000000000000000000000000;;	// booleans. The first boolean controls whether the unit shall be
0000000000000000000000000000000000000000;;	// enabled for runtime only (true, /run), or persistently (false,
0000000000000000000000000000000000000000;;	// /etc).
0000000000000000000000000000000000000000;;	// The second controls whether symlinks pointing to other units shall
0000000000000000000000000000000000000000;;	// be replaced if necessary.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This call returns a list of the changes made. The list consists of
0000000000000000000000000000000000000000;;	// structures with three strings: the type of the change (one of symlink
0000000000000000000000000000000000000000;;	// or unlink), the file name of the symlink and the destination of the
0000000000000000000000000000000000000000;;	// symlink.
0000000000000000000000000000000000000000;;	func (c *Conn) LinkUnitFiles(files []string, runtime bool, force bool) ([]LinkUnitFileChange, error) {
0000000000000000000000000000000000000000;;		result := make([][]interface{}, 0)
0000000000000000000000000000000000000000;;		err := c.sysobj.Call("org.freedesktop.systemd1.Manager.LinkUnitFiles", 0, files, runtime, force).Store(&result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultInterface := make([]interface{}, len(result))
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			resultInterface[i] = result[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes := make([]LinkUnitFileChange, len(result))
0000000000000000000000000000000000000000;;		changesInterface := make([]interface{}, len(changes))
0000000000000000000000000000000000000000;;		for i := range changes {
0000000000000000000000000000000000000000;;			changesInterface[i] = &changes[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = dbus.Store(resultInterface, changesInterface...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return changes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnableUnitFiles() may be used to enable one or more units in the system (by
0000000000000000000000000000000000000000;;	// creating symlinks to them in /etc or /run).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It takes a list of unit files to enable (either just file names or full
0000000000000000000000000000000000000000;;	// absolute paths if the unit files are residing outside the usual unit
0000000000000000000000000000000000000000;;	// search paths), and two booleans: the first controls whether the unit shall
0000000000000000000000000000000000000000;;	// be enabled for runtime only (true, /run), or persistently (false, /etc).
0000000000000000000000000000000000000000;;	// The second one controls whether symlinks pointing to other units shall
0000000000000000000000000000000000000000;;	// be replaced if necessary.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This call returns one boolean and an array with the changes made. The
0000000000000000000000000000000000000000;;	// boolean signals whether the unit files contained any enablement
0000000000000000000000000000000000000000;;	// information (i.e. an [Install]) section. The changes list consists of
0000000000000000000000000000000000000000;;	// structures with three strings: the type of the change (one of symlink
0000000000000000000000000000000000000000;;	// or unlink), the file name of the symlink and the destination of the
0000000000000000000000000000000000000000;;	// symlink.
0000000000000000000000000000000000000000;;	func (c *Conn) EnableUnitFiles(files []string, runtime bool, force bool) (bool, []EnableUnitFileChange, error) {
0000000000000000000000000000000000000000;;		var carries_install_info bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([][]interface{}, 0)
0000000000000000000000000000000000000000;;		err := c.sysobj.Call("org.freedesktop.systemd1.Manager.EnableUnitFiles", 0, files, runtime, force).Store(&carries_install_info, &result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultInterface := make([]interface{}, len(result))
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			resultInterface[i] = result[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes := make([]EnableUnitFileChange, len(result))
0000000000000000000000000000000000000000;;		changesInterface := make([]interface{}, len(changes))
0000000000000000000000000000000000000000;;		for i := range changes {
0000000000000000000000000000000000000000;;			changesInterface[i] = &changes[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = dbus.Store(resultInterface, changesInterface...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return carries_install_info, changes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EnableUnitFileChange struct {
0000000000000000000000000000000000000000;;		Type        string // Type of the change (one of symlink or unlink)
0000000000000000000000000000000000000000;;		Filename    string // File name of the symlink
0000000000000000000000000000000000000000;;		Destination string // Destination of the symlink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisableUnitFiles() may be used to disable one or more units in the system (by
0000000000000000000000000000000000000000;;	// removing symlinks to them from /etc or /run).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It takes a list of unit files to disable (either just file names or full
0000000000000000000000000000000000000000;;	// absolute paths if the unit files are residing outside the usual unit
0000000000000000000000000000000000000000;;	// search paths), and one boolean: whether the unit was enabled for runtime
0000000000000000000000000000000000000000;;	// only (true, /run), or persistently (false, /etc).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This call returns an array with the changes made. The changes list
0000000000000000000000000000000000000000;;	// consists of structures with three strings: the type of the change (one of
0000000000000000000000000000000000000000;;	// symlink or unlink), the file name of the symlink and the destination of the
0000000000000000000000000000000000000000;;	// symlink.
0000000000000000000000000000000000000000;;	func (c *Conn) DisableUnitFiles(files []string, runtime bool) ([]DisableUnitFileChange, error) {
0000000000000000000000000000000000000000;;		result := make([][]interface{}, 0)
0000000000000000000000000000000000000000;;		err := c.sysobj.Call("org.freedesktop.systemd1.Manager.DisableUnitFiles", 0, files, runtime).Store(&result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultInterface := make([]interface{}, len(result))
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			resultInterface[i] = result[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes := make([]DisableUnitFileChange, len(result))
0000000000000000000000000000000000000000;;		changesInterface := make([]interface{}, len(changes))
0000000000000000000000000000000000000000;;		for i := range changes {
0000000000000000000000000000000000000000;;			changesInterface[i] = &changes[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = dbus.Store(resultInterface, changesInterface...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return changes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DisableUnitFileChange struct {
0000000000000000000000000000000000000000;;		Type        string // Type of the change (one of symlink or unlink)
0000000000000000000000000000000000000000;;		Filename    string // File name of the symlink
0000000000000000000000000000000000000000;;		Destination string // Destination of the symlink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaskUnitFiles masks one or more units in the system
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It takes three arguments:
0000000000000000000000000000000000000000;;	//   * list of units to mask (either just file names or full
0000000000000000000000000000000000000000;;	//     absolute paths if the unit files are residing outside
0000000000000000000000000000000000000000;;	//     the usual unit search paths)
0000000000000000000000000000000000000000;;	//   * runtime to specify whether the unit was enabled for runtime
0000000000000000000000000000000000000000;;	//     only (true, /run/systemd/..), or persistently (false, /etc/systemd/..)
0000000000000000000000000000000000000000;;	//   * force flag
0000000000000000000000000000000000000000;;	func (c *Conn) MaskUnitFiles(files []string, runtime bool, force bool) ([]MaskUnitFileChange, error) {
0000000000000000000000000000000000000000;;		result := make([][]interface{}, 0)
0000000000000000000000000000000000000000;;		err := c.sysobj.Call("org.freedesktop.systemd1.Manager.MaskUnitFiles", 0, files, runtime, force).Store(&result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultInterface := make([]interface{}, len(result))
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			resultInterface[i] = result[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes := make([]MaskUnitFileChange, len(result))
0000000000000000000000000000000000000000;;		changesInterface := make([]interface{}, len(changes))
0000000000000000000000000000000000000000;;		for i := range changes {
0000000000000000000000000000000000000000;;			changesInterface[i] = &changes[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = dbus.Store(resultInterface, changesInterface...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return changes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MaskUnitFileChange struct {
0000000000000000000000000000000000000000;;		Type        string // Type of the change (one of symlink or unlink)
0000000000000000000000000000000000000000;;		Filename    string // File name of the symlink
0000000000000000000000000000000000000000;;		Destination string // Destination of the symlink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmaskUnitFiles unmasks one or more units in the system
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It takes two arguments:
0000000000000000000000000000000000000000;;	//   * list of unit files to mask (either just file names or full
0000000000000000000000000000000000000000;;	//     absolute paths if the unit files are residing outside
0000000000000000000000000000000000000000;;	//     the usual unit search paths)
0000000000000000000000000000000000000000;;	//   * runtime to specify whether the unit was enabled for runtime
0000000000000000000000000000000000000000;;	//     only (true, /run/systemd/..), or persistently (false, /etc/systemd/..)
0000000000000000000000000000000000000000;;	func (c *Conn) UnmaskUnitFiles(files []string, runtime bool) ([]UnmaskUnitFileChange, error) {
0000000000000000000000000000000000000000;;		result := make([][]interface{}, 0)
0000000000000000000000000000000000000000;;		err := c.sysobj.Call("org.freedesktop.systemd1.Manager.UnmaskUnitFiles", 0, files, runtime).Store(&result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultInterface := make([]interface{}, len(result))
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			resultInterface[i] = result[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes := make([]UnmaskUnitFileChange, len(result))
0000000000000000000000000000000000000000;;		changesInterface := make([]interface{}, len(changes))
0000000000000000000000000000000000000000;;		for i := range changes {
0000000000000000000000000000000000000000;;			changesInterface[i] = &changes[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = dbus.Store(resultInterface, changesInterface...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return changes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UnmaskUnitFileChange struct {
0000000000000000000000000000000000000000;;		Type        string // Type of the change (one of symlink or unlink)
0000000000000000000000000000000000000000;;		Filename    string // File name of the symlink
0000000000000000000000000000000000000000;;		Destination string // Destination of the symlink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reload instructs systemd to scan for and reload unit files. This is
0000000000000000000000000000000000000000;;	// equivalent to a 'systemctl daemon-reload'.
0000000000000000000000000000000000000000;;	func (c *Conn) Reload() error {
0000000000000000000000000000000000000000;;		return c.sysobj.Call("org.freedesktop.systemd1.Manager.Reload", 0).Store()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unitPath(name string) dbus.ObjectPath {
0000000000000000000000000000000000000000;;		return dbus.ObjectPath("/org/freedesktop/systemd1/unit/" + PathBusEscape(name))
0000000000000000000000000000000000000000;;	}
