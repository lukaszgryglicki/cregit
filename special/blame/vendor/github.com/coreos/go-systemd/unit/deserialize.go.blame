0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8d973c48ce204bda083f5a578278a9cd3743f879;Godeps/_workspace/src/github.com/coreos/go-systemd/unit/deserialize.go[Godeps/_workspace/src/github.com/coreos/go-systemd/unit/deserialize.go][vendor/github.com/coreos/go-systemd/unit/deserialize.go];	
0000000000000000000000000000000000000000;;	package unit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// SYSTEMD_LINE_MAX mimics the maximum line length that systemd can use.
0000000000000000000000000000000000000000;;		// On typical systemd platforms (i.e. modern Linux), this will most
0000000000000000000000000000000000000000;;		// commonly be 2048, so let's use that as a sanity check.
0000000000000000000000000000000000000000;;		// Technically, we should probably pull this at runtime:
0000000000000000000000000000000000000000;;		//    SYSTEMD_LINE_MAX = int(C.sysconf(C.__SC_LINE_MAX))
0000000000000000000000000000000000000000;;		// but this would introduce an (unfortunate) dependency on cgo
0000000000000000000000000000000000000000;;		SYSTEMD_LINE_MAX = 2048
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// characters that systemd considers indicate a newline
0000000000000000000000000000000000000000;;		SYSTEMD_NEWLINE = "\r\n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrLineTooLong = fmt.Errorf("line too long (max %d bytes)", SYSTEMD_LINE_MAX)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deserialize parses a systemd unit file into a list of UnitOption objects.
0000000000000000000000000000000000000000;;	func Deserialize(f io.Reader) (opts []*UnitOption, err error) {
0000000000000000000000000000000000000000;;		lexer, optchan, errchan := newLexer(f)
0000000000000000000000000000000000000000;;		go lexer.lex()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for opt := range optchan {
0000000000000000000000000000000000000000;;			opts = append(opts, &(*opt))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = <-errchan
0000000000000000000000000000000000000000;;		return opts, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLexer(f io.Reader) (*lexer, <-chan *UnitOption, <-chan error) {
0000000000000000000000000000000000000000;;		optchan := make(chan *UnitOption)
0000000000000000000000000000000000000000;;		errchan := make(chan error, 1)
0000000000000000000000000000000000000000;;		buf := bufio.NewReader(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &lexer{buf, optchan, errchan, ""}, optchan, errchan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lexer struct {
0000000000000000000000000000000000000000;;		buf     *bufio.Reader
0000000000000000000000000000000000000000;;		optchan chan *UnitOption
0000000000000000000000000000000000000000;;		errchan chan error
0000000000000000000000000000000000000000;;		section string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) lex() {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(l.optchan)
0000000000000000000000000000000000000000;;			close(l.errchan)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		next := l.lexNextSection
0000000000000000000000000000000000000000;;		for next != nil {
0000000000000000000000000000000000000000;;			if l.buf.Buffered() >= SYSTEMD_LINE_MAX {
0000000000000000000000000000000000000000;;				// systemd truncates lines longer than LINE_MAX
0000000000000000000000000000000000000000;;				// https://bugs.freedesktop.org/show_bug.cgi?id=85308
0000000000000000000000000000000000000000;;				// Rather than allowing this to pass silently, let's
0000000000000000000000000000000000000000;;				// explicitly gate people from encountering this
0000000000000000000000000000000000000000;;				line, err := l.buf.Peek(SYSTEMD_LINE_MAX)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					l.errchan <- err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if bytes.IndexAny(line, SYSTEMD_NEWLINE) == -1 {
0000000000000000000000000000000000000000;;					l.errchan <- ErrLineTooLong
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			next, err = next()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				l.errchan <- err
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lexStep func() (lexStep, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) lexSectionName() (lexStep, error) {
0000000000000000000000000000000000000000;;		sec, err := l.buf.ReadBytes(']')
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("unable to find end of section")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l.lexSectionSuffixFunc(string(sec[:len(sec)-1])), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) lexSectionSuffixFunc(section string) lexStep {
0000000000000000000000000000000000000000;;		return func() (lexStep, error) {
0000000000000000000000000000000000000000;;			garbage, _, err := l.toEOL()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			garbage = bytes.TrimSpace(garbage)
0000000000000000000000000000000000000000;;			if len(garbage) > 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("found garbage after section name %s: %v", l.section, garbage)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return l.lexNextSectionOrOptionFunc(section), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) ignoreLineFunc(next lexStep) lexStep {
0000000000000000000000000000000000000000;;		return func() (lexStep, error) {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				line, _, err := l.toEOL()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				line = bytes.TrimSuffix(line, []byte{' '})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// lack of continuation means this line has been exhausted
0000000000000000000000000000000000000000;;				if !bytes.HasSuffix(line, []byte{'\\'}) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// reached end of buffer, safe to exit
0000000000000000000000000000000000000000;;			return next, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) lexNextSection() (lexStep, error) {
0000000000000000000000000000000000000000;;		r, _, err := l.buf.ReadRune()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r == '[' {
0000000000000000000000000000000000000000;;			return l.lexSectionName, nil
0000000000000000000000000000000000000000;;		} else if isComment(r) {
0000000000000000000000000000000000000000;;			return l.ignoreLineFunc(l.lexNextSection), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l.lexNextSection, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) lexNextSectionOrOptionFunc(section string) lexStep {
0000000000000000000000000000000000000000;;		return func() (lexStep, error) {
0000000000000000000000000000000000000000;;			r, _, err := l.buf.ReadRune()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					err = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if unicode.IsSpace(r) {
0000000000000000000000000000000000000000;;				return l.lexNextSectionOrOptionFunc(section), nil
0000000000000000000000000000000000000000;;			} else if r == '[' {
0000000000000000000000000000000000000000;;				return l.lexSectionName, nil
0000000000000000000000000000000000000000;;			} else if isComment(r) {
0000000000000000000000000000000000000000;;				return l.ignoreLineFunc(l.lexNextSectionOrOptionFunc(section)), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			l.buf.UnreadRune()
0000000000000000000000000000000000000000;;			return l.lexOptionNameFunc(section), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) lexOptionNameFunc(section string) lexStep {
0000000000000000000000000000000000000000;;		return func() (lexStep, error) {
0000000000000000000000000000000000000000;;			var partial bytes.Buffer
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				r, _, err := l.buf.ReadRune()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if r == '\n' || r == '\r' {
0000000000000000000000000000000000000000;;					return nil, errors.New("unexpected newline encountered while parsing option name")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if r == '=' {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				partial.WriteRune(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			name := strings.TrimSpace(partial.String())
0000000000000000000000000000000000000000;;			return l.lexOptionValueFunc(section, name, bytes.Buffer{}), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lexer) lexOptionValueFunc(section, name string, partial bytes.Buffer) lexStep {
0000000000000000000000000000000000000000;;		return func() (lexStep, error) {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				line, eof, err := l.toEOL()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(bytes.TrimSpace(line)) == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				partial.Write(line)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// lack of continuation means this value has been exhausted
0000000000000000000000000000000000000000;;				idx := bytes.LastIndex(line, []byte{'\\'})
0000000000000000000000000000000000000000;;				if idx == -1 || idx != (len(line)-1) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !eof {
0000000000000000000000000000000000000000;;					partial.WriteRune('\n')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return l.lexOptionValueFunc(section, name, partial), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			val := partial.String()
0000000000000000000000000000000000000000;;			if strings.HasSuffix(val, "\n") {
0000000000000000000000000000000000000000;;				// A newline was added to the end, so the file didn't end with a backslash.
0000000000000000000000000000000000000000;;				// => Keep the newline
0000000000000000000000000000000000000000;;				val = strings.TrimSpace(val) + "\n"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				val = strings.TrimSpace(val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.optchan <- &UnitOption{Section: section, Name: name, Value: val}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return l.lexNextSectionOrOptionFunc(section), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toEOL reads until the end-of-line or end-of-file.
0000000000000000000000000000000000000000;;	// Returns (data, EOFfound, error)
0000000000000000000000000000000000000000;;	func (l *lexer) toEOL() ([]byte, bool, error) {
0000000000000000000000000000000000000000;;		line, err := l.buf.ReadBytes('\n')
0000000000000000000000000000000000000000;;		// ignore EOF here since it's roughly equivalent to EOL
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		line = bytes.TrimSuffix(line, []byte{'\r'})
0000000000000000000000000000000000000000;;		line = bytes.TrimSuffix(line, []byte{'\n'})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return line, err == io.EOF, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isComment(r rune) bool {
0000000000000000000000000000000000000000;;		return r == '#' || r == ';'
0000000000000000000000000000000000000000;;	}
