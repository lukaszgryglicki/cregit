0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
2e6b23087c07e0ca25a1986b378417fd0915b4d7;;	
0000000000000000000000000000000000000000;;	// Package journal provides write bindings to the local systemd journal.
0000000000000000000000000000000000000000;;	// It is implemented in pure Go and connects to the journal directly over its
0000000000000000000000000000000000000000;;	// unix socket.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To read from the journal, see the "sdjournal" package, which wraps the
0000000000000000000000000000000000000000;;	// sd-journal a C API.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.freedesktop.org/software/systemd/man/systemd-journald.service.html
0000000000000000000000000000000000000000;;	package journal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Priority of a journal message
0000000000000000000000000000000000000000;;	type Priority int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		PriEmerg Priority = iota
0000000000000000000000000000000000000000;;		PriAlert
0000000000000000000000000000000000000000;;		PriCrit
0000000000000000000000000000000000000000;;		PriErr
0000000000000000000000000000000000000000;;		PriWarning
0000000000000000000000000000000000000000;;		PriNotice
0000000000000000000000000000000000000000;;		PriInfo
0000000000000000000000000000000000000000;;		PriDebug
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var conn net.Conn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		conn, err = net.Dial("unixgram", "/run/systemd/journal/socket")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			conn = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enabled returns true if the local systemd journal is available for logging
0000000000000000000000000000000000000000;;	func Enabled() bool {
0000000000000000000000000000000000000000;;		return conn != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send a message to the local systemd journal. vars is a map of journald
0000000000000000000000000000000000000000;;	// fields to values.  Fields must be composed of uppercase letters, numbers,
0000000000000000000000000000000000000000;;	// and underscores, but must not start with an underscore. Within these
0000000000000000000000000000000000000000;;	// restrictions, any arbitrary field name may be used.  Some names have special
0000000000000000000000000000000000000000;;	// significance: see the journalctl documentation
0000000000000000000000000000000000000000;;	// (http://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)
0000000000000000000000000000000000000000;;	// for more details.  vars may be nil.
0000000000000000000000000000000000000000;;	func Send(message string, priority Priority, vars map[string]string) error {
0000000000000000000000000000000000000000;;		if conn == nil {
0000000000000000000000000000000000000000;;			return journalError("could not connect to journald socket")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		appendVariable(data, "PRIORITY", strconv.Itoa(int(priority)))
0000000000000000000000000000000000000000;;		appendVariable(data, "MESSAGE", message)
0000000000000000000000000000000000000000;;		for k, v := range vars {
0000000000000000000000000000000000000000;;			appendVariable(data, k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := io.Copy(conn, data)
0000000000000000000000000000000000000000;;		if err != nil && isSocketSpaceError(err) {
0000000000000000000000000000000000000000;;			file, err := tempFd()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return journalError(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer file.Close()
0000000000000000000000000000000000000000;;			_, err = io.Copy(file, data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return journalError(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rights := syscall.UnixRights(int(file.Fd()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			/* this connection should always be a UnixConn, but better safe than sorry */
0000000000000000000000000000000000000000;;			unixConn, ok := conn.(*net.UnixConn)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return journalError("can't send file through non-Unix connection")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unixConn.WriteMsgUnix([]byte{}, rights, nil)
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return journalError(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Print prints a message to the local systemd journal using Send().
0000000000000000000000000000000000000000;;	func Print(priority Priority, format string, a ...interface{}) error {
0000000000000000000000000000000000000000;;		return Send(fmt.Sprintf(format, a...), priority, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendVariable(w io.Writer, name, value string) {
0000000000000000000000000000000000000000;;		if !validVarName(name) {
0000000000000000000000000000000000000000;;			journalError("variable name contains invalid character, ignoring")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.ContainsRune(value, '\n') {
0000000000000000000000000000000000000000;;			/* When the value contains a newline, we write:
0000000000000000000000000000000000000000;;			 * - the variable name, followed by a newline
0000000000000000000000000000000000000000;;			 * - the size (in 64bit little endian format)
0000000000000000000000000000000000000000;;			 * - the data, followed by a newline
0000000000000000000000000000000000000000;;			 */
0000000000000000000000000000000000000000;;			fmt.Fprintln(w, name)
0000000000000000000000000000000000000000;;			binary.Write(w, binary.LittleEndian, uint64(len(value)))
0000000000000000000000000000000000000000;;			fmt.Fprintln(w, value)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			/* just write the variable and value all on one line */
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%s=%s\n", name, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validVarName(name string) bool {
0000000000000000000000000000000000000000;;		/* The variable name must be in uppercase and consist only of characters,
0000000000000000000000000000000000000000;;		 * numbers and underscores, and may not begin with an underscore. (from the docs)
0000000000000000000000000000000000000000;;		 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		valid := name[0] != '_'
0000000000000000000000000000000000000000;;		for _, c := range name {
0000000000000000000000000000000000000000;;			valid = valid && ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9') || c == '_'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return valid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSocketSpaceError(err error) bool {
0000000000000000000000000000000000000000;;		opErr, ok := err.(*net.OpError)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sysErr, ok := opErr.Err.(syscall.Errno)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sysErr == syscall.EMSGSIZE || sysErr == syscall.ENOBUFS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tempFd() (*os.File, error) {
0000000000000000000000000000000000000000;;		file, err := ioutil.TempFile("/dev/shm/", "journal.XXXXX")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syscall.Unlink(file.Name())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return file, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func journalError(s string) error {
0000000000000000000000000000000000000000;;		s = "journal error: " + s
0000000000000000000000000000000000000000;;		fmt.Fprintln(os.Stderr, s)
0000000000000000000000000000000000000000;;		return errors.New(s)
0000000000000000000000000000000000000000;;	}
