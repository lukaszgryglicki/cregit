0000000000000000000000000000000000000000;;	// Copyright 2016 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
00d3d819457a61a2df72ee4571d003d5397ccd1f;;	
0000000000000000000000000000000000000000;;	// +build cgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package util
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// #include <stdlib.h>
0000000000000000000000000000000000000000;;	// #include <sys/types.h>
0000000000000000000000000000000000000000;;	// #include <unistd.h>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// int
0000000000000000000000000000000000000000;;	// my_sd_pid_get_owner_uid(void *f, pid_t pid, uid_t *uid)
0000000000000000000000000000000000000000;;	// {
0000000000000000000000000000000000000000;;	//   int (*sd_pid_get_owner_uid)(pid_t, uid_t *);
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   sd_pid_get_owner_uid = (int (*)(pid_t, uid_t *))f;
0000000000000000000000000000000000000000;;	//   return sd_pid_get_owner_uid(pid, uid);
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// int
0000000000000000000000000000000000000000;;	// my_sd_pid_get_unit(void *f, pid_t pid, char **unit)
0000000000000000000000000000000000000000;;	// {
0000000000000000000000000000000000000000;;	//   int (*sd_pid_get_unit)(pid_t, char **);
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   sd_pid_get_unit = (int (*)(pid_t, char **))f;
0000000000000000000000000000000000000000;;	//   return sd_pid_get_unit(pid, unit);
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// int
0000000000000000000000000000000000000000;;	// my_sd_pid_get_slice(void *f, pid_t pid, char **slice)
0000000000000000000000000000000000000000;;	// {
0000000000000000000000000000000000000000;;	//   int (*sd_pid_get_slice)(pid_t, char **);
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   sd_pid_get_slice = (int (*)(pid_t, char **))f;
0000000000000000000000000000000000000000;;	//   return sd_pid_get_slice(pid, slice);
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// int
0000000000000000000000000000000000000000;;	// am_session_leader()
0000000000000000000000000000000000000000;;	// {
0000000000000000000000000000000000000000;;	//   return (getsid(0) == getpid());
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	import "C"
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/dlopen"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var libsystemdNames = []string{
0000000000000000000000000000000000000000;;		// systemd < 209
0000000000000000000000000000000000000000;;		"libsystemd-login.so.0",
0000000000000000000000000000000000000000;;		"libsystemd-login.so",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// systemd >= 209 merged libsystemd-login into libsystemd proper
0000000000000000000000000000000000000000;;		"libsystemd.so.0",
0000000000000000000000000000000000000000;;		"libsystemd.so",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRunningSlice() (slice string, err error) {
0000000000000000000000000000000000000000;;		var h *dlopen.LibHandle
0000000000000000000000000000000000000000;;		h, err = dlopen.GetHandle(libsystemdNames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err1 := h.Close(); err1 != nil {
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sd_pid_get_slice, err := h.GetSymbolPointer("sd_pid_get_slice")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		sl := C.CString(s)
0000000000000000000000000000000000000000;;		defer C.free(unsafe.Pointer(sl))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := C.my_sd_pid_get_slice(sd_pid_get_slice, 0, &sl)
0000000000000000000000000000000000000000;;		if ret < 0 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("error calling sd_pid_get_slice: %v", syscall.Errno(-ret))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return C.GoString(sl), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runningFromSystemService() (ret bool, err error) {
0000000000000000000000000000000000000000;;		var h *dlopen.LibHandle
0000000000000000000000000000000000000000;;		h, err = dlopen.GetHandle(libsystemdNames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err1 := h.Close(); err1 != nil {
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sd_pid_get_owner_uid, err := h.GetSymbolPointer("sd_pid_get_owner_uid")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var uid C.uid_t
0000000000000000000000000000000000000000;;		errno := C.my_sd_pid_get_owner_uid(sd_pid_get_owner_uid, 0, &uid)
0000000000000000000000000000000000000000;;		serrno := syscall.Errno(-errno)
0000000000000000000000000000000000000000;;		// when we're running from a unit file, sd_pid_get_owner_uid returns
0000000000000000000000000000000000000000;;		// ENOENT (systemd <220) or ENXIO (systemd >=220)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case errno >= 0:
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;		case serrno == syscall.ENOENT, serrno == syscall.ENXIO:
0000000000000000000000000000000000000000;;			// Since the implementation of sessions in systemd relies on
0000000000000000000000000000000000000000;;			// the `pam_systemd` module, using the sd_pid_get_owner_uid
0000000000000000000000000000000000000000;;			// heuristic alone can result in false positives if that module
0000000000000000000000000000000000000000;;			// (or PAM itself) is not present or properly configured on the
0000000000000000000000000000000000000000;;			// system. As such, we also check if we're the session leader,
0000000000000000000000000000000000000000;;			// which should be the case if we're invoked from a unit file,
0000000000000000000000000000000000000000;;			// but not if e.g. we're invoked from the command line from a
0000000000000000000000000000000000000000;;			// user's login session
0000000000000000000000000000000000000000;;			ret = C.am_session_leader() == 1
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("error calling sd_pid_get_owner_uid: %v", syscall.Errno(-errno))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func currentUnitName() (unit string, err error) {
0000000000000000000000000000000000000000;;		var h *dlopen.LibHandle
0000000000000000000000000000000000000000;;		h, err = dlopen.GetHandle(libsystemdNames)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err1 := h.Close(); err1 != nil {
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sd_pid_get_unit, err := h.GetSymbolPointer("sd_pid_get_unit")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		u := C.CString(s)
0000000000000000000000000000000000000000;;		defer C.free(unsafe.Pointer(u))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := C.my_sd_pid_get_unit(sd_pid_get_unit, 0, &u)
0000000000000000000000000000000000000000;;		if ret < 0 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("error calling sd_pid_get_unit: %v", syscall.Errno(-ret))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unit = C.GoString(u)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
