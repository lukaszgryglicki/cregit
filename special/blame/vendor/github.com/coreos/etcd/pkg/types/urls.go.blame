0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/types/urls.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/types/urls.go][vendor/github.com/coreos/etcd/pkg/types/urls.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type URLs []url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewURLs(strs []string) (URLs, error) {
0000000000000000000000000000000000000000;;		all := make([]url.URL, len(strs))
0000000000000000000000000000000000000000;;		if len(all) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("no valid URLs given")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, in := range strs {
0000000000000000000000000000000000000000;;			in = strings.TrimSpace(in)
0000000000000000000000000000000000000000;;			u, err := url.Parse(in)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u.Scheme != "http" && u.Scheme != "https" && u.Scheme != "unix" && u.Scheme != "unixs" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("URL scheme must be http, https, unix, or unixs: %s", in)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, _, err := net.SplitHostPort(u.Host); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf(`URL address does not have the form "host:port": %s`, in)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u.Path != "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("URL must not contain a path: %s", in)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			all[i] = *u
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		us := URLs(all)
0000000000000000000000000000000000000000;;		us.Sort()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return us, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MustNewURLs(strs []string) URLs {
0000000000000000000000000000000000000000;;		urls, err := NewURLs(strs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return urls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (us URLs) String() string {
0000000000000000000000000000000000000000;;		return strings.Join(us.StringSlice(), ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (us *URLs) Sort() {
0000000000000000000000000000000000000000;;		sort.Sort(us)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (us URLs) Len() int           { return len(us) }
0000000000000000000000000000000000000000;;	func (us URLs) Less(i, j int) bool { return us[i].String() < us[j].String() }
0000000000000000000000000000000000000000;;	func (us URLs) Swap(i, j int)      { us[i], us[j] = us[j], us[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (us URLs) StringSlice() []string {
0000000000000000000000000000000000000000;;		out := make([]string, len(us))
0000000000000000000000000000000000000000;;		for i := range us {
0000000000000000000000000000000000000000;;			out[i] = us[i].String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
