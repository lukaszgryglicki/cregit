0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/types/urlsmap.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/types/urlsmap.go][vendor/github.com/coreos/etcd/pkg/types/urlsmap.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLsMap is a map from a name to its URLs.
0000000000000000000000000000000000000000;;	type URLsMap map[string]URLs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewURLsMap returns a URLsMap instantiated from the given string,
0000000000000000000000000000000000000000;;	// which consists of discovery-formatted names-to-URLs, like:
0000000000000000000000000000000000000000;;	// mach0=http://1.1.1.1:2380,mach0=http://2.2.2.2::2380,mach1=http://3.3.3.3:2380,mach2=http://4.4.4.4:2380
0000000000000000000000000000000000000000;;	func NewURLsMap(s string) (URLsMap, error) {
0000000000000000000000000000000000000000;;		m := parse(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cl := URLsMap{}
0000000000000000000000000000000000000000;;		for name, urls := range m {
0000000000000000000000000000000000000000;;			us, err := NewURLs(urls)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cl[name] = us
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewURLsMapFromStringMap takes a map of strings and returns a URLsMap. The
0000000000000000000000000000000000000000;;	// string values in the map can be multiple values separated by the sep string.
0000000000000000000000000000000000000000;;	func NewURLsMapFromStringMap(m map[string]string, sep string) (URLsMap, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		um := URLsMap{}
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			um[k], err = NewURLs(strings.Split(v, sep))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return um, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String turns URLsMap into discovery-formatted name-to-URLs sorted by name.
0000000000000000000000000000000000000000;;	func (c URLsMap) String() string {
0000000000000000000000000000000000000000;;		var pairs []string
0000000000000000000000000000000000000000;;		for name, urls := range c {
0000000000000000000000000000000000000000;;			for _, url := range urls {
0000000000000000000000000000000000000000;;				pairs = append(pairs, fmt.Sprintf("%s=%s", name, url.String()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(pairs)
0000000000000000000000000000000000000000;;		return strings.Join(pairs, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLs returns a list of all URLs.
0000000000000000000000000000000000000000;;	// The returned list is sorted in ascending lexicographical order.
0000000000000000000000000000000000000000;;	func (c URLsMap) URLs() []string {
0000000000000000000000000000000000000000;;		var urls []string
0000000000000000000000000000000000000000;;		for _, us := range c {
0000000000000000000000000000000000000000;;			for _, u := range us {
0000000000000000000000000000000000000000;;				urls = append(urls, u.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(urls)
0000000000000000000000000000000000000000;;		return urls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the size of URLsMap.
0000000000000000000000000000000000000000;;	func (c URLsMap) Len() int {
0000000000000000000000000000000000000000;;		return len(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse parses the given string and returns a map listing the values specified for each key.
0000000000000000000000000000000000000000;;	func parse(s string) map[string][]string {
0000000000000000000000000000000000000000;;		m := make(map[string][]string)
0000000000000000000000000000000000000000;;		for s != "" {
0000000000000000000000000000000000000000;;			key := s
0000000000000000000000000000000000000000;;			if i := strings.IndexAny(key, ","); i >= 0 {
0000000000000000000000000000000000000000;;				key, s = key[:i], key[i+1:]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if key == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value := ""
0000000000000000000000000000000000000000;;			if i := strings.Index(key, "="); i >= 0 {
0000000000000000000000000000000000000000;;				key, value = key[:i], key[i+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m[key] = append(m[key], value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
