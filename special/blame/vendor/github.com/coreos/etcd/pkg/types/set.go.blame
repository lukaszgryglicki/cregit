0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/types/set.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/types/set.go][vendor/github.com/coreos/etcd/pkg/types/set.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Set interface {
0000000000000000000000000000000000000000;;		Add(string)
0000000000000000000000000000000000000000;;		Remove(string)
0000000000000000000000000000000000000000;;		Contains(string) bool
0000000000000000000000000000000000000000;;		Equals(Set) bool
0000000000000000000000000000000000000000;;		Length() int
0000000000000000000000000000000000000000;;		Values() []string
0000000000000000000000000000000000000000;;		Copy() Set
0000000000000000000000000000000000000000;;		Sub(Set) Set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewUnsafeSet(values ...string) *unsafeSet {
0000000000000000000000000000000000000000;;		set := &unsafeSet{make(map[string]struct{})}
0000000000000000000000000000000000000000;;		for _, v := range values {
0000000000000000000000000000000000000000;;			set.Add(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewThreadsafeSet(values ...string) *tsafeSet {
0000000000000000000000000000000000000000;;		us := NewUnsafeSet(values...)
0000000000000000000000000000000000000000;;		return &tsafeSet{us, sync.RWMutex{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unsafeSet struct {
0000000000000000000000000000000000000000;;		d map[string]struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a new value to the set (no-op if the value is already present)
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Add(value string) {
0000000000000000000000000000000000000000;;		us.d[value] = struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the given value from the set
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Remove(value string) {
0000000000000000000000000000000000000000;;		delete(us.d, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains returns whether the set contains the given value
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Contains(value string) (exists bool) {
0000000000000000000000000000000000000000;;		_, exists = us.d[value]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainsAll returns whether the set contains all given values
0000000000000000000000000000000000000000;;	func (us *unsafeSet) ContainsAll(values []string) bool {
0000000000000000000000000000000000000000;;		for _, s := range values {
0000000000000000000000000000000000000000;;			if !us.Contains(s) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equals returns whether the contents of two sets are identical
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Equals(other Set) bool {
0000000000000000000000000000000000000000;;		v1 := sort.StringSlice(us.Values())
0000000000000000000000000000000000000000;;		v2 := sort.StringSlice(other.Values())
0000000000000000000000000000000000000000;;		v1.Sort()
0000000000000000000000000000000000000000;;		v2.Sort()
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(v1, v2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Length returns the number of elements in the set
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Length() int {
0000000000000000000000000000000000000000;;		return len(us.d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Values returns the values of the Set in an unspecified order.
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Values() (values []string) {
0000000000000000000000000000000000000000;;		values = make([]string, 0)
0000000000000000000000000000000000000000;;		for val := range us.d {
0000000000000000000000000000000000000000;;			values = append(values, val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy creates a new Set containing the values of the first
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Copy() Set {
0000000000000000000000000000000000000000;;		cp := NewUnsafeSet()
0000000000000000000000000000000000000000;;		for val := range us.d {
0000000000000000000000000000000000000000;;			cp.Add(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sub removes all elements in other from the set
0000000000000000000000000000000000000000;;	func (us *unsafeSet) Sub(other Set) Set {
0000000000000000000000000000000000000000;;		oValues := other.Values()
0000000000000000000000000000000000000000;;		result := us.Copy().(*unsafeSet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, val := range oValues {
0000000000000000000000000000000000000000;;			if _, ok := result.d[val]; !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(result.d, val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tsafeSet struct {
0000000000000000000000000000000000000000;;		us *unsafeSet
0000000000000000000000000000000000000000;;		m  sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Add(value string) {
0000000000000000000000000000000000000000;;		ts.m.Lock()
0000000000000000000000000000000000000000;;		defer ts.m.Unlock()
0000000000000000000000000000000000000000;;		ts.us.Add(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Remove(value string) {
0000000000000000000000000000000000000000;;		ts.m.Lock()
0000000000000000000000000000000000000000;;		defer ts.m.Unlock()
0000000000000000000000000000000000000000;;		ts.us.Remove(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Contains(value string) (exists bool) {
0000000000000000000000000000000000000000;;		ts.m.RLock()
0000000000000000000000000000000000000000;;		defer ts.m.RUnlock()
0000000000000000000000000000000000000000;;		return ts.us.Contains(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Equals(other Set) bool {
0000000000000000000000000000000000000000;;		ts.m.RLock()
0000000000000000000000000000000000000000;;		defer ts.m.RUnlock()
0000000000000000000000000000000000000000;;		return ts.us.Equals(other)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Length() int {
0000000000000000000000000000000000000000;;		ts.m.RLock()
0000000000000000000000000000000000000000;;		defer ts.m.RUnlock()
0000000000000000000000000000000000000000;;		return ts.us.Length()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Values() (values []string) {
0000000000000000000000000000000000000000;;		ts.m.RLock()
0000000000000000000000000000000000000000;;		defer ts.m.RUnlock()
0000000000000000000000000000000000000000;;		return ts.us.Values()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Copy() Set {
0000000000000000000000000000000000000000;;		ts.m.RLock()
0000000000000000000000000000000000000000;;		defer ts.m.RUnlock()
0000000000000000000000000000000000000000;;		usResult := ts.us.Copy().(*unsafeSet)
0000000000000000000000000000000000000000;;		return &tsafeSet{usResult, sync.RWMutex{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *tsafeSet) Sub(other Set) Set {
0000000000000000000000000000000000000000;;		ts.m.RLock()
0000000000000000000000000000000000000000;;		defer ts.m.RUnlock()
0000000000000000000000000000000000000000;;		usResult := ts.us.Sub(other).(*unsafeSet)
0000000000000000000000000000000000000000;;		return &tsafeSet{usResult, sync.RWMutex{}}
0000000000000000000000000000000000000000;;	}
