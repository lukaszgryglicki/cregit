0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/idutil/id.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/idutil/id.go][vendor/github.com/coreos/etcd/pkg/idutil/id.go];	
0000000000000000000000000000000000000000;;	// Package idutil implements utility functions for generating unique,
0000000000000000000000000000000000000000;;	// randomized ids.
0000000000000000000000000000000000000000;;	package idutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tsLen     = 5 * 8
0000000000000000000000000000000000000000;;		cntLen    = 8
0000000000000000000000000000000000000000;;		suffixLen = tsLen + cntLen
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generator generates unique identifiers based on counters, timestamps, and
0000000000000000000000000000000000000000;;	// a node member ID.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The initial id is in this format:
0000000000000000000000000000000000000000;;	// High order byte is memberID, next 5 bytes are from timestamp,
0000000000000000000000000000000000000000;;	// and low order 2 bytes are 0s.
0000000000000000000000000000000000000000;;	// | prefix   | suffix              |
0000000000000000000000000000000000000000;;	// | 2 bytes  | 5 bytes   | 1 byte  |
0000000000000000000000000000000000000000;;	// | memberID | timestamp | cnt     |
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The timestamp 5 bytes is different when the machine is restart
0000000000000000000000000000000000000000;;	// after 1 ms and before 35 years.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It increases suffix to generate the next id.
0000000000000000000000000000000000000000;;	// The count field may overflow to timestamp field, which is intentional.
0000000000000000000000000000000000000000;;	// It helps to extend the event window to 2^56. This doesn't break that
0000000000000000000000000000000000000000;;	// id generated after restart is unique because etcd throughput is <<
0000000000000000000000000000000000000000;;	// 256req/ms(250k reqs/second).
0000000000000000000000000000000000000000;;	type Generator struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		// high order 2 bytes
0000000000000000000000000000000000000000;;		prefix uint64
0000000000000000000000000000000000000000;;		// low order 6 bytes
0000000000000000000000000000000000000000;;		suffix uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGenerator(memberID uint16, now time.Time) *Generator {
0000000000000000000000000000000000000000;;		prefix := uint64(memberID) << suffixLen
0000000000000000000000000000000000000000;;		unixMilli := uint64(now.UnixNano()) / uint64(time.Millisecond/time.Nanosecond)
0000000000000000000000000000000000000000;;		suffix := lowbit(unixMilli, tsLen) << cntLen
0000000000000000000000000000000000000000;;		return &Generator{
0000000000000000000000000000000000000000;;			prefix: prefix,
0000000000000000000000000000000000000000;;			suffix: suffix,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next generates a id that is unique.
0000000000000000000000000000000000000000;;	func (g *Generator) Next() uint64 {
0000000000000000000000000000000000000000;;		g.mu.Lock()
0000000000000000000000000000000000000000;;		defer g.mu.Unlock()
0000000000000000000000000000000000000000;;		g.suffix++
0000000000000000000000000000000000000000;;		id := g.prefix | lowbit(g.suffix, suffixLen)
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lowbit(x uint64, n uint) uint64 {
0000000000000000000000000000000000000000;;		return x & (math.MaxUint64 >> (64 - n))
0000000000000000000000000000000000000000;;	}
