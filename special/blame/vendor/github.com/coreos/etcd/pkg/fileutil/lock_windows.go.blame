0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/fileutil/lock_windows.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/fileutil/lock_windows.go][vendor/github.com/coreos/etcd/pkg/fileutil/lock_windows.go];	
0000000000000000000000000000000000000000;;	// +build windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fileutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		modkernel32    = syscall.NewLazyDLL("kernel32.dll")
0000000000000000000000000000000000000000;;		procLockFileEx = modkernel32.NewProc("LockFileEx")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errLocked = errors.New("The process cannot access the file because another process has locked a portion of the file.")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// https://msdn.microsoft.com/en-us/library/windows/desktop/aa365203(v=vs.85).aspx
0000000000000000000000000000000000000000;;		LOCKFILE_EXCLUSIVE_LOCK   = 2
0000000000000000000000000000000000000000;;		LOCKFILE_FAIL_IMMEDIATELY = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see https://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx
0000000000000000000000000000000000000000;;		errLockViolation syscall.Errno = 0x21
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TryLockFile(path string, flag int, perm os.FileMode) (*LockedFile, error) {
0000000000000000000000000000000000000000;;		f, err := open(path, flag, perm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := lockFile(syscall.Handle(f.Fd()), LOCKFILE_FAIL_IMMEDIATELY); err != nil {
0000000000000000000000000000000000000000;;			f.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &LockedFile{f}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LockFile(path string, flag int, perm os.FileMode) (*LockedFile, error) {
0000000000000000000000000000000000000000;;		f, err := open(path, flag, perm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := lockFile(syscall.Handle(f.Fd()), 0); err != nil {
0000000000000000000000000000000000000000;;			f.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &LockedFile{f}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func open(path string, flag int, perm os.FileMode) (*os.File, error) {
0000000000000000000000000000000000000000;;		if path == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot open empty filename")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var access uint32
0000000000000000000000000000000000000000;;		switch flag {
0000000000000000000000000000000000000000;;		case syscall.O_RDONLY:
0000000000000000000000000000000000000000;;			access = syscall.GENERIC_READ
0000000000000000000000000000000000000000;;		case syscall.O_WRONLY:
0000000000000000000000000000000000000000;;			access = syscall.GENERIC_WRITE
0000000000000000000000000000000000000000;;		case syscall.O_RDWR:
0000000000000000000000000000000000000000;;			access = syscall.GENERIC_READ | syscall.GENERIC_WRITE
0000000000000000000000000000000000000000;;		case syscall.O_WRONLY | syscall.O_CREAT:
0000000000000000000000000000000000000000;;			access = syscall.GENERIC_ALL
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("flag %v is not supported", flag))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd, err := syscall.CreateFile(&(syscall.StringToUTF16(path)[0]),
0000000000000000000000000000000000000000;;			access,
0000000000000000000000000000000000000000;;			syscall.FILE_SHARE_READ|syscall.FILE_SHARE_WRITE|syscall.FILE_SHARE_DELETE,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			syscall.OPEN_ALWAYS,
0000000000000000000000000000000000000000;;			syscall.FILE_ATTRIBUTE_NORMAL,
0000000000000000000000000000000000000000;;			0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.NewFile(uintptr(fd), path), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lockFile(fd syscall.Handle, flags uint32) error {
0000000000000000000000000000000000000000;;		var flag uint32 = LOCKFILE_EXCLUSIVE_LOCK
0000000000000000000000000000000000000000;;		flag |= flags
0000000000000000000000000000000000000000;;		if fd == syscall.InvalidHandle {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := lockFileEx(fd, flag, 1, 0, &syscall.Overlapped{})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if err.Error() == errLocked.Error() {
0000000000000000000000000000000000000000;;			return ErrLocked
0000000000000000000000000000000000000000;;		} else if err != errLockViolation {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lockFileEx(h syscall.Handle, flags, locklow, lockhigh uint32, ol *syscall.Overlapped) (err error) {
0000000000000000000000000000000000000000;;		var reserved uint32 = 0
0000000000000000000000000000000000000000;;		r1, _, e1 := syscall.Syscall6(procLockFileEx.Addr(), 6, uintptr(h), uintptr(flags), uintptr(reserved), uintptr(locklow), uintptr(lockhigh), uintptr(unsafe.Pointer(ol)))
0000000000000000000000000000000000000000;;		if r1 == 0 {
0000000000000000000000000000000000000000;;			if e1 != 0 {
0000000000000000000000000000000000000000;;				err = error(e1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = syscall.EINVAL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
