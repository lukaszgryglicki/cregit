0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/fileutil/fileutil.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/fileutil/fileutil.go][vendor/github.com/coreos/etcd/pkg/fileutil/fileutil.go];	
0000000000000000000000000000000000000000;;	// Package fileutil implements utility functions related to files and paths.
0000000000000000000000000000000000000000;;	package fileutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PrivateFileMode grants owner to read/write a file.
0000000000000000000000000000000000000000;;		PrivateFileMode = 0600
0000000000000000000000000000000000000000;;		// PrivateDirMode grants owner to make/remove files inside the directory.
0000000000000000000000000000000000000000;;		PrivateDirMode = 0700
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "pkg/fileutil")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDirWriteable checks if dir is writable by writing and removing a file
0000000000000000000000000000000000000000;;	// to dir. It returns nil if dir is writable.
0000000000000000000000000000000000000000;;	func IsDirWriteable(dir string) error {
0000000000000000000000000000000000000000;;		f := filepath.Join(dir, ".touch")
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(f, []byte(""), PrivateFileMode); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.Remove(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadDir returns the filenames in the given directory in sorted order.
0000000000000000000000000000000000000000;;	func ReadDir(dirpath string) ([]string, error) {
0000000000000000000000000000000000000000;;		dir, err := os.Open(dirpath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer dir.Close()
0000000000000000000000000000000000000000;;		names, err := dir.Readdirnames(-1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(names)
0000000000000000000000000000000000000000;;		return names, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TouchDirAll is similar to os.MkdirAll. It creates directories with 0700 permission if any directory
0000000000000000000000000000000000000000;;	// does not exists. TouchDirAll also ensures the given directory is writable.
0000000000000000000000000000000000000000;;	func TouchDirAll(dir string) error {
0000000000000000000000000000000000000000;;		// If path is already a directory, MkdirAll does nothing
0000000000000000000000000000000000000000;;		// and returns nil.
0000000000000000000000000000000000000000;;		err := os.MkdirAll(dir, PrivateDirMode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if mkdirAll("a/text") and "text" is not
0000000000000000000000000000000000000000;;			// a directory, this will return syscall.ENOTDIR
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return IsDirWriteable(dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateDirAll is similar to TouchDirAll but returns error
0000000000000000000000000000000000000000;;	// if the deepest directory was not empty.
0000000000000000000000000000000000000000;;	func CreateDirAll(dir string) error {
0000000000000000000000000000000000000000;;		err := TouchDirAll(dir)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			var ns []string
0000000000000000000000000000000000000000;;			ns, err = ReadDir(dir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(ns) != 0 {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("expected %q to be empty, got %q", dir, ns)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Exist(name string) bool {
0000000000000000000000000000000000000000;;		_, err := os.Stat(name)
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ZeroToEnd zeros a file starting from SEEK_CUR to its SEEK_END. May temporarily
0000000000000000000000000000000000000000;;	// shorten the length of the file.
0000000000000000000000000000000000000000;;	func ZeroToEnd(f *os.File) error {
0000000000000000000000000000000000000000;;		// TODO: support FALLOC_FL_ZERO_RANGE
0000000000000000000000000000000000000000;;		off, err := f.Seek(0, os.SEEK_CUR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lenf, lerr := f.Seek(0, os.SEEK_END)
0000000000000000000000000000000000000000;;		if lerr != nil {
0000000000000000000000000000000000000000;;			return lerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = f.Truncate(off); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// make sure blocks remain allocated
0000000000000000000000000000000000000000;;		if err = Preallocate(f, lenf, true); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = f.Seek(off, os.SEEK_SET)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
