0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/netutil/netutil.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/netutil/netutil.go][vendor/github.com/coreos/etcd/pkg/netutil/netutil.go];	
0000000000000000000000000000000000000000;;	// Package netutil implements network-related utility functions.
0000000000000000000000000000000000000000;;	package netutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "pkg/netutil")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// indirection for testing
0000000000000000000000000000000000000000;;		resolveTCPAddr = net.ResolveTCPAddr
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const retryInterval = time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolveTCPAddrs is a convenience wrapper for net.ResolveTCPAddr.
0000000000000000000000000000000000000000;;	// resolveTCPAddrs return a new set of url.URLs, in which all DNS hostnames
0000000000000000000000000000000000000000;;	// are resolved.
0000000000000000000000000000000000000000;;	func resolveTCPAddrs(ctx context.Context, urls [][]url.URL) ([][]url.URL, error) {
0000000000000000000000000000000000000000;;		newurls := make([][]url.URL, 0)
0000000000000000000000000000000000000000;;		for _, us := range urls {
0000000000000000000000000000000000000000;;			nus := make([]url.URL, len(us))
0000000000000000000000000000000000000000;;			for i, u := range us {
0000000000000000000000000000000000000000;;				nu, err := url.Parse(u.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nus[i] = *nu
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, u := range nus {
0000000000000000000000000000000000000000;;				h, err := resolveURL(ctx, u)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if h != "" {
0000000000000000000000000000000000000000;;					nus[i].Host = h
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newurls = append(newurls, nus)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newurls, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resolveURL(ctx context.Context, u url.URL) (string, error) {
0000000000000000000000000000000000000000;;		for ctx.Err() == nil {
0000000000000000000000000000000000000000;;			host, _, err := net.SplitHostPort(u.Host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("could not parse url %s during tcp resolving", u.Host)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if host == "localhost" || net.ParseIP(host) != nil {
0000000000000000000000000000000000000000;;				return "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tcpAddr, err := resolveTCPAddr("tcp", u.Host)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				plog.Infof("resolving %s to %s", u.Host, tcpAddr.String())
0000000000000000000000000000000000000000;;				return tcpAddr.String(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Warningf("failed resolving host %s (%v); retrying in %v", u.Host, err, retryInterval)
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				plog.Errorf("could not resolve host %s", u.Host)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			case <-time.After(retryInterval):
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", ctx.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// urlsEqual checks equality of url.URLS between two arrays.
0000000000000000000000000000000000000000;;	// This check pass even if an URL is in hostname and opposite is in IP address.
0000000000000000000000000000000000000000;;	func urlsEqual(ctx context.Context, a []url.URL, b []url.URL) bool {
0000000000000000000000000000000000000000;;		if len(a) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		urls, err := resolveTCPAddrs(ctx, [][]url.URL{a, b})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a, b = urls[0], urls[1]
0000000000000000000000000000000000000000;;		sort.Sort(types.URLs(a))
0000000000000000000000000000000000000000;;		sort.Sort(types.URLs(b))
0000000000000000000000000000000000000000;;		for i := range a {
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(a[i], b[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func URLStringsEqual(ctx context.Context, a []string, b []string) bool {
0000000000000000000000000000000000000000;;		if len(a) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		urlsA := make([]url.URL, 0)
0000000000000000000000000000000000000000;;		for _, str := range a {
0000000000000000000000000000000000000000;;			u, err := url.Parse(str)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			urlsA = append(urlsA, *u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		urlsB := make([]url.URL, 0)
0000000000000000000000000000000000000000;;		for _, str := range b {
0000000000000000000000000000000000000000;;			u, err := url.Parse(str)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			urlsB = append(urlsB, *u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return urlsEqual(ctx, urlsA, urlsB)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsNetworkTimeoutError(err error) bool {
0000000000000000000000000000000000000000;;		nerr, ok := err.(net.Error)
0000000000000000000000000000000000000000;;		return ok && nerr.Timeout()
0000000000000000000000000000000000000000;;	}
