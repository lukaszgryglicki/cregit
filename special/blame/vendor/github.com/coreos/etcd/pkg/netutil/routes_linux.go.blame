0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	// +build linux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package netutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/cpuutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errNoDefaultRoute = fmt.Errorf("could not find default route")
0000000000000000000000000000000000000000;;	var errNoDefaultHost = fmt.Errorf("could not find default host")
0000000000000000000000000000000000000000;;	var errNoDefaultInterface = fmt.Errorf("could not find default interface")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDefaultHost obtains the first IP address of machine from the routing table and returns the IP address as string.
0000000000000000000000000000000000000000;;	// An IPv4 address is preferred to an IPv6 address for backward compatibility.
0000000000000000000000000000000000000000;;	func GetDefaultHost() (string, error) {
0000000000000000000000000000000000000000;;		rmsgs, rerr := getDefaultRoutes()
0000000000000000000000000000000000000000;;		if rerr != nil {
0000000000000000000000000000000000000000;;			return "", rerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// prioritize IPv4
0000000000000000000000000000000000000000;;		if rmsg, ok := rmsgs[syscall.AF_INET]; ok {
0000000000000000000000000000000000000000;;			if host, err := chooseHost(syscall.AF_INET, rmsg); host != "" || err != nil {
0000000000000000000000000000000000000000;;				return host, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(rmsgs, syscall.AF_INET)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sort so choice is deterministic
0000000000000000000000000000000000000000;;		var families []int
0000000000000000000000000000000000000000;;		for family := range rmsgs {
0000000000000000000000000000000000000000;;			families = append(families, int(family))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Ints(families)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range families {
0000000000000000000000000000000000000000;;			family := uint8(f)
0000000000000000000000000000000000000000;;			if host, err := chooseHost(family, rmsgs[family]); host != "" || err != nil {
0000000000000000000000000000000000000000;;				return host, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", errNoDefaultHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func chooseHost(family uint8, rmsg *syscall.NetlinkMessage) (string, error) {
0000000000000000000000000000000000000000;;		host, oif, err := parsePREFSRC(rmsg)
0000000000000000000000000000000000000000;;		if host != "" || err != nil {
0000000000000000000000000000000000000000;;			return host, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// prefsrc not detected, fall back to getting address from iface
0000000000000000000000000000000000000000;;		ifmsg, ierr := getIfaceAddr(oif, family)
0000000000000000000000000000000000000000;;		if ierr != nil {
0000000000000000000000000000000000000000;;			return "", ierr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs, aerr := syscall.ParseNetlinkRouteAttr(ifmsg)
0000000000000000000000000000000000000000;;		if aerr != nil {
0000000000000000000000000000000000000000;;			return "", aerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, attr := range attrs {
0000000000000000000000000000000000000000;;			// search for RTA_DST because ipv6 doesn't have RTA_SRC
0000000000000000000000000000000000000000;;			if attr.Attr.Type == syscall.RTA_DST {
0000000000000000000000000000000000000000;;				return net.IP(attr.Value).String(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDefaultRoutes() (map[uint8]*syscall.NetlinkMessage, error) {
0000000000000000000000000000000000000000;;		dat, err := syscall.NetlinkRIB(syscall.RTM_GETROUTE, syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs, msgErr := syscall.ParseNetlinkMessage(dat)
0000000000000000000000000000000000000000;;		if msgErr != nil {
0000000000000000000000000000000000000000;;			return nil, msgErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		routes := make(map[uint8]*syscall.NetlinkMessage)
0000000000000000000000000000000000000000;;		rtmsg := syscall.RtMsg{}
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			if m.Header.Type != syscall.RTM_NEWROUTE {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer(m.Data[:syscall.SizeofRtMsg])
0000000000000000000000000000000000000000;;			if rerr := binary.Read(buf, cpuutil.ByteOrder(), &rtmsg); rerr != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rtmsg.Dst_len == 0 && rtmsg.Table == syscall.RT_TABLE_MAIN {
0000000000000000000000000000000000000000;;				// zero-length Dst_len implies default route
0000000000000000000000000000000000000000;;				msg := m
0000000000000000000000000000000000000000;;				routes[rtmsg.Family] = &msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(routes) > 0 {
0000000000000000000000000000000000000000;;			return routes, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, errNoDefaultRoute
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used to get an address of interface.
0000000000000000000000000000000000000000;;	func getIfaceAddr(idx uint32, family uint8) (*syscall.NetlinkMessage, error) {
0000000000000000000000000000000000000000;;		dat, err := syscall.NetlinkRIB(syscall.RTM_GETADDR, int(family))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs, msgErr := syscall.ParseNetlinkMessage(dat)
0000000000000000000000000000000000000000;;		if msgErr != nil {
0000000000000000000000000000000000000000;;			return nil, msgErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ifaddrmsg := syscall.IfAddrmsg{}
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			if m.Header.Type != syscall.RTM_NEWADDR {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer(m.Data[:syscall.SizeofIfAddrmsg])
0000000000000000000000000000000000000000;;			if rerr := binary.Read(buf, cpuutil.ByteOrder(), &ifaddrmsg); rerr != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ifaddrmsg.Index == idx {
0000000000000000000000000000000000000000;;				return &m, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("could not find address for interface index %v", idx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used to get a name of interface.
0000000000000000000000000000000000000000;;	func getIfaceLink(idx uint32) (*syscall.NetlinkMessage, error) {
0000000000000000000000000000000000000000;;		dat, err := syscall.NetlinkRIB(syscall.RTM_GETLINK, syscall.AF_UNSPEC)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs, msgErr := syscall.ParseNetlinkMessage(dat)
0000000000000000000000000000000000000000;;		if msgErr != nil {
0000000000000000000000000000000000000000;;			return nil, msgErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ifinfomsg := syscall.IfInfomsg{}
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			if m.Header.Type != syscall.RTM_NEWLINK {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer(m.Data[:syscall.SizeofIfInfomsg])
0000000000000000000000000000000000000000;;			if rerr := binary.Read(buf, cpuutil.ByteOrder(), &ifinfomsg); rerr != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ifinfomsg.Index == int32(idx) {
0000000000000000000000000000000000000000;;				return &m, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("could not find link for interface index %v", idx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDefaultInterfaces gets names of interfaces and returns a map[interface]families.
0000000000000000000000000000000000000000;;	func GetDefaultInterfaces() (map[string]uint8, error) {
0000000000000000000000000000000000000000;;		interfaces := make(map[string]uint8)
0000000000000000000000000000000000000000;;		rmsgs, rerr := getDefaultRoutes()
0000000000000000000000000000000000000000;;		if rerr != nil {
0000000000000000000000000000000000000000;;			return interfaces, rerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for family, rmsg := range rmsgs {
0000000000000000000000000000000000000000;;			_, oif, err := parsePREFSRC(rmsg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return interfaces, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ifmsg, ierr := getIfaceLink(oif)
0000000000000000000000000000000000000000;;			if ierr != nil {
0000000000000000000000000000000000000000;;				return interfaces, ierr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			attrs, aerr := syscall.ParseNetlinkRouteAttr(ifmsg)
0000000000000000000000000000000000000000;;			if aerr != nil {
0000000000000000000000000000000000000000;;				return interfaces, aerr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, attr := range attrs {
0000000000000000000000000000000000000000;;				if attr.Attr.Type == syscall.IFLA_IFNAME {
0000000000000000000000000000000000000000;;					// key is an interface name
0000000000000000000000000000000000000000;;					// possible values: 2 - AF_INET, 10 - AF_INET6, 12 - dualstack
0000000000000000000000000000000000000000;;					interfaces[string(attr.Value[:len(attr.Value)-1])] += family
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(interfaces) > 0 {
0000000000000000000000000000000000000000;;			return interfaces, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return interfaces, errNoDefaultInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parsePREFSRC returns preferred source address and output interface index (RTA_OIF).
0000000000000000000000000000000000000000;;	func parsePREFSRC(m *syscall.NetlinkMessage) (host string, oif uint32, err error) {
0000000000000000000000000000000000000000;;		var attrs []syscall.NetlinkRouteAttr
0000000000000000000000000000000000000000;;		attrs, err = syscall.ParseNetlinkRouteAttr(m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, attr := range attrs {
0000000000000000000000000000000000000000;;			if attr.Attr.Type == syscall.RTA_PREFSRC {
0000000000000000000000000000000000000000;;				host = net.IP(attr.Value).String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if attr.Attr.Type == syscall.RTA_OIF {
0000000000000000000000000000000000000000;;				oif = cpuutil.ByteOrder().Uint32(attr.Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if host != "" && oif != uint32(0) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oif == 0 {
0000000000000000000000000000000000000000;;			err = errNoDefaultRoute
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
