0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a0c6d1f6525fb38e26fc8c9217073cf57b989161;;	
0000000000000000000000000000000000000000;;	package ioutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultBufferBytes = 128 * 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PageWriter implements the io.Writer interface so that writes will
0000000000000000000000000000000000000000;;	// either be in page chunks or from flushing.
0000000000000000000000000000000000000000;;	type PageWriter struct {
0000000000000000000000000000000000000000;;		w io.Writer
0000000000000000000000000000000000000000;;		// pageOffset tracks the page offset of the base of the buffer
0000000000000000000000000000000000000000;;		pageOffset int
0000000000000000000000000000000000000000;;		// pageBytes is the number of bytes per page
0000000000000000000000000000000000000000;;		pageBytes int
0000000000000000000000000000000000000000;;		// bufferedBytes counts the number of bytes pending for write in the buffer
0000000000000000000000000000000000000000;;		bufferedBytes int
0000000000000000000000000000000000000000;;		// buf holds the write buffer
0000000000000000000000000000000000000000;;		buf []byte
0000000000000000000000000000000000000000;;		// bufWatermarkBytes is the number of bytes the buffer can hold before it needs
0000000000000000000000000000000000000000;;		// to be flushed. It is less than len(buf) so there is space for slack writes
0000000000000000000000000000000000000000;;		// to bring the writer to page alignment.
0000000000000000000000000000000000000000;;		bufWatermarkBytes int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPageWriter creates a new PageWriter. pageBytes is the number of bytes
0000000000000000000000000000000000000000;;	// to write per page. pageOffset is the starting offset of io.Writer.
0000000000000000000000000000000000000000;;	func NewPageWriter(w io.Writer, pageBytes, pageOffset int) *PageWriter {
0000000000000000000000000000000000000000;;		return &PageWriter{
0000000000000000000000000000000000000000;;			w:                 w,
0000000000000000000000000000000000000000;;			pageOffset:        pageOffset,
0000000000000000000000000000000000000000;;			pageBytes:         pageBytes,
0000000000000000000000000000000000000000;;			buf:               make([]byte, defaultBufferBytes+pageBytes),
0000000000000000000000000000000000000000;;			bufWatermarkBytes: defaultBufferBytes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pw *PageWriter) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if len(p)+pw.bufferedBytes <= pw.bufWatermarkBytes {
0000000000000000000000000000000000000000;;			// no overflow
0000000000000000000000000000000000000000;;			copy(pw.buf[pw.bufferedBytes:], p)
0000000000000000000000000000000000000000;;			pw.bufferedBytes += len(p)
0000000000000000000000000000000000000000;;			return len(p), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// complete the slack page in the buffer if unaligned
0000000000000000000000000000000000000000;;		slack := pw.pageBytes - ((pw.pageOffset + pw.bufferedBytes) % pw.pageBytes)
0000000000000000000000000000000000000000;;		if slack != pw.pageBytes {
0000000000000000000000000000000000000000;;			partial := slack > len(p)
0000000000000000000000000000000000000000;;			if partial {
0000000000000000000000000000000000000000;;				// not enough data to complete the slack page
0000000000000000000000000000000000000000;;				slack = len(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// special case: writing to slack page in buffer
0000000000000000000000000000000000000000;;			copy(pw.buf[pw.bufferedBytes:], p[:slack])
0000000000000000000000000000000000000000;;			pw.bufferedBytes += slack
0000000000000000000000000000000000000000;;			n = slack
0000000000000000000000000000000000000000;;			p = p[slack:]
0000000000000000000000000000000000000000;;			if partial {
0000000000000000000000000000000000000000;;				// avoid forcing an unaligned flush
0000000000000000000000000000000000000000;;				return n, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// buffer contents are now page-aligned; clear out
0000000000000000000000000000000000000000;;		if err = pw.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// directly write all complete pages without copying
0000000000000000000000000000000000000000;;		if len(p) > pw.pageBytes {
0000000000000000000000000000000000000000;;			pages := len(p) / pw.pageBytes
0000000000000000000000000000000000000000;;			c, werr := pw.w.Write(p[:pages*pw.pageBytes])
0000000000000000000000000000000000000000;;			n += c
0000000000000000000000000000000000000000;;			if werr != nil {
0000000000000000000000000000000000000000;;				return n, werr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p = p[pages*pw.pageBytes:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// write remaining tail to buffer
0000000000000000000000000000000000000000;;		c, werr := pw.Write(p)
0000000000000000000000000000000000000000;;		n += c
0000000000000000000000000000000000000000;;		return n, werr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pw *PageWriter) Flush() error {
0000000000000000000000000000000000000000;;		if pw.bufferedBytes == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := pw.w.Write(pw.buf[:pw.bufferedBytes])
0000000000000000000000000000000000000000;;		pw.pageOffset = (pw.pageOffset + pw.bufferedBytes) % pw.pageBytes
0000000000000000000000000000000000000000;;		pw.bufferedBytes = 0
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
