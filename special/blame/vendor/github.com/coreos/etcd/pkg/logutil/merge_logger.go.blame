0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/pkg/logutil/merge_logger.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/logutil/merge_logger.go][vendor/github.com/coreos/etcd/pkg/logutil/merge_logger.go];	
0000000000000000000000000000000000000000;;	// Package logutil includes utilities to facilitate logging.
0000000000000000000000000000000000000000;;	package logutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultMergePeriod     = time.Second
0000000000000000000000000000000000000000;;		defaultTimeOutputScale = 10 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outputInterval = time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// line represents a log line that can be printed out
0000000000000000000000000000000000000000;;	// through capnslog.PackageLogger.
0000000000000000000000000000000000000000;;	type line struct {
0000000000000000000000000000000000000000;;		level capnslog.LogLevel
0000000000000000000000000000000000000000;;		str   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l line) append(s string) line {
0000000000000000000000000000000000000000;;		return line{
0000000000000000000000000000000000000000;;			level: l.level,
0000000000000000000000000000000000000000;;			str:   l.str + " " + s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// status represents the merge status of a line.
0000000000000000000000000000000000000000;;	type status struct {
0000000000000000000000000000000000000000;;		period time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start time.Time // start time of latest merge period
0000000000000000000000000000000000000000;;		count int       // number of merged lines from starting
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *status) isInMergePeriod(now time.Time) bool {
0000000000000000000000000000000000000000;;		return s.period == 0 || s.start.Add(s.period).After(now)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *status) isEmpty() bool { return s.count == 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *status) summary(now time.Time) string {
0000000000000000000000000000000000000000;;		ts := s.start.Round(defaultTimeOutputScale)
0000000000000000000000000000000000000000;;		took := now.Round(defaultTimeOutputScale).Sub(ts)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("[merged %d repeated lines in %s]", s.count, took)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *status) reset(now time.Time) {
0000000000000000000000000000000000000000;;		s.start = now
0000000000000000000000000000000000000000;;		s.count = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeLogger supports merge logging, which merges repeated log lines
0000000000000000000000000000000000000000;;	// and prints summary log lines instead.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For merge logging, MergeLogger prints out the line when the line appears
0000000000000000000000000000000000000000;;	// at the first time. MergeLogger holds the same log line printed within
0000000000000000000000000000000000000000;;	// defaultMergePeriod, and prints out summary log line at the end of defaultMergePeriod.
0000000000000000000000000000000000000000;;	// It stops merging when the line doesn't appear within the
0000000000000000000000000000000000000000;;	// defaultMergePeriod.
0000000000000000000000000000000000000000;;	type MergeLogger struct {
0000000000000000000000000000000000000000;;		*capnslog.PackageLogger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu      sync.Mutex // protect statusm
0000000000000000000000000000000000000000;;		statusm map[line]*status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMergeLogger(logger *capnslog.PackageLogger) *MergeLogger {
0000000000000000000000000000000000000000;;		l := &MergeLogger{
0000000000000000000000000000000000000000;;			PackageLogger: logger,
0000000000000000000000000000000000000000;;			statusm:       make(map[line]*status),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go l.outputLoop()
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeInfo(entries ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.INFO,
0000000000000000000000000000000000000000;;			str:   fmt.Sprint(entries...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeInfof(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.INFO,
0000000000000000000000000000000000000000;;			str:   fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeNotice(entries ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.NOTICE,
0000000000000000000000000000000000000000;;			str:   fmt.Sprint(entries...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeNoticef(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.NOTICE,
0000000000000000000000000000000000000000;;			str:   fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeWarning(entries ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.WARNING,
0000000000000000000000000000000000000000;;			str:   fmt.Sprint(entries...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeWarningf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.WARNING,
0000000000000000000000000000000000000000;;			str:   fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeError(entries ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.ERROR,
0000000000000000000000000000000000000000;;			str:   fmt.Sprint(entries...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) MergeErrorf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		l.merge(line{
0000000000000000000000000000000000000000;;			level: capnslog.ERROR,
0000000000000000000000000000000000000000;;			str:   fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) merge(ln line) {
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// increase count if the logger is merging the line
0000000000000000000000000000000000000000;;		if status, ok := l.statusm[ln]; ok {
0000000000000000000000000000000000000000;;			status.count++
0000000000000000000000000000000000000000;;			l.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// initialize status of the line
0000000000000000000000000000000000000000;;		l.statusm[ln] = &status{
0000000000000000000000000000000000000000;;			period: defaultMergePeriod,
0000000000000000000000000000000000000000;;			start:  time.Now(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// release the lock before IO operation
0000000000000000000000000000000000000000;;		l.mu.Unlock()
0000000000000000000000000000000000000000;;		// print out the line at its first time
0000000000000000000000000000000000000000;;		l.PackageLogger.Logf(ln.level, ln.str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *MergeLogger) outputLoop() {
0000000000000000000000000000000000000000;;		for now := range time.Tick(outputInterval) {
0000000000000000000000000000000000000000;;			var outputs []line
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			l.mu.Lock()
0000000000000000000000000000000000000000;;			for ln, status := range l.statusm {
0000000000000000000000000000000000000000;;				if status.isInMergePeriod(now) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if status.isEmpty() {
0000000000000000000000000000000000000000;;					delete(l.statusm, ln)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				outputs = append(outputs, ln.append(status.summary(now)))
0000000000000000000000000000000000000000;;				status.reset(now)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, o := range outputs {
0000000000000000000000000000000000000000;;				l.PackageLogger.Logf(o.level, o.str)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
