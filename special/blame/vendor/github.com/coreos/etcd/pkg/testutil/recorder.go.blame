0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/pkg/testutil/recorder.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/testutil/recorder.go][vendor/github.com/coreos/etcd/pkg/testutil/recorder.go];	
0000000000000000000000000000000000000000;;	package testutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Action struct {
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Params []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Recorder interface {
0000000000000000000000000000000000000000;;		// Record publishes an Action (e.g., function call) which will
0000000000000000000000000000000000000000;;		// be reflected by Wait() or Chan()
0000000000000000000000000000000000000000;;		Record(a Action)
0000000000000000000000000000000000000000;;		// Wait waits until at least n Actions are available or returns with error
0000000000000000000000000000000000000000;;		Wait(n int) ([]Action, error)
0000000000000000000000000000000000000000;;		// Action returns immediately available Actions
0000000000000000000000000000000000000000;;		Action() []Action
0000000000000000000000000000000000000000;;		// Chan returns the channel for actions published by Record
0000000000000000000000000000000000000000;;		Chan() <-chan Action
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecorderBuffered appends all Actions to a slice
0000000000000000000000000000000000000000;;	type RecorderBuffered struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		actions []Action
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RecorderBuffered) Record(a Action) {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		r.actions = append(r.actions, a)
0000000000000000000000000000000000000000;;		r.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *RecorderBuffered) Action() []Action {
0000000000000000000000000000000000000000;;		r.Lock()
0000000000000000000000000000000000000000;;		cpy := make([]Action, len(r.actions))
0000000000000000000000000000000000000000;;		copy(cpy, r.actions)
0000000000000000000000000000000000000000;;		r.Unlock()
0000000000000000000000000000000000000000;;		return cpy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *RecorderBuffered) Wait(n int) (acts []Action, err error) {
0000000000000000000000000000000000000000;;		// legacy racey behavior
0000000000000000000000000000000000000000;;		WaitSchedule()
0000000000000000000000000000000000000000;;		acts = r.Action()
0000000000000000000000000000000000000000;;		if len(acts) < n {
0000000000000000000000000000000000000000;;			err = newLenErr(n, len(acts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return acts, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *RecorderBuffered) Chan() <-chan Action {
0000000000000000000000000000000000000000;;		ch := make(chan Action)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			acts := r.Action()
0000000000000000000000000000000000000000;;			for i := range acts {
0000000000000000000000000000000000000000;;				ch <- acts[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecorderStream writes all Actions to an unbuffered channel
0000000000000000000000000000000000000000;;	type recorderStream struct {
0000000000000000000000000000000000000000;;		ch chan Action
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRecorderStream() Recorder {
0000000000000000000000000000000000000000;;		return &recorderStream{ch: make(chan Action)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *recorderStream) Record(a Action) {
0000000000000000000000000000000000000000;;		r.ch <- a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *recorderStream) Action() (acts []Action) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case act := <-r.ch:
0000000000000000000000000000000000000000;;				acts = append(acts, act)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return acts
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *recorderStream) Chan() <-chan Action {
0000000000000000000000000000000000000000;;		return r.ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *recorderStream) Wait(n int) ([]Action, error) {
0000000000000000000000000000000000000000;;		acts := make([]Action, n)
0000000000000000000000000000000000000000;;		timeoutC := time.After(5 * time.Second)
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case acts[i] = <-r.ch:
0000000000000000000000000000000000000000;;			case <-timeoutC:
0000000000000000000000000000000000000000;;				acts = acts[:i]
0000000000000000000000000000000000000000;;				return acts, newLenErr(n, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// extra wait to catch any Action spew
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case act := <-r.ch:
0000000000000000000000000000000000000000;;			acts = append(acts, act)
0000000000000000000000000000000000000000;;		case <-time.After(10 * time.Millisecond):
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return acts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLenErr(expected int, actual int) error {
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("len(actions) = %d, expected >= %d", actual, expected)
0000000000000000000000000000000000000000;;		return errors.New(s)
0000000000000000000000000000000000000000;;	}
