0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/pkg/testutil/leak.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/testutil/leak.go][vendor/github.com/coreos/etcd/pkg/testutil/leak.go];	
0000000000000000000000000000000000000000;;	package testutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	CheckLeakedGoroutine verifies tests do not leave any leaky
0000000000000000000000000000000000000000;;	goroutines. It returns true when there are goroutines still
0000000000000000000000000000000000000000;;	running(leaking) after all tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		import "github.com/coreos/etcd/pkg/testutil"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func TestMain(m *testing.M) {
0000000000000000000000000000000000000000;;			v := m.Run()
0000000000000000000000000000000000000000;;			if v == 0 && testutil.CheckLeakedGoroutine() {
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			os.Exit(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func TestSample(t *testing.T) {
0000000000000000000000000000000000000000;;			defer testutil.AfterTest(t)
0000000000000000000000000000000000000000;;			...
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func CheckLeakedGoroutine() bool {
0000000000000000000000000000000000000000;;		if testing.Short() {
0000000000000000000000000000000000000000;;			// not counting goroutines for leakage in -short mode
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gs := interestingGoroutines()
0000000000000000000000000000000000000000;;		if len(gs) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stackCount := make(map[string]int)
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(`\(0[0-9a-fx, ]*\)`)
0000000000000000000000000000000000000000;;		for _, g := range gs {
0000000000000000000000000000000000000000;;			// strip out pointer arguments in first function of stack dump
0000000000000000000000000000000000000000;;			normalized := string(re.ReplaceAll([]byte(g), []byte("(...)")))
0000000000000000000000000000000000000000;;			stackCount[normalized]++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "Too many goroutines running after all test(s).\n")
0000000000000000000000000000000000000000;;		for stack, count := range stackCount {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "%d instances of:\n%s\n", count, stack)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AfterTest(t *testing.T) {
0000000000000000000000000000000000000000;;		http.DefaultTransport.(*http.Transport).CloseIdleConnections()
0000000000000000000000000000000000000000;;		if testing.Short() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var bad string
0000000000000000000000000000000000000000;;		badSubstring := map[string]string{
0000000000000000000000000000000000000000;;			").writeLoop(":                                 "a Transport",
0000000000000000000000000000000000000000;;			"created by net/http/httptest.(*Server).Start": "an httptest.Server",
0000000000000000000000000000000000000000;;			"timeoutHandler":                               "a TimeoutHandler",
0000000000000000000000000000000000000000;;			"net.(*netFD).connect(":                        "a timing out dial",
0000000000000000000000000000000000000000;;			").noteClientGone(":                            "a closenotifier sender",
0000000000000000000000000000000000000000;;			").readLoop(":                                  "a Transport",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var stacks string
0000000000000000000000000000000000000000;;		for i := 0; i < 6; i++ {
0000000000000000000000000000000000000000;;			bad = ""
0000000000000000000000000000000000000000;;			stacks = strings.Join(interestingGoroutines(), "\n\n")
0000000000000000000000000000000000000000;;			for substr, what := range badSubstring {
0000000000000000000000000000000000000000;;				if strings.Contains(stacks, substr) {
0000000000000000000000000000000000000000;;					bad = what
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bad == "" {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Bad stuff found, but goroutines might just still be
0000000000000000000000000000000000000000;;			// shutting down, so give it some time.
0000000000000000000000000000000000000000;;			time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Errorf("Test appears to have leaked %s:\n%s", bad, stacks)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func interestingGoroutines() (gs []string) {
0000000000000000000000000000000000000000;;		buf := make([]byte, 2<<20)
0000000000000000000000000000000000000000;;		buf = buf[:runtime.Stack(buf, true)]
0000000000000000000000000000000000000000;;		for _, g := range strings.Split(string(buf), "\n\n") {
0000000000000000000000000000000000000000;;			sl := strings.SplitN(g, "\n", 2)
0000000000000000000000000000000000000000;;			if len(sl) != 2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stack := strings.TrimSpace(sl[1])
0000000000000000000000000000000000000000;;			if stack == "" ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "created by os/signal.init") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "runtime/panic.go") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "created by testing.RunTests") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "testing.Main(") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "runtime.goexit") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "github.com/coreos/etcd/pkg/testutil.interestingGoroutines") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "github.com/coreos/etcd/pkg/logutil.(*MergeLogger).outputLoop") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "github.com/golang/glog.(*loggingT).flushDaemon") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "created by runtime.gc") ||
0000000000000000000000000000000000000000;;				strings.Contains(stack, "runtime.MHeap_Scavenger") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gs = append(gs, stack)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(gs)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
