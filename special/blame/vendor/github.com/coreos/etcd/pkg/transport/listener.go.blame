0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/pkg/transport/listener.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/transport/listener.go][vendor/github.com/coreos/etcd/pkg/transport/listener.go];	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/fileutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/tlsutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewListener(addr, scheme string, tlscfg *tls.Config) (l net.Listener, err error) {
0000000000000000000000000000000000000000;;		if l, err = newListener(addr, scheme); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wrapTLS(addr, scheme, tlscfg, l)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newListener(addr string, scheme string) (net.Listener, error) {
0000000000000000000000000000000000000000;;		if scheme == "unix" || scheme == "unixs" {
0000000000000000000000000000000000000000;;			// unix sockets via unix://laddr
0000000000000000000000000000000000000000;;			return NewUnixListener(addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return net.Listen("tcp", addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wrapTLS(addr, scheme string, tlscfg *tls.Config, l net.Listener) (net.Listener, error) {
0000000000000000000000000000000000000000;;		if scheme != "https" && scheme != "unixs" {
0000000000000000000000000000000000000000;;			return l, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tlscfg == nil {
0000000000000000000000000000000000000000;;			l.Close()
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot listen on TLS for %s: KeyFile and CertFile are not presented", scheme+"://"+addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tls.NewListener(l, tlscfg), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TLSInfo struct {
0000000000000000000000000000000000000000;;		CertFile       string
0000000000000000000000000000000000000000;;		KeyFile        string
0000000000000000000000000000000000000000;;		CAFile         string
0000000000000000000000000000000000000000;;		TrustedCAFile  string
0000000000000000000000000000000000000000;;		ClientCertAuth bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServerName ensures the cert matches the given host in case of discovery / virtual hosting
0000000000000000000000000000000000000000;;		ServerName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selfCert bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parseFunc exists to simplify testing. Typically, parseFunc
0000000000000000000000000000000000000000;;		// should be left nil. In that case, tls.X509KeyPair will be used.
0000000000000000000000000000000000000000;;		parseFunc func([]byte, []byte) (tls.Certificate, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info TLSInfo) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("cert = %s, key = %s, ca = %s, trusted-ca = %s, client-cert-auth = %v", info.CertFile, info.KeyFile, info.CAFile, info.TrustedCAFile, info.ClientCertAuth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info TLSInfo) Empty() bool {
0000000000000000000000000000000000000000;;		return info.CertFile == "" && info.KeyFile == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SelfCert(dirpath string, hosts []string) (info TLSInfo, err error) {
0000000000000000000000000000000000000000;;		if err = fileutil.TouchDirAll(dirpath); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certPath := filepath.Join(dirpath, "cert.pem")
0000000000000000000000000000000000000000;;		keyPath := filepath.Join(dirpath, "key.pem")
0000000000000000000000000000000000000000;;		_, errcert := os.Stat(certPath)
0000000000000000000000000000000000000000;;		_, errkey := os.Stat(keyPath)
0000000000000000000000000000000000000000;;		if errcert == nil && errkey == nil {
0000000000000000000000000000000000000000;;			info.CertFile = certPath
0000000000000000000000000000000000000000;;			info.KeyFile = keyPath
0000000000000000000000000000000000000000;;			info.selfCert = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
0000000000000000000000000000000000000000;;		serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmpl := x509.Certificate{
0000000000000000000000000000000000000000;;			SerialNumber: serialNumber,
0000000000000000000000000000000000000000;;			Subject:      pkix.Name{Organization: []string{"etcd"}},
0000000000000000000000000000000000000000;;			NotBefore:    time.Now(),
0000000000000000000000000000000000000000;;			NotAfter:     time.Now().Add(365 * (24 * time.Hour)),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
0000000000000000000000000000000000000000;;			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;			BasicConstraintsValid: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, host := range hosts {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(host); ip != nil {
0000000000000000000000000000000000000000;;				tmpl.IPAddresses = append(tmpl.IPAddresses, ip)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tmpl.DNSNames = append(tmpl.DNSNames, strings.Split(host, ":")[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priv, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		derBytes, err := x509.CreateCertificate(rand.Reader, &tmpl, &tmpl, &priv.PublicKey, priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certOut, err := os.Create(certPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pem.Encode(certOut, &pem.Block{Type: "CERTIFICATE", Bytes: derBytes})
0000000000000000000000000000000000000000;;		certOut.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := x509.MarshalECPrivateKey(priv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyOut, err := os.OpenFile(keyPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pem.Encode(keyOut, &pem.Block{Type: "EC PRIVATE KEY", Bytes: b})
0000000000000000000000000000000000000000;;		keyOut.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return SelfCert(dirpath, hosts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info TLSInfo) baseConfig() (*tls.Config, error) {
0000000000000000000000000000000000000000;;		if info.KeyFile == "" || info.CertFile == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("KeyFile and CertFile must both be present[key: %v, cert: %v]", info.KeyFile, info.CertFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsCert, err := tlsutil.NewCert(info.CertFile, info.KeyFile, info.parseFunc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &tls.Config{
0000000000000000000000000000000000000000;;			Certificates: []tls.Certificate{*tlsCert},
0000000000000000000000000000000000000000;;			MinVersion:   tls.VersionTLS12,
0000000000000000000000000000000000000000;;			ServerName:   info.ServerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cafiles returns a list of CA file paths.
0000000000000000000000000000000000000000;;	func (info TLSInfo) cafiles() []string {
0000000000000000000000000000000000000000;;		cs := make([]string, 0)
0000000000000000000000000000000000000000;;		if info.CAFile != "" {
0000000000000000000000000000000000000000;;			cs = append(cs, info.CAFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.TrustedCAFile != "" {
0000000000000000000000000000000000000000;;			cs = append(cs, info.TrustedCAFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerConfig generates a tls.Config object for use by an HTTP server.
0000000000000000000000000000000000000000;;	func (info TLSInfo) ServerConfig() (*tls.Config, error) {
0000000000000000000000000000000000000000;;		cfg, err := info.baseConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg.ClientAuth = tls.NoClientCert
0000000000000000000000000000000000000000;;		if info.CAFile != "" || info.ClientCertAuth {
0000000000000000000000000000000000000000;;			cfg.ClientAuth = tls.RequireAndVerifyClientCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CAFiles := info.cafiles()
0000000000000000000000000000000000000000;;		if len(CAFiles) > 0 {
0000000000000000000000000000000000000000;;			cp, err := tlsutil.NewCertPool(CAFiles)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cfg.ClientCAs = cp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "h2" NextProtos is necessary for enabling HTTP2 for go's HTTP server
0000000000000000000000000000000000000000;;		cfg.NextProtos = []string{"h2"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfig generates a tls.Config object for use by an HTTP client.
0000000000000000000000000000000000000000;;	func (info TLSInfo) ClientConfig() (*tls.Config, error) {
0000000000000000000000000000000000000000;;		var cfg *tls.Config
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !info.Empty() {
0000000000000000000000000000000000000000;;			cfg, err = info.baseConfig()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cfg = &tls.Config{ServerName: info.ServerName}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CAFiles := info.cafiles()
0000000000000000000000000000000000000000;;		if len(CAFiles) > 0 {
0000000000000000000000000000000000000000;;			cfg.RootCAs, err = tlsutil.NewCertPool(CAFiles)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if given a CA, trust any host with a cert signed by the CA
0000000000000000000000000000000000000000;;			log.Println("warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated")
0000000000000000000000000000000000000000;;			cfg.ServerName = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if info.selfCert {
0000000000000000000000000000000000000000;;			cfg.InsecureSkipVerify = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShallowCopyTLSConfig copies *tls.Config. This is only
0000000000000000000000000000000000000000;;	// work-around for go-vet tests, which complains
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   assignment copies lock value to p: crypto/tls.Config contains sync.Once contains sync.Mutex
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Keep up-to-date with 'go/src/crypto/tls/common.go'
0000000000000000000000000000000000000000;;	func ShallowCopyTLSConfig(cfg *tls.Config) *tls.Config {
0000000000000000000000000000000000000000;;		ncfg := tls.Config{
0000000000000000000000000000000000000000;;			Time:                     cfg.Time,
0000000000000000000000000000000000000000;;			Certificates:             cfg.Certificates,
0000000000000000000000000000000000000000;;			NameToCertificate:        cfg.NameToCertificate,
0000000000000000000000000000000000000000;;			GetCertificate:           cfg.GetCertificate,
0000000000000000000000000000000000000000;;			RootCAs:                  cfg.RootCAs,
0000000000000000000000000000000000000000;;			NextProtos:               cfg.NextProtos,
0000000000000000000000000000000000000000;;			ServerName:               cfg.ServerName,
0000000000000000000000000000000000000000;;			ClientAuth:               cfg.ClientAuth,
0000000000000000000000000000000000000000;;			ClientCAs:                cfg.ClientCAs,
0000000000000000000000000000000000000000;;			InsecureSkipVerify:       cfg.InsecureSkipVerify,
0000000000000000000000000000000000000000;;			CipherSuites:             cfg.CipherSuites,
0000000000000000000000000000000000000000;;			PreferServerCipherSuites: cfg.PreferServerCipherSuites,
0000000000000000000000000000000000000000;;			SessionTicketKey:         cfg.SessionTicketKey,
0000000000000000000000000000000000000000;;			ClientSessionCache:       cfg.ClientSessionCache,
0000000000000000000000000000000000000000;;			MinVersion:               cfg.MinVersion,
0000000000000000000000000000000000000000;;			MaxVersion:               cfg.MaxVersion,
0000000000000000000000000000000000000000;;			CurvePreferences:         cfg.CurvePreferences,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ncfg
0000000000000000000000000000000000000000;;	}
