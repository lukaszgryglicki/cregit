0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/pkg/adt/interval_tree.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/adt/interval_tree.go][vendor/github.com/coreos/etcd/pkg/adt/interval_tree.go];	
0000000000000000000000000000000000000000;;	package adt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Comparable is an interface for trichotomic comparisons.
0000000000000000000000000000000000000000;;	type Comparable interface {
0000000000000000000000000000000000000000;;		// Compare gives the result of a 3-way comparison
0000000000000000000000000000000000000000;;		// a.Compare(b) = 1 => a > b
0000000000000000000000000000000000000000;;		// a.Compare(b) = 0 => a == b
0000000000000000000000000000000000000000;;		// a.Compare(b) = -1 => a < b
0000000000000000000000000000000000000000;;		Compare(c Comparable) int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rbcolor int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		black rbcolor = iota
0000000000000000000000000000000000000000;;		red
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interval implements a Comparable interval [begin, end)
0000000000000000000000000000000000000000;;	// TODO: support different sorts of intervals: (a,b), [a,b], (a, b]
0000000000000000000000000000000000000000;;	type Interval struct {
0000000000000000000000000000000000000000;;		Begin Comparable
0000000000000000000000000000000000000000;;		End   Comparable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare on an interval gives == if the interval overlaps.
0000000000000000000000000000000000000000;;	func (ivl *Interval) Compare(c Comparable) int {
0000000000000000000000000000000000000000;;		ivl2 := c.(*Interval)
0000000000000000000000000000000000000000;;		ivbCmpBegin := ivl.Begin.Compare(ivl2.Begin)
0000000000000000000000000000000000000000;;		ivbCmpEnd := ivl.Begin.Compare(ivl2.End)
0000000000000000000000000000000000000000;;		iveCmpBegin := ivl.End.Compare(ivl2.Begin)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ivl is left of ivl2
0000000000000000000000000000000000000000;;		if ivbCmpBegin < 0 && iveCmpBegin <= 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// iv is right of iv2
0000000000000000000000000000000000000000;;		if ivbCmpEnd >= 0 {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type intervalNode struct {
0000000000000000000000000000000000000000;;		// iv is the interval-value pair entry.
0000000000000000000000000000000000000000;;		iv IntervalValue
0000000000000000000000000000000000000000;;		// max endpoint of all descendent nodes.
0000000000000000000000000000000000000000;;		max Comparable
0000000000000000000000000000000000000000;;		// left and right are sorted by low endpoint of key interval
0000000000000000000000000000000000000000;;		left, right *intervalNode
0000000000000000000000000000000000000000;;		// parent is the direct ancestor of the node
0000000000000000000000000000000000000000;;		parent *intervalNode
0000000000000000000000000000000000000000;;		c      rbcolor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *intervalNode) color() rbcolor {
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			return black
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x.c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *intervalNode) height() int {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ld := n.left.height()
0000000000000000000000000000000000000000;;		rd := n.right.height()
0000000000000000000000000000000000000000;;		if ld < rd {
0000000000000000000000000000000000000000;;			return rd + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ld + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *intervalNode) min() *intervalNode {
0000000000000000000000000000000000000000;;		for x.left != nil {
0000000000000000000000000000000000000000;;			x = x.left
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// successor is the next in-order node in the tree
0000000000000000000000000000000000000000;;	func (x *intervalNode) successor() *intervalNode {
0000000000000000000000000000000000000000;;		if x.right != nil {
0000000000000000000000000000000000000000;;			return x.right.min()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		y := x.parent
0000000000000000000000000000000000000000;;		for y != nil && x == y.right {
0000000000000000000000000000000000000000;;			x = y
0000000000000000000000000000000000000000;;			y = y.parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return y
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateMax updates the maximum values for a node and its ancestors
0000000000000000000000000000000000000000;;	func (x *intervalNode) updateMax() {
0000000000000000000000000000000000000000;;		for x != nil {
0000000000000000000000000000000000000000;;			oldmax := x.max
0000000000000000000000000000000000000000;;			max := x.iv.Ivl.End
0000000000000000000000000000000000000000;;			if x.left != nil && x.left.max.Compare(max) > 0 {
0000000000000000000000000000000000000000;;				max = x.left.max
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.right != nil && x.right.max.Compare(max) > 0 {
0000000000000000000000000000000000000000;;				max = x.right.max
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if oldmax.Compare(max) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.max = max
0000000000000000000000000000000000000000;;			x = x.parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodeVisitor func(n *intervalNode) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// visit will call a node visitor on each node that overlaps the given interval
0000000000000000000000000000000000000000;;	func (x *intervalNode) visit(iv *Interval, nv nodeVisitor) {
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := iv.Compare(&x.iv.Ivl)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case v < 0:
0000000000000000000000000000000000000000;;			x.left.visit(iv, nv)
0000000000000000000000000000000000000000;;		case v > 0:
0000000000000000000000000000000000000000;;			maxiv := Interval{x.iv.Ivl.Begin, x.max}
0000000000000000000000000000000000000000;;			if maxiv.Compare(iv) == 0 {
0000000000000000000000000000000000000000;;				x.left.visit(iv, nv)
0000000000000000000000000000000000000000;;				x.right.visit(iv, nv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			nv(x)
0000000000000000000000000000000000000000;;			x.left.visit(iv, nv)
0000000000000000000000000000000000000000;;			x.right.visit(iv, nv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IntervalValue struct {
0000000000000000000000000000000000000000;;		Ivl Interval
0000000000000000000000000000000000000000;;		Val interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntervalTree represents a (mostly) textbook implementation of the
0000000000000000000000000000000000000000;;	// "Introduction to Algorithms" (Cormen et al, 2nd ed.) chapter 13 red-black tree
0000000000000000000000000000000000000000;;	// and chapter 14.3 interval tree with search supporting "stabbing queries".
0000000000000000000000000000000000000000;;	type IntervalTree struct {
0000000000000000000000000000000000000000;;		root  *intervalNode
0000000000000000000000000000000000000000;;		count int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes the node with the given interval from the tree, returning
0000000000000000000000000000000000000000;;	// true if a node is in fact removed.
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Delete(ivl Interval) bool {
0000000000000000000000000000000000000000;;		z := ivt.find(ivl)
0000000000000000000000000000000000000000;;		if z == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		y := z
0000000000000000000000000000000000000000;;		if z.left != nil && z.right != nil {
0000000000000000000000000000000000000000;;			y = z.successor()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := y.left
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			x = y.right
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x != nil {
0000000000000000000000000000000000000000;;			x.parent = y.parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if y.parent == nil {
0000000000000000000000000000000000000000;;			ivt.root = x
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if y == y.parent.left {
0000000000000000000000000000000000000000;;				y.parent.left = x
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				y.parent.right = x
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			y.parent.updateMax()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if y != z {
0000000000000000000000000000000000000000;;			z.iv = y.iv
0000000000000000000000000000000000000000;;			z.updateMax()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if y.color() == black && x != nil {
0000000000000000000000000000000000000000;;			ivt.deleteFixup(x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ivt.count--
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) deleteFixup(x *intervalNode) {
0000000000000000000000000000000000000000;;		for x != ivt.root && x.color() == black && x.parent != nil {
0000000000000000000000000000000000000000;;			if x == x.parent.left {
0000000000000000000000000000000000000000;;				w := x.parent.right
0000000000000000000000000000000000000000;;				if w.color() == red {
0000000000000000000000000000000000000000;;					w.c = black
0000000000000000000000000000000000000000;;					x.parent.c = red
0000000000000000000000000000000000000000;;					ivt.rotateLeft(x.parent)
0000000000000000000000000000000000000000;;					w = x.parent.right
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if w == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if w.left.color() == black && w.right.color() == black {
0000000000000000000000000000000000000000;;					w.c = red
0000000000000000000000000000000000000000;;					x = x.parent
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if w.right.color() == black {
0000000000000000000000000000000000000000;;						w.left.c = black
0000000000000000000000000000000000000000;;						w.c = red
0000000000000000000000000000000000000000;;						ivt.rotateRight(w)
0000000000000000000000000000000000000000;;						w = x.parent.right
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.c = x.parent.color()
0000000000000000000000000000000000000000;;					x.parent.c = black
0000000000000000000000000000000000000000;;					w.right.c = black
0000000000000000000000000000000000000000;;					ivt.rotateLeft(x.parent)
0000000000000000000000000000000000000000;;					x = ivt.root
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// same as above but with left and right exchanged
0000000000000000000000000000000000000000;;				w := x.parent.left
0000000000000000000000000000000000000000;;				if w.color() == red {
0000000000000000000000000000000000000000;;					w.c = black
0000000000000000000000000000000000000000;;					x.parent.c = red
0000000000000000000000000000000000000000;;					ivt.rotateRight(x.parent)
0000000000000000000000000000000000000000;;					w = x.parent.left
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if w == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if w.left.color() == black && w.right.color() == black {
0000000000000000000000000000000000000000;;					w.c = red
0000000000000000000000000000000000000000;;					x = x.parent
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if w.left.color() == black {
0000000000000000000000000000000000000000;;						w.right.c = black
0000000000000000000000000000000000000000;;						w.c = red
0000000000000000000000000000000000000000;;						ivt.rotateLeft(w)
0000000000000000000000000000000000000000;;						w = x.parent.left
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.c = x.parent.color()
0000000000000000000000000000000000000000;;					x.parent.c = black
0000000000000000000000000000000000000000;;					w.left.c = black
0000000000000000000000000000000000000000;;					ivt.rotateRight(x.parent)
0000000000000000000000000000000000000000;;					x = ivt.root
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x != nil {
0000000000000000000000000000000000000000;;			x.c = black
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert adds a node with the given interval into the tree.
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Insert(ivl Interval, val interface{}) {
0000000000000000000000000000000000000000;;		var y *intervalNode
0000000000000000000000000000000000000000;;		z := &intervalNode{iv: IntervalValue{ivl, val}, max: ivl.End, c: red}
0000000000000000000000000000000000000000;;		x := ivt.root
0000000000000000000000000000000000000000;;		for x != nil {
0000000000000000000000000000000000000000;;			y = x
0000000000000000000000000000000000000000;;			if z.iv.Ivl.Begin.Compare(x.iv.Ivl.Begin) < 0 {
0000000000000000000000000000000000000000;;				x = x.left
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x = x.right
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		z.parent = y
0000000000000000000000000000000000000000;;		if y == nil {
0000000000000000000000000000000000000000;;			ivt.root = z
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if z.iv.Ivl.Begin.Compare(y.iv.Ivl.Begin) < 0 {
0000000000000000000000000000000000000000;;				y.left = z
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				y.right = z
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			y.updateMax()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.c = red
0000000000000000000000000000000000000000;;		ivt.insertFixup(z)
0000000000000000000000000000000000000000;;		ivt.count++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) insertFixup(z *intervalNode) {
0000000000000000000000000000000000000000;;		for z.parent != nil && z.parent.parent != nil && z.parent.color() == red {
0000000000000000000000000000000000000000;;			if z.parent == z.parent.parent.left {
0000000000000000000000000000000000000000;;				y := z.parent.parent.right
0000000000000000000000000000000000000000;;				if y.color() == red {
0000000000000000000000000000000000000000;;					y.c = black
0000000000000000000000000000000000000000;;					z.parent.c = black
0000000000000000000000000000000000000000;;					z.parent.parent.c = red
0000000000000000000000000000000000000000;;					z = z.parent.parent
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if z == z.parent.right {
0000000000000000000000000000000000000000;;						z = z.parent
0000000000000000000000000000000000000000;;						ivt.rotateLeft(z)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					z.parent.c = black
0000000000000000000000000000000000000000;;					z.parent.parent.c = red
0000000000000000000000000000000000000000;;					ivt.rotateRight(z.parent.parent)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// same as then with left/right exchanged
0000000000000000000000000000000000000000;;				y := z.parent.parent.left
0000000000000000000000000000000000000000;;				if y.color() == red {
0000000000000000000000000000000000000000;;					y.c = black
0000000000000000000000000000000000000000;;					z.parent.c = black
0000000000000000000000000000000000000000;;					z.parent.parent.c = red
0000000000000000000000000000000000000000;;					z = z.parent.parent
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if z == z.parent.left {
0000000000000000000000000000000000000000;;						z = z.parent
0000000000000000000000000000000000000000;;						ivt.rotateRight(z)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					z.parent.c = black
0000000000000000000000000000000000000000;;					z.parent.parent.c = red
0000000000000000000000000000000000000000;;					ivt.rotateLeft(z.parent.parent)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ivt.root.c = black
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rotateLeft moves x so it is left of its right child
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) rotateLeft(x *intervalNode) {
0000000000000000000000000000000000000000;;		y := x.right
0000000000000000000000000000000000000000;;		x.right = y.left
0000000000000000000000000000000000000000;;		if y.left != nil {
0000000000000000000000000000000000000000;;			y.left.parent = x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.updateMax()
0000000000000000000000000000000000000000;;		ivt.replaceParent(x, y)
0000000000000000000000000000000000000000;;		y.left = x
0000000000000000000000000000000000000000;;		y.updateMax()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rotateLeft moves x so it is right of its left child
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) rotateRight(x *intervalNode) {
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		y := x.left
0000000000000000000000000000000000000000;;		x.left = y.right
0000000000000000000000000000000000000000;;		if y.right != nil {
0000000000000000000000000000000000000000;;			y.right.parent = x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.updateMax()
0000000000000000000000000000000000000000;;		ivt.replaceParent(x, y)
0000000000000000000000000000000000000000;;		y.right = x
0000000000000000000000000000000000000000;;		y.updateMax()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// replaceParent replaces x's parent with y
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) replaceParent(x *intervalNode, y *intervalNode) {
0000000000000000000000000000000000000000;;		y.parent = x.parent
0000000000000000000000000000000000000000;;		if x.parent == nil {
0000000000000000000000000000000000000000;;			ivt.root = y
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if x == x.parent.left {
0000000000000000000000000000000000000000;;				x.parent.left = y
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.parent.right = y
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.parent.updateMax()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.parent = y
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len gives the number of elements in the tree
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Len() int { return ivt.count }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Height is the number of levels in the tree; one node has height 1.
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Height() int { return ivt.root.height() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxHeight is the expected maximum tree height given the number of nodes
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) MaxHeight() int {
0000000000000000000000000000000000000000;;		return int((2 * math.Log2(float64(ivt.Len()+1))) + 0.5)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntervalVisitor is used on tree searchs; return false to stop searching.
0000000000000000000000000000000000000000;;	type IntervalVisitor func(n *IntervalValue) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Visit calls a visitor function on every tree node intersecting the given interval.
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Visit(ivl Interval, ivv IntervalVisitor) {
0000000000000000000000000000000000000000;;		ivt.root.visit(&ivl, func(n *intervalNode) bool { return ivv(&n.iv) })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// find the exact node for a given interval
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) find(ivl Interval) (ret *intervalNode) {
0000000000000000000000000000000000000000;;		f := func(n *intervalNode) bool {
0000000000000000000000000000000000000000;;			if n.iv.Ivl != ivl {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret = n
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ivt.root.visit(&ivl, f)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find gets the IntervalValue for the node matching the given interval
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Find(ivl Interval) (ret *IntervalValue) {
0000000000000000000000000000000000000000;;		n := ivt.find(ivl)
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &n.iv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains returns true if there is some tree node intersecting the given interval.
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Contains(iv Interval) bool {
0000000000000000000000000000000000000000;;		x := ivt.root
0000000000000000000000000000000000000000;;		for x != nil && iv.Compare(&x.iv.Ivl) != 0 {
0000000000000000000000000000000000000000;;			if x.left != nil && x.left.max.Compare(iv.Begin) > 0 {
0000000000000000000000000000000000000000;;				x = x.left
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x = x.right
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stab returns a slice with all elements in the tree intersecting the interval.
0000000000000000000000000000000000000000;;	func (ivt *IntervalTree) Stab(iv Interval) (ivs []*IntervalValue) {
0000000000000000000000000000000000000000;;		if ivt.count == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f := func(n *IntervalValue) bool { ivs = append(ivs, n); return true }
0000000000000000000000000000000000000000;;		ivt.Visit(iv, f)
0000000000000000000000000000000000000000;;		return ivs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StringComparable string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s StringComparable) Compare(c Comparable) int {
0000000000000000000000000000000000000000;;		sc := c.(StringComparable)
0000000000000000000000000000000000000000;;		if s < sc {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s > sc {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStringInterval(begin, end string) Interval {
0000000000000000000000000000000000000000;;		return Interval{StringComparable(begin), StringComparable(end)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStringPoint(s string) Interval {
0000000000000000000000000000000000000000;;		return Interval{StringComparable(s), StringComparable(s + "\x00")}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringAffineComparable treats "" as > all other strings
0000000000000000000000000000000000000000;;	type StringAffineComparable string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s StringAffineComparable) Compare(c Comparable) int {
0000000000000000000000000000000000000000;;		sc := c.(StringAffineComparable)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			if len(sc) == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(sc) == 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s < sc {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s > sc {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStringAffineInterval(begin, end string) Interval {
0000000000000000000000000000000000000000;;		return Interval{StringAffineComparable(begin), StringAffineComparable(end)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func NewStringAffinePoint(s string) Interval {
0000000000000000000000000000000000000000;;		return NewStringAffineInterval(s, s+"\x00")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewInt64Interval(a int64, b int64) Interval {
0000000000000000000000000000000000000000;;		return Interval{Int64Comparable(a), Int64Comparable(b)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewInt64Point(a int64) Interval {
0000000000000000000000000000000000000000;;		return Interval{Int64Comparable(a), Int64Comparable(a + 1)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Int64Comparable int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v Int64Comparable) Compare(c Comparable) int {
0000000000000000000000000000000000000000;;		vc := c.(Int64Comparable)
0000000000000000000000000000000000000000;;		cmp := v - vc
0000000000000000000000000000000000000000;;		if cmp < 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cmp > 0 {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
