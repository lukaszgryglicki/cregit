0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/pkg/schedule/schedule.go[Godeps/_workspace/src/github.com/coreos/etcd/pkg/schedule/schedule.go][vendor/github.com/coreos/etcd/pkg/schedule/schedule.go];	
0000000000000000000000000000000000000000;;	package schedule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Job func(context.Context)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scheduler can schedule jobs.
0000000000000000000000000000000000000000;;	type Scheduler interface {
0000000000000000000000000000000000000000;;		// Schedule asks the scheduler to schedule a job defined by the given func.
0000000000000000000000000000000000000000;;		// Schedule to a stopped scheduler might panic.
0000000000000000000000000000000000000000;;		Schedule(j Job)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pending returns number of pending jobs
0000000000000000000000000000000000000000;;		Pending() int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scheduled returns the number of scheduled jobs (excluding pending jobs)
0000000000000000000000000000000000000000;;		Scheduled() int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finished returns the number of finished jobs
0000000000000000000000000000000000000000;;		Finished() int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WaitFinish waits until at least n job are finished and all pending jobs are finished.
0000000000000000000000000000000000000000;;		WaitFinish(n int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop stops the scheduler.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fifo struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resume    chan struct{}
0000000000000000000000000000000000000000;;		scheduled int
0000000000000000000000000000000000000000;;		finished  int
0000000000000000000000000000000000000000;;		pendings  []Job
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		finishCond *sync.Cond
0000000000000000000000000000000000000000;;		donec      chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFIFOScheduler returns a Scheduler that schedules jobs in FIFO
0000000000000000000000000000000000000000;;	// order sequentially
0000000000000000000000000000000000000000;;	func NewFIFOScheduler() Scheduler {
0000000000000000000000000000000000000000;;		f := &fifo{
0000000000000000000000000000000000000000;;			resume: make(chan struct{}, 1),
0000000000000000000000000000000000000000;;			donec:  make(chan struct{}, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.finishCond = sync.NewCond(&f.mu)
0000000000000000000000000000000000000000;;		f.ctx, f.cancel = context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		go f.run()
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Schedule schedules a job that will be ran in FIFO order sequentially.
0000000000000000000000000000000000000000;;	func (f *fifo) Schedule(j Job) {
0000000000000000000000000000000000000000;;		f.mu.Lock()
0000000000000000000000000000000000000000;;		defer f.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.cancel == nil {
0000000000000000000000000000000000000000;;			panic("schedule: schedule to stopped scheduler")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(f.pendings) == 0 {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case f.resume <- struct{}{}:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.pendings = append(f.pendings, j)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fifo) Pending() int {
0000000000000000000000000000000000000000;;		f.mu.Lock()
0000000000000000000000000000000000000000;;		defer f.mu.Unlock()
0000000000000000000000000000000000000000;;		return len(f.pendings)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fifo) Scheduled() int {
0000000000000000000000000000000000000000;;		f.mu.Lock()
0000000000000000000000000000000000000000;;		defer f.mu.Unlock()
0000000000000000000000000000000000000000;;		return f.scheduled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fifo) Finished() int {
0000000000000000000000000000000000000000;;		f.finishCond.L.Lock()
0000000000000000000000000000000000000000;;		defer f.finishCond.L.Unlock()
0000000000000000000000000000000000000000;;		return f.finished
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fifo) WaitFinish(n int) {
0000000000000000000000000000000000000000;;		f.finishCond.L.Lock()
0000000000000000000000000000000000000000;;		for f.finished < n || len(f.pendings) != 0 {
0000000000000000000000000000000000000000;;			f.finishCond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.finishCond.L.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the scheduler and cancels all pending jobs.
0000000000000000000000000000000000000000;;	func (f *fifo) Stop() {
0000000000000000000000000000000000000000;;		f.mu.Lock()
0000000000000000000000000000000000000000;;		f.cancel()
0000000000000000000000000000000000000000;;		f.cancel = nil
0000000000000000000000000000000000000000;;		f.mu.Unlock()
0000000000000000000000000000000000000000;;		<-f.donec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fifo) run() {
0000000000000000000000000000000000000000;;		// TODO: recover from job panic?
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			close(f.donec)
0000000000000000000000000000000000000000;;			close(f.resume)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var todo Job
0000000000000000000000000000000000000000;;			f.mu.Lock()
0000000000000000000000000000000000000000;;			if len(f.pendings) != 0 {
0000000000000000000000000000000000000000;;				f.scheduled++
0000000000000000000000000000000000000000;;				todo = f.pendings[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.mu.Unlock()
0000000000000000000000000000000000000000;;			if todo == nil {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-f.resume:
0000000000000000000000000000000000000000;;				case <-f.ctx.Done():
0000000000000000000000000000000000000000;;					f.mu.Lock()
0000000000000000000000000000000000000000;;					pendings := f.pendings
0000000000000000000000000000000000000000;;					f.pendings = nil
0000000000000000000000000000000000000000;;					f.mu.Unlock()
0000000000000000000000000000000000000000;;					// clean up pending jobs
0000000000000000000000000000000000000000;;					for _, todo := range pendings {
0000000000000000000000000000000000000000;;						todo(f.ctx)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				todo(f.ctx)
0000000000000000000000000000000000000000;;				f.finishCond.L.Lock()
0000000000000000000000000000000000000000;;				f.finished++
0000000000000000000000000000000000000000;;				f.pendings = f.pendings[1:]
0000000000000000000000000000000000000000;;				f.finishCond.Broadcast()
0000000000000000000000000000000000000000;;				f.finishCond.L.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
