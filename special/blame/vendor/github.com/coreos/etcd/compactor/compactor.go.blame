0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/compactor/compactor.go[Godeps/_workspace/src/github.com/coreos/etcd/compactor/compactor.go][vendor/github.com/coreos/etcd/compactor/compactor.go];	
0000000000000000000000000000000000000000;;	package compactor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "compactor")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		checkCompactionInterval = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Compactable interface {
0000000000000000000000000000000000000000;;		Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RevGetter interface {
0000000000000000000000000000000000000000;;		Rev() int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Periodic struct {
0000000000000000000000000000000000000000;;		clock        clockwork.Clock
0000000000000000000000000000000000000000;;		periodInHour int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rg RevGetter
0000000000000000000000000000000000000000;;		c  Compactable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		revs   []int64
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu     sync.Mutex
0000000000000000000000000000000000000000;;		paused bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPeriodic(h int, rg RevGetter, c Compactable) *Periodic {
0000000000000000000000000000000000000000;;		return &Periodic{
0000000000000000000000000000000000000000;;			clock:        clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;			periodInHour: h,
0000000000000000000000000000000000000000;;			rg:           rg,
0000000000000000000000000000000000000000;;			c:            c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Periodic) Run() {
0000000000000000000000000000000000000000;;		t.ctx, t.cancel = context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		t.revs = make([]int64, 0)
0000000000000000000000000000000000000000;;		clock := t.clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			last := clock.Now()
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				t.revs = append(t.revs, t.rg.Rev())
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-t.ctx.Done():
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case <-clock.After(checkCompactionInterval):
0000000000000000000000000000000000000000;;					t.mu.Lock()
0000000000000000000000000000000000000000;;					p := t.paused
0000000000000000000000000000000000000000;;					t.mu.Unlock()
0000000000000000000000000000000000000000;;					if p {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if clock.Now().Sub(last) < time.Duration(t.periodInHour)*time.Hour {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rev := t.getRev(t.periodInHour)
0000000000000000000000000000000000000000;;				if rev < 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				plog.Noticef("Starting auto-compaction at revision %d", rev)
0000000000000000000000000000000000000000;;				_, err := t.c.Compact(t.ctx, &pb.CompactionRequest{Revision: rev})
0000000000000000000000000000000000000000;;				if err == nil || err == mvcc.ErrCompacted {
0000000000000000000000000000000000000000;;					t.revs = make([]int64, 0)
0000000000000000000000000000000000000000;;					last = clock.Now()
0000000000000000000000000000000000000000;;					plog.Noticef("Finished auto-compaction at revision %d", rev)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					plog.Noticef("Failed auto-compaction at revision %d (%v)", err, rev)
0000000000000000000000000000000000000000;;					plog.Noticef("Retry after %v", checkCompactionInterval)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Periodic) Stop() {
0000000000000000000000000000000000000000;;		t.cancel()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Periodic) Pause() {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		t.paused = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Periodic) Resume() {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		t.paused = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Periodic) getRev(h int) int64 {
0000000000000000000000000000000000000000;;		i := len(t.revs) - int(time.Duration(h)*time.Hour/checkCompactionInterval)
0000000000000000000000000000000000000000;;		if i < 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.revs[i]
0000000000000000000000000000000000000000;;	}
