0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/wal/encoder.go[Godeps/_workspace/src/github.com/coreos/etcd/wal/encoder.go][vendor/github.com/coreos/etcd/wal/encoder.go];	
0000000000000000000000000000000000000000;;	package wal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/crc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/ioutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// walPageBytes is the alignment for flushing records to the backing Writer.
0000000000000000000000000000000000000000;;	// It should be a multiple of the minimum sector size so that WAL can safely
0000000000000000000000000000000000000000;;	// distinguish between torn writes and ordinary data corruption.
0000000000000000000000000000000000000000;;	const walPageBytes = 8 * minSectorSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encoder struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		bw *ioutil.PageWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crc       hash.Hash32
0000000000000000000000000000000000000000;;		buf       []byte
0000000000000000000000000000000000000000;;		uint64buf []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEncoder(w io.Writer, prevCrc uint32, pageOffset int) *encoder {
0000000000000000000000000000000000000000;;		return &encoder{
0000000000000000000000000000000000000000;;			bw:  ioutil.NewPageWriter(w, walPageBytes, pageOffset),
0000000000000000000000000000000000000000;;			crc: crc.New(prevCrc, crcTable),
0000000000000000000000000000000000000000;;			// 1MB buffer
0000000000000000000000000000000000000000;;			buf:       make([]byte, 1024*1024),
0000000000000000000000000000000000000000;;			uint64buf: make([]byte, 8),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newFileEncoder creates a new encoder with current file offset for the page writer.
0000000000000000000000000000000000000000;;	func newFileEncoder(f *os.File, prevCrc uint32) (*encoder, error) {
0000000000000000000000000000000000000000;;		offset, err := f.Seek(0, os.SEEK_CUR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newEncoder(f, prevCrc, int(offset)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) encode(rec *walpb.Record) error {
0000000000000000000000000000000000000000;;		e.mu.Lock()
0000000000000000000000000000000000000000;;		defer e.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.crc.Write(rec.Data)
0000000000000000000000000000000000000000;;		rec.Crc = e.crc.Sum32()
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			data []byte
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;			n    int
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rec.Size() > len(e.buf) {
0000000000000000000000000000000000000000;;			data, err = rec.Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n, err = rec.MarshalTo(e.buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data = e.buf[:n]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lenField, padBytes := encodeFrameSize(len(data))
0000000000000000000000000000000000000000;;		if err = writeUint64(e.bw, lenField, e.uint64buf); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if padBytes != 0 {
0000000000000000000000000000000000000000;;			data = append(data, make([]byte, padBytes)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = e.bw.Write(data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeFrameSize(dataBytes int) (lenField uint64, padBytes int) {
0000000000000000000000000000000000000000;;		lenField = uint64(dataBytes)
0000000000000000000000000000000000000000;;		// force 8 byte alignment so length never gets a torn write
0000000000000000000000000000000000000000;;		padBytes = (8 - (dataBytes % 8)) % 8
0000000000000000000000000000000000000000;;		if padBytes != 0 {
0000000000000000000000000000000000000000;;			lenField |= uint64(0x80|padBytes) << 56
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) flush() error {
0000000000000000000000000000000000000000;;		e.mu.Lock()
0000000000000000000000000000000000000000;;		defer e.mu.Unlock()
0000000000000000000000000000000000000000;;		return e.bw.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeUint64(w io.Writer, n uint64, buf []byte) error {
0000000000000000000000000000000000000000;;		// http://golang.org/src/encoding/binary/binary.go
0000000000000000000000000000000000000000;;		binary.LittleEndian.PutUint64(buf, n)
0000000000000000000000000000000000000000;;		_, err := w.Write(buf)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
