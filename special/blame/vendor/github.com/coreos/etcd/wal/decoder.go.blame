0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/wal/decoder.go[Godeps/_workspace/src/github.com/coreos/etcd/wal/decoder.go][vendor/github.com/coreos/etcd/wal/decoder.go];	
0000000000000000000000000000000000000000;;	package wal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/crc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const minSectorSize = 512
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decoder struct {
0000000000000000000000000000000000000000;;		mu  sync.Mutex
0000000000000000000000000000000000000000;;		brs []*bufio.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lastValidOff file offset following the last valid decoded record
0000000000000000000000000000000000000000;;		lastValidOff int64
0000000000000000000000000000000000000000;;		crc          hash.Hash32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDecoder(r ...io.Reader) *decoder {
0000000000000000000000000000000000000000;;		readers := make([]*bufio.Reader, len(r))
0000000000000000000000000000000000000000;;		for i := range r {
0000000000000000000000000000000000000000;;			readers[i] = bufio.NewReader(r[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &decoder{
0000000000000000000000000000000000000000;;			brs: readers,
0000000000000000000000000000000000000000;;			crc: crc.New(0, crcTable),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decode(rec *walpb.Record) error {
0000000000000000000000000000000000000000;;		rec.Reset()
0000000000000000000000000000000000000000;;		d.mu.Lock()
0000000000000000000000000000000000000000;;		defer d.mu.Unlock()
0000000000000000000000000000000000000000;;		return d.decodeRecord(rec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeRecord(rec *walpb.Record) error {
0000000000000000000000000000000000000000;;		if len(d.brs) == 0 {
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, err := readInt64(d.brs[0])
0000000000000000000000000000000000000000;;		if err == io.EOF || (err == nil && l == 0) {
0000000000000000000000000000000000000000;;			// hit end of file or preallocated space
0000000000000000000000000000000000000000;;			d.brs = d.brs[1:]
0000000000000000000000000000000000000000;;			if len(d.brs) == 0 {
0000000000000000000000000000000000000000;;				return io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.lastValidOff = 0
0000000000000000000000000000000000000000;;			return d.decodeRecord(rec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recBytes, padBytes := decodeFrameSize(l)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := make([]byte, recBytes+padBytes)
0000000000000000000000000000000000000000;;		if _, err = io.ReadFull(d.brs[0], data); err != nil {
0000000000000000000000000000000000000000;;			// ReadFull returns io.EOF only if no bytes were read
0000000000000000000000000000000000000000;;			// the decoder should treat this as an ErrUnexpectedEOF instead.
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := rec.Unmarshal(data[:recBytes]); err != nil {
0000000000000000000000000000000000000000;;			if d.isTornEntry(data) {
0000000000000000000000000000000000000000;;				return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip crc checking if the record type is crcType
0000000000000000000000000000000000000000;;		if rec.Type != crcType {
0000000000000000000000000000000000000000;;			d.crc.Write(rec.Data)
0000000000000000000000000000000000000000;;			if err := rec.Validate(d.crc.Sum32()); err != nil {
0000000000000000000000000000000000000000;;				if d.isTornEntry(data) {
0000000000000000000000000000000000000000;;					return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// record decoded as valid; point last valid offset to end of record
0000000000000000000000000000000000000000;;		d.lastValidOff += recBytes + padBytes + 8
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeFrameSize(lenField int64) (recBytes int64, padBytes int64) {
0000000000000000000000000000000000000000;;		// the record size is stored in the lower 56 bits of the 64-bit length
0000000000000000000000000000000000000000;;		recBytes = int64(uint64(lenField) & ^(uint64(0xff) << 56))
0000000000000000000000000000000000000000;;		// non-zero padding is indicated by set MSb / a negative length
0000000000000000000000000000000000000000;;		if lenField < 0 {
0000000000000000000000000000000000000000;;			// padding is stored in lower 3 bits of length MSB
0000000000000000000000000000000000000000;;			padBytes = int64((uint64(lenField) >> 56) & 0x7)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTornEntry determines whether the last entry of the WAL was partially written
0000000000000000000000000000000000000000;;	// and corrupted because of a torn write.
0000000000000000000000000000000000000000;;	func (d *decoder) isTornEntry(data []byte) bool {
0000000000000000000000000000000000000000;;		if len(d.brs) != 1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fileOff := d.lastValidOff + 8
0000000000000000000000000000000000000000;;		curOff := 0
0000000000000000000000000000000000000000;;		chunks := [][]byte{}
0000000000000000000000000000000000000000;;		// split data on sector boundaries
0000000000000000000000000000000000000000;;		for curOff < len(data) {
0000000000000000000000000000000000000000;;			chunkLen := int(minSectorSize - (fileOff % minSectorSize))
0000000000000000000000000000000000000000;;			if chunkLen > len(data)-curOff {
0000000000000000000000000000000000000000;;				chunkLen = len(data) - curOff
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chunks = append(chunks, data[curOff:curOff+chunkLen])
0000000000000000000000000000000000000000;;			fileOff += int64(chunkLen)
0000000000000000000000000000000000000000;;			curOff += chunkLen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if any data for a sector chunk is all 0, it's a torn write
0000000000000000000000000000000000000000;;		for _, sect := range chunks {
0000000000000000000000000000000000000000;;			isZero := true
0000000000000000000000000000000000000000;;			for _, v := range sect {
0000000000000000000000000000000000000000;;				if v != 0 {
0000000000000000000000000000000000000000;;					isZero = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isZero {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) updateCRC(prevCrc uint32) {
0000000000000000000000000000000000000000;;		d.crc = crc.New(prevCrc, crcTable)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) lastCRC() uint32 {
0000000000000000000000000000000000000000;;		return d.crc.Sum32()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) lastOffset() int64 { return d.lastValidOff }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustUnmarshalEntry(d []byte) raftpb.Entry {
0000000000000000000000000000000000000000;;		var e raftpb.Entry
0000000000000000000000000000000000000000;;		pbutil.MustUnmarshal(&e, d)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustUnmarshalState(d []byte) raftpb.HardState {
0000000000000000000000000000000000000000;;		var s raftpb.HardState
0000000000000000000000000000000000000000;;		pbutil.MustUnmarshal(&s, d)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readInt64(r io.Reader) (int64, error) {
0000000000000000000000000000000000000000;;		var n int64
0000000000000000000000000000000000000000;;		err := binary.Read(r, binary.LittleEndian, &n)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
