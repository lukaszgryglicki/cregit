0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/wal/wal.go[Godeps/_workspace/src/github.com/coreos/etcd/wal/wal.go][vendor/github.com/coreos/etcd/wal/wal.go];	
0000000000000000000000000000000000000000;;	package wal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/crc32"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/fileutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		metadataType int64 = iota + 1
0000000000000000000000000000000000000000;;		entryType
0000000000000000000000000000000000000000;;		stateType
0000000000000000000000000000000000000000;;		crcType
0000000000000000000000000000000000000000;;		snapshotType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// warnSyncDuration is the amount of time allotted to an fsync before
0000000000000000000000000000000000000000;;		// logging a warning
0000000000000000000000000000000000000000;;		warnSyncDuration = time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// SegmentSizeBytes is the preallocated size of each wal segment file.
0000000000000000000000000000000000000000;;		// The actual size might be larger than this. In general, the default
0000000000000000000000000000000000000000;;		// value should be used, but this is defined as an exported variable
0000000000000000000000000000000000000000;;		// so that tests can set a different segment size.
0000000000000000000000000000000000000000;;		SegmentSizeBytes int64 = 64 * 1000 * 1000 // 64MB
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "wal")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrMetadataConflict = errors.New("wal: conflicting metadata found")
0000000000000000000000000000000000000000;;		ErrFileNotFound     = errors.New("wal: file not found")
0000000000000000000000000000000000000000;;		ErrCRCMismatch      = errors.New("wal: crc mismatch")
0000000000000000000000000000000000000000;;		ErrSnapshotMismatch = errors.New("wal: snapshot mismatch")
0000000000000000000000000000000000000000;;		ErrSnapshotNotFound = errors.New("wal: snapshot not found")
0000000000000000000000000000000000000000;;		crcTable            = crc32.MakeTable(crc32.Castagnoli)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WAL is a logical representation of the stable storage.
0000000000000000000000000000000000000000;;	// WAL is either in read mode or append mode but not both.
0000000000000000000000000000000000000000;;	// A newly created WAL is in append mode, and ready for appending records.
0000000000000000000000000000000000000000;;	// A just opened WAL is in read mode, and ready for reading records.
0000000000000000000000000000000000000000;;	// The WAL will be ready for appending after reading out all the previous records.
0000000000000000000000000000000000000000;;	type WAL struct {
0000000000000000000000000000000000000000;;		dir string // the living directory of the underlay files
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// dirFile is a fd for the wal directory for syncing on Rename
0000000000000000000000000000000000000000;;		dirFile *os.File
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metadata []byte           // metadata recorded at the head of each WAL
0000000000000000000000000000000000000000;;		state    raftpb.HardState // hardstate recorded at the head of WAL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start     walpb.Snapshot // snapshot to start reading
0000000000000000000000000000000000000000;;		decoder   *decoder       // decoder to decode records
0000000000000000000000000000000000000000;;		readClose func() error   // closer for decode reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		enti    uint64   // index of the last entry saved to the wal
0000000000000000000000000000000000000000;;		encoder *encoder // encoder to encode records
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		locks []*fileutil.LockedFile // the locked files the WAL holds (the name is increasing)
0000000000000000000000000000000000000000;;		fp    *filePipeline
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates a WAL ready for appending records. The given metadata is
0000000000000000000000000000000000000000;;	// recorded at the head of each WAL file, and can be retrieved with ReadAll.
0000000000000000000000000000000000000000;;	func Create(dirpath string, metadata []byte) (*WAL, error) {
0000000000000000000000000000000000000000;;		if Exist(dirpath) {
0000000000000000000000000000000000000000;;			return nil, os.ErrExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keep temporary wal directory so WAL initialization appears atomic
0000000000000000000000000000000000000000;;		tmpdirpath := filepath.Clean(dirpath) + ".tmp"
0000000000000000000000000000000000000000;;		if fileutil.Exist(tmpdirpath) {
0000000000000000000000000000000000000000;;			if err := os.RemoveAll(tmpdirpath); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := fileutil.CreateDirAll(tmpdirpath); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := filepath.Join(tmpdirpath, walName(0, 0))
0000000000000000000000000000000000000000;;		f, err := fileutil.LockFile(p, os.O_WRONLY|os.O_CREATE, fileutil.PrivateFileMode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = f.Seek(0, os.SEEK_END); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = fileutil.Preallocate(f.File, SegmentSizeBytes, true); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := &WAL{
0000000000000000000000000000000000000000;;			dir:      dirpath,
0000000000000000000000000000000000000000;;			metadata: metadata,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.encoder, err = newFileEncoder(f.File, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.locks = append(w.locks, f)
0000000000000000000000000000000000000000;;		if err = w.saveCrc(0); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = w.encoder.encode(&walpb.Record{Type: metadataType, Data: metadata}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = w.SaveSnapshot(walpb.Snapshot{}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w, err = w.renameWal(tmpdirpath); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// directory was renamed; sync parent dir to persist rename
0000000000000000000000000000000000000000;;		pdir, perr := fileutil.OpenDir(filepath.Dir(w.dir))
0000000000000000000000000000000000000000;;		if perr != nil {
0000000000000000000000000000000000000000;;			return nil, perr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if perr = fileutil.Fsync(pdir); perr != nil {
0000000000000000000000000000000000000000;;			return nil, perr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if perr = pdir.Close(); err != nil {
0000000000000000000000000000000000000000;;			return nil, perr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open opens the WAL at the given snap.
0000000000000000000000000000000000000000;;	// The snap SHOULD have been previously saved to the WAL, or the following
0000000000000000000000000000000000000000;;	// ReadAll will fail.
0000000000000000000000000000000000000000;;	// The returned WAL is ready to read and the first record will be the one after
0000000000000000000000000000000000000000;;	// the given snap. The WAL cannot be appended to before reading out all of its
0000000000000000000000000000000000000000;;	// previous records.
0000000000000000000000000000000000000000;;	func Open(dirpath string, snap walpb.Snapshot) (*WAL, error) {
0000000000000000000000000000000000000000;;		w, err := openAtIndex(dirpath, snap, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.dirFile, err = fileutil.OpenDir(w.dir); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenForRead only opens the wal files for read.
0000000000000000000000000000000000000000;;	// Write on a read only wal panics.
0000000000000000000000000000000000000000;;	func OpenForRead(dirpath string, snap walpb.Snapshot) (*WAL, error) {
0000000000000000000000000000000000000000;;		return openAtIndex(dirpath, snap, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func openAtIndex(dirpath string, snap walpb.Snapshot, write bool) (*WAL, error) {
0000000000000000000000000000000000000000;;		names, err := readWalNames(dirpath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nameIndex, ok := searchIndex(names, snap.Index)
0000000000000000000000000000000000000000;;		if !ok || !isValidSeq(names[nameIndex:]) {
0000000000000000000000000000000000000000;;			return nil, ErrFileNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// open the wal files
0000000000000000000000000000000000000000;;		rcs := make([]io.ReadCloser, 0)
0000000000000000000000000000000000000000;;		rs := make([]io.Reader, 0)
0000000000000000000000000000000000000000;;		ls := make([]*fileutil.LockedFile, 0)
0000000000000000000000000000000000000000;;		for _, name := range names[nameIndex:] {
0000000000000000000000000000000000000000;;			p := filepath.Join(dirpath, name)
0000000000000000000000000000000000000000;;			if write {
0000000000000000000000000000000000000000;;				l, err := fileutil.TryLockFile(p, os.O_RDWR, fileutil.PrivateFileMode)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					closeAll(rcs...)
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ls = append(ls, l)
0000000000000000000000000000000000000000;;				rcs = append(rcs, l)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rf, err := os.OpenFile(p, os.O_RDONLY, fileutil.PrivateFileMode)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					closeAll(rcs...)
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ls = append(ls, nil)
0000000000000000000000000000000000000000;;				rcs = append(rcs, rf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rs = append(rs, rcs[len(rcs)-1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closer := func() error { return closeAll(rcs...) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a WAL ready for reading
0000000000000000000000000000000000000000;;		w := &WAL{
0000000000000000000000000000000000000000;;			dir:       dirpath,
0000000000000000000000000000000000000000;;			start:     snap,
0000000000000000000000000000000000000000;;			decoder:   newDecoder(rs...),
0000000000000000000000000000000000000000;;			readClose: closer,
0000000000000000000000000000000000000000;;			locks:     ls,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if write {
0000000000000000000000000000000000000000;;			// write reuses the file descriptors from read; don't close so
0000000000000000000000000000000000000000;;			// WAL can append without dropping the file lock
0000000000000000000000000000000000000000;;			w.readClose = nil
0000000000000000000000000000000000000000;;			if _, _, err := parseWalName(filepath.Base(w.tail().Name())); err != nil {
0000000000000000000000000000000000000000;;				closer()
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.fp = newFilePipeline(w.dir, SegmentSizeBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadAll reads out records of the current WAL.
0000000000000000000000000000000000000000;;	// If opened in write mode, it must read out all records until EOF. Or an error
0000000000000000000000000000000000000000;;	// will be returned.
0000000000000000000000000000000000000000;;	// If opened in read mode, it will try to read all records if possible.
0000000000000000000000000000000000000000;;	// If it cannot read out the expected snap, it will return ErrSnapshotNotFound.
0000000000000000000000000000000000000000;;	// If loaded snap doesn't match with the expected one, it will return
0000000000000000000000000000000000000000;;	// all the records and error ErrSnapshotMismatch.
0000000000000000000000000000000000000000;;	// TODO: detect not-last-snap error.
0000000000000000000000000000000000000000;;	// TODO: maybe loose the checking of match.
0000000000000000000000000000000000000000;;	// After ReadAll, the WAL will be ready for appending new records.
0000000000000000000000000000000000000000;;	func (w *WAL) ReadAll() (metadata []byte, state raftpb.HardState, ents []raftpb.Entry, err error) {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		defer w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rec := &walpb.Record{}
0000000000000000000000000000000000000000;;		decoder := w.decoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var match bool
0000000000000000000000000000000000000000;;		for err = decoder.decode(rec); err == nil; err = decoder.decode(rec) {
0000000000000000000000000000000000000000;;			switch rec.Type {
0000000000000000000000000000000000000000;;			case entryType:
0000000000000000000000000000000000000000;;				e := mustUnmarshalEntry(rec.Data)
0000000000000000000000000000000000000000;;				if e.Index > w.start.Index {
0000000000000000000000000000000000000000;;					ents = append(ents[:e.Index-w.start.Index-1], e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.enti = e.Index
0000000000000000000000000000000000000000;;			case stateType:
0000000000000000000000000000000000000000;;				state = mustUnmarshalState(rec.Data)
0000000000000000000000000000000000000000;;			case metadataType:
0000000000000000000000000000000000000000;;				if metadata != nil && !bytes.Equal(metadata, rec.Data) {
0000000000000000000000000000000000000000;;					state.Reset()
0000000000000000000000000000000000000000;;					return nil, state, nil, ErrMetadataConflict
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				metadata = rec.Data
0000000000000000000000000000000000000000;;			case crcType:
0000000000000000000000000000000000000000;;				crc := decoder.crc.Sum32()
0000000000000000000000000000000000000000;;				// current crc of decoder must match the crc of the record.
0000000000000000000000000000000000000000;;				// do no need to match 0 crc, since the decoder is a new one at this case.
0000000000000000000000000000000000000000;;				if crc != 0 && rec.Validate(crc) != nil {
0000000000000000000000000000000000000000;;					state.Reset()
0000000000000000000000000000000000000000;;					return nil, state, nil, ErrCRCMismatch
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				decoder.updateCRC(rec.Crc)
0000000000000000000000000000000000000000;;			case snapshotType:
0000000000000000000000000000000000000000;;				var snap walpb.Snapshot
0000000000000000000000000000000000000000;;				pbutil.MustUnmarshal(&snap, rec.Data)
0000000000000000000000000000000000000000;;				if snap.Index == w.start.Index {
0000000000000000000000000000000000000000;;					if snap.Term != w.start.Term {
0000000000000000000000000000000000000000;;						state.Reset()
0000000000000000000000000000000000000000;;						return nil, state, nil, ErrSnapshotMismatch
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					match = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				state.Reset()
0000000000000000000000000000000000000000;;				return nil, state, nil, fmt.Errorf("unexpected block type %d", rec.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch w.tail() {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			// We do not have to read out all entries in read mode.
0000000000000000000000000000000000000000;;			// The last record maybe a partial written one, so
0000000000000000000000000000000000000000;;			// ErrunexpectedEOF might be returned.
0000000000000000000000000000000000000000;;			if err != io.EOF && err != io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;				state.Reset()
0000000000000000000000000000000000000000;;				return nil, state, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// We must read all of the entries if WAL is opened in write mode.
0000000000000000000000000000000000000000;;			if err != io.EOF {
0000000000000000000000000000000000000000;;				state.Reset()
0000000000000000000000000000000000000000;;				return nil, state, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// decodeRecord() will return io.EOF if it detects a zero record,
0000000000000000000000000000000000000000;;			// but this zero record may be followed by non-zero records from
0000000000000000000000000000000000000000;;			// a torn write. Overwriting some of these non-zero records, but
0000000000000000000000000000000000000000;;			// not all, will cause CRC errors on WAL open. Since the records
0000000000000000000000000000000000000000;;			// were never fully synced to disk in the first place, it's safe
0000000000000000000000000000000000000000;;			// to zero them out to avoid any CRC errors from new writes.
0000000000000000000000000000000000000000;;			if _, err = w.tail().Seek(w.decoder.lastOffset(), os.SEEK_SET); err != nil {
0000000000000000000000000000000000000000;;				return nil, state, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = fileutil.ZeroToEnd(w.tail().File); err != nil {
0000000000000000000000000000000000000000;;				return nil, state, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;		if !match {
0000000000000000000000000000000000000000;;			err = ErrSnapshotNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// close decoder, disable reading
0000000000000000000000000000000000000000;;		if w.readClose != nil {
0000000000000000000000000000000000000000;;			w.readClose()
0000000000000000000000000000000000000000;;			w.readClose = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.start = walpb.Snapshot{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.metadata = metadata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.tail() != nil {
0000000000000000000000000000000000000000;;			// create encoder (chain crc with the decoder), enable appending
0000000000000000000000000000000000000000;;			w.encoder, err = newFileEncoder(w.tail().File, w.decoder.lastCRC())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.decoder = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return metadata, state, ents, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cut closes current file written and creates a new one ready to append.
0000000000000000000000000000000000000000;;	// cut first creates a temp wal file and writes necessary headers into it.
0000000000000000000000000000000000000000;;	// Then cut atomically rename temp wal file to a wal file.
0000000000000000000000000000000000000000;;	func (w *WAL) cut() error {
0000000000000000000000000000000000000000;;		// close old wal file; truncate to avoid wasting space if an early cut
0000000000000000000000000000000000000000;;		off, serr := w.tail().Seek(0, os.SEEK_CUR)
0000000000000000000000000000000000000000;;		if serr != nil {
0000000000000000000000000000000000000000;;			return serr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.tail().Truncate(off); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.sync(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fpath := filepath.Join(w.dir, walName(w.seq()+1, w.enti+1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create a temp wal file with name sequence + 1, or truncate the existing one
0000000000000000000000000000000000000000;;		newTail, err := w.fp.Open()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update writer and save the previous crc
0000000000000000000000000000000000000000;;		w.locks = append(w.locks, newTail)
0000000000000000000000000000000000000000;;		prevCrc := w.encoder.crc.Sum32()
0000000000000000000000000000000000000000;;		w.encoder, err = newFileEncoder(w.tail().File, prevCrc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = w.saveCrc(prevCrc); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = w.encoder.encode(&walpb.Record{Type: metadataType, Data: w.metadata}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = w.saveState(&w.state); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// atomically move temp wal file to wal file
0000000000000000000000000000000000000000;;		if err = w.sync(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		off, err = w.tail().Seek(0, os.SEEK_CUR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = os.Rename(newTail.Name(), fpath); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = fileutil.Fsync(w.dirFile); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newTail.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if newTail, err = fileutil.LockFile(fpath, os.O_WRONLY, fileutil.PrivateFileMode); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = newTail.Seek(off, os.SEEK_SET); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.locks[len(w.locks)-1] = newTail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prevCrc = w.encoder.crc.Sum32()
0000000000000000000000000000000000000000;;		w.encoder, err = newFileEncoder(w.tail().File, prevCrc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("segmented wal file %v is created", fpath)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) sync() error {
0000000000000000000000000000000000000000;;		if w.encoder != nil {
0000000000000000000000000000000000000000;;			if err := w.encoder.flush(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		err := fileutil.Fdatasync(w.tail().File)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		duration := time.Since(start)
0000000000000000000000000000000000000000;;		if duration > warnSyncDuration {
0000000000000000000000000000000000000000;;			plog.Warningf("sync duration of %v, expected less than %v", duration, warnSyncDuration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syncDurations.Observe(duration.Seconds())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReleaseLockTo releases the locks, which has smaller index than the given index
0000000000000000000000000000000000000000;;	// except the largest one among them.
0000000000000000000000000000000000000000;;	// For example, if WAL is holding lock 1,2,3,4,5,6, ReleaseLockTo(4) will release
0000000000000000000000000000000000000000;;	// lock 1,2 but keep 3. ReleaseLockTo(5) will release 1,2,3 but keep 4.
0000000000000000000000000000000000000000;;	func (w *WAL) ReleaseLockTo(index uint64) error {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		defer w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var smaller int
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, l := range w.locks {
0000000000000000000000000000000000000000;;			_, lockIndex, err := parseWalName(filepath.Base(l.Name()))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lockIndex >= index {
0000000000000000000000000000000000000000;;				smaller = i - 1
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if no lock index is greater than the release index, we can
0000000000000000000000000000000000000000;;		// release lock up to the last one(excluding).
0000000000000000000000000000000000000000;;		if !found && len(w.locks) != 0 {
0000000000000000000000000000000000000000;;			smaller = len(w.locks) - 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if smaller <= 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < smaller; i++ {
0000000000000000000000000000000000000000;;			if w.locks[i] == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.locks[i].Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.locks = w.locks[smaller:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) Close() error {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		defer w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.fp != nil {
0000000000000000000000000000000000000000;;			w.fp.Close()
0000000000000000000000000000000000000000;;			w.fp = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.tail() != nil {
0000000000000000000000000000000000000000;;			if err := w.sync(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, l := range w.locks {
0000000000000000000000000000000000000000;;			if l == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := l.Close(); err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("failed to unlock during closing wal: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w.dirFile.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) saveEntry(e *raftpb.Entry) error {
0000000000000000000000000000000000000000;;		// TODO: add MustMarshalTo to reduce one allocation.
0000000000000000000000000000000000000000;;		b := pbutil.MustMarshal(e)
0000000000000000000000000000000000000000;;		rec := &walpb.Record{Type: entryType, Data: b}
0000000000000000000000000000000000000000;;		if err := w.encoder.encode(rec); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.enti = e.Index
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) saveState(s *raftpb.HardState) error {
0000000000000000000000000000000000000000;;		if raft.IsEmptyHardState(*s) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.state = *s
0000000000000000000000000000000000000000;;		b := pbutil.MustMarshal(s)
0000000000000000000000000000000000000000;;		rec := &walpb.Record{Type: stateType, Data: b}
0000000000000000000000000000000000000000;;		return w.encoder.encode(rec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) Save(st raftpb.HardState, ents []raftpb.Entry) error {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		defer w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// short cut, do not call sync
0000000000000000000000000000000000000000;;		if raft.IsEmptyHardState(st) && len(ents) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mustSync := mustSync(st, w.state, len(ents))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(xiangli): no more reference operator
0000000000000000000000000000000000000000;;		for i := range ents {
0000000000000000000000000000000000000000;;			if err := w.saveEntry(&ents[i]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.saveState(&st); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curOff, err := w.tail().Seek(0, os.SEEK_CUR)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if curOff < SegmentSizeBytes {
0000000000000000000000000000000000000000;;			if mustSync {
0000000000000000000000000000000000000000;;				return w.sync()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w.cut()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) SaveSnapshot(e walpb.Snapshot) error {
0000000000000000000000000000000000000000;;		b := pbutil.MustMarshal(&e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		defer w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rec := &walpb.Record{Type: snapshotType, Data: b}
0000000000000000000000000000000000000000;;		if err := w.encoder.encode(rec); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update enti only when snapshot is ahead of last index
0000000000000000000000000000000000000000;;		if w.enti < e.Index {
0000000000000000000000000000000000000000;;			w.enti = e.Index
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.sync()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) saveCrc(prevCrc uint32) error {
0000000000000000000000000000000000000000;;		return w.encoder.encode(&walpb.Record{Type: crcType, Crc: prevCrc})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) tail() *fileutil.LockedFile {
0000000000000000000000000000000000000000;;		if len(w.locks) > 0 {
0000000000000000000000000000000000000000;;			return w.locks[len(w.locks)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *WAL) seq() uint64 {
0000000000000000000000000000000000000000;;		t := w.tail()
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seq, _, err := parseWalName(filepath.Base(t.Name()))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("bad wal name %s (%v)", t.Name(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return seq
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustSync(st, prevst raftpb.HardState, entsnum int) bool {
0000000000000000000000000000000000000000;;		// Persistent state on all servers:
0000000000000000000000000000000000000000;;		// (Updated on stable storage before responding to RPCs)
0000000000000000000000000000000000000000;;		// currentTerm
0000000000000000000000000000000000000000;;		// votedFor
0000000000000000000000000000000000000000;;		// log entries[]
0000000000000000000000000000000000000000;;		return entsnum != 0 || st.Vote != prevst.Vote || st.Term != prevst.Term
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func closeAll(rcs ...io.ReadCloser) error {
0000000000000000000000000000000000000000;;		for _, f := range rcs {
0000000000000000000000000000000000000000;;			if err := f.Close(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
