0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1861d099d10ddfa47b9f2b8b925fc11bd0827dac;Godeps/_workspace/src/github.com/coreos/etcd/wal/file_pipeline.go[Godeps/_workspace/src/github.com/coreos/etcd/wal/file_pipeline.go][vendor/github.com/coreos/etcd/wal/file_pipeline.go];	
0000000000000000000000000000000000000000;;	package wal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/fileutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filePipeline pipelines allocating disk space
0000000000000000000000000000000000000000;;	type filePipeline struct {
0000000000000000000000000000000000000000;;		// dir to put files
0000000000000000000000000000000000000000;;		dir string
0000000000000000000000000000000000000000;;		// size of files to make, in bytes
0000000000000000000000000000000000000000;;		size int64
0000000000000000000000000000000000000000;;		// count number of files generated
0000000000000000000000000000000000000000;;		count int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filec chan *fileutil.LockedFile
0000000000000000000000000000000000000000;;		errc  chan error
0000000000000000000000000000000000000000;;		donec chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFilePipeline(dir string, fileSize int64) *filePipeline {
0000000000000000000000000000000000000000;;		fp := &filePipeline{
0000000000000000000000000000000000000000;;			dir:   dir,
0000000000000000000000000000000000000000;;			size:  fileSize,
0000000000000000000000000000000000000000;;			filec: make(chan *fileutil.LockedFile),
0000000000000000000000000000000000000000;;			errc:  make(chan error, 1),
0000000000000000000000000000000000000000;;			donec: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go fp.run()
0000000000000000000000000000000000000000;;		return fp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open returns a fresh file for writing. Rename the file before calling
0000000000000000000000000000000000000000;;	// Open again or there will be file collisions.
0000000000000000000000000000000000000000;;	func (fp *filePipeline) Open() (f *fileutil.LockedFile, err error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case f = <-fp.filec:
0000000000000000000000000000000000000000;;		case err = <-fp.errc:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fp *filePipeline) Close() error {
0000000000000000000000000000000000000000;;		close(fp.donec)
0000000000000000000000000000000000000000;;		return <-fp.errc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fp *filePipeline) alloc() (f *fileutil.LockedFile, err error) {
0000000000000000000000000000000000000000;;		// count % 2 so this file isn't the same as the one last published
0000000000000000000000000000000000000000;;		fpath := filepath.Join(fp.dir, fmt.Sprintf("%d.tmp", fp.count%2))
0000000000000000000000000000000000000000;;		if f, err = fileutil.LockFile(fpath, os.O_CREATE|os.O_WRONLY, fileutil.PrivateFileMode); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = fileutil.Preallocate(f.File, fp.size, true); err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("failed to allocate space when creating new wal file (%v)", err)
0000000000000000000000000000000000000000;;			f.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fp.count++
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fp *filePipeline) run() {
0000000000000000000000000000000000000000;;		defer close(fp.errc)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			f, err := fp.alloc()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fp.errc <- err
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case fp.filec <- f:
0000000000000000000000000000000000000000;;			case <-fp.donec:
0000000000000000000000000000000000000000;;				os.Remove(f.Name())
0000000000000000000000000000000000000000;;				f.Close()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
