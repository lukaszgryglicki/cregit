0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/snap/snapshotter.go[Godeps/_workspace/src/github.com/coreos/etcd/snap/snapshotter.go][vendor/github.com/coreos/etcd/snap/snapshotter.go];	
0000000000000000000000000000000000000000;;	// Package snap stores raft nodes' states with snapshots.
0000000000000000000000000000000000000000;;	package snap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/crc32"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pioutil "github.com/coreos/etcd/pkg/ioutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap/snappb"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		snapSuffix = ".snap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "snap")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrNoSnapshot    = errors.New("snap: no available snapshot")
0000000000000000000000000000000000000000;;		ErrEmptySnapshot = errors.New("snap: empty snapshot")
0000000000000000000000000000000000000000;;		ErrCRCMismatch   = errors.New("snap: crc mismatch")
0000000000000000000000000000000000000000;;		crcTable         = crc32.MakeTable(crc32.Castagnoli)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A map of valid files that can be present in the snap folder.
0000000000000000000000000000000000000000;;		validFiles = map[string]bool{
0000000000000000000000000000000000000000;;			"db": true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Snapshotter struct {
0000000000000000000000000000000000000000;;		dir string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(dir string) *Snapshotter {
0000000000000000000000000000000000000000;;		return &Snapshotter{
0000000000000000000000000000000000000000;;			dir: dir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Snapshotter) SaveSnap(snapshot raftpb.Snapshot) error {
0000000000000000000000000000000000000000;;		if raft.IsEmptySnap(snapshot) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.save(&snapshot)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Snapshotter) save(snapshot *raftpb.Snapshot) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fname := fmt.Sprintf("%016x-%016x%s", snapshot.Metadata.Term, snapshot.Metadata.Index, snapSuffix)
0000000000000000000000000000000000000000;;		b := pbutil.MustMarshal(snapshot)
0000000000000000000000000000000000000000;;		crc := crc32.Update(0, crcTable, b)
0000000000000000000000000000000000000000;;		snap := snappb.Snapshot{Crc: crc, Data: b}
0000000000000000000000000000000000000000;;		d, err := snap.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			marshallingDurations.Observe(float64(time.Since(start)) / float64(time.Second))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = pioutil.WriteAndSyncFile(filepath.Join(s.dir, fname), d, 0666)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			saveDurations.Observe(float64(time.Since(start)) / float64(time.Second))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err1 := os.Remove(filepath.Join(s.dir, fname))
0000000000000000000000000000000000000000;;			if err1 != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("failed to remove broken snapshot file %s", filepath.Join(s.dir, fname))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Snapshotter) Load() (*raftpb.Snapshot, error) {
0000000000000000000000000000000000000000;;		names, err := s.snapNames()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var snap *raftpb.Snapshot
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			if snap, err = loadSnap(s.dir, name); err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, ErrNoSnapshot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return snap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadSnap(dir, name string) (*raftpb.Snapshot, error) {
0000000000000000000000000000000000000000;;		fpath := filepath.Join(dir, name)
0000000000000000000000000000000000000000;;		snap, err := Read(fpath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			renameBroken(fpath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return snap, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads the snapshot named by snapname and returns the snapshot.
0000000000000000000000000000000000000000;;	func Read(snapname string) (*raftpb.Snapshot, error) {
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadFile(snapname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("cannot read file %v: %v", snapname, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b) == 0 {
0000000000000000000000000000000000000000;;			plog.Errorf("unexpected empty snapshot")
0000000000000000000000000000000000000000;;			return nil, ErrEmptySnapshot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var serializedSnap snappb.Snapshot
0000000000000000000000000000000000000000;;		if err = serializedSnap.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("corrupted snapshot file %v: %v", snapname, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(serializedSnap.Data) == 0 || serializedSnap.Crc == 0 {
0000000000000000000000000000000000000000;;			plog.Errorf("unexpected empty snapshot")
0000000000000000000000000000000000000000;;			return nil, ErrEmptySnapshot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		crc := crc32.Update(0, crcTable, serializedSnap.Data)
0000000000000000000000000000000000000000;;		if crc != serializedSnap.Crc {
0000000000000000000000000000000000000000;;			plog.Errorf("corrupted snapshot file %v: crc mismatch", snapname)
0000000000000000000000000000000000000000;;			return nil, ErrCRCMismatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var snap raftpb.Snapshot
0000000000000000000000000000000000000000;;		if err = snap.Unmarshal(serializedSnap.Data); err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("corrupted snapshot file %v: %v", snapname, err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &snap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// snapNames returns the filename of the snapshots in logical time order (from newest to oldest).
0000000000000000000000000000000000000000;;	// If there is no available snapshots, an ErrNoSnapshot will be returned.
0000000000000000000000000000000000000000;;	func (s *Snapshotter) snapNames() ([]string, error) {
0000000000000000000000000000000000000000;;		dir, err := os.Open(s.dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer dir.Close()
0000000000000000000000000000000000000000;;		names, err := dir.Readdirnames(-1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		snaps := checkSuffix(names)
0000000000000000000000000000000000000000;;		if len(snaps) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNoSnapshot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(sort.StringSlice(snaps)))
0000000000000000000000000000000000000000;;		return snaps, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkSuffix(names []string) []string {
0000000000000000000000000000000000000000;;		snaps := []string{}
0000000000000000000000000000000000000000;;		for i := range names {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(names[i], snapSuffix) {
0000000000000000000000000000000000000000;;				snaps = append(snaps, names[i])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// If we find a file which is not a snapshot then check if it's
0000000000000000000000000000000000000000;;				// a vaild file. If not throw out a warning.
0000000000000000000000000000000000000000;;				if _, ok := validFiles[names[i]]; !ok {
0000000000000000000000000000000000000000;;					plog.Warningf("skipped unexpected non snapshot file %v", names[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return snaps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func renameBroken(path string) {
0000000000000000000000000000000000000000;;		brokenPath := path + ".broken"
0000000000000000000000000000000000000000;;		if err := os.Rename(path, brokenPath); err != nil {
0000000000000000000000000000000000000000;;			plog.Warningf("cannot rename broken snapshot file %v to %v: %v", path, brokenPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
