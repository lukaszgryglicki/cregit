0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	package auth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CAUTION: This randum number based token mechanism is only for testing purpose.
0000000000000000000000000000000000000000;;	// JWT based mechanism will be added in the near future.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		letters                  = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
0000000000000000000000000000000000000000;;		defaultSimpleTokenLength = 16
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// var for testing purposes
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		simpleTokenTTL           = 5 * time.Minute
0000000000000000000000000000000000000000;;		simpleTokenTTLResolution = 1 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleTokenTTLKeeper struct {
0000000000000000000000000000000000000000;;		tokensMu        sync.Mutex
0000000000000000000000000000000000000000;;		tokens          map[string]time.Time
0000000000000000000000000000000000000000;;		stopCh          chan chan struct{}
0000000000000000000000000000000000000000;;		deleteTokenFunc func(string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSimpleTokenTTLKeeper(deletefunc func(string)) *simpleTokenTTLKeeper {
0000000000000000000000000000000000000000;;		stk := &simpleTokenTTLKeeper{
0000000000000000000000000000000000000000;;			tokens:          make(map[string]time.Time),
0000000000000000000000000000000000000000;;			stopCh:          make(chan chan struct{}),
0000000000000000000000000000000000000000;;			deleteTokenFunc: deletefunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go stk.run()
0000000000000000000000000000000000000000;;		return stk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tm *simpleTokenTTLKeeper) stop() {
0000000000000000000000000000000000000000;;		waitCh := make(chan struct{})
0000000000000000000000000000000000000000;;		tm.stopCh <- waitCh
0000000000000000000000000000000000000000;;		<-waitCh
0000000000000000000000000000000000000000;;		close(tm.stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tm *simpleTokenTTLKeeper) addSimpleToken(token string) {
0000000000000000000000000000000000000000;;		tm.tokens[token] = time.Now().Add(simpleTokenTTL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tm *simpleTokenTTLKeeper) resetSimpleToken(token string) {
0000000000000000000000000000000000000000;;		if _, ok := tm.tokens[token]; ok {
0000000000000000000000000000000000000000;;			tm.tokens[token] = time.Now().Add(simpleTokenTTL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tm *simpleTokenTTLKeeper) deleteSimpleToken(token string) {
0000000000000000000000000000000000000000;;		delete(tm.tokens, token)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tm *simpleTokenTTLKeeper) run() {
0000000000000000000000000000000000000000;;		tokenTicker := time.NewTicker(simpleTokenTTLResolution)
0000000000000000000000000000000000000000;;		defer tokenTicker.Stop()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-tokenTicker.C:
0000000000000000000000000000000000000000;;				nowtime := time.Now()
0000000000000000000000000000000000000000;;				tm.tokensMu.Lock()
0000000000000000000000000000000000000000;;				for t, tokenendtime := range tm.tokens {
0000000000000000000000000000000000000000;;					if nowtime.After(tokenendtime) {
0000000000000000000000000000000000000000;;						tm.deleteTokenFunc(t)
0000000000000000000000000000000000000000;;						delete(tm.tokens, t)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tm.tokensMu.Unlock()
0000000000000000000000000000000000000000;;			case waitCh := <-tm.stopCh:
0000000000000000000000000000000000000000;;				tm.tokens = make(map[string]time.Time)
0000000000000000000000000000000000000000;;				waitCh <- struct{}{}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) GenSimpleToken() (string, error) {
0000000000000000000000000000000000000000;;		ret := make([]byte, defaultSimpleTokenLength)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < defaultSimpleTokenLength; i++ {
0000000000000000000000000000000000000000;;			bInt, err := rand.Int(rand.Reader, big.NewInt(int64(len(letters))))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret[i] = letters[bInt.Int64()]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(ret), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) assignSimpleTokenToUser(username, token string) {
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper.tokensMu.Lock()
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, ok := as.simpleTokens[token]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			plog.Panicf("token %s is alredy used", token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.simpleTokens[token] = username
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper.addSimpleToken(token)
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Unlock()
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper.tokensMu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) invalidateUser(username string) {
0000000000000000000000000000000000000000;;		if as.simpleTokenKeeper == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper.tokensMu.Lock()
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Lock()
0000000000000000000000000000000000000000;;		for token, name := range as.simpleTokens {
0000000000000000000000000000000000000000;;			if strings.Compare(name, username) == 0 {
0000000000000000000000000000000000000000;;				delete(as.simpleTokens, token)
0000000000000000000000000000000000000000;;				as.simpleTokenKeeper.deleteSimpleToken(token)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Unlock()
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper.tokensMu.Unlock()
0000000000000000000000000000000000000000;;	}
