0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	package auth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/auth/authpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSubset returns true if a is a subset of b.
0000000000000000000000000000000000000000;;	// If a is a prefix of b, then a is a subset of b.
0000000000000000000000000000000000000000;;	// Given intervals [a1,a2) and [b1,b2), is
0000000000000000000000000000000000000000;;	// the a interval a subset of b?
0000000000000000000000000000000000000000;;	func isSubset(a, b *rangePerm) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(a.end) == 0 && len(b.end) == 0:
0000000000000000000000000000000000000000;;			// a, b are both keys
0000000000000000000000000000000000000000;;			return bytes.Equal(a.begin, b.begin)
0000000000000000000000000000000000000000;;		case len(b.end) == 0:
0000000000000000000000000000000000000000;;			// b is a key, a is a range
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case len(a.end) == 0:
0000000000000000000000000000000000000000;;			// a is a key, b is a range. need b1 <= a1 and a1 < b2
0000000000000000000000000000000000000000;;			return bytes.Compare(b.begin, a.begin) <= 0 && bytes.Compare(a.begin, b.end) < 0
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// both are ranges. need b1 <= a1 and a2 <= b2
0000000000000000000000000000000000000000;;			return bytes.Compare(b.begin, a.begin) <= 0 && bytes.Compare(a.end, b.end) <= 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isRangeEqual(a, b *rangePerm) bool {
0000000000000000000000000000000000000000;;		return bytes.Equal(a.begin, b.begin) && bytes.Equal(a.end, b.end)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeSubsetRangePerms removes any rangePerms that are subsets of other rangePerms.
0000000000000000000000000000000000000000;;	// If there are equal ranges, removeSubsetRangePerms only keeps one of them.
0000000000000000000000000000000000000000;;	// It returns a sorted rangePerm slice.
0000000000000000000000000000000000000000;;	func removeSubsetRangePerms(perms []*rangePerm) (newp []*rangePerm) {
0000000000000000000000000000000000000000;;		sort.Sort(RangePermSliceByBegin(perms))
0000000000000000000000000000000000000000;;		var prev *rangePerm
0000000000000000000000000000000000000000;;		for i := range perms {
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				prev = perms[i]
0000000000000000000000000000000000000000;;				newp = append(newp, perms[i])
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isRangeEqual(perms[i], prev) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isSubset(perms[i], prev) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isSubset(prev, perms[i]) {
0000000000000000000000000000000000000000;;				prev = perms[i]
0000000000000000000000000000000000000000;;				newp[len(newp)-1] = perms[i]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prev = perms[i]
0000000000000000000000000000000000000000;;			newp = append(newp, perms[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeRangePerms merges adjacent rangePerms.
0000000000000000000000000000000000000000;;	func mergeRangePerms(perms []*rangePerm) []*rangePerm {
0000000000000000000000000000000000000000;;		var merged []*rangePerm
0000000000000000000000000000000000000000;;		perms = removeSubsetRangePerms(perms)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < len(perms) {
0000000000000000000000000000000000000000;;			begin, next := i, i
0000000000000000000000000000000000000000;;			for next+1 < len(perms) && bytes.Compare(perms[next].end, perms[next+1].begin) >= 0 {
0000000000000000000000000000000000000000;;				next++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// don't merge ["a", "b") with ["b", ""), because perms[next+1].end is empty.
0000000000000000000000000000000000000000;;			if next != begin && len(perms[next].end) > 0 {
0000000000000000000000000000000000000000;;				merged = append(merged, &rangePerm{begin: perms[begin].begin, end: perms[next].end})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				merged = append(merged, perms[begin])
0000000000000000000000000000000000000000;;				if next != begin {
0000000000000000000000000000000000000000;;					merged = append(merged, perms[next])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = next + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return merged
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMergedPerms(tx backend.BatchTx, userName string) *unifiedRangePermissions {
0000000000000000000000000000000000000000;;		user := getUser(tx, userName)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			plog.Errorf("invalid user name %s", userName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var readPerms, writePerms []*rangePerm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, roleName := range user.Roles {
0000000000000000000000000000000000000000;;			role := getRole(tx, roleName)
0000000000000000000000000000000000000000;;			if role == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, perm := range role.KeyPermission {
0000000000000000000000000000000000000000;;				rp := &rangePerm{begin: perm.Key, end: perm.RangeEnd}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch perm.PermType {
0000000000000000000000000000000000000000;;				case authpb.READWRITE:
0000000000000000000000000000000000000000;;					readPerms = append(readPerms, rp)
0000000000000000000000000000000000000000;;					writePerms = append(writePerms, rp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case authpb.READ:
0000000000000000000000000000000000000000;;					readPerms = append(readPerms, rp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case authpb.WRITE:
0000000000000000000000000000000000000000;;					writePerms = append(writePerms, rp)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &unifiedRangePermissions{
0000000000000000000000000000000000000000;;			readPerms:  mergeRangePerms(readPerms),
0000000000000000000000000000000000000000;;			writePerms: mergeRangePerms(writePerms),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkKeyPerm(cachedPerms *unifiedRangePermissions, key, rangeEnd []byte, permtyp authpb.Permission_Type) bool {
0000000000000000000000000000000000000000;;		var tocheck []*rangePerm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch permtyp {
0000000000000000000000000000000000000000;;		case authpb.READ:
0000000000000000000000000000000000000000;;			tocheck = cachedPerms.readPerms
0000000000000000000000000000000000000000;;		case authpb.WRITE:
0000000000000000000000000000000000000000;;			tocheck = cachedPerms.writePerms
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			plog.Panicf("unknown auth type: %v", permtyp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requiredPerm := &rangePerm{begin: key, end: rangeEnd}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, perm := range tocheck {
0000000000000000000000000000000000000000;;			if isSubset(requiredPerm, perm) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) isRangeOpPermitted(tx backend.BatchTx, userName string, key, rangeEnd []byte, permtyp authpb.Permission_Type) bool {
0000000000000000000000000000000000000000;;		// assumption: tx is Lock()ed
0000000000000000000000000000000000000000;;		_, ok := as.rangePermCache[userName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			perms := getMergedPerms(tx, userName)
0000000000000000000000000000000000000000;;			if perms == nil {
0000000000000000000000000000000000000000;;				plog.Errorf("failed to create a unified permission of user %s", userName)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			as.rangePermCache[userName] = perms
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return checkKeyPerm(as.rangePermCache[userName], key, rangeEnd, permtyp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) clearCachedPerm() {
0000000000000000000000000000000000000000;;		as.rangePermCache = make(map[string]*unifiedRangePermissions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) invalidateCachedPerm(userName string) {
0000000000000000000000000000000000000000;;		delete(as.rangePermCache, userName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unifiedRangePermissions struct {
0000000000000000000000000000000000000000;;		// readPerms[i] and readPerms[j] (i != j) don't overlap
0000000000000000000000000000000000000000;;		readPerms []*rangePerm
0000000000000000000000000000000000000000;;		// writePerms[i] and writePerms[j] (i != j) don't overlap, too
0000000000000000000000000000000000000000;;		writePerms []*rangePerm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rangePerm struct {
0000000000000000000000000000000000000000;;		begin, end []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RangePermSliceByBegin []*rangePerm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (slice RangePermSliceByBegin) Len() int {
0000000000000000000000000000000000000000;;		return len(slice)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (slice RangePermSliceByBegin) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		switch bytes.Compare(slice[i].begin, slice[j].begin) {
0000000000000000000000000000000000000000;;		case 0: // begin(i) == begin(j)
0000000000000000000000000000000000000000;;			return bytes.Compare(slice[i].end, slice[j].end) == -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case -1: // begin(i) < begin(j)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (slice RangePermSliceByBegin) Swap(i, j int) {
0000000000000000000000000000000000000000;;		slice[i], slice[j] = slice[j], slice[i]
0000000000000000000000000000000000000000;;	}
