0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/auth/store.go[Godeps/_workspace/src/github.com/coreos/etcd/auth/store.go][vendor/github.com/coreos/etcd/auth/store.go];	
0000000000000000000000000000000000000000;;	package auth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/auth/authpb"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/bcrypt"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		enableFlagKey = []byte("authEnabled")
0000000000000000000000000000000000000000;;		authEnabled   = []byte{1}
0000000000000000000000000000000000000000;;		authDisabled  = []byte{0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		revisionKey = []byte("authRevision")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authBucketName      = []byte("auth")
0000000000000000000000000000000000000000;;		authUsersBucketName = []byte("authUsers")
0000000000000000000000000000000000000000;;		authRolesBucketName = []byte("authRoles")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "auth")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrRootUserNotExist     = errors.New("auth: root user does not exist")
0000000000000000000000000000000000000000;;		ErrRootRoleNotExist     = errors.New("auth: root user does not have root role")
0000000000000000000000000000000000000000;;		ErrUserAlreadyExist     = errors.New("auth: user already exists")
0000000000000000000000000000000000000000;;		ErrUserEmpty            = errors.New("auth: user name is empty")
0000000000000000000000000000000000000000;;		ErrUserNotFound         = errors.New("auth: user not found")
0000000000000000000000000000000000000000;;		ErrRoleAlreadyExist     = errors.New("auth: role already exists")
0000000000000000000000000000000000000000;;		ErrRoleNotFound         = errors.New("auth: role not found")
0000000000000000000000000000000000000000;;		ErrAuthFailed           = errors.New("auth: authentication failed, invalid user ID or password")
0000000000000000000000000000000000000000;;		ErrPermissionDenied     = errors.New("auth: permission denied")
0000000000000000000000000000000000000000;;		ErrRoleNotGranted       = errors.New("auth: role is not granted to the user")
0000000000000000000000000000000000000000;;		ErrPermissionNotGranted = errors.New("auth: permission is not granted to the role")
0000000000000000000000000000000000000000;;		ErrAuthNotEnabled       = errors.New("auth: authentication is not enabled")
0000000000000000000000000000000000000000;;		ErrAuthOldRevision      = errors.New("auth: revision in header is old")
0000000000000000000000000000000000000000;;		ErrInvalidAuthToken     = errors.New("auth: invalid auth token")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BcryptCost is the algorithm cost / strength for hashing auth passwords
0000000000000000000000000000000000000000;;		BcryptCost = bcrypt.DefaultCost
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		rootUser = "root"
0000000000000000000000000000000000000000;;		rootRole = "root"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		revBytesLen = 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuthInfo struct {
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;		Revision uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuthStore interface {
0000000000000000000000000000000000000000;;		// AuthEnable turns on the authentication feature
0000000000000000000000000000000000000000;;		AuthEnable() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuthDisable turns off the authentication feature
0000000000000000000000000000000000000000;;		AuthDisable()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Authenticate does authentication based on given user name and password
0000000000000000000000000000000000000000;;		Authenticate(ctx context.Context, username, password string) (*pb.AuthenticateResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recover recovers the state of auth store from the given backend
0000000000000000000000000000000000000000;;		Recover(b backend.Backend)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserAdd adds a new user
0000000000000000000000000000000000000000;;		UserAdd(r *pb.AuthUserAddRequest) (*pb.AuthUserAddResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserDelete deletes a user
0000000000000000000000000000000000000000;;		UserDelete(r *pb.AuthUserDeleteRequest) (*pb.AuthUserDeleteResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserChangePassword changes a password of a user
0000000000000000000000000000000000000000;;		UserChangePassword(r *pb.AuthUserChangePasswordRequest) (*pb.AuthUserChangePasswordResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserGrantRole grants a role to the user
0000000000000000000000000000000000000000;;		UserGrantRole(r *pb.AuthUserGrantRoleRequest) (*pb.AuthUserGrantRoleResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserGet gets the detailed information of a users
0000000000000000000000000000000000000000;;		UserGet(r *pb.AuthUserGetRequest) (*pb.AuthUserGetResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserRevokeRole revokes a role of a user
0000000000000000000000000000000000000000;;		UserRevokeRole(r *pb.AuthUserRevokeRoleRequest) (*pb.AuthUserRevokeRoleResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleAdd adds a new role
0000000000000000000000000000000000000000;;		RoleAdd(r *pb.AuthRoleAddRequest) (*pb.AuthRoleAddResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleGrantPermission grants a permission to a role
0000000000000000000000000000000000000000;;		RoleGrantPermission(r *pb.AuthRoleGrantPermissionRequest) (*pb.AuthRoleGrantPermissionResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleGet gets the detailed information of a role
0000000000000000000000000000000000000000;;		RoleGet(r *pb.AuthRoleGetRequest) (*pb.AuthRoleGetResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleRevokePermission gets the detailed information of a role
0000000000000000000000000000000000000000;;		RoleRevokePermission(r *pb.AuthRoleRevokePermissionRequest) (*pb.AuthRoleRevokePermissionResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleDelete gets the detailed information of a role
0000000000000000000000000000000000000000;;		RoleDelete(r *pb.AuthRoleDeleteRequest) (*pb.AuthRoleDeleteResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserList gets a list of all users
0000000000000000000000000000000000000000;;		UserList(r *pb.AuthUserListRequest) (*pb.AuthUserListResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleList gets a list of all roles
0000000000000000000000000000000000000000;;		RoleList(r *pb.AuthRoleListRequest) (*pb.AuthRoleListResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuthInfoFromToken gets a username from the given Token and current revision number
0000000000000000000000000000000000000000;;		// (The revision number is used for preventing the TOCTOU problem)
0000000000000000000000000000000000000000;;		AuthInfoFromToken(token string) (*AuthInfo, bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsPutPermitted checks put permission of the user
0000000000000000000000000000000000000000;;		IsPutPermitted(authInfo *AuthInfo, key []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsRangePermitted checks range permission of the user
0000000000000000000000000000000000000000;;		IsRangePermitted(authInfo *AuthInfo, key, rangeEnd []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsDeleteRangePermitted checks delete-range permission of the user
0000000000000000000000000000000000000000;;		IsDeleteRangePermitted(authInfo *AuthInfo, key, rangeEnd []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsAdminPermitted checks admin permission of the user
0000000000000000000000000000000000000000;;		IsAdminPermitted(authInfo *AuthInfo) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GenSimpleToken produces a simple random string
0000000000000000000000000000000000000000;;		GenSimpleToken() (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Revision gets current revision of authStore
0000000000000000000000000000000000000000;;		Revision() uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CheckPassword checks a given pair of username and password is correct
0000000000000000000000000000000000000000;;		CheckPassword(username, password string) (uint64, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close does cleanup of AuthStore
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuthInfoFromCtx gets AuthInfo from gRPC's context
0000000000000000000000000000000000000000;;		AuthInfoFromCtx(ctx context.Context) (*AuthInfo, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authStore struct {
0000000000000000000000000000000000000000;;		be        backend.Backend
0000000000000000000000000000000000000000;;		enabled   bool
0000000000000000000000000000000000000000;;		enabledMu sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rangePermCache map[string]*unifiedRangePermissions // username -> unifiedRangePermissions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		revision uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tokenSimple in v3.2+
0000000000000000000000000000000000000000;;		indexWaiter       func(uint64) <-chan struct{}
0000000000000000000000000000000000000000;;		simpleTokenKeeper *simpleTokenTTLKeeper
0000000000000000000000000000000000000000;;		simpleTokensMu    sync.Mutex
0000000000000000000000000000000000000000;;		simpleTokens      map[string]string // token -> username
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDeleterFunc(as *authStore) func(string) {
0000000000000000000000000000000000000000;;		return func(t string) {
0000000000000000000000000000000000000000;;			as.simpleTokensMu.Lock()
0000000000000000000000000000000000000000;;			defer as.simpleTokensMu.Unlock()
0000000000000000000000000000000000000000;;			if username, ok := as.simpleTokens[t]; ok {
0000000000000000000000000000000000000000;;				plog.Infof("deleting token %s for user %s", t, username)
0000000000000000000000000000000000000000;;				delete(as.simpleTokens, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) AuthEnable() error {
0000000000000000000000000000000000000000;;		as.enabledMu.Lock()
0000000000000000000000000000000000000000;;		defer as.enabledMu.Unlock()
0000000000000000000000000000000000000000;;		if as.enabled {
0000000000000000000000000000000000000000;;			plog.Noticef("Authentication already enabled")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := as.be
0000000000000000000000000000000000000000;;		tx := b.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			tx.Unlock()
0000000000000000000000000000000000000000;;			b.ForceCommit()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u := getUser(tx, rootUser)
0000000000000000000000000000000000000000;;		if u == nil {
0000000000000000000000000000000000000000;;			return ErrRootUserNotExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !hasRootRole(u) {
0000000000000000000000000000000000000000;;			return ErrRootRoleNotExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.UnsafePut(authBucketName, enableFlagKey, authEnabled)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.enabled = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper = NewSimpleTokenTTLKeeper(newDeleterFunc(as))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.rangePermCache = make(map[string]*unifiedRangePermissions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.revision = getRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("Authentication enabled")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) AuthDisable() {
0000000000000000000000000000000000000000;;		as.enabledMu.Lock()
0000000000000000000000000000000000000000;;		defer as.enabledMu.Unlock()
0000000000000000000000000000000000000000;;		if !as.enabled {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := as.be
0000000000000000000000000000000000000000;;		tx := b.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		tx.UnsafePut(authBucketName, enableFlagKey, authDisabled)
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;		b.ForceCommit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.enabled = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Lock()
0000000000000000000000000000000000000000;;		as.simpleTokens = make(map[string]string) // invalidate all tokens
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Unlock()
0000000000000000000000000000000000000000;;		if as.simpleTokenKeeper != nil {
0000000000000000000000000000000000000000;;			as.simpleTokenKeeper.stop()
0000000000000000000000000000000000000000;;			as.simpleTokenKeeper = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("Authentication disabled")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) Close() error {
0000000000000000000000000000000000000000;;		as.enabledMu.Lock()
0000000000000000000000000000000000000000;;		defer as.enabledMu.Unlock()
0000000000000000000000000000000000000000;;		if !as.enabled {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if as.simpleTokenKeeper != nil {
0000000000000000000000000000000000000000;;			as.simpleTokenKeeper.stop()
0000000000000000000000000000000000000000;;			as.simpleTokenKeeper = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) Authenticate(ctx context.Context, username, password string) (*pb.AuthenticateResponse, error) {
0000000000000000000000000000000000000000;;		if !as.isAuthEnabled() {
0000000000000000000000000000000000000000;;			return nil, ErrAuthNotEnabled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(mitake): after adding jwt support, branching based on values of ctx is required
0000000000000000000000000000000000000000;;		index := ctx.Value("index").(uint64)
0000000000000000000000000000000000000000;;		simpleToken := ctx.Value("simpleToken").(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, username)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			return nil, ErrAuthFailed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := fmt.Sprintf("%s.%d", simpleToken, index)
0000000000000000000000000000000000000000;;		as.assignSimpleTokenToUser(username, token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("authorized %s, token is %s", username, token)
0000000000000000000000000000000000000000;;		return &pb.AuthenticateResponse{Token: token}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) CheckPassword(username, password string) (uint64, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, username)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			return 0, ErrAuthFailed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bcrypt.CompareHashAndPassword(user.Password, []byte(password)) != nil {
0000000000000000000000000000000000000000;;			plog.Noticef("authentication failed, invalid password for user %s", username)
0000000000000000000000000000000000000000;;			return 0, ErrAuthFailed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return getRevision(tx), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) Recover(be backend.Backend) {
0000000000000000000000000000000000000000;;		enabled := false
0000000000000000000000000000000000000000;;		as.be = be
0000000000000000000000000000000000000000;;		tx := be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(authBucketName, enableFlagKey, nil, 0)
0000000000000000000000000000000000000000;;		if len(vs) == 1 {
0000000000000000000000000000000000000000;;			if bytes.Equal(vs[0], authEnabled) {
0000000000000000000000000000000000000000;;				enabled = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.revision = getRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.enabledMu.Lock()
0000000000000000000000000000000000000000;;		as.enabled = enabled
0000000000000000000000000000000000000000;;		as.enabledMu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) UserAdd(r *pb.AuthUserAddRequest) (*pb.AuthUserAddResponse, error) {
0000000000000000000000000000000000000000;;		if len(r.Name) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrUserEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hashed, err := bcrypt.GenerateFromPassword([]byte(r.Password), BcryptCost)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("failed to hash password: %s", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, r.Name)
0000000000000000000000000000000000000000;;		if user != nil {
0000000000000000000000000000000000000000;;			return nil, ErrUserAlreadyExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newUser := &authpb.User{
0000000000000000000000000000000000000000;;			Name:     []byte(r.Name),
0000000000000000000000000000000000000000;;			Password: hashed,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putUser(tx, newUser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("added a new user: %s", r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pb.AuthUserAddResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) UserDelete(r *pb.AuthUserDeleteRequest) (*pb.AuthUserDeleteResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, r.Name)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			return nil, ErrUserNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delUser(tx, r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.invalidateCachedPerm(r.Name)
0000000000000000000000000000000000000000;;		as.invalidateUser(r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("deleted a user: %s", r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pb.AuthUserDeleteResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) UserChangePassword(r *pb.AuthUserChangePasswordRequest) (*pb.AuthUserChangePasswordResponse, error) {
0000000000000000000000000000000000000000;;		// TODO(mitake): measure the cost of bcrypt.GenerateFromPassword()
0000000000000000000000000000000000000000;;		// If the cost is too high, we should move the encryption to outside of the raft
0000000000000000000000000000000000000000;;		hashed, err := bcrypt.GenerateFromPassword([]byte(r.Password), BcryptCost)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("failed to hash password: %s", err)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, r.Name)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			return nil, ErrUserNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedUser := &authpb.User{
0000000000000000000000000000000000000000;;			Name:     []byte(r.Name),
0000000000000000000000000000000000000000;;			Roles:    user.Roles,
0000000000000000000000000000000000000000;;			Password: hashed,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putUser(tx, updatedUser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.invalidateCachedPerm(r.Name)
0000000000000000000000000000000000000000;;		as.invalidateUser(r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("changed a password of a user: %s", r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pb.AuthUserChangePasswordResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) UserGrantRole(r *pb.AuthUserGrantRoleRequest) (*pb.AuthUserGrantRoleResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, r.User)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			return nil, ErrUserNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Role != rootRole {
0000000000000000000000000000000000000000;;			role := getRole(tx, r.Role)
0000000000000000000000000000000000000000;;			if role == nil {
0000000000000000000000000000000000000000;;				return nil, ErrRoleNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idx := sort.SearchStrings(user.Roles, r.Role)
0000000000000000000000000000000000000000;;		if idx < len(user.Roles) && strings.Compare(user.Roles[idx], r.Role) == 0 {
0000000000000000000000000000000000000000;;			plog.Warningf("user %s is already granted role %s", r.User, r.Role)
0000000000000000000000000000000000000000;;			return &pb.AuthUserGrantRoleResponse{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user.Roles = append(user.Roles, r.Role)
0000000000000000000000000000000000000000;;		sort.Sort(sort.StringSlice(user.Roles))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putUser(tx, user)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.invalidateCachedPerm(r.User)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("granted role %s to user %s", r.Role, r.User)
0000000000000000000000000000000000000000;;		return &pb.AuthUserGrantRoleResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) UserGet(r *pb.AuthUserGetRequest) (*pb.AuthUserGetResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp pb.AuthUserGetResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, r.Name)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			return nil, ErrUserNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Roles = append(resp.Roles, user.Roles...)
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) UserList(r *pb.AuthUserListRequest) (*pb.AuthUserListResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp pb.AuthUserListResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		users := getAllUsers(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, u := range users {
0000000000000000000000000000000000000000;;			resp.Users = append(resp.Users, string(u.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) UserRevokeRole(r *pb.AuthUserRevokeRoleRequest) (*pb.AuthUserRevokeRoleResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, r.Name)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			return nil, ErrUserNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedUser := &authpb.User{
0000000000000000000000000000000000000000;;			Name:     user.Name,
0000000000000000000000000000000000000000;;			Password: user.Password,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, role := range user.Roles {
0000000000000000000000000000000000000000;;			if strings.Compare(role, r.Role) != 0 {
0000000000000000000000000000000000000000;;				updatedUser.Roles = append(updatedUser.Roles, role)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(updatedUser.Roles) == len(user.Roles) {
0000000000000000000000000000000000000000;;			return nil, ErrRoleNotGranted
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putUser(tx, updatedUser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.invalidateCachedPerm(r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("revoked role %s from user %s", r.Role, r.Name)
0000000000000000000000000000000000000000;;		return &pb.AuthUserRevokeRoleResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) RoleGet(r *pb.AuthRoleGetRequest) (*pb.AuthRoleGetResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp pb.AuthRoleGetResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := getRole(tx, r.Role)
0000000000000000000000000000000000000000;;		if role == nil {
0000000000000000000000000000000000000000;;			return nil, ErrRoleNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Perm = append(resp.Perm, role.KeyPermission...)
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) RoleList(r *pb.AuthRoleListRequest) (*pb.AuthRoleListResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp pb.AuthRoleListResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roles := getAllRoles(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range roles {
0000000000000000000000000000000000000000;;			resp.Roles = append(resp.Roles, string(r.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) RoleRevokePermission(r *pb.AuthRoleRevokePermissionRequest) (*pb.AuthRoleRevokePermissionResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := getRole(tx, r.Role)
0000000000000000000000000000000000000000;;		if role == nil {
0000000000000000000000000000000000000000;;			return nil, ErrRoleNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatedRole := &authpb.Role{
0000000000000000000000000000000000000000;;			Name: role.Name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, perm := range role.KeyPermission {
0000000000000000000000000000000000000000;;			if !bytes.Equal(perm.Key, []byte(r.Key)) || !bytes.Equal(perm.RangeEnd, []byte(r.RangeEnd)) {
0000000000000000000000000000000000000000;;				updatedRole.KeyPermission = append(updatedRole.KeyPermission, perm)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(role.KeyPermission) == len(updatedRole.KeyPermission) {
0000000000000000000000000000000000000000;;			return nil, ErrPermissionNotGranted
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putRole(tx, updatedRole)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(mitake): currently single role update invalidates every cache
0000000000000000000000000000000000000000;;		// It should be optimized.
0000000000000000000000000000000000000000;;		as.clearCachedPerm()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("revoked key %s from role %s", r.Key, r.Role)
0000000000000000000000000000000000000000;;		return &pb.AuthRoleRevokePermissionResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) RoleDelete(r *pb.AuthRoleDeleteRequest) (*pb.AuthRoleDeleteResponse, error) {
0000000000000000000000000000000000000000;;		// TODO(mitake): current scheme of role deletion allows existing users to have the deleted roles
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Assume a case like below:
0000000000000000000000000000000000000000;;		// create a role r1
0000000000000000000000000000000000000000;;		// create a user u1 and grant r1 to u1
0000000000000000000000000000000000000000;;		// delete r1
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// After this sequence, u1 is still granted the role r1. So if admin create a new role with the name r1,
0000000000000000000000000000000000000000;;		// the new r1 is automatically granted u1.
0000000000000000000000000000000000000000;;		// In some cases, it would be confusing. So we need to provide an option for deleting the grant relation
0000000000000000000000000000000000000000;;		// from all users.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := getRole(tx, r.Role)
0000000000000000000000000000000000000000;;		if role == nil {
0000000000000000000000000000000000000000;;			return nil, ErrRoleNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delRole(tx, r.Role)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("deleted role %s", r.Role)
0000000000000000000000000000000000000000;;		return &pb.AuthRoleDeleteResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) RoleAdd(r *pb.AuthRoleAddRequest) (*pb.AuthRoleAddResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := getRole(tx, r.Name)
0000000000000000000000000000000000000000;;		if role != nil {
0000000000000000000000000000000000000000;;			return nil, ErrRoleAlreadyExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newRole := &authpb.Role{
0000000000000000000000000000000000000000;;			Name: []byte(r.Name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putRole(tx, newRole)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("Role %s is created", r.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pb.AuthRoleAddResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) AuthInfoFromToken(token string) (*AuthInfo, bool) {
0000000000000000000000000000000000000000;;		// same as '(t *tokenSimple) info' in v3.2+
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper.tokensMu.Lock()
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Lock()
0000000000000000000000000000000000000000;;		username, ok := as.simpleTokens[token]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			as.simpleTokenKeeper.resetSimpleToken(token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		as.simpleTokensMu.Unlock()
0000000000000000000000000000000000000000;;		as.simpleTokenKeeper.tokensMu.Unlock()
0000000000000000000000000000000000000000;;		return &AuthInfo{Username: username, Revision: as.revision}, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type permSlice []*authpb.Permission
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (perms permSlice) Len() int {
0000000000000000000000000000000000000000;;		return len(perms)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (perms permSlice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return bytes.Compare(perms[i].Key, perms[j].Key) < 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (perms permSlice) Swap(i, j int) {
0000000000000000000000000000000000000000;;		perms[i], perms[j] = perms[j], perms[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) RoleGrantPermission(r *pb.AuthRoleGrantPermissionRequest) (*pb.AuthRoleGrantPermissionResponse, error) {
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := getRole(tx, r.Name)
0000000000000000000000000000000000000000;;		if role == nil {
0000000000000000000000000000000000000000;;			return nil, ErrRoleNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idx := sort.Search(len(role.KeyPermission), func(i int) bool {
0000000000000000000000000000000000000000;;			return bytes.Compare(role.KeyPermission[i].Key, []byte(r.Perm.Key)) >= 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if idx < len(role.KeyPermission) && bytes.Equal(role.KeyPermission[idx].Key, r.Perm.Key) && bytes.Equal(role.KeyPermission[idx].RangeEnd, r.Perm.RangeEnd) {
0000000000000000000000000000000000000000;;			// update existing permission
0000000000000000000000000000000000000000;;			role.KeyPermission[idx].PermType = r.Perm.PermType
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// append new permission to the role
0000000000000000000000000000000000000000;;			newPerm := &authpb.Permission{
0000000000000000000000000000000000000000;;				Key:      []byte(r.Perm.Key),
0000000000000000000000000000000000000000;;				RangeEnd: []byte(r.Perm.RangeEnd),
0000000000000000000000000000000000000000;;				PermType: r.Perm.PermType,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			role.KeyPermission = append(role.KeyPermission, newPerm)
0000000000000000000000000000000000000000;;			sort.Sort(permSlice(role.KeyPermission))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putRole(tx, role)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(mitake): currently single role update invalidates every cache
0000000000000000000000000000000000000000;;		// It should be optimized.
0000000000000000000000000000000000000000;;		as.clearCachedPerm()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as.commitRevision(tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("role %s's permission of key %s is updated as %s", r.Name, r.Perm.Key, authpb.Permission_Type_name[int32(r.Perm.PermType)])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pb.AuthRoleGrantPermissionResponse{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) isOpPermitted(userName string, revision uint64, key, rangeEnd []byte, permTyp authpb.Permission_Type) error {
0000000000000000000000000000000000000000;;		// TODO(mitake): this function would be costly so we need a caching mechanism
0000000000000000000000000000000000000000;;		if !as.isAuthEnabled() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only gets rev == 0 when passed AuthInfo{}; no user given
0000000000000000000000000000000000000000;;		if revision == 0 {
0000000000000000000000000000000000000000;;			return ErrUserEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if revision < as.revision {
0000000000000000000000000000000000000000;;			return ErrAuthOldRevision
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := getUser(tx, userName)
0000000000000000000000000000000000000000;;		if user == nil {
0000000000000000000000000000000000000000;;			plog.Errorf("invalid user name %s for permission checking", userName)
0000000000000000000000000000000000000000;;			return ErrPermissionDenied
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// root role should have permission on all ranges
0000000000000000000000000000000000000000;;		if hasRootRole(user) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if as.isRangeOpPermitted(tx, userName, key, rangeEnd, permTyp) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ErrPermissionDenied
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) IsPutPermitted(authInfo *AuthInfo, key []byte) error {
0000000000000000000000000000000000000000;;		return as.isOpPermitted(authInfo.Username, authInfo.Revision, key, nil, authpb.WRITE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) IsRangePermitted(authInfo *AuthInfo, key, rangeEnd []byte) error {
0000000000000000000000000000000000000000;;		return as.isOpPermitted(authInfo.Username, authInfo.Revision, key, rangeEnd, authpb.READ)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) IsDeleteRangePermitted(authInfo *AuthInfo, key, rangeEnd []byte) error {
0000000000000000000000000000000000000000;;		return as.isOpPermitted(authInfo.Username, authInfo.Revision, key, rangeEnd, authpb.WRITE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) IsAdminPermitted(authInfo *AuthInfo) error {
0000000000000000000000000000000000000000;;		if !as.isAuthEnabled() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if authInfo == nil {
0000000000000000000000000000000000000000;;			return ErrUserEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := as.be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u := getUser(tx, authInfo.Username)
0000000000000000000000000000000000000000;;		if u == nil {
0000000000000000000000000000000000000000;;			return ErrUserNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !hasRootRole(u) {
0000000000000000000000000000000000000000;;			return ErrPermissionDenied
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getUser(tx backend.BatchTx, username string) *authpb.User {
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(authUsersBucketName, []byte(username), nil, 0)
0000000000000000000000000000000000000000;;		if len(vs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user := &authpb.User{}
0000000000000000000000000000000000000000;;		err := user.Unmarshal(vs[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("failed to unmarshal user struct (name: %s): %s", username, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return user
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAllUsers(tx backend.BatchTx) []*authpb.User {
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(authUsersBucketName, []byte{0}, []byte{0xff}, -1)
0000000000000000000000000000000000000000;;		if len(vs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var users []*authpb.User
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range vs {
0000000000000000000000000000000000000000;;			user := &authpb.User{}
0000000000000000000000000000000000000000;;			err := user.Unmarshal(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("failed to unmarshal user struct: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			users = append(users, user)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return users
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func putUser(tx backend.BatchTx, user *authpb.User) {
0000000000000000000000000000000000000000;;		b, err := user.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("failed to marshal user struct (name: %s): %s", user.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.UnsafePut(authUsersBucketName, user.Name, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func delUser(tx backend.BatchTx, username string) {
0000000000000000000000000000000000000000;;		tx.UnsafeDelete(authUsersBucketName, []byte(username))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRole(tx backend.BatchTx, rolename string) *authpb.Role {
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(authRolesBucketName, []byte(rolename), nil, 0)
0000000000000000000000000000000000000000;;		if len(vs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		role := &authpb.Role{}
0000000000000000000000000000000000000000;;		err := role.Unmarshal(vs[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("failed to unmarshal role struct (name: %s): %s", rolename, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return role
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAllRoles(tx backend.BatchTx) []*authpb.Role {
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(authRolesBucketName, []byte{0}, []byte{0xff}, -1)
0000000000000000000000000000000000000000;;		if len(vs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var roles []*authpb.Role
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range vs {
0000000000000000000000000000000000000000;;			role := &authpb.Role{}
0000000000000000000000000000000000000000;;			err := role.Unmarshal(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("failed to unmarshal role struct: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			roles = append(roles, role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return roles
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func putRole(tx backend.BatchTx, role *authpb.Role) {
0000000000000000000000000000000000000000;;		b, err := role.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("failed to marshal role struct (name: %s): %s", role.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.UnsafePut(authRolesBucketName, []byte(role.Name), b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func delRole(tx backend.BatchTx, rolename string) {
0000000000000000000000000000000000000000;;		tx.UnsafeDelete(authRolesBucketName, []byte(rolename))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) isAuthEnabled() bool {
0000000000000000000000000000000000000000;;		as.enabledMu.RLock()
0000000000000000000000000000000000000000;;		defer as.enabledMu.RUnlock()
0000000000000000000000000000000000000000;;		return as.enabled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAuthStore(be backend.Backend, indexWaiter func(uint64) <-chan struct{}) *authStore {
0000000000000000000000000000000000000000;;		tx := be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(authBucketName)
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(authUsersBucketName)
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(authRolesBucketName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enabled := false
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(authBucketName, enableFlagKey, nil, 0)
0000000000000000000000000000000000000000;;		if len(vs) == 1 {
0000000000000000000000000000000000000000;;			if bytes.Equal(vs[0], authEnabled) {
0000000000000000000000000000000000000000;;				enabled = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		as := &authStore{
0000000000000000000000000000000000000000;;			be:             be,
0000000000000000000000000000000000000000;;			simpleTokens:   make(map[string]string),
0000000000000000000000000000000000000000;;			revision:       getRevision(tx),
0000000000000000000000000000000000000000;;			indexWaiter:    indexWaiter,
0000000000000000000000000000000000000000;;			enabled:        enabled,
0000000000000000000000000000000000000000;;			rangePermCache: make(map[string]*unifiedRangePermissions),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if enabled {
0000000000000000000000000000000000000000;;			as.simpleTokenKeeper = NewSimpleTokenTTLKeeper(newDeleterFunc(as))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if as.revision == 0 {
0000000000000000000000000000000000000000;;			as.commitRevision(tx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;		be.ForceCommit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return as
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasRootRole(u *authpb.User) bool {
0000000000000000000000000000000000000000;;		for _, r := range u.Roles {
0000000000000000000000000000000000000000;;			if r == rootRole {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) commitRevision(tx backend.BatchTx) {
0000000000000000000000000000000000000000;;		as.revision++
0000000000000000000000000000000000000000;;		revBytes := make([]byte, revBytesLen)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(revBytes, as.revision)
0000000000000000000000000000000000000000;;		tx.UnsafePut(authBucketName, revisionKey, revBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRevision(tx backend.BatchTx) uint64 {
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(authBucketName, []byte(revisionKey), nil, 0)
0000000000000000000000000000000000000000;;		if len(vs) != 1 {
0000000000000000000000000000000000000000;;			// this can happen in the initialization phase
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return binary.BigEndian.Uint64(vs[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) Revision() uint64 {
0000000000000000000000000000000000000000;;		return as.revision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) isValidSimpleToken(token string, ctx context.Context) bool {
0000000000000000000000000000000000000000;;		splitted := strings.Split(token, ".")
0000000000000000000000000000000000000000;;		if len(splitted) != 2 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index, err := strconv.Atoi(splitted[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-as.indexWaiter(uint64(index)):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (as *authStore) AuthInfoFromCtx(ctx context.Context) (*AuthInfo, error) {
0000000000000000000000000000000000000000;;		md, ok := metadata.FromContext(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts, tok := md["token"]
0000000000000000000000000000000000000000;;		if !tok {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := ts[0]
0000000000000000000000000000000000000000;;		if !as.isValidSimpleToken(token, ctx) {
0000000000000000000000000000000000000000;;			return nil, ErrInvalidAuthToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authInfo, uok := as.AuthInfoFromToken(token)
0000000000000000000000000000000000000000;;		if !uok {
0000000000000000000000000000000000000000;;			plog.Warningf("invalid auth token: %s", token)
0000000000000000000000000000000000000000;;			return nil, ErrInvalidAuthToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return authInfo, nil
0000000000000000000000000000000000000000;;	}
