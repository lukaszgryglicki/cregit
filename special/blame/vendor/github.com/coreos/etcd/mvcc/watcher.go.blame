0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/storage/watcher.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/watcher.go][vendor/github.com/coreos/etcd/mvcc/watcher.go];	
0000000000000000000000000000000000000000;;	package mvcc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/mvccpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrWatcherNotExist = errors.New("mvcc: watcher does not exist")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WatchID int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterFunc returns true if the given event should be filtered out.
0000000000000000000000000000000000000000;;	type FilterFunc func(e mvccpb.Event) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WatchStream interface {
0000000000000000000000000000000000000000;;		// Watch creates a watcher. The watcher watches the events happening or
0000000000000000000000000000000000000000;;		// happened on the given key or range [key, end) from the given startRev.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The whole event history can be watched unless compacted.
0000000000000000000000000000000000000000;;		// If `startRev` <=0, watch observes events after currentRev.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The returned `id` is the ID of this watcher. It appears as WatchID
0000000000000000000000000000000000000000;;		// in events that are sent to the created watcher through stream channel.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		Watch(key, end []byte, startRev int64, fcs ...FilterFunc) WatchID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Chan returns a chan. All watch response will be sent to the returned chan.
0000000000000000000000000000000000000000;;		Chan() <-chan WatchResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequestProgress requests the progress of the watcher with given ID. The response
0000000000000000000000000000000000000000;;		// will only be sent if the watcher is currently synced.
0000000000000000000000000000000000000000;;		// The responses will be sent through the WatchRespone Chan attached
0000000000000000000000000000000000000000;;		// with this stream to ensure correct ordering.
0000000000000000000000000000000000000000;;		// The responses contains no events. The revision in the response is the progress
0000000000000000000000000000000000000000;;		// of the watchers since the watcher is currently synced.
0000000000000000000000000000000000000000;;		RequestProgress(id WatchID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cancel cancels a watcher by giving its ID. If watcher does not exist, an error will be
0000000000000000000000000000000000000000;;		// returned.
0000000000000000000000000000000000000000;;		Cancel(id WatchID) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close closes Chan and release all related resources.
0000000000000000000000000000000000000000;;		Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rev returns the current revision of the KV the stream watches on.
0000000000000000000000000000000000000000;;		Rev() int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WatchResponse struct {
0000000000000000000000000000000000000000;;		// WatchID is the WatchID of the watcher this response sent to.
0000000000000000000000000000000000000000;;		WatchID WatchID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Events contains all the events that needs to send.
0000000000000000000000000000000000000000;;		Events []mvccpb.Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Revision is the revision of the KV when the watchResponse is created.
0000000000000000000000000000000000000000;;		// For a normal response, the revision should be the same as the last
0000000000000000000000000000000000000000;;		// modified revision inside Events. For a delayed response to a unsynced
0000000000000000000000000000000000000000;;		// watcher, the revision is greater than the last modified revision
0000000000000000000000000000000000000000;;		// inside Events.
0000000000000000000000000000000000000000;;		Revision int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CompactRevision is set when the watcher is cancelled due to compaction.
0000000000000000000000000000000000000000;;		CompactRevision int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchStream contains a collection of watchers that share
0000000000000000000000000000000000000000;;	// one streaming chan to send out watched events and other control events.
0000000000000000000000000000000000000000;;	type watchStream struct {
0000000000000000000000000000000000000000;;		watchable watchable
0000000000000000000000000000000000000000;;		ch        chan WatchResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.Mutex // guards fields below it
0000000000000000000000000000000000000000;;		// nextID is the ID pre-allocated for next new watcher in this stream
0000000000000000000000000000000000000000;;		nextID   WatchID
0000000000000000000000000000000000000000;;		closed   bool
0000000000000000000000000000000000000000;;		cancels  map[WatchID]cancelFunc
0000000000000000000000000000000000000000;;		watchers map[WatchID]*watcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch creates a new watcher in the stream and returns its WatchID.
0000000000000000000000000000000000000000;;	// TODO: return error if ws is closed?
0000000000000000000000000000000000000000;;	func (ws *watchStream) Watch(key, end []byte, startRev int64, fcs ...FilterFunc) WatchID {
0000000000000000000000000000000000000000;;		// prevent wrong range where key >= end lexicographically
0000000000000000000000000000000000000000;;		// watch request with 'WithFromKey' has empty-byte range end
0000000000000000000000000000000000000000;;		if len(end) != 0 && bytes.Compare(key, end) != -1 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws.mu.Lock()
0000000000000000000000000000000000000000;;		defer ws.mu.Unlock()
0000000000000000000000000000000000000000;;		if ws.closed {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := ws.nextID
0000000000000000000000000000000000000000;;		ws.nextID++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, c := ws.watchable.watch(key, end, startRev, id, ws.ch, fcs...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws.cancels[id] = c
0000000000000000000000000000000000000000;;		ws.watchers[id] = w
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *watchStream) Chan() <-chan WatchResponse {
0000000000000000000000000000000000000000;;		return ws.ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *watchStream) Cancel(id WatchID) error {
0000000000000000000000000000000000000000;;		ws.mu.Lock()
0000000000000000000000000000000000000000;;		cancel, ok := ws.cancels[id]
0000000000000000000000000000000000000000;;		ok = ok && !ws.closed
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			delete(ws.cancels, id)
0000000000000000000000000000000000000000;;			delete(ws.watchers, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws.mu.Unlock()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrWatcherNotExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *watchStream) Close() {
0000000000000000000000000000000000000000;;		ws.mu.Lock()
0000000000000000000000000000000000000000;;		defer ws.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cancel := range ws.cancels {
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws.closed = true
0000000000000000000000000000000000000000;;		close(ws.ch)
0000000000000000000000000000000000000000;;		watchStreamGauge.Dec()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *watchStream) Rev() int64 {
0000000000000000000000000000000000000000;;		ws.mu.Lock()
0000000000000000000000000000000000000000;;		defer ws.mu.Unlock()
0000000000000000000000000000000000000000;;		return ws.watchable.rev()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *watchStream) RequestProgress(id WatchID) {
0000000000000000000000000000000000000000;;		ws.mu.Lock()
0000000000000000000000000000000000000000;;		w, ok := ws.watchers[id]
0000000000000000000000000000000000000000;;		ws.mu.Unlock()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws.watchable.progress(w)
0000000000000000000000000000000000000000;;	}
