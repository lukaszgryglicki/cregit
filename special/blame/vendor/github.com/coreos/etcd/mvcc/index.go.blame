0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/storage/index.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/index.go][vendor/github.com/coreos/etcd/mvcc/index.go];	
0000000000000000000000000000000000000000;;	package mvcc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/btree"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type index interface {
0000000000000000000000000000000000000000;;		Get(key []byte, atRev int64) (rev, created revision, ver int64, err error)
0000000000000000000000000000000000000000;;		Range(key, end []byte, atRev int64) ([][]byte, []revision)
0000000000000000000000000000000000000000;;		Put(key []byte, rev revision)
0000000000000000000000000000000000000000;;		Tombstone(key []byte, rev revision) error
0000000000000000000000000000000000000000;;		RangeSince(key, end []byte, rev int64) []revision
0000000000000000000000000000000000000000;;		Compact(rev int64) map[revision]struct{}
0000000000000000000000000000000000000000;;		Equal(b index) bool
0000000000000000000000000000000000000000;;		Insert(ki *keyIndex)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type treeIndex struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		tree *btree.BTree
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTreeIndex() index {
0000000000000000000000000000000000000000;;		return &treeIndex{
0000000000000000000000000000000000000000;;			tree: btree.New(32),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ti *treeIndex) Put(key []byte, rev revision) {
0000000000000000000000000000000000000000;;		keyi := &keyIndex{key: key}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti.Lock()
0000000000000000000000000000000000000000;;		defer ti.Unlock()
0000000000000000000000000000000000000000;;		item := ti.tree.Get(keyi)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			keyi.put(rev.main, rev.sub)
0000000000000000000000000000000000000000;;			ti.tree.ReplaceOrInsert(keyi)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		okeyi := item.(*keyIndex)
0000000000000000000000000000000000000000;;		okeyi.put(rev.main, rev.sub)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ti *treeIndex) Get(key []byte, atRev int64) (modified, created revision, ver int64, err error) {
0000000000000000000000000000000000000000;;		keyi := &keyIndex{key: key}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti.RLock()
0000000000000000000000000000000000000000;;		defer ti.RUnlock()
0000000000000000000000000000000000000000;;		item := ti.tree.Get(keyi)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return revision{}, revision{}, 0, ErrRevisionNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyi = item.(*keyIndex)
0000000000000000000000000000000000000000;;		return keyi.get(atRev)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ti *treeIndex) Range(key, end []byte, atRev int64) (keys [][]byte, revs []revision) {
0000000000000000000000000000000000000000;;		if end == nil {
0000000000000000000000000000000000000000;;			rev, _, _, err := ti.Get(key, atRev)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return [][]byte{key}, []revision{rev}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyi := &keyIndex{key: key}
0000000000000000000000000000000000000000;;		endi := &keyIndex{key: end}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti.RLock()
0000000000000000000000000000000000000000;;		defer ti.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti.tree.AscendGreaterOrEqual(keyi, func(item btree.Item) bool {
0000000000000000000000000000000000000000;;			if len(endi.key) > 0 && !item.Less(endi) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			curKeyi := item.(*keyIndex)
0000000000000000000000000000000000000000;;			rev, _, _, err := curKeyi.get(atRev)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			revs = append(revs, rev)
0000000000000000000000000000000000000000;;			keys = append(keys, curKeyi.key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return keys, revs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ti *treeIndex) Tombstone(key []byte, rev revision) error {
0000000000000000000000000000000000000000;;		keyi := &keyIndex{key: key}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti.Lock()
0000000000000000000000000000000000000000;;		defer ti.Unlock()
0000000000000000000000000000000000000000;;		item := ti.tree.Get(keyi)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return ErrRevisionNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ki := item.(*keyIndex)
0000000000000000000000000000000000000000;;		return ki.tombstone(rev.main, rev.sub)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeSince returns all revisions from key(including) to end(excluding)
0000000000000000000000000000000000000000;;	// at or after the given rev. The returned slice is sorted in the order
0000000000000000000000000000000000000000;;	// of revision.
0000000000000000000000000000000000000000;;	func (ti *treeIndex) RangeSince(key, end []byte, rev int64) []revision {
0000000000000000000000000000000000000000;;		ti.RLock()
0000000000000000000000000000000000000000;;		defer ti.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyi := &keyIndex{key: key}
0000000000000000000000000000000000000000;;		if end == nil {
0000000000000000000000000000000000000000;;			item := ti.tree.Get(keyi)
0000000000000000000000000000000000000000;;			if item == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyi = item.(*keyIndex)
0000000000000000000000000000000000000000;;			return keyi.since(rev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endi := &keyIndex{key: end}
0000000000000000000000000000000000000000;;		var revs []revision
0000000000000000000000000000000000000000;;		ti.tree.AscendGreaterOrEqual(keyi, func(item btree.Item) bool {
0000000000000000000000000000000000000000;;			if len(endi.key) > 0 && !item.Less(endi) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			curKeyi := item.(*keyIndex)
0000000000000000000000000000000000000000;;			revs = append(revs, curKeyi.since(rev)...)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		sort.Sort(revisions(revs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return revs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ti *treeIndex) Compact(rev int64) map[revision]struct{} {
0000000000000000000000000000000000000000;;		available := make(map[revision]struct{})
0000000000000000000000000000000000000000;;		var emptyki []*keyIndex
0000000000000000000000000000000000000000;;		plog.Printf("store.index: compact %d", rev)
0000000000000000000000000000000000000000;;		// TODO: do not hold the lock for long time?
0000000000000000000000000000000000000000;;		// This is probably OK. Compacting 10M keys takes O(10ms).
0000000000000000000000000000000000000000;;		ti.Lock()
0000000000000000000000000000000000000000;;		defer ti.Unlock()
0000000000000000000000000000000000000000;;		ti.tree.Ascend(compactIndex(rev, available, &emptyki))
0000000000000000000000000000000000000000;;		for _, ki := range emptyki {
0000000000000000000000000000000000000000;;			item := ti.tree.Delete(ki)
0000000000000000000000000000000000000000;;			if item == nil {
0000000000000000000000000000000000000000;;				plog.Panic("store.index: unexpected delete failure during compaction")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return available
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compactIndex(rev int64, available map[revision]struct{}, emptyki *[]*keyIndex) func(i btree.Item) bool {
0000000000000000000000000000000000000000;;		return func(i btree.Item) bool {
0000000000000000000000000000000000000000;;			keyi := i.(*keyIndex)
0000000000000000000000000000000000000000;;			keyi.compact(rev, available)
0000000000000000000000000000000000000000;;			if keyi.isEmpty() {
0000000000000000000000000000000000000000;;				*emptyki = append(*emptyki, keyi)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *treeIndex) Equal(bi index) bool {
0000000000000000000000000000000000000000;;		b := bi.(*treeIndex)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.tree.Len() != b.tree.Len() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		equal := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a.tree.Ascend(func(item btree.Item) bool {
0000000000000000000000000000000000000000;;			aki := item.(*keyIndex)
0000000000000000000000000000000000000000;;			bki := b.tree.Get(item).(*keyIndex)
0000000000000000000000000000000000000000;;			if !aki.equal(bki) {
0000000000000000000000000000000000000000;;				equal = false
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return equal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ti *treeIndex) Insert(ki *keyIndex) {
0000000000000000000000000000000000000000;;		ti.Lock()
0000000000000000000000000000000000000000;;		defer ti.Unlock()
0000000000000000000000000000000000000000;;		ti.tree.ReplaceOrInsert(ki)
0000000000000000000000000000000000000000;;	}
