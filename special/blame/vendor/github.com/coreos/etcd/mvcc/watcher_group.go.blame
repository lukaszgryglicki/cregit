0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/storage/watcher_group.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/watcher_group.go][vendor/github.com/coreos/etcd/mvcc/watcher_group.go];	
0000000000000000000000000000000000000000;;	package mvcc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/mvccpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/adt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// watchBatchMaxRevs is the maximum distinct revisions that
0000000000000000000000000000000000000000;;		// may be sent to an unsynced watcher at a time. Declared as
0000000000000000000000000000000000000000;;		// var instead of const for testing purposes.
0000000000000000000000000000000000000000;;		watchBatchMaxRevs = 1000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type eventBatch struct {
0000000000000000000000000000000000000000;;		// evs is a batch of revision-ordered events
0000000000000000000000000000000000000000;;		evs []mvccpb.Event
0000000000000000000000000000000000000000;;		// revs is the minimum unique revisions observed for this batch
0000000000000000000000000000000000000000;;		revs int
0000000000000000000000000000000000000000;;		// moreRev is first revision with more events following this batch
0000000000000000000000000000000000000000;;		moreRev int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (eb *eventBatch) add(ev mvccpb.Event) {
0000000000000000000000000000000000000000;;		if eb.revs > watchBatchMaxRevs {
0000000000000000000000000000000000000000;;			// maxed out batch size
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(eb.evs) == 0 {
0000000000000000000000000000000000000000;;			// base case
0000000000000000000000000000000000000000;;			eb.revs = 1
0000000000000000000000000000000000000000;;			eb.evs = append(eb.evs, ev)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// revision accounting
0000000000000000000000000000000000000000;;		ebRev := eb.evs[len(eb.evs)-1].Kv.ModRevision
0000000000000000000000000000000000000000;;		evRev := ev.Kv.ModRevision
0000000000000000000000000000000000000000;;		if evRev > ebRev {
0000000000000000000000000000000000000000;;			eb.revs++
0000000000000000000000000000000000000000;;			if eb.revs > watchBatchMaxRevs {
0000000000000000000000000000000000000000;;				eb.moreRev = evRev
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eb.evs = append(eb.evs, ev)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watcherBatch map[*watcher]*eventBatch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wb watcherBatch) add(w *watcher, ev mvccpb.Event) {
0000000000000000000000000000000000000000;;		eb := wb[w]
0000000000000000000000000000000000000000;;		if eb == nil {
0000000000000000000000000000000000000000;;			eb = &eventBatch{}
0000000000000000000000000000000000000000;;			wb[w] = eb
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eb.add(ev)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newWatcherBatch maps watchers to their matched events. It enables quick
0000000000000000000000000000000000000000;;	// events look up by watcher.
0000000000000000000000000000000000000000;;	func newWatcherBatch(wg *watcherGroup, evs []mvccpb.Event) watcherBatch {
0000000000000000000000000000000000000000;;		if len(wg.watchers) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wb := make(watcherBatch)
0000000000000000000000000000000000000000;;		for _, ev := range evs {
0000000000000000000000000000000000000000;;			for w := range wg.watcherSetByKey(string(ev.Kv.Key)) {
0000000000000000000000000000000000000000;;				if ev.Kv.ModRevision >= w.minRev {
0000000000000000000000000000000000000000;;					// don't double notify
0000000000000000000000000000000000000000;;					wb.add(w, ev)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wb
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watcherSet map[*watcher]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w watcherSet) add(wa *watcher) {
0000000000000000000000000000000000000000;;		if _, ok := w[wa]; ok {
0000000000000000000000000000000000000000;;			panic("add watcher twice!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w[wa] = struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w watcherSet) union(ws watcherSet) {
0000000000000000000000000000000000000000;;		for wa := range ws {
0000000000000000000000000000000000000000;;			w.add(wa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w watcherSet) delete(wa *watcher) {
0000000000000000000000000000000000000000;;		if _, ok := w[wa]; !ok {
0000000000000000000000000000000000000000;;			panic("removing missing watcher!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(w, wa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watcherSetByKey map[string]watcherSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w watcherSetByKey) add(wa *watcher) {
0000000000000000000000000000000000000000;;		set := w[string(wa.key)]
0000000000000000000000000000000000000000;;		if set == nil {
0000000000000000000000000000000000000000;;			set = make(watcherSet)
0000000000000000000000000000000000000000;;			w[string(wa.key)] = set
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		set.add(wa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w watcherSetByKey) delete(wa *watcher) bool {
0000000000000000000000000000000000000000;;		k := string(wa.key)
0000000000000000000000000000000000000000;;		if v, ok := w[k]; ok {
0000000000000000000000000000000000000000;;			if _, ok := v[wa]; ok {
0000000000000000000000000000000000000000;;				delete(v, wa)
0000000000000000000000000000000000000000;;				if len(v) == 0 {
0000000000000000000000000000000000000000;;					// remove the set; nothing left
0000000000000000000000000000000000000000;;					delete(w, k)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watcherGroup is a collection of watchers organized by their ranges
0000000000000000000000000000000000000000;;	type watcherGroup struct {
0000000000000000000000000000000000000000;;		// keyWatchers has the watchers that watch on a single key
0000000000000000000000000000000000000000;;		keyWatchers watcherSetByKey
0000000000000000000000000000000000000000;;		// ranges has the watchers that watch a range; it is sorted by interval
0000000000000000000000000000000000000000;;		ranges adt.IntervalTree
0000000000000000000000000000000000000000;;		// watchers is the set of all watchers
0000000000000000000000000000000000000000;;		watchers watcherSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newWatcherGroup() watcherGroup {
0000000000000000000000000000000000000000;;		return watcherGroup{
0000000000000000000000000000000000000000;;			keyWatchers: make(watcherSetByKey),
0000000000000000000000000000000000000000;;			watchers:    make(watcherSet),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// add puts a watcher in the group.
0000000000000000000000000000000000000000;;	func (wg *watcherGroup) add(wa *watcher) {
0000000000000000000000000000000000000000;;		wg.watchers.add(wa)
0000000000000000000000000000000000000000;;		if wa.end == nil {
0000000000000000000000000000000000000000;;			wg.keyWatchers.add(wa)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// interval already registered?
0000000000000000000000000000000000000000;;		ivl := adt.NewStringAffineInterval(string(wa.key), string(wa.end))
0000000000000000000000000000000000000000;;		if iv := wg.ranges.Find(ivl); iv != nil {
0000000000000000000000000000000000000000;;			iv.Val.(watcherSet).add(wa)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// not registered, put in interval tree
0000000000000000000000000000000000000000;;		ws := make(watcherSet)
0000000000000000000000000000000000000000;;		ws.add(wa)
0000000000000000000000000000000000000000;;		wg.ranges.Insert(ivl, ws)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contains is whether the given key has a watcher in the group.
0000000000000000000000000000000000000000;;	func (wg *watcherGroup) contains(key string) bool {
0000000000000000000000000000000000000000;;		_, ok := wg.keyWatchers[key]
0000000000000000000000000000000000000000;;		return ok || wg.ranges.Contains(adt.NewStringAffinePoint(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// size gives the number of unique watchers in the group.
0000000000000000000000000000000000000000;;	func (wg *watcherGroup) size() int { return len(wg.watchers) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delete removes a watcher from the group.
0000000000000000000000000000000000000000;;	func (wg *watcherGroup) delete(wa *watcher) bool {
0000000000000000000000000000000000000000;;		if _, ok := wg.watchers[wa]; !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.watchers.delete(wa)
0000000000000000000000000000000000000000;;		if wa.end == nil {
0000000000000000000000000000000000000000;;			wg.keyWatchers.delete(wa)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ivl := adt.NewStringAffineInterval(string(wa.key), string(wa.end))
0000000000000000000000000000000000000000;;		iv := wg.ranges.Find(ivl)
0000000000000000000000000000000000000000;;		if iv == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws := iv.Val.(watcherSet)
0000000000000000000000000000000000000000;;		delete(ws, wa)
0000000000000000000000000000000000000000;;		if len(ws) == 0 {
0000000000000000000000000000000000000000;;			// remove interval missing watchers
0000000000000000000000000000000000000000;;			if ok := wg.ranges.Delete(ivl); !ok {
0000000000000000000000000000000000000000;;				panic("could not remove watcher from interval tree")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// choose selects watchers from the watcher group to update
0000000000000000000000000000000000000000;;	func (wg *watcherGroup) choose(maxWatchers int, curRev, compactRev int64) (*watcherGroup, int64) {
0000000000000000000000000000000000000000;;		if len(wg.watchers) < maxWatchers {
0000000000000000000000000000000000000000;;			return wg, wg.chooseAll(curRev, compactRev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := newWatcherGroup()
0000000000000000000000000000000000000000;;		for w := range wg.watchers {
0000000000000000000000000000000000000000;;			if maxWatchers <= 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			maxWatchers--
0000000000000000000000000000000000000000;;			ret.add(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ret, ret.chooseAll(curRev, compactRev)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wg *watcherGroup) chooseAll(curRev, compactRev int64) int64 {
0000000000000000000000000000000000000000;;		minRev := int64(math.MaxInt64)
0000000000000000000000000000000000000000;;		for w := range wg.watchers {
0000000000000000000000000000000000000000;;			if w.minRev > curRev {
0000000000000000000000000000000000000000;;				panic("watcher current revision should not exceed current revision")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if w.minRev < compactRev {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case w.ch <- WatchResponse{WatchID: w.id, CompactRevision: compactRev}:
0000000000000000000000000000000000000000;;					w.compacted = true
0000000000000000000000000000000000000000;;					wg.delete(w)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// retry next time
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if minRev > w.minRev {
0000000000000000000000000000000000000000;;				minRev = w.minRev
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return minRev
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watcherSetByKey gets the set of watchers that receive events on the given key.
0000000000000000000000000000000000000000;;	func (wg *watcherGroup) watcherSetByKey(key string) watcherSet {
0000000000000000000000000000000000000000;;		wkeys := wg.keyWatchers[key]
0000000000000000000000000000000000000000;;		wranges := wg.ranges.Stab(adt.NewStringAffinePoint(key))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// zero-copy cases
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(wranges) == 0:
0000000000000000000000000000000000000000;;			// no need to merge ranges or copy; reuse single-key set
0000000000000000000000000000000000000000;;			return wkeys
0000000000000000000000000000000000000000;;		case len(wranges) == 0 && len(wkeys) == 0:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case len(wranges) == 1 && len(wkeys) == 0:
0000000000000000000000000000000000000000;;			return wranges[0].Val.(watcherSet)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copy case
0000000000000000000000000000000000000000;;		ret := make(watcherSet)
0000000000000000000000000000000000000000;;		ret.union(wg.keyWatchers[key])
0000000000000000000000000000000000000000;;		for _, item := range wranges {
0000000000000000000000000000000000000000;;			ret.union(item.Val.(watcherSet))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
