0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/storage/kvstore.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/kvstore.go][vendor/github.com/coreos/etcd/mvcc/kvstore.go];	
0000000000000000000000000000000000000000;;	package mvcc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/lease"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/mvccpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/schedule"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		keyBucketName  = []byte("key")
0000000000000000000000000000000000000000;;		metaBucketName = []byte("meta")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// markedRevBytesLen is the byte length of marked revision.
0000000000000000000000000000000000000000;;		// The first `revBytesLen` bytes represents a normal revision. The last
0000000000000000000000000000000000000000;;		// one byte is the mark.
0000000000000000000000000000000000000000;;		markedRevBytesLen      = revBytesLen + 1
0000000000000000000000000000000000000000;;		markBytePosition       = markedRevBytesLen - 1
0000000000000000000000000000000000000000;;		markTombstone     byte = 't'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		consistentIndexKeyName  = []byte("consistent_index")
0000000000000000000000000000000000000000;;		scheduledCompactKeyName = []byte("scheduledCompactRev")
0000000000000000000000000000000000000000;;		finishedCompactKeyName  = []byte("finishedCompactRev")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrTxnIDMismatch = errors.New("mvcc: txn id mismatch")
0000000000000000000000000000000000000000;;		ErrCompacted     = errors.New("mvcc: required revision has been compacted")
0000000000000000000000000000000000000000;;		ErrFutureRev     = errors.New("mvcc: required revision is a future revision")
0000000000000000000000000000000000000000;;		ErrCanceled      = errors.New("mvcc: watcher is canceled")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "mvcc")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConsistentIndexGetter is an interface that wraps the Get method.
0000000000000000000000000000000000000000;;	// Consistent index is the offset of an entry in a consistent replicated log.
0000000000000000000000000000000000000000;;	type ConsistentIndexGetter interface {
0000000000000000000000000000000000000000;;		// ConsistentIndex returns the consistent index of current executing entry.
0000000000000000000000000000000000000000;;		ConsistentIndex() uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type store struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex // guards the following
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ig ConsistentIndexGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b       backend.Backend
0000000000000000000000000000000000000000;;		kvindex index
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le lease.Lessor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentRev revision
0000000000000000000000000000000000000000;;		// the main revision of the last compaction
0000000000000000000000000000000000000000;;		compactMainRev int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx        backend.BatchTx
0000000000000000000000000000000000000000;;		txnID     int64 // tracks the current txnID to verify txn operations
0000000000000000000000000000000000000000;;		txnModify bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// bytesBuf8 is a byte slice of length 8
0000000000000000000000000000000000000000;;		// to avoid a repetitive allocation in saveIndex.
0000000000000000000000000000000000000000;;		bytesBuf8 []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		changes   []mvccpb.KeyValue
0000000000000000000000000000000000000000;;		fifoSched schedule.Scheduler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopc chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStore returns a new store. It is useful to create a store inside
0000000000000000000000000000000000000000;;	// mvcc pkg. It should only be used for testing externally.
0000000000000000000000000000000000000000;;	func NewStore(b backend.Backend, le lease.Lessor, ig ConsistentIndexGetter) *store {
0000000000000000000000000000000000000000;;		s := &store{
0000000000000000000000000000000000000000;;			b:       b,
0000000000000000000000000000000000000000;;			ig:      ig,
0000000000000000000000000000000000000000;;			kvindex: newTreeIndex(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			le: le,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			currentRev:     revision{main: 1},
0000000000000000000000000000000000000000;;			compactMainRev: -1,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			bytesBuf8: make([]byte, 8, 8),
0000000000000000000000000000000000000000;;			fifoSched: schedule.NewFIFOScheduler(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stopc: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.le != nil {
0000000000000000000000000000000000000000;;			s.le.SetRangeDeleter(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := s.b.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(keyBucketName)
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(metaBucketName)
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;		s.b.ForceCommit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.restore(); err != nil {
0000000000000000000000000000000000000000;;			// TODO: return the error instead of panic here?
0000000000000000000000000000000000000000;;			panic("failed to recover store from backend")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Rev() int64 {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.currentRev.main
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) FirstRev() int64 {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.compactMainRev
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Put(key, value []byte, lease lease.LeaseID) int64 {
0000000000000000000000000000000000000000;;		id := s.TxnBegin()
0000000000000000000000000000000000000000;;		s.put(key, value, lease)
0000000000000000000000000000000000000000;;		s.txnEnd(id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		putCounter.Inc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return int64(s.currentRev.main)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Range(key, end []byte, ro RangeOptions) (r *RangeResult, err error) {
0000000000000000000000000000000000000000;;		id := s.TxnBegin()
0000000000000000000000000000000000000000;;		kvs, count, rev, err := s.rangeKeys(key, end, ro.Limit, ro.Rev, ro.Count)
0000000000000000000000000000000000000000;;		s.txnEnd(id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rangeCounter.Inc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r = &RangeResult{
0000000000000000000000000000000000000000;;			KVs:   kvs,
0000000000000000000000000000000000000000;;			Count: count,
0000000000000000000000000000000000000000;;			Rev:   rev,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) DeleteRange(key, end []byte) (n, rev int64) {
0000000000000000000000000000000000000000;;		id := s.TxnBegin()
0000000000000000000000000000000000000000;;		n = s.deleteRange(key, end)
0000000000000000000000000000000000000000;;		s.txnEnd(id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleteCounter.Inc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, int64(s.currentRev.main)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) TxnBegin() int64 {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		s.currentRev.sub = 0
0000000000000000000000000000000000000000;;		s.tx = s.b.BatchTx()
0000000000000000000000000000000000000000;;		s.tx.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.txnID = rand.Int63()
0000000000000000000000000000000000000000;;		return s.txnID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) TxnEnd(txnID int64) error {
0000000000000000000000000000000000000000;;		err := s.txnEnd(txnID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		txnCounter.Inc()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// txnEnd is used for unlocking an internal txn. It does
0000000000000000000000000000000000000000;;	// not increase the txnCounter.
0000000000000000000000000000000000000000;;	func (s *store) txnEnd(txnID int64) error {
0000000000000000000000000000000000000000;;		if txnID != s.txnID {
0000000000000000000000000000000000000000;;			return ErrTxnIDMismatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only update index if the txn modifies the mvcc state.
0000000000000000000000000000000000000000;;		// read only txn might execute with one write txn concurrently,
0000000000000000000000000000000000000000;;		// it should not write its index to mvcc.
0000000000000000000000000000000000000000;;		if s.txnModify {
0000000000000000000000000000000000000000;;			s.saveIndex()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.txnModify = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.tx.Unlock()
0000000000000000000000000000000000000000;;		if s.currentRev.sub != 0 {
0000000000000000000000000000000000000000;;			s.currentRev.main += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.currentRev.sub = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dbTotalSize.Set(float64(s.b.Size()))
0000000000000000000000000000000000000000;;		s.mu.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) TxnRange(txnID int64, key, end []byte, ro RangeOptions) (r *RangeResult, err error) {
0000000000000000000000000000000000000000;;		if txnID != s.txnID {
0000000000000000000000000000000000000000;;			return nil, ErrTxnIDMismatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kvs, count, rev, err := s.rangeKeys(key, end, ro.Limit, ro.Rev, ro.Count)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r = &RangeResult{
0000000000000000000000000000000000000000;;			KVs:   kvs,
0000000000000000000000000000000000000000;;			Count: count,
0000000000000000000000000000000000000000;;			Rev:   rev,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) TxnPut(txnID int64, key, value []byte, lease lease.LeaseID) (rev int64, err error) {
0000000000000000000000000000000000000000;;		if txnID != s.txnID {
0000000000000000000000000000000000000000;;			return 0, ErrTxnIDMismatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.put(key, value, lease)
0000000000000000000000000000000000000000;;		return int64(s.currentRev.main + 1), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) TxnDeleteRange(txnID int64, key, end []byte) (n, rev int64, err error) {
0000000000000000000000000000000000000000;;		if txnID != s.txnID {
0000000000000000000000000000000000000000;;			return 0, 0, ErrTxnIDMismatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n = s.deleteRange(key, end)
0000000000000000000000000000000000000000;;		if n != 0 || s.currentRev.sub != 0 {
0000000000000000000000000000000000000000;;			rev = int64(s.currentRev.main + 1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rev = int64(s.currentRev.main)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, rev, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) compactBarrier(ctx context.Context, ch chan struct{}) {
0000000000000000000000000000000000000000;;		if ctx == nil || ctx.Err() != nil {
0000000000000000000000000000000000000000;;			s.mu.Lock()
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-s.stopc:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				f := func(ctx context.Context) { s.compactBarrier(ctx, ch) }
0000000000000000000000000000000000000000;;				s.fifoSched.Schedule(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Compact(rev int64) (<-chan struct{}, error) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if rev <= s.compactMainRev {
0000000000000000000000000000000000000000;;			ch := make(chan struct{})
0000000000000000000000000000000000000000;;			f := func(ctx context.Context) { s.compactBarrier(ctx, ch) }
0000000000000000000000000000000000000000;;			s.fifoSched.Schedule(f)
0000000000000000000000000000000000000000;;			return ch, ErrCompacted
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rev > s.currentRev.main {
0000000000000000000000000000000000000000;;			return nil, ErrFutureRev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.compactMainRev = rev
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rbytes := newRevBytes()
0000000000000000000000000000000000000000;;		revToBytes(revision{main: rev}, rbytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := s.b.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		tx.UnsafePut(metaBucketName, scheduledCompactKeyName, rbytes)
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;		// ensure that desired compaction is persisted
0000000000000000000000000000000000000000;;		s.b.ForceCommit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keep := s.kvindex.Compact(rev)
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		var j = func(ctx context.Context) {
0000000000000000000000000000000000000000;;			if ctx.Err() != nil {
0000000000000000000000000000000000000000;;				s.compactBarrier(ctx, ch)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !s.scheduleCompaction(rev, keep) {
0000000000000000000000000000000000000000;;				s.compactBarrier(nil, ch)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.fifoSched.Schedule(j)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indexCompactionPauseDurations.Observe(float64(time.Since(start) / time.Millisecond))
0000000000000000000000000000000000000000;;		return ch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultIgnores is a map of keys to ignore in hash checking.
0000000000000000000000000000000000000000;;	var DefaultIgnores map[backend.IgnoreKey]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		DefaultIgnores = map[backend.IgnoreKey]struct{}{
0000000000000000000000000000000000000000;;			// consistent index might be changed due to v2 internal sync, which
0000000000000000000000000000000000000000;;			// is not controllable by the user.
0000000000000000000000000000000000000000;;			{Bucket: string(metaBucketName), Key: string(consistentIndexKeyName)}: {},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Hash() (uint32, int64, error) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		s.b.ForceCommit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h, err := s.b.Hash(DefaultIgnores)
0000000000000000000000000000000000000000;;		rev := s.currentRev.main
0000000000000000000000000000000000000000;;		return h, rev, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Commit() {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.tx = s.b.BatchTx()
0000000000000000000000000000000000000000;;		s.tx.Lock()
0000000000000000000000000000000000000000;;		s.saveIndex()
0000000000000000000000000000000000000000;;		s.tx.Unlock()
0000000000000000000000000000000000000000;;		s.b.ForceCommit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Restore(b backend.Backend) error {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(s.stopc)
0000000000000000000000000000000000000000;;		s.fifoSched.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.b = b
0000000000000000000000000000000000000000;;		s.kvindex = newTreeIndex()
0000000000000000000000000000000000000000;;		s.currentRev = revision{main: 1}
0000000000000000000000000000000000000000;;		s.compactMainRev = -1
0000000000000000000000000000000000000000;;		s.tx = b.BatchTx()
0000000000000000000000000000000000000000;;		s.txnID = -1
0000000000000000000000000000000000000000;;		s.fifoSched = schedule.NewFIFOScheduler()
0000000000000000000000000000000000000000;;		s.stopc = make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.restore()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) restore() error {
0000000000000000000000000000000000000000;;		min, max := newRevBytes(), newRevBytes()
0000000000000000000000000000000000000000;;		revToBytes(revision{main: 1}, min)
0000000000000000000000000000000000000000;;		revToBytes(revision{main: math.MaxInt64, sub: math.MaxInt64}, max)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyToLease := make(map[string]lease.LeaseID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// use an unordered map to hold the temp index data to speed up
0000000000000000000000000000000000000000;;		// the initial key index recovery.
0000000000000000000000000000000000000000;;		// we will convert this unordered map into the tree index later.
0000000000000000000000000000000000000000;;		unordered := make(map[string]*keyIndex, 100000)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// restore index
0000000000000000000000000000000000000000;;		tx := s.b.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		_, finishedCompactBytes := tx.UnsafeRange(metaBucketName, finishedCompactKeyName, nil, 0)
0000000000000000000000000000000000000000;;		if len(finishedCompactBytes) != 0 {
0000000000000000000000000000000000000000;;			s.compactMainRev = bytesToRev(finishedCompactBytes[0]).main
0000000000000000000000000000000000000000;;			plog.Printf("restore compact to %d", s.compactMainRev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: limit N to reduce max memory usage
0000000000000000000000000000000000000000;;		keys, vals := tx.UnsafeRange(keyBucketName, min, max, 0)
0000000000000000000000000000000000000000;;		for i, key := range keys {
0000000000000000000000000000000000000000;;			var kv mvccpb.KeyValue
0000000000000000000000000000000000000000;;			if err := kv.Unmarshal(vals[i]); err != nil {
0000000000000000000000000000000000000000;;				plog.Fatalf("cannot unmarshal event: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rev := bytesToRev(key[:revBytesLen])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// restore index
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case isTombstone(key):
0000000000000000000000000000000000000000;;				if ki, ok := unordered[string(kv.Key)]; ok {
0000000000000000000000000000000000000000;;					ki.tombstone(rev.main, rev.sub)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(keyToLease, string(kv.Key))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				ki, ok := unordered[string(kv.Key)]
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					ki.put(rev.main, rev.sub)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ki = &keyIndex{key: kv.Key}
0000000000000000000000000000000000000000;;					ki.restore(revision{kv.CreateRevision, 0}, rev, kv.Version)
0000000000000000000000000000000000000000;;					unordered[string(kv.Key)] = ki
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if lid := lease.LeaseID(kv.Lease); lid != lease.NoLease {
0000000000000000000000000000000000000000;;					keyToLease[string(kv.Key)] = lid
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					delete(keyToLease, string(kv.Key))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// update revision
0000000000000000000000000000000000000000;;			s.currentRev = rev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// restore the tree index from the unordered index.
0000000000000000000000000000000000000000;;		for _, v := range unordered {
0000000000000000000000000000000000000000;;			s.kvindex.Insert(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keys in the range [compacted revision -N, compaction] might all be deleted due to compaction.
0000000000000000000000000000000000000000;;		// the correct revision should be set to compaction revision in the case, not the largest revision
0000000000000000000000000000000000000000;;		// we have seen.
0000000000000000000000000000000000000000;;		if s.currentRev.main < s.compactMainRev {
0000000000000000000000000000000000000000;;			s.currentRev.main = s.compactMainRev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, lid := range keyToLease {
0000000000000000000000000000000000000000;;			if s.le == nil {
0000000000000000000000000000000000000000;;				panic("no lessor to attach lease")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := s.le.Attach(lid, []lease.LeaseItem{{Key: key}})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("unexpected Attach error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, scheduledCompactBytes := tx.UnsafeRange(metaBucketName, scheduledCompactKeyName, nil, 0)
0000000000000000000000000000000000000000;;		scheduledCompact := int64(0)
0000000000000000000000000000000000000000;;		if len(scheduledCompactBytes) != 0 {
0000000000000000000000000000000000000000;;			scheduledCompact = bytesToRev(scheduledCompactBytes[0]).main
0000000000000000000000000000000000000000;;			if scheduledCompact <= s.compactMainRev {
0000000000000000000000000000000000000000;;				scheduledCompact = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if scheduledCompact != 0 {
0000000000000000000000000000000000000000;;			s.Compact(scheduledCompact)
0000000000000000000000000000000000000000;;			plog.Printf("resume scheduled compaction at %d", scheduledCompact)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Close() error {
0000000000000000000000000000000000000000;;		close(s.stopc)
0000000000000000000000000000000000000000;;		s.fifoSched.Stop()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *store) Equal(b *store) bool {
0000000000000000000000000000000000000000;;		if a.currentRev != b.currentRev {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.compactMainRev != b.compactMainRev {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.kvindex.Equal(b.kvindex)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// range is a keyword in Go, add Keys suffix.
0000000000000000000000000000000000000000;;	func (s *store) rangeKeys(key, end []byte, limit, rangeRev int64, countOnly bool) (kvs []mvccpb.KeyValue, count int, curRev int64, err error) {
0000000000000000000000000000000000000000;;		curRev = int64(s.currentRev.main)
0000000000000000000000000000000000000000;;		if s.currentRev.sub > 0 {
0000000000000000000000000000000000000000;;			curRev += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rangeRev > curRev {
0000000000000000000000000000000000000000;;			return nil, -1, s.currentRev.main, ErrFutureRev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var rev int64
0000000000000000000000000000000000000000;;		if rangeRev <= 0 {
0000000000000000000000000000000000000000;;			rev = curRev
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rev = rangeRev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rev < s.compactMainRev {
0000000000000000000000000000000000000000;;			return nil, -1, 0, ErrCompacted
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, revpairs := s.kvindex.Range(key, end, int64(rev))
0000000000000000000000000000000000000000;;		if len(revpairs) == 0 {
0000000000000000000000000000000000000000;;			return nil, 0, curRev, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if countOnly {
0000000000000000000000000000000000000000;;			return nil, len(revpairs), curRev, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, revpair := range revpairs {
0000000000000000000000000000000000000000;;			start, end := revBytesRange(revpair)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, vs := s.tx.UnsafeRange(keyBucketName, start, end, 0)
0000000000000000000000000000000000000000;;			if len(vs) != 1 {
0000000000000000000000000000000000000000;;				plog.Fatalf("range cannot find rev (%d,%d)", revpair.main, revpair.sub)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var kv mvccpb.KeyValue
0000000000000000000000000000000000000000;;			if err := kv.Unmarshal(vs[0]); err != nil {
0000000000000000000000000000000000000000;;				plog.Fatalf("cannot unmarshal event: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kvs = append(kvs, kv)
0000000000000000000000000000000000000000;;			if limit > 0 && len(kvs) >= int(limit) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kvs, len(revpairs), curRev, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) put(key, value []byte, leaseID lease.LeaseID) {
0000000000000000000000000000000000000000;;		s.txnModify = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rev := s.currentRev.main + 1
0000000000000000000000000000000000000000;;		c := rev
0000000000000000000000000000000000000000;;		oldLease := lease.NoLease
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the key exists before, use its previous created and
0000000000000000000000000000000000000000;;		// get its previous leaseID
0000000000000000000000000000000000000000;;		_, created, ver, err := s.kvindex.Get(key, rev)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			c = created.main
0000000000000000000000000000000000000000;;			oldLease = s.le.GetLease(lease.LeaseItem{Key: string(key)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ibytes := newRevBytes()
0000000000000000000000000000000000000000;;		revToBytes(revision{main: rev, sub: s.currentRev.sub}, ibytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ver = ver + 1
0000000000000000000000000000000000000000;;		kv := mvccpb.KeyValue{
0000000000000000000000000000000000000000;;			Key:            key,
0000000000000000000000000000000000000000;;			Value:          value,
0000000000000000000000000000000000000000;;			CreateRevision: c,
0000000000000000000000000000000000000000;;			ModRevision:    rev,
0000000000000000000000000000000000000000;;			Version:        ver,
0000000000000000000000000000000000000000;;			Lease:          int64(leaseID),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d, err := kv.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot marshal event: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.tx.UnsafeSeqPut(keyBucketName, ibytes, d)
0000000000000000000000000000000000000000;;		s.kvindex.Put(key, revision{main: rev, sub: s.currentRev.sub})
0000000000000000000000000000000000000000;;		s.changes = append(s.changes, kv)
0000000000000000000000000000000000000000;;		s.currentRev.sub += 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldLease != lease.NoLease {
0000000000000000000000000000000000000000;;			if s.le == nil {
0000000000000000000000000000000000000000;;				panic("no lessor to detach lease")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = s.le.Detach(oldLease, []lease.LeaseItem{{Key: string(key)}})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("unexpected error from lease detach: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if leaseID != lease.NoLease {
0000000000000000000000000000000000000000;;			if s.le == nil {
0000000000000000000000000000000000000000;;				panic("no lessor to attach lease")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = s.le.Attach(leaseID, []lease.LeaseItem{{Key: string(key)}})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic("unexpected error from lease Attach")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) deleteRange(key, end []byte) int64 {
0000000000000000000000000000000000000000;;		s.txnModify = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rrev := s.currentRev.main
0000000000000000000000000000000000000000;;		if s.currentRev.sub > 0 {
0000000000000000000000000000000000000000;;			rrev += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keys, revs := s.kvindex.Range(key, end, rrev)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(keys) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, key := range keys {
0000000000000000000000000000000000000000;;			s.delete(key, revs[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(len(keys))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) delete(key []byte, rev revision) {
0000000000000000000000000000000000000000;;		mainrev := s.currentRev.main + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ibytes := newRevBytes()
0000000000000000000000000000000000000000;;		revToBytes(revision{main: mainrev, sub: s.currentRev.sub}, ibytes)
0000000000000000000000000000000000000000;;		ibytes = appendMarkTombstone(ibytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kv := mvccpb.KeyValue{
0000000000000000000000000000000000000000;;			Key: key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d, err := kv.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot marshal event: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.tx.UnsafeSeqPut(keyBucketName, ibytes, d)
0000000000000000000000000000000000000000;;		err = s.kvindex.Tombstone(key, revision{main: mainrev, sub: s.currentRev.sub})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot tombstone an existing key (%s): %v", string(key), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.changes = append(s.changes, kv)
0000000000000000000000000000000000000000;;		s.currentRev.sub += 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		item := lease.LeaseItem{Key: string(key)}
0000000000000000000000000000000000000000;;		leaseID := s.le.GetLease(item)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if leaseID != lease.NoLease {
0000000000000000000000000000000000000000;;			err = s.le.Detach(leaseID, []lease.LeaseItem{item})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("cannot detach %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) getChanges() []mvccpb.KeyValue {
0000000000000000000000000000000000000000;;		changes := s.changes
0000000000000000000000000000000000000000;;		s.changes = make([]mvccpb.KeyValue, 0, 4)
0000000000000000000000000000000000000000;;		return changes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) saveIndex() {
0000000000000000000000000000000000000000;;		if s.ig == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx := s.tx
0000000000000000000000000000000000000000;;		bs := s.bytesBuf8
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(bs, s.ig.ConsistentIndex())
0000000000000000000000000000000000000000;;		// put the index into the underlying backend
0000000000000000000000000000000000000000;;		// tx has been locked in TxnBegin, so there is no need to lock it again
0000000000000000000000000000000000000000;;		tx.UnsafePut(metaBucketName, consistentIndexKeyName, bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) ConsistentIndex() uint64 {
0000000000000000000000000000000000000000;;		// TODO: cache index in a uint64 field?
0000000000000000000000000000000000000000;;		tx := s.b.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(metaBucketName, consistentIndexKeyName, nil, 0)
0000000000000000000000000000000000000000;;		if len(vs) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return binary.BigEndian.Uint64(vs[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendMarkTombstone appends tombstone mark to normal revision bytes.
0000000000000000000000000000000000000000;;	func appendMarkTombstone(b []byte) []byte {
0000000000000000000000000000000000000000;;		if len(b) != revBytesLen {
0000000000000000000000000000000000000000;;			plog.Panicf("cannot append mark to non normal revision bytes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(b, markTombstone)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTombstone checks whether the revision bytes is a tombstone.
0000000000000000000000000000000000000000;;	func isTombstone(b []byte) bool {
0000000000000000000000000000000000000000;;		return len(b) == markedRevBytesLen && b[markBytePosition] == markTombstone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// revBytesRange returns the range of revision bytes at
0000000000000000000000000000000000000000;;	// the given revision.
0000000000000000000000000000000000000000;;	func revBytesRange(rev revision) (start, end []byte) {
0000000000000000000000000000000000000000;;		start = newRevBytes()
0000000000000000000000000000000000000000;;		revToBytes(rev, start)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end = newRevBytes()
0000000000000000000000000000000000000000;;		endRev := revision{main: rev.main, sub: rev.sub + 1}
0000000000000000000000000000000000000000;;		revToBytes(endRev, end)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return start, end
0000000000000000000000000000000000000000;;	}
