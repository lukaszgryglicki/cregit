0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/storage/backend/backend.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/backend/backend.go][vendor/github.com/coreos/etcd/mvcc/backend/backend.go];	
0000000000000000000000000000000000000000;;	package backend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/crc32"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/boltdb/bolt"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultBatchLimit    = 10000
0000000000000000000000000000000000000000;;		defaultBatchInterval = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defragLimit = 10000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InitialMmapSize is the initial size of the mmapped region. Setting this larger than
0000000000000000000000000000000000000000;;		// the potential max db size can prevent writer from blocking reader.
0000000000000000000000000000000000000000;;		// This only works for linux.
0000000000000000000000000000000000000000;;		InitialMmapSize = int64(10 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "mvcc/backend")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultQuotaBytes is the number of bytes the backend Size may
0000000000000000000000000000000000000000;;		// consume before exceeding the space quota.
0000000000000000000000000000000000000000;;		DefaultQuotaBytes = int64(2 * 1024 * 1024 * 1024) // 2GB
0000000000000000000000000000000000000000;;		// MaxQuotaBytes is the maximum number of bytes suggested for a backend
0000000000000000000000000000000000000000;;		// quota. A larger quota may lead to degraded performance.
0000000000000000000000000000000000000000;;		MaxQuotaBytes = int64(8 * 1024 * 1024 * 1024) // 8GB
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Backend interface {
0000000000000000000000000000000000000000;;		BatchTx() BatchTx
0000000000000000000000000000000000000000;;		Snapshot() Snapshot
0000000000000000000000000000000000000000;;		Hash(ignores map[IgnoreKey]struct{}) (uint32, error)
0000000000000000000000000000000000000000;;		// Size returns the current size of the backend.
0000000000000000000000000000000000000000;;		Size() int64
0000000000000000000000000000000000000000;;		Defrag() error
0000000000000000000000000000000000000000;;		ForceCommit()
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Snapshot interface {
0000000000000000000000000000000000000000;;		// Size gets the size of the snapshot.
0000000000000000000000000000000000000000;;		Size() int64
0000000000000000000000000000000000000000;;		// WriteTo writes the snapshot into the given writer.
0000000000000000000000000000000000000000;;		WriteTo(w io.Writer) (n int64, err error)
0000000000000000000000000000000000000000;;		// Close closes the snapshot.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type backend struct {
0000000000000000000000000000000000000000;;		// size and commits are used with atomic operations so they must be
0000000000000000000000000000000000000000;;		// 64-bit aligned, otherwise 32-bit tests will crash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// size is the number of bytes in the backend
0000000000000000000000000000000000000000;;		size int64
0000000000000000000000000000000000000000;;		// commits counts number of commits since start
0000000000000000000000000000000000000000;;		commits int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.RWMutex
0000000000000000000000000000000000000000;;		db *bolt.DB
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchInterval time.Duration
0000000000000000000000000000000000000000;;		batchLimit    int
0000000000000000000000000000000000000000;;		batchTx       *batchTx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopc chan struct{}
0000000000000000000000000000000000000000;;		donec chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(path string, d time.Duration, limit int) Backend {
0000000000000000000000000000000000000000;;		return newBackend(path, d, limit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefaultBackend(path string) Backend {
0000000000000000000000000000000000000000;;		return newBackend(path, defaultBatchInterval, defaultBatchLimit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBackend(path string, d time.Duration, limit int) *backend {
0000000000000000000000000000000000000000;;		db, err := bolt.Open(path, 0600, boltOpenOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("cannot open database at %s (%v)", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := &backend{
0000000000000000000000000000000000000000;;			db: db,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			batchInterval: d,
0000000000000000000000000000000000000000;;			batchLimit:    limit,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stopc: make(chan struct{}),
0000000000000000000000000000000000000000;;			donec: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.batchTx = newBatchTx(b)
0000000000000000000000000000000000000000;;		go b.run()
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BatchTx returns the current batch tx in coalescer. The tx can be used for read and
0000000000000000000000000000000000000000;;	// write operations. The write result can be retrieved within the same tx immediately.
0000000000000000000000000000000000000000;;	// The write result is isolated with other txs until the current one get committed.
0000000000000000000000000000000000000000;;	func (b *backend) BatchTx() BatchTx {
0000000000000000000000000000000000000000;;		return b.batchTx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForceCommit forces the current batching tx to commit.
0000000000000000000000000000000000000000;;	func (b *backend) ForceCommit() {
0000000000000000000000000000000000000000;;		b.batchTx.Commit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backend) Snapshot() Snapshot {
0000000000000000000000000000000000000000;;		b.batchTx.Commit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.mu.RLock()
0000000000000000000000000000000000000000;;		defer b.mu.RUnlock()
0000000000000000000000000000000000000000;;		tx, err := b.db.Begin(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot begin tx (%s)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &snapshot{tx}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IgnoreKey struct {
0000000000000000000000000000000000000000;;		Bucket string
0000000000000000000000000000000000000000;;		Key    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backend) Hash(ignores map[IgnoreKey]struct{}) (uint32, error) {
0000000000000000000000000000000000000000;;		h := crc32.New(crc32.MakeTable(crc32.Castagnoli))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.mu.RLock()
0000000000000000000000000000000000000000;;		defer b.mu.RUnlock()
0000000000000000000000000000000000000000;;		err := b.db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;			c := tx.Cursor()
0000000000000000000000000000000000000000;;			for next, _ := c.First(); next != nil; next, _ = c.Next() {
0000000000000000000000000000000000000000;;				b := tx.Bucket(next)
0000000000000000000000000000000000000000;;				if b == nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("cannot get hash of bucket %s", string(next))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				h.Write(next)
0000000000000000000000000000000000000000;;				b.ForEach(func(k, v []byte) error {
0000000000000000000000000000000000000000;;					bk := IgnoreKey{Bucket: string(next), Key: string(k)}
0000000000000000000000000000000000000000;;					if _, ok := ignores[bk]; !ok {
0000000000000000000000000000000000000000;;						h.Write(k)
0000000000000000000000000000000000000000;;						h.Write(v)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return h.Sum32(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backend) Size() int64 {
0000000000000000000000000000000000000000;;		return atomic.LoadInt64(&b.size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backend) run() {
0000000000000000000000000000000000000000;;		defer close(b.donec)
0000000000000000000000000000000000000000;;		t := time.NewTimer(b.batchInterval)
0000000000000000000000000000000000000000;;		defer t.Stop()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-t.C:
0000000000000000000000000000000000000000;;			case <-b.stopc:
0000000000000000000000000000000000000000;;				b.batchTx.CommitAndStop()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.batchTx.Commit()
0000000000000000000000000000000000000000;;			t.Reset(b.batchInterval)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backend) Close() error {
0000000000000000000000000000000000000000;;		close(b.stopc)
0000000000000000000000000000000000000000;;		<-b.donec
0000000000000000000000000000000000000000;;		return b.db.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Commits returns total number of commits since start
0000000000000000000000000000000000000000;;	func (b *backend) Commits() int64 {
0000000000000000000000000000000000000000;;		return atomic.LoadInt64(&b.commits)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backend) Defrag() error {
0000000000000000000000000000000000000000;;		err := b.defrag()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// commit to update metadata like db.size
0000000000000000000000000000000000000000;;		b.batchTx.Commit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backend) defrag() error {
0000000000000000000000000000000000000000;;		// TODO: make this non-blocking?
0000000000000000000000000000000000000000;;		// lock batchTx to ensure nobody is using previous tx, and then
0000000000000000000000000000000000000000;;		// close previous ongoing tx.
0000000000000000000000000000000000000000;;		b.batchTx.Lock()
0000000000000000000000000000000000000000;;		defer b.batchTx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lock database after lock tx to avoid deadlock.
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.batchTx.commit(true)
0000000000000000000000000000000000000000;;		b.batchTx.tx = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmpdb, err := bolt.Open(b.db.Path()+".tmp", 0600, boltOpenOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = defragdb(b.db, tmpdb, defragLimit)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			tmpdb.Close()
0000000000000000000000000000000000000000;;			os.RemoveAll(tmpdb.Path())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dbp := b.db.Path()
0000000000000000000000000000000000000000;;		tdbp := tmpdb.Path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = b.db.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot close database (%s)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = tmpdb.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot close database (%s)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = os.Rename(tdbp, dbp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot rename database (%s)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.db, err = bolt.Open(dbp, 0600, boltOpenOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("cannot open database at %s (%v)", dbp, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.batchTx.tx, err = b.db.Begin(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot begin tx (%s)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defragdb(odb, tmpdb *bolt.DB, limit int) error {
0000000000000000000000000000000000000000;;		// open a tx on tmpdb for writes
0000000000000000000000000000000000000000;;		tmptx, err := tmpdb.Begin(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// open a tx on old db for read
0000000000000000000000000000000000000000;;		tx, err := odb.Begin(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer tx.Rollback()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := tx.Cursor()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for next, _ := c.First(); next != nil; next, _ = c.Next() {
0000000000000000000000000000000000000000;;			b := tx.Bucket(next)
0000000000000000000000000000000000000000;;			if b == nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("backend: cannot defrag bucket %s", string(next))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tmpb, berr := tmptx.CreateBucketIfNotExists(next)
0000000000000000000000000000000000000000;;			tmpb.FillPercent = 0.9 // for seq write in for each
0000000000000000000000000000000000000000;;			if berr != nil {
0000000000000000000000000000000000000000;;				return berr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b.ForEach(func(k, v []byte) error {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;				if count > limit {
0000000000000000000000000000000000000000;;					err = tmptx.Commit()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tmptx, err = tmpdb.Begin(true)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tmpb = tmptx.Bucket(next)
0000000000000000000000000000000000000000;;					tmpb.FillPercent = 0.9 // for seq write in for each
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					count = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return tmpb.Put(k, v)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tmptx.Commit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTmpBackend creates a backend implementation for testing.
0000000000000000000000000000000000000000;;	func NewTmpBackend(batchInterval time.Duration, batchLimit int) (*backend, string) {
0000000000000000000000000000000000000000;;		dir, err := ioutil.TempDir(os.TempDir(), "etcd_backend_test")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmpPath := filepath.Join(dir, "database")
0000000000000000000000000000000000000000;;		return newBackend(tmpPath, batchInterval, batchLimit), tmpPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefaultTmpBackend() (*backend, string) {
0000000000000000000000000000000000000000;;		return NewTmpBackend(defaultBatchInterval, defaultBatchLimit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type snapshot struct {
0000000000000000000000000000000000000000;;		*bolt.Tx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *snapshot) Close() error { return s.Tx.Rollback() }
