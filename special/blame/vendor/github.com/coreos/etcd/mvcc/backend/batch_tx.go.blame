0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/storage/backend/batch_tx.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/backend/batch_tx.go][vendor/github.com/coreos/etcd/mvcc/backend/batch_tx.go];	
0000000000000000000000000000000000000000;;	package backend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/boltdb/bolt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BatchTx interface {
0000000000000000000000000000000000000000;;		Lock()
0000000000000000000000000000000000000000;;		Unlock()
0000000000000000000000000000000000000000;;		UnsafeCreateBucket(name []byte)
0000000000000000000000000000000000000000;;		UnsafePut(bucketName []byte, key []byte, value []byte)
0000000000000000000000000000000000000000;;		UnsafeSeqPut(bucketName []byte, key []byte, value []byte)
0000000000000000000000000000000000000000;;		UnsafeRange(bucketName []byte, key, endKey []byte, limit int64) (keys [][]byte, vals [][]byte)
0000000000000000000000000000000000000000;;		UnsafeDelete(bucketName []byte, key []byte)
0000000000000000000000000000000000000000;;		UnsafeForEach(bucketName []byte, visitor func(k, v []byte) error) error
0000000000000000000000000000000000000000;;		Commit()
0000000000000000000000000000000000000000;;		CommitAndStop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type batchTx struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		tx      *bolt.Tx
0000000000000000000000000000000000000000;;		backend *backend
0000000000000000000000000000000000000000;;		pending int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBatchTx(backend *backend) *batchTx {
0000000000000000000000000000000000000000;;		tx := &batchTx{backend: backend}
0000000000000000000000000000000000000000;;		tx.Commit()
0000000000000000000000000000000000000000;;		return tx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *batchTx) UnsafeCreateBucket(name []byte) {
0000000000000000000000000000000000000000;;		_, err := t.tx.CreateBucket(name)
0000000000000000000000000000000000000000;;		if err != nil && err != bolt.ErrBucketExists {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot create bucket %s (%v)", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.pending++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafePut must be called holding the lock on the tx.
0000000000000000000000000000000000000000;;	func (t *batchTx) UnsafePut(bucketName []byte, key []byte, value []byte) {
0000000000000000000000000000000000000000;;		t.unsafePut(bucketName, key, value, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeSeqPut must be called holding the lock on the tx.
0000000000000000000000000000000000000000;;	func (t *batchTx) UnsafeSeqPut(bucketName []byte, key []byte, value []byte) {
0000000000000000000000000000000000000000;;		t.unsafePut(bucketName, key, value, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *batchTx) unsafePut(bucketName []byte, key []byte, value []byte, seq bool) {
0000000000000000000000000000000000000000;;		bucket := t.tx.Bucket(bucketName)
0000000000000000000000000000000000000000;;		if bucket == nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("bucket %s does not exist", bucketName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if seq {
0000000000000000000000000000000000000000;;			// it is useful to increase fill percent when the workloads are mostly append-only.
0000000000000000000000000000000000000000;;			// this can delay the page split and reduce space usage.
0000000000000000000000000000000000000000;;			bucket.FillPercent = 0.9
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := bucket.Put(key, value); err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot put key into bucket (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.pending++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeRange must be called holding the lock on the tx.
0000000000000000000000000000000000000000;;	func (t *batchTx) UnsafeRange(bucketName []byte, key, endKey []byte, limit int64) (keys [][]byte, vs [][]byte) {
0000000000000000000000000000000000000000;;		bucket := t.tx.Bucket(bucketName)
0000000000000000000000000000000000000000;;		if bucket == nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("bucket %s does not exist", bucketName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(endKey) == 0 {
0000000000000000000000000000000000000000;;			if v := bucket.Get(key); v == nil {
0000000000000000000000000000000000000000;;				return keys, vs
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return append(keys, key), append(vs, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := bucket.Cursor()
0000000000000000000000000000000000000000;;		for ck, cv := c.Seek(key); ck != nil && bytes.Compare(ck, endKey) < 0; ck, cv = c.Next() {
0000000000000000000000000000000000000000;;			vs = append(vs, cv)
0000000000000000000000000000000000000000;;			keys = append(keys, ck)
0000000000000000000000000000000000000000;;			if limit > 0 && limit == int64(len(keys)) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return keys, vs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeDelete must be called holding the lock on the tx.
0000000000000000000000000000000000000000;;	func (t *batchTx) UnsafeDelete(bucketName []byte, key []byte) {
0000000000000000000000000000000000000000;;		bucket := t.tx.Bucket(bucketName)
0000000000000000000000000000000000000000;;		if bucket == nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("bucket %s does not exist", bucketName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := bucket.Delete(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot delete key from bucket (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.pending++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeForEach must be called holding the lock on the tx.
0000000000000000000000000000000000000000;;	func (t *batchTx) UnsafeForEach(bucketName []byte, visitor func(k, v []byte) error) error {
0000000000000000000000000000000000000000;;		b := t.tx.Bucket(bucketName)
0000000000000000000000000000000000000000;;		if b == nil {
0000000000000000000000000000000000000000;;			// bucket does not exist
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.ForEach(visitor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Commit commits a previous tx and begins a new writable one.
0000000000000000000000000000000000000000;;	func (t *batchTx) Commit() {
0000000000000000000000000000000000000000;;		t.Lock()
0000000000000000000000000000000000000000;;		defer t.Unlock()
0000000000000000000000000000000000000000;;		t.commit(false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CommitAndStop commits the previous tx and do not create a new one.
0000000000000000000000000000000000000000;;	func (t *batchTx) CommitAndStop() {
0000000000000000000000000000000000000000;;		t.Lock()
0000000000000000000000000000000000000000;;		defer t.Unlock()
0000000000000000000000000000000000000000;;		t.commit(true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *batchTx) Unlock() {
0000000000000000000000000000000000000000;;		if t.pending >= t.backend.batchLimit {
0000000000000000000000000000000000000000;;			t.commit(false)
0000000000000000000000000000000000000000;;			t.pending = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Mutex.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *batchTx) commit(stop bool) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		// commit the last tx
0000000000000000000000000000000000000000;;		if t.tx != nil {
0000000000000000000000000000000000000000;;			if t.pending == 0 && !stop {
0000000000000000000000000000000000000000;;				t.backend.mu.RLock()
0000000000000000000000000000000000000000;;				defer t.backend.mu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// batchTx.commit(true) calls *bolt.Tx.Commit, which
0000000000000000000000000000000000000000;;				// initializes *bolt.Tx.db and *bolt.Tx.meta as nil,
0000000000000000000000000000000000000000;;				// and subsequent *bolt.Tx.Size() call panics.
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// This nil pointer reference panic happens when:
0000000000000000000000000000000000000000;;				//   1. batchTx.commit(false) from newBatchTx
0000000000000000000000000000000000000000;;				//   2. batchTx.commit(true) from stopping backend
0000000000000000000000000000000000000000;;				//   3. batchTx.commit(false) from inflight mvcc Hash call
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// Check if db is nil to prevent this panic
0000000000000000000000000000000000000000;;				if t.tx.DB() != nil {
0000000000000000000000000000000000000000;;					atomic.StoreInt64(&t.backend.size, t.tx.Size())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			start := time.Now()
0000000000000000000000000000000000000000;;			// gofail: var beforeCommit struct{}
0000000000000000000000000000000000000000;;			err = t.tx.Commit()
0000000000000000000000000000000000000000;;			// gofail: var afterCommit struct{}
0000000000000000000000000000000000000000;;			commitDurations.Observe(time.Since(start).Seconds())
0000000000000000000000000000000000000000;;			atomic.AddInt64(&t.backend.commits, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.pending = 0
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Fatalf("cannot commit tx (%s)", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if stop {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.backend.mu.RLock()
0000000000000000000000000000000000000000;;		defer t.backend.mu.RUnlock()
0000000000000000000000000000000000000000;;		// begin a new tx
0000000000000000000000000000000000000000;;		t.tx, err = t.backend.db.Begin(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("cannot begin tx (%s)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		atomic.StoreInt64(&t.backend.size, t.tx.Size())
0000000000000000000000000000000000000000;;	}
