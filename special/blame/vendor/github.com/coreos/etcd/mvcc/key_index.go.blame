0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/storage/key_index.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/key_index.go][vendor/github.com/coreos/etcd/mvcc/key_index.go];	
0000000000000000000000000000000000000000;;	package mvcc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/btree"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrRevisionNotFound = errors.New("mvcc: revision not found")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keyIndex stores the revisions of a key in the backend.
0000000000000000000000000000000000000000;;	// Each keyIndex has at least one key generation.
0000000000000000000000000000000000000000;;	// Each generation might have several key versions.
0000000000000000000000000000000000000000;;	// Tombstone on a key appends an tombstone version at the end
0000000000000000000000000000000000000000;;	// of the current generation and creates a new empty generation.
0000000000000000000000000000000000000000;;	// Each version of a key has an index pointing to the backend.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example: put(1.0);put(2.0);tombstone(3.0);put(4.0);tombstone(5.0) on key "foo"
0000000000000000000000000000000000000000;;	// generate a keyIndex:
0000000000000000000000000000000000000000;;	// key:     "foo"
0000000000000000000000000000000000000000;;	// rev: 5
0000000000000000000000000000000000000000;;	// generations:
0000000000000000000000000000000000000000;;	//    {empty}
0000000000000000000000000000000000000000;;	//    {4.0, 5.0(t)}
0000000000000000000000000000000000000000;;	//    {1.0, 2.0, 3.0(t)}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Compact a keyIndex removes the versions with smaller or equal to
0000000000000000000000000000000000000000;;	// rev except the largest one. If the generation becomes empty
0000000000000000000000000000000000000000;;	// during compaction, it will be removed. if all the generations get
0000000000000000000000000000000000000000;;	// removed, the keyIndex should be removed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	// compact(2) on the previous example
0000000000000000000000000000000000000000;;	// generations:
0000000000000000000000000000000000000000;;	//    {empty}
0000000000000000000000000000000000000000;;	//    {4.0, 5.0(t)}
0000000000000000000000000000000000000000;;	//    {2.0, 3.0(t)}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// compact(4)
0000000000000000000000000000000000000000;;	// generations:
0000000000000000000000000000000000000000;;	//    {empty}
0000000000000000000000000000000000000000;;	//    {4.0, 5.0(t)}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// compact(5):
0000000000000000000000000000000000000000;;	// generations:
0000000000000000000000000000000000000000;;	//    {empty} -> key SHOULD be removed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// compact(6):
0000000000000000000000000000000000000000;;	// generations:
0000000000000000000000000000000000000000;;	//    {empty} -> key SHOULD be removed.
0000000000000000000000000000000000000000;;	type keyIndex struct {
0000000000000000000000000000000000000000;;		key         []byte
0000000000000000000000000000000000000000;;		modified    revision // the main rev of the last modification
0000000000000000000000000000000000000000;;		generations []generation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// put puts a revision to the keyIndex.
0000000000000000000000000000000000000000;;	func (ki *keyIndex) put(main int64, sub int64) {
0000000000000000000000000000000000000000;;		rev := revision{main: main, sub: sub}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !rev.GreaterThan(ki.modified) {
0000000000000000000000000000000000000000;;			plog.Panicf("store.keyindex: put with unexpected smaller revision [%v / %v]", rev, ki.modified)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ki.generations) == 0 {
0000000000000000000000000000000000000000;;			ki.generations = append(ki.generations, generation{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g := &ki.generations[len(ki.generations)-1]
0000000000000000000000000000000000000000;;		if len(g.revs) == 0 { // create a new key
0000000000000000000000000000000000000000;;			keysGauge.Inc()
0000000000000000000000000000000000000000;;			g.created = rev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.revs = append(g.revs, rev)
0000000000000000000000000000000000000000;;		g.ver++
0000000000000000000000000000000000000000;;		ki.modified = rev
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ki *keyIndex) restore(created, modified revision, ver int64) {
0000000000000000000000000000000000000000;;		if len(ki.generations) != 0 {
0000000000000000000000000000000000000000;;			plog.Panicf("store.keyindex: cannot restore non-empty keyIndex")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ki.modified = modified
0000000000000000000000000000000000000000;;		g := generation{created: created, ver: ver, revs: []revision{modified}}
0000000000000000000000000000000000000000;;		ki.generations = append(ki.generations, g)
0000000000000000000000000000000000000000;;		keysGauge.Inc()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tombstone puts a revision, pointing to a tombstone, to the keyIndex.
0000000000000000000000000000000000000000;;	// It also creates a new empty generation in the keyIndex.
0000000000000000000000000000000000000000;;	// It returns ErrRevisionNotFound when tombstone on an empty generation.
0000000000000000000000000000000000000000;;	func (ki *keyIndex) tombstone(main int64, sub int64) error {
0000000000000000000000000000000000000000;;		if ki.isEmpty() {
0000000000000000000000000000000000000000;;			plog.Panicf("store.keyindex: unexpected tombstone on empty keyIndex %s", string(ki.key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ki.generations[len(ki.generations)-1].isEmpty() {
0000000000000000000000000000000000000000;;			return ErrRevisionNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ki.put(main, sub)
0000000000000000000000000000000000000000;;		ki.generations = append(ki.generations, generation{})
0000000000000000000000000000000000000000;;		keysGauge.Dec()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get gets the modified, created revision and version of the key that satisfies the given atRev.
0000000000000000000000000000000000000000;;	// Rev must be higher than or equal to the given atRev.
0000000000000000000000000000000000000000;;	func (ki *keyIndex) get(atRev int64) (modified, created revision, ver int64, err error) {
0000000000000000000000000000000000000000;;		if ki.isEmpty() {
0000000000000000000000000000000000000000;;			plog.Panicf("store.keyindex: unexpected get on empty keyIndex %s", string(ki.key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g := ki.findGeneration(atRev)
0000000000000000000000000000000000000000;;		if g.isEmpty() {
0000000000000000000000000000000000000000;;			return revision{}, revision{}, 0, ErrRevisionNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := g.walk(func(rev revision) bool { return rev.main > atRev })
0000000000000000000000000000000000000000;;		if n != -1 {
0000000000000000000000000000000000000000;;			return g.revs[n], g.created, g.ver - int64(len(g.revs)-n-1), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return revision{}, revision{}, 0, ErrRevisionNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// since returns revisions since the given rev. Only the revision with the
0000000000000000000000000000000000000000;;	// largest sub revision will be returned if multiple revisions have the same
0000000000000000000000000000000000000000;;	// main revision.
0000000000000000000000000000000000000000;;	func (ki *keyIndex) since(rev int64) []revision {
0000000000000000000000000000000000000000;;		if ki.isEmpty() {
0000000000000000000000000000000000000000;;			plog.Panicf("store.keyindex: unexpected get on empty keyIndex %s", string(ki.key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		since := revision{rev, 0}
0000000000000000000000000000000000000000;;		var gi int
0000000000000000000000000000000000000000;;		// find the generations to start checking
0000000000000000000000000000000000000000;;		for gi = len(ki.generations) - 1; gi > 0; gi-- {
0000000000000000000000000000000000000000;;			g := ki.generations[gi]
0000000000000000000000000000000000000000;;			if g.isEmpty() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if since.GreaterThan(g.created) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var revs []revision
0000000000000000000000000000000000000000;;		var last int64
0000000000000000000000000000000000000000;;		for ; gi < len(ki.generations); gi++ {
0000000000000000000000000000000000000000;;			for _, r := range ki.generations[gi].revs {
0000000000000000000000000000000000000000;;				if since.GreaterThan(r) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if r.main == last {
0000000000000000000000000000000000000000;;					// replace the revision with a new one that has higher sub value,
0000000000000000000000000000000000000000;;					// because the original one should not be seen by external
0000000000000000000000000000000000000000;;					revs[len(revs)-1] = r
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				revs = append(revs, r)
0000000000000000000000000000000000000000;;				last = r.main
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return revs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compact compacts a keyIndex by removing the versions with smaller or equal
0000000000000000000000000000000000000000;;	// revision than the given atRev except the largest one (If the largest one is
0000000000000000000000000000000000000000;;	// a tombstone, it will not be kept).
0000000000000000000000000000000000000000;;	// If a generation becomes empty during compaction, it will be removed.
0000000000000000000000000000000000000000;;	func (ki *keyIndex) compact(atRev int64, available map[revision]struct{}) {
0000000000000000000000000000000000000000;;		if ki.isEmpty() {
0000000000000000000000000000000000000000;;			plog.Panicf("store.keyindex: unexpected compact on empty keyIndex %s", string(ki.key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// walk until reaching the first revision that has an revision smaller or equal to
0000000000000000000000000000000000000000;;		// the atRev.
0000000000000000000000000000000000000000;;		// add it to the available map
0000000000000000000000000000000000000000;;		f := func(rev revision) bool {
0000000000000000000000000000000000000000;;			if rev.main <= atRev {
0000000000000000000000000000000000000000;;				available[rev] = struct{}{}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i, g := 0, &ki.generations[0]
0000000000000000000000000000000000000000;;		// find first generation includes atRev or created after atRev
0000000000000000000000000000000000000000;;		for i < len(ki.generations)-1 {
0000000000000000000000000000000000000000;;			if tomb := g.revs[len(g.revs)-1].main; tomb > atRev {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			g = &ki.generations[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !g.isEmpty() {
0000000000000000000000000000000000000000;;			n := g.walk(f)
0000000000000000000000000000000000000000;;			// remove the previous contents.
0000000000000000000000000000000000000000;;			if n != -1 {
0000000000000000000000000000000000000000;;				g.revs = g.revs[n:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// remove any tombstone
0000000000000000000000000000000000000000;;			if len(g.revs) == 1 && i != len(ki.generations)-1 {
0000000000000000000000000000000000000000;;				delete(available, g.revs[0])
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// remove the previous generations.
0000000000000000000000000000000000000000;;		ki.generations = ki.generations[i:]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ki *keyIndex) isEmpty() bool {
0000000000000000000000000000000000000000;;		return len(ki.generations) == 1 && ki.generations[0].isEmpty()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findGeneration finds out the generation of the keyIndex that the
0000000000000000000000000000000000000000;;	// given rev belongs to. If the given rev is at the gap of two generations,
0000000000000000000000000000000000000000;;	// which means that the key does not exist at the given rev, it returns nil.
0000000000000000000000000000000000000000;;	func (ki *keyIndex) findGeneration(rev int64) *generation {
0000000000000000000000000000000000000000;;		lastg := len(ki.generations) - 1
0000000000000000000000000000000000000000;;		cg := lastg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for cg >= 0 {
0000000000000000000000000000000000000000;;			if len(ki.generations[cg].revs) == 0 {
0000000000000000000000000000000000000000;;				cg--
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g := ki.generations[cg]
0000000000000000000000000000000000000000;;			if cg != lastg {
0000000000000000000000000000000000000000;;				if tomb := g.revs[len(g.revs)-1].main; tomb <= rev {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if g.revs[0].main <= rev {
0000000000000000000000000000000000000000;;				return &ki.generations[cg]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cg--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *keyIndex) Less(b btree.Item) bool {
0000000000000000000000000000000000000000;;		return bytes.Compare(a.key, b.(*keyIndex).key) == -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *keyIndex) equal(b *keyIndex) bool {
0000000000000000000000000000000000000000;;		if !bytes.Equal(a.key, b.key) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.modified != b.modified {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(a.generations) != len(b.generations) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range a.generations {
0000000000000000000000000000000000000000;;			ag, bg := a.generations[i], b.generations[i]
0000000000000000000000000000000000000000;;			if !ag.equal(bg) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ki *keyIndex) String() string {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for _, g := range ki.generations {
0000000000000000000000000000000000000000;;			s += g.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generation contains multiple revisions of a key.
0000000000000000000000000000000000000000;;	type generation struct {
0000000000000000000000000000000000000000;;		ver     int64
0000000000000000000000000000000000000000;;		created revision // when the generation is created (put in first revision).
0000000000000000000000000000000000000000;;		revs    []revision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *generation) isEmpty() bool { return g == nil || len(g.revs) == 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// walk walks through the revisions in the generation in descending order.
0000000000000000000000000000000000000000;;	// It passes the revision to the given function.
0000000000000000000000000000000000000000;;	// walk returns until: 1. it finishes walking all pairs 2. the function returns false.
0000000000000000000000000000000000000000;;	// walk returns the position at where it stopped. If it stopped after
0000000000000000000000000000000000000000;;	// finishing walking, -1 will be returned.
0000000000000000000000000000000000000000;;	func (g *generation) walk(f func(rev revision) bool) int {
0000000000000000000000000000000000000000;;		l := len(g.revs)
0000000000000000000000000000000000000000;;		for i := range g.revs {
0000000000000000000000000000000000000000;;			ok := f(g.revs[l-i-1])
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return l - i - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *generation) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("g: created[%d] ver[%d], revs %#v\n", g.created, g.ver, g.revs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a generation) equal(b generation) bool {
0000000000000000000000000000000000000000;;		if a.ver != b.ver {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(a.revs) != len(b.revs) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range a.revs {
0000000000000000000000000000000000000000;;			ar, br := a.revs[i], b.revs[i]
0000000000000000000000000000000000000000;;			if ar != br {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
