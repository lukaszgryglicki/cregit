0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/storage/kvstore_compaction.go[Godeps/_workspace/src/github.com/coreos/etcd/storage/kvstore_compaction.go][vendor/github.com/coreos/etcd/mvcc/kvstore_compaction.go];	
0000000000000000000000000000000000000000;;	package mvcc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) scheduleCompaction(compactMainRev int64, keep map[revision]struct{}) bool {
0000000000000000000000000000000000000000;;		totalStart := time.Now()
0000000000000000000000000000000000000000;;		defer dbCompactionTotalDurations.Observe(float64(time.Since(totalStart) / time.Millisecond))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end := make([]byte, 8)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(end, uint64(compactMainRev+1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchsize := int64(10000)
0000000000000000000000000000000000000000;;		last := make([]byte, 8+1+8)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var rev revision
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			start := time.Now()
0000000000000000000000000000000000000000;;			tx := s.b.BatchTx()
0000000000000000000000000000000000000000;;			tx.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keys, _ := tx.UnsafeRange(keyBucketName, last, end, batchsize)
0000000000000000000000000000000000000000;;			for _, key := range keys {
0000000000000000000000000000000000000000;;				rev = bytesToRev(key)
0000000000000000000000000000000000000000;;				if _, ok := keep[rev]; !ok {
0000000000000000000000000000000000000000;;					tx.UnsafeDelete(keyBucketName, key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(keys) < int(batchsize) {
0000000000000000000000000000000000000000;;				rbytes := make([]byte, 8+1+8)
0000000000000000000000000000000000000000;;				revToBytes(revision{main: compactMainRev}, rbytes)
0000000000000000000000000000000000000000;;				tx.UnsafePut(metaBucketName, finishedCompactKeyName, rbytes)
0000000000000000000000000000000000000000;;				tx.Unlock()
0000000000000000000000000000000000000000;;				plog.Printf("finished scheduled compaction at %d (took %v)", compactMainRev, time.Since(totalStart))
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// update last
0000000000000000000000000000000000000000;;			revToBytes(revision{main: rev.main, sub: rev.sub + 1}, last)
0000000000000000000000000000000000000000;;			tx.Unlock()
0000000000000000000000000000000000000000;;			dbCompactionPauseDurations.Observe(float64(time.Since(start) / time.Millisecond))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(100 * time.Millisecond):
0000000000000000000000000000000000000000;;			case <-s.stopc:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
