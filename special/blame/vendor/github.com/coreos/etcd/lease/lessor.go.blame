0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/lease/lessor.go[Godeps/_workspace/src/github.com/coreos/etcd/lease/lessor.go][vendor/github.com/coreos/etcd/lease/lessor.go];	
0000000000000000000000000000000000000000;;	package lease
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/lease/leasepb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/monotime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NoLease is a special LeaseID representing the absence of a lease.
0000000000000000000000000000000000000000;;		NoLease = LeaseID(0)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		leaseBucketName = []byte("lease")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		forever = monotime.Time(math.MaxInt64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrNotPrimary    = errors.New("not a primary lessor")
0000000000000000000000000000000000000000;;		ErrLeaseNotFound = errors.New("lease not found")
0000000000000000000000000000000000000000;;		ErrLeaseExists   = errors.New("lease already exists")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LeaseID int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeDeleter defines an interface with Txn and DeleteRange method.
0000000000000000000000000000000000000000;;	// We define this interface only for lessor to limit the number
0000000000000000000000000000000000000000;;	// of methods of mvcc.KV to what lessor actually needs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Having a minimum interface makes testing easy.
0000000000000000000000000000000000000000;;	type RangeDeleter interface {
0000000000000000000000000000000000000000;;		// TxnBegin see comments on mvcc.KV
0000000000000000000000000000000000000000;;		TxnBegin() int64
0000000000000000000000000000000000000000;;		// TxnEnd see comments on mvcc.KV
0000000000000000000000000000000000000000;;		TxnEnd(txnID int64) error
0000000000000000000000000000000000000000;;		// TxnDeleteRange see comments on mvcc.KV
0000000000000000000000000000000000000000;;		TxnDeleteRange(txnID int64, key, end []byte) (n, rev int64, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lessor owns leases. It can grant, revoke, renew and modify leases for lessee.
0000000000000000000000000000000000000000;;	type Lessor interface {
0000000000000000000000000000000000000000;;		// SetRangeDeleter sets the RangeDeleter to the Lessor.
0000000000000000000000000000000000000000;;		// Lessor deletes the items in the revoked or expired lease from the
0000000000000000000000000000000000000000;;		// the set RangeDeleter.
0000000000000000000000000000000000000000;;		SetRangeDeleter(dr RangeDeleter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Grant grants a lease that expires at least after TTL seconds.
0000000000000000000000000000000000000000;;		Grant(id LeaseID, ttl int64) (*Lease, error)
0000000000000000000000000000000000000000;;		// Revoke revokes a lease with given ID. The item attached to the
0000000000000000000000000000000000000000;;		// given lease will be removed. If the ID does not exist, an error
0000000000000000000000000000000000000000;;		// will be returned.
0000000000000000000000000000000000000000;;		Revoke(id LeaseID) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attach attaches given leaseItem to the lease with given LeaseID.
0000000000000000000000000000000000000000;;		// If the lease does not exist, an error will be returned.
0000000000000000000000000000000000000000;;		Attach(id LeaseID, items []LeaseItem) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetLease returns LeaseID for given item.
0000000000000000000000000000000000000000;;		// If no lease found, NoLease value will be returned.
0000000000000000000000000000000000000000;;		GetLease(item LeaseItem) LeaseID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Detach detaches given leaseItem from the lease with given LeaseID.
0000000000000000000000000000000000000000;;		// If the lease does not exist, an error will be returned.
0000000000000000000000000000000000000000;;		Detach(id LeaseID, items []LeaseItem) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Promote promotes the lessor to be the primary lessor. Primary lessor manages
0000000000000000000000000000000000000000;;		// the expiration and renew of leases.
0000000000000000000000000000000000000000;;		// Newly promoted lessor renew the TTL of all lease to extend + previous TTL.
0000000000000000000000000000000000000000;;		Promote(extend time.Duration)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Demote demotes the lessor from being the primary lessor.
0000000000000000000000000000000000000000;;		Demote()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Renew renews a lease with given ID. It returns the renewed TTL. If the ID does not exist,
0000000000000000000000000000000000000000;;		// an error will be returned.
0000000000000000000000000000000000000000;;		Renew(id LeaseID) (int64, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lookup gives the lease at a given lease id, if any
0000000000000000000000000000000000000000;;		Lookup(id LeaseID) *Lease
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExpiredLeasesC returns a chan that is used to receive expired leases.
0000000000000000000000000000000000000000;;		ExpiredLeasesC() <-chan []*Lease
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recover recovers the lessor state from the given backend and RangeDeleter.
0000000000000000000000000000000000000000;;		Recover(b backend.Backend, rd RangeDeleter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop stops the lessor for managing leases. The behavior of calling Stop multiple
0000000000000000000000000000000000000000;;		// times is undefined.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lessor implements Lessor interface.
0000000000000000000000000000000000000000;;	// TODO: use clockwork for testability.
0000000000000000000000000000000000000000;;	type lessor struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// demotec is set when the lessor is the primary.
0000000000000000000000000000000000000000;;		// demotec will be closed if the lessor is demoted.
0000000000000000000000000000000000000000;;		demotec chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: probably this should be a heap with a secondary
0000000000000000000000000000000000000000;;		// id index.
0000000000000000000000000000000000000000;;		// Now it is O(N) to loop over the leases to find expired ones.
0000000000000000000000000000000000000000;;		// We want to make Grant, Revoke, and findExpiredLeases all O(logN) and
0000000000000000000000000000000000000000;;		// Renew O(1).
0000000000000000000000000000000000000000;;		// findExpiredLeases and Renew should be the most frequent operations.
0000000000000000000000000000000000000000;;		leaseMap map[LeaseID]*Lease
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemMap map[LeaseItem]LeaseID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a lease expires, the lessor will delete the
0000000000000000000000000000000000000000;;		// leased range (or key) by the RangeDeleter.
0000000000000000000000000000000000000000;;		rd RangeDeleter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// backend to persist leases. We only persist lease ID and expiry for now.
0000000000000000000000000000000000000000;;		// The leased items can be recovered by iterating all the keys in kv.
0000000000000000000000000000000000000000;;		b backend.Backend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// minLeaseTTL is the minimum lease TTL that can be granted for a lease. Any
0000000000000000000000000000000000000000;;		// requests for shorter TTLs are extended to the minimum TTL.
0000000000000000000000000000000000000000;;		minLeaseTTL int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expiredC chan []*Lease
0000000000000000000000000000000000000000;;		// stopC is a channel whose closure indicates that the lessor should be stopped.
0000000000000000000000000000000000000000;;		stopC chan struct{}
0000000000000000000000000000000000000000;;		// doneC is a channel whose closure indicates that the lessor is stopped.
0000000000000000000000000000000000000000;;		doneC chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewLessor(b backend.Backend, minLeaseTTL int64) Lessor {
0000000000000000000000000000000000000000;;		return newLessor(b, minLeaseTTL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLessor(b backend.Backend, minLeaseTTL int64) *lessor {
0000000000000000000000000000000000000000;;		l := &lessor{
0000000000000000000000000000000000000000;;			leaseMap:    make(map[LeaseID]*Lease),
0000000000000000000000000000000000000000;;			itemMap:     make(map[LeaseItem]LeaseID),
0000000000000000000000000000000000000000;;			b:           b,
0000000000000000000000000000000000000000;;			minLeaseTTL: minLeaseTTL,
0000000000000000000000000000000000000000;;			// expiredC is a small buffered chan to avoid unnecessary blocking.
0000000000000000000000000000000000000000;;			expiredC: make(chan []*Lease, 16),
0000000000000000000000000000000000000000;;			stopC:    make(chan struct{}),
0000000000000000000000000000000000000000;;			doneC:    make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.initAndRecover()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go l.runLoop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPrimary indicates if this lessor is the primary lessor. The primary
0000000000000000000000000000000000000000;;	// lessor manages lease expiration and renew.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// in etcd, raft leader is the primary. Thus there might be two primary
0000000000000000000000000000000000000000;;	// leaders at the same time (raft allows concurrent leader but with different term)
0000000000000000000000000000000000000000;;	// for at most a leader election timeout.
0000000000000000000000000000000000000000;;	// The old primary leader cannot affect the correctness since its proposal has a
0000000000000000000000000000000000000000;;	// smaller term and will not be committed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: raft follower do not forward lease management proposals. There might be a
0000000000000000000000000000000000000000;;	// very small window (within second normally which depends on go scheduling) that
0000000000000000000000000000000000000000;;	// a raft follow is the primary between the raft leader demotion and lessor demotion.
0000000000000000000000000000000000000000;;	// Usually this should not be a problem. Lease should not be that sensitive to timing.
0000000000000000000000000000000000000000;;	func (le *lessor) isPrimary() bool {
0000000000000000000000000000000000000000;;		return le.demotec != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) SetRangeDeleter(rd RangeDeleter) {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le.rd = rd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) Grant(id LeaseID, ttl int64) (*Lease, error) {
0000000000000000000000000000000000000000;;		if id == NoLease {
0000000000000000000000000000000000000000;;			return nil, ErrLeaseNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: when lessor is under high load, it should give out lease
0000000000000000000000000000000000000000;;		// with longer TTL to reduce renew load.
0000000000000000000000000000000000000000;;		l := &Lease{
0000000000000000000000000000000000000000;;			ID:      id,
0000000000000000000000000000000000000000;;			ttl:     ttl,
0000000000000000000000000000000000000000;;			itemSet: make(map[LeaseItem]struct{}),
0000000000000000000000000000000000000000;;			revokec: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := le.leaseMap[id]; ok {
0000000000000000000000000000000000000000;;			return nil, ErrLeaseExists
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.ttl < le.minLeaseTTL {
0000000000000000000000000000000000000000;;			l.ttl = le.minLeaseTTL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if le.isPrimary() {
0000000000000000000000000000000000000000;;			l.refresh(0)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			l.forever()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le.leaseMap[id] = l
0000000000000000000000000000000000000000;;		l.persistTo(le.b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) Revoke(id LeaseID) error {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := le.leaseMap[id]
0000000000000000000000000000000000000000;;		if l == nil {
0000000000000000000000000000000000000000;;			le.mu.Unlock()
0000000000000000000000000000000000000000;;			return ErrLeaseNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer close(l.revokec)
0000000000000000000000000000000000000000;;		// unlock before doing external work
0000000000000000000000000000000000000000;;		le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if le.rd == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tid := le.rd.TxnBegin()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sort keys so deletes are in same order among all members,
0000000000000000000000000000000000000000;;		// otherwise the backened hashes will be different
0000000000000000000000000000000000000000;;		keys := l.Keys()
0000000000000000000000000000000000000000;;		sort.StringSlice(keys).Sort()
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			_, _, err := le.rd.TxnDeleteRange(tid, []byte(key), nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;		delete(le.leaseMap, l.ID)
0000000000000000000000000000000000000000;;		// lease deletion needs to be in the same backend transaction with the
0000000000000000000000000000000000000000;;		// kv deletion. Or we might end up with not executing the revoke or not
0000000000000000000000000000000000000000;;		// deleting the keys if etcdserver fails in between.
0000000000000000000000000000000000000000;;		le.b.BatchTx().UnsafeDelete(leaseBucketName, int64ToBytes(int64(l.ID)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := le.rd.TxnEnd(tid)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Renew renews an existing lease. If the given lease does not exist or
0000000000000000000000000000000000000000;;	// has expired, an error will be returned.
0000000000000000000000000000000000000000;;	func (le *lessor) Renew(id LeaseID) (int64, error) {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unlock := func() { le.mu.Unlock() }
0000000000000000000000000000000000000000;;		defer func() { unlock() }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !le.isPrimary() {
0000000000000000000000000000000000000000;;			// forward renew request to primary instead of returning error.
0000000000000000000000000000000000000000;;			return -1, ErrNotPrimary
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		demotec := le.demotec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := le.leaseMap[id]
0000000000000000000000000000000000000000;;		if l == nil {
0000000000000000000000000000000000000000;;			return -1, ErrLeaseNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.expired() {
0000000000000000000000000000000000000000;;			le.mu.Unlock()
0000000000000000000000000000000000000000;;			unlock = func() {}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			// A expired lease might be pending for revoking or going through
0000000000000000000000000000000000000000;;			// quorum to be revoked. To be accurate, renew request must wait for the
0000000000000000000000000000000000000000;;			// deletion to complete.
0000000000000000000000000000000000000000;;			case <-l.revokec:
0000000000000000000000000000000000000000;;				return -1, ErrLeaseNotFound
0000000000000000000000000000000000000000;;			// The expired lease might fail to be revoked if the primary changes.
0000000000000000000000000000000000000000;;			// The caller will retry on ErrNotPrimary.
0000000000000000000000000000000000000000;;			case <-demotec:
0000000000000000000000000000000000000000;;				return -1, ErrNotPrimary
0000000000000000000000000000000000000000;;			case <-le.stopC:
0000000000000000000000000000000000000000;;				return -1, ErrNotPrimary
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.refresh(0)
0000000000000000000000000000000000000000;;		return l.ttl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) Lookup(id LeaseID) *Lease {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;		return le.leaseMap[id]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) Promote(extend time.Duration) {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le.demotec = make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// refresh the expiries of all leases.
0000000000000000000000000000000000000000;;		for _, l := range le.leaseMap {
0000000000000000000000000000000000000000;;			l.refresh(extend)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) Demote() {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set the expiries of all leases to forever
0000000000000000000000000000000000000000;;		for _, l := range le.leaseMap {
0000000000000000000000000000000000000000;;			l.forever()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if le.demotec != nil {
0000000000000000000000000000000000000000;;			close(le.demotec)
0000000000000000000000000000000000000000;;			le.demotec = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attach attaches items to the lease with given ID. When the lease
0000000000000000000000000000000000000000;;	// expires, the attached items will be automatically removed.
0000000000000000000000000000000000000000;;	// If the given lease does not exist, an error will be returned.
0000000000000000000000000000000000000000;;	func (le *lessor) Attach(id LeaseID, items []LeaseItem) error {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := le.leaseMap[id]
0000000000000000000000000000000000000000;;		if l == nil {
0000000000000000000000000000000000000000;;			return ErrLeaseNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		for _, it := range items {
0000000000000000000000000000000000000000;;			l.itemSet[it] = struct{}{}
0000000000000000000000000000000000000000;;			le.itemMap[it] = id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.mu.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) GetLease(item LeaseItem) LeaseID {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		id := le.itemMap[item]
0000000000000000000000000000000000000000;;		le.mu.Unlock()
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detach detaches items from the lease with given ID.
0000000000000000000000000000000000000000;;	// If the given lease does not exist, an error will be returned.
0000000000000000000000000000000000000000;;	func (le *lessor) Detach(id LeaseID, items []LeaseItem) error {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := le.leaseMap[id]
0000000000000000000000000000000000000000;;		if l == nil {
0000000000000000000000000000000000000000;;			return ErrLeaseNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		for _, it := range items {
0000000000000000000000000000000000000000;;			delete(l.itemSet, it)
0000000000000000000000000000000000000000;;			delete(le.itemMap, it)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.mu.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) Recover(b backend.Backend, rd RangeDeleter) {
0000000000000000000000000000000000000000;;		le.mu.Lock()
0000000000000000000000000000000000000000;;		defer le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le.b = b
0000000000000000000000000000000000000000;;		le.rd = rd
0000000000000000000000000000000000000000;;		le.leaseMap = make(map[LeaseID]*Lease)
0000000000000000000000000000000000000000;;		le.itemMap = make(map[LeaseItem]LeaseID)
0000000000000000000000000000000000000000;;		le.initAndRecover()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) ExpiredLeasesC() <-chan []*Lease {
0000000000000000000000000000000000000000;;		return le.expiredC
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) Stop() {
0000000000000000000000000000000000000000;;		close(le.stopC)
0000000000000000000000000000000000000000;;		<-le.doneC
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) runLoop() {
0000000000000000000000000000000000000000;;		defer close(le.doneC)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var ls []*Lease
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			le.mu.Lock()
0000000000000000000000000000000000000000;;			if le.isPrimary() {
0000000000000000000000000000000000000000;;				ls = le.findExpiredLeases()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			le.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(ls) != 0 {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-le.stopC:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case le.expiredC <- ls:
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// the receiver of expiredC is probably busy handling
0000000000000000000000000000000000000000;;					// other stuff
0000000000000000000000000000000000000000;;					// let's try this next time after 500ms
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(500 * time.Millisecond):
0000000000000000000000000000000000000000;;			case <-le.stopC:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findExpiredLeases loops all the leases in the leaseMap and returns the expired
0000000000000000000000000000000000000000;;	// leases that needed to be revoked.
0000000000000000000000000000000000000000;;	func (le *lessor) findExpiredLeases() []*Lease {
0000000000000000000000000000000000000000;;		leases := make([]*Lease, 0, 16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, l := range le.leaseMap {
0000000000000000000000000000000000000000;;			// TODO: probably should change to <= 100-500 millisecond to
0000000000000000000000000000000000000000;;			// make up committing latency.
0000000000000000000000000000000000000000;;			if l.expired() {
0000000000000000000000000000000000000000;;				leases = append(leases, l)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return leases
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *lessor) initAndRecover() {
0000000000000000000000000000000000000000;;		tx := le.b.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(leaseBucketName)
0000000000000000000000000000000000000000;;		_, vs := tx.UnsafeRange(leaseBucketName, int64ToBytes(0), int64ToBytes(math.MaxInt64), 0)
0000000000000000000000000000000000000000;;		// TODO: copy vs and do decoding outside tx lock if lock contention becomes an issue.
0000000000000000000000000000000000000000;;		for i := range vs {
0000000000000000000000000000000000000000;;			var lpb leasepb.Lease
0000000000000000000000000000000000000000;;			err := lpb.Unmarshal(vs[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				tx.Unlock()
0000000000000000000000000000000000000000;;				panic("failed to unmarshal lease proto item")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ID := LeaseID(lpb.ID)
0000000000000000000000000000000000000000;;			if lpb.TTL < le.minLeaseTTL {
0000000000000000000000000000000000000000;;				lpb.TTL = le.minLeaseTTL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			le.leaseMap[ID] = &Lease{
0000000000000000000000000000000000000000;;				ID:  ID,
0000000000000000000000000000000000000000;;				ttl: lpb.TTL,
0000000000000000000000000000000000000000;;				// itemSet will be filled in when recover key-value pairs
0000000000000000000000000000000000000000;;				// set expiry to forever, refresh when promoted
0000000000000000000000000000000000000000;;				itemSet: make(map[LeaseItem]struct{}),
0000000000000000000000000000000000000000;;				expiry:  forever,
0000000000000000000000000000000000000000;;				revokec: make(chan struct{}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		le.b.ForceCommit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Lease struct {
0000000000000000000000000000000000000000;;		ID  LeaseID
0000000000000000000000000000000000000000;;		ttl int64 // time to live in seconds
0000000000000000000000000000000000000000;;		// expiry is time when lease should expire; must be 64-bit aligned.
0000000000000000000000000000000000000000;;		expiry monotime.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects concurrent accesses to itemSet
0000000000000000000000000000000000000000;;		mu      sync.RWMutex
0000000000000000000000000000000000000000;;		itemSet map[LeaseItem]struct{}
0000000000000000000000000000000000000000;;		revokec chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *Lease) expired() bool {
0000000000000000000000000000000000000000;;		return l.Remaining() <= 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *Lease) persistTo(b backend.Backend) {
0000000000000000000000000000000000000000;;		key := int64ToBytes(int64(l.ID))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lpb := leasepb.Lease{ID: int64(l.ID), TTL: int64(l.ttl)}
0000000000000000000000000000000000000000;;		val, err := lpb.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("failed to marshal lease proto item")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.BatchTx().Lock()
0000000000000000000000000000000000000000;;		b.BatchTx().UnsafePut(leaseBucketName, key, val)
0000000000000000000000000000000000000000;;		b.BatchTx().Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TTL returns the TTL of the Lease.
0000000000000000000000000000000000000000;;	func (l *Lease) TTL() int64 {
0000000000000000000000000000000000000000;;		return l.ttl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// refresh refreshes the expiry of the lease.
0000000000000000000000000000000000000000;;	func (l *Lease) refresh(extend time.Duration) {
0000000000000000000000000000000000000000;;		t := monotime.Now().Add(extend + time.Duration(l.ttl)*time.Second)
0000000000000000000000000000000000000000;;		atomic.StoreUint64((*uint64)(&l.expiry), uint64(t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forever sets the expiry of lease to be forever.
0000000000000000000000000000000000000000;;	func (l *Lease) forever() { atomic.StoreUint64((*uint64)(&l.expiry), uint64(forever)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns all the keys attached to the lease.
0000000000000000000000000000000000000000;;	func (l *Lease) Keys() []string {
0000000000000000000000000000000000000000;;		l.mu.RLock()
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(l.itemSet))
0000000000000000000000000000000000000000;;		for k := range l.itemSet {
0000000000000000000000000000000000000000;;			keys = append(keys, k.Key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.mu.RUnlock()
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remaining returns the remaining time of the lease.
0000000000000000000000000000000000000000;;	func (l *Lease) Remaining() time.Duration {
0000000000000000000000000000000000000000;;		t := monotime.Time(atomic.LoadUint64((*uint64)(&l.expiry)))
0000000000000000000000000000000000000000;;		return time.Duration(t - monotime.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LeaseItem struct {
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func int64ToBytes(n int64) []byte {
0000000000000000000000000000000000000000;;		bytes := make([]byte, 8)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(bytes, uint64(n))
0000000000000000000000000000000000000000;;		return bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeLessor is a fake implementation of Lessor interface.
0000000000000000000000000000000000000000;;	// Used for testing only.
0000000000000000000000000000000000000000;;	type FakeLessor struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) SetRangeDeleter(dr RangeDeleter) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Grant(id LeaseID, ttl int64) (*Lease, error) { return nil, nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Revoke(id LeaseID) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Attach(id LeaseID, items []LeaseItem) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) GetLease(item LeaseItem) LeaseID            { return 0 }
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Detach(id LeaseID, items []LeaseItem) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Promote(extend time.Duration) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Demote() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Renew(id LeaseID) (int64, error) { return 10, nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (le *FakeLessor) Lookup(id LeaseID) *Lease { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) ExpiredLeasesC() <-chan []*Lease { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Recover(b backend.Backend, rd RangeDeleter) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fl *FakeLessor) Stop() {}
