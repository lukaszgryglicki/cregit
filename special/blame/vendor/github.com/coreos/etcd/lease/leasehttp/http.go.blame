0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/lease/leasehttp/http.go[Godeps/_workspace/src/github.com/coreos/etcd/lease/leasehttp/http.go][vendor/github.com/coreos/etcd/lease/leasehttp/http.go];	
0000000000000000000000000000000000000000;;	package leasehttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/lease"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/lease/leasepb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/httputil"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		LeasePrefix         = "/leases"
0000000000000000000000000000000000000000;;		LeaseInternalPrefix = "/leases/internal"
0000000000000000000000000000000000000000;;		applyTimeout        = time.Second
0000000000000000000000000000000000000000;;		ErrLeaseHTTPTimeout = errors.New("waiting for node to catch up its applied index has timed out")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHandler returns an http Handler for lease renewals
0000000000000000000000000000000000000000;;	func NewHandler(l lease.Lessor, waitch func() <-chan struct{}) http.Handler {
0000000000000000000000000000000000000000;;		return &leaseHandler{l, waitch}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type leaseHandler struct {
0000000000000000000000000000000000000000;;		l      lease.Lessor
0000000000000000000000000000000000000000;;		waitch func() <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *leaseHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if r.Method != "POST" {
0000000000000000000000000000000000000000;;			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, "error reading body", http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var v []byte
0000000000000000000000000000000000000000;;		switch r.URL.Path {
0000000000000000000000000000000000000000;;		case LeasePrefix:
0000000000000000000000000000000000000000;;			lreq := pb.LeaseKeepAliveRequest{}
0000000000000000000000000000000000000000;;			if err := lreq.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, "error unmarshalling request", http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-h.waitch():
0000000000000000000000000000000000000000;;			case <-time.After(applyTimeout):
0000000000000000000000000000000000000000;;				http.Error(w, ErrLeaseHTTPTimeout.Error(), http.StatusRequestTimeout)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ttl, err := h.l.Renew(lease.LeaseID(lreq.ID))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == lease.ErrLeaseNotFound {
0000000000000000000000000000000000000000;;					http.Error(w, err.Error(), http.StatusNotFound)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				http.Error(w, err.Error(), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: fill out ResponseHeader
0000000000000000000000000000000000000000;;			resp := &pb.LeaseKeepAliveResponse{ID: lreq.ID, TTL: ttl}
0000000000000000000000000000000000000000;;			v, err = resp.Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case LeaseInternalPrefix:
0000000000000000000000000000000000000000;;			lreq := leasepb.LeaseInternalRequest{}
0000000000000000000000000000000000000000;;			if err := lreq.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, "error unmarshalling request", http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-h.waitch():
0000000000000000000000000000000000000000;;			case <-time.After(applyTimeout):
0000000000000000000000000000000000000000;;				http.Error(w, ErrLeaseHTTPTimeout.Error(), http.StatusRequestTimeout)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l := h.l.Lookup(lease.LeaseID(lreq.LeaseTimeToLiveRequest.ID))
0000000000000000000000000000000000000000;;			if l == nil {
0000000000000000000000000000000000000000;;				http.Error(w, lease.ErrLeaseNotFound.Error(), http.StatusNotFound)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: fill out ResponseHeader
0000000000000000000000000000000000000000;;			resp := &leasepb.LeaseInternalResponse{
0000000000000000000000000000000000000000;;				LeaseTimeToLiveResponse: &pb.LeaseTimeToLiveResponse{
0000000000000000000000000000000000000000;;					Header:     &pb.ResponseHeader{},
0000000000000000000000000000000000000000;;					ID:         lreq.LeaseTimeToLiveRequest.ID,
0000000000000000000000000000000000000000;;					TTL:        int64(l.Remaining().Seconds()),
0000000000000000000000000000000000000000;;					GrantedTTL: l.TTL(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lreq.LeaseTimeToLiveRequest.Keys {
0000000000000000000000000000000000000000;;				ks := l.Keys()
0000000000000000000000000000000000000000;;				kbs := make([][]byte, len(ks))
0000000000000000000000000000000000000000;;				for i := range ks {
0000000000000000000000000000000000000000;;					kbs[i] = []byte(ks[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resp.LeaseTimeToLiveResponse.Keys = kbs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v, err = resp.Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("unknown request path %q", r.URL.Path), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/protobuf")
0000000000000000000000000000000000000000;;		w.Write(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RenewHTTP renews a lease at a given primary server.
0000000000000000000000000000000000000000;;	// TODO: Batch request in future?
0000000000000000000000000000000000000000;;	func RenewHTTP(ctx context.Context, id lease.LeaseID, url string, rt http.RoundTripper) (int64, error) {
0000000000000000000000000000000000000000;;		// will post lreq protobuf to leader
0000000000000000000000000000000000000000;;		lreq, err := (&pb.LeaseKeepAliveRequest{ID: int64(id)}).Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc := &http.Client{Transport: rt}
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", url, bytes.NewReader(lreq))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/protobuf")
0000000000000000000000000000000000000000;;		req.Cancel = ctx.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := cc.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := readResponse(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode == http.StatusRequestTimeout {
0000000000000000000000000000000000000000;;			return -1, ErrLeaseHTTPTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;			return -1, lease.ErrLeaseNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf("lease: unknown error(%s)", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lresp := &pb.LeaseKeepAliveResponse{}
0000000000000000000000000000000000000000;;		if err := lresp.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf(`lease: %v. data = "%s"`, err, string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lresp.ID != int64(id) {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf("lease: renew id mismatch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lresp.TTL, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeToLiveHTTP retrieves lease information of the given lease ID.
0000000000000000000000000000000000000000;;	func TimeToLiveHTTP(ctx context.Context, id lease.LeaseID, keys bool, url string, rt http.RoundTripper) (*leasepb.LeaseInternalResponse, error) {
0000000000000000000000000000000000000000;;		// will post lreq protobuf to leader
0000000000000000000000000000000000000000;;		lreq, err := (&leasepb.LeaseInternalRequest{&pb.LeaseTimeToLiveRequest{ID: int64(id), Keys: keys}}).Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", url, bytes.NewReader(lreq))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/protobuf")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cancel := httputil.RequestCanceler(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc := &http.Client{Transport: rt}
0000000000000000000000000000000000000000;;		var b []byte
0000000000000000000000000000000000000000;;		// buffer errc channel so that errc don't block inside the go routinue
0000000000000000000000000000000000000000;;		errc := make(chan error, 2)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			resp, err := cc.Do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errc <- err
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b, err = readResponse(resp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errc <- err
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode == http.StatusRequestTimeout {
0000000000000000000000000000000000000000;;				errc <- ErrLeaseHTTPTimeout
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				errc <- lease.ErrLeaseNotFound
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;				errc <- fmt.Errorf("lease: unknown error(%s)", string(b))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errc <- nil
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case derr := <-errc:
0000000000000000000000000000000000000000;;			if derr != nil {
0000000000000000000000000000000000000000;;				return nil, derr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;			return nil, ctx.Err()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lresp := &leasepb.LeaseInternalResponse{}
0000000000000000000000000000000000000000;;		if err := lresp.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(`lease: %v. data = "%s"`, err, string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lresp.LeaseTimeToLiveResponse.ID != int64(id) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("lease: renew id mismatch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lresp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readResponse(resp *http.Response) (b []byte, err error) {
0000000000000000000000000000000000000000;;		b, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		httputil.GracefulClose(resp)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
