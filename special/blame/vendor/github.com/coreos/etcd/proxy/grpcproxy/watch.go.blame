0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package grpcproxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/time/rate"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v3rpc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watchProxy struct {
0000000000000000000000000000000000000000;;		cw  clientv3.Watcher
0000000000000000000000000000000000000000;;		ctx context.Context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ranges *watchRanges
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retryLimiter controls the create watch retry rate on lost leaders.
0000000000000000000000000000000000000000;;		retryLimiter *rate.Limiter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects leaderc updates.
0000000000000000000000000000000000000000;;		mu      sync.RWMutex
0000000000000000000000000000000000000000;;		leaderc chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wg waits until all outstanding watch servers quit.
0000000000000000000000000000000000000000;;		wg sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		lostLeaderKey  = "__lostleader" // watched to detect leader loss
0000000000000000000000000000000000000000;;		retryPerSecond = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewWatchProxy(c *clientv3.Client) (pb.WatchServer, <-chan struct{}) {
0000000000000000000000000000000000000000;;		wp := &watchProxy{
0000000000000000000000000000000000000000;;			cw:           c.Watcher,
0000000000000000000000000000000000000000;;			ctx:          clientv3.WithRequireLeader(c.Ctx()),
0000000000000000000000000000000000000000;;			retryLimiter: rate.NewLimiter(rate.Limit(retryPerSecond), retryPerSecond),
0000000000000000000000000000000000000000;;			leaderc:      make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wp.ranges = newWatchRanges(wp)
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(ch)
0000000000000000000000000000000000000000;;			// a new streams without opening any watchers won't catch
0000000000000000000000000000000000000000;;			// a lost leader event, so have a special watch to monitor it
0000000000000000000000000000000000000000;;			rev := int64((uint64(1) << 63) - 2)
0000000000000000000000000000000000000000;;			for wp.ctx.Err() == nil {
0000000000000000000000000000000000000000;;				wch := wp.cw.Watch(wp.ctx, lostLeaderKey, clientv3.WithRev(rev))
0000000000000000000000000000000000000000;;				for range wch {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wp.mu.Lock()
0000000000000000000000000000000000000000;;				close(wp.leaderc)
0000000000000000000000000000000000000000;;				wp.leaderc = make(chan struct{})
0000000000000000000000000000000000000000;;				wp.mu.Unlock()
0000000000000000000000000000000000000000;;				wp.retryLimiter.Wait(wp.ctx)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wp.mu.Lock()
0000000000000000000000000000000000000000;;			<-wp.ctx.Done()
0000000000000000000000000000000000000000;;			wp.mu.Unlock()
0000000000000000000000000000000000000000;;			wp.wg.Wait()
0000000000000000000000000000000000000000;;			wp.ranges.stop()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return wp, ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wp *watchProxy) Watch(stream pb.Watch_WatchServer) (err error) {
0000000000000000000000000000000000000000;;		wp.mu.Lock()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-wp.ctx.Done():
0000000000000000000000000000000000000000;;			wp.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			wp.wg.Add(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wp.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(stream.Context())
0000000000000000000000000000000000000000;;		wps := &watchProxyStream{
0000000000000000000000000000000000000000;;			ranges:   wp.ranges,
0000000000000000000000000000000000000000;;			watchers: make(map[int64]*watcher),
0000000000000000000000000000000000000000;;			stream:   stream,
0000000000000000000000000000000000000000;;			watchCh:  make(chan *pb.WatchResponse, 1024),
0000000000000000000000000000000000000000;;			ctx:      ctx,
0000000000000000000000000000000000000000;;			cancel:   cancel,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var leaderc <-chan struct{}
0000000000000000000000000000000000000000;;		if md, ok := metadata.FromContext(stream.Context()); ok {
0000000000000000000000000000000000000000;;			v := md[rpctypes.MetadataRequireLeaderKey]
0000000000000000000000000000000000000000;;			if len(v) > 0 && v[0] == rpctypes.MetadataHasLeader {
0000000000000000000000000000000000000000;;				leaderc = wp.lostLeaderNotify()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// post to stopc => terminate server stream; can't use a waitgroup
0000000000000000000000000000000000000000;;		// since all goroutines will only terminate after Watch() exits.
0000000000000000000000000000000000000000;;		stopc := make(chan struct{}, 3)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer func() { stopc <- struct{}{} }()
0000000000000000000000000000000000000000;;			wps.recvLoop()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer func() { stopc <- struct{}{} }()
0000000000000000000000000000000000000000;;			wps.sendLoop()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// tear down watch if leader goes down or entire watch proxy is terminated
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer func() { stopc <- struct{}{} }()
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-leaderc:
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;			case <-wp.ctx.Done():
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopc
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// recv/send may only shutdown after function exits;
0000000000000000000000000000000000000000;;		// goroutine notifies proxy that stream is through
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-stopc
0000000000000000000000000000000000000000;;			<-stopc
0000000000000000000000000000000000000000;;			wps.close()
0000000000000000000000000000000000000000;;			wp.wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-leaderc:
0000000000000000000000000000000000000000;;			return rpctypes.ErrNoLeader
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return wps.ctx.Err()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wp *watchProxy) lostLeaderNotify() <-chan struct{} {
0000000000000000000000000000000000000000;;		wp.mu.RLock()
0000000000000000000000000000000000000000;;		defer wp.mu.RUnlock()
0000000000000000000000000000000000000000;;		return wp.leaderc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchProxyStream forwards etcd watch events to a proxied client stream.
0000000000000000000000000000000000000000;;	type watchProxyStream struct {
0000000000000000000000000000000000000000;;		ranges *watchRanges
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects watchers and nextWatcherID
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		// watchers receive events from watch broadcast.
0000000000000000000000000000000000000000;;		watchers map[int64]*watcher
0000000000000000000000000000000000000000;;		// nextWatcherID is the id to assign the next watcher on this stream.
0000000000000000000000000000000000000000;;		nextWatcherID int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream pb.Watch_WatchServer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// watchCh receives watch responses from the watchers.
0000000000000000000000000000000000000000;;		watchCh chan *pb.WatchResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wps *watchProxyStream) close() {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wps.cancel()
0000000000000000000000000000000000000000;;		wps.mu.Lock()
0000000000000000000000000000000000000000;;		wg.Add(len(wps.watchers))
0000000000000000000000000000000000000000;;		for _, wpsw := range wps.watchers {
0000000000000000000000000000000000000000;;			go func(w *watcher) {
0000000000000000000000000000000000000000;;				wps.ranges.delete(w)
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}(wpsw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wps.watchers = nil
0000000000000000000000000000000000000000;;		wps.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(wps.watchCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wps *watchProxyStream) recvLoop() error {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			req, err := wps.stream.Recv()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch uv := req.RequestUnion.(type) {
0000000000000000000000000000000000000000;;			case *pb.WatchRequest_CreateRequest:
0000000000000000000000000000000000000000;;				cr := uv.CreateRequest
0000000000000000000000000000000000000000;;				w := &watcher{
0000000000000000000000000000000000000000;;					wr:  watchRange{string(cr.Key), string(cr.RangeEnd)},
0000000000000000000000000000000000000000;;					id:  wps.nextWatcherID,
0000000000000000000000000000000000000000;;					wps: wps,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					nextrev:  cr.StartRevision,
0000000000000000000000000000000000000000;;					progress: cr.ProgressNotify,
0000000000000000000000000000000000000000;;					prevKV:   cr.PrevKv,
0000000000000000000000000000000000000000;;					filters:  v3rpc.FiltersFromRequest(cr),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !w.wr.valid() {
0000000000000000000000000000000000000000;;					w.post(&pb.WatchResponse{WatchId: -1, Created: true, Canceled: true})
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wps.nextWatcherID++
0000000000000000000000000000000000000000;;				w.nextrev = cr.StartRevision
0000000000000000000000000000000000000000;;				wps.watchers[w.id] = w
0000000000000000000000000000000000000000;;				wps.ranges.add(w)
0000000000000000000000000000000000000000;;			case *pb.WatchRequest_CancelRequest:
0000000000000000000000000000000000000000;;				wps.delete(uv.CancelRequest.WatchId)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("not implemented")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wps *watchProxyStream) sendLoop() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case wresp, ok := <-wps.watchCh:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := wps.stream.Send(wresp); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-wps.ctx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wps *watchProxyStream) delete(id int64) {
0000000000000000000000000000000000000000;;		wps.mu.Lock()
0000000000000000000000000000000000000000;;		defer wps.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w, ok := wps.watchers[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wps.ranges.delete(w)
0000000000000000000000000000000000000000;;		delete(wps.watchers, id)
0000000000000000000000000000000000000000;;		resp := &pb.WatchResponse{
0000000000000000000000000000000000000000;;			Header:   &w.lastHeader,
0000000000000000000000000000000000000000;;			WatchId:  id,
0000000000000000000000000000000000000000;;			Canceled: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wps.watchCh <- resp
0000000000000000000000000000000000000000;;	}
