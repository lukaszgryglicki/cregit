0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package grpcproxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/proxy/grpcproxy/cache"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kvProxy struct {
0000000000000000000000000000000000000000;;		kv    clientv3.KV
0000000000000000000000000000000000000000;;		cache cache.Cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewKvProxy(c *clientv3.Client) (pb.KVServer, <-chan struct{}) {
0000000000000000000000000000000000000000;;		kv := &kvProxy{
0000000000000000000000000000000000000000;;			kv:    c.KV,
0000000000000000000000000000000000000000;;			cache: cache.NewCache(cache.DefaultMaxEntries),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		donec := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(donec)
0000000000000000000000000000000000000000;;			<-c.Ctx().Done()
0000000000000000000000000000000000000000;;			kv.cache.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return kv, donec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *kvProxy) Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
0000000000000000000000000000000000000000;;		if r.Serializable {
0000000000000000000000000000000000000000;;			resp, err := p.cache.Get(r)
0000000000000000000000000000000000000000;;			switch err {
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				cacheHits.Inc()
0000000000000000000000000000000000000000;;				return resp, nil
0000000000000000000000000000000000000000;;			case cache.ErrCompacted:
0000000000000000000000000000000000000000;;				cacheHits.Inc()
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cachedMisses.Inc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := p.kv.Do(ctx, RangeRequestToOp(r))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cache linearizable as serializable
0000000000000000000000000000000000000000;;		req := *r
0000000000000000000000000000000000000000;;		req.Serializable = true
0000000000000000000000000000000000000000;;		gresp := (*pb.RangeResponse)(resp.Get())
0000000000000000000000000000000000000000;;		p.cache.Add(&req, gresp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gresp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *kvProxy) Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error) {
0000000000000000000000000000000000000000;;		p.cache.Invalidate(r.Key, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := p.kv.Do(ctx, PutRequestToOp(r))
0000000000000000000000000000000000000000;;		return (*pb.PutResponse)(resp.Put()), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *kvProxy) DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error) {
0000000000000000000000000000000000000000;;		p.cache.Invalidate(r.Key, r.RangeEnd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := p.kv.Do(ctx, DelRequestToOp(r))
0000000000000000000000000000000000000000;;		return (*pb.DeleteRangeResponse)(resp.Del()), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *kvProxy) txnToCache(reqs []*pb.RequestOp, resps []*pb.ResponseOp) {
0000000000000000000000000000000000000000;;		for i := range resps {
0000000000000000000000000000000000000000;;			switch tv := resps[i].Response.(type) {
0000000000000000000000000000000000000000;;			case *pb.ResponseOp_ResponsePut:
0000000000000000000000000000000000000000;;				p.cache.Invalidate(reqs[i].GetRequestPut().Key, nil)
0000000000000000000000000000000000000000;;			case *pb.ResponseOp_ResponseDeleteRange:
0000000000000000000000000000000000000000;;				rdr := reqs[i].GetRequestDeleteRange()
0000000000000000000000000000000000000000;;				p.cache.Invalidate(rdr.Key, rdr.RangeEnd)
0000000000000000000000000000000000000000;;			case *pb.ResponseOp_ResponseRange:
0000000000000000000000000000000000000000;;				req := *(reqs[i].GetRequestRange())
0000000000000000000000000000000000000000;;				req.Serializable = true
0000000000000000000000000000000000000000;;				p.cache.Add(&req, tv.ResponseRange)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *kvProxy) Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error) {
0000000000000000000000000000000000000000;;		txn := p.kv.Txn(ctx)
0000000000000000000000000000000000000000;;		cmps := make([]clientv3.Cmp, len(r.Compare))
0000000000000000000000000000000000000000;;		thenops := make([]clientv3.Op, len(r.Success))
0000000000000000000000000000000000000000;;		elseops := make([]clientv3.Op, len(r.Failure))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range r.Compare {
0000000000000000000000000000000000000000;;			cmps[i] = (clientv3.Cmp)(*r.Compare[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range r.Success {
0000000000000000000000000000000000000000;;			thenops[i] = requestOpToOp(r.Success[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range r.Failure {
0000000000000000000000000000000000000000;;			elseops[i] = requestOpToOp(r.Failure[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := txn.If(cmps...).Then(thenops...).Else(elseops...).Commit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// txn may claim an outdated key is updated; be safe and invalidate
0000000000000000000000000000000000000000;;		for _, cmp := range r.Compare {
0000000000000000000000000000000000000000;;			p.cache.Invalidate(cmp.Key, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update any fetched keys
0000000000000000000000000000000000000000;;		if resp.Succeeded {
0000000000000000000000000000000000000000;;			p.txnToCache(r.Success, resp.Responses)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.txnToCache(r.Failure, resp.Responses)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return (*pb.TxnResponse)(resp), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *kvProxy) Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error) {
0000000000000000000000000000000000000000;;		var opts []clientv3.CompactOption
0000000000000000000000000000000000000000;;		if r.Physical {
0000000000000000000000000000000000000000;;			opts = append(opts, clientv3.WithCompactPhysical())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := p.kv.Compact(ctx, r.Revision, opts...)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			p.cache.Compact(r.Revision)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return (*pb.CompactionResponse)(resp), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func requestOpToOp(union *pb.RequestOp) clientv3.Op {
0000000000000000000000000000000000000000;;		switch tv := union.Request.(type) {
0000000000000000000000000000000000000000;;		case *pb.RequestOp_RequestRange:
0000000000000000000000000000000000000000;;			if tv.RequestRange != nil {
0000000000000000000000000000000000000000;;				return RangeRequestToOp(tv.RequestRange)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *pb.RequestOp_RequestPut:
0000000000000000000000000000000000000000;;			if tv.RequestPut != nil {
0000000000000000000000000000000000000000;;				return PutRequestToOp(tv.RequestPut)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *pb.RequestOp_RequestDeleteRange:
0000000000000000000000000000000000000000;;			if tv.RequestDeleteRange != nil {
0000000000000000000000000000000000000000;;				return DelRequestToOp(tv.RequestDeleteRange)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unknown request")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RangeRequestToOp(r *pb.RangeRequest) clientv3.Op {
0000000000000000000000000000000000000000;;		opts := []clientv3.OpOption{}
0000000000000000000000000000000000000000;;		if len(r.RangeEnd) != 0 {
0000000000000000000000000000000000000000;;			opts = append(opts, clientv3.WithRange(string(r.RangeEnd)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithRev(r.Revision))
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithLimit(r.Limit))
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithSort(
0000000000000000000000000000000000000000;;			clientv3.SortTarget(r.SortTarget),
0000000000000000000000000000000000000000;;			clientv3.SortOrder(r.SortOrder)),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithMaxCreateRev(r.MaxCreateRevision))
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithMinCreateRev(r.MinCreateRevision))
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithMaxModRev(r.MaxModRevision))
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithMinModRev(r.MinModRevision))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Serializable {
0000000000000000000000000000000000000000;;			opts = append(opts, clientv3.WithSerializable())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientv3.OpGet(string(r.Key), opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PutRequestToOp(r *pb.PutRequest) clientv3.Op {
0000000000000000000000000000000000000000;;		opts := []clientv3.OpOption{}
0000000000000000000000000000000000000000;;		opts = append(opts, clientv3.WithLease(clientv3.LeaseID(r.Lease)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientv3.OpPut(string(r.Key), string(r.Value), opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DelRequestToOp(r *pb.DeleteRangeRequest) clientv3.Op {
0000000000000000000000000000000000000000;;		opts := []clientv3.OpOption{}
0000000000000000000000000000000000000000;;		if len(r.RangeEnd) != 0 {
0000000000000000000000000000000000000000;;			opts = append(opts, clientv3.WithRange(string(r.RangeEnd)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.PrevKv {
0000000000000000000000000000000000000000;;			opts = append(opts, clientv3.WithPrevKV())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientv3.OpDelete(string(r.Key), opts...)
0000000000000000000000000000000000000000;;	}
