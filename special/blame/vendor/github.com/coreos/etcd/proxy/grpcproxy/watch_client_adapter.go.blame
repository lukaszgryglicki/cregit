0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package grpcproxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errAlreadySentHeader = errors.New("grpcproxy: already send header")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ws2wc struct{ wserv pb.WatchServer }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WatchServerToWatchClient(wserv pb.WatchServer) pb.WatchClient {
0000000000000000000000000000000000000000;;		return &ws2wc{wserv}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ws2wc) Watch(ctx context.Context, opts ...grpc.CallOption) (pb.Watch_WatchClient, error) {
0000000000000000000000000000000000000000;;		// ch1 is buffered so server can send error on close
0000000000000000000000000000000000000000;;		ch1, ch2 := make(chan interface{}, 1), make(chan interface{})
0000000000000000000000000000000000000000;;		headerc, trailerc := make(chan metadata.MD, 1), make(chan metadata.MD, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cctx, ccancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		cli := &chanStream{recvc: ch1, sendc: ch2, ctx: cctx, cancel: ccancel}
0000000000000000000000000000000000000000;;		wclient := &ws2wcClientStream{chanClientStream{headerc, trailerc, cli}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sctx, scancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		srv := &chanStream{recvc: ch2, sendc: ch1, ctx: sctx, cancel: scancel}
0000000000000000000000000000000000000000;;		wserver := &ws2wcServerStream{chanServerStream{headerc, trailerc, srv, nil}}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			if err := s.wserv.Watch(wserver); err != nil {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case srv.sendc <- err:
0000000000000000000000000000000000000000;;				case <-sctx.Done():
0000000000000000000000000000000000000000;;				case <-cctx.Done():
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			scancel()
0000000000000000000000000000000000000000;;			ccancel()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return wclient, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ws2wcClientStream implements Watch_WatchClient
0000000000000000000000000000000000000000;;	type ws2wcClientStream struct{ chanClientStream }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ws2wcServerStream implements Watch_WatchServer
0000000000000000000000000000000000000000;;	type ws2wcServerStream struct{ chanServerStream }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ws2wcClientStream) Send(wr *pb.WatchRequest) error {
0000000000000000000000000000000000000000;;		return s.SendMsg(wr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s *ws2wcClientStream) Recv() (*pb.WatchResponse, error) {
0000000000000000000000000000000000000000;;		var v interface{}
0000000000000000000000000000000000000000;;		if err := s.RecvMsg(&v); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.(*pb.WatchResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ws2wcServerStream) Send(wr *pb.WatchResponse) error {
0000000000000000000000000000000000000000;;		return s.SendMsg(wr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s *ws2wcServerStream) Recv() (*pb.WatchRequest, error) {
0000000000000000000000000000000000000000;;		var v interface{}
0000000000000000000000000000000000000000;;		if err := s.RecvMsg(&v); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.(*pb.WatchRequest), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// chanServerStream implements grpc.ServerStream with a chanStream
0000000000000000000000000000000000000000;;	type chanServerStream struct {
0000000000000000000000000000000000000000;;		headerc  chan<- metadata.MD
0000000000000000000000000000000000000000;;		trailerc chan<- metadata.MD
0000000000000000000000000000000000000000;;		grpc.Stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers []metadata.MD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *chanServerStream) SendHeader(md metadata.MD) error {
0000000000000000000000000000000000000000;;		if ss.headerc == nil {
0000000000000000000000000000000000000000;;			return errAlreadySentHeader
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outmd := make(map[string][]string)
0000000000000000000000000000000000000000;;		for _, h := range append(ss.headers, md) {
0000000000000000000000000000000000000000;;			for k, v := range h {
0000000000000000000000000000000000000000;;				outmd[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case ss.headerc <- outmd:
0000000000000000000000000000000000000000;;			ss.headerc = nil
0000000000000000000000000000000000000000;;			ss.headers = nil
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-ss.Context().Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ss.Context().Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *chanServerStream) SetHeader(md metadata.MD) error {
0000000000000000000000000000000000000000;;		if ss.headerc == nil {
0000000000000000000000000000000000000000;;			return errAlreadySentHeader
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.headers = append(ss.headers, md)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *chanServerStream) SetTrailer(md metadata.MD) {
0000000000000000000000000000000000000000;;		ss.trailerc <- md
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// chanClientStream implements grpc.ClientStream with a chanStream
0000000000000000000000000000000000000000;;	type chanClientStream struct {
0000000000000000000000000000000000000000;;		headerc  <-chan metadata.MD
0000000000000000000000000000000000000000;;		trailerc <-chan metadata.MD
0000000000000000000000000000000000000000;;		*chanStream
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *chanClientStream) Header() (metadata.MD, error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case md := <-cs.headerc:
0000000000000000000000000000000000000000;;			return md, nil
0000000000000000000000000000000000000000;;		case <-cs.Context().Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, cs.Context().Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *chanClientStream) Trailer() metadata.MD {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case md := <-cs.trailerc:
0000000000000000000000000000000000000000;;			return md
0000000000000000000000000000000000000000;;		case <-cs.Context().Done():
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *chanClientStream) CloseSend() error {
0000000000000000000000000000000000000000;;		close(s.chanStream.sendc)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// chanStream implements grpc.Stream using channels
0000000000000000000000000000000000000000;;	type chanStream struct {
0000000000000000000000000000000000000000;;		recvc  <-chan interface{}
0000000000000000000000000000000000000000;;		sendc  chan<- interface{}
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *chanStream) Context() context.Context { return s.ctx }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *chanStream) SendMsg(m interface{}) error {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case s.sendc <- m:
0000000000000000000000000000000000000000;;			if err, ok := m.(error); ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-s.ctx.Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.ctx.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *chanStream) RecvMsg(m interface{}) error {
0000000000000000000000000000000000000000;;		v := m.(*interface{})
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case msg, ok := <-s.recvc:
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return grpc.ErrClientConnClosing
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err, ok := msg.(error); ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*v = msg
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-s.ctx.Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.ctx.Err()
0000000000000000000000000000000000000000;;	}
