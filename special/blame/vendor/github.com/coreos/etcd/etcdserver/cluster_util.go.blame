0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/cluster_util.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/cluster_util.go][vendor/github.com/coreos/etcd/etcdserver/cluster_util.go];	
0000000000000000000000000000000000000000;;	package etcdserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/membership"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/httputil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/version"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isMemberBootstrapped tries to check if the given member has been bootstrapped
0000000000000000000000000000000000000000;;	// in the given cluster.
0000000000000000000000000000000000000000;;	func isMemberBootstrapped(cl *membership.RaftCluster, member string, rt http.RoundTripper, timeout time.Duration) bool {
0000000000000000000000000000000000000000;;		rcl, err := getClusterFromRemotePeers(getRemotePeerURLs(cl, member), timeout, false, rt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id := cl.MemberByName(member).ID
0000000000000000000000000000000000000000;;		m := rcl.Member(id)
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(m.ClientURLs) > 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetClusterFromRemotePeers takes a set of URLs representing etcd peers, and
0000000000000000000000000000000000000000;;	// attempts to construct a Cluster by accessing the members endpoint on one of
0000000000000000000000000000000000000000;;	// these URLs. The first URL to provide a response is used. If no URLs provide
0000000000000000000000000000000000000000;;	// a response, or a Cluster cannot be successfully created from a received
0000000000000000000000000000000000000000;;	// response, an error is returned.
0000000000000000000000000000000000000000;;	// Each request has a 10-second timeout. Because the upper limit of TTL is 5s,
0000000000000000000000000000000000000000;;	// 10 second is enough for building connection and finishing request.
0000000000000000000000000000000000000000;;	func GetClusterFromRemotePeers(urls []string, rt http.RoundTripper) (*membership.RaftCluster, error) {
0000000000000000000000000000000000000000;;		return getClusterFromRemotePeers(urls, 10*time.Second, true, rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If logerr is true, it prints out more error messages.
0000000000000000000000000000000000000000;;	func getClusterFromRemotePeers(urls []string, timeout time.Duration, logerr bool, rt http.RoundTripper) (*membership.RaftCluster, error) {
0000000000000000000000000000000000000000;;		cc := &http.Client{
0000000000000000000000000000000000000000;;			Transport: rt,
0000000000000000000000000000000000000000;;			Timeout:   timeout,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, u := range urls {
0000000000000000000000000000000000000000;;			resp, err := cc.Get(u + "/members")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if logerr {
0000000000000000000000000000000000000000;;					plog.Warningf("could not get cluster response from %s: %v", u, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if logerr {
0000000000000000000000000000000000000000;;					plog.Warningf("could not read the body of cluster response: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var membs []*membership.Member
0000000000000000000000000000000000000000;;			if err = json.Unmarshal(b, &membs); err != nil {
0000000000000000000000000000000000000000;;				if logerr {
0000000000000000000000000000000000000000;;					plog.Warningf("could not unmarshal cluster response: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			id, err := types.IDFromString(resp.Header.Get("X-Etcd-Cluster-ID"))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if logerr {
0000000000000000000000000000000000000000;;					plog.Warningf("could not parse the cluster ID from cluster res: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check the length of membership members
0000000000000000000000000000000000000000;;			// if the membership members are present then prepare and return raft cluster
0000000000000000000000000000000000000000;;			// if membership members are not present then the raft cluster formed will be
0000000000000000000000000000000000000000;;			// an invalid empty cluster hence return failed to get raft cluster member(s) from the given urls error
0000000000000000000000000000000000000000;;			if len(membs) > 0 {
0000000000000000000000000000000000000000;;				return membership.NewClusterFromMembers("", id, membs), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get raft cluster member(s) from the given urls.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("could not retrieve cluster information from the given urls")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRemotePeerURLs returns peer urls of remote members in the cluster. The
0000000000000000000000000000000000000000;;	// returned list is sorted in ascending lexicographical order.
0000000000000000000000000000000000000000;;	func getRemotePeerURLs(cl *membership.RaftCluster, local string) []string {
0000000000000000000000000000000000000000;;		us := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, m := range cl.Members() {
0000000000000000000000000000000000000000;;			if m.Name == local {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			us = append(us, m.PeerURLs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(us)
0000000000000000000000000000000000000000;;		return us
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getVersions returns the versions of the members in the given cluster.
0000000000000000000000000000000000000000;;	// The key of the returned map is the member's ID. The value of the returned map
0000000000000000000000000000000000000000;;	// is the semver versions string, including server and cluster.
0000000000000000000000000000000000000000;;	// If it fails to get the version of a member, the key will be nil.
0000000000000000000000000000000000000000;;	func getVersions(cl *membership.RaftCluster, local types.ID, rt http.RoundTripper) map[string]*version.Versions {
0000000000000000000000000000000000000000;;		members := cl.Members()
0000000000000000000000000000000000000000;;		vers := make(map[string]*version.Versions)
0000000000000000000000000000000000000000;;		for _, m := range members {
0000000000000000000000000000000000000000;;			if m.ID == local {
0000000000000000000000000000000000000000;;				cv := "not_decided"
0000000000000000000000000000000000000000;;				if cl.Version() != nil {
0000000000000000000000000000000000000000;;					cv = cl.Version().String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				vers[m.ID.String()] = &version.Versions{Server: version.Version, Cluster: cv}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ver, err := getVersion(m, rt)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("cannot get the version of member %s (%v)", m.ID, err)
0000000000000000000000000000000000000000;;				vers[m.ID.String()] = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vers[m.ID.String()] = ver
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decideClusterVersion decides the cluster version based on the versions map.
0000000000000000000000000000000000000000;;	// The returned version is the min server version in the map, or nil if the min
0000000000000000000000000000000000000000;;	// version in unknown.
0000000000000000000000000000000000000000;;	func decideClusterVersion(vers map[string]*version.Versions) *semver.Version {
0000000000000000000000000000000000000000;;		var cv *semver.Version
0000000000000000000000000000000000000000;;		lv := semver.Must(semver.NewVersion(version.Version))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for mid, ver := range vers {
0000000000000000000000000000000000000000;;			if ver == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v, err := semver.NewVersion(ver.Server)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("cannot understand the version of member %s (%v)", mid, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lv.LessThan(*v) {
0000000000000000000000000000000000000000;;				plog.Warningf("the local etcd version %s is not up-to-date", lv.String())
0000000000000000000000000000000000000000;;				plog.Warningf("member %s has a higher version %s", mid, ver.Server)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cv == nil {
0000000000000000000000000000000000000000;;				cv = v
0000000000000000000000000000000000000000;;			} else if v.LessThan(*cv) {
0000000000000000000000000000000000000000;;				cv = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isCompatibleWithCluster return true if the local member has a compatible version with
0000000000000000000000000000000000000000;;	// the current running cluster.
0000000000000000000000000000000000000000;;	// The version is considered as compatible when at least one of the other members in the cluster has a
0000000000000000000000000000000000000000;;	// cluster version in the range of [MinClusterVersion, Version] and no known members has a cluster version
0000000000000000000000000000000000000000;;	// out of the range.
0000000000000000000000000000000000000000;;	// We set this rule since when the local member joins, another member might be offline.
0000000000000000000000000000000000000000;;	func isCompatibleWithCluster(cl *membership.RaftCluster, local types.ID, rt http.RoundTripper) bool {
0000000000000000000000000000000000000000;;		vers := getVersions(cl, local, rt)
0000000000000000000000000000000000000000;;		minV := semver.Must(semver.NewVersion(version.MinClusterVersion))
0000000000000000000000000000000000000000;;		maxV := semver.Must(semver.NewVersion(version.Version))
0000000000000000000000000000000000000000;;		maxV = &semver.Version{
0000000000000000000000000000000000000000;;			Major: maxV.Major,
0000000000000000000000000000000000000000;;			Minor: maxV.Minor,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return isCompatibleWithVers(vers, local, minV, maxV)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isCompatibleWithVers(vers map[string]*version.Versions, local types.ID, minV, maxV *semver.Version) bool {
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		for id, v := range vers {
0000000000000000000000000000000000000000;;			// ignore comparison with local version
0000000000000000000000000000000000000000;;			if id == local.String() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clusterv, err := semver.NewVersion(v.Cluster)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("cannot understand the cluster version of member %s (%v)", id, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if clusterv.LessThan(*minV) {
0000000000000000000000000000000000000000;;				plog.Warningf("the running cluster version(%v) is lower than the minimal cluster version(%v) supported", clusterv.String(), minV.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if maxV.LessThan(*clusterv) {
0000000000000000000000000000000000000000;;				plog.Warningf("the running cluster version(%v) is higher than the maximum cluster version(%v) supported", clusterv.String(), maxV.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ok = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getVersion returns the Versions of the given member via its
0000000000000000000000000000000000000000;;	// peerURLs. Returns the last error if it fails to get the version.
0000000000000000000000000000000000000000;;	func getVersion(m *membership.Member, rt http.RoundTripper) (*version.Versions, error) {
0000000000000000000000000000000000000000;;		cc := &http.Client{
0000000000000000000000000000000000000000;;			Transport: rt,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;			resp *http.Response
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, u := range m.PeerURLs {
0000000000000000000000000000000000000000;;			resp, err = cc.Get(u + "/version")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("failed to reach the peerURL(%s) of member %s (%v)", u, m.ID, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// etcd 2.0 does not have version endpoint on peer url.
0000000000000000000000000000000000000000;;			if resp.StatusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;				httputil.GracefulClose(resp)
0000000000000000000000000000000000000000;;				return &version.Versions{
0000000000000000000000000000000000000000;;					Server:  "2.0.0",
0000000000000000000000000000000000000000;;					Cluster: "2.0.0",
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var b []byte
0000000000000000000000000000000000000000;;			b, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("failed to read out the response body from the peerURL(%s) of member %s (%v)", u, m.ID, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var vers version.Versions
0000000000000000000000000000000000000000;;			if err = json.Unmarshal(b, &vers); err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("failed to unmarshal the response body got from the peerURL(%s) of member %s (%v)", u, m.ID, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &vers, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
