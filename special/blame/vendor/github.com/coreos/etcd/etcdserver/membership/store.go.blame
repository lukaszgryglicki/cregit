0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/member.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/member.go][vendor/github.com/coreos/etcd/etcdserver/membership/store.go];	
0000000000000000000000000000000000000000;;	package membership
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/store"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		attributesSuffix     = "attributes"
0000000000000000000000000000000000000000;;		raftAttributesSuffix = "raftAttributes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the prefix for stroing membership related information in store provided by store pkg.
0000000000000000000000000000000000000000;;		storePrefix = "/0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		membersBucketName        = []byte("members")
0000000000000000000000000000000000000000;;		membersRemovedBuckedName = []byte("members_removed")
0000000000000000000000000000000000000000;;		clusterBucketName        = []byte("cluster")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		StoreMembersPrefix        = path.Join(storePrefix, "members")
0000000000000000000000000000000000000000;;		storeRemovedMembersPrefix = path.Join(storePrefix, "removed_members")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustSaveMemberToBackend(be backend.Backend, m *Member) {
0000000000000000000000000000000000000000;;		mkey := backendMemberKey(m.ID)
0000000000000000000000000000000000000000;;		mvalue, err := json.Marshal(m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("marshal raftAttributes should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		tx.UnsafePut(membersBucketName, mkey, mvalue)
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustDeleteMemberFromBackend(be backend.Backend, id types.ID) {
0000000000000000000000000000000000000000;;		mkey := backendMemberKey(id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		tx.UnsafeDelete(membersBucketName, mkey)
0000000000000000000000000000000000000000;;		tx.UnsafePut(membersRemovedBuckedName, mkey, []byte("removed"))
0000000000000000000000000000000000000000;;		tx.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustSaveClusterVersionToBackend(be backend.Backend, ver *semver.Version) {
0000000000000000000000000000000000000000;;		ckey := backendClusterVersionKey()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tx := be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;		tx.UnsafePut(clusterBucketName, ckey, []byte(ver.String()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustSaveMemberToStore(s store.Store, m *Member) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(m.RaftAttributes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("marshal raftAttributes should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := path.Join(MemberStoreKey(m.ID), raftAttributesSuffix)
0000000000000000000000000000000000000000;;		if _, err := s.Create(p, false, string(b), false, store.TTLOptionSet{ExpireTime: store.Permanent}); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("create raftAttributes should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustDeleteMemberFromStore(s store.Store, id types.ID) {
0000000000000000000000000000000000000000;;		if _, err := s.Delete(MemberStoreKey(id), true, true); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("delete member should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := s.Create(RemovedMemberStoreKey(id), false, "", false, store.TTLOptionSet{ExpireTime: store.Permanent}); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("create removedMember should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustUpdateMemberInStore(s store.Store, m *Member) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(m.RaftAttributes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("marshal raftAttributes should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := path.Join(MemberStoreKey(m.ID), raftAttributesSuffix)
0000000000000000000000000000000000000000;;		if _, err := s.Update(p, string(b), store.TTLOptionSet{ExpireTime: store.Permanent}); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("update raftAttributes should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustUpdateMemberAttrInStore(s store.Store, m *Member) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(m.Attributes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("marshal raftAttributes should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := path.Join(MemberStoreKey(m.ID), attributesSuffix)
0000000000000000000000000000000000000000;;		if _, err := s.Set(p, false, string(b), store.TTLOptionSet{ExpireTime: store.Permanent}); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("update raftAttributes should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustSaveClusterVersionToStore(s store.Store, ver *semver.Version) {
0000000000000000000000000000000000000000;;		if _, err := s.Set(StoreClusterVersionKey(), false, ver.String(), store.TTLOptionSet{ExpireTime: store.Permanent}); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("save cluster version should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeToMember builds member from a key value node.
0000000000000000000000000000000000000000;;	// the child nodes of the given node MUST be sorted by key.
0000000000000000000000000000000000000000;;	func nodeToMember(n *store.NodeExtern) (*Member, error) {
0000000000000000000000000000000000000000;;		m := &Member{ID: MustParseMemberIDFromKey(n.Key)}
0000000000000000000000000000000000000000;;		attrs := make(map[string][]byte)
0000000000000000000000000000000000000000;;		raftAttrKey := path.Join(n.Key, raftAttributesSuffix)
0000000000000000000000000000000000000000;;		attrKey := path.Join(n.Key, attributesSuffix)
0000000000000000000000000000000000000000;;		for _, nn := range n.Nodes {
0000000000000000000000000000000000000000;;			if nn.Key != raftAttrKey && nn.Key != attrKey {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unknown key %q", nn.Key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attrs[nn.Key] = []byte(*nn.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if data := attrs[raftAttrKey]; data != nil {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &m.RaftAttributes); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unmarshal raftAttributes error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("raftAttributes key doesn't exist")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if data := attrs[attrKey]; data != nil {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &m.Attributes); err != nil {
0000000000000000000000000000000000000000;;				return m, fmt.Errorf("unmarshal attributes error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func backendMemberKey(id types.ID) []byte {
0000000000000000000000000000000000000000;;		return []byte(id.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func backendClusterVersionKey() []byte {
0000000000000000000000000000000000000000;;		return []byte("clusterVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustCreateBackendBuckets(be backend.Backend) {
0000000000000000000000000000000000000000;;		tx := be.BatchTx()
0000000000000000000000000000000000000000;;		tx.Lock()
0000000000000000000000000000000000000000;;		defer tx.Unlock()
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(membersBucketName)
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(membersRemovedBuckedName)
0000000000000000000000000000000000000000;;		tx.UnsafeCreateBucket(clusterBucketName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MemberStoreKey(id types.ID) string {
0000000000000000000000000000000000000000;;		return path.Join(StoreMembersPrefix, id.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StoreClusterVersionKey() string {
0000000000000000000000000000000000000000;;		return path.Join(storePrefix, "version")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MemberAttributesStorePath(id types.ID) string {
0000000000000000000000000000000000000000;;		return path.Join(MemberStoreKey(id), attributesSuffix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MustParseMemberIDFromKey(key string) types.ID {
0000000000000000000000000000000000000000;;		id, err := types.IDFromString(path.Base(key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("unexpected parse member id error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RemovedMemberStoreKey(id types.ID) string {
0000000000000000000000000000000000000000;;		return path.Join(storeRemovedMembersPrefix, id.String())
0000000000000000000000000000000000000000;;	}
