0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/cluster.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/cluster.go][vendor/github.com/coreos/etcd/etcdserver/membership/cluster.go];	
0000000000000000000000000000000000000000;;	package membership
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/netutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/store"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/version"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RaftCluster is a list of Members that belong to the same raft cluster
0000000000000000000000000000000000000000;;	type RaftCluster struct {
0000000000000000000000000000000000000000;;		id    types.ID
0000000000000000000000000000000000000000;;		token string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		store store.Store
0000000000000000000000000000000000000000;;		be    backend.Backend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sync.Mutex // guards the fields below
0000000000000000000000000000000000000000;;		version    *semver.Version
0000000000000000000000000000000000000000;;		members    map[types.ID]*Member
0000000000000000000000000000000000000000;;		// removed contains the ids of removed members in the cluster.
0000000000000000000000000000000000000000;;		// removed id cannot be reused.
0000000000000000000000000000000000000000;;		removed map[types.ID]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClusterFromURLsMap(token string, urlsmap types.URLsMap) (*RaftCluster, error) {
0000000000000000000000000000000000000000;;		c := NewCluster(token)
0000000000000000000000000000000000000000;;		for name, urls := range urlsmap {
0000000000000000000000000000000000000000;;			m := NewMember(name, urls, token, nil)
0000000000000000000000000000000000000000;;			if _, ok := c.members[m.ID]; ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("member exists with identical ID %v", m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if uint64(m.ID) == raft.None {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot use %x as member id", raft.None)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.members[m.ID] = m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.genID()
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClusterFromMembers(token string, id types.ID, membs []*Member) *RaftCluster {
0000000000000000000000000000000000000000;;		c := NewCluster(token)
0000000000000000000000000000000000000000;;		c.id = id
0000000000000000000000000000000000000000;;		for _, m := range membs {
0000000000000000000000000000000000000000;;			c.members[m.ID] = m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCluster(token string) *RaftCluster {
0000000000000000000000000000000000000000;;		return &RaftCluster{
0000000000000000000000000000000000000000;;			token:   token,
0000000000000000000000000000000000000000;;			members: make(map[types.ID]*Member),
0000000000000000000000000000000000000000;;			removed: make(map[types.ID]bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) ID() types.ID { return c.id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) Members() []*Member {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		var ms MembersByID
0000000000000000000000000000000000000000;;		for _, m := range c.members {
0000000000000000000000000000000000000000;;			ms = append(ms, m.Clone())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(ms)
0000000000000000000000000000000000000000;;		return []*Member(ms)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) Member(id types.ID) *Member {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		return c.members[id].Clone()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MemberByName returns a Member with the given name if exists.
0000000000000000000000000000000000000000;;	// If more than one member has the given name, it will panic.
0000000000000000000000000000000000000000;;	func (c *RaftCluster) MemberByName(name string) *Member {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		var memb *Member
0000000000000000000000000000000000000000;;		for _, m := range c.members {
0000000000000000000000000000000000000000;;			if m.Name == name {
0000000000000000000000000000000000000000;;				if memb != nil {
0000000000000000000000000000000000000000;;					plog.Panicf("two members with the given name %q exist", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				memb = m
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return memb.Clone()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) MemberIDs() []types.ID {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		var ids []types.ID
0000000000000000000000000000000000000000;;		for _, m := range c.members {
0000000000000000000000000000000000000000;;			ids = append(ids, m.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(types.IDSlice(ids))
0000000000000000000000000000000000000000;;		return ids
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) IsIDRemoved(id types.ID) bool {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		return c.removed[id]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PeerURLs returns a list of all peer addresses.
0000000000000000000000000000000000000000;;	// The returned list is sorted in ascending lexicographical order.
0000000000000000000000000000000000000000;;	func (c *RaftCluster) PeerURLs() []string {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		urls := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, p := range c.members {
0000000000000000000000000000000000000000;;			urls = append(urls, p.PeerURLs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(urls)
0000000000000000000000000000000000000000;;		return urls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientURLs returns a list of all client addresses.
0000000000000000000000000000000000000000;;	// The returned list is sorted in ascending lexicographical order.
0000000000000000000000000000000000000000;;	func (c *RaftCluster) ClientURLs() []string {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		urls := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, p := range c.members {
0000000000000000000000000000000000000000;;			urls = append(urls, p.ClientURLs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(urls)
0000000000000000000000000000000000000000;;		return urls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) String() string {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		fmt.Fprintf(b, "{ClusterID:%s ", c.id)
0000000000000000000000000000000000000000;;		var ms []string
0000000000000000000000000000000000000000;;		for _, m := range c.members {
0000000000000000000000000000000000000000;;			ms = append(ms, fmt.Sprintf("%+v", m))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(b, "Members:[%s] ", strings.Join(ms, " "))
0000000000000000000000000000000000000000;;		var ids []string
0000000000000000000000000000000000000000;;		for id := range c.removed {
0000000000000000000000000000000000000000;;			ids = append(ids, fmt.Sprintf("%s", id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(b, "RemovedMemberIDs:[%s]}", strings.Join(ids, " "))
0000000000000000000000000000000000000000;;		return b.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) genID() {
0000000000000000000000000000000000000000;;		mIDs := c.MemberIDs()
0000000000000000000000000000000000000000;;		b := make([]byte, 8*len(mIDs))
0000000000000000000000000000000000000000;;		for i, id := range mIDs {
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint64(b[8*i:], uint64(id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := sha1.Sum(b)
0000000000000000000000000000000000000000;;		c.id = types.ID(binary.BigEndian.Uint64(hash[:8]))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) SetID(id types.ID) { c.id = id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) SetStore(st store.Store) { c.store = st }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) SetBackend(be backend.Backend) {
0000000000000000000000000000000000000000;;		c.be = be
0000000000000000000000000000000000000000;;		mustCreateBackendBuckets(c.be)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) Recover(onSet func(*semver.Version)) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.members, c.removed = membersFromStore(c.store)
0000000000000000000000000000000000000000;;		c.version = clusterVersionFromStore(c.store)
0000000000000000000000000000000000000000;;		mustDetectDowngrade(c.version)
0000000000000000000000000000000000000000;;		onSet(c.version)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, m := range c.members {
0000000000000000000000000000000000000000;;			plog.Infof("added member %s %v to cluster %s from store", m.ID, m.PeerURLs, c.id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.version != nil {
0000000000000000000000000000000000000000;;			plog.Infof("set the cluster version to %v from store", version.Cluster(c.version.String()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateConfigurationChange takes a proposed ConfChange and
0000000000000000000000000000000000000000;;	// ensures that it is still valid.
0000000000000000000000000000000000000000;;	func (c *RaftCluster) ValidateConfigurationChange(cc raftpb.ConfChange) error {
0000000000000000000000000000000000000000;;		members, removed := membersFromStore(c.store)
0000000000000000000000000000000000000000;;		id := types.ID(cc.NodeID)
0000000000000000000000000000000000000000;;		if removed[id] {
0000000000000000000000000000000000000000;;			return ErrIDRemoved
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch cc.Type {
0000000000000000000000000000000000000000;;		case raftpb.ConfChangeAddNode:
0000000000000000000000000000000000000000;;			if members[id] != nil {
0000000000000000000000000000000000000000;;				return ErrIDExists
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			urls := make(map[string]bool)
0000000000000000000000000000000000000000;;			for _, m := range members {
0000000000000000000000000000000000000000;;				for _, u := range m.PeerURLs {
0000000000000000000000000000000000000000;;					urls[u] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m := new(Member)
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(cc.Context, m); err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("unmarshal member should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, u := range m.PeerURLs {
0000000000000000000000000000000000000000;;				if urls[u] {
0000000000000000000000000000000000000000;;					return ErrPeerURLexists
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case raftpb.ConfChangeRemoveNode:
0000000000000000000000000000000000000000;;			if members[id] == nil {
0000000000000000000000000000000000000000;;				return ErrIDNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case raftpb.ConfChangeUpdateNode:
0000000000000000000000000000000000000000;;			if members[id] == nil {
0000000000000000000000000000000000000000;;				return ErrIDNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			urls := make(map[string]bool)
0000000000000000000000000000000000000000;;			for _, m := range members {
0000000000000000000000000000000000000000;;				if m.ID == id {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, u := range m.PeerURLs {
0000000000000000000000000000000000000000;;					urls[u] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m := new(Member)
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(cc.Context, m); err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("unmarshal member should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, u := range m.PeerURLs {
0000000000000000000000000000000000000000;;				if urls[u] {
0000000000000000000000000000000000000000;;					return ErrPeerURLexists
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			plog.Panicf("ConfChange type should be either AddNode, RemoveNode or UpdateNode")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddMember adds a new Member into the cluster, and saves the given member's
0000000000000000000000000000000000000000;;	// raftAttributes into the store. The given member should have empty attributes.
0000000000000000000000000000000000000000;;	// A Member with a matching id must not exist.
0000000000000000000000000000000000000000;;	func (c *RaftCluster) AddMember(m *Member) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		if c.store != nil {
0000000000000000000000000000000000000000;;			mustSaveMemberToStore(c.store, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.be != nil {
0000000000000000000000000000000000000000;;			mustSaveMemberToBackend(c.be, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.members[m.ID] = m
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("added member %s %v to cluster %s", m.ID, m.PeerURLs, c.id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveMember removes a member from the store.
0000000000000000000000000000000000000000;;	// The given id MUST exist, or the function panics.
0000000000000000000000000000000000000000;;	func (c *RaftCluster) RemoveMember(id types.ID) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		if c.store != nil {
0000000000000000000000000000000000000000;;			mustDeleteMemberFromStore(c.store, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.be != nil {
0000000000000000000000000000000000000000;;			mustDeleteMemberFromBackend(c.be, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(c.members, id)
0000000000000000000000000000000000000000;;		c.removed[id] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("removed member %s from cluster %s", id, c.id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) UpdateAttributes(id types.ID, attr Attributes) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		if m, ok := c.members[id]; ok {
0000000000000000000000000000000000000000;;			m.Attributes = attr
0000000000000000000000000000000000000000;;			if c.store != nil {
0000000000000000000000000000000000000000;;				mustUpdateMemberAttrInStore(c.store, m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.be != nil {
0000000000000000000000000000000000000000;;				mustSaveMemberToBackend(c.be, m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := c.removed[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			plog.Panicf("error updating attributes of unknown member %s", id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Warningf("skipped updating attributes of removed member %s", id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) UpdateRaftAttributes(id types.ID, raftAttr RaftAttributes) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.members[id].RaftAttributes = raftAttr
0000000000000000000000000000000000000000;;		if c.store != nil {
0000000000000000000000000000000000000000;;			mustUpdateMemberInStore(c.store, c.members[id])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.be != nil {
0000000000000000000000000000000000000000;;			mustSaveMemberToBackend(c.be, c.members[id])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("updated member %s %v in cluster %s", id, raftAttr.PeerURLs, c.id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) Version() *semver.Version {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		if c.version == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return semver.Must(semver.NewVersion(c.version.String()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) SetVersion(ver *semver.Version, onSet func(*semver.Version)) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		if c.version != nil {
0000000000000000000000000000000000000000;;			plog.Noticef("updated the cluster version from %v to %v", version.Cluster(c.version.String()), version.Cluster(ver.String()))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			plog.Noticef("set the initial cluster version to %v", version.Cluster(ver.String()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.version = ver
0000000000000000000000000000000000000000;;		mustDetectDowngrade(c.version)
0000000000000000000000000000000000000000;;		if c.store != nil {
0000000000000000000000000000000000000000;;			mustSaveClusterVersionToStore(c.store, ver)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.be != nil {
0000000000000000000000000000000000000000;;			mustSaveClusterVersionToBackend(c.be, ver)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		onSet(ver)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) IsReadyToAddNewMember() bool {
0000000000000000000000000000000000000000;;		nmembers := 1
0000000000000000000000000000000000000000;;		nstarted := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, member := range c.members {
0000000000000000000000000000000000000000;;			if member.IsStarted() {
0000000000000000000000000000000000000000;;				nstarted++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nmembers++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nstarted == 1 && nmembers == 2 {
0000000000000000000000000000000000000000;;			// a case of adding a new node to 1-member cluster for restoring cluster data
0000000000000000000000000000000000000000;;			// https://github.com/coreos/etcd/blob/master/Documentation/v2/admin_guide.md#restoring-the-cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			plog.Debugf("The number of started member is 1. This cluster can accept add member request.")
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nquorum := nmembers/2 + 1
0000000000000000000000000000000000000000;;		if nstarted < nquorum {
0000000000000000000000000000000000000000;;			plog.Warningf("Reject add member request: the number of started member (%d) will be less than the quorum number of the cluster (%d)", nstarted, nquorum)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *RaftCluster) IsReadyToRemoveMember(id uint64) bool {
0000000000000000000000000000000000000000;;		nmembers := 0
0000000000000000000000000000000000000000;;		nstarted := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, member := range c.members {
0000000000000000000000000000000000000000;;			if uint64(member.ID) == id {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if member.IsStarted() {
0000000000000000000000000000000000000000;;				nstarted++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nmembers++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nquorum := nmembers/2 + 1
0000000000000000000000000000000000000000;;		if nstarted < nquorum {
0000000000000000000000000000000000000000;;			plog.Warningf("Reject remove member request: the number of started member (%d) will be less than the quorum number of the cluster (%d)", nstarted, nquorum)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func membersFromStore(st store.Store) (map[types.ID]*Member, map[types.ID]bool) {
0000000000000000000000000000000000000000;;		members := make(map[types.ID]*Member)
0000000000000000000000000000000000000000;;		removed := make(map[types.ID]bool)
0000000000000000000000000000000000000000;;		e, err := st.Get(StoreMembersPrefix, true, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isKeyNotFound(err) {
0000000000000000000000000000000000000000;;				return members, removed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Panicf("get storeMembers should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, n := range e.Node.Nodes {
0000000000000000000000000000000000000000;;			var m *Member
0000000000000000000000000000000000000000;;			m, err = nodeToMember(n)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("nodeToMember should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			members[m.ID] = m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e, err = st.Get(storeRemovedMembersPrefix, true, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isKeyNotFound(err) {
0000000000000000000000000000000000000000;;				return members, removed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Panicf("get storeRemovedMembers should never fail: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, n := range e.Node.Nodes {
0000000000000000000000000000000000000000;;			removed[MustParseMemberIDFromKey(n.Key)] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return members, removed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clusterVersionFromStore(st store.Store) *semver.Version {
0000000000000000000000000000000000000000;;		e, err := st.Get(path.Join(storePrefix, "version"), false, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if isKeyNotFound(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Panicf("unexpected error (%v) when getting cluster version from store", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return semver.Must(semver.NewVersion(*e.Node.Value))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateClusterAndAssignIDs validates the local cluster by matching the PeerURLs
0000000000000000000000000000000000000000;;	// with the existing cluster. If the validation succeeds, it assigns the IDs
0000000000000000000000000000000000000000;;	// from the existing cluster to the local cluster.
0000000000000000000000000000000000000000;;	// If the validation fails, an error will be returned.
0000000000000000000000000000000000000000;;	func ValidateClusterAndAssignIDs(local *RaftCluster, existing *RaftCluster) error {
0000000000000000000000000000000000000000;;		ems := existing.Members()
0000000000000000000000000000000000000000;;		lms := local.Members()
0000000000000000000000000000000000000000;;		if len(ems) != len(lms) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("member count is unequal")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(MembersByPeerURLs(ems))
0000000000000000000000000000000000000000;;		sort.Sort(MembersByPeerURLs(lms))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.TODO(), 30*time.Second)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		for i := range ems {
0000000000000000000000000000000000000000;;			if !netutil.URLStringsEqual(ctx, ems[i].PeerURLs, lms[i].PeerURLs) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unmatched member while checking PeerURLs")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lms[i].ID = ems[i].ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		local.members = make(map[types.ID]*Member)
0000000000000000000000000000000000000000;;		for _, m := range lms {
0000000000000000000000000000000000000000;;			local.members[m.ID] = m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustDetectDowngrade(cv *semver.Version) {
0000000000000000000000000000000000000000;;		lv := semver.Must(semver.NewVersion(version.Version))
0000000000000000000000000000000000000000;;		// only keep major.minor version for comparison against cluster version
0000000000000000000000000000000000000000;;		lv = &semver.Version{Major: lv.Major, Minor: lv.Minor}
0000000000000000000000000000000000000000;;		if cv != nil && lv.LessThan(*cv) {
0000000000000000000000000000000000000000;;			plog.Fatalf("cluster cannot be downgraded (current version: %s is lower than determined cluster version: %s).", version.Version, version.Cluster(cv.String()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
