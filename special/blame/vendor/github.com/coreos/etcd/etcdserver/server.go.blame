0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/server.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/server.go][vendor/github.com/coreos/etcd/etcdserver/server.go];	
0000000000000000000000000000000000000000;;	package etcdserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"expvar"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/alarm"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/auth"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/compactor"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/discovery"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/membership"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/stats"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/lease"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/contention"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/fileutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/idutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/runtime"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/schedule"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/wait"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/rafthttp"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/store"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/version"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultSnapCount = 10000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		StoreClusterPrefix = "/0"
0000000000000000000000000000000000000000;;		StoreKeysPrefix    = "/1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HealthInterval is the minimum time the cluster should be healthy
0000000000000000000000000000000000000000;;		// before accepting add member requests.
0000000000000000000000000000000000000000;;		HealthInterval = 5 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		purgeFileInterval = 30 * time.Second
0000000000000000000000000000000000000000;;		// monitorVersionInterval should be smaller than the timeout
0000000000000000000000000000000000000000;;		// on the connection. Or we will not be able to reuse the connection
0000000000000000000000000000000000000000;;		// (since it will timeout).
0000000000000000000000000000000000000000;;		monitorVersionInterval = rafthttp.ConnWriteTimeout - time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		databaseFilename = "db"
0000000000000000000000000000000000000000;;		// max number of in-flight snapshot messages etcdserver allows to have
0000000000000000000000000000000000000000;;		// This number is more than enough for most clusters with 5 machines.
0000000000000000000000000000000000000000;;		maxInFlightMsgSnap = 16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		releaseDelayAfterSnapshot = 30 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maxPendingRevokes is the maximum number of outstanding expired lease revocations.
0000000000000000000000000000000000000000;;		maxPendingRevokes = 16
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "etcdserver")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storeMemberAttributeRegexp = regexp.MustCompile(path.Join(membership.StoreMembersPrefix, "[[:xdigit:]]{1,16}", "attributes"))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		rand.Seed(time.Now().UnixNano())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expvar.Publish(
0000000000000000000000000000000000000000;;			"file_descriptor_limit",
0000000000000000000000000000000000000000;;			expvar.Func(
0000000000000000000000000000000000000000;;				func() interface{} {
0000000000000000000000000000000000000000;;					n, _ := runtime.FDLimit()
0000000000000000000000000000000000000000;;					return n
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Response struct {
0000000000000000000000000000000000000000;;		Event   *store.Event
0000000000000000000000000000000000000000;;		Watcher store.Watcher
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Server interface {
0000000000000000000000000000000000000000;;		// Start performs any initialization of the Server necessary for it to
0000000000000000000000000000000000000000;;		// begin serving requests. It must be called before Do or Process.
0000000000000000000000000000000000000000;;		// Start must be non-blocking; any long-running server functionality
0000000000000000000000000000000000000000;;		// should be implemented in goroutines.
0000000000000000000000000000000000000000;;		Start()
0000000000000000000000000000000000000000;;		// Stop terminates the Server and performs any necessary finalization.
0000000000000000000000000000000000000000;;		// Do and Process cannot be called after Stop has been invoked.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;		// ID returns the ID of the Server.
0000000000000000000000000000000000000000;;		ID() types.ID
0000000000000000000000000000000000000000;;		// Leader returns the ID of the leader Server.
0000000000000000000000000000000000000000;;		Leader() types.ID
0000000000000000000000000000000000000000;;		// Do takes a request and attempts to fulfill it, returning a Response.
0000000000000000000000000000000000000000;;		Do(ctx context.Context, r pb.Request) (Response, error)
0000000000000000000000000000000000000000;;		// Process takes a raft message and applies it to the server's raft state
0000000000000000000000000000000000000000;;		// machine, respecting any timeout of the given context.
0000000000000000000000000000000000000000;;		Process(ctx context.Context, m raftpb.Message) error
0000000000000000000000000000000000000000;;		// AddMember attempts to add a member into the cluster. It will return
0000000000000000000000000000000000000000;;		// ErrIDRemoved if member ID is removed from the cluster, or return
0000000000000000000000000000000000000000;;		// ErrIDExists if member ID exists in the cluster.
0000000000000000000000000000000000000000;;		AddMember(ctx context.Context, memb membership.Member) error
0000000000000000000000000000000000000000;;		// RemoveMember attempts to remove a member from the cluster. It will
0000000000000000000000000000000000000000;;		// return ErrIDRemoved if member ID is removed from the cluster, or return
0000000000000000000000000000000000000000;;		// ErrIDNotFound if member ID is not in the cluster.
0000000000000000000000000000000000000000;;		RemoveMember(ctx context.Context, id uint64) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UpdateMember attempts to update an existing member in the cluster. It will
0000000000000000000000000000000000000000;;		// return ErrIDNotFound if the member ID does not exist.
0000000000000000000000000000000000000000;;		UpdateMember(ctx context.Context, updateMemb membership.Member) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClusterVersion is the cluster-wide minimum major.minor version.
0000000000000000000000000000000000000000;;		// Cluster version is set to the min version that an etcd member is
0000000000000000000000000000000000000000;;		// compatible with when first bootstrap.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// ClusterVersion is nil until the cluster is bootstrapped (has a quorum).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// During a rolling upgrades, the ClusterVersion will be updated
0000000000000000000000000000000000000000;;		// automatically after a sync. (5 second by default)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The API/raft component can utilize ClusterVersion to determine if
0000000000000000000000000000000000000000;;		// it can accept a client request or a raft RPC.
0000000000000000000000000000000000000000;;		// NOTE: ClusterVersion might be nil when etcd 2.1 works with etcd 2.0 and
0000000000000000000000000000000000000000;;		// the leader is etcd 2.0. etcd 2.0 leader will not update clusterVersion since
0000000000000000000000000000000000000000;;		// this feature is introduced post 2.0.
0000000000000000000000000000000000000000;;		ClusterVersion() *semver.Version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EtcdServer is the production implementation of the Server interface
0000000000000000000000000000000000000000;;	type EtcdServer struct {
0000000000000000000000000000000000000000;;		// inflightSnapshots holds count the number of snapshots currently inflight.
0000000000000000000000000000000000000000;;		inflightSnapshots int64  // must use atomic operations to access; keep 64-bit aligned.
0000000000000000000000000000000000000000;;		appliedIndex      uint64 // must use atomic operations to access; keep 64-bit aligned.
0000000000000000000000000000000000000000;;		committedIndex    uint64 // must use atomic operations to access; keep 64-bit aligned.
0000000000000000000000000000000000000000;;		// consistIndex used to hold the offset of current executing entry
0000000000000000000000000000000000000000;;		// It is initialized to 0 before executing any entry.
0000000000000000000000000000000000000000;;		consistIndex consistentIndex // must use atomic operations to access; keep 64-bit aligned.
0000000000000000000000000000000000000000;;		Cfg          *ServerConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readych chan struct{}
0000000000000000000000000000000000000000;;		r       raftNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		snapCount uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w wait.Wait
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readMu sync.RWMutex
0000000000000000000000000000000000000000;;		// read routine notifies etcd server that it waits for reading by sending an empty struct to
0000000000000000000000000000000000000000;;		// readwaitC
0000000000000000000000000000000000000000;;		readwaitc chan struct{}
0000000000000000000000000000000000000000;;		// readNotifier is used to notify the read routine that it can process the request
0000000000000000000000000000000000000000;;		// when there is no error
0000000000000000000000000000000000000000;;		readNotifier *notifier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stop signals the run goroutine should shutdown.
0000000000000000000000000000000000000000;;		stop chan struct{}
0000000000000000000000000000000000000000;;		// stopping is closed by run goroutine on shutdown.
0000000000000000000000000000000000000000;;		stopping chan struct{}
0000000000000000000000000000000000000000;;		// done is closed when all goroutines from start() complete.
0000000000000000000000000000000000000000;;		done chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorc     chan error
0000000000000000000000000000000000000000;;		id         types.ID
0000000000000000000000000000000000000000;;		attributes membership.Attributes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cluster *membership.RaftCluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		store store.Store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		applyV2 ApplierV2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// applyV3 is the applier with auth and quotas
0000000000000000000000000000000000000000;;		applyV3 applierV3
0000000000000000000000000000000000000000;;		// applyV3Base is the core applier without auth or quotas
0000000000000000000000000000000000000000;;		applyV3Base applierV3
0000000000000000000000000000000000000000;;		applyWait   wait.WaitTime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kv         mvcc.ConsistentWatchableKV
0000000000000000000000000000000000000000;;		lessor     lease.Lessor
0000000000000000000000000000000000000000;;		bemu       sync.Mutex
0000000000000000000000000000000000000000;;		be         backend.Backend
0000000000000000000000000000000000000000;;		authStore  auth.AuthStore
0000000000000000000000000000000000000000;;		alarmStore *alarm.AlarmStore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats  *stats.ServerStats
0000000000000000000000000000000000000000;;		lstats *stats.LeaderStats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SyncTicker <-chan time.Time
0000000000000000000000000000000000000000;;		// compactor is used to auto-compact the KV.
0000000000000000000000000000000000000000;;		compactor *compactor.Periodic
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// peerRt used to send requests (version, lease) to peers.
0000000000000000000000000000000000000000;;		peerRt   http.RoundTripper
0000000000000000000000000000000000000000;;		reqIDGen *idutil.Generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// forceVersionC is used to force the version monitor loop
0000000000000000000000000000000000000000;;		// to detect the cluster version immediately.
0000000000000000000000000000000000000000;;		forceVersionC chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wgMu blocks concurrent waitgroup mutation while server stopping
0000000000000000000000000000000000000000;;		wgMu sync.RWMutex
0000000000000000000000000000000000000000;;		// wg is used to wait for the go routines that depends on the server state
0000000000000000000000000000000000000000;;		// to exit when stopping the server.
0000000000000000000000000000000000000000;;		wg sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServer creates a new EtcdServer from the supplied configuration. The
0000000000000000000000000000000000000000;;	// configuration is considered static for the lifetime of the EtcdServer.
0000000000000000000000000000000000000000;;	func NewServer(cfg *ServerConfig) (srv *EtcdServer, err error) {
0000000000000000000000000000000000000000;;		st := store.New(StoreClusterPrefix, StoreKeysPrefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			w  *wal.WAL
0000000000000000000000000000000000000000;;			n  raft.Node
0000000000000000000000000000000000000000;;			s  *raft.MemoryStorage
0000000000000000000000000000000000000000;;			id types.ID
0000000000000000000000000000000000000000;;			cl *membership.RaftCluster
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if terr := fileutil.TouchDirAll(cfg.DataDir); terr != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot access data directory: %v", terr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		haveWAL := wal.Exist(cfg.WALDir())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = fileutil.TouchDirAll(cfg.SnapDir()); err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("create snapshot directory error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := snap.New(cfg.SnapDir())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bepath := filepath.Join(cfg.SnapDir(), databaseFilename)
0000000000000000000000000000000000000000;;		beExist := fileutil.Exist(bepath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var be backend.Backend
0000000000000000000000000000000000000000;;		beOpened := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			be = backend.NewDefaultBackend(bepath)
0000000000000000000000000000000000000000;;			beOpened <- struct{}{}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-beOpened:
0000000000000000000000000000000000000000;;		case <-time.After(time.Second):
0000000000000000000000000000000000000000;;			plog.Warningf("another etcd process is running with the same data dir and holding the file lock.")
0000000000000000000000000000000000000000;;			plog.Warningf("waiting for it to exit before starting...")
0000000000000000000000000000000000000000;;			<-beOpened
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				be.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prt, err := rafthttp.NewRoundTripper(cfg.PeerTLSInfo, cfg.peerDialTimeout())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			remotes  []*membership.Member
0000000000000000000000000000000000000000;;			snapshot *raftpb.Snapshot
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case !haveWAL && !cfg.NewCluster:
0000000000000000000000000000000000000000;;			if err = cfg.VerifyJoinExisting(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cl, err = membership.NewClusterFromURLsMap(cfg.InitialClusterToken, cfg.InitialPeerURLsMap)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			existingCluster, gerr := GetClusterFromRemotePeers(getRemotePeerURLs(cl, cfg.Name), prt)
0000000000000000000000000000000000000000;;			if gerr != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot fetch cluster info from peer urls: %v", gerr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = membership.ValidateClusterAndAssignIDs(cl, existingCluster); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error validating peerURLs %s: %v", existingCluster, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isCompatibleWithCluster(cl, cl.MemberByName(cfg.Name).ID, prt) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("incompatible with current running cluster")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			remotes = existingCluster.Members()
0000000000000000000000000000000000000000;;			cl.SetID(existingCluster.ID())
0000000000000000000000000000000000000000;;			cl.SetStore(st)
0000000000000000000000000000000000000000;;			cl.SetBackend(be)
0000000000000000000000000000000000000000;;			cfg.Print()
0000000000000000000000000000000000000000;;			id, n, s, w = startNode(cfg, cl, nil)
0000000000000000000000000000000000000000;;		case !haveWAL && cfg.NewCluster:
0000000000000000000000000000000000000000;;			if err = cfg.VerifyBootstrap(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cl, err = membership.NewClusterFromURLsMap(cfg.InitialClusterToken, cfg.InitialPeerURLsMap)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m := cl.MemberByName(cfg.Name)
0000000000000000000000000000000000000000;;			if isMemberBootstrapped(cl, cfg.Name, prt, cfg.bootstrapTimeout()) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("member %s has already been bootstrapped", m.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cfg.ShouldDiscover() {
0000000000000000000000000000000000000000;;				var str string
0000000000000000000000000000000000000000;;				str, err = discovery.JoinCluster(cfg.DiscoveryURL, cfg.DiscoveryProxy, m.ID, cfg.InitialPeerURLsMap.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, &DiscoveryError{Op: "join", Err: err}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var urlsmap types.URLsMap
0000000000000000000000000000000000000000;;				urlsmap, err = types.NewURLsMap(str)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if checkDuplicateURL(urlsmap) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("discovery cluster %s has duplicate url", urlsmap)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cl, err = membership.NewClusterFromURLsMap(cfg.InitialClusterToken, urlsmap); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cl.SetStore(st)
0000000000000000000000000000000000000000;;			cl.SetBackend(be)
0000000000000000000000000000000000000000;;			cfg.PrintWithInitial()
0000000000000000000000000000000000000000;;			id, n, s, w = startNode(cfg, cl, cl.MemberIDs())
0000000000000000000000000000000000000000;;		case haveWAL:
0000000000000000000000000000000000000000;;			if err = fileutil.IsDirWriteable(cfg.MemberDir()); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot write to member directory: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = fileutil.IsDirWriteable(cfg.WALDir()); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot write to WAL directory: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cfg.ShouldDiscover() {
0000000000000000000000000000000000000000;;				plog.Warningf("discovery token ignored since a cluster has already been initialized. Valid log found at %q", cfg.WALDir())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			snapshot, err = ss.Load()
0000000000000000000000000000000000000000;;			if err != nil && err != snap.ErrNoSnapshot {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if snapshot != nil {
0000000000000000000000000000000000000000;;				if err = st.Recovery(snapshot.Data); err != nil {
0000000000000000000000000000000000000000;;					plog.Panicf("recovered store from snapshot error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Infof("recovered store from snapshot at index %d", snapshot.Metadata.Index)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cfg.Print()
0000000000000000000000000000000000000000;;			if !cfg.ForceNewCluster {
0000000000000000000000000000000000000000;;				id, cl, n, s, w = restartNode(cfg, snapshot)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				id, cl, n, s, w = restartAsStandaloneNode(cfg, snapshot)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cl.SetStore(st)
0000000000000000000000000000000000000000;;			cl.SetBackend(be)
0000000000000000000000000000000000000000;;			cl.Recover(api.UpdateCapability)
0000000000000000000000000000000000000000;;			if cl.Version() != nil && !cl.Version().LessThan(semver.Version{Major: 3}) && !beExist {
0000000000000000000000000000000000000000;;				os.RemoveAll(bepath)
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("database file (%v) of the backend is missing", bepath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported bootstrap config")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if terr := fileutil.TouchDirAll(cfg.MemberDir()); terr != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot access member directory: %v", terr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sstats := &stats.ServerStats{
0000000000000000000000000000000000000000;;			Name: cfg.Name,
0000000000000000000000000000000000000000;;			ID:   id.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sstats.Initialize()
0000000000000000000000000000000000000000;;		lstats := stats.NewLeaderStats(id.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		heartbeat := time.Duration(cfg.TickMs) * time.Millisecond
0000000000000000000000000000000000000000;;		srv = &EtcdServer{
0000000000000000000000000000000000000000;;			readych:   make(chan struct{}),
0000000000000000000000000000000000000000;;			Cfg:       cfg,
0000000000000000000000000000000000000000;;			snapCount: cfg.SnapCount,
0000000000000000000000000000000000000000;;			errorc:    make(chan error, 1),
0000000000000000000000000000000000000000;;			store:     st,
0000000000000000000000000000000000000000;;			r: raftNode{
0000000000000000000000000000000000000000;;				isIDRemoved: func(id uint64) bool { return cl.IsIDRemoved(types.ID(id)) },
0000000000000000000000000000000000000000;;				Node:        n,
0000000000000000000000000000000000000000;;				ticker:      time.Tick(heartbeat),
0000000000000000000000000000000000000000;;				// set up contention detectors for raft heartbeat message.
0000000000000000000000000000000000000000;;				// expect to send a heartbeat within 2 heartbeat intervals.
0000000000000000000000000000000000000000;;				td:          contention.NewTimeoutDetector(2 * heartbeat),
0000000000000000000000000000000000000000;;				heartbeat:   heartbeat,
0000000000000000000000000000000000000000;;				raftStorage: s,
0000000000000000000000000000000000000000;;				storage:     NewStorage(w, ss),
0000000000000000000000000000000000000000;;				msgSnapC:    make(chan raftpb.Message, maxInFlightMsgSnap),
0000000000000000000000000000000000000000;;				readStateC:  make(chan raft.ReadState, 1),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			id:            id,
0000000000000000000000000000000000000000;;			attributes:    membership.Attributes{Name: cfg.Name, ClientURLs: cfg.ClientURLs.StringSlice()},
0000000000000000000000000000000000000000;;			cluster:       cl,
0000000000000000000000000000000000000000;;			stats:         sstats,
0000000000000000000000000000000000000000;;			lstats:        lstats,
0000000000000000000000000000000000000000;;			SyncTicker:    time.Tick(500 * time.Millisecond),
0000000000000000000000000000000000000000;;			peerRt:        prt,
0000000000000000000000000000000000000000;;			reqIDGen:      idutil.NewGenerator(uint16(id), time.Now()),
0000000000000000000000000000000000000000;;			forceVersionC: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srv.applyV2 = &applierV2store{store: srv.store, cluster: srv.cluster}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srv.be = be
0000000000000000000000000000000000000000;;		minTTL := time.Duration((3*cfg.ElectionTicks)/2) * heartbeat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always recover lessor before kv. When we recover the mvcc.KV it will reattach keys to its leases.
0000000000000000000000000000000000000000;;		// If we recover mvcc.KV first, it will attach the keys to the wrong lessor before it recovers.
0000000000000000000000000000000000000000;;		srv.lessor = lease.NewLessor(srv.be, int64(math.Ceil(minTTL.Seconds())))
0000000000000000000000000000000000000000;;		srv.kv = mvcc.New(srv.be, srv.lessor, &srv.consistIndex)
0000000000000000000000000000000000000000;;		if beExist {
0000000000000000000000000000000000000000;;			kvindex := srv.kv.ConsistentIndex()
0000000000000000000000000000000000000000;;			// TODO: remove kvindex != 0 checking when we do not expect users to upgrade
0000000000000000000000000000000000000000;;			// etcd from pre-3.0 release.
0000000000000000000000000000000000000000;;			if snapshot != nil && kvindex < snapshot.Metadata.Index {
0000000000000000000000000000000000000000;;				if kvindex != 0 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("database file (%v index %d) does not match with snapshot (index %d).", bepath, kvindex, snapshot.Metadata.Index)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Warningf("consistent index never saved (snapshot index=%d)", snapshot.Metadata.Index)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv.consistIndex.setConsistentIndex(srv.kv.ConsistentIndex())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srv.authStore = auth.NewAuthStore(srv.be,
0000000000000000000000000000000000000000;;			func(index uint64) <-chan struct{} {
0000000000000000000000000000000000000000;;				return srv.applyWait.Wait(index)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		if h := cfg.AutoCompactionRetention; h != 0 {
0000000000000000000000000000000000000000;;			srv.compactor = compactor.NewPeriodic(h, srv.kv, srv)
0000000000000000000000000000000000000000;;			srv.compactor.Run()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srv.applyV3Base = &applierV3backend{srv}
0000000000000000000000000000000000000000;;		if err = srv.restoreAlarms(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: move transport initialization near the definition of remote
0000000000000000000000000000000000000000;;		tr := &rafthttp.Transport{
0000000000000000000000000000000000000000;;			TLSInfo:     cfg.PeerTLSInfo,
0000000000000000000000000000000000000000;;			DialTimeout: cfg.peerDialTimeout(),
0000000000000000000000000000000000000000;;			ID:          id,
0000000000000000000000000000000000000000;;			URLs:        cfg.PeerURLs,
0000000000000000000000000000000000000000;;			ClusterID:   cl.ID(),
0000000000000000000000000000000000000000;;			Raft:        srv,
0000000000000000000000000000000000000000;;			Snapshotter: ss,
0000000000000000000000000000000000000000;;			ServerStats: sstats,
0000000000000000000000000000000000000000;;			LeaderStats: lstats,
0000000000000000000000000000000000000000;;			ErrorC:      srv.errorc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = tr.Start(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// add all remotes into transport
0000000000000000000000000000000000000000;;		for _, m := range remotes {
0000000000000000000000000000000000000000;;			if m.ID != id {
0000000000000000000000000000000000000000;;				tr.AddRemote(m.ID, m.PeerURLs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, m := range cl.Members() {
0000000000000000000000000000000000000000;;			if m.ID != id {
0000000000000000000000000000000000000000;;				tr.AddPeer(m.ID, m.PeerURLs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv.r.transport = tr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return srv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start prepares and starts server in a new goroutine. It is no longer safe to
0000000000000000000000000000000000000000;;	// modify a server's fields after it has been sent to Start.
0000000000000000000000000000000000000000;;	// It also starts a goroutine to publish its server information.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Start() {
0000000000000000000000000000000000000000;;		s.start()
0000000000000000000000000000000000000000;;		s.goAttach(func() { s.publish(s.Cfg.ReqTimeout()) })
0000000000000000000000000000000000000000;;		s.goAttach(s.purgeFile)
0000000000000000000000000000000000000000;;		s.goAttach(func() { monitorFileDescriptor(s.stopping) })
0000000000000000000000000000000000000000;;		s.goAttach(s.monitorVersions)
0000000000000000000000000000000000000000;;		s.goAttach(s.linearizableReadLoop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// start prepares and starts server in a new goroutine. It is no longer safe to
0000000000000000000000000000000000000000;;	// modify a server's fields after it has been sent to Start.
0000000000000000000000000000000000000000;;	// This function is just used for testing.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) start() {
0000000000000000000000000000000000000000;;		if s.snapCount == 0 {
0000000000000000000000000000000000000000;;			plog.Infof("set snapshot count to default %d", DefaultSnapCount)
0000000000000000000000000000000000000000;;			s.snapCount = DefaultSnapCount
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.w = wait.New()
0000000000000000000000000000000000000000;;		s.applyWait = wait.NewTimeList()
0000000000000000000000000000000000000000;;		s.done = make(chan struct{})
0000000000000000000000000000000000000000;;		s.stop = make(chan struct{})
0000000000000000000000000000000000000000;;		s.stopping = make(chan struct{})
0000000000000000000000000000000000000000;;		s.readwaitc = make(chan struct{}, 1)
0000000000000000000000000000000000000000;;		s.readNotifier = newNotifier()
0000000000000000000000000000000000000000;;		if s.ClusterVersion() != nil {
0000000000000000000000000000000000000000;;			plog.Infof("starting server... [version: %v, cluster version: %v]", version.Version, version.Cluster(s.ClusterVersion().String()))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			plog.Infof("starting server... [version: %v, cluster version: to_be_decided]", version.Version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: if this is an empty log, writes all peer infos
0000000000000000000000000000000000000000;;		// into the first entry
0000000000000000000000000000000000000000;;		go s.run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) purgeFile() {
0000000000000000000000000000000000000000;;		var serrc, werrc <-chan error
0000000000000000000000000000000000000000;;		if s.Cfg.MaxSnapFiles > 0 {
0000000000000000000000000000000000000000;;			serrc = fileutil.PurgeFile(s.Cfg.SnapDir(), "snap", s.Cfg.MaxSnapFiles, purgeFileInterval, s.done)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Cfg.MaxWALFiles > 0 {
0000000000000000000000000000000000000000;;			werrc = fileutil.PurgeFile(s.Cfg.WALDir(), "wal", s.Cfg.MaxWALFiles, purgeFileInterval, s.done)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case e := <-werrc:
0000000000000000000000000000000000000000;;			plog.Fatalf("failed to purge wal file %v", e)
0000000000000000000000000000000000000000;;		case e := <-serrc:
0000000000000000000000000000000000000000;;			plog.Fatalf("failed to purge snap file %v", e)
0000000000000000000000000000000000000000;;		case <-s.stopping:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) ID() types.ID { return s.id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Cluster() *membership.RaftCluster { return s.cluster }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RaftHandler() http.Handler { return s.r.transport.Handler() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Lessor() lease.Lessor { return s.lessor }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) ApplyWait() <-chan struct{} { return s.applyWait.Wait(s.getCommittedIndex()) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Process(ctx context.Context, m raftpb.Message) error {
0000000000000000000000000000000000000000;;		if s.cluster.IsIDRemoved(types.ID(m.From)) {
0000000000000000000000000000000000000000;;			plog.Warningf("reject message from removed member %s", types.ID(m.From).String())
0000000000000000000000000000000000000000;;			return httptypes.NewHTTPError(http.StatusForbidden, "cannot process message from removed member")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Type == raftpb.MsgApp {
0000000000000000000000000000000000000000;;			s.stats.RecvAppendReq(types.ID(m.From).String(), m.Size())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.r.Step(ctx, m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) IsIDRemoved(id uint64) bool { return s.cluster.IsIDRemoved(types.ID(id)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) ReportUnreachable(id uint64) { s.r.ReportUnreachable(id) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReportSnapshot reports snapshot sent status to the raft state machine,
0000000000000000000000000000000000000000;;	// and clears the used snapshot from the snapshot store.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) ReportSnapshot(id uint64, status raft.SnapshotStatus) {
0000000000000000000000000000000000000000;;		s.r.ReportSnapshot(id, status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type etcdProgress struct {
0000000000000000000000000000000000000000;;		confState raftpb.ConfState
0000000000000000000000000000000000000000;;		snapi     uint64
0000000000000000000000000000000000000000;;		appliedt  uint64
0000000000000000000000000000000000000000;;		appliedi  uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// raftReadyHandler contains a set of EtcdServer operations to be called by raftNode,
0000000000000000000000000000000000000000;;	// and helps decouple state machine logic from Raft algorithms.
0000000000000000000000000000000000000000;;	// TODO: add a state machine interface to apply the commit entries and do snapshot/recover
0000000000000000000000000000000000000000;;	type raftReadyHandler struct {
0000000000000000000000000000000000000000;;		updateLeadership     func()
0000000000000000000000000000000000000000;;		updateCommittedIndex func(uint64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) run() {
0000000000000000000000000000000000000000;;		snap, err := s.r.raftStorage.Snapshot()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("get snapshot from raft storage error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			smu   sync.RWMutex
0000000000000000000000000000000000000000;;			syncC <-chan time.Time
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		setSyncC := func(ch <-chan time.Time) {
0000000000000000000000000000000000000000;;			smu.Lock()
0000000000000000000000000000000000000000;;			syncC = ch
0000000000000000000000000000000000000000;;			smu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		getSyncC := func() (ch <-chan time.Time) {
0000000000000000000000000000000000000000;;			smu.RLock()
0000000000000000000000000000000000000000;;			ch = syncC
0000000000000000000000000000000000000000;;			smu.RUnlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rh := &raftReadyHandler{
0000000000000000000000000000000000000000;;			updateLeadership: func() {
0000000000000000000000000000000000000000;;				if !s.isLeader() {
0000000000000000000000000000000000000000;;					if s.lessor != nil {
0000000000000000000000000000000000000000;;						s.lessor.Demote()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if s.compactor != nil {
0000000000000000000000000000000000000000;;						s.compactor.Pause()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					setSyncC(nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					setSyncC(s.SyncTicker)
0000000000000000000000000000000000000000;;					if s.compactor != nil {
0000000000000000000000000000000000000000;;						s.compactor.Resume()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: remove the nil checking
0000000000000000000000000000000000000000;;				// current test utility does not provide the stats
0000000000000000000000000000000000000000;;				if s.stats != nil {
0000000000000000000000000000000000000000;;					s.stats.BecomeLeader()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if s.r.td != nil {
0000000000000000000000000000000000000000;;					s.r.td.Reset()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			updateCommittedIndex: func(ci uint64) {
0000000000000000000000000000000000000000;;				cci := s.getCommittedIndex()
0000000000000000000000000000000000000000;;				if ci > cci {
0000000000000000000000000000000000000000;;					s.setCommittedIndex(ci)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.r.start(rh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// asynchronously accept apply packets, dispatch progress in-order
0000000000000000000000000000000000000000;;		sched := schedule.NewFIFOScheduler()
0000000000000000000000000000000000000000;;		ep := etcdProgress{
0000000000000000000000000000000000000000;;			confState: snap.Metadata.ConfState,
0000000000000000000000000000000000000000;;			snapi:     snap.Metadata.Index,
0000000000000000000000000000000000000000;;			appliedt:  snap.Metadata.Term,
0000000000000000000000000000000000000000;;			appliedi:  snap.Metadata.Index,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			s.wgMu.Lock() // block concurrent waitgroup adds in goAttach while stopping
0000000000000000000000000000000000000000;;			close(s.stopping)
0000000000000000000000000000000000000000;;			s.wgMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sched.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// wait for gouroutines before closing raft so wal stays open
0000000000000000000000000000000000000000;;			s.wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// must stop raft after scheduler-- etcdserver can leak rafthttp pipelines
0000000000000000000000000000000000000000;;			// by adding a peer after raft stops the transport
0000000000000000000000000000000000000000;;			s.r.stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// kv, lessor and backend can be nil if running without v3 enabled
0000000000000000000000000000000000000000;;			// or running unit tests.
0000000000000000000000000000000000000000;;			if s.lessor != nil {
0000000000000000000000000000000000000000;;				s.lessor.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.kv != nil {
0000000000000000000000000000000000000000;;				s.kv.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.authStore != nil {
0000000000000000000000000000000000000000;;				s.authStore.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.be != nil {
0000000000000000000000000000000000000000;;				s.be.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.compactor != nil {
0000000000000000000000000000000000000000;;				s.compactor.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(s.done)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var expiredLeaseC <-chan []*lease.Lease
0000000000000000000000000000000000000000;;		if s.lessor != nil {
0000000000000000000000000000000000000000;;			expiredLeaseC = s.lessor.ExpiredLeasesC()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case ap := <-s.r.apply():
0000000000000000000000000000000000000000;;				f := func(context.Context) { s.applyAll(&ep, &ap) }
0000000000000000000000000000000000000000;;				sched.Schedule(f)
0000000000000000000000000000000000000000;;			case leases := <-expiredLeaseC:
0000000000000000000000000000000000000000;;				s.goAttach(func() {
0000000000000000000000000000000000000000;;					// Increases throughput of expired leases deletion process through parallelization
0000000000000000000000000000000000000000;;					c := make(chan struct{}, maxPendingRevokes)
0000000000000000000000000000000000000000;;					for _, lease := range leases {
0000000000000000000000000000000000000000;;						select {
0000000000000000000000000000000000000000;;						case c <- struct{}{}:
0000000000000000000000000000000000000000;;						case <-s.stopping:
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						lid := lease.ID
0000000000000000000000000000000000000000;;						s.goAttach(func() {
0000000000000000000000000000000000000000;;							s.LeaseRevoke(context.TODO(), &pb.LeaseRevokeRequest{ID: int64(lid)})
0000000000000000000000000000000000000000;;							<-c
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			case err := <-s.errorc:
0000000000000000000000000000000000000000;;				plog.Errorf("%s", err)
0000000000000000000000000000000000000000;;				plog.Infof("the data-dir used by this member must be removed.")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-getSyncC():
0000000000000000000000000000000000000000;;				if s.store.HasTTLKeys() {
0000000000000000000000000000000000000000;;					s.sync(s.Cfg.ReqTimeout())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-s.stop:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) applyAll(ep *etcdProgress, apply *apply) {
0000000000000000000000000000000000000000;;		s.applySnapshot(ep, apply)
0000000000000000000000000000000000000000;;		st := time.Now()
0000000000000000000000000000000000000000;;		s.applyEntries(ep, apply)
0000000000000000000000000000000000000000;;		d := time.Since(st)
0000000000000000000000000000000000000000;;		entriesNum := len(apply.entries)
0000000000000000000000000000000000000000;;		if entriesNum != 0 && d > time.Duration(entriesNum)*warnApplyDuration {
0000000000000000000000000000000000000000;;			plog.Warningf("apply entries took too long [%v for %d entries]", d, len(apply.entries))
0000000000000000000000000000000000000000;;			plog.Warningf("avoid queries with large range/delete range!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proposalsApplied.Set(float64(ep.appliedi))
0000000000000000000000000000000000000000;;		s.applyWait.Trigger(ep.appliedi)
0000000000000000000000000000000000000000;;		// wait for the raft routine to finish the disk writes before triggering a
0000000000000000000000000000000000000000;;		// snapshot. or applied index might be greater than the last index in raft
0000000000000000000000000000000000000000;;		// storage, since the raft routine might be slower than apply routine.
0000000000000000000000000000000000000000;;		<-apply.raftDone
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.triggerSnapshot(ep)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		// snapshot requested via send()
0000000000000000000000000000000000000000;;		case m := <-s.r.msgSnapC:
0000000000000000000000000000000000000000;;			merged := s.createMergedSnapshotMessage(m, ep.appliedt, ep.appliedi, ep.confState)
0000000000000000000000000000000000000000;;			s.sendMergedSnap(merged)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) applySnapshot(ep *etcdProgress, apply *apply) {
0000000000000000000000000000000000000000;;		if raft.IsEmptySnap(apply.snapshot) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("applying snapshot at index %d...", ep.snapi)
0000000000000000000000000000000000000000;;		defer plog.Infof("finished applying incoming snapshot at index %d", ep.snapi)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if apply.snapshot.Metadata.Index <= ep.appliedi {
0000000000000000000000000000000000000000;;			plog.Panicf("snapshot index [%d] should > appliedi[%d] + 1",
0000000000000000000000000000000000000000;;				apply.snapshot.Metadata.Index, ep.appliedi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		snapfn, err := s.r.storage.DBFilePath(apply.snapshot.Metadata.Index)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("get database snapshot file path error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fn := filepath.Join(s.Cfg.SnapDir(), databaseFilename)
0000000000000000000000000000000000000000;;		if err := os.Rename(snapfn, fn); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("rename snapshot file error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newbe := backend.NewDefaultBackend(fn)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always recover lessor before kv. When we recover the mvcc.KV it will reattach keys to its leases.
0000000000000000000000000000000000000000;;		// If we recover mvcc.KV first, it will attach the keys to the wrong lessor before it recovers.
0000000000000000000000000000000000000000;;		if s.lessor != nil {
0000000000000000000000000000000000000000;;			plog.Info("recovering lessor...")
0000000000000000000000000000000000000000;;			s.lessor.Recover(newbe, s.kv)
0000000000000000000000000000000000000000;;			plog.Info("finished recovering lessor")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Info("restoring mvcc store...")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.kv.Restore(newbe); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("restore KV error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.consistIndex.setConsistentIndex(s.kv.ConsistentIndex())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Info("finished restoring mvcc store")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Closing old backend might block until all the txns
0000000000000000000000000000000000000000;;		// on the backend are finished.
0000000000000000000000000000000000000000;;		// We do not want to wait on closing the old backend.
0000000000000000000000000000000000000000;;		s.bemu.Lock()
0000000000000000000000000000000000000000;;		oldbe := s.be
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			plog.Info("closing old backend...")
0000000000000000000000000000000000000000;;			defer plog.Info("finished closing old backend")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := oldbe.Close(); err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("close backend error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.be = newbe
0000000000000000000000000000000000000000;;		s.bemu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Info("recovering alarms...")
0000000000000000000000000000000000000000;;		if err := s.restoreAlarms(); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("restore alarms error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Info("finished recovering alarms")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.authStore != nil {
0000000000000000000000000000000000000000;;			plog.Info("recovering auth store...")
0000000000000000000000000000000000000000;;			s.authStore.Recover(newbe)
0000000000000000000000000000000000000000;;			plog.Info("finished recovering auth store")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Info("recovering store v2...")
0000000000000000000000000000000000000000;;		if err := s.store.Recovery(apply.snapshot.Data); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("recovery store error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Info("finished recovering store v2")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.cluster.SetBackend(s.be)
0000000000000000000000000000000000000000;;		plog.Info("recovering cluster configuration...")
0000000000000000000000000000000000000000;;		s.cluster.Recover(api.UpdateCapability)
0000000000000000000000000000000000000000;;		plog.Info("finished recovering cluster configuration")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Info("removing old peers from network...")
0000000000000000000000000000000000000000;;		// recover raft transport
0000000000000000000000000000000000000000;;		s.r.transport.RemoveAllPeers()
0000000000000000000000000000000000000000;;		plog.Info("finished removing old peers from network")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Info("adding peers from new cluster configuration into network...")
0000000000000000000000000000000000000000;;		for _, m := range s.cluster.Members() {
0000000000000000000000000000000000000000;;			if m.ID == s.ID() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.r.transport.AddPeer(m.ID, m.PeerURLs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Info("finished adding peers from new cluster configuration into network...")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ep.appliedt = apply.snapshot.Metadata.Term
0000000000000000000000000000000000000000;;		ep.appliedi = apply.snapshot.Metadata.Index
0000000000000000000000000000000000000000;;		ep.snapi = ep.appliedi
0000000000000000000000000000000000000000;;		ep.confState = apply.snapshot.Metadata.ConfState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) applyEntries(ep *etcdProgress, apply *apply) {
0000000000000000000000000000000000000000;;		if len(apply.entries) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		firsti := apply.entries[0].Index
0000000000000000000000000000000000000000;;		if firsti > ep.appliedi+1 {
0000000000000000000000000000000000000000;;			plog.Panicf("first index of committed entry[%d] should <= appliedi[%d] + 1", firsti, ep.appliedi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ents []raftpb.Entry
0000000000000000000000000000000000000000;;		if ep.appliedi+1-firsti < uint64(len(apply.entries)) {
0000000000000000000000000000000000000000;;			ents = apply.entries[ep.appliedi+1-firsti:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ents) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var shouldstop bool
0000000000000000000000000000000000000000;;		if ep.appliedt, ep.appliedi, shouldstop = s.apply(ents, &ep.confState); shouldstop {
0000000000000000000000000000000000000000;;			go s.stopWithDelay(10*100*time.Millisecond, fmt.Errorf("the member has been permanently removed from the cluster"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) triggerSnapshot(ep *etcdProgress) {
0000000000000000000000000000000000000000;;		if ep.appliedi-ep.snapi <= s.snapCount {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("start to snapshot (applied: %d, lastsnap: %d)", ep.appliedi, ep.snapi)
0000000000000000000000000000000000000000;;		s.snapshot(ep.appliedi, ep.confState)
0000000000000000000000000000000000000000;;		ep.snapi = ep.appliedi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) isMultiNode() bool {
0000000000000000000000000000000000000000;;		return s.cluster != nil && len(s.cluster.MemberIDs()) > 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) isLeader() bool {
0000000000000000000000000000000000000000;;		return uint64(s.ID()) == s.Lead()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transferLeadership transfers the leader to the given transferee.
0000000000000000000000000000000000000000;;	// TODO: maybe expose to client?
0000000000000000000000000000000000000000;;	func (s *EtcdServer) transferLeadership(ctx context.Context, lead, transferee uint64) error {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		interval := time.Duration(s.Cfg.TickMs) * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("%s starts leadership transfer from %s to %s", s.ID(), types.ID(lead), types.ID(transferee))
0000000000000000000000000000000000000000;;		s.r.TransferLeadership(ctx, lead, transferee)
0000000000000000000000000000000000000000;;		for s.Lead() != transferee {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done(): // time out
0000000000000000000000000000000000000000;;				return ErrTimeoutLeaderTransfer
0000000000000000000000000000000000000000;;			case <-time.After(interval):
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: drain all requests, or drop all messages to the old leader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("%s finished leadership transfer from %s to %s (took %v)", s.ID(), types.ID(lead), types.ID(transferee), time.Since(now))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransferLeadership transfers the leader to the chosen transferee.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) TransferLeadership() error {
0000000000000000000000000000000000000000;;		if !s.isLeader() {
0000000000000000000000000000000000000000;;			plog.Printf("skipped leadership transfer for stopping non-leader member")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.isMultiNode() {
0000000000000000000000000000000000000000;;			plog.Printf("skipped leadership transfer for single member cluster")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		transferee, ok := longestConnected(s.r.transport, s.cluster.MemberIDs())
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrUnhealthy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tm := s.Cfg.ReqTimeout()
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.TODO(), tm)
0000000000000000000000000000000000000000;;		err := s.transferLeadership(ctx, s.Lead(), uint64(transferee))
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HardStop stops the server without coordination with other members in the cluster.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) HardStop() {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case s.stop <- struct{}{}:
0000000000000000000000000000000000000000;;		case <-s.done:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-s.done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the server gracefully, and shuts down the running goroutine.
0000000000000000000000000000000000000000;;	// Stop should be called after a Start(s), otherwise it will block forever.
0000000000000000000000000000000000000000;;	// When stopping leader, Stop transfers its leadership to one of its peers
0000000000000000000000000000000000000000;;	// before stopping the server.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Stop() {
0000000000000000000000000000000000000000;;		if err := s.TransferLeadership(); err != nil {
0000000000000000000000000000000000000000;;			plog.Warningf("%s failed to transfer leadership (%v)", s.ID(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.HardStop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadyNotify returns a channel that will be closed when the server
0000000000000000000000000000000000000000;;	// is ready to serve client requests
0000000000000000000000000000000000000000;;	func (s *EtcdServer) ReadyNotify() <-chan struct{} { return s.readych }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) stopWithDelay(d time.Duration, err error) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(d):
0000000000000000000000000000000000000000;;		case <-s.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case s.errorc <- err:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopNotify returns a channel that receives a empty struct
0000000000000000000000000000000000000000;;	// when the server is stopped.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) StopNotify() <-chan struct{} { return s.done }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) SelfStats() []byte { return s.stats.JSON() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) LeaderStats() []byte {
0000000000000000000000000000000000000000;;		lead := atomic.LoadUint64(&s.r.lead)
0000000000000000000000000000000000000000;;		if lead != uint64(s.id) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.lstats.JSON()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) StoreStats() []byte { return s.store.JsonStats() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) checkMembershipOperationPermission(ctx context.Context) error {
0000000000000000000000000000000000000000;;		if s.authStore == nil {
0000000000000000000000000000000000000000;;			// In the context of ordinal etcd process, s.authStore will never be nil.
0000000000000000000000000000000000000000;;			// This branch is for handling cases in server_test.go
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note that this permission check is done in the API layer,
0000000000000000000000000000000000000000;;		// so TOCTOU problem can be caused potentially in a schedule like this:
0000000000000000000000000000000000000000;;		// update membership with user A -> revoke root role of A -> apply membership change
0000000000000000000000000000000000000000;;		// in the state machine layer
0000000000000000000000000000000000000000;;		// However, both of membership change and role management requires the root privilege.
0000000000000000000000000000000000000000;;		// So careful operation by admins can prevent the problem.
0000000000000000000000000000000000000000;;		authInfo, err := s.AuthStore().AuthInfoFromCtx(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.AuthStore().IsAdminPermitted(authInfo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) AddMember(ctx context.Context, memb membership.Member) error {
0000000000000000000000000000000000000000;;		if err := s.checkMembershipOperationPermission(ctx); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Cfg.StrictReconfigCheck {
0000000000000000000000000000000000000000;;			// by default StrictReconfigCheck is enabled; reject new members if unhealthy
0000000000000000000000000000000000000000;;			if !s.cluster.IsReadyToAddNewMember() {
0000000000000000000000000000000000000000;;				plog.Warningf("not enough started members, rejecting member add %+v", memb)
0000000000000000000000000000000000000000;;				return ErrNotEnoughStartedMembers
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isConnectedFullySince(s.r.transport, time.Now().Add(-HealthInterval), s.ID(), s.cluster.Members()) {
0000000000000000000000000000000000000000;;				plog.Warningf("not healthy for reconfigure, rejecting member add %+v", memb)
0000000000000000000000000000000000000000;;				return ErrUnhealthy
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: move Member to protobuf type
0000000000000000000000000000000000000000;;		b, err := json.Marshal(memb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc := raftpb.ConfChange{
0000000000000000000000000000000000000000;;			Type:    raftpb.ConfChangeAddNode,
0000000000000000000000000000000000000000;;			NodeID:  uint64(memb.ID),
0000000000000000000000000000000000000000;;			Context: b,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.configure(ctx, cc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RemoveMember(ctx context.Context, id uint64) error {
0000000000000000000000000000000000000000;;		if err := s.checkMembershipOperationPermission(ctx); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// by default StrictReconfigCheck is enabled; reject removal if leads to quorum loss
0000000000000000000000000000000000000000;;		if err := s.mayRemoveMember(types.ID(id)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc := raftpb.ConfChange{
0000000000000000000000000000000000000000;;			Type:   raftpb.ConfChangeRemoveNode,
0000000000000000000000000000000000000000;;			NodeID: id,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.configure(ctx, cc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) mayRemoveMember(id types.ID) error {
0000000000000000000000000000000000000000;;		if !s.Cfg.StrictReconfigCheck {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.cluster.IsReadyToRemoveMember(uint64(id)) {
0000000000000000000000000000000000000000;;			plog.Warningf("not enough started members, rejecting remove member %s", id)
0000000000000000000000000000000000000000;;			return ErrNotEnoughStartedMembers
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// downed member is safe to remove since it's not part of the active quorum
0000000000000000000000000000000000000000;;		if t := s.r.transport.ActiveSince(id); id != s.ID() && t.IsZero() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// protect quorum if some members are down
0000000000000000000000000000000000000000;;		m := s.cluster.Members()
0000000000000000000000000000000000000000;;		active := numConnectedSince(s.r.transport, time.Now().Add(-HealthInterval), s.ID(), m)
0000000000000000000000000000000000000000;;		if (active - 1) < 1+((len(m)-1)/2) {
0000000000000000000000000000000000000000;;			plog.Warningf("reconfigure breaks active quorum, rejecting remove member %s", id)
0000000000000000000000000000000000000000;;			return ErrUnhealthy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UpdateMember(ctx context.Context, memb membership.Member) error {
0000000000000000000000000000000000000000;;		b, merr := json.Marshal(memb)
0000000000000000000000000000000000000000;;		if merr != nil {
0000000000000000000000000000000000000000;;			return merr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.checkMembershipOperationPermission(ctx); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc := raftpb.ConfChange{
0000000000000000000000000000000000000000;;			Type:    raftpb.ConfChangeUpdateNode,
0000000000000000000000000000000000000000;;			NodeID:  uint64(memb.ID),
0000000000000000000000000000000000000000;;			Context: b,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.configure(ctx, cc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement the RaftTimer interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Index() uint64 { return atomic.LoadUint64(&s.r.index) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Term() uint64 { return atomic.LoadUint64(&s.r.term) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lead is only for testing purposes.
0000000000000000000000000000000000000000;;	// TODO: add Raft server interface to expose raft related info:
0000000000000000000000000000000000000000;;	// Index, Term, Lead, Committed, Applied, LastIndex, etc.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Lead() uint64 { return atomic.LoadUint64(&s.r.lead) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Leader() types.ID { return types.ID(s.Lead()) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// configure sends a configuration change through consensus and
0000000000000000000000000000000000000000;;	// then waits for it to be applied to the server. It
0000000000000000000000000000000000000000;;	// will block until the change is performed or there is an error.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) configure(ctx context.Context, cc raftpb.ConfChange) error {
0000000000000000000000000000000000000000;;		cc.ID = s.reqIDGen.Next()
0000000000000000000000000000000000000000;;		ch := s.w.Register(cc.ID)
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		if err := s.r.ProposeConfChange(ctx, cc); err != nil {
0000000000000000000000000000000000000000;;			s.w.Trigger(cc.ID, nil)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case x := <-ch:
0000000000000000000000000000000000000000;;			if err, ok := x.(error); ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("return type should always be error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			s.w.Trigger(cc.ID, nil) // GC wait
0000000000000000000000000000000000000000;;			return s.parseProposeCtxErr(ctx.Err(), start)
0000000000000000000000000000000000000000;;		case <-s.stopping:
0000000000000000000000000000000000000000;;			return ErrStopped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sync proposes a SYNC request and is non-blocking.
0000000000000000000000000000000000000000;;	// This makes no guarantee that the request will be proposed or performed.
0000000000000000000000000000000000000000;;	// The request will be canceled after the given timeout.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) sync(timeout time.Duration) {
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), timeout)
0000000000000000000000000000000000000000;;		req := pb.Request{
0000000000000000000000000000000000000000;;			Method: "SYNC",
0000000000000000000000000000000000000000;;			ID:     s.reqIDGen.Next(),
0000000000000000000000000000000000000000;;			Time:   time.Now().UnixNano(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := pbutil.MustMarshal(&req)
0000000000000000000000000000000000000000;;		// There is no promise that node has leader when do SYNC request,
0000000000000000000000000000000000000000;;		// so it uses goroutine to propose.
0000000000000000000000000000000000000000;;		s.goAttach(func() {
0000000000000000000000000000000000000000;;			s.r.Propose(ctx, data)
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// publish registers server information into the cluster. The information
0000000000000000000000000000000000000000;;	// is the JSON representation of this server's member struct, updated with the
0000000000000000000000000000000000000000;;	// static clientURLs of the server.
0000000000000000000000000000000000000000;;	// The function keeps attempting to register until it succeeds,
0000000000000000000000000000000000000000;;	// or its server is stopped.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) publish(timeout time.Duration) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(s.attributes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("json marshal error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := pb.Request{
0000000000000000000000000000000000000000;;			Method: "PUT",
0000000000000000000000000000000000000000;;			Path:   membership.MemberAttributesStorePath(s.id),
0000000000000000000000000000000000000000;;			Val:    string(b),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(context.Background(), timeout)
0000000000000000000000000000000000000000;;			_, err := s.Do(ctx, req)
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;			switch err {
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				close(s.readych)
0000000000000000000000000000000000000000;;				plog.Infof("published %+v to cluster %s", s.attributes, s.cluster.ID())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case ErrStopped:
0000000000000000000000000000000000000000;;				plog.Infof("aborting publish because server is stopped")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				plog.Errorf("publish error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) sendMergedSnap(merged snap.Message) {
0000000000000000000000000000000000000000;;		atomic.AddInt64(&s.inflightSnapshots, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.r.transport.SendSnapshot(merged)
0000000000000000000000000000000000000000;;		s.goAttach(func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case ok := <-merged.CloseNotify():
0000000000000000000000000000000000000000;;				// delay releasing inflight snapshot for another 30 seconds to
0000000000000000000000000000000000000000;;				// block log compaction.
0000000000000000000000000000000000000000;;				// If the follower still fails to catch up, it is probably just too slow
0000000000000000000000000000000000000000;;				// to catch up. We cannot avoid the snapshot cycle anyway.
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case <-time.After(releaseDelayAfterSnapshot):
0000000000000000000000000000000000000000;;					case <-s.stopping:
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				atomic.AddInt64(&s.inflightSnapshots, -1)
0000000000000000000000000000000000000000;;			case <-s.stopping:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// apply takes entries received from Raft (after it has been committed) and
0000000000000000000000000000000000000000;;	// applies them to the current state of the EtcdServer.
0000000000000000000000000000000000000000;;	// The given entries should not be empty.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) apply(es []raftpb.Entry, confState *raftpb.ConfState) (appliedt uint64, appliedi uint64, shouldStop bool) {
0000000000000000000000000000000000000000;;		for i := range es {
0000000000000000000000000000000000000000;;			e := es[i]
0000000000000000000000000000000000000000;;			switch e.Type {
0000000000000000000000000000000000000000;;			case raftpb.EntryNormal:
0000000000000000000000000000000000000000;;				s.applyEntryNormal(&e)
0000000000000000000000000000000000000000;;			case raftpb.EntryConfChange:
0000000000000000000000000000000000000000;;				var cc raftpb.ConfChange
0000000000000000000000000000000000000000;;				pbutil.MustUnmarshal(&cc, e.Data)
0000000000000000000000000000000000000000;;				removedSelf, err := s.applyConfChange(cc, confState)
0000000000000000000000000000000000000000;;				shouldStop = shouldStop || removedSelf
0000000000000000000000000000000000000000;;				s.w.Trigger(cc.ID, err)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				plog.Panicf("entry type should be either EntryNormal or EntryConfChange")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			atomic.StoreUint64(&s.r.index, e.Index)
0000000000000000000000000000000000000000;;			atomic.StoreUint64(&s.r.term, e.Term)
0000000000000000000000000000000000000000;;			appliedt = e.Term
0000000000000000000000000000000000000000;;			appliedi = e.Index
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return appliedt, appliedi, shouldStop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyEntryNormal apples an EntryNormal type raftpb request to the EtcdServer
0000000000000000000000000000000000000000;;	func (s *EtcdServer) applyEntryNormal(e *raftpb.Entry) {
0000000000000000000000000000000000000000;;		shouldApplyV3 := false
0000000000000000000000000000000000000000;;		if e.Index > s.consistIndex.ConsistentIndex() {
0000000000000000000000000000000000000000;;			// set the consistent index of current executing entry
0000000000000000000000000000000000000000;;			s.consistIndex.setConsistentIndex(e.Index)
0000000000000000000000000000000000000000;;			shouldApplyV3 = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer s.setAppliedIndex(e.Index)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// raft state machine may generate noop entry when leader confirmation.
0000000000000000000000000000000000000000;;		// skip it in advance to avoid some potential bug in the future
0000000000000000000000000000000000000000;;		if len(e.Data) == 0 {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case s.forceVersionC <- struct{}{}:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// promote lessor when the local member is leader and finished
0000000000000000000000000000000000000000;;			// applying all entries from the last term.
0000000000000000000000000000000000000000;;			if s.isLeader() {
0000000000000000000000000000000000000000;;				s.lessor.Promote(s.Cfg.electionTimeout())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var raftReq pb.InternalRaftRequest
0000000000000000000000000000000000000000;;		if !pbutil.MaybeUnmarshal(&raftReq, e.Data) { // backward compatible
0000000000000000000000000000000000000000;;			var r pb.Request
0000000000000000000000000000000000000000;;			pbutil.MustUnmarshal(&r, e.Data)
0000000000000000000000000000000000000000;;			s.w.Trigger(r.ID, s.applyV2Request(&r))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if raftReq.V2 != nil {
0000000000000000000000000000000000000000;;			req := raftReq.V2
0000000000000000000000000000000000000000;;			s.w.Trigger(req.ID, s.applyV2Request(req))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do not re-apply applied entries.
0000000000000000000000000000000000000000;;		if !shouldApplyV3 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := raftReq.ID
0000000000000000000000000000000000000000;;		if id == 0 {
0000000000000000000000000000000000000000;;			id = raftReq.Header.ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ar *applyResult
0000000000000000000000000000000000000000;;		needResult := s.w.IsRegistered(id)
0000000000000000000000000000000000000000;;		if needResult || !noSideEffect(&raftReq) {
0000000000000000000000000000000000000000;;			if !needResult && raftReq.Txn != nil {
0000000000000000000000000000000000000000;;				removeNeedlessRangeReqs(raftReq.Txn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ar = s.applyV3.Apply(&raftReq)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ar == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ar.err != ErrNoSpace || len(s.alarmStore.Get(pb.AlarmType_NOSPACE)) > 0 {
0000000000000000000000000000000000000000;;			s.w.Trigger(id, ar)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Errorf("applying raft message exceeded backend quota")
0000000000000000000000000000000000000000;;		s.goAttach(func() {
0000000000000000000000000000000000000000;;			a := &pb.AlarmRequest{
0000000000000000000000000000000000000000;;				MemberID: uint64(s.ID()),
0000000000000000000000000000000000000000;;				Action:   pb.AlarmRequest_ACTIVATE,
0000000000000000000000000000000000000000;;				Alarm:    pb.AlarmType_NOSPACE,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r := pb.InternalRaftRequest{Alarm: a}
0000000000000000000000000000000000000000;;			s.processInternalRaftRequest(context.TODO(), r)
0000000000000000000000000000000000000000;;			s.w.Trigger(id, ar)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyConfChange applies a ConfChange to the server. It is only
0000000000000000000000000000000000000000;;	// invoked with a ConfChange that has already passed through Raft
0000000000000000000000000000000000000000;;	func (s *EtcdServer) applyConfChange(cc raftpb.ConfChange, confState *raftpb.ConfState) (bool, error) {
0000000000000000000000000000000000000000;;		if err := s.cluster.ValidateConfigurationChange(cc); err != nil {
0000000000000000000000000000000000000000;;			cc.NodeID = raft.None
0000000000000000000000000000000000000000;;			s.r.ApplyConfChange(cc)
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*confState = *s.r.ApplyConfChange(cc)
0000000000000000000000000000000000000000;;		switch cc.Type {
0000000000000000000000000000000000000000;;		case raftpb.ConfChangeAddNode:
0000000000000000000000000000000000000000;;			m := new(membership.Member)
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(cc.Context, m); err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("unmarshal member should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cc.NodeID != uint64(m.ID) {
0000000000000000000000000000000000000000;;				plog.Panicf("nodeID should always be equal to member ID")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.cluster.AddMember(m)
0000000000000000000000000000000000000000;;			if m.ID != s.id {
0000000000000000000000000000000000000000;;				s.r.transport.AddPeer(m.ID, m.PeerURLs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case raftpb.ConfChangeRemoveNode:
0000000000000000000000000000000000000000;;			id := types.ID(cc.NodeID)
0000000000000000000000000000000000000000;;			s.cluster.RemoveMember(id)
0000000000000000000000000000000000000000;;			if id == s.id {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.r.transport.RemovePeer(id)
0000000000000000000000000000000000000000;;		case raftpb.ConfChangeUpdateNode:
0000000000000000000000000000000000000000;;			m := new(membership.Member)
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(cc.Context, m); err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("unmarshal member should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cc.NodeID != uint64(m.ID) {
0000000000000000000000000000000000000000;;				plog.Panicf("nodeID should always be equal to member ID")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.cluster.UpdateRaftAttributes(m.ID, m.RaftAttributes)
0000000000000000000000000000000000000000;;			if m.ID != s.id {
0000000000000000000000000000000000000000;;				s.r.transport.UpdatePeer(m.ID, m.PeerURLs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: non-blocking snapshot
0000000000000000000000000000000000000000;;	func (s *EtcdServer) snapshot(snapi uint64, confState raftpb.ConfState) {
0000000000000000000000000000000000000000;;		clone := s.store.Clone()
0000000000000000000000000000000000000000;;		// commit kv to write metadata (for example: consistent index) to disk.
0000000000000000000000000000000000000000;;		// KV().commit() updates the consistent index in backend.
0000000000000000000000000000000000000000;;		// All operations that update consistent index must be called sequentially
0000000000000000000000000000000000000000;;		// from applyAll function.
0000000000000000000000000000000000000000;;		// So KV().Commit() cannot run in parallel with apply. It has to be called outside
0000000000000000000000000000000000000000;;		// the go routine created below.
0000000000000000000000000000000000000000;;		s.KV().Commit()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.goAttach(func() {
0000000000000000000000000000000000000000;;			d, err := clone.SaveNoCopy()
0000000000000000000000000000000000000000;;			// TODO: current store will never fail to do a snapshot
0000000000000000000000000000000000000000;;			// what should we do if the store might fail?
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("store save should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			snap, err := s.r.raftStorage.CreateSnapshot(snapi, &confState, d)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// the snapshot was done asynchronously with the progress of raft.
0000000000000000000000000000000000000000;;				// raft might have already got a newer snapshot.
0000000000000000000000000000000000000000;;				if err == raft.ErrSnapOutOfDate {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Panicf("unexpected create snapshot error %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// SaveSnap saves the snapshot and releases the locked wal files
0000000000000000000000000000000000000000;;			// to the snapshot index.
0000000000000000000000000000000000000000;;			if err = s.r.storage.SaveSnap(snap); err != nil {
0000000000000000000000000000000000000000;;				plog.Fatalf("save snapshot error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Infof("saved snapshot at index %d", snap.Metadata.Index)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// When sending a snapshot, etcd will pause compaction.
0000000000000000000000000000000000000000;;			// After receives a snapshot, the slow follower needs to get all the entries right after
0000000000000000000000000000000000000000;;			// the snapshot sent to catch up. If we do not pause compaction, the log entries right after
0000000000000000000000000000000000000000;;			// the snapshot sent might already be compacted. It happens when the snapshot takes long time
0000000000000000000000000000000000000000;;			// to send and save. Pausing compaction avoids triggering a snapshot sending cycle.
0000000000000000000000000000000000000000;;			if atomic.LoadInt64(&s.inflightSnapshots) != 0 {
0000000000000000000000000000000000000000;;				plog.Infof("skip compaction since there is an inflight snapshot")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// keep some in memory log entries for slow followers.
0000000000000000000000000000000000000000;;			compacti := uint64(1)
0000000000000000000000000000000000000000;;			if snapi > numberOfCatchUpEntries {
0000000000000000000000000000000000000000;;				compacti = snapi - numberOfCatchUpEntries
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = s.r.raftStorage.Compact(compacti)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// the compaction was done asynchronously with the progress of raft.
0000000000000000000000000000000000000000;;				// raft log might already been compact.
0000000000000000000000000000000000000000;;				if err == raft.ErrCompacted {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Panicf("unexpected compaction error %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Infof("compacted raft log at %d", compacti)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CutPeer drops messages to the specified peer.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) CutPeer(id types.ID) {
0000000000000000000000000000000000000000;;		tr, ok := s.r.transport.(*rafthttp.Transport)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			tr.CutPeer(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MendPeer recovers the message dropping behavior of the given peer.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) MendPeer(id types.ID) {
0000000000000000000000000000000000000000;;		tr, ok := s.r.transport.(*rafthttp.Transport)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			tr.MendPeer(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) PauseSending() { s.r.pauseSending() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) ResumeSending() { s.r.resumeSending() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) ClusterVersion() *semver.Version {
0000000000000000000000000000000000000000;;		if s.cluster == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.cluster.Version()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// monitorVersions checks the member's version every monitorVersionInterval.
0000000000000000000000000000000000000000;;	// It updates the cluster version if all members agrees on a higher one.
0000000000000000000000000000000000000000;;	// It prints out log if there is a member with a higher version than the
0000000000000000000000000000000000000000;;	// local version.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) monitorVersions() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-s.forceVersionC:
0000000000000000000000000000000000000000;;			case <-time.After(monitorVersionInterval):
0000000000000000000000000000000000000000;;			case <-s.stopping:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if s.Leader() != s.ID() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v := decideClusterVersion(getVersions(s.cluster, s.id, s.peerRt))
0000000000000000000000000000000000000000;;			if v != nil {
0000000000000000000000000000000000000000;;				// only keep major.minor version for comparison
0000000000000000000000000000000000000000;;				v = &semver.Version{
0000000000000000000000000000000000000000;;					Major: v.Major,
0000000000000000000000000000000000000000;;					Minor: v.Minor,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if the current version is nil:
0000000000000000000000000000000000000000;;			// 1. use the decided version if possible
0000000000000000000000000000000000000000;;			// 2. or use the min cluster version
0000000000000000000000000000000000000000;;			if s.cluster.Version() == nil {
0000000000000000000000000000000000000000;;				verStr := version.MinClusterVersion
0000000000000000000000000000000000000000;;				if v != nil {
0000000000000000000000000000000000000000;;					verStr = v.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.goAttach(func() { s.updateClusterVersion(verStr) })
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// update cluster version only if the decided version is greater than
0000000000000000000000000000000000000000;;			// the current cluster version
0000000000000000000000000000000000000000;;			if v != nil && s.cluster.Version().LessThan(*v) {
0000000000000000000000000000000000000000;;				s.goAttach(func() { s.updateClusterVersion(v.String()) })
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) updateClusterVersion(ver string) {
0000000000000000000000000000000000000000;;		if s.cluster.Version() == nil {
0000000000000000000000000000000000000000;;			plog.Infof("setting up the initial cluster version to %s", version.Cluster(ver))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			plog.Infof("updating the cluster version from %s to %s", version.Cluster(s.cluster.Version().String()), version.Cluster(ver))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := pb.Request{
0000000000000000000000000000000000000000;;			Method: "PUT",
0000000000000000000000000000000000000000;;			Path:   membership.StoreClusterVersionKey(),
0000000000000000000000000000000000000000;;			Val:    ver,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), s.Cfg.ReqTimeout())
0000000000000000000000000000000000000000;;		_, err := s.Do(ctx, req)
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case ErrStopped:
0000000000000000000000000000000000000000;;			plog.Infof("aborting update cluster version because server is stopped")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			plog.Errorf("error updating cluster version (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) parseProposeCtxErr(err error, start time.Time) error {
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		case context.Canceled:
0000000000000000000000000000000000000000;;			return ErrCanceled
0000000000000000000000000000000000000000;;		case context.DeadlineExceeded:
0000000000000000000000000000000000000000;;			curLeadElected := s.r.leadElectedTime()
0000000000000000000000000000000000000000;;			prevLeadLost := curLeadElected.Add(-2 * time.Duration(s.Cfg.ElectionTicks) * time.Duration(s.Cfg.TickMs) * time.Millisecond)
0000000000000000000000000000000000000000;;			if start.After(prevLeadLost) && start.Before(curLeadElected) {
0000000000000000000000000000000000000000;;				return ErrTimeoutDueToLeaderFail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lead := types.ID(atomic.LoadUint64(&s.r.lead))
0000000000000000000000000000000000000000;;			switch lead {
0000000000000000000000000000000000000000;;			case types.ID(raft.None):
0000000000000000000000000000000000000000;;				// TODO: return error to specify it happens because the cluster does not have leader now
0000000000000000000000000000000000000000;;			case s.ID():
0000000000000000000000000000000000000000;;				if !isConnectedToQuorumSince(s.r.transport, start, s.ID(), s.cluster.Members()) {
0000000000000000000000000000000000000000;;					return ErrTimeoutDueToConnectionLost
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if !isConnectedSince(s.r.transport, start, lead) {
0000000000000000000000000000000000000000;;					return ErrTimeoutDueToConnectionLost
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ErrTimeout
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) KV() mvcc.ConsistentWatchableKV { return s.kv }
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Backend() backend.Backend {
0000000000000000000000000000000000000000;;		s.bemu.Lock()
0000000000000000000000000000000000000000;;		defer s.bemu.Unlock()
0000000000000000000000000000000000000000;;		return s.be
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) AuthStore() auth.AuthStore { return s.authStore }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) restoreAlarms() error {
0000000000000000000000000000000000000000;;		s.applyV3 = s.newApplierV3()
0000000000000000000000000000000000000000;;		as, err := alarm.NewAlarmStore(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.alarmStore = as
0000000000000000000000000000000000000000;;		if len(as.Get(pb.AlarmType_NOSPACE)) > 0 {
0000000000000000000000000000000000000000;;			s.applyV3 = newApplierV3Capped(s.applyV3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) getAppliedIndex() uint64 {
0000000000000000000000000000000000000000;;		return atomic.LoadUint64(&s.appliedIndex)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) setAppliedIndex(v uint64) {
0000000000000000000000000000000000000000;;		atomic.StoreUint64(&s.appliedIndex, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) getCommittedIndex() uint64 {
0000000000000000000000000000000000000000;;		return atomic.LoadUint64(&s.committedIndex)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) setCommittedIndex(v uint64) {
0000000000000000000000000000000000000000;;		atomic.StoreUint64(&s.committedIndex, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goAttach creates a goroutine on a given function and tracks it using
0000000000000000000000000000000000000000;;	// the etcdserver waitgroup.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) goAttach(f func()) {
0000000000000000000000000000000000000000;;		s.wgMu.RLock() // this blocks with ongoing close(s.stopping)
0000000000000000000000000000000000000000;;		defer s.wgMu.RUnlock()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.stopping:
0000000000000000000000000000000000000000;;			plog.Warning("server has stopped (skipping goAttach)")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now safe to add since waitgroup wait has not started yet
0000000000000000000000000000000000000000;;		s.wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer s.wg.Done()
0000000000000000000000000000000000000000;;			f()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
