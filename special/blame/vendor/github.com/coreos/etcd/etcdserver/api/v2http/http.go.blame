0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/etcdhttp/http.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/etcdhttp/http.go][vendor/github.com/coreos/etcd/etcdserver/api/v2http/http.go];	
0000000000000000000000000000000000000000;;	package v2http
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdErr "github.com/coreos/etcd/error"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/auth"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/logutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// time to wait for a Watch request
0000000000000000000000000000000000000000;;		defaultWatchTimeout = time.Duration(math.MaxInt64)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "etcdserver/api/v2http")
0000000000000000000000000000000000000000;;		mlog = logutil.NewMergeLogger(plog)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeError logs and writes the given Error to the ResponseWriter
0000000000000000000000000000000000000000;;	// If Error is an etcdErr, it is rendered to the ResponseWriter
0000000000000000000000000000000000000000;;	// Otherwise, it is assumed to be a StatusInternalServerError
0000000000000000000000000000000000000000;;	func writeError(w http.ResponseWriter, r *http.Request, err error) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch e := err.(type) {
0000000000000000000000000000000000000000;;		case *etcdErr.Error:
0000000000000000000000000000000000000000;;			e.WriteTo(w)
0000000000000000000000000000000000000000;;		case *httptypes.HTTPError:
0000000000000000000000000000000000000000;;			if et := e.WriteTo(w); et != nil {
0000000000000000000000000000000000000000;;				plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case auth.Error:
0000000000000000000000000000000000000000;;			herr := httptypes.NewHTTPError(e.HTTPStatus(), e.Error())
0000000000000000000000000000000000000000;;			if et := herr.WriteTo(w); et != nil {
0000000000000000000000000000000000000000;;				plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch err {
0000000000000000000000000000000000000000;;			case etcdserver.ErrTimeoutDueToLeaderFail, etcdserver.ErrTimeoutDueToConnectionLost, etcdserver.ErrNotEnoughStartedMembers, etcdserver.ErrUnhealthy:
0000000000000000000000000000000000000000;;				mlog.MergeError(err)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				mlog.MergeErrorf("got unexpected response error (%v)", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			herr := httptypes.NewHTTPError(http.StatusInternalServerError, "Internal Server Error")
0000000000000000000000000000000000000000;;			if et := herr.WriteTo(w); et != nil {
0000000000000000000000000000000000000000;;				plog.Debugf("error writing HTTPError (%v) to %s", et, r.RemoteAddr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allowMethod verifies that the given method is one of the allowed methods,
0000000000000000000000000000000000000000;;	// and if not, it writes an error to w.  A boolean is returned indicating
0000000000000000000000000000000000000000;;	// whether or not the method is allowed.
0000000000000000000000000000000000000000;;	func allowMethod(w http.ResponseWriter, m string, ms ...string) bool {
0000000000000000000000000000000000000000;;		for _, meth := range ms {
0000000000000000000000000000000000000000;;			if m == meth {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Allow", strings.Join(ms, ","))
0000000000000000000000000000000000000000;;		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func requestLogger(handler http.Handler) http.Handler {
0000000000000000000000000000000000000000;;		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			plog.Debugf("[%s] %s remote:%s", r.Method, r.RequestURI, r.RemoteAddr)
0000000000000000000000000000000000000000;;			handler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
