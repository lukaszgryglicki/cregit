0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/api/v3rpc/key.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/api/v3rpc/key.go][vendor/github.com/coreos/etcd/etcdserver/api/v3rpc/key.go];	
0000000000000000000000000000000000000000;;	// Package v3rpc implements etcd v3 RPC system based on gRPC.
0000000000000000000000000000000000000000;;	package v3rpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "etcdserver/api/v3rpc")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Max operations per txn list. For example, Txn.Success can have at most 128 operations,
0000000000000000000000000000000000000000;;		// and Txn.Failure can have at most 128 operations.
0000000000000000000000000000000000000000;;		MaxOpsPerTxn = 128
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kvServer struct {
0000000000000000000000000000000000000000;;		hdr header
0000000000000000000000000000000000000000;;		kv  etcdserver.RaftKV
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewKVServer(s *etcdserver.EtcdServer) pb.KVServer {
0000000000000000000000000000000000000000;;		return &kvServer{hdr: newHeader(s), kv: s}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *kvServer) Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
0000000000000000000000000000000000000000;;		if err := checkRangeRequest(r); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := s.kv.Range(ctx, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, togRPCError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Header == nil {
0000000000000000000000000000000000000000;;			plog.Panic("unexpected nil resp.Header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hdr.fill(resp.Header)
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *kvServer) Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error) {
0000000000000000000000000000000000000000;;		if err := checkPutRequest(r); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := s.kv.Put(ctx, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, togRPCError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Header == nil {
0000000000000000000000000000000000000000;;			plog.Panic("unexpected nil resp.Header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hdr.fill(resp.Header)
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *kvServer) DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error) {
0000000000000000000000000000000000000000;;		if err := checkDeleteRequest(r); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := s.kv.DeleteRange(ctx, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, togRPCError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Header == nil {
0000000000000000000000000000000000000000;;			plog.Panic("unexpected nil resp.Header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hdr.fill(resp.Header)
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *kvServer) Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error) {
0000000000000000000000000000000000000000;;		if err := checkTxnRequest(r); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := s.kv.Txn(ctx, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, togRPCError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Header == nil {
0000000000000000000000000000000000000000;;			plog.Panic("unexpected nil resp.Header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hdr.fill(resp.Header)
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *kvServer) Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error) {
0000000000000000000000000000000000000000;;		resp, err := s.kv.Compact(ctx, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, togRPCError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.Header == nil {
0000000000000000000000000000000000000000;;			plog.Panic("unexpected nil resp.Header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.hdr.fill(resp.Header)
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkRangeRequest(r *pb.RangeRequest) error {
0000000000000000000000000000000000000000;;		if len(r.Key) == 0 {
0000000000000000000000000000000000000000;;			return rpctypes.ErrGRPCEmptyKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkPutRequest(r *pb.PutRequest) error {
0000000000000000000000000000000000000000;;		if len(r.Key) == 0 {
0000000000000000000000000000000000000000;;			return rpctypes.ErrGRPCEmptyKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkDeleteRequest(r *pb.DeleteRangeRequest) error {
0000000000000000000000000000000000000000;;		if len(r.Key) == 0 {
0000000000000000000000000000000000000000;;			return rpctypes.ErrGRPCEmptyKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkTxnRequest(r *pb.TxnRequest) error {
0000000000000000000000000000000000000000;;		if len(r.Compare) > MaxOpsPerTxn || len(r.Success) > MaxOpsPerTxn || len(r.Failure) > MaxOpsPerTxn {
0000000000000000000000000000000000000000;;			return rpctypes.ErrGRPCTooManyOps
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range r.Compare {
0000000000000000000000000000000000000000;;			if len(c.Key) == 0 {
0000000000000000000000000000000000000000;;				return rpctypes.ErrGRPCEmptyKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, u := range r.Success {
0000000000000000000000000000000000000000;;			if err := checkRequestOp(u); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkRequestDupKeys(r.Success); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, u := range r.Failure {
0000000000000000000000000000000000000000;;			if err := checkRequestOp(u); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return checkRequestDupKeys(r.Failure)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkRequestDupKeys gives rpctypes.ErrGRPCDuplicateKey if the same key is modified twice
0000000000000000000000000000000000000000;;	func checkRequestDupKeys(reqs []*pb.RequestOp) error {
0000000000000000000000000000000000000000;;		// check put overlap
0000000000000000000000000000000000000000;;		keys := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, requ := range reqs {
0000000000000000000000000000000000000000;;			tv, ok := requ.Request.(*pb.RequestOp_RequestPut)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			preq := tv.RequestPut
0000000000000000000000000000000000000000;;			if preq == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := keys[string(preq.Key)]; ok {
0000000000000000000000000000000000000000;;				return rpctypes.ErrGRPCDuplicateKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keys[string(preq.Key)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no need to check deletes if no puts; delete overlaps are permitted
0000000000000000000000000000000000000000;;		if len(keys) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sort keys for range checking
0000000000000000000000000000000000000000;;		sortedKeys := []string{}
0000000000000000000000000000000000000000;;		for k := range keys {
0000000000000000000000000000000000000000;;			sortedKeys = append(sortedKeys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(sortedKeys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check put overlap with deletes
0000000000000000000000000000000000000000;;		for _, requ := range reqs {
0000000000000000000000000000000000000000;;			tv, ok := requ.Request.(*pb.RequestOp_RequestDeleteRange)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dreq := tv.RequestDeleteRange
0000000000000000000000000000000000000000;;			if dreq == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if dreq.RangeEnd == nil {
0000000000000000000000000000000000000000;;				if _, found := keys[string(dreq.Key)]; found {
0000000000000000000000000000000000000000;;					return rpctypes.ErrGRPCDuplicateKey
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				lo := sort.SearchStrings(sortedKeys, string(dreq.Key))
0000000000000000000000000000000000000000;;				hi := sort.SearchStrings(sortedKeys, string(dreq.RangeEnd))
0000000000000000000000000000000000000000;;				if lo != hi {
0000000000000000000000000000000000000000;;					// element between lo and hi => overlap
0000000000000000000000000000000000000000;;					return rpctypes.ErrGRPCDuplicateKey
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkRequestOp(u *pb.RequestOp) error {
0000000000000000000000000000000000000000;;		// TODO: ensure only one of the field is set.
0000000000000000000000000000000000000000;;		switch uv := u.Request.(type) {
0000000000000000000000000000000000000000;;		case *pb.RequestOp_RequestRange:
0000000000000000000000000000000000000000;;			if uv.RequestRange != nil {
0000000000000000000000000000000000000000;;				return checkRangeRequest(uv.RequestRange)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *pb.RequestOp_RequestPut:
0000000000000000000000000000000000000000;;			if uv.RequestPut != nil {
0000000000000000000000000000000000000000;;				return checkPutRequest(uv.RequestPut)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *pb.RequestOp_RequestDeleteRange:
0000000000000000000000000000000000000000;;			if uv.RequestDeleteRange != nil {
0000000000000000000000000000000000000000;;				return checkDeleteRequest(uv.RequestDeleteRange)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// empty op
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
