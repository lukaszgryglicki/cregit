0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/etcdhttp/client.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/etcdhttp/client.go][vendor/github.com/coreos/etcd/etcdserver/api/v2http/client.go];	
0000000000000000000000000000000000000000;;	package v2http
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"expvar"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdErr "github.com/coreos/etcd/error"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/auth"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/membership"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/stats"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/store"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/version"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;		"github.com/prometheus/client_golang/prometheus"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		authPrefix               = "/v2/auth"
0000000000000000000000000000000000000000;;		keysPrefix               = "/v2/keys"
0000000000000000000000000000000000000000;;		deprecatedMachinesPrefix = "/v2/machines"
0000000000000000000000000000000000000000;;		membersPrefix            = "/v2/members"
0000000000000000000000000000000000000000;;		statsPrefix              = "/v2/stats"
0000000000000000000000000000000000000000;;		varsPath                 = "/debug/vars"
0000000000000000000000000000000000000000;;		metricsPath              = "/metrics"
0000000000000000000000000000000000000000;;		healthPath               = "/health"
0000000000000000000000000000000000000000;;		versionPath              = "/version"
0000000000000000000000000000000000000000;;		configPath               = "/config"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientHandler generates a muxed http.Handler with the given parameters to serve etcd client requests.
0000000000000000000000000000000000000000;;	func NewClientHandler(server *etcdserver.EtcdServer, timeout time.Duration) http.Handler {
0000000000000000000000000000000000000000;;		sec := auth.NewStore(server, timeout)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kh := &keysHandler{
0000000000000000000000000000000000000000;;			sec:                   sec,
0000000000000000000000000000000000000000;;			server:                server,
0000000000000000000000000000000000000000;;			cluster:               server.Cluster(),
0000000000000000000000000000000000000000;;			timer:                 server,
0000000000000000000000000000000000000000;;			timeout:               timeout,
0000000000000000000000000000000000000000;;			clientCertAuthEnabled: server.Cfg.ClientCertAuthEnabled,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sh := &statsHandler{
0000000000000000000000000000000000000000;;			stats: server,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mh := &membersHandler{
0000000000000000000000000000000000000000;;			sec:     sec,
0000000000000000000000000000000000000000;;			server:  server,
0000000000000000000000000000000000000000;;			cluster: server.Cluster(),
0000000000000000000000000000000000000000;;			timeout: timeout,
0000000000000000000000000000000000000000;;			clock:   clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;			clientCertAuthEnabled: server.Cfg.ClientCertAuthEnabled,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dmh := &deprecatedMachinesHandler{
0000000000000000000000000000000000000000;;			cluster: server.Cluster(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sech := &authHandler{
0000000000000000000000000000000000000000;;			sec:                   sec,
0000000000000000000000000000000000000000;;			cluster:               server.Cluster(),
0000000000000000000000000000000000000000;;			clientCertAuthEnabled: server.Cfg.ClientCertAuthEnabled,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;		mux.HandleFunc("/", http.NotFound)
0000000000000000000000000000000000000000;;		mux.Handle(healthPath, healthHandler(server))
0000000000000000000000000000000000000000;;		mux.HandleFunc(versionPath, versionHandler(server.Cluster(), serveVersion))
0000000000000000000000000000000000000000;;		mux.Handle(keysPrefix, kh)
0000000000000000000000000000000000000000;;		mux.Handle(keysPrefix+"/", kh)
0000000000000000000000000000000000000000;;		mux.HandleFunc(statsPrefix+"/store", sh.serveStore)
0000000000000000000000000000000000000000;;		mux.HandleFunc(statsPrefix+"/self", sh.serveSelf)
0000000000000000000000000000000000000000;;		mux.HandleFunc(statsPrefix+"/leader", sh.serveLeader)
0000000000000000000000000000000000000000;;		mux.HandleFunc(varsPath, serveVars)
0000000000000000000000000000000000000000;;		mux.HandleFunc(configPath+"/local/log", logHandleFunc)
0000000000000000000000000000000000000000;;		mux.Handle(metricsPath, prometheus.Handler())
0000000000000000000000000000000000000000;;		mux.Handle(membersPrefix, mh)
0000000000000000000000000000000000000000;;		mux.Handle(membersPrefix+"/", mh)
0000000000000000000000000000000000000000;;		mux.Handle(deprecatedMachinesPrefix, dmh)
0000000000000000000000000000000000000000;;		handleAuth(mux, sech)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return requestLogger(mux)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type keysHandler struct {
0000000000000000000000000000000000000000;;		sec                   auth.Store
0000000000000000000000000000000000000000;;		server                etcdserver.Server
0000000000000000000000000000000000000000;;		cluster               api.Cluster
0000000000000000000000000000000000000000;;		timer                 etcdserver.RaftTimer
0000000000000000000000000000000000000000;;		timeout               time.Duration
0000000000000000000000000000000000000000;;		clientCertAuthEnabled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *keysHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "HEAD", "GET", "PUT", "POST", "DELETE") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), h.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;		clock := clockwork.NewRealClock()
0000000000000000000000000000000000000000;;		startTime := clock.Now()
0000000000000000000000000000000000000000;;		rr, noValueOnSuccess, err := parseKeyRequest(r, clock)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeKeyError(w, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The path must be valid at this point (we've parsed the request successfully).
0000000000000000000000000000000000000000;;		if !hasKeyPrefixAccess(h.sec, r, r.URL.Path[len(keysPrefix):], rr.Recursive, h.clientCertAuthEnabled) {
0000000000000000000000000000000000000000;;			writeKeyNoAuth(w)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !rr.Wait {
0000000000000000000000000000000000000000;;			reportRequestReceived(rr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := h.server.Do(ctx, rr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = trimErrorPrefix(err, etcdserver.StoreKeysPrefix)
0000000000000000000000000000000000000000;;			writeKeyError(w, err)
0000000000000000000000000000000000000000;;			reportRequestFailed(rr, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case resp.Event != nil:
0000000000000000000000000000000000000000;;			if err := writeKeyEvent(w, resp.Event, noValueOnSuccess, h.timer); err != nil {
0000000000000000000000000000000000000000;;				// Should never be reached
0000000000000000000000000000000000000000;;				plog.Errorf("error writing event (%v)", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reportRequestCompleted(rr, resp, startTime)
0000000000000000000000000000000000000000;;		case resp.Watcher != nil:
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(context.Background(), defaultWatchTimeout)
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;			handleKeyWatch(ctx, w, resp.Watcher, rr.Stream, h.timer)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			writeKeyError(w, errors.New("received response with no Event/Watcher!"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deprecatedMachinesHandler struct {
0000000000000000000000000000000000000000;;		cluster api.Cluster
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *deprecatedMachinesHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET", "HEAD") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		endpoints := h.cluster.ClientURLs()
0000000000000000000000000000000000000000;;		w.Write([]byte(strings.Join(endpoints, ", ")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type membersHandler struct {
0000000000000000000000000000000000000000;;		sec                   auth.Store
0000000000000000000000000000000000000000;;		server                etcdserver.Server
0000000000000000000000000000000000000000;;		cluster               api.Cluster
0000000000000000000000000000000000000000;;		timeout               time.Duration
0000000000000000000000000000000000000000;;		clock                 clockwork.Clock
0000000000000000000000000000000000000000;;		clientCertAuthEnabled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *membersHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET", "POST", "DELETE", "PUT") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasWriteRootAccess(h.sec, r, h.clientCertAuthEnabled) {
0000000000000000000000000000000000000000;;			writeNoAuth(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", h.cluster.ID().String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), h.timeout)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch r.Method {
0000000000000000000000000000000000000000;;		case "GET":
0000000000000000000000000000000000000000;;			switch trimPrefix(r.URL.Path, membersPrefix) {
0000000000000000000000000000000000000000;;			case "":
0000000000000000000000000000000000000000;;				mc := newMemberCollection(h.cluster.Members())
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				if err := json.NewEncoder(w).Encode(mc); err != nil {
0000000000000000000000000000000000000000;;					plog.Warningf("failed to encode members response (%v)", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "leader":
0000000000000000000000000000000000000000;;				id := h.server.Leader()
0000000000000000000000000000000000000000;;				if id == 0 {
0000000000000000000000000000000000000000;;					writeError(w, r, httptypes.NewHTTPError(http.StatusServiceUnavailable, "During election"))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m := newMember(h.cluster.Member(id))
0000000000000000000000000000000000000000;;				w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;				if err := json.NewEncoder(w).Encode(m); err != nil {
0000000000000000000000000000000000000000;;					plog.Warningf("failed to encode members response (%v)", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, "Not found"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "POST":
0000000000000000000000000000000000000000;;			req := httptypes.MemberCreateRequest{}
0000000000000000000000000000000000000000;;			if ok := unmarshalRequest(r, &req, w); !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			now := h.clock.Now()
0000000000000000000000000000000000000000;;			m := membership.NewMember("", req.PeerURLs, "", &now)
0000000000000000000000000000000000000000;;			err := h.server.AddMember(ctx, *m)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == membership.ErrIDExists || err == membership.ErrPeerURLexists:
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusConflict, err.Error()))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				plog.Errorf("error adding member %s (%v)", m.ID, err)
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res := newMember(m)
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusCreated)
0000000000000000000000000000000000000000;;			if err := json.NewEncoder(w).Encode(res); err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("failed to encode members response (%v)", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "DELETE":
0000000000000000000000000000000000000000;;			id, ok := getID(r.URL.Path, w)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := h.server.RemoveMember(ctx, uint64(id))
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == membership.ErrIDRemoved:
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusGone, fmt.Sprintf("Member permanently removed: %s", id)))
0000000000000000000000000000000000000000;;			case err == membership.ErrIDNotFound:
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", id)))
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				plog.Errorf("error removing member %s (%v)", id, err)
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNoContent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "PUT":
0000000000000000000000000000000000000000;;			id, ok := getID(r.URL.Path, w)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req := httptypes.MemberUpdateRequest{}
0000000000000000000000000000000000000000;;			if ok := unmarshalRequest(r, &req, w); !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m := membership.Member{
0000000000000000000000000000000000000000;;				ID:             id,
0000000000000000000000000000000000000000;;				RaftAttributes: membership.RaftAttributes{PeerURLs: req.PeerURLs.StringSlice()},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := h.server.UpdateMember(ctx, m)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == membership.ErrPeerURLexists:
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusConflict, err.Error()))
0000000000000000000000000000000000000000;;			case err == membership.ErrIDNotFound:
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", id)))
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				plog.Errorf("error updating member %s (%v)", m.ID, err)
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusNoContent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type statsHandler struct {
0000000000000000000000000000000000000000;;		stats stats.Stats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *statsHandler) serveStore(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Write(h.stats.StoreStats())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *statsHandler) serveSelf(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Write(h.stats.SelfStats())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *statsHandler) serveLeader(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats := h.stats.LeaderStats()
0000000000000000000000000000000000000000;;		if stats == nil {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusForbidden, "not current leader"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Write(stats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serveVars(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json; charset=utf-8")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "{\n")
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		expvar.Do(func(kv expvar.KeyValue) {
0000000000000000000000000000000000000000;;			if !first {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, ",\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			first = false
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%q: %s", kv.Key, kv.Value)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "\n}\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func healthHandler(server *etcdserver.EtcdServer) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if uint64(server.Leader()) == raft.None {
0000000000000000000000000000000000000000;;				http.Error(w, `{"health": "false"}`, http.StatusServiceUnavailable)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(context.Background(), time.Second)
0000000000000000000000000000000000000000;;			defer cancel()
0000000000000000000000000000000000000000;;			if _, err := server.Do(ctx, etcdserverpb.Request{Method: "QGET"}); err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, `{"health": "false"}`, http.StatusServiceUnavailable)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			w.Write([]byte(`{"health": "true"}`))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func versionHandler(c api.Cluster, fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			v := c.Version()
0000000000000000000000000000000000000000;;			if v != nil {
0000000000000000000000000000000000000000;;				fn(w, r, v.String())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fn(w, r, "not_decided")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serveVersion(w http.ResponseWriter, r *http.Request, clusterV string) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vs := version.Versions{
0000000000000000000000000000000000000000;;			Server:  version.Version,
0000000000000000000000000000000000000000;;			Cluster: clusterV,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		b, err := json.Marshal(&vs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("cannot marshal versions to json (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logHandleFunc(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "PUT") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in := struct{ Level string }{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := json.NewDecoder(r.Body)
0000000000000000000000000000000000000000;;		if err := d.Decode(&in); err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid json body"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logl, err := capnslog.ParseLevel(strings.ToUpper(in.Level))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid log level "+in.Level))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("globalLogLevel set to %q", logl.String())
0000000000000000000000000000000000000000;;		capnslog.SetGlobalLogLevel(logl)
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusNoContent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseKeyRequest converts a received http.Request on keysPrefix to
0000000000000000000000000000000000000000;;	// a server Request, performing validation of supplied fields as appropriate.
0000000000000000000000000000000000000000;;	// If any validation fails, an empty Request and non-nil error is returned.
0000000000000000000000000000000000000000;;	func parseKeyRequest(r *http.Request, clock clockwork.Clock) (etcdserverpb.Request, bool, error) {
0000000000000000000000000000000000000000;;		noValueOnSuccess := false
0000000000000000000000000000000000000000;;		emptyReq := etcdserverpb.Request{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := r.ParseForm()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidForm,
0000000000000000000000000000000000000000;;				err.Error(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(r.URL.Path, keysPrefix) {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidForm,
0000000000000000000000000000000000000000;;				"incorrect key prefix",
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := path.Join(etcdserver.StoreKeysPrefix, r.URL.Path[len(keysPrefix):])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pIdx, wIdx uint64
0000000000000000000000000000000000000000;;		if pIdx, err = getUint64(r.Form, "prevIndex"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeIndexNaN,
0000000000000000000000000000000000000000;;				`invalid value for "prevIndex"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wIdx, err = getUint64(r.Form, "waitIndex"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeIndexNaN,
0000000000000000000000000000000000000000;;				`invalid value for "waitIndex"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rec, sort, wait, dir, quorum, stream bool
0000000000000000000000000000000000000000;;		if rec, err = getBool(r.Form, "recursive"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`invalid value for "recursive"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sort, err = getBool(r.Form, "sorted"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`invalid value for "sorted"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wait, err = getBool(r.Form, "wait"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`invalid value for "wait"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(jonboulle): define what parameters dir is/isn't compatible with?
0000000000000000000000000000000000000000;;		if dir, err = getBool(r.Form, "dir"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`invalid value for "dir"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if quorum, err = getBool(r.Form, "quorum"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`invalid value for "quorum"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stream, err = getBool(r.Form, "stream"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`invalid value for "stream"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if wait && r.Method != "GET" {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`"wait" can only be used with GET requests`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pV := r.FormValue("prevValue")
0000000000000000000000000000000000000000;;		if _, ok := r.Form["prevValue"]; ok && pV == "" {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodePrevValueRequired,
0000000000000000000000000000000000000000;;				`"prevValue" cannot be empty`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if noValueOnSuccess, err = getBool(r.Form, "noValueOnSuccess"); err != nil {
0000000000000000000000000000000000000000;;			return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;				etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;				`invalid value for "noValueOnSuccess"`,
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTL is nullable, so leave it null if not specified
0000000000000000000000000000000000000000;;		// or an empty string
0000000000000000000000000000000000000000;;		var ttl *uint64
0000000000000000000000000000000000000000;;		if len(r.FormValue("ttl")) > 0 {
0000000000000000000000000000000000000000;;			i, err := getUint64(r.Form, "ttl")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;					etcdErr.EcodeTTLNaN,
0000000000000000000000000000000000000000;;					`invalid value for "ttl"`,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ttl = &i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// prevExist is nullable, so leave it null if not specified
0000000000000000000000000000000000000000;;		var pe *bool
0000000000000000000000000000000000000000;;		if _, ok := r.Form["prevExist"]; ok {
0000000000000000000000000000000000000000;;			bv, err := getBool(r.Form, "prevExist")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;					etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;					"invalid value for prevExist",
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pe = &bv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// refresh is nullable, so leave it null if not specified
0000000000000000000000000000000000000000;;		var refresh *bool
0000000000000000000000000000000000000000;;		if _, ok := r.Form["refresh"]; ok {
0000000000000000000000000000000000000000;;			bv, err := getBool(r.Form, "refresh")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;					etcdErr.EcodeInvalidField,
0000000000000000000000000000000000000000;;					"invalid value for refresh",
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			refresh = &bv
0000000000000000000000000000000000000000;;			if refresh != nil && *refresh {
0000000000000000000000000000000000000000;;				val := r.FormValue("value")
0000000000000000000000000000000000000000;;				if _, ok := r.Form["value"]; ok && val != "" {
0000000000000000000000000000000000000000;;					return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;						etcdErr.EcodeRefreshValue,
0000000000000000000000000000000000000000;;						`A value was provided on a refresh`,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ttl == nil {
0000000000000000000000000000000000000000;;					return emptyReq, false, etcdErr.NewRequestError(
0000000000000000000000000000000000000000;;						etcdErr.EcodeRefreshTTLRequired,
0000000000000000000000000000000000000000;;						`No TTL value set`,
0000000000000000000000000000000000000000;;					)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr := etcdserverpb.Request{
0000000000000000000000000000000000000000;;			Method:    r.Method,
0000000000000000000000000000000000000000;;			Path:      p,
0000000000000000000000000000000000000000;;			Val:       r.FormValue("value"),
0000000000000000000000000000000000000000;;			Dir:       dir,
0000000000000000000000000000000000000000;;			PrevValue: pV,
0000000000000000000000000000000000000000;;			PrevIndex: pIdx,
0000000000000000000000000000000000000000;;			PrevExist: pe,
0000000000000000000000000000000000000000;;			Wait:      wait,
0000000000000000000000000000000000000000;;			Since:     wIdx,
0000000000000000000000000000000000000000;;			Recursive: rec,
0000000000000000000000000000000000000000;;			Sorted:    sort,
0000000000000000000000000000000000000000;;			Quorum:    quorum,
0000000000000000000000000000000000000000;;			Stream:    stream,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pe != nil {
0000000000000000000000000000000000000000;;			rr.PrevExist = pe
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if refresh != nil {
0000000000000000000000000000000000000000;;			rr.Refresh = refresh
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Null TTL is equivalent to unset Expiration
0000000000000000000000000000000000000000;;		if ttl != nil {
0000000000000000000000000000000000000000;;			expr := time.Duration(*ttl) * time.Second
0000000000000000000000000000000000000000;;			rr.Expiration = clock.Now().Add(expr).UnixNano()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rr, noValueOnSuccess, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeKeyEvent trims the prefix of key path in a single Event under
0000000000000000000000000000000000000000;;	// StoreKeysPrefix, serializes it and writes the resulting JSON to the given
0000000000000000000000000000000000000000;;	// ResponseWriter, along with the appropriate headers.
0000000000000000000000000000000000000000;;	func writeKeyEvent(w http.ResponseWriter, ev *store.Event, noValueOnSuccess bool, rt etcdserver.RaftTimer) error {
0000000000000000000000000000000000000000;;		if ev == nil {
0000000000000000000000000000000000000000;;			return errors.New("cannot write empty Event!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Index", fmt.Sprint(ev.EtcdIndex))
0000000000000000000000000000000000000000;;		w.Header().Set("X-Raft-Index", fmt.Sprint(rt.Index()))
0000000000000000000000000000000000000000;;		w.Header().Set("X-Raft-Term", fmt.Sprint(rt.Term()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ev.IsCreated() {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusCreated)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ev = trimEventPrefix(ev, etcdserver.StoreKeysPrefix)
0000000000000000000000000000000000000000;;		if noValueOnSuccess &&
0000000000000000000000000000000000000000;;			(ev.Action == store.Set || ev.Action == store.CompareAndSwap ||
0000000000000000000000000000000000000000;;				ev.Action == store.Create || ev.Action == store.Update) {
0000000000000000000000000000000000000000;;			ev.Node = nil
0000000000000000000000000000000000000000;;			ev.PrevNode = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.NewEncoder(w).Encode(ev)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeKeyNoAuth(w http.ResponseWriter) {
0000000000000000000000000000000000000000;;		e := etcdErr.NewError(etcdErr.EcodeUnauthorized, "Insufficient credentials", 0)
0000000000000000000000000000000000000000;;		e.WriteTo(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeKeyError logs and writes the given Error to the ResponseWriter.
0000000000000000000000000000000000000000;;	// If Error is not an etcdErr, the error will be converted to an etcd error.
0000000000000000000000000000000000000000;;	func writeKeyError(w http.ResponseWriter, err error) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch e := err.(type) {
0000000000000000000000000000000000000000;;		case *etcdErr.Error:
0000000000000000000000000000000000000000;;			e.WriteTo(w)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch err {
0000000000000000000000000000000000000000;;			case etcdserver.ErrTimeoutDueToLeaderFail, etcdserver.ErrTimeoutDueToConnectionLost:
0000000000000000000000000000000000000000;;				mlog.MergeError(err)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				mlog.MergeErrorf("got unexpected response error (%v)", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ee := etcdErr.NewError(etcdErr.EcodeRaftInternal, err.Error(), 0)
0000000000000000000000000000000000000000;;			ee.WriteTo(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleKeyWatch(ctx context.Context, w http.ResponseWriter, wa store.Watcher, stream bool, rt etcdserver.RaftTimer) {
0000000000000000000000000000000000000000;;		defer wa.Remove()
0000000000000000000000000000000000000000;;		ech := wa.EventChan()
0000000000000000000000000000000000000000;;		var nch <-chan bool
0000000000000000000000000000000000000000;;		if x, ok := w.(http.CloseNotifier); ok {
0000000000000000000000000000000000000000;;			nch = x.CloseNotify()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Index", fmt.Sprint(wa.StartIndex()))
0000000000000000000000000000000000000000;;		w.Header().Set("X-Raft-Index", fmt.Sprint(rt.Index()))
0000000000000000000000000000000000000000;;		w.Header().Set("X-Raft-Term", fmt.Sprint(rt.Term()))
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure headers are flushed early, in case of long polling
0000000000000000000000000000000000000000;;		w.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-nch:
0000000000000000000000000000000000000000;;				// Client closed connection. Nothing to do.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				// Timed out. net/http will close the connection for us, so nothing to do.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case ev, ok := <-ech:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// If the channel is closed this may be an indication of
0000000000000000000000000000000000000000;;					// that notifications are much more than we are able to
0000000000000000000000000000000000000000;;					// send to the client in time. Then we simply end streaming.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ev = trimEventPrefix(ev, etcdserver.StoreKeysPrefix)
0000000000000000000000000000000000000000;;				if err := json.NewEncoder(w).Encode(ev); err != nil {
0000000000000000000000000000000000000000;;					// Should never be reached
0000000000000000000000000000000000000000;;					plog.Warningf("error writing event (%v)", err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !stream {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trimEventPrefix(ev *store.Event, prefix string) *store.Event {
0000000000000000000000000000000000000000;;		if ev == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Since the *Event may reference one in the store history
0000000000000000000000000000000000000000;;		// history, we must copy it before modifying
0000000000000000000000000000000000000000;;		e := ev.Clone()
0000000000000000000000000000000000000000;;		trimNodeExternPrefix(e.Node, prefix)
0000000000000000000000000000000000000000;;		trimNodeExternPrefix(e.PrevNode, prefix)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trimNodeExternPrefix(n *store.NodeExtern, prefix string) {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.Key = strings.TrimPrefix(n.Key, prefix)
0000000000000000000000000000000000000000;;		for _, nn := range n.Nodes {
0000000000000000000000000000000000000000;;			trimNodeExternPrefix(nn, prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trimErrorPrefix(err error, prefix string) error {
0000000000000000000000000000000000000000;;		if e, ok := err.(*etcdErr.Error); ok {
0000000000000000000000000000000000000000;;			e.Cause = strings.TrimPrefix(e.Cause, prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalRequest(r *http.Request, req json.Unmarshaler, w http.ResponseWriter) bool {
0000000000000000000000000000000000000000;;		ctype := r.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;		semicolonPosition := strings.Index(ctype, ";")
0000000000000000000000000000000000000000;;		if semicolonPosition != -1 {
0000000000000000000000000000000000000000;;			ctype = strings.TrimSpace(strings.ToLower(ctype[0:semicolonPosition]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ctype != "application/json" {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusUnsupportedMediaType, fmt.Sprintf("Bad Content-Type %s, accept application/json", ctype)))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(r.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, err.Error()))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := req.UnmarshalJSON(b); err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, err.Error()))
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getID(p string, w http.ResponseWriter) (types.ID, bool) {
0000000000000000000000000000000000000000;;		idStr := trimPrefix(p, membersPrefix)
0000000000000000000000000000000000000000;;		if idStr == "" {
0000000000000000000000000000000000000000;;			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id, err := types.IDFromString(idStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeError(w, nil, httptypes.NewHTTPError(http.StatusNotFound, fmt.Sprintf("No such member: %s", idStr)))
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return id, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getUint64 extracts a uint64 by the given key from a Form. If the key does
0000000000000000000000000000000000000000;;	// not exist in the form, 0 is returned. If the key exists but the value is
0000000000000000000000000000000000000000;;	// badly formed, an error is returned. If multiple values are present only the
0000000000000000000000000000000000000000;;	// first is considered.
0000000000000000000000000000000000000000;;	func getUint64(form url.Values, key string) (i uint64, err error) {
0000000000000000000000000000000000000000;;		if vals, ok := form[key]; ok {
0000000000000000000000000000000000000000;;			i, err = strconv.ParseUint(vals[0], 10, 64)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getBool extracts a bool by the given key from a Form. If the key does not
0000000000000000000000000000000000000000;;	// exist in the form, false is returned. If the key exists but the value is
0000000000000000000000000000000000000000;;	// badly formed, an error is returned. If multiple values are present only the
0000000000000000000000000000000000000000;;	// first is considered.
0000000000000000000000000000000000000000;;	func getBool(form url.Values, key string) (b bool, err error) {
0000000000000000000000000000000000000000;;		if vals, ok := form[key]; ok {
0000000000000000000000000000000000000000;;			b, err = strconv.ParseBool(vals[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// trimPrefix removes a given prefix and any slash following the prefix
0000000000000000000000000000000000000000;;	// e.g.: trimPrefix("foo", "foo") == trimPrefix("foo/", "foo") == ""
0000000000000000000000000000000000000000;;	func trimPrefix(p, prefix string) (s string) {
0000000000000000000000000000000000000000;;		s = strings.TrimPrefix(p, prefix)
0000000000000000000000000000000000000000;;		s = strings.TrimPrefix(s, "/")
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMemberCollection(ms []*membership.Member) *httptypes.MemberCollection {
0000000000000000000000000000000000000000;;		c := httptypes.MemberCollection(make([]httptypes.Member, len(ms)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, m := range ms {
0000000000000000000000000000000000000000;;			c[i] = newMember(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMember(m *membership.Member) httptypes.Member {
0000000000000000000000000000000000000000;;		tm := httptypes.Member{
0000000000000000000000000000000000000000;;			ID:         m.ID.String(),
0000000000000000000000000000000000000000;;			Name:       m.Name,
0000000000000000000000000000000000000000;;			PeerURLs:   make([]string, len(m.PeerURLs)),
0000000000000000000000000000000000000000;;			ClientURLs: make([]string, len(m.ClientURLs)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(tm.PeerURLs, m.PeerURLs)
0000000000000000000000000000000000000000;;		copy(tm.ClientURLs, m.ClientURLs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tm
0000000000000000000000000000000000000000;;	}
