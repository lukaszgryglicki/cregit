0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/api/v3rpc/watch.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/api/v3rpc/watch.go][vendor/github.com/coreos/etcd/etcdserver/api/v3rpc/watch.go];	
0000000000000000000000000000000000000000;;	package v3rpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/mvccpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watchServer struct {
0000000000000000000000000000000000000000;;		clusterID int64
0000000000000000000000000000000000000000;;		memberID  int64
0000000000000000000000000000000000000000;;		raftTimer etcdserver.RaftTimer
0000000000000000000000000000000000000000;;		watchable mvcc.WatchableKV
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewWatchServer(s *etcdserver.EtcdServer) pb.WatchServer {
0000000000000000000000000000000000000000;;		return &watchServer{
0000000000000000000000000000000000000000;;			clusterID: int64(s.Cluster().ID()),
0000000000000000000000000000000000000000;;			memberID:  int64(s.ID()),
0000000000000000000000000000000000000000;;			raftTimer: s,
0000000000000000000000000000000000000000;;			watchable: s.Watchable(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// External test can read this with GetProgressReportInterval()
0000000000000000000000000000000000000000;;		// and change this to a small value to finish fast with
0000000000000000000000000000000000000000;;		// SetProgressReportInterval().
0000000000000000000000000000000000000000;;		progressReportInterval   = 10 * time.Minute
0000000000000000000000000000000000000000;;		progressReportIntervalMu sync.RWMutex
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetProgressReportInterval() time.Duration {
0000000000000000000000000000000000000000;;		progressReportIntervalMu.RLock()
0000000000000000000000000000000000000000;;		defer progressReportIntervalMu.RUnlock()
0000000000000000000000000000000000000000;;		return progressReportInterval
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetProgressReportInterval(newTimeout time.Duration) {
0000000000000000000000000000000000000000;;		progressReportIntervalMu.Lock()
0000000000000000000000000000000000000000;;		defer progressReportIntervalMu.Unlock()
0000000000000000000000000000000000000000;;		progressReportInterval = newTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// We send ctrl response inside the read loop. We do not want
0000000000000000000000000000000000000000;;		// send to block read, but we still want ctrl response we sent to
0000000000000000000000000000000000000000;;		// be serialized. Thus we use a buffered chan to solve the problem.
0000000000000000000000000000000000000000;;		// A small buffer should be OK for most cases, since we expect the
0000000000000000000000000000000000000000;;		// ctrl requests are infrequent.
0000000000000000000000000000000000000000;;		ctrlStreamBufLen = 16
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serverWatchStream is an etcd server side stream. It receives requests
0000000000000000000000000000000000000000;;	// from client side gRPC stream. It receives watch events from mvcc.WatchStream,
0000000000000000000000000000000000000000;;	// and creates responses that forwarded to gRPC stream.
0000000000000000000000000000000000000000;;	// It also forwards control message like watch created and canceled.
0000000000000000000000000000000000000000;;	type serverWatchStream struct {
0000000000000000000000000000000000000000;;		clusterID int64
0000000000000000000000000000000000000000;;		memberID  int64
0000000000000000000000000000000000000000;;		raftTimer etcdserver.RaftTimer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watchable mvcc.WatchableKV
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gRPCStream  pb.Watch_WatchServer
0000000000000000000000000000000000000000;;		watchStream mvcc.WatchStream
0000000000000000000000000000000000000000;;		ctrlStream  chan *pb.WatchResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects progress, prevKV
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		// progress tracks the watchID that stream might need to send
0000000000000000000000000000000000000000;;		// progress to.
0000000000000000000000000000000000000000;;		// TODO: combine progress and prevKV into a single struct?
0000000000000000000000000000000000000000;;		progress map[mvcc.WatchID]bool
0000000000000000000000000000000000000000;;		prevKV   map[mvcc.WatchID]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// closec indicates the stream is closed.
0000000000000000000000000000000000000000;;		closec chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wg waits for the send loop to complete
0000000000000000000000000000000000000000;;		wg sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *watchServer) Watch(stream pb.Watch_WatchServer) (err error) {
0000000000000000000000000000000000000000;;		sws := serverWatchStream{
0000000000000000000000000000000000000000;;			clusterID: ws.clusterID,
0000000000000000000000000000000000000000;;			memberID:  ws.memberID,
0000000000000000000000000000000000000000;;			raftTimer: ws.raftTimer,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			watchable: ws.watchable,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gRPCStream:  stream,
0000000000000000000000000000000000000000;;			watchStream: ws.watchable.NewWatchStream(),
0000000000000000000000000000000000000000;;			// chan for sending control response like watcher created and canceled.
0000000000000000000000000000000000000000;;			ctrlStream: make(chan *pb.WatchResponse, ctrlStreamBufLen),
0000000000000000000000000000000000000000;;			progress:   make(map[mvcc.WatchID]bool),
0000000000000000000000000000000000000000;;			prevKV:     make(map[mvcc.WatchID]bool),
0000000000000000000000000000000000000000;;			closec:     make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sws.wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			sws.sendLoop()
0000000000000000000000000000000000000000;;			sws.wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errc := make(chan error, 1)
0000000000000000000000000000000000000000;;		// Ideally recvLoop would also use sws.wg to signal its completion
0000000000000000000000000000000000000000;;		// but when stream.Context().Done() is closed, the stream's recv
0000000000000000000000000000000000000000;;		// may continue to block since it uses a different context, leading to
0000000000000000000000000000000000000000;;		// deadlock when calling sws.close().
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			if rerr := sws.recvLoop(); rerr != nil {
0000000000000000000000000000000000000000;;				errc <- rerr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err = <-errc:
0000000000000000000000000000000000000000;;			close(sws.ctrlStream)
0000000000000000000000000000000000000000;;		case <-stream.Context().Done():
0000000000000000000000000000000000000000;;			err = stream.Context().Err()
0000000000000000000000000000000000000000;;			// the only server-side cancellation is noleader for now.
0000000000000000000000000000000000000000;;			if err == context.Canceled {
0000000000000000000000000000000000000000;;				err = rpctypes.ErrGRPCNoLeader
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sws.close()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws *serverWatchStream) recvLoop() error {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			req, err := sws.gRPCStream.Recv()
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch uv := req.RequestUnion.(type) {
0000000000000000000000000000000000000000;;			case *pb.WatchRequest_CreateRequest:
0000000000000000000000000000000000000000;;				if uv.CreateRequest == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				creq := uv.CreateRequest
0000000000000000000000000000000000000000;;				if len(creq.Key) == 0 {
0000000000000000000000000000000000000000;;					// \x00 is the smallest key
0000000000000000000000000000000000000000;;					creq.Key = []byte{0}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(creq.RangeEnd) == 1 && creq.RangeEnd[0] == 0 {
0000000000000000000000000000000000000000;;					// support  >= key queries
0000000000000000000000000000000000000000;;					creq.RangeEnd = []byte{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				filters := FiltersFromRequest(creq)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wsrev := sws.watchStream.Rev()
0000000000000000000000000000000000000000;;				rev := creq.StartRevision
0000000000000000000000000000000000000000;;				if rev == 0 {
0000000000000000000000000000000000000000;;					rev = wsrev + 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				id := sws.watchStream.Watch(creq.Key, creq.RangeEnd, rev, filters...)
0000000000000000000000000000000000000000;;				if id != -1 {
0000000000000000000000000000000000000000;;					sws.mu.Lock()
0000000000000000000000000000000000000000;;					if creq.ProgressNotify {
0000000000000000000000000000000000000000;;						sws.progress[id] = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if creq.PrevKv {
0000000000000000000000000000000000000000;;						sws.prevKV[id] = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sws.mu.Unlock()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wr := &pb.WatchResponse{
0000000000000000000000000000000000000000;;					Header:   sws.newResponseHeader(wsrev),
0000000000000000000000000000000000000000;;					WatchId:  int64(id),
0000000000000000000000000000000000000000;;					Created:  true,
0000000000000000000000000000000000000000;;					Canceled: id == -1,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case sws.ctrlStream <- wr:
0000000000000000000000000000000000000000;;				case <-sws.closec:
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *pb.WatchRequest_CancelRequest:
0000000000000000000000000000000000000000;;				if uv.CancelRequest != nil {
0000000000000000000000000000000000000000;;					id := uv.CancelRequest.WatchId
0000000000000000000000000000000000000000;;					err := sws.watchStream.Cancel(mvcc.WatchID(id))
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						sws.ctrlStream <- &pb.WatchResponse{
0000000000000000000000000000000000000000;;							Header:   sws.newResponseHeader(sws.watchStream.Rev()),
0000000000000000000000000000000000000000;;							WatchId:  id,
0000000000000000000000000000000000000000;;							Canceled: true,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						sws.mu.Lock()
0000000000000000000000000000000000000000;;						delete(sws.progress, mvcc.WatchID(id))
0000000000000000000000000000000000000000;;						delete(sws.prevKV, mvcc.WatchID(id))
0000000000000000000000000000000000000000;;						sws.mu.Unlock()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// we probably should not shutdown the entire stream when
0000000000000000000000000000000000000000;;				// receive an valid command.
0000000000000000000000000000000000000000;;				// so just do nothing instead.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws *serverWatchStream) sendLoop() {
0000000000000000000000000000000000000000;;		// watch ids that are currently active
0000000000000000000000000000000000000000;;		ids := make(map[mvcc.WatchID]struct{})
0000000000000000000000000000000000000000;;		// watch responses pending on a watch id creation message
0000000000000000000000000000000000000000;;		pending := make(map[mvcc.WatchID][]*pb.WatchResponse)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		interval := GetProgressReportInterval()
0000000000000000000000000000000000000000;;		progressTicker := time.NewTicker(interval)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			progressTicker.Stop()
0000000000000000000000000000000000000000;;			// drain the chan to clean up pending events
0000000000000000000000000000000000000000;;			for ws := range sws.watchStream.Chan() {
0000000000000000000000000000000000000000;;				mvcc.ReportEventReceived(len(ws.Events))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, wrs := range pending {
0000000000000000000000000000000000000000;;				for _, ws := range wrs {
0000000000000000000000000000000000000000;;					mvcc.ReportEventReceived(len(ws.Events))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case wresp, ok := <-sws.watchStream.Chan():
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: evs is []mvccpb.Event type
0000000000000000000000000000000000000000;;				// either return []*mvccpb.Event from the mvcc package
0000000000000000000000000000000000000000;;				// or define protocol buffer with []mvccpb.Event.
0000000000000000000000000000000000000000;;				evs := wresp.Events
0000000000000000000000000000000000000000;;				events := make([]*mvccpb.Event, len(evs))
0000000000000000000000000000000000000000;;				sws.mu.Lock()
0000000000000000000000000000000000000000;;				needPrevKV := sws.prevKV[wresp.WatchID]
0000000000000000000000000000000000000000;;				sws.mu.Unlock()
0000000000000000000000000000000000000000;;				for i := range evs {
0000000000000000000000000000000000000000;;					events[i] = &evs[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if needPrevKV {
0000000000000000000000000000000000000000;;						opt := mvcc.RangeOptions{Rev: evs[i].Kv.ModRevision - 1}
0000000000000000000000000000000000000000;;						r, err := sws.watchable.Range(evs[i].Kv.Key, nil, opt)
0000000000000000000000000000000000000000;;						if err == nil && len(r.KVs) != 0 {
0000000000000000000000000000000000000000;;							events[i].PrevKv = &(r.KVs[0])
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wr := &pb.WatchResponse{
0000000000000000000000000000000000000000;;					Header:          sws.newResponseHeader(wresp.Revision),
0000000000000000000000000000000000000000;;					WatchId:         int64(wresp.WatchID),
0000000000000000000000000000000000000000;;					Events:          events,
0000000000000000000000000000000000000000;;					CompactRevision: wresp.CompactRevision,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, hasId := ids[wresp.WatchID]; !hasId {
0000000000000000000000000000000000000000;;					// buffer if id not yet announced
0000000000000000000000000000000000000000;;					wrs := append(pending[wresp.WatchID], wr)
0000000000000000000000000000000000000000;;					pending[wresp.WatchID] = wrs
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				mvcc.ReportEventReceived(len(evs))
0000000000000000000000000000000000000000;;				if err := sws.gRPCStream.Send(wr); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sws.mu.Lock()
0000000000000000000000000000000000000000;;				if len(evs) > 0 && sws.progress[wresp.WatchID] {
0000000000000000000000000000000000000000;;					// elide next progress update if sent a key update
0000000000000000000000000000000000000000;;					sws.progress[wresp.WatchID] = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sws.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case c, ok := <-sws.ctrlStream:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := sws.gRPCStream.Send(c); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// track id creation
0000000000000000000000000000000000000000;;				wid := mvcc.WatchID(c.WatchId)
0000000000000000000000000000000000000000;;				if c.Canceled {
0000000000000000000000000000000000000000;;					delete(ids, wid)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.Created {
0000000000000000000000000000000000000000;;					// flush buffered events
0000000000000000000000000000000000000000;;					ids[wid] = struct{}{}
0000000000000000000000000000000000000000;;					for _, v := range pending[wid] {
0000000000000000000000000000000000000000;;						mvcc.ReportEventReceived(len(v.Events))
0000000000000000000000000000000000000000;;						if err := sws.gRPCStream.Send(v); err != nil {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					delete(pending, wid)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-progressTicker.C:
0000000000000000000000000000000000000000;;				sws.mu.Lock()
0000000000000000000000000000000000000000;;				for id, ok := range sws.progress {
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						sws.watchStream.RequestProgress(id)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sws.progress[id] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sws.mu.Unlock()
0000000000000000000000000000000000000000;;			case <-sws.closec:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws *serverWatchStream) close() {
0000000000000000000000000000000000000000;;		sws.watchStream.Close()
0000000000000000000000000000000000000000;;		close(sws.closec)
0000000000000000000000000000000000000000;;		sws.wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sws *serverWatchStream) newResponseHeader(rev int64) *pb.ResponseHeader {
0000000000000000000000000000000000000000;;		return &pb.ResponseHeader{
0000000000000000000000000000000000000000;;			ClusterId: uint64(sws.clusterID),
0000000000000000000000000000000000000000;;			MemberId:  uint64(sws.memberID),
0000000000000000000000000000000000000000;;			Revision:  rev,
0000000000000000000000000000000000000000;;			RaftTerm:  sws.raftTimer.Term(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filterNoDelete(e mvccpb.Event) bool {
0000000000000000000000000000000000000000;;		return e.Type == mvccpb.DELETE
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filterNoPut(e mvccpb.Event) bool {
0000000000000000000000000000000000000000;;		return e.Type == mvccpb.PUT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FiltersFromRequest(creq *pb.WatchCreateRequest) []mvcc.FilterFunc {
0000000000000000000000000000000000000000;;		filters := make([]mvcc.FilterFunc, 0, len(creq.Filters))
0000000000000000000000000000000000000000;;		for _, ft := range creq.Filters {
0000000000000000000000000000000000000000;;			switch ft {
0000000000000000000000000000000000000000;;			case pb.WatchCreateRequest_NOPUT:
0000000000000000000000000000000000000000;;				filters = append(filters, filterNoPut)
0000000000000000000000000000000000000000;;			case pb.WatchCreateRequest_NODELETE:
0000000000000000000000000000000000000000;;				filters = append(filters, filterNoDelete)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filters
0000000000000000000000000000000000000000;;	}
