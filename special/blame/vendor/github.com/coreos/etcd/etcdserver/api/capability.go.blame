0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	package api
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/version"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Capability string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AuthCapability  Capability = "auth"
0000000000000000000000000000000000000000;;		V3rpcCapability Capability = "v3rpc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "etcdserver/api")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// capabilityMaps is a static map of version to capability map.
0000000000000000000000000000000000000000;;		// the base capabilities is the set of capability 2.0 supports.
0000000000000000000000000000000000000000;;		capabilityMaps = map[string]map[Capability]bool{
0000000000000000000000000000000000000000;;			"2.3.0": {AuthCapability: true},
0000000000000000000000000000000000000000;;			"3.0.0": {AuthCapability: true, V3rpcCapability: true},
0000000000000000000000000000000000000000;;			"3.1.0": {AuthCapability: true, V3rpcCapability: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enableMapMu sync.RWMutex
0000000000000000000000000000000000000000;;		// enabledMap points to a map in capabilityMaps
0000000000000000000000000000000000000000;;		enabledMap map[Capability]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curVersion *semver.Version
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		enabledMap = make(map[Capability]bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateCapability updates the enabledMap when the cluster version increases.
0000000000000000000000000000000000000000;;	func UpdateCapability(v *semver.Version) {
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			// if recovered but version was never set by cluster
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enableMapMu.Lock()
0000000000000000000000000000000000000000;;		if curVersion != nil && !curVersion.LessThan(*v) {
0000000000000000000000000000000000000000;;			enableMapMu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		curVersion = v
0000000000000000000000000000000000000000;;		enabledMap = capabilityMaps[curVersion.String()]
0000000000000000000000000000000000000000;;		enableMapMu.Unlock()
0000000000000000000000000000000000000000;;		plog.Infof("enabled capabilities for version %s", version.Cluster(v.String()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsCapabilityEnabled(c Capability) bool {
0000000000000000000000000000000000000000;;		enableMapMu.RLock()
0000000000000000000000000000000000000000;;		defer enableMapMu.RUnlock()
0000000000000000000000000000000000000000;;		if enabledMap == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return enabledMap[c]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EnableCapability(c Capability) {
0000000000000000000000000000000000000000;;		enableMapMu.Lock()
0000000000000000000000000000000000000000;;		defer enableMapMu.Unlock()
0000000000000000000000000000000000000000;;		enabledMap[c] = true
0000000000000000000000000000000000000000;;	}
