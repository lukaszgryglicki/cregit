0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/etcdhttp/client_auth.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/etcdhttp/client_auth.go][vendor/github.com/coreos/etcd/etcdserver/api/v2http/client_auth.go];	
0000000000000000000000000000000000000000;;	package v2http
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v2http/httptypes"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/auth"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authHandler struct {
0000000000000000000000000000000000000000;;		sec                   auth.Store
0000000000000000000000000000000000000000;;		cluster               api.Cluster
0000000000000000000000000000000000000000;;		clientCertAuthEnabled bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasWriteRootAccess(sec auth.Store, r *http.Request, clientCertAuthEnabled bool) bool {
0000000000000000000000000000000000000000;;		if r.Method == "GET" || r.Method == "HEAD" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hasRootAccess(sec, r, clientCertAuthEnabled)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func userFromBasicAuth(sec auth.Store, r *http.Request) *auth.User {
0000000000000000000000000000000000000000;;		username, password, ok := r.BasicAuth()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			plog.Warningf("auth: malformed basic auth encoding")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		user, err := sec.GetUser(username)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok = sec.CheckPassword(user, password)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			plog.Warningf("auth: incorrect password for user: %s", username)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &user
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func userFromClientCertificate(sec auth.Store, r *http.Request) *auth.User {
0000000000000000000000000000000000000000;;		if r.TLS == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, chains := range r.TLS.VerifiedChains {
0000000000000000000000000000000000000000;;			for _, chain := range chains {
0000000000000000000000000000000000000000;;				plog.Debugf("auth: found common name %s.\n", chain.Subject.CommonName)
0000000000000000000000000000000000000000;;				user, err := sec.GetUser(chain.Subject.CommonName)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					plog.Debugf("auth: authenticated user %s by cert common name.", user.User)
0000000000000000000000000000000000000000;;					return &user
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasRootAccess(sec auth.Store, r *http.Request, clientCertAuthEnabled bool) bool {
0000000000000000000000000000000000000000;;		if sec == nil {
0000000000000000000000000000000000000000;;			// No store means no auth available, eg, tests.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sec.AuthEnabled() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rootUser *auth.User
0000000000000000000000000000000000000000;;		if r.Header.Get("Authorization") == "" && clientCertAuthEnabled {
0000000000000000000000000000000000000000;;			rootUser = userFromClientCertificate(sec, r)
0000000000000000000000000000000000000000;;			if rootUser == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rootUser = userFromBasicAuth(sec, r)
0000000000000000000000000000000000000000;;			if rootUser == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, role := range rootUser.Roles {
0000000000000000000000000000000000000000;;			if role == auth.RootRoleName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Warningf("auth: user %s does not have the %s role for resource %s.", rootUser.User, auth.RootRoleName, r.URL.Path)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasKeyPrefixAccess(sec auth.Store, r *http.Request, key string, recursive, clientCertAuthEnabled bool) bool {
0000000000000000000000000000000000000000;;		if sec == nil {
0000000000000000000000000000000000000000;;			// No store means no auth available, eg, tests.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !sec.AuthEnabled() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var user *auth.User
0000000000000000000000000000000000000000;;		if r.Header.Get("Authorization") == "" {
0000000000000000000000000000000000000000;;			if clientCertAuthEnabled {
0000000000000000000000000000000000000000;;				user = userFromClientCertificate(sec, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if user == nil {
0000000000000000000000000000000000000000;;				return hasGuestAccess(sec, r, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			user = userFromBasicAuth(sec, r)
0000000000000000000000000000000000000000;;			if user == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writeAccess := r.Method != "GET" && r.Method != "HEAD"
0000000000000000000000000000000000000000;;		for _, roleName := range user.Roles {
0000000000000000000000000000000000000000;;			role, err := sec.GetRole(roleName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if recursive {
0000000000000000000000000000000000000000;;				if role.HasRecursiveAccess(key, writeAccess) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if role.HasKeyAccess(key, writeAccess) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Warningf("auth: invalid access for user %s on key %s.", user.User, key)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasGuestAccess(sec auth.Store, r *http.Request, key string) bool {
0000000000000000000000000000000000000000;;		writeAccess := r.Method != "GET" && r.Method != "HEAD"
0000000000000000000000000000000000000000;;		role, err := sec.GetRole(auth.GuestRoleName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if role.HasKeyAccess(key, writeAccess) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Warningf("auth: invalid access for unauthenticated user on resource %s.", key)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeNoAuth(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		herr := httptypes.NewHTTPError(http.StatusUnauthorized, "Insufficient credentials")
0000000000000000000000000000000000000000;;		if err := herr.WriteTo(w); err != nil {
0000000000000000000000000000000000000000;;			plog.Debugf("error writing HTTPError (%v) to %s", err, r.RemoteAddr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleAuth(mux *http.ServeMux, sh *authHandler) {
0000000000000000000000000000000000000000;;		mux.HandleFunc(authPrefix+"/roles", capabilityHandler(api.AuthCapability, sh.baseRoles))
0000000000000000000000000000000000000000;;		mux.HandleFunc(authPrefix+"/roles/", capabilityHandler(api.AuthCapability, sh.handleRoles))
0000000000000000000000000000000000000000;;		mux.HandleFunc(authPrefix+"/users", capabilityHandler(api.AuthCapability, sh.baseUsers))
0000000000000000000000000000000000000000;;		mux.HandleFunc(authPrefix+"/users/", capabilityHandler(api.AuthCapability, sh.handleUsers))
0000000000000000000000000000000000000000;;		mux.HandleFunc(authPrefix+"/enable", capabilityHandler(api.AuthCapability, sh.enableDisable))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *authHandler) baseRoles(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasRootAccess(sh.sec, r, sh.clientCertAuthEnabled) {
0000000000000000000000000000000000000000;;			writeNoAuth(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roles, err := sh.sec.AllRoles()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if roles == nil {
0000000000000000000000000000000000000000;;			roles = make([]string, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.ParseForm()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rolesCollections struct {
0000000000000000000000000000000000000000;;			Roles []auth.Role `json:"roles"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, roleName := range roles {
0000000000000000000000000000000000000000;;			var role auth.Role
0000000000000000000000000000000000000000;;			role, err = sh.sec.GetRole(roleName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rolesCollections.Roles = append(rolesCollections.Roles, role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.NewEncoder(w).Encode(rolesCollections)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Warningf("baseRoles error encoding on %s", r.URL)
0000000000000000000000000000000000000000;;			writeError(w, r, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *authHandler) handleRoles(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		subpath := path.Clean(r.URL.Path[len(authPrefix):])
0000000000000000000000000000000000000000;;		// Split "/roles/rolename/command".
0000000000000000000000000000000000000000;;		// First item is an empty string, second is "roles"
0000000000000000000000000000000000000000;;		pieces := strings.Split(subpath, "/")
0000000000000000000000000000000000000000;;		if len(pieces) == 2 {
0000000000000000000000000000000000000000;;			sh.baseRoles(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pieces) != 3 {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid path"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sh.forRole(w, r, pieces[2])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *authHandler) forRole(w http.ResponseWriter, r *http.Request, role string) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasRootAccess(sh.sec, r, sh.clientCertAuthEnabled) {
0000000000000000000000000000000000000000;;			writeNoAuth(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch r.Method {
0000000000000000000000000000000000000000;;		case "GET":
0000000000000000000000000000000000000000;;			data, err := sh.sec.GetRole(role)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = json.NewEncoder(w).Encode(data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("forRole error encoding on %s", r.URL)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "PUT":
0000000000000000000000000000000000000000;;			var in auth.Role
0000000000000000000000000000000000000000;;			err := json.NewDecoder(r.Body).Decode(&in)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid JSON in request body."))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if in.Role != role {
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Role JSON name does not match the name in the URL"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var out auth.Role
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// create
0000000000000000000000000000000000000000;;			if in.Grant.IsEmpty() && in.Revoke.IsEmpty() {
0000000000000000000000000000000000000000;;				err = sh.sec.CreateRole(in)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					writeError(w, r, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusCreated)
0000000000000000000000000000000000000000;;				out = in
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !in.Permissions.IsEmpty() {
0000000000000000000000000000000000000000;;					writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Role JSON contains both permissions and grant/revoke"))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out, err = sh.sec.UpdateRole(in)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					writeError(w, r, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = json.NewEncoder(w).Encode(out)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("forRole error encoding on %s", r.URL)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "DELETE":
0000000000000000000000000000000000000000;;			err := sh.sec.DeleteRole(role)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userWithRoles struct {
0000000000000000000000000000000000000000;;		User  string      `json:"user"`
0000000000000000000000000000000000000000;;		Roles []auth.Role `json:"roles,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type usersCollections struct {
0000000000000000000000000000000000000000;;		Users []userWithRoles `json:"users"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *authHandler) baseUsers(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasRootAccess(sh.sec, r, sh.clientCertAuthEnabled) {
0000000000000000000000000000000000000000;;			writeNoAuth(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		users, err := sh.sec.AllUsers()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if users == nil {
0000000000000000000000000000000000000000;;			users = make([]string, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = r.ParseForm()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			writeError(w, r, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ucs := usersCollections{}
0000000000000000000000000000000000000000;;		for _, userName := range users {
0000000000000000000000000000000000000000;;			var user auth.User
0000000000000000000000000000000000000000;;			user, err = sh.sec.GetUser(userName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			uwr := userWithRoles{User: user.User}
0000000000000000000000000000000000000000;;			for _, roleName := range user.Roles {
0000000000000000000000000000000000000000;;				var role auth.Role
0000000000000000000000000000000000000000;;				role, err = sh.sec.GetRole(roleName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				uwr.Roles = append(uwr.Roles, role)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ucs.Users = append(ucs.Users, uwr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.NewEncoder(w).Encode(ucs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Warningf("baseUsers error encoding on %s", r.URL)
0000000000000000000000000000000000000000;;			writeError(w, r, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *authHandler) handleUsers(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		subpath := path.Clean(r.URL.Path[len(authPrefix):])
0000000000000000000000000000000000000000;;		// Split "/users/username".
0000000000000000000000000000000000000000;;		// First item is an empty string, second is "users"
0000000000000000000000000000000000000000;;		pieces := strings.Split(subpath, "/")
0000000000000000000000000000000000000000;;		if len(pieces) == 2 {
0000000000000000000000000000000000000000;;			sh.baseUsers(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pieces) != 3 {
0000000000000000000000000000000000000000;;			writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid path"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sh.forUser(w, r, pieces[2])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *authHandler) forUser(w http.ResponseWriter, r *http.Request, user string) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasRootAccess(sh.sec, r, sh.clientCertAuthEnabled) {
0000000000000000000000000000000000000000;;			writeNoAuth(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch r.Method {
0000000000000000000000000000000000000000;;		case "GET":
0000000000000000000000000000000000000000;;			u, err := sh.sec.GetUser(user)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = r.ParseForm()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			uwr := userWithRoles{User: u.User}
0000000000000000000000000000000000000000;;			for _, roleName := range u.Roles {
0000000000000000000000000000000000000000;;				var role auth.Role
0000000000000000000000000000000000000000;;				role, err = sh.sec.GetRole(roleName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					writeError(w, r, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				uwr.Roles = append(uwr.Roles, role)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = json.NewEncoder(w).Encode(uwr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("forUser error encoding on %s", r.URL)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "PUT":
0000000000000000000000000000000000000000;;			var u auth.User
0000000000000000000000000000000000000000;;			err := json.NewDecoder(r.Body).Decode(&u)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "Invalid JSON in request body."))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u.User != user {
0000000000000000000000000000000000000000;;				writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "User JSON name does not match the name in the URL"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				out     auth.User
0000000000000000000000000000000000000000;;				created bool
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(u.Grant) == 0 && len(u.Revoke) == 0 {
0000000000000000000000000000000000000000;;				// create or update
0000000000000000000000000000000000000000;;				if len(u.Roles) != 0 {
0000000000000000000000000000000000000000;;					out, err = sh.sec.CreateUser(u)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// if user passes in both password and roles, we are unsure about his/her
0000000000000000000000000000000000000000;;					// intention.
0000000000000000000000000000000000000000;;					out, created, err = sh.sec.CreateOrUpdateUser(u)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					writeError(w, r, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// update case
0000000000000000000000000000000000000000;;				if len(u.Roles) != 0 {
0000000000000000000000000000000000000000;;					writeError(w, r, httptypes.NewHTTPError(http.StatusBadRequest, "User JSON contains both roles and grant/revoke"))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out, err = sh.sec.UpdateUser(u)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					writeError(w, r, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if created {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusCreated)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out.Password = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = json.NewEncoder(w).Encode(out)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("forUser error encoding on %s", r.URL)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case "DELETE":
0000000000000000000000000000000000000000;;			err := sh.sec.DeleteUser(user)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type enabled struct {
0000000000000000000000000000000000000000;;		Enabled bool `json:"enabled"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *authHandler) enableDisable(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if !allowMethod(w, r.Method, "GET", "PUT", "DELETE") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !hasWriteRootAccess(sh.sec, r, sh.clientCertAuthEnabled) {
0000000000000000000000000000000000000000;;			writeNoAuth(w, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", sh.cluster.ID().String())
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		isEnabled := sh.sec.AuthEnabled()
0000000000000000000000000000000000000000;;		switch r.Method {
0000000000000000000000000000000000000000;;		case "GET":
0000000000000000000000000000000000000000;;			jsonDict := enabled{isEnabled}
0000000000000000000000000000000000000000;;			err := json.NewEncoder(w).Encode(jsonDict)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Warningf("error encoding auth state on %s", r.URL)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "PUT":
0000000000000000000000000000000000000000;;			err := sh.sec.EnableAuth()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "DELETE":
0000000000000000000000000000000000000000;;			err := sh.sec.DisableAuth()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				writeError(w, r, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
