0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/auth/auth.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/auth/auth.go][vendor/github.com/coreos/etcd/etcdserver/auth/auth.go];	
0000000000000000000000000000000000000000;;	// Package auth implements etcd authentication.
0000000000000000000000000000000000000000;;	package auth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcderr "github.com/coreos/etcd/error"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/bcrypt"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// StorePermsPrefix is the internal prefix of the storage layer dedicated to storing user data.
0000000000000000000000000000000000000000;;		StorePermsPrefix = "/2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RootRoleName is the name of the ROOT role, with privileges to manage the cluster.
0000000000000000000000000000000000000000;;		RootRoleName = "root"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GuestRoleName is the name of the role that defines the privileges of an unauthenticated user.
0000000000000000000000000000000000000000;;		GuestRoleName = "guest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "etcdserver/auth")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var rootRole = Role{
0000000000000000000000000000000000000000;;		Role: RootRoleName,
0000000000000000000000000000000000000000;;		Permissions: Permissions{
0000000000000000000000000000000000000000;;			KV: RWPermission{
0000000000000000000000000000000000000000;;				Read:  []string{"/*"},
0000000000000000000000000000000000000000;;				Write: []string{"/*"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var guestRole = Role{
0000000000000000000000000000000000000000;;		Role: GuestRoleName,
0000000000000000000000000000000000000000;;		Permissions: Permissions{
0000000000000000000000000000000000000000;;			KV: RWPermission{
0000000000000000000000000000000000000000;;				Read:  []string{"/*"},
0000000000000000000000000000000000000000;;				Write: []string{"/*"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type doer interface {
0000000000000000000000000000000000000000;;		Do(context.Context, etcdserverpb.Request) (etcdserver.Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Store interface {
0000000000000000000000000000000000000000;;		AllUsers() ([]string, error)
0000000000000000000000000000000000000000;;		GetUser(name string) (User, error)
0000000000000000000000000000000000000000;;		CreateOrUpdateUser(user User) (out User, created bool, err error)
0000000000000000000000000000000000000000;;		CreateUser(user User) (User, error)
0000000000000000000000000000000000000000;;		DeleteUser(name string) error
0000000000000000000000000000000000000000;;		UpdateUser(user User) (User, error)
0000000000000000000000000000000000000000;;		AllRoles() ([]string, error)
0000000000000000000000000000000000000000;;		GetRole(name string) (Role, error)
0000000000000000000000000000000000000000;;		CreateRole(role Role) error
0000000000000000000000000000000000000000;;		DeleteRole(name string) error
0000000000000000000000000000000000000000;;		UpdateRole(role Role) (Role, error)
0000000000000000000000000000000000000000;;		AuthEnabled() bool
0000000000000000000000000000000000000000;;		EnableAuth() error
0000000000000000000000000000000000000000;;		DisableAuth() error
0000000000000000000000000000000000000000;;		PasswordStore
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PasswordStore interface {
0000000000000000000000000000000000000000;;		CheckPassword(user User, password string) bool
0000000000000000000000000000000000000000;;		HashPassword(password string) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type store struct {
0000000000000000000000000000000000000000;;		server      doer
0000000000000000000000000000000000000000;;		timeout     time.Duration
0000000000000000000000000000000000000000;;		ensuredOnce bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PasswordStore
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type User struct {
0000000000000000000000000000000000000000;;		User     string   `json:"user"`
0000000000000000000000000000000000000000;;		Password string   `json:"password,omitempty"`
0000000000000000000000000000000000000000;;		Roles    []string `json:"roles"`
0000000000000000000000000000000000000000;;		Grant    []string `json:"grant,omitempty"`
0000000000000000000000000000000000000000;;		Revoke   []string `json:"revoke,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Role struct {
0000000000000000000000000000000000000000;;		Role        string       `json:"role"`
0000000000000000000000000000000000000000;;		Permissions Permissions  `json:"permissions"`
0000000000000000000000000000000000000000;;		Grant       *Permissions `json:"grant,omitempty"`
0000000000000000000000000000000000000000;;		Revoke      *Permissions `json:"revoke,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Permissions struct {
0000000000000000000000000000000000000000;;		KV RWPermission `json:"kv"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Permissions) IsEmpty() bool {
0000000000000000000000000000000000000000;;		return p == nil || (len(p.KV.Read) == 0 && len(p.KV.Write) == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RWPermission struct {
0000000000000000000000000000000000000000;;		Read  []string `json:"read"`
0000000000000000000000000000000000000000;;		Write []string `json:"write"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Status int
0000000000000000000000000000000000000000;;		Errmsg string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ae Error) Error() string   { return ae.Errmsg }
0000000000000000000000000000000000000000;;	func (ae Error) HTTPStatus() int { return ae.Status }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func authErr(hs int, s string, v ...interface{}) Error {
0000000000000000000000000000000000000000;;		return Error{Status: hs, Errmsg: fmt.Sprintf("auth: "+s, v...)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStore(server doer, timeout time.Duration) Store {
0000000000000000000000000000000000000000;;		s := &store{
0000000000000000000000000000000000000000;;			server:        server,
0000000000000000000000000000000000000000;;			timeout:       timeout,
0000000000000000000000000000000000000000;;			PasswordStore: passwordStore{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// passwordStore implements PasswordStore using bcrypt to hash user passwords
0000000000000000000000000000000000000000;;	type passwordStore struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ passwordStore) CheckPassword(user User, password string) bool {
0000000000000000000000000000000000000000;;		err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ passwordStore) HashPassword(password string) (string, error) {
0000000000000000000000000000000000000000;;		hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
0000000000000000000000000000000000000000;;		return string(hash), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) AllUsers() ([]string, error) {
0000000000000000000000000000000000000000;;		resp, err := s.requestResource("/users/", false, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return []string{}, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var nodes []string
0000000000000000000000000000000000000000;;		for _, n := range resp.Event.Node.Nodes {
0000000000000000000000000000000000000000;;			_, user := path.Split(n.Key)
0000000000000000000000000000000000000000;;			nodes = append(nodes, user)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(nodes)
0000000000000000000000000000000000000000;;		return nodes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) GetUser(name string) (User, error) { return s.getUser(name, false) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOrUpdateUser should be only used for creating the new user or when you are not
0000000000000000000000000000000000000000;;	// sure if it is a create or update. (When only password is passed in, we are not sure
0000000000000000000000000000000000000000;;	// if it is a update or create)
0000000000000000000000000000000000000000;;	func (s *store) CreateOrUpdateUser(user User) (out User, created bool, err error) {
0000000000000000000000000000000000000000;;		_, err = s.getUser(user.User, true)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			out, err = s.UpdateUser(user)
0000000000000000000000000000000000000000;;			return out, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u, err := s.CreateUser(user)
0000000000000000000000000000000000000000;;		return u, true, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) CreateUser(user User) (User, error) {
0000000000000000000000000000000000000000;;		// Attach root role to root user.
0000000000000000000000000000000000000000;;		if user.User == "root" {
0000000000000000000000000000000000000000;;			user = attachRootRole(user)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u, err := s.createUserInternal(user)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			plog.Noticef("created user %s", user.User)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) createUserInternal(user User) (User, error) {
0000000000000000000000000000000000000000;;		if user.Password == "" {
0000000000000000000000000000000000000000;;			return user, authErr(http.StatusBadRequest, "Cannot create user %s with an empty password", user.User)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash, err := s.HashPassword(user.Password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return user, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		user.Password = hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = s.createResource("/users/"+user.User, user)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeNodeExist {
0000000000000000000000000000000000000000;;					return user, authErr(http.StatusConflict, "User %s already exists.", user.User)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return user, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) DeleteUser(name string) error {
0000000000000000000000000000000000000000;;		if s.AuthEnabled() && name == "root" {
0000000000000000000000000000000000000000;;			return authErr(http.StatusForbidden, "Cannot delete root user while auth is enabled.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := s.deleteResource("/users/" + name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return authErr(http.StatusNotFound, "User %s does not exist", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Noticef("deleted user %s", name)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) UpdateUser(user User) (User, error) {
0000000000000000000000000000000000000000;;		old, err := s.getUser(user.User, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return user, authErr(http.StatusNotFound, "User %s doesn't exist.", user.User)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return old, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newUser, err := old.merge(user, s.PasswordStore)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return old, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(old, newUser) {
0000000000000000000000000000000000000000;;			return old, authErr(http.StatusBadRequest, "User not updated. Use grant/revoke/password to update the user.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = s.updateResource("/users/"+user.User, newUser)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			plog.Noticef("updated user %s", user.User)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newUser, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) AllRoles() ([]string, error) {
0000000000000000000000000000000000000000;;		nodes := []string{RootRoleName}
0000000000000000000000000000000000000000;;		resp, err := s.requestResource("/roles/", false, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return nodes, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, n := range resp.Event.Node.Nodes {
0000000000000000000000000000000000000000;;			_, role := path.Split(n.Key)
0000000000000000000000000000000000000000;;			nodes = append(nodes, role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(nodes)
0000000000000000000000000000000000000000;;		return nodes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) GetRole(name string) (Role, error) { return s.getRole(name, false) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) CreateRole(role Role) error {
0000000000000000000000000000000000000000;;		if role.Role == RootRoleName {
0000000000000000000000000000000000000000;;			return authErr(http.StatusForbidden, "Cannot modify role %s: is root role.", role.Role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := s.createResource("/roles/"+role.Role, role)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeNodeExist {
0000000000000000000000000000000000000000;;					return authErr(http.StatusConflict, "Role %s already exists.", role.Role)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			plog.Noticef("created new role %s", role.Role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) DeleteRole(name string) error {
0000000000000000000000000000000000000000;;		if name == RootRoleName {
0000000000000000000000000000000000000000;;			return authErr(http.StatusForbidden, "Cannot modify role %s: is root role.", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := s.deleteResource("/roles/" + name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return authErr(http.StatusNotFound, "Role %s doesn't exist.", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			plog.Noticef("deleted role %s", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) UpdateRole(role Role) (Role, error) {
0000000000000000000000000000000000000000;;		if role.Role == RootRoleName {
0000000000000000000000000000000000000000;;			return Role{}, authErr(http.StatusForbidden, "Cannot modify role %s: is root role.", role.Role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		old, err := s.getRole(role.Role, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return role, authErr(http.StatusNotFound, "Role %s doesn't exist.", role.Role)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return old, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newRole, err := old.merge(role)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return old, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(old, newRole) {
0000000000000000000000000000000000000000;;			return old, authErr(http.StatusBadRequest, "Role not updated. Use grant/revoke to update the role.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = s.updateResource("/roles/"+role.Role, newRole)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			plog.Noticef("updated role %s", role.Role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newRole, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) AuthEnabled() bool {
0000000000000000000000000000000000000000;;		return s.detectAuth()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) EnableAuth() error {
0000000000000000000000000000000000000000;;		if s.AuthEnabled() {
0000000000000000000000000000000000000000;;			return authErr(http.StatusConflict, "already enabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := s.getUser("root", true); err != nil {
0000000000000000000000000000000000000000;;			return authErr(http.StatusConflict, "No root user available, please create one")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := s.getRole(GuestRoleName, true); err != nil {
0000000000000000000000000000000000000000;;			plog.Printf("no guest role access found, creating default")
0000000000000000000000000000000000000000;;			if err := s.CreateRole(guestRole); err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("error creating guest role. aborting auth enable.")
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.enableAuth(); err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("error enabling auth (%v)", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Noticef("auth: enabled auth")
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) DisableAuth() error {
0000000000000000000000000000000000000000;;		if !s.AuthEnabled() {
0000000000000000000000000000000000000000;;			return authErr(http.StatusConflict, "already disabled")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := s.disableAuth()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			plog.Noticef("auth: disabled auth")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			plog.Errorf("error disabling auth (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// merge applies the properties of the passed-in User to the User on which it
0000000000000000000000000000000000000000;;	// is called and returns a new User with these modifications applied. Think of
0000000000000000000000000000000000000000;;	// all Users as immutable sets of data. Merge allows you to perform the set
0000000000000000000000000000000000000000;;	// operations (desired grants and revokes) atomically
0000000000000000000000000000000000000000;;	func (ou User) merge(nu User, s PasswordStore) (User, error) {
0000000000000000000000000000000000000000;;		var out User
0000000000000000000000000000000000000000;;		if ou.User != nu.User {
0000000000000000000000000000000000000000;;			return out, authErr(http.StatusConflict, "Merging user data with conflicting usernames: %s %s", ou.User, nu.User)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.User = ou.User
0000000000000000000000000000000000000000;;		if nu.Password != "" {
0000000000000000000000000000000000000000;;			hash, err := s.HashPassword(nu.Password)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ou, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Password = hash
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.Password = ou.Password
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentRoles := types.NewUnsafeSet(ou.Roles...)
0000000000000000000000000000000000000000;;		for _, g := range nu.Grant {
0000000000000000000000000000000000000000;;			if currentRoles.Contains(g) {
0000000000000000000000000000000000000000;;				plog.Noticef("granting duplicate role %s for user %s", g, nu.User)
0000000000000000000000000000000000000000;;				return User{}, authErr(http.StatusConflict, fmt.Sprintf("Granting duplicate role %s for user %s", g, nu.User))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentRoles.Add(g)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range nu.Revoke {
0000000000000000000000000000000000000000;;			if !currentRoles.Contains(r) {
0000000000000000000000000000000000000000;;				plog.Noticef("revoking ungranted role %s for user %s", r, nu.User)
0000000000000000000000000000000000000000;;				return User{}, authErr(http.StatusConflict, fmt.Sprintf("Revoking ungranted role %s for user %s", r, nu.User))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentRoles.Remove(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Roles = currentRoles.Values()
0000000000000000000000000000000000000000;;		sort.Strings(out.Roles)
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// merge for a role works the same as User above -- atomic Role application to
0000000000000000000000000000000000000000;;	// each of the substructures.
0000000000000000000000000000000000000000;;	func (r Role) merge(n Role) (Role, error) {
0000000000000000000000000000000000000000;;		var out Role
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if r.Role != n.Role {
0000000000000000000000000000000000000000;;			return out, authErr(http.StatusConflict, "Merging role with conflicting names: %s %s", r.Role, n.Role)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Role = r.Role
0000000000000000000000000000000000000000;;		out.Permissions, err = r.Permissions.Grant(n.Grant)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return out, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Permissions, err = out.Permissions.Revoke(n.Revoke)
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r Role) HasKeyAccess(key string, write bool) bool {
0000000000000000000000000000000000000000;;		if r.Role == RootRoleName {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.Permissions.KV.HasAccess(key, write)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r Role) HasRecursiveAccess(key string, write bool) bool {
0000000000000000000000000000000000000000;;		if r.Role == RootRoleName {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.Permissions.KV.HasRecursiveAccess(key, write)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Grant adds a set of permissions to the permission object on which it is called,
0000000000000000000000000000000000000000;;	// returning a new permission object.
0000000000000000000000000000000000000000;;	func (p Permissions) Grant(n *Permissions) (Permissions, error) {
0000000000000000000000000000000000000000;;		var out Permissions
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.KV, err = p.KV.Grant(n.KV)
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Revoke removes a set of permissions to the permission object on which it is called,
0000000000000000000000000000000000000000;;	// returning a new permission object.
0000000000000000000000000000000000000000;;	func (p Permissions) Revoke(n *Permissions) (Permissions, error) {
0000000000000000000000000000000000000000;;		var out Permissions
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.KV, err = p.KV.Revoke(n.KV)
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Grant adds a set of permissions to the permission object on which it is called,
0000000000000000000000000000000000000000;;	// returning a new permission object.
0000000000000000000000000000000000000000;;	func (rw RWPermission) Grant(n RWPermission) (RWPermission, error) {
0000000000000000000000000000000000000000;;		var out RWPermission
0000000000000000000000000000000000000000;;		currentRead := types.NewUnsafeSet(rw.Read...)
0000000000000000000000000000000000000000;;		for _, r := range n.Read {
0000000000000000000000000000000000000000;;			if currentRead.Contains(r) {
0000000000000000000000000000000000000000;;				return out, authErr(http.StatusConflict, "Granting duplicate read permission %s", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentRead.Add(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentWrite := types.NewUnsafeSet(rw.Write...)
0000000000000000000000000000000000000000;;		for _, w := range n.Write {
0000000000000000000000000000000000000000;;			if currentWrite.Contains(w) {
0000000000000000000000000000000000000000;;				return out, authErr(http.StatusConflict, "Granting duplicate write permission %s", w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentWrite.Add(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Read = currentRead.Values()
0000000000000000000000000000000000000000;;		out.Write = currentWrite.Values()
0000000000000000000000000000000000000000;;		sort.Strings(out.Read)
0000000000000000000000000000000000000000;;		sort.Strings(out.Write)
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Revoke removes a set of permissions to the permission object on which it is called,
0000000000000000000000000000000000000000;;	// returning a new permission object.
0000000000000000000000000000000000000000;;	func (rw RWPermission) Revoke(n RWPermission) (RWPermission, error) {
0000000000000000000000000000000000000000;;		var out RWPermission
0000000000000000000000000000000000000000;;		currentRead := types.NewUnsafeSet(rw.Read...)
0000000000000000000000000000000000000000;;		for _, r := range n.Read {
0000000000000000000000000000000000000000;;			if !currentRead.Contains(r) {
0000000000000000000000000000000000000000;;				plog.Noticef("revoking ungranted read permission %s", r)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentRead.Remove(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentWrite := types.NewUnsafeSet(rw.Write...)
0000000000000000000000000000000000000000;;		for _, w := range n.Write {
0000000000000000000000000000000000000000;;			if !currentWrite.Contains(w) {
0000000000000000000000000000000000000000;;				plog.Noticef("revoking ungranted write permission %s", w)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentWrite.Remove(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Read = currentRead.Values()
0000000000000000000000000000000000000000;;		out.Write = currentWrite.Values()
0000000000000000000000000000000000000000;;		sort.Strings(out.Read)
0000000000000000000000000000000000000000;;		sort.Strings(out.Write)
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rw RWPermission) HasAccess(key string, write bool) bool {
0000000000000000000000000000000000000000;;		var list []string
0000000000000000000000000000000000000000;;		if write {
0000000000000000000000000000000000000000;;			list = rw.Write
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			list = rw.Read
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pat := range list {
0000000000000000000000000000000000000000;;			match, err := simpleMatch(pat, key)
0000000000000000000000000000000000000000;;			if err == nil && match {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rw RWPermission) HasRecursiveAccess(key string, write bool) bool {
0000000000000000000000000000000000000000;;		list := rw.Read
0000000000000000000000000000000000000000;;		if write {
0000000000000000000000000000000000000000;;			list = rw.Write
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pat := range list {
0000000000000000000000000000000000000000;;			match, err := prefixMatch(pat, key)
0000000000000000000000000000000000000000;;			if err == nil && match {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func simpleMatch(pattern string, key string) (match bool, err error) {
0000000000000000000000000000000000000000;;		if pattern[len(pattern)-1] == '*' {
0000000000000000000000000000000000000000;;			return strings.HasPrefix(key, pattern[:len(pattern)-1]), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key == pattern, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prefixMatch(pattern string, key string) (match bool, err error) {
0000000000000000000000000000000000000000;;		if pattern[len(pattern)-1] != '*' {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.HasPrefix(key, pattern[:len(pattern)-1]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func attachRootRole(u User) User {
0000000000000000000000000000000000000000;;		inRoles := false
0000000000000000000000000000000000000000;;		for _, r := range u.Roles {
0000000000000000000000000000000000000000;;			if r == RootRoleName {
0000000000000000000000000000000000000000;;				inRoles = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !inRoles {
0000000000000000000000000000000000000000;;			u.Roles = append(u.Roles, RootRoleName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) getUser(name string, quorum bool) (User, error) {
0000000000000000000000000000000000000000;;		resp, err := s.requestResource("/users/"+name, false, quorum)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return User{}, authErr(http.StatusNotFound, "User %s does not exist.", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return User{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var u User
0000000000000000000000000000000000000000;;		err = json.Unmarshal([]byte(*resp.Event.Node.Value), &u)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return u, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Attach root role to root user.
0000000000000000000000000000000000000000;;		if u.User == "root" {
0000000000000000000000000000000000000000;;			u = attachRootRole(u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) getRole(name string, quorum bool) (Role, error) {
0000000000000000000000000000000000000000;;		if name == RootRoleName {
0000000000000000000000000000000000000000;;			return rootRole, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := s.requestResource("/roles/"+name, false, quorum)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if e, ok := err.(*etcderr.Error); ok {
0000000000000000000000000000000000000000;;				if e.ErrorCode == etcderr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;					return Role{}, authErr(http.StatusNotFound, "Role %s does not exist.", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Role{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var r Role
0000000000000000000000000000000000000000;;		err = json.Unmarshal([]byte(*resp.Event.Node.Value), &r)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
