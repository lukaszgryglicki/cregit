0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
1861d099d10ddfa47b9f2b8b925fc11bd0827dac;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/quota.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/quota.go][vendor/github.com/coreos/etcd/etcdserver/quota.go];	
0000000000000000000000000000000000000000;;	package etcdserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc/backend"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Quota represents an arbitrary quota against arbitrary requests. Each request
0000000000000000000000000000000000000000;;	// costs some charge; if there is not enough remaining charge, then there are
0000000000000000000000000000000000000000;;	// too few resources available within the quota to apply the request.
0000000000000000000000000000000000000000;;	type Quota interface {
0000000000000000000000000000000000000000;;		// Available judges whether the given request fits within the quota.
0000000000000000000000000000000000000000;;		Available(req interface{}) bool
0000000000000000000000000000000000000000;;		// Cost computes the charge against the quota for a given request.
0000000000000000000000000000000000000000;;		Cost(req interface{}) int
0000000000000000000000000000000000000000;;		// Remaining is the amount of charge left for the quota.
0000000000000000000000000000000000000000;;		Remaining() int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type passthroughQuota struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*passthroughQuota) Available(interface{}) bool { return true }
0000000000000000000000000000000000000000;;	func (*passthroughQuota) Cost(interface{}) int       { return 0 }
0000000000000000000000000000000000000000;;	func (*passthroughQuota) Remaining() int64           { return 1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type backendQuota struct {
0000000000000000000000000000000000000000;;		s               *EtcdServer
0000000000000000000000000000000000000000;;		maxBackendBytes int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// leaseOverhead is an estimate for the cost of storing a lease
0000000000000000000000000000000000000000;;		leaseOverhead = 64
0000000000000000000000000000000000000000;;		// kvOverhead is an estimate for the cost of storing a key's metadata
0000000000000000000000000000000000000000;;		kvOverhead = 256
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBackendQuota(s *EtcdServer) Quota {
0000000000000000000000000000000000000000;;		if s.Cfg.QuotaBackendBytes < 0 {
0000000000000000000000000000000000000000;;			// disable quotas if negative
0000000000000000000000000000000000000000;;			plog.Warningf("disabling backend quota")
0000000000000000000000000000000000000000;;			return &passthroughQuota{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Cfg.QuotaBackendBytes == 0 {
0000000000000000000000000000000000000000;;			// use default size if no quota size given
0000000000000000000000000000000000000000;;			return &backendQuota{s, backend.DefaultQuotaBytes}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Cfg.QuotaBackendBytes > backend.MaxQuotaBytes {
0000000000000000000000000000000000000000;;			plog.Warningf("backend quota %v exceeds maximum quota %v; using maximum", s.Cfg.QuotaBackendBytes, backend.MaxQuotaBytes)
0000000000000000000000000000000000000000;;			return &backendQuota{s, backend.MaxQuotaBytes}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &backendQuota{s, s.Cfg.QuotaBackendBytes}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backendQuota) Available(v interface{}) bool {
0000000000000000000000000000000000000000;;		// TODO: maybe optimize backend.Size()
0000000000000000000000000000000000000000;;		return b.s.Backend().Size()+int64(b.Cost(v)) < b.maxBackendBytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backendQuota) Cost(v interface{}) int {
0000000000000000000000000000000000000000;;		switch r := v.(type) {
0000000000000000000000000000000000000000;;		case *pb.PutRequest:
0000000000000000000000000000000000000000;;			return costPut(r)
0000000000000000000000000000000000000000;;		case *pb.TxnRequest:
0000000000000000000000000000000000000000;;			return costTxn(r)
0000000000000000000000000000000000000000;;		case *pb.LeaseGrantRequest:
0000000000000000000000000000000000000000;;			return leaseOverhead
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unexpected cost")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func costPut(r *pb.PutRequest) int { return kvOverhead + len(r.Key) + len(r.Value) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func costTxnReq(u *pb.RequestOp) int {
0000000000000000000000000000000000000000;;		r := u.GetRequestPut()
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return costPut(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func costTxn(r *pb.TxnRequest) int {
0000000000000000000000000000000000000000;;		sizeSuccess := 0
0000000000000000000000000000000000000000;;		for _, u := range r.Success {
0000000000000000000000000000000000000000;;			sizeSuccess += costTxnReq(u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sizeFailure := 0
0000000000000000000000000000000000000000;;		for _, u := range r.Failure {
0000000000000000000000000000000000000000;;			sizeFailure += costTxnReq(u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sizeFailure > sizeSuccess {
0000000000000000000000000000000000000000;;			return sizeFailure
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sizeSuccess
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *backendQuota) Remaining() int64 {
0000000000000000000000000000000000000000;;		return b.maxBackendBytes - b.s.Backend().Size()
0000000000000000000000000000000000000000;;	}
