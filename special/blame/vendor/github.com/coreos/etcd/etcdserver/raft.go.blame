0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/raft.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/raft.go][vendor/github.com/coreos/etcd/etcdserver/raft.go];	
0000000000000000000000000000000000000000;;	package etcdserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"expvar"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/membership"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/contention"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/rafthttp"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Number of entries for slow follower to catch-up after compacting
0000000000000000000000000000000000000000;;		// the raft storage entries.
0000000000000000000000000000000000000000;;		// We expect the follower has a millisecond level latency with the leader.
0000000000000000000000000000000000000000;;		// The max throughput is around 10K. Keep a 5K entries is enough for helping
0000000000000000000000000000000000000000;;		// follower to catch up.
0000000000000000000000000000000000000000;;		numberOfCatchUpEntries = 5000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The max throughput of etcd will not exceed 100MB/s (100K * 1KB value).
0000000000000000000000000000000000000000;;		// Assuming the RTT is around 10ms, 1MB max size is large enough.
0000000000000000000000000000000000000000;;		maxSizePerMsg = 1 * 1024 * 1024
0000000000000000000000000000000000000000;;		// Never overflow the rafthttp buffer, which is 4096.
0000000000000000000000000000000000000000;;		// TODO: a better const?
0000000000000000000000000000000000000000;;		maxInflightMsgs = 4096 / 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// protects raftStatus
0000000000000000000000000000000000000000;;		raftStatusMu sync.Mutex
0000000000000000000000000000000000000000;;		// indirection for expvar func interface
0000000000000000000000000000000000000000;;		// expvar panics when publishing duplicate name
0000000000000000000000000000000000000000;;		// expvar does not support remove a registered name
0000000000000000000000000000000000000000;;		// so only register a func that calls raftStatus
0000000000000000000000000000000000000000;;		// and change raftStatus as we need.
0000000000000000000000000000000000000000;;		raftStatus func() raft.Status
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		raft.SetLogger(capnslog.NewPackageLogger("github.com/coreos/etcd", "raft"))
0000000000000000000000000000000000000000;;		expvar.Publish("raft.status", expvar.Func(func() interface{} {
0000000000000000000000000000000000000000;;			raftStatusMu.Lock()
0000000000000000000000000000000000000000;;			defer raftStatusMu.Unlock()
0000000000000000000000000000000000000000;;			return raftStatus()
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RaftTimer interface {
0000000000000000000000000000000000000000;;		Index() uint64
0000000000000000000000000000000000000000;;		Term() uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// apply contains entries, snapshot to be applied. Once
0000000000000000000000000000000000000000;;	// an apply is consumed, the entries will be persisted to
0000000000000000000000000000000000000000;;	// to raft storage concurrently; the application must read
0000000000000000000000000000000000000000;;	// raftDone before assuming the raft messages are stable.
0000000000000000000000000000000000000000;;	type apply struct {
0000000000000000000000000000000000000000;;		entries  []raftpb.Entry
0000000000000000000000000000000000000000;;		snapshot raftpb.Snapshot
0000000000000000000000000000000000000000;;		raftDone <-chan struct{} // rx {} after raft has persisted messages
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type raftNode struct {
0000000000000000000000000000000000000000;;		// Cache of the latest raft index and raft term the server has seen.
0000000000000000000000000000000000000000;;		// These three unit64 fields must be the first elements to keep 64-bit
0000000000000000000000000000000000000000;;		// alignment for atomic access to the fields.
0000000000000000000000000000000000000000;;		index uint64
0000000000000000000000000000000000000000;;		term  uint64
0000000000000000000000000000000000000000;;		lead  uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;		// last lead elected time
0000000000000000000000000000000000000000;;		lt time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// to check if msg receiver is removed from cluster
0000000000000000000000000000000000000000;;		isIDRemoved func(id uint64) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raft.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a chan to send/receive snapshot
0000000000000000000000000000000000000000;;		msgSnapC chan raftpb.Message
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a chan to send out apply
0000000000000000000000000000000000000000;;		applyc chan apply
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a chan to send out readState
0000000000000000000000000000000000000000;;		readStateC chan raft.ReadState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// utility
0000000000000000000000000000000000000000;;		ticker <-chan time.Time
0000000000000000000000000000000000000000;;		// contention detectors for raft heartbeat message
0000000000000000000000000000000000000000;;		td          *contention.TimeoutDetector
0000000000000000000000000000000000000000;;		heartbeat   time.Duration // for logging
0000000000000000000000000000000000000000;;		raftStorage *raft.MemoryStorage
0000000000000000000000000000000000000000;;		storage     Storage
0000000000000000000000000000000000000000;;		// transport specifies the transport to send and receive msgs to members.
0000000000000000000000000000000000000000;;		// Sending messages MUST NOT block. It is okay to drop messages, since
0000000000000000000000000000000000000000;;		// clients should timeout and reissue their messages.
0000000000000000000000000000000000000000;;		// If transport is nil, server will panic.
0000000000000000000000000000000000000000;;		transport rafthttp.Transporter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopped chan struct{}
0000000000000000000000000000000000000000;;		done    chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// start prepares and starts raftNode in a new goroutine. It is no longer safe
0000000000000000000000000000000000000000;;	// to modify the fields after it has been started.
0000000000000000000000000000000000000000;;	func (r *raftNode) start(rh *raftReadyHandler) {
0000000000000000000000000000000000000000;;		r.applyc = make(chan apply)
0000000000000000000000000000000000000000;;		r.stopped = make(chan struct{})
0000000000000000000000000000000000000000;;		r.done = make(chan struct{})
0000000000000000000000000000000000000000;;		internalTimeout := time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer r.onStop()
0000000000000000000000000000000000000000;;			islead := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-r.ticker:
0000000000000000000000000000000000000000;;					r.Tick()
0000000000000000000000000000000000000000;;				case rd := <-r.Ready():
0000000000000000000000000000000000000000;;					if rd.SoftState != nil {
0000000000000000000000000000000000000000;;						if lead := atomic.LoadUint64(&r.lead); rd.SoftState.Lead != raft.None && lead != rd.SoftState.Lead {
0000000000000000000000000000000000000000;;							r.mu.Lock()
0000000000000000000000000000000000000000;;							r.lt = time.Now()
0000000000000000000000000000000000000000;;							r.mu.Unlock()
0000000000000000000000000000000000000000;;							leaderChanges.Inc()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if rd.SoftState.Lead == raft.None {
0000000000000000000000000000000000000000;;							hasLeader.Set(0)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							hasLeader.Set(1)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						atomic.StoreUint64(&r.lead, rd.SoftState.Lead)
0000000000000000000000000000000000000000;;						islead = rd.RaftState == raft.StateLeader
0000000000000000000000000000000000000000;;						rh.updateLeadership()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if len(rd.ReadStates) != 0 {
0000000000000000000000000000000000000000;;						select {
0000000000000000000000000000000000000000;;						case r.readStateC <- rd.ReadStates[len(rd.ReadStates)-1]:
0000000000000000000000000000000000000000;;						case <-time.After(internalTimeout):
0000000000000000000000000000000000000000;;							plog.Warningf("timed out sending read state")
0000000000000000000000000000000000000000;;						case <-r.stopped:
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					raftDone := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;					ap := apply{
0000000000000000000000000000000000000000;;						entries:  rd.CommittedEntries,
0000000000000000000000000000000000000000;;						snapshot: rd.Snapshot,
0000000000000000000000000000000000000000;;						raftDone: raftDone,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					updateCommittedIndex(&ap, rh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case r.applyc <- ap:
0000000000000000000000000000000000000000;;					case <-r.stopped:
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// the leader can write to its disk in parallel with replicating to the followers and them
0000000000000000000000000000000000000000;;					// writing to their disks.
0000000000000000000000000000000000000000;;					// For more details, check raft thesis 10.2.1
0000000000000000000000000000000000000000;;					if islead {
0000000000000000000000000000000000000000;;						// gofail: var raftBeforeLeaderSend struct{}
0000000000000000000000000000000000000000;;						r.sendMessages(rd.Messages)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// gofail: var raftBeforeSave struct{}
0000000000000000000000000000000000000000;;					if err := r.storage.Save(rd.HardState, rd.Entries); err != nil {
0000000000000000000000000000000000000000;;						plog.Fatalf("raft save state and entries error: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !raft.IsEmptyHardState(rd.HardState) {
0000000000000000000000000000000000000000;;						proposalsCommitted.Set(float64(rd.HardState.Commit))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// gofail: var raftAfterSave struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !raft.IsEmptySnap(rd.Snapshot) {
0000000000000000000000000000000000000000;;						// gofail: var raftBeforeSaveSnap struct{}
0000000000000000000000000000000000000000;;						if err := r.storage.SaveSnap(rd.Snapshot); err != nil {
0000000000000000000000000000000000000000;;							plog.Fatalf("raft save snapshot error: %v", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// gofail: var raftAfterSaveSnap struct{}
0000000000000000000000000000000000000000;;						r.raftStorage.ApplySnapshot(rd.Snapshot)
0000000000000000000000000000000000000000;;						plog.Infof("raft applied incoming snapshot at index %d", rd.Snapshot.Metadata.Index)
0000000000000000000000000000000000000000;;						// gofail: var raftAfterApplySnap struct{}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					r.raftStorage.Append(rd.Entries)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !islead {
0000000000000000000000000000000000000000;;						// gofail: var raftBeforeFollowerSend struct{}
0000000000000000000000000000000000000000;;						r.sendMessages(rd.Messages)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					raftDone <- struct{}{}
0000000000000000000000000000000000000000;;					r.Advance()
0000000000000000000000000000000000000000;;				case <-r.stopped:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func updateCommittedIndex(ap *apply, rh *raftReadyHandler) {
0000000000000000000000000000000000000000;;		var ci uint64
0000000000000000000000000000000000000000;;		if len(ap.entries) != 0 {
0000000000000000000000000000000000000000;;			ci = ap.entries[len(ap.entries)-1].Index
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ap.snapshot.Metadata.Index > ci {
0000000000000000000000000000000000000000;;			ci = ap.snapshot.Metadata.Index
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ci != 0 {
0000000000000000000000000000000000000000;;			rh.updateCommittedIndex(ci)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raftNode) sendMessages(ms []raftpb.Message) {
0000000000000000000000000000000000000000;;		sentAppResp := false
0000000000000000000000000000000000000000;;		for i := len(ms) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if r.isIDRemoved(ms[i].To) {
0000000000000000000000000000000000000000;;				ms[i].To = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ms[i].Type == raftpb.MsgAppResp {
0000000000000000000000000000000000000000;;				if sentAppResp {
0000000000000000000000000000000000000000;;					ms[i].To = 0
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sentAppResp = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ms[i].Type == raftpb.MsgSnap {
0000000000000000000000000000000000000000;;				// There are two separate data store: the store for v2, and the KV for v3.
0000000000000000000000000000000000000000;;				// The msgSnap only contains the most recent snapshot of store without KV.
0000000000000000000000000000000000000000;;				// So we need to redirect the msgSnap to etcd server main loop for merging in the
0000000000000000000000000000000000000000;;				// current store snapshot and KV snapshot.
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case r.msgSnapC <- ms[i]:
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// drop msgSnap if the inflight chan if full.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ms[i].To = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ms[i].Type == raftpb.MsgHeartbeat {
0000000000000000000000000000000000000000;;				ok, exceed := r.td.Observe(ms[i].To)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// TODO: limit request rate.
0000000000000000000000000000000000000000;;					plog.Warningf("failed to send out heartbeat on time (exceeded the %v timeout for %v)", r.heartbeat, exceed)
0000000000000000000000000000000000000000;;					plog.Warningf("server is likely overloaded")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.transport.Send(ms)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raftNode) apply() chan apply {
0000000000000000000000000000000000000000;;		return r.applyc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raftNode) leadElectedTime() time.Time {
0000000000000000000000000000000000000000;;		r.mu.Lock()
0000000000000000000000000000000000000000;;		defer r.mu.Unlock()
0000000000000000000000000000000000000000;;		return r.lt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raftNode) stop() {
0000000000000000000000000000000000000000;;		r.stopped <- struct{}{}
0000000000000000000000000000000000000000;;		<-r.done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raftNode) onStop() {
0000000000000000000000000000000000000000;;		r.Stop()
0000000000000000000000000000000000000000;;		r.transport.Stop()
0000000000000000000000000000000000000000;;		if err := r.storage.Close(); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("raft close storage error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(r.done)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// for testing
0000000000000000000000000000000000000000;;	func (r *raftNode) pauseSending() {
0000000000000000000000000000000000000000;;		p := r.transport.(rafthttp.Pausable)
0000000000000000000000000000000000000000;;		p.Pause()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raftNode) resumeSending() {
0000000000000000000000000000000000000000;;		p := r.transport.(rafthttp.Pausable)
0000000000000000000000000000000000000000;;		p.Resume()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// advanceTicksForElection advances ticks to the node for fast election.
0000000000000000000000000000000000000000;;	// This reduces the time to wait for first leader election if bootstrapping the whole
0000000000000000000000000000000000000000;;	// cluster, while leaving at least 1 heartbeat for possible existing leader
0000000000000000000000000000000000000000;;	// to contact it.
0000000000000000000000000000000000000000;;	func advanceTicksForElection(n raft.Node, electionTicks int) {
0000000000000000000000000000000000000000;;		for i := 0; i < electionTicks-1; i++ {
0000000000000000000000000000000000000000;;			n.Tick()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startNode(cfg *ServerConfig, cl *membership.RaftCluster, ids []types.ID) (id types.ID, n raft.Node, s *raft.MemoryStorage, w *wal.WAL) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		member := cl.MemberByName(cfg.Name)
0000000000000000000000000000000000000000;;		metadata := pbutil.MustMarshal(
0000000000000000000000000000000000000000;;			&pb.Metadata{
0000000000000000000000000000000000000000;;				NodeID:    uint64(member.ID),
0000000000000000000000000000000000000000;;				ClusterID: uint64(cl.ID()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if w, err = wal.Create(cfg.WALDir(), metadata); err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("create wal error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		peers := make([]raft.Peer, len(ids))
0000000000000000000000000000000000000000;;		for i, id := range ids {
0000000000000000000000000000000000000000;;			ctx, err := json.Marshal((*cl).Member(id))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("marshal member should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			peers[i] = raft.Peer{ID: uint64(id), Context: ctx}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id = member.ID
0000000000000000000000000000000000000000;;		plog.Infof("starting member %s in cluster %s", id, cl.ID())
0000000000000000000000000000000000000000;;		s = raft.NewMemoryStorage()
0000000000000000000000000000000000000000;;		c := &raft.Config{
0000000000000000000000000000000000000000;;			ID:              uint64(id),
0000000000000000000000000000000000000000;;			ElectionTick:    cfg.ElectionTicks,
0000000000000000000000000000000000000000;;			HeartbeatTick:   1,
0000000000000000000000000000000000000000;;			Storage:         s,
0000000000000000000000000000000000000000;;			MaxSizePerMsg:   maxSizePerMsg,
0000000000000000000000000000000000000000;;			MaxInflightMsgs: maxInflightMsgs,
0000000000000000000000000000000000000000;;			CheckQuorum:     true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n = raft.StartNode(c, peers)
0000000000000000000000000000000000000000;;		raftStatusMu.Lock()
0000000000000000000000000000000000000000;;		raftStatus = n.Status
0000000000000000000000000000000000000000;;		raftStatusMu.Unlock()
0000000000000000000000000000000000000000;;		advanceTicksForElection(n, c.ElectionTick)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restartNode(cfg *ServerConfig, snapshot *raftpb.Snapshot) (types.ID, *membership.RaftCluster, raft.Node, *raft.MemoryStorage, *wal.WAL) {
0000000000000000000000000000000000000000;;		var walsnap walpb.Snapshot
0000000000000000000000000000000000000000;;		if snapshot != nil {
0000000000000000000000000000000000000000;;			walsnap.Index, walsnap.Term = snapshot.Metadata.Index, snapshot.Metadata.Term
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w, id, cid, st, ents := readWAL(cfg.WALDir(), walsnap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("restarting member %s in cluster %s at commit index %d", id, cid, st.Commit)
0000000000000000000000000000000000000000;;		cl := membership.NewCluster("")
0000000000000000000000000000000000000000;;		cl.SetID(cid)
0000000000000000000000000000000000000000;;		s := raft.NewMemoryStorage()
0000000000000000000000000000000000000000;;		if snapshot != nil {
0000000000000000000000000000000000000000;;			s.ApplySnapshot(*snapshot)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.SetHardState(st)
0000000000000000000000000000000000000000;;		s.Append(ents)
0000000000000000000000000000000000000000;;		c := &raft.Config{
0000000000000000000000000000000000000000;;			ID:              uint64(id),
0000000000000000000000000000000000000000;;			ElectionTick:    cfg.ElectionTicks,
0000000000000000000000000000000000000000;;			HeartbeatTick:   1,
0000000000000000000000000000000000000000;;			Storage:         s,
0000000000000000000000000000000000000000;;			MaxSizePerMsg:   maxSizePerMsg,
0000000000000000000000000000000000000000;;			MaxInflightMsgs: maxInflightMsgs,
0000000000000000000000000000000000000000;;			CheckQuorum:     true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := raft.RestartNode(c)
0000000000000000000000000000000000000000;;		raftStatusMu.Lock()
0000000000000000000000000000000000000000;;		raftStatus = n.Status
0000000000000000000000000000000000000000;;		raftStatusMu.Unlock()
0000000000000000000000000000000000000000;;		advanceTicksForElection(n, c.ElectionTick)
0000000000000000000000000000000000000000;;		return id, cl, n, s, w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restartAsStandaloneNode(cfg *ServerConfig, snapshot *raftpb.Snapshot) (types.ID, *membership.RaftCluster, raft.Node, *raft.MemoryStorage, *wal.WAL) {
0000000000000000000000000000000000000000;;		var walsnap walpb.Snapshot
0000000000000000000000000000000000000000;;		if snapshot != nil {
0000000000000000000000000000000000000000;;			walsnap.Index, walsnap.Term = snapshot.Metadata.Index, snapshot.Metadata.Term
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w, id, cid, st, ents := readWAL(cfg.WALDir(), walsnap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// discard the previously uncommitted entries
0000000000000000000000000000000000000000;;		for i, ent := range ents {
0000000000000000000000000000000000000000;;			if ent.Index > st.Commit {
0000000000000000000000000000000000000000;;				plog.Infof("discarding %d uncommitted WAL entries ", len(ents)-i)
0000000000000000000000000000000000000000;;				ents = ents[:i]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// force append the configuration change entries
0000000000000000000000000000000000000000;;		toAppEnts := createConfigChangeEnts(getIDs(snapshot, ents), uint64(id), st.Term, st.Commit)
0000000000000000000000000000000000000000;;		ents = append(ents, toAppEnts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// force commit newly appended entries
0000000000000000000000000000000000000000;;		err := w.Save(raftpb.HardState{}, toAppEnts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Fatalf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ents) != 0 {
0000000000000000000000000000000000000000;;			st.Commit = ents[len(ents)-1].Index
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Printf("forcing restart of member %s in cluster %s at commit index %d", id, cid, st.Commit)
0000000000000000000000000000000000000000;;		cl := membership.NewCluster("")
0000000000000000000000000000000000000000;;		cl.SetID(cid)
0000000000000000000000000000000000000000;;		s := raft.NewMemoryStorage()
0000000000000000000000000000000000000000;;		if snapshot != nil {
0000000000000000000000000000000000000000;;			s.ApplySnapshot(*snapshot)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.SetHardState(st)
0000000000000000000000000000000000000000;;		s.Append(ents)
0000000000000000000000000000000000000000;;		c := &raft.Config{
0000000000000000000000000000000000000000;;			ID:              uint64(id),
0000000000000000000000000000000000000000;;			ElectionTick:    cfg.ElectionTicks,
0000000000000000000000000000000000000000;;			HeartbeatTick:   1,
0000000000000000000000000000000000000000;;			Storage:         s,
0000000000000000000000000000000000000000;;			MaxSizePerMsg:   maxSizePerMsg,
0000000000000000000000000000000000000000;;			MaxInflightMsgs: maxInflightMsgs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := raft.RestartNode(c)
0000000000000000000000000000000000000000;;		raftStatus = n.Status
0000000000000000000000000000000000000000;;		return id, cl, n, s, w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIDs returns an ordered set of IDs included in the given snapshot and
0000000000000000000000000000000000000000;;	// the entries. The given snapshot/entries can contain two kinds of
0000000000000000000000000000000000000000;;	// ID-related entry:
0000000000000000000000000000000000000000;;	// - ConfChangeAddNode, in which case the contained ID will be added into the set.
0000000000000000000000000000000000000000;;	// - ConfChangeRemoveNode, in which case the contained ID will be removed from the set.
0000000000000000000000000000000000000000;;	func getIDs(snap *raftpb.Snapshot, ents []raftpb.Entry) []uint64 {
0000000000000000000000000000000000000000;;		ids := make(map[uint64]bool)
0000000000000000000000000000000000000000;;		if snap != nil {
0000000000000000000000000000000000000000;;			for _, id := range snap.Metadata.ConfState.Nodes {
0000000000000000000000000000000000000000;;				ids[id] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, e := range ents {
0000000000000000000000000000000000000000;;			if e.Type != raftpb.EntryConfChange {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var cc raftpb.ConfChange
0000000000000000000000000000000000000000;;			pbutil.MustUnmarshal(&cc, e.Data)
0000000000000000000000000000000000000000;;			switch cc.Type {
0000000000000000000000000000000000000000;;			case raftpb.ConfChangeAddNode:
0000000000000000000000000000000000000000;;				ids[cc.NodeID] = true
0000000000000000000000000000000000000000;;			case raftpb.ConfChangeRemoveNode:
0000000000000000000000000000000000000000;;				delete(ids, cc.NodeID)
0000000000000000000000000000000000000000;;			case raftpb.ConfChangeUpdateNode:
0000000000000000000000000000000000000000;;				// do nothing
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				plog.Panicf("ConfChange Type should be either ConfChangeAddNode or ConfChangeRemoveNode!")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sids := make(types.Uint64Slice, 0, len(ids))
0000000000000000000000000000000000000000;;		for id := range ids {
0000000000000000000000000000000000000000;;			sids = append(sids, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sids)
0000000000000000000000000000000000000000;;		return []uint64(sids)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createConfigChangeEnts creates a series of Raft entries (i.e.
0000000000000000000000000000000000000000;;	// EntryConfChange) to remove the set of given IDs from the cluster. The ID
0000000000000000000000000000000000000000;;	// `self` is _not_ removed, even if present in the set.
0000000000000000000000000000000000000000;;	// If `self` is not inside the given ids, it creates a Raft entry to add a
0000000000000000000000000000000000000000;;	// default member with the given `self`.
0000000000000000000000000000000000000000;;	func createConfigChangeEnts(ids []uint64, self uint64, term, index uint64) []raftpb.Entry {
0000000000000000000000000000000000000000;;		ents := make([]raftpb.Entry, 0)
0000000000000000000000000000000000000000;;		next := index + 1
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		for _, id := range ids {
0000000000000000000000000000000000000000;;			if id == self {
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc := &raftpb.ConfChange{
0000000000000000000000000000000000000000;;				Type:   raftpb.ConfChangeRemoveNode,
0000000000000000000000000000000000000000;;				NodeID: id,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e := raftpb.Entry{
0000000000000000000000000000000000000000;;				Type:  raftpb.EntryConfChange,
0000000000000000000000000000000000000000;;				Data:  pbutil.MustMarshal(cc),
0000000000000000000000000000000000000000;;				Term:  term,
0000000000000000000000000000000000000000;;				Index: next,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ents = append(ents, e)
0000000000000000000000000000000000000000;;			next++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			m := membership.Member{
0000000000000000000000000000000000000000;;				ID:             types.ID(self),
0000000000000000000000000000000000000000;;				RaftAttributes: membership.RaftAttributes{PeerURLs: []string{"http://localhost:2380"}},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx, err := json.Marshal(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Panicf("marshal member should never fail: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc := &raftpb.ConfChange{
0000000000000000000000000000000000000000;;				Type:    raftpb.ConfChangeAddNode,
0000000000000000000000000000000000000000;;				NodeID:  self,
0000000000000000000000000000000000000000;;				Context: ctx,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e := raftpb.Entry{
0000000000000000000000000000000000000000;;				Type:  raftpb.EntryConfChange,
0000000000000000000000000000000000000000;;				Data:  pbutil.MustMarshal(cc),
0000000000000000000000000000000000000000;;				Term:  term,
0000000000000000000000000000000000000000;;				Index: next,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ents = append(ents, e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ents
0000000000000000000000000000000000000000;;	}
