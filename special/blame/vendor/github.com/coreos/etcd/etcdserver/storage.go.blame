0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/storage.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/storage.go][vendor/github.com/coreos/etcd/etcdserver/storage.go];	
0000000000000000000000000000000000000000;;	package etcdserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/wal/walpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Storage interface {
0000000000000000000000000000000000000000;;		// Save function saves ents and state to the underlying stable storage.
0000000000000000000000000000000000000000;;		// Save MUST block until st and ents are on stable storage.
0000000000000000000000000000000000000000;;		Save(st raftpb.HardState, ents []raftpb.Entry) error
0000000000000000000000000000000000000000;;		// SaveSnap function saves snapshot to the underlying stable storage.
0000000000000000000000000000000000000000;;		SaveSnap(snap raftpb.Snapshot) error
0000000000000000000000000000000000000000;;		// DBFilePath returns the file path of database snapshot saved with given
0000000000000000000000000000000000000000;;		// id.
0000000000000000000000000000000000000000;;		DBFilePath(id uint64) (string, error)
0000000000000000000000000000000000000000;;		// Close closes the Storage and performs finalization.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storage struct {
0000000000000000000000000000000000000000;;		*wal.WAL
0000000000000000000000000000000000000000;;		*snap.Snapshotter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStorage(w *wal.WAL, s *snap.Snapshotter) Storage {
0000000000000000000000000000000000000000;;		return &storage{w, s}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SaveSnap saves the snapshot to disk and release the locked
0000000000000000000000000000000000000000;;	// wal files since they will not be used.
0000000000000000000000000000000000000000;;	func (st *storage) SaveSnap(snap raftpb.Snapshot) error {
0000000000000000000000000000000000000000;;		walsnap := walpb.Snapshot{
0000000000000000000000000000000000000000;;			Index: snap.Metadata.Index,
0000000000000000000000000000000000000000;;			Term:  snap.Metadata.Term,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := st.WAL.SaveSnapshot(walsnap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = st.Snapshotter.SaveSnap(snap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return st.WAL.ReleaseLockTo(snap.Metadata.Index)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readWAL(waldir string, snap walpb.Snapshot) (w *wal.WAL, id, cid types.ID, st raftpb.HardState, ents []raftpb.Entry) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			err       error
0000000000000000000000000000000000000000;;			wmetadata []byte
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		repaired := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if w, err = wal.Open(waldir, snap); err != nil {
0000000000000000000000000000000000000000;;				plog.Fatalf("open wal error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if wmetadata, st, ents, err = w.ReadAll(); err != nil {
0000000000000000000000000000000000000000;;				w.Close()
0000000000000000000000000000000000000000;;				// we can only repair ErrUnexpectedEOF and we never repair twice.
0000000000000000000000000000000000000000;;				if repaired || err != io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;					plog.Fatalf("read wal error (%v) and cannot be repaired", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !wal.Repair(waldir) {
0000000000000000000000000000000000000000;;					plog.Fatalf("WAL error (%v) cannot be repaired", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					plog.Infof("repaired WAL error (%v)", err)
0000000000000000000000000000000000000000;;					repaired = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var metadata pb.Metadata
0000000000000000000000000000000000000000;;		pbutil.MustUnmarshal(&metadata, wmetadata)
0000000000000000000000000000000000000000;;		id = types.ID(metadata.NodeID)
0000000000000000000000000000000000000000;;		cid = types.ID(metadata.ClusterID)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
