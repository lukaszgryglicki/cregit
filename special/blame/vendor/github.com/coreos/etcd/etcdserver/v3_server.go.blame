0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/v3demo_server.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/v3demo_server.go][vendor/github.com/coreos/etcd/etcdserver/v3_server.go];	
0000000000000000000000000000000000000000;;	package etcdserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/auth"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/membership"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/lease"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/lease/leasehttp"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/mvcc"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// the max request size that raft accepts.
0000000000000000000000000000000000000000;;		// TODO: make this a flag? But we probably do not want to
0000000000000000000000000000000000000000;;		// accept large request which might block raft stream. User
0000000000000000000000000000000000000000;;		// specify a large value might end up with shooting in the foot.
0000000000000000000000000000000000000000;;		maxRequestBytes = 1.5 * 1024 * 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In the health case, there might be a small gap (10s of entries) between
0000000000000000000000000000000000000000;;		// the applied index and committed index.
0000000000000000000000000000000000000000;;		// However, if the committed entries are very heavy to apply, the gap might grow.
0000000000000000000000000000000000000000;;		// We should stop accepting new proposals if the gap growing to a certain point.
0000000000000000000000000000000000000000;;		maxGapBetweenApplyAndCommitIndex = 5000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		newRangeClusterVersion = *semver.Must(semver.NewVersion("3.1.0"))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RaftKV interface {
0000000000000000000000000000000000000000;;		Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error)
0000000000000000000000000000000000000000;;		Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error)
0000000000000000000000000000000000000000;;		DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error)
0000000000000000000000000000000000000000;;		Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error)
0000000000000000000000000000000000000000;;		Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Lessor interface {
0000000000000000000000000000000000000000;;		// LeaseGrant sends LeaseGrant request to raft and apply it after committed.
0000000000000000000000000000000000000000;;		LeaseGrant(ctx context.Context, r *pb.LeaseGrantRequest) (*pb.LeaseGrantResponse, error)
0000000000000000000000000000000000000000;;		// LeaseRevoke sends LeaseRevoke request to raft and apply it after committed.
0000000000000000000000000000000000000000;;		LeaseRevoke(ctx context.Context, r *pb.LeaseRevokeRequest) (*pb.LeaseRevokeResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LeaseRenew renews the lease with given ID. The renewed TTL is returned. Or an error
0000000000000000000000000000000000000000;;		// is returned.
0000000000000000000000000000000000000000;;		LeaseRenew(ctx context.Context, id lease.LeaseID) (int64, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LeaseTimeToLive retrieves lease information.
0000000000000000000000000000000000000000;;		LeaseTimeToLive(ctx context.Context, r *pb.LeaseTimeToLiveRequest) (*pb.LeaseTimeToLiveResponse, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Authenticator interface {
0000000000000000000000000000000000000000;;		AuthEnable(ctx context.Context, r *pb.AuthEnableRequest) (*pb.AuthEnableResponse, error)
0000000000000000000000000000000000000000;;		AuthDisable(ctx context.Context, r *pb.AuthDisableRequest) (*pb.AuthDisableResponse, error)
0000000000000000000000000000000000000000;;		Authenticate(ctx context.Context, r *pb.AuthenticateRequest) (*pb.AuthenticateResponse, error)
0000000000000000000000000000000000000000;;		UserAdd(ctx context.Context, r *pb.AuthUserAddRequest) (*pb.AuthUserAddResponse, error)
0000000000000000000000000000000000000000;;		UserDelete(ctx context.Context, r *pb.AuthUserDeleteRequest) (*pb.AuthUserDeleteResponse, error)
0000000000000000000000000000000000000000;;		UserChangePassword(ctx context.Context, r *pb.AuthUserChangePasswordRequest) (*pb.AuthUserChangePasswordResponse, error)
0000000000000000000000000000000000000000;;		UserGrantRole(ctx context.Context, r *pb.AuthUserGrantRoleRequest) (*pb.AuthUserGrantRoleResponse, error)
0000000000000000000000000000000000000000;;		UserGet(ctx context.Context, r *pb.AuthUserGetRequest) (*pb.AuthUserGetResponse, error)
0000000000000000000000000000000000000000;;		UserRevokeRole(ctx context.Context, r *pb.AuthUserRevokeRoleRequest) (*pb.AuthUserRevokeRoleResponse, error)
0000000000000000000000000000000000000000;;		RoleAdd(ctx context.Context, r *pb.AuthRoleAddRequest) (*pb.AuthRoleAddResponse, error)
0000000000000000000000000000000000000000;;		RoleGrantPermission(ctx context.Context, r *pb.AuthRoleGrantPermissionRequest) (*pb.AuthRoleGrantPermissionResponse, error)
0000000000000000000000000000000000000000;;		RoleGet(ctx context.Context, r *pb.AuthRoleGetRequest) (*pb.AuthRoleGetResponse, error)
0000000000000000000000000000000000000000;;		RoleRevokePermission(ctx context.Context, r *pb.AuthRoleRevokePermissionRequest) (*pb.AuthRoleRevokePermissionResponse, error)
0000000000000000000000000000000000000000;;		RoleDelete(ctx context.Context, r *pb.AuthRoleDeleteRequest) (*pb.AuthRoleDeleteResponse, error)
0000000000000000000000000000000000000000;;		UserList(ctx context.Context, r *pb.AuthUserListRequest) (*pb.AuthUserListResponse, error)
0000000000000000000000000000000000000000;;		RoleList(ctx context.Context, r *pb.AuthRoleListRequest) (*pb.AuthRoleListResponse, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Range(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
0000000000000000000000000000000000000000;;		// TODO: remove this checking when we release etcd 3.2
0000000000000000000000000000000000000000;;		if s.ClusterVersion() == nil || s.ClusterVersion().LessThan(newRangeClusterVersion) {
0000000000000000000000000000000000000000;;			return s.legacyRange(ctx, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !r.Serializable {
0000000000000000000000000000000000000000;;			err := s.linearizableReadNotify(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var resp *pb.RangeResponse
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		chk := func(ai *auth.AuthInfo) error {
0000000000000000000000000000000000000000;;			return s.authStore.IsRangePermitted(ai, r.Key, r.RangeEnd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		get := func() { resp, err = s.applyV3Base.Range(noTxn, r) }
0000000000000000000000000000000000000000;;		if serr := s.doSerialize(ctx, chk, get); serr != nil {
0000000000000000000000000000000000000000;;			return nil, serr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove this func when we release etcd 3.2
0000000000000000000000000000000000000000;;	func (s *EtcdServer) legacyRange(ctx context.Context, r *pb.RangeRequest) (*pb.RangeResponse, error) {
0000000000000000000000000000000000000000;;		if r.Serializable {
0000000000000000000000000000000000000000;;			var resp *pb.RangeResponse
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			chk := func(ai *auth.AuthInfo) error {
0000000000000000000000000000000000000000;;				return s.authStore.IsRangePermitted(ai, r.Key, r.RangeEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			get := func() { resp, err = s.applyV3Base.Range(noTxn, r) }
0000000000000000000000000000000000000000;;			if serr := s.doSerialize(ctx, chk, get); serr != nil {
0000000000000000000000000000000000000000;;				return nil, serr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{Range: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.RangeResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Put(ctx context.Context, r *pb.PutRequest) (*pb.PutResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{Put: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.PutResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) DeleteRange(ctx context.Context, r *pb.DeleteRangeRequest) (*pb.DeleteRangeResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{DeleteRange: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.DeleteRangeResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Txn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error) {
0000000000000000000000000000000000000000;;		// TODO: remove this checking when we release etcd 3.2
0000000000000000000000000000000000000000;;		if s.ClusterVersion() == nil || s.ClusterVersion().LessThan(newRangeClusterVersion) {
0000000000000000000000000000000000000000;;			return s.legacyTxn(ctx, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isTxnReadonly(r) {
0000000000000000000000000000000000000000;;			if !isTxnSerializable(r) {
0000000000000000000000000000000000000000;;				err := s.linearizableReadNotify(ctx)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var resp *pb.TxnResponse
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			chk := func(ai *auth.AuthInfo) error {
0000000000000000000000000000000000000000;;				return checkTxnAuth(s.authStore, ai, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			get := func() { resp, err = s.applyV3Base.Txn(r) }
0000000000000000000000000000000000000000;;			if serr := s.doSerialize(ctx, chk, get); serr != nil {
0000000000000000000000000000000000000000;;				return nil, serr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{Txn: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.TxnResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove this func when we release etcd 3.2
0000000000000000000000000000000000000000;;	func (s *EtcdServer) legacyTxn(ctx context.Context, r *pb.TxnRequest) (*pb.TxnResponse, error) {
0000000000000000000000000000000000000000;;		if isTxnSerializable(r) {
0000000000000000000000000000000000000000;;			var resp *pb.TxnResponse
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			chk := func(ai *auth.AuthInfo) error {
0000000000000000000000000000000000000000;;				return checkTxnAuth(s.authStore, ai, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			get := func() { resp, err = s.applyV3Base.Txn(r) }
0000000000000000000000000000000000000000;;			if serr := s.doSerialize(ctx, chk, get); serr != nil {
0000000000000000000000000000000000000000;;				return nil, serr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{Txn: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.TxnResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isTxnSerializable(r *pb.TxnRequest) bool {
0000000000000000000000000000000000000000;;		for _, u := range r.Success {
0000000000000000000000000000000000000000;;			if r := u.GetRequestRange(); r == nil || !r.Serializable {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, u := range r.Failure {
0000000000000000000000000000000000000000;;			if r := u.GetRequestRange(); r == nil || !r.Serializable {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isTxnReadonly(r *pb.TxnRequest) bool {
0000000000000000000000000000000000000000;;		for _, u := range r.Success {
0000000000000000000000000000000000000000;;			if r := u.GetRequestRange(); r == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, u := range r.Failure {
0000000000000000000000000000000000000000;;			if r := u.GetRequestRange(); r == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Compact(ctx context.Context, r *pb.CompactionRequest) (*pb.CompactionResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequestOnce(ctx, pb.InternalRaftRequest{Compaction: r})
0000000000000000000000000000000000000000;;		if r.Physical && result != nil && result.physc != nil {
0000000000000000000000000000000000000000;;			<-result.physc
0000000000000000000000000000000000000000;;			// The compaction is done deleting keys; the hash is now settled
0000000000000000000000000000000000000000;;			// but the data is not necessarily committed. If there's a crash,
0000000000000000000000000000000000000000;;			// the hash may revert to a hash prior to compaction completing
0000000000000000000000000000000000000000;;			// if the compaction resumes. Force the finished compaction to
0000000000000000000000000000000000000000;;			// commit so it won't resume following a crash.
0000000000000000000000000000000000000000;;			s.be.ForceCommit()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp := result.resp.(*pb.CompactionResponse)
0000000000000000000000000000000000000000;;		if resp == nil {
0000000000000000000000000000000000000000;;			resp = &pb.CompactionResponse{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.Header == nil {
0000000000000000000000000000000000000000;;			resp.Header = &pb.ResponseHeader{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Header.Revision = s.kv.Rev()
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) LeaseGrant(ctx context.Context, r *pb.LeaseGrantRequest) (*pb.LeaseGrantResponse, error) {
0000000000000000000000000000000000000000;;		// no id given? choose one
0000000000000000000000000000000000000000;;		for r.ID == int64(lease.NoLease) {
0000000000000000000000000000000000000000;;			// only use positive int64 id's
0000000000000000000000000000000000000000;;			r.ID = int64(s.reqIDGen.Next() & ((1 << 63) - 1))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequestOnce(ctx, pb.InternalRaftRequest{LeaseGrant: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.LeaseGrantResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) LeaseRevoke(ctx context.Context, r *pb.LeaseRevokeRequest) (*pb.LeaseRevokeResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequestOnce(ctx, pb.InternalRaftRequest{LeaseRevoke: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.LeaseRevokeResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) LeaseRenew(ctx context.Context, id lease.LeaseID) (int64, error) {
0000000000000000000000000000000000000000;;		ttl, err := s.lessor.Renew(id)
0000000000000000000000000000000000000000;;		if err == nil { // already requested to primary lessor(leader)
0000000000000000000000000000000000000000;;			return ttl, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != lease.ErrNotPrimary {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithTimeout(ctx, s.Cfg.ReqTimeout())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// renewals don't go through raft; forward to leader manually
0000000000000000000000000000000000000000;;		for cctx.Err() == nil && err != nil {
0000000000000000000000000000000000000000;;			leader, lerr := s.waitLeader(cctx)
0000000000000000000000000000000000000000;;			if lerr != nil {
0000000000000000000000000000000000000000;;				return -1, lerr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, url := range leader.PeerURLs {
0000000000000000000000000000000000000000;;				lurl := url + leasehttp.LeasePrefix
0000000000000000000000000000000000000000;;				ttl, err = leasehttp.RenewHTTP(cctx, id, lurl, s.peerRt)
0000000000000000000000000000000000000000;;				if err == nil || err == lease.ErrLeaseNotFound {
0000000000000000000000000000000000000000;;					return ttl, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1, ErrTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) LeaseTimeToLive(ctx context.Context, r *pb.LeaseTimeToLiveRequest) (*pb.LeaseTimeToLiveResponse, error) {
0000000000000000000000000000000000000000;;		if s.Leader() == s.ID() {
0000000000000000000000000000000000000000;;			// primary; timetolive directly from leader
0000000000000000000000000000000000000000;;			le := s.lessor.Lookup(lease.LeaseID(r.ID))
0000000000000000000000000000000000000000;;			if le == nil {
0000000000000000000000000000000000000000;;				return nil, lease.ErrLeaseNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: fill out ResponseHeader
0000000000000000000000000000000000000000;;			resp := &pb.LeaseTimeToLiveResponse{Header: &pb.ResponseHeader{}, ID: r.ID, TTL: int64(le.Remaining().Seconds()), GrantedTTL: le.TTL()}
0000000000000000000000000000000000000000;;			if r.Keys {
0000000000000000000000000000000000000000;;				ks := le.Keys()
0000000000000000000000000000000000000000;;				kbs := make([][]byte, len(ks))
0000000000000000000000000000000000000000;;				for i := range ks {
0000000000000000000000000000000000000000;;					kbs[i] = []byte(ks[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resp.Keys = kbs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithTimeout(ctx, s.Cfg.ReqTimeout())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// forward to leader
0000000000000000000000000000000000000000;;		for cctx.Err() == nil {
0000000000000000000000000000000000000000;;			leader, err := s.waitLeader(cctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, url := range leader.PeerURLs {
0000000000000000000000000000000000000000;;				lurl := url + leasehttp.LeaseInternalPrefix
0000000000000000000000000000000000000000;;				resp, err := leasehttp.TimeToLiveHTTP(cctx, lease.LeaseID(r.ID), r.Keys, lurl, s.peerRt)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return resp.LeaseTimeToLiveResponse, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == lease.ErrLeaseNotFound {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, ErrTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) waitLeader(ctx context.Context) (*membership.Member, error) {
0000000000000000000000000000000000000000;;		leader := s.cluster.Member(s.Leader())
0000000000000000000000000000000000000000;;		for leader == nil {
0000000000000000000000000000000000000000;;			// wait an election
0000000000000000000000000000000000000000;;			dur := time.Duration(s.Cfg.ElectionTicks) * time.Duration(s.Cfg.TickMs) * time.Millisecond
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(dur):
0000000000000000000000000000000000000000;;				leader = s.cluster.Member(s.Leader())
0000000000000000000000000000000000000000;;			case <-s.stopping:
0000000000000000000000000000000000000000;;				return nil, ErrStopped
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return nil, ErrNoLeader
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if leader == nil || len(leader.PeerURLs) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNoLeader
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return leader, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Alarm(ctx context.Context, r *pb.AlarmRequest) (*pb.AlarmResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequestOnce(ctx, pb.InternalRaftRequest{Alarm: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AlarmResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) AuthEnable(ctx context.Context, r *pb.AuthEnableRequest) (*pb.AuthEnableResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequestOnce(ctx, pb.InternalRaftRequest{AuthEnable: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthEnableResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) AuthDisable(ctx context.Context, r *pb.AuthDisableRequest) (*pb.AuthDisableResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthDisable: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthDisableResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Authenticate(ctx context.Context, r *pb.AuthenticateRequest) (*pb.AuthenticateResponse, error) {
0000000000000000000000000000000000000000;;		var result *applyResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := s.linearizableReadNotify(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			checkedRevision, err := s.AuthStore().CheckPassword(r.Name, r.Password)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("invalid authentication request to user %s was issued", r.Name)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			st, err := s.AuthStore().GenSimpleToken()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			internalReq := &pb.InternalAuthenticateRequest{
0000000000000000000000000000000000000000;;				Name:        r.Name,
0000000000000000000000000000000000000000;;				Password:    r.Password,
0000000000000000000000000000000000000000;;				SimpleToken: st,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result, err = s.processInternalRaftRequestOnce(ctx, pb.InternalRaftRequest{Authenticate: internalReq})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result.err != nil {
0000000000000000000000000000000000000000;;				return nil, result.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if checkedRevision != s.AuthStore().Revision() {
0000000000000000000000000000000000000000;;				plog.Infof("revision when password checked is obsolete, retrying")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthenticateResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UserAdd(ctx context.Context, r *pb.AuthUserAddRequest) (*pb.AuthUserAddResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthUserAdd: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthUserAddResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UserDelete(ctx context.Context, r *pb.AuthUserDeleteRequest) (*pb.AuthUserDeleteResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthUserDelete: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthUserDeleteResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UserChangePassword(ctx context.Context, r *pb.AuthUserChangePasswordRequest) (*pb.AuthUserChangePasswordResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthUserChangePassword: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthUserChangePasswordResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UserGrantRole(ctx context.Context, r *pb.AuthUserGrantRoleRequest) (*pb.AuthUserGrantRoleResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthUserGrantRole: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthUserGrantRoleResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UserGet(ctx context.Context, r *pb.AuthUserGetRequest) (*pb.AuthUserGetResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthUserGet: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthUserGetResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UserList(ctx context.Context, r *pb.AuthUserListRequest) (*pb.AuthUserListResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthUserList: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthUserListResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) UserRevokeRole(ctx context.Context, r *pb.AuthUserRevokeRoleRequest) (*pb.AuthUserRevokeRoleResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthUserRevokeRole: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthUserRevokeRoleResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RoleAdd(ctx context.Context, r *pb.AuthRoleAddRequest) (*pb.AuthRoleAddResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthRoleAdd: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthRoleAddResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RoleGrantPermission(ctx context.Context, r *pb.AuthRoleGrantPermissionRequest) (*pb.AuthRoleGrantPermissionResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthRoleGrantPermission: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthRoleGrantPermissionResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RoleGet(ctx context.Context, r *pb.AuthRoleGetRequest) (*pb.AuthRoleGetResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthRoleGet: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthRoleGetResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RoleList(ctx context.Context, r *pb.AuthRoleListRequest) (*pb.AuthRoleListResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthRoleList: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthRoleListResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RoleRevokePermission(ctx context.Context, r *pb.AuthRoleRevokePermissionRequest) (*pb.AuthRoleRevokePermissionResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthRoleRevokePermission: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthRoleRevokePermissionResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) RoleDelete(ctx context.Context, r *pb.AuthRoleDeleteRequest) (*pb.AuthRoleDeleteResponse, error) {
0000000000000000000000000000000000000000;;		result, err := s.processInternalRaftRequest(ctx, pb.InternalRaftRequest{AuthRoleDelete: r})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.err != nil {
0000000000000000000000000000000000000000;;			return nil, result.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result.resp.(*pb.AuthRoleDeleteResponse), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// doSerialize handles the auth logic, with permissions checked by "chk", for a serialized request "get". Returns a non-nil error on authentication failure.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) doSerialize(ctx context.Context, chk func(*auth.AuthInfo) error, get func()) error {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ai, err := s.AuthStore().AuthInfoFromCtx(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ai == nil {
0000000000000000000000000000000000000000;;				// chk expects non-nil AuthInfo; use empty credentials
0000000000000000000000000000000000000000;;				ai = &auth.AuthInfo{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = chk(ai); err != nil {
0000000000000000000000000000000000000000;;				if err == auth.ErrAuthOldRevision {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// fetch response for serialized request
0000000000000000000000000000000000000000;;			get()
0000000000000000000000000000000000000000;;			//  empty credentials or current auth info means no need to retry
0000000000000000000000000000000000000000;;			if ai.Revision == 0 || ai.Revision == s.authStore.Revision() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// avoid TOCTOU error, retry of the request is required.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) processInternalRaftRequestOnce(ctx context.Context, r pb.InternalRaftRequest) (*applyResult, error) {
0000000000000000000000000000000000000000;;		ai := s.getAppliedIndex()
0000000000000000000000000000000000000000;;		ci := s.getCommittedIndex()
0000000000000000000000000000000000000000;;		if ci > ai+maxGapBetweenApplyAndCommitIndex {
0000000000000000000000000000000000000000;;			return nil, ErrTooManyRequests
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Header = &pb.RequestHeader{
0000000000000000000000000000000000000000;;			ID: s.reqIDGen.Next(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authInfo, err := s.AuthStore().AuthInfoFromCtx(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if authInfo != nil {
0000000000000000000000000000000000000000;;			r.Header.Username = authInfo.Username
0000000000000000000000000000000000000000;;			r.Header.AuthRevision = authInfo.Revision
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := r.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) > maxRequestBytes {
0000000000000000000000000000000000000000;;			return nil, ErrRequestTooLarge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := r.ID
0000000000000000000000000000000000000000;;		if id == 0 {
0000000000000000000000000000000000000000;;			id = r.Header.ID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch := s.w.Register(id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithTimeout(ctx, s.Cfg.ReqTimeout())
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		s.r.Propose(cctx, data)
0000000000000000000000000000000000000000;;		proposalsPending.Inc()
0000000000000000000000000000000000000000;;		defer proposalsPending.Dec()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case x := <-ch:
0000000000000000000000000000000000000000;;			return x.(*applyResult), nil
0000000000000000000000000000000000000000;;		case <-cctx.Done():
0000000000000000000000000000000000000000;;			proposalsFailed.Inc()
0000000000000000000000000000000000000000;;			s.w.Trigger(id, nil) // GC wait
0000000000000000000000000000000000000000;;			return nil, s.parseProposeCtxErr(cctx.Err(), start)
0000000000000000000000000000000000000000;;		case <-s.done:
0000000000000000000000000000000000000000;;			return nil, ErrStopped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) processInternalRaftRequest(ctx context.Context, r pb.InternalRaftRequest) (*applyResult, error) {
0000000000000000000000000000000000000000;;		var result *applyResult
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			result, err = s.processInternalRaftRequestOnce(ctx, r)
0000000000000000000000000000000000000000;;			if err != auth.ErrAuthOldRevision {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watchable returns a watchable interface attached to the etcdserver.
0000000000000000000000000000000000000000;;	func (s *EtcdServer) Watchable() mvcc.WatchableKV { return s.KV() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) linearizableReadLoop() {
0000000000000000000000000000000000000000;;		var rs raft.ReadState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ctx := make([]byte, 8)
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint64(ctx, s.reqIDGen.Next())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-s.readwaitc:
0000000000000000000000000000000000000000;;			case <-s.stopping:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nextnr := newNotifier()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.readMu.Lock()
0000000000000000000000000000000000000000;;			nr := s.readNotifier
0000000000000000000000000000000000000000;;			s.readNotifier = nextnr
0000000000000000000000000000000000000000;;			s.readMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cctx, cancel := context.WithTimeout(context.Background(), s.Cfg.ReqTimeout())
0000000000000000000000000000000000000000;;			if err := s.r.ReadIndex(cctx, ctx); err != nil {
0000000000000000000000000000000000000000;;				cancel()
0000000000000000000000000000000000000000;;				if err == raft.ErrStopped {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Errorf("failed to get read index from raft: %v", err)
0000000000000000000000000000000000000000;;				nr.notify(err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				timeout bool
0000000000000000000000000000000000000000;;				done    bool
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			for !timeout && !done {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case rs = <-s.r.readStateC:
0000000000000000000000000000000000000000;;					done = bytes.Equal(rs.RequestCtx, ctx)
0000000000000000000000000000000000000000;;					if !done {
0000000000000000000000000000000000000000;;						// a previous request might time out. now we should ignore the response of it and
0000000000000000000000000000000000000000;;						// continue waiting for the response of the current requests.
0000000000000000000000000000000000000000;;						plog.Warningf("ignored out-of-date read index response (want %v, got %v)", rs.RequestCtx, ctx)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-time.After(s.Cfg.ReqTimeout()):
0000000000000000000000000000000000000000;;					plog.Warningf("timed out waiting for read index response")
0000000000000000000000000000000000000000;;					nr.notify(ErrTimeout)
0000000000000000000000000000000000000000;;					timeout = true
0000000000000000000000000000000000000000;;				case <-s.stopping:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !done {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ai := s.getAppliedIndex(); ai < rs.Index {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-s.applyWait.Wait(rs.Index):
0000000000000000000000000000000000000000;;				case <-s.stopping:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// unblock all l-reads requested at indices before rs.Index
0000000000000000000000000000000000000000;;			nr.notify(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *EtcdServer) linearizableReadNotify(ctx context.Context) error {
0000000000000000000000000000000000000000;;		s.readMu.RLock()
0000000000000000000000000000000000000000;;		nc := s.readNotifier
0000000000000000000000000000000000000000;;		s.readMu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// signal linearizable loop for current notify if it hasn't been already
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case s.readwaitc <- struct{}{}:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for read state notification
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-nc.c:
0000000000000000000000000000000000000000;;			return nc.err
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return ctx.Err()
0000000000000000000000000000000000000000;;		case <-s.done:
0000000000000000000000000000000000000000;;			return ErrStopped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
