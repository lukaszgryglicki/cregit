0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/stats/server.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/stats/server.go][vendor/github.com/coreos/etcd/etcdserver/stats/server.go];	
0000000000000000000000000000000000000000;;	package stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerStats encapsulates various statistics about an EtcdServer and its
0000000000000000000000000000000000000000;;	// communication with other members of the cluster
0000000000000000000000000000000000000000;;	type ServerStats struct {
0000000000000000000000000000000000000000;;		Name string `json:"name"`
0000000000000000000000000000000000000000;;		// ID is the raft ID of the node.
0000000000000000000000000000000000000000;;		// TODO(jonboulle): use ID instead of name?
0000000000000000000000000000000000000000;;		ID        string         `json:"id"`
0000000000000000000000000000000000000000;;		State     raft.StateType `json:"state"`
0000000000000000000000000000000000000000;;		StartTime time.Time      `json:"startTime"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LeaderInfo struct {
0000000000000000000000000000000000000000;;			Name      string    `json:"leader"`
0000000000000000000000000000000000000000;;			Uptime    string    `json:"uptime"`
0000000000000000000000000000000000000000;;			StartTime time.Time `json:"startTime"`
0000000000000000000000000000000000000000;;		} `json:"leaderInfo"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RecvAppendRequestCnt uint64  `json:"recvAppendRequestCnt,"`
0000000000000000000000000000000000000000;;		RecvingPkgRate       float64 `json:"recvPkgRate,omitempty"`
0000000000000000000000000000000000000000;;		RecvingBandwidthRate float64 `json:"recvBandwidthRate,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SendAppendRequestCnt uint64  `json:"sendAppendRequestCnt"`
0000000000000000000000000000000000000000;;		SendingPkgRate       float64 `json:"sendPkgRate,omitempty"`
0000000000000000000000000000000000000000;;		SendingBandwidthRate float64 `json:"sendBandwidthRate,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sendRateQueue *statsQueue
0000000000000000000000000000000000000000;;		recvRateQueue *statsQueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *ServerStats) JSON() []byte {
0000000000000000000000000000000000000000;;		ss.Lock()
0000000000000000000000000000000000000000;;		stats := *ss
0000000000000000000000000000000000000000;;		ss.Unlock()
0000000000000000000000000000000000000000;;		stats.LeaderInfo.Uptime = time.Since(stats.LeaderInfo.StartTime).String()
0000000000000000000000000000000000000000;;		stats.SendingPkgRate, stats.SendingBandwidthRate = stats.SendRates()
0000000000000000000000000000000000000000;;		stats.RecvingPkgRate, stats.RecvingBandwidthRate = stats.RecvRates()
0000000000000000000000000000000000000000;;		b, err := json.Marshal(stats)
0000000000000000000000000000000000000000;;		// TODO(jonboulle): appropriate error handling?
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Printf("stats: error marshalling server stats: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize clears the statistics of ServerStats and resets its start time
0000000000000000000000000000000000000000;;	func (ss *ServerStats) Initialize() {
0000000000000000000000000000000000000000;;		if ss == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		ss.StartTime = now
0000000000000000000000000000000000000000;;		ss.LeaderInfo.StartTime = now
0000000000000000000000000000000000000000;;		ss.sendRateQueue = &statsQueue{
0000000000000000000000000000000000000000;;			back: -1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.recvRateQueue = &statsQueue{
0000000000000000000000000000000000000000;;			back: -1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecvRates calculates and returns the rate of received append requests
0000000000000000000000000000000000000000;;	func (ss *ServerStats) RecvRates() (float64, float64) {
0000000000000000000000000000000000000000;;		return ss.recvRateQueue.Rate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendRates calculates and returns the rate of sent append requests
0000000000000000000000000000000000000000;;	func (ss *ServerStats) SendRates() (float64, float64) {
0000000000000000000000000000000000000000;;		return ss.sendRateQueue.Rate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecvAppendReq updates the ServerStats in response to an AppendRequest
0000000000000000000000000000000000000000;;	// from the given leader being received
0000000000000000000000000000000000000000;;	func (ss *ServerStats) RecvAppendReq(leader string, reqSize int) {
0000000000000000000000000000000000000000;;		ss.Lock()
0000000000000000000000000000000000000000;;		defer ss.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss.State = raft.StateFollower
0000000000000000000000000000000000000000;;		if leader != ss.LeaderInfo.Name {
0000000000000000000000000000000000000000;;			ss.LeaderInfo.Name = leader
0000000000000000000000000000000000000000;;			ss.LeaderInfo.StartTime = now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss.recvRateQueue.Insert(
0000000000000000000000000000000000000000;;			&RequestStats{
0000000000000000000000000000000000000000;;				SendingTime: now,
0000000000000000000000000000000000000000;;				Size:        reqSize,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		ss.RecvAppendRequestCnt++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendAppendReq updates the ServerStats in response to an AppendRequest
0000000000000000000000000000000000000000;;	// being sent by this server
0000000000000000000000000000000000000000;;	func (ss *ServerStats) SendAppendReq(reqSize int) {
0000000000000000000000000000000000000000;;		ss.Lock()
0000000000000000000000000000000000000000;;		defer ss.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss.becomeLeader()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss.sendRateQueue.Insert(
0000000000000000000000000000000000000000;;			&RequestStats{
0000000000000000000000000000000000000000;;				SendingTime: time.Now(),
0000000000000000000000000000000000000000;;				Size:        reqSize,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss.SendAppendRequestCnt++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *ServerStats) BecomeLeader() {
0000000000000000000000000000000000000000;;		ss.Lock()
0000000000000000000000000000000000000000;;		defer ss.Unlock()
0000000000000000000000000000000000000000;;		ss.becomeLeader()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *ServerStats) becomeLeader() {
0000000000000000000000000000000000000000;;		if ss.State != raft.StateLeader {
0000000000000000000000000000000000000000;;			ss.State = raft.StateLeader
0000000000000000000000000000000000000000;;			ss.LeaderInfo.Name = ss.ID
0000000000000000000000000000000000000000;;			ss.LeaderInfo.StartTime = time.Now()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
