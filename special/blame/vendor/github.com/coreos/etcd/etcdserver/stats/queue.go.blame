0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/stats/queue.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/stats/queue.go][vendor/github.com/coreos/etcd/etcdserver/stats/queue.go];	
0000000000000000000000000000000000000000;;	package stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		queueCapacity = 200
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestStats represent the stats for a request.
0000000000000000000000000000000000000000;;	// It encapsulates the sending time and the size of the request.
0000000000000000000000000000000000000000;;	type RequestStats struct {
0000000000000000000000000000000000000000;;		SendingTime time.Time
0000000000000000000000000000000000000000;;		Size        int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type statsQueue struct {
0000000000000000000000000000000000000000;;		items        [queueCapacity]*RequestStats
0000000000000000000000000000000000000000;;		size         int
0000000000000000000000000000000000000000;;		front        int
0000000000000000000000000000000000000000;;		back         int
0000000000000000000000000000000000000000;;		totalReqSize int
0000000000000000000000000000000000000000;;		rwl          sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *statsQueue) Len() int {
0000000000000000000000000000000000000000;;		return q.size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *statsQueue) ReqSize() int {
0000000000000000000000000000000000000000;;		return q.totalReqSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FrontAndBack gets the front and back elements in the queue
0000000000000000000000000000000000000000;;	// We must grab front and back together with the protection of the lock
0000000000000000000000000000000000000000;;	func (q *statsQueue) frontAndBack() (*RequestStats, *RequestStats) {
0000000000000000000000000000000000000000;;		q.rwl.RLock()
0000000000000000000000000000000000000000;;		defer q.rwl.RUnlock()
0000000000000000000000000000000000000000;;		if q.size != 0 {
0000000000000000000000000000000000000000;;			return q.items[q.front], q.items[q.back]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert function insert a RequestStats into the queue and update the records
0000000000000000000000000000000000000000;;	func (q *statsQueue) Insert(p *RequestStats) {
0000000000000000000000000000000000000000;;		q.rwl.Lock()
0000000000000000000000000000000000000000;;		defer q.rwl.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.back = (q.back + 1) % queueCapacity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if q.size == queueCapacity { //dequeue
0000000000000000000000000000000000000000;;			q.totalReqSize -= q.items[q.front].Size
0000000000000000000000000000000000000000;;			q.front = (q.back + 1) % queueCapacity
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			q.size++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.items[q.back] = p
0000000000000000000000000000000000000000;;		q.totalReqSize += q.items[q.back].Size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rate function returns the package rate and byte rate
0000000000000000000000000000000000000000;;	func (q *statsQueue) Rate() (float64, float64) {
0000000000000000000000000000000000000000;;		front, back := q.frontAndBack()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if front == nil || back == nil {
0000000000000000000000000000000000000000;;			return 0, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if time.Since(back.SendingTime) > time.Second {
0000000000000000000000000000000000000000;;			q.Clear()
0000000000000000000000000000000000000000;;			return 0, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sampleDuration := back.SendingTime.Sub(front.SendingTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pr := float64(q.Len()) / float64(sampleDuration) * float64(time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		br := float64(q.ReqSize()) / float64(sampleDuration) * float64(time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pr, br
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clear function clear up the statsQueue
0000000000000000000000000000000000000000;;	func (q *statsQueue) Clear() {
0000000000000000000000000000000000000000;;		q.rwl.Lock()
0000000000000000000000000000000000000000;;		defer q.rwl.Unlock()
0000000000000000000000000000000000000000;;		q.back = -1
0000000000000000000000000000000000000000;;		q.front = 0
0000000000000000000000000000000000000000;;		q.size = 0
0000000000000000000000000000000000000000;;		q.totalReqSize = 0
0000000000000000000000000000000000000000;;	}
