0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/util.go[Godeps/_workspace/src/github.com/coreos/etcd/etcdserver/util.go][vendor/github.com/coreos/etcd/etcdserver/util.go];	
0000000000000000000000000000000000000000;;	package etcdserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/membership"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/rafthttp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isConnectedToQuorumSince checks whether the local member is connected to the
0000000000000000000000000000000000000000;;	// quorum of the cluster since the given time.
0000000000000000000000000000000000000000;;	func isConnectedToQuorumSince(transport rafthttp.Transporter, since time.Time, self types.ID, members []*membership.Member) bool {
0000000000000000000000000000000000000000;;		return numConnectedSince(transport, since, self, members) >= (len(members)/2)+1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isConnectedSince checks whether the local member is connected to the
0000000000000000000000000000000000000000;;	// remote member since the given time.
0000000000000000000000000000000000000000;;	func isConnectedSince(transport rafthttp.Transporter, since time.Time, remote types.ID) bool {
0000000000000000000000000000000000000000;;		t := transport.ActiveSince(remote)
0000000000000000000000000000000000000000;;		return !t.IsZero() && t.Before(since)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isConnectedFullySince checks whether the local member is connected to all
0000000000000000000000000000000000000000;;	// members in the cluster since the given time.
0000000000000000000000000000000000000000;;	func isConnectedFullySince(transport rafthttp.Transporter, since time.Time, self types.ID, members []*membership.Member) bool {
0000000000000000000000000000000000000000;;		return numConnectedSince(transport, since, self, members) == len(members)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// numConnectedSince counts how many members are connected to the local member
0000000000000000000000000000000000000000;;	// since the given time.
0000000000000000000000000000000000000000;;	func numConnectedSince(transport rafthttp.Transporter, since time.Time, self types.ID, members []*membership.Member) int {
0000000000000000000000000000000000000000;;		connectedNum := 0
0000000000000000000000000000000000000000;;		for _, m := range members {
0000000000000000000000000000000000000000;;			if m.ID == self || isConnectedSince(transport, since, m.ID) {
0000000000000000000000000000000000000000;;				connectedNum++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return connectedNum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// longestConnected chooses the member with longest active-since-time.
0000000000000000000000000000000000000000;;	// It returns false, if nothing is active.
0000000000000000000000000000000000000000;;	func longestConnected(tp rafthttp.Transporter, membs []types.ID) (types.ID, bool) {
0000000000000000000000000000000000000000;;		var longest types.ID
0000000000000000000000000000000000000000;;		var oldest time.Time
0000000000000000000000000000000000000000;;		for _, id := range membs {
0000000000000000000000000000000000000000;;			tm := tp.ActiveSince(id)
0000000000000000000000000000000000000000;;			if tm.IsZero() { // inactive
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if oldest.IsZero() { // first longest candidate
0000000000000000000000000000000000000000;;				oldest = tm
0000000000000000000000000000000000000000;;				longest = id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tm.Before(oldest) {
0000000000000000000000000000000000000000;;				oldest = tm
0000000000000000000000000000000000000000;;				longest = id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if uint64(longest) == 0 {
0000000000000000000000000000000000000000;;			return longest, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return longest, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type notifier struct {
0000000000000000000000000000000000000000;;		c   chan struct{}
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newNotifier() *notifier {
0000000000000000000000000000000000000000;;		return &notifier{
0000000000000000000000000000000000000000;;			c: make(chan struct{}, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nc *notifier) notify(err error) {
0000000000000000000000000000000000000000;;		nc.err = err
0000000000000000000000000000000000000000;;		close(nc.c)
0000000000000000000000000000000000000000;;	}
