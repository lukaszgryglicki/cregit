0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/discovery/discovery.go[Godeps/_workspace/src/github.com/coreos/etcd/discovery/discovery.go][vendor/github.com/coreos/etcd/discovery/discovery.go];	
0000000000000000000000000000000000000000;;	// Package discovery provides an implementation of the cluster discovery that
0000000000000000000000000000000000000000;;	// is used by etcd.
0000000000000000000000000000000000000000;;	package discovery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/transport"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "discovery")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrInvalidURL           = errors.New("discovery: invalid URL")
0000000000000000000000000000000000000000;;		ErrBadSizeKey           = errors.New("discovery: size key is bad")
0000000000000000000000000000000000000000;;		ErrSizeNotFound         = errors.New("discovery: size key not found")
0000000000000000000000000000000000000000;;		ErrTokenNotFound        = errors.New("discovery: token not found")
0000000000000000000000000000000000000000;;		ErrDuplicateID          = errors.New("discovery: found duplicate id")
0000000000000000000000000000000000000000;;		ErrDuplicateName        = errors.New("discovery: found duplicate name")
0000000000000000000000000000000000000000;;		ErrFullCluster          = errors.New("discovery: cluster is full")
0000000000000000000000000000000000000000;;		ErrTooManyRetries       = errors.New("discovery: too many retries")
0000000000000000000000000000000000000000;;		ErrBadDiscoveryEndpoint = errors.New("discovery: bad discovery endpoint")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Number of retries discovery will attempt before giving up and erroring out.
0000000000000000000000000000000000000000;;		nRetries             = uint(math.MaxUint32)
0000000000000000000000000000000000000000;;		maxExpoentialRetries = uint(8)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JoinCluster will connect to the discovery service at the given url, and
0000000000000000000000000000000000000000;;	// register the server represented by the given id and config to the cluster
0000000000000000000000000000000000000000;;	func JoinCluster(durl, dproxyurl string, id types.ID, config string) (string, error) {
0000000000000000000000000000000000000000;;		d, err := newDiscovery(durl, dproxyurl, id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.joinCluster(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCluster will connect to the discovery service at the given url and
0000000000000000000000000000000000000000;;	// retrieve a string describing the cluster
0000000000000000000000000000000000000000;;	func GetCluster(durl, dproxyurl string) (string, error) {
0000000000000000000000000000000000000000;;		d, err := newDiscovery(durl, dproxyurl, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.getCluster()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type discovery struct {
0000000000000000000000000000000000000000;;		cluster string
0000000000000000000000000000000000000000;;		id      types.ID
0000000000000000000000000000000000000000;;		c       client.KeysAPI
0000000000000000000000000000000000000000;;		retries uint
0000000000000000000000000000000000000000;;		url     *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock clockwork.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newProxyFunc builds a proxy function from the given string, which should
0000000000000000000000000000000000000000;;	// represent a URL that can be used as a proxy. It performs basic
0000000000000000000000000000000000000000;;	// sanitization of the URL and returns any error encountered.
0000000000000000000000000000000000000000;;	func newProxyFunc(proxy string) (func(*http.Request) (*url.URL, error), error) {
0000000000000000000000000000000000000000;;		if proxy == "" {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do a small amount of URL sanitization to help the user
0000000000000000000000000000000000000000;;		// Derived from net/http.ProxyFromEnvironment
0000000000000000000000000000000000000000;;		proxyURL, err := url.Parse(proxy)
0000000000000000000000000000000000000000;;		if err != nil || !strings.HasPrefix(proxyURL.Scheme, "http") {
0000000000000000000000000000000000000000;;			// proxy was bogus. Try prepending "http://" to it and
0000000000000000000000000000000000000000;;			// see if that parses correctly. If not, we ignore the
0000000000000000000000000000000000000000;;			// error and complain about the original one
0000000000000000000000000000000000000000;;			var err2 error
0000000000000000000000000000000000000000;;			proxyURL, err2 = url.Parse("http://" + proxy)
0000000000000000000000000000000000000000;;			if err2 == nil {
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid proxy address %q: %v", proxy, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("using proxy %q", proxyURL.String())
0000000000000000000000000000000000000000;;		return http.ProxyURL(proxyURL), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDiscovery(durl, dproxyurl string, id types.ID) (*discovery, error) {
0000000000000000000000000000000000000000;;		u, err := url.Parse(durl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token := u.Path
0000000000000000000000000000000000000000;;		u.Path = ""
0000000000000000000000000000000000000000;;		pf, err := newProxyFunc(dproxyurl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: add ResponseHeaderTimeout back when watch on discovery service writes header early
0000000000000000000000000000000000000000;;		tr, err := transport.NewTransport(transport.TLSInfo{}, 30*time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tr.Proxy = pf
0000000000000000000000000000000000000000;;		cfg := client.Config{
0000000000000000000000000000000000000000;;			Transport: tr,
0000000000000000000000000000000000000000;;			Endpoints: []string{u.String()},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, err := client.New(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dc := client.NewKeysAPIWithPrefix(c, "")
0000000000000000000000000000000000000000;;		return &discovery{
0000000000000000000000000000000000000000;;			cluster: token,
0000000000000000000000000000000000000000;;			c:       dc,
0000000000000000000000000000000000000000;;			id:      id,
0000000000000000000000000000000000000000;;			url:     u,
0000000000000000000000000000000000000000;;			clock:   clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) joinCluster(config string) (string, error) {
0000000000000000000000000000000000000000;;		// fast path: if the cluster is full, return the error
0000000000000000000000000000000000000000;;		// do not need to register to the cluster in this case.
0000000000000000000000000000000000000000;;		if _, _, _, err := d.checkCluster(); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := d.createSelf(config); err != nil {
0000000000000000000000000000000000000000;;			// Fails, even on a timeout, if createSelf times out.
0000000000000000000000000000000000000000;;			// TODO(barakmich): Retrying the same node might want to succeed here
0000000000000000000000000000000000000000;;			// (ie, createSelf should be idempotent for discovery).
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes, size, index, err := d.checkCluster()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		all, err := d.waitNodes(nodes, size, index)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodesToCluster(all, size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) getCluster() (string, error) {
0000000000000000000000000000000000000000;;		nodes, size, index, err := d.checkCluster()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == ErrFullCluster {
0000000000000000000000000000000000000000;;				return nodesToCluster(nodes, size)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		all, err := d.waitNodes(nodes, size, index)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodesToCluster(all, size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) createSelf(contents string) error {
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), client.DefaultRequestTimeout)
0000000000000000000000000000000000000000;;		resp, err := d.c.Create(ctx, d.selfKey(), contents)
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if eerr, ok := err.(client.Error); ok && eerr.Code == client.ErrorCodeNodeExist {
0000000000000000000000000000000000000000;;				return ErrDuplicateID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure self appears on the server we connected to
0000000000000000000000000000000000000000;;		w := d.c.Watcher(d.selfKey(), &client.WatcherOptions{AfterIndex: resp.Node.CreatedIndex - 1})
0000000000000000000000000000000000000000;;		_, err = w.Next(context.Background())
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) checkCluster() ([]*client.Node, int, uint64, error) {
0000000000000000000000000000000000000000;;		configKey := path.Join("/", d.cluster, "_config")
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), client.DefaultRequestTimeout)
0000000000000000000000000000000000000000;;		// find cluster size
0000000000000000000000000000000000000000;;		resp, err := d.c.Get(ctx, path.Join(configKey, "size"), nil)
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if eerr, ok := err.(*client.Error); ok && eerr.Code == client.ErrorCodeKeyNotFound {
0000000000000000000000000000000000000000;;				return nil, 0, 0, ErrSizeNotFound
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == client.ErrInvalidJSON {
0000000000000000000000000000000000000000;;				return nil, 0, 0, ErrBadDiscoveryEndpoint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ce, ok := err.(*client.ClusterError); ok {
0000000000000000000000000000000000000000;;				plog.Error(ce.Detail())
0000000000000000000000000000000000000000;;				return d.checkClusterRetry()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		size, err := strconv.Atoi(resp.Node.Value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, 0, ErrBadSizeKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel = context.WithTimeout(context.Background(), client.DefaultRequestTimeout)
0000000000000000000000000000000000000000;;		resp, err = d.c.Get(ctx, d.cluster, nil)
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if ce, ok := err.(*client.ClusterError); ok {
0000000000000000000000000000000000000000;;				plog.Error(ce.Detail())
0000000000000000000000000000000000000000;;				return d.checkClusterRetry()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var nodes []*client.Node
0000000000000000000000000000000000000000;;		// append non-config keys to nodes
0000000000000000000000000000000000000000;;		for _, n := range resp.Node.Nodes {
0000000000000000000000000000000000000000;;			if !(path.Base(n.Key) == path.Base(configKey)) {
0000000000000000000000000000000000000000;;				nodes = append(nodes, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		snodes := sortableNodes{nodes}
0000000000000000000000000000000000000000;;		sort.Sort(snodes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find self position
0000000000000000000000000000000000000000;;		for i := range nodes {
0000000000000000000000000000000000000000;;			if path.Base(nodes[i].Key) == path.Base(d.selfKey()) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i >= size-1 {
0000000000000000000000000000000000000000;;				return nodes[:size], size, resp.Index, ErrFullCluster
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes, size, resp.Index, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) logAndBackoffForRetry(step string) {
0000000000000000000000000000000000000000;;		d.retries++
0000000000000000000000000000000000000000;;		// logAndBackoffForRetry stops exponential backoff when the retries are more than maxExpoentialRetries and is set to a constant backoff afterward.
0000000000000000000000000000000000000000;;		retries := d.retries
0000000000000000000000000000000000000000;;		if retries > maxExpoentialRetries {
0000000000000000000000000000000000000000;;			retries = maxExpoentialRetries
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		retryTimeInSecond := time.Duration(0x1<<retries) * time.Second
0000000000000000000000000000000000000000;;		plog.Infof("%s: error connecting to %s, retrying in %s", step, d.url, retryTimeInSecond)
0000000000000000000000000000000000000000;;		d.clock.Sleep(retryTimeInSecond)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) checkClusterRetry() ([]*client.Node, int, uint64, error) {
0000000000000000000000000000000000000000;;		if d.retries < nRetries {
0000000000000000000000000000000000000000;;			d.logAndBackoffForRetry("cluster status check")
0000000000000000000000000000000000000000;;			return d.checkCluster()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, 0, 0, ErrTooManyRetries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) waitNodesRetry() ([]*client.Node, error) {
0000000000000000000000000000000000000000;;		if d.retries < nRetries {
0000000000000000000000000000000000000000;;			d.logAndBackoffForRetry("waiting for other nodes")
0000000000000000000000000000000000000000;;			nodes, n, index, err := d.checkCluster()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return d.waitNodes(nodes, n, index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, ErrTooManyRetries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) waitNodes(nodes []*client.Node, size int, index uint64) ([]*client.Node, error) {
0000000000000000000000000000000000000000;;		if len(nodes) > size {
0000000000000000000000000000000000000000;;			nodes = nodes[:size]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// watch from the next index
0000000000000000000000000000000000000000;;		w := d.c.Watcher(d.cluster, &client.WatcherOptions{AfterIndex: index, Recursive: true})
0000000000000000000000000000000000000000;;		all := make([]*client.Node, len(nodes))
0000000000000000000000000000000000000000;;		copy(all, nodes)
0000000000000000000000000000000000000000;;		for _, n := range all {
0000000000000000000000000000000000000000;;			if path.Base(n.Key) == path.Base(d.selfKey()) {
0000000000000000000000000000000000000000;;				plog.Noticef("found self %s in the cluster", path.Base(d.selfKey()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				plog.Noticef("found peer %s in the cluster", path.Base(n.Key))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for others
0000000000000000000000000000000000000000;;		for len(all) < size {
0000000000000000000000000000000000000000;;			plog.Noticef("found %d peer(s), waiting for %d more", len(all), size-len(all))
0000000000000000000000000000000000000000;;			resp, err := w.Next(context.Background())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if ce, ok := err.(*client.ClusterError); ok {
0000000000000000000000000000000000000000;;					plog.Error(ce.Detail())
0000000000000000000000000000000000000000;;					return d.waitNodesRetry()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Noticef("found peer %s in the cluster", path.Base(resp.Node.Key))
0000000000000000000000000000000000000000;;			all = append(all, resp.Node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Noticef("found %d needed peer(s)", len(all))
0000000000000000000000000000000000000000;;		return all, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discovery) selfKey() string {
0000000000000000000000000000000000000000;;		return path.Join("/", d.cluster, d.id.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nodesToCluster(ns []*client.Node, size int) (string, error) {
0000000000000000000000000000000000000000;;		s := make([]string, len(ns))
0000000000000000000000000000000000000000;;		for i, n := range ns {
0000000000000000000000000000000000000000;;			s[i] = n.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		us := strings.Join(s, ",")
0000000000000000000000000000000000000000;;		m, err := types.NewURLsMap(us)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return us, ErrInvalidURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Len() != size {
0000000000000000000000000000000000000000;;			return us, ErrDuplicateName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return us, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortableNodes struct{ Nodes []*client.Node }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ns sortableNodes) Len() int { return len(ns.Nodes) }
0000000000000000000000000000000000000000;;	func (ns sortableNodes) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return ns.Nodes[i].CreatedIndex < ns.Nodes[j].CreatedIndex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (ns sortableNodes) Swap(i, j int) { ns.Nodes[i], ns.Nodes[j] = ns.Nodes[j], ns.Nodes[i] }
