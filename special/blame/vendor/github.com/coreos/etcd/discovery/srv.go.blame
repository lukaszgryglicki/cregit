0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/discovery/srv.go[Godeps/_workspace/src/github.com/coreos/etcd/discovery/srv.go][vendor/github.com/coreos/etcd/discovery/srv.go];	
0000000000000000000000000000000000000000;;	package discovery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// indirection for testing
0000000000000000000000000000000000000000;;		lookupSRV      = net.LookupSRV
0000000000000000000000000000000000000000;;		resolveTCPAddr = net.ResolveTCPAddr
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SRVGetCluster gets the cluster information via DNS discovery.
0000000000000000000000000000000000000000;;	// TODO(barakmich): Currently ignores priority and weight (as they don't make as much sense for a bootstrap)
0000000000000000000000000000000000000000;;	// Also doesn't do any lookups for the token (though it could)
0000000000000000000000000000000000000000;;	// Also sees each entry as a separate instance.
0000000000000000000000000000000000000000;;	func SRVGetCluster(name, dns string, defaultToken string, apurls types.URLs) (string, string, error) {
0000000000000000000000000000000000000000;;		tempName := int(0)
0000000000000000000000000000000000000000;;		tcp2ap := make(map[string]url.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First, resolve the apurls
0000000000000000000000000000000000000000;;		for _, url := range apurls {
0000000000000000000000000000000000000000;;			tcpAddr, err := resolveTCPAddr("tcp", url.Host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				plog.Errorf("couldn't resolve host %s during SRV discovery", url.Host)
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tcp2ap[tcpAddr.String()] = url
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stringParts := []string{}
0000000000000000000000000000000000000000;;		updateNodeMap := func(service, scheme string) error {
0000000000000000000000000000000000000000;;			_, addrs, err := lookupSRV(service, "tcp", dns)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, srv := range addrs {
0000000000000000000000000000000000000000;;				port := fmt.Sprintf("%d", srv.Port)
0000000000000000000000000000000000000000;;				host := net.JoinHostPort(srv.Target, port)
0000000000000000000000000000000000000000;;				tcpAddr, err := resolveTCPAddr("tcp", host)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					plog.Warningf("couldn't resolve host %s during SRV discovery", host)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n := ""
0000000000000000000000000000000000000000;;				url, ok := tcp2ap[tcpAddr.String()]
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					n = name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n == "" {
0000000000000000000000000000000000000000;;					n = fmt.Sprintf("%d", tempName)
0000000000000000000000000000000000000000;;					tempName++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// SRV records have a trailing dot but URL shouldn't.
0000000000000000000000000000000000000000;;				shortHost := strings.TrimSuffix(srv.Target, ".")
0000000000000000000000000000000000000000;;				urlHost := net.JoinHostPort(shortHost, port)
0000000000000000000000000000000000000000;;				stringParts = append(stringParts, fmt.Sprintf("%s=%s://%s", n, scheme, urlHost))
0000000000000000000000000000000000000000;;				plog.Noticef("got bootstrap from DNS for %s at %s://%s", service, scheme, urlHost)
0000000000000000000000000000000000000000;;				if ok && url.Scheme != scheme {
0000000000000000000000000000000000000000;;					plog.Errorf("bootstrap at %s from DNS for %s has scheme mismatch with expected peer %s", scheme+"://"+urlHost, service, url.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failCount := 0
0000000000000000000000000000000000000000;;		err := updateNodeMap("etcd-server-ssl", "https")
0000000000000000000000000000000000000000;;		srvErr := make([]string, 2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			srvErr[0] = fmt.Sprintf("error querying DNS SRV records for _etcd-server-ssl %s", err)
0000000000000000000000000000000000000000;;			failCount++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = updateNodeMap("etcd-server", "http")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			srvErr[1] = fmt.Sprintf("error querying DNS SRV records for _etcd-server %s", err)
0000000000000000000000000000000000000000;;			failCount++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if failCount == 2 {
0000000000000000000000000000000000000000;;			plog.Warningf(srvErr[0])
0000000000000000000000000000000000000000;;			plog.Warningf(srvErr[1])
0000000000000000000000000000000000000000;;			plog.Errorf("SRV discovery failed: too many errors querying DNS SRV records")
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(stringParts, ","), defaultToken, nil
0000000000000000000000000000000000000000;;	}
