0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/raft/progress.go[Godeps/_workspace/src/github.com/coreos/etcd/raft/progress.go][vendor/github.com/coreos/etcd/raft/progress.go];	
0000000000000000000000000000000000000000;;	package raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProgressStateProbe ProgressStateType = iota
0000000000000000000000000000000000000000;;		ProgressStateReplicate
0000000000000000000000000000000000000000;;		ProgressStateSnapshot
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ProgressStateType uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var prstmap = [...]string{
0000000000000000000000000000000000000000;;		"ProgressStateProbe",
0000000000000000000000000000000000000000;;		"ProgressStateReplicate",
0000000000000000000000000000000000000000;;		"ProgressStateSnapshot",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (st ProgressStateType) String() string { return prstmap[uint64(st)] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Progress represents a followerâ€™s progress in the view of the leader. Leader maintains
0000000000000000000000000000000000000000;;	// progresses of all followers, and sends entries to the follower based on its progress.
0000000000000000000000000000000000000000;;	type Progress struct {
0000000000000000000000000000000000000000;;		Match, Next uint64
0000000000000000000000000000000000000000;;		// State defines how the leader should interact with the follower.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When in ProgressStateProbe, leader sends at most one replication message
0000000000000000000000000000000000000000;;		// per heartbeat interval. It also probes actual progress of the follower.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When in ProgressStateReplicate, leader optimistically increases next
0000000000000000000000000000000000000000;;		// to the latest entry sent after sending replication message. This is
0000000000000000000000000000000000000000;;		// an optimized state for fast replicating log entries to the follower.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When in ProgressStateSnapshot, leader should have sent out snapshot
0000000000000000000000000000000000000000;;		// before and stops sending any replication message.
0000000000000000000000000000000000000000;;		State ProgressStateType
0000000000000000000000000000000000000000;;		// Paused is used in ProgressStateProbe.
0000000000000000000000000000000000000000;;		// When Paused is true, raft should pause sending replication message to this peer.
0000000000000000000000000000000000000000;;		Paused bool
0000000000000000000000000000000000000000;;		// PendingSnapshot is used in ProgressStateSnapshot.
0000000000000000000000000000000000000000;;		// If there is a pending snapshot, the pendingSnapshot will be set to the
0000000000000000000000000000000000000000;;		// index of the snapshot. If pendingSnapshot is set, the replication process of
0000000000000000000000000000000000000000;;		// this Progress will be paused. raft will not resend snapshot until the pending one
0000000000000000000000000000000000000000;;		// is reported to be failed.
0000000000000000000000000000000000000000;;		PendingSnapshot uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RecentActive is true if the progress is recently active. Receiving any messages
0000000000000000000000000000000000000000;;		// from the corresponding follower indicates the progress is active.
0000000000000000000000000000000000000000;;		// RecentActive can be reset to false after an election timeout.
0000000000000000000000000000000000000000;;		RecentActive bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// inflights is a sliding window for the inflight messages.
0000000000000000000000000000000000000000;;		// Each inflight message contains one or more log entries.
0000000000000000000000000000000000000000;;		// The max number of entries per message is defined in raft config as MaxSizePerMsg.
0000000000000000000000000000000000000000;;		// Thus inflight effectively limits both the number of inflight messages
0000000000000000000000000000000000000000;;		// and the bandwidth each Progress can use.
0000000000000000000000000000000000000000;;		// When inflights is full, no more message should be sent.
0000000000000000000000000000000000000000;;		// When a leader sends out a message, the index of the last
0000000000000000000000000000000000000000;;		// entry should be added to inflights. The index MUST be added
0000000000000000000000000000000000000000;;		// into inflights in order.
0000000000000000000000000000000000000000;;		// When a leader receives a reply, the previous inflights should
0000000000000000000000000000000000000000;;		// be freed by calling inflights.freeTo with the index of the last
0000000000000000000000000000000000000000;;		// received entry.
0000000000000000000000000000000000000000;;		ins *inflights
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) resetState(state ProgressStateType) {
0000000000000000000000000000000000000000;;		pr.Paused = false
0000000000000000000000000000000000000000;;		pr.PendingSnapshot = 0
0000000000000000000000000000000000000000;;		pr.State = state
0000000000000000000000000000000000000000;;		pr.ins.reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) becomeProbe() {
0000000000000000000000000000000000000000;;		// If the original state is ProgressStateSnapshot, progress knows that
0000000000000000000000000000000000000000;;		// the pending snapshot has been sent to this peer successfully, then
0000000000000000000000000000000000000000;;		// probes from pendingSnapshot + 1.
0000000000000000000000000000000000000000;;		if pr.State == ProgressStateSnapshot {
0000000000000000000000000000000000000000;;			pendingSnapshot := pr.PendingSnapshot
0000000000000000000000000000000000000000;;			pr.resetState(ProgressStateProbe)
0000000000000000000000000000000000000000;;			pr.Next = max(pr.Match+1, pendingSnapshot+1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pr.resetState(ProgressStateProbe)
0000000000000000000000000000000000000000;;			pr.Next = pr.Match + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) becomeReplicate() {
0000000000000000000000000000000000000000;;		pr.resetState(ProgressStateReplicate)
0000000000000000000000000000000000000000;;		pr.Next = pr.Match + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) becomeSnapshot(snapshoti uint64) {
0000000000000000000000000000000000000000;;		pr.resetState(ProgressStateSnapshot)
0000000000000000000000000000000000000000;;		pr.PendingSnapshot = snapshoti
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeUpdate returns false if the given n index comes from an outdated message.
0000000000000000000000000000000000000000;;	// Otherwise it updates the progress and returns true.
0000000000000000000000000000000000000000;;	func (pr *Progress) maybeUpdate(n uint64) bool {
0000000000000000000000000000000000000000;;		var updated bool
0000000000000000000000000000000000000000;;		if pr.Match < n {
0000000000000000000000000000000000000000;;			pr.Match = n
0000000000000000000000000000000000000000;;			updated = true
0000000000000000000000000000000000000000;;			pr.resume()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pr.Next < n+1 {
0000000000000000000000000000000000000000;;			pr.Next = n + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return updated
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) optimisticUpdate(n uint64) { pr.Next = n + 1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeDecrTo returns false if the given to index comes from an out of order message.
0000000000000000000000000000000000000000;;	// Otherwise it decreases the progress next index to min(rejected, last) and returns true.
0000000000000000000000000000000000000000;;	func (pr *Progress) maybeDecrTo(rejected, last uint64) bool {
0000000000000000000000000000000000000000;;		if pr.State == ProgressStateReplicate {
0000000000000000000000000000000000000000;;			// the rejection must be stale if the progress has matched and "rejected"
0000000000000000000000000000000000000000;;			// is smaller than "match".
0000000000000000000000000000000000000000;;			if rejected <= pr.Match {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// directly decrease next to match + 1
0000000000000000000000000000000000000000;;			pr.Next = pr.Match + 1
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the rejection must be stale if "rejected" does not match next - 1
0000000000000000000000000000000000000000;;		if pr.Next-1 != rejected {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pr.Next = min(rejected, last+1); pr.Next < 1 {
0000000000000000000000000000000000000000;;			pr.Next = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pr.resume()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) pause()  { pr.Paused = true }
0000000000000000000000000000000000000000;;	func (pr *Progress) resume() { pr.Paused = false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPaused returns whether sending log entries to this node has been
0000000000000000000000000000000000000000;;	// paused. A node may be paused because it has rejected recent
0000000000000000000000000000000000000000;;	// MsgApps, is currently waiting for a snapshot, or has reached the
0000000000000000000000000000000000000000;;	// MaxInflightMsgs limit.
0000000000000000000000000000000000000000;;	func (pr *Progress) IsPaused() bool {
0000000000000000000000000000000000000000;;		switch pr.State {
0000000000000000000000000000000000000000;;		case ProgressStateProbe:
0000000000000000000000000000000000000000;;			return pr.Paused
0000000000000000000000000000000000000000;;		case ProgressStateReplicate:
0000000000000000000000000000000000000000;;			return pr.ins.full()
0000000000000000000000000000000000000000;;		case ProgressStateSnapshot:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unexpected state")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) snapshotFailure() { pr.PendingSnapshot = 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// needSnapshotAbort returns true if snapshot progress's Match
0000000000000000000000000000000000000000;;	// is equal or higher than the pendingSnapshot.
0000000000000000000000000000000000000000;;	func (pr *Progress) needSnapshotAbort() bool {
0000000000000000000000000000000000000000;;		return pr.State == ProgressStateSnapshot && pr.Match >= pr.PendingSnapshot
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pr *Progress) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("next = %d, match = %d, state = %s, waiting = %v, pendingSnapshot = %d", pr.Next, pr.Match, pr.State, pr.IsPaused(), pr.PendingSnapshot)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type inflights struct {
0000000000000000000000000000000000000000;;		// the starting index in the buffer
0000000000000000000000000000000000000000;;		start int
0000000000000000000000000000000000000000;;		// number of inflights in the buffer
0000000000000000000000000000000000000000;;		count int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the size of the buffer
0000000000000000000000000000000000000000;;		size int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// buffer contains the index of the last entry
0000000000000000000000000000000000000000;;		// inside one message.
0000000000000000000000000000000000000000;;		buffer []uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInflights(size int) *inflights {
0000000000000000000000000000000000000000;;		return &inflights{
0000000000000000000000000000000000000000;;			size: size,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// add adds an inflight into inflights
0000000000000000000000000000000000000000;;	func (in *inflights) add(inflight uint64) {
0000000000000000000000000000000000000000;;		if in.full() {
0000000000000000000000000000000000000000;;			panic("cannot add into a full inflights")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		next := in.start + in.count
0000000000000000000000000000000000000000;;		size := in.size
0000000000000000000000000000000000000000;;		if next >= size {
0000000000000000000000000000000000000000;;			next -= size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if next >= len(in.buffer) {
0000000000000000000000000000000000000000;;			in.growBuf()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		in.buffer[next] = inflight
0000000000000000000000000000000000000000;;		in.count++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// grow the inflight buffer by doubling up to inflights.size. We grow on demand
0000000000000000000000000000000000000000;;	// instead of preallocating to inflights.size to handle systems which have
0000000000000000000000000000000000000000;;	// thousands of Raft groups per process.
0000000000000000000000000000000000000000;;	func (in *inflights) growBuf() {
0000000000000000000000000000000000000000;;		newSize := len(in.buffer) * 2
0000000000000000000000000000000000000000;;		if newSize == 0 {
0000000000000000000000000000000000000000;;			newSize = 1
0000000000000000000000000000000000000000;;		} else if newSize > in.size {
0000000000000000000000000000000000000000;;			newSize = in.size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newBuffer := make([]uint64, newSize)
0000000000000000000000000000000000000000;;		copy(newBuffer, in.buffer)
0000000000000000000000000000000000000000;;		in.buffer = newBuffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// freeTo frees the inflights smaller or equal to the given `to` flight.
0000000000000000000000000000000000000000;;	func (in *inflights) freeTo(to uint64) {
0000000000000000000000000000000000000000;;		if in.count == 0 || to < in.buffer[in.start] {
0000000000000000000000000000000000000000;;			// out of the left side of the window
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i, idx := 0, in.start
0000000000000000000000000000000000000000;;		for i = 0; i < in.count; i++ {
0000000000000000000000000000000000000000;;			if to < in.buffer[idx] { // found the first large inflight
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// increase index and maybe rotate
0000000000000000000000000000000000000000;;			size := in.size
0000000000000000000000000000000000000000;;			if idx++; idx >= size {
0000000000000000000000000000000000000000;;				idx -= size
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// free i inflights and set new start index
0000000000000000000000000000000000000000;;		in.count -= i
0000000000000000000000000000000000000000;;		in.start = idx
0000000000000000000000000000000000000000;;		if in.count == 0 {
0000000000000000000000000000000000000000;;			// inflights is empty, reset the start index so that we don't grow the
0000000000000000000000000000000000000000;;			// buffer unnecessarily.
0000000000000000000000000000000000000000;;			in.start = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (in *inflights) freeFirstOne() { in.freeTo(in.buffer[in.start]) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// full returns true if the inflights is full.
0000000000000000000000000000000000000000;;	func (in *inflights) full() bool {
0000000000000000000000000000000000000000;;		return in.count == in.size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resets frees all inflights.
0000000000000000000000000000000000000000;;	func (in *inflights) reset() {
0000000000000000000000000000000000000000;;		in.count = 0
0000000000000000000000000000000000000000;;		in.start = 0
0000000000000000000000000000000000000000;;	}
