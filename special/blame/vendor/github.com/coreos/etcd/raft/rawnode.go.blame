0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/raft/rawnode.go[Godeps/_workspace/src/github.com/coreos/etcd/raft/rawnode.go][vendor/github.com/coreos/etcd/raft/rawnode.go];	
0000000000000000000000000000000000000000;;	package raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrStepLocalMsg is returned when try to step a local raft message
0000000000000000000000000000000000000000;;	var ErrStepLocalMsg = errors.New("raft: cannot step raft local message")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrStepPeerNotFound is returned when try to step a response message
0000000000000000000000000000000000000000;;	// but there is no peer found in raft.prs for that node.
0000000000000000000000000000000000000000;;	var ErrStepPeerNotFound = errors.New("raft: cannot step as peer not found")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RawNode is a thread-unsafe Node.
0000000000000000000000000000000000000000;;	// The methods of this struct correspond to the methods of Node and are described
0000000000000000000000000000000000000000;;	// more fully there.
0000000000000000000000000000000000000000;;	type RawNode struct {
0000000000000000000000000000000000000000;;		raft       *raft
0000000000000000000000000000000000000000;;		prevSoftSt *SoftState
0000000000000000000000000000000000000000;;		prevHardSt pb.HardState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rn *RawNode) newReady() Ready {
0000000000000000000000000000000000000000;;		return newReady(rn.raft, rn.prevSoftSt, rn.prevHardSt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rn *RawNode) commitReady(rd Ready) {
0000000000000000000000000000000000000000;;		if rd.SoftState != nil {
0000000000000000000000000000000000000000;;			rn.prevSoftSt = rd.SoftState
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsEmptyHardState(rd.HardState) {
0000000000000000000000000000000000000000;;			rn.prevHardSt = rd.HardState
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rn.prevHardSt.Commit != 0 {
0000000000000000000000000000000000000000;;			// In most cases, prevHardSt and rd.HardState will be the same
0000000000000000000000000000000000000000;;			// because when there are new entries to apply we just sent a
0000000000000000000000000000000000000000;;			// HardState with an updated Commit value. However, on initial
0000000000000000000000000000000000000000;;			// startup the two are different because we don't send a HardState
0000000000000000000000000000000000000000;;			// until something changes, but we do send any un-applied but
0000000000000000000000000000000000000000;;			// committed entries (and previously-committed entries may be
0000000000000000000000000000000000000000;;			// incorporated into the snapshot, even if rd.CommittedEntries is
0000000000000000000000000000000000000000;;			// empty). Therefore we mark all committed entries as applied
0000000000000000000000000000000000000000;;			// whether they were included in rd.HardState or not.
0000000000000000000000000000000000000000;;			rn.raft.raftLog.appliedTo(rn.prevHardSt.Commit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rd.Entries) > 0 {
0000000000000000000000000000000000000000;;			e := rd.Entries[len(rd.Entries)-1]
0000000000000000000000000000000000000000;;			rn.raft.raftLog.stableTo(e.Index, e.Term)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !IsEmptySnap(rd.Snapshot) {
0000000000000000000000000000000000000000;;			rn.raft.raftLog.stableSnapTo(rd.Snapshot.Metadata.Index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rd.ReadStates) != 0 {
0000000000000000000000000000000000000000;;			rn.raft.readStates = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRawNode returns a new RawNode given configuration and a list of raft peers.
0000000000000000000000000000000000000000;;	func NewRawNode(config *Config, peers []Peer) (*RawNode, error) {
0000000000000000000000000000000000000000;;		if config.ID == 0 {
0000000000000000000000000000000000000000;;			panic("config.ID must not be zero")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := newRaft(config)
0000000000000000000000000000000000000000;;		rn := &RawNode{
0000000000000000000000000000000000000000;;			raft: r,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lastIndex, err := config.Storage.LastIndex()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the log is empty, this is a new RawNode (like StartNode); otherwise it's
0000000000000000000000000000000000000000;;		// restoring an existing RawNode (like RestartNode).
0000000000000000000000000000000000000000;;		// TODO(bdarnell): rethink RawNode initialization and whether the application needs
0000000000000000000000000000000000000000;;		// to be able to tell us when it expects the RawNode to exist.
0000000000000000000000000000000000000000;;		if lastIndex == 0 {
0000000000000000000000000000000000000000;;			r.becomeFollower(1, None)
0000000000000000000000000000000000000000;;			ents := make([]pb.Entry, len(peers))
0000000000000000000000000000000000000000;;			for i, peer := range peers {
0000000000000000000000000000000000000000;;				cc := pb.ConfChange{Type: pb.ConfChangeAddNode, NodeID: peer.ID, Context: peer.Context}
0000000000000000000000000000000000000000;;				data, err := cc.Marshal()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic("unexpected marshal error")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ents[i] = pb.Entry{Type: pb.EntryConfChange, Term: 1, Index: uint64(i + 1), Data: data}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.raftLog.append(ents...)
0000000000000000000000000000000000000000;;			r.raftLog.committed = uint64(len(ents))
0000000000000000000000000000000000000000;;			for _, peer := range peers {
0000000000000000000000000000000000000000;;				r.addNode(peer.ID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the initial hard and soft states after performing all initialization.
0000000000000000000000000000000000000000;;		rn.prevSoftSt = r.softState()
0000000000000000000000000000000000000000;;		if lastIndex == 0 {
0000000000000000000000000000000000000000;;			rn.prevHardSt = emptyState
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rn.prevHardSt = r.hardState()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tick advances the internal logical clock by a single tick.
0000000000000000000000000000000000000000;;	func (rn *RawNode) Tick() {
0000000000000000000000000000000000000000;;		rn.raft.tick()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TickQuiesced advances the internal logical clock by a single tick without
0000000000000000000000000000000000000000;;	// performing any other state machine processing. It allows the caller to avoid
0000000000000000000000000000000000000000;;	// periodic heartbeats and elections when all of the peers in a Raft group are
0000000000000000000000000000000000000000;;	// known to be at the same state. Expected usage is to periodically invoke Tick
0000000000000000000000000000000000000000;;	// or TickQuiesced depending on whether the group is "active" or "quiesced".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// WARNING: Be very careful about using this method as it subverts the Raft
0000000000000000000000000000000000000000;;	// state machine. You should probably be using Tick instead.
0000000000000000000000000000000000000000;;	func (rn *RawNode) TickQuiesced() {
0000000000000000000000000000000000000000;;		rn.raft.electionElapsed++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Campaign causes this RawNode to transition to candidate state.
0000000000000000000000000000000000000000;;	func (rn *RawNode) Campaign() error {
0000000000000000000000000000000000000000;;		return rn.raft.Step(pb.Message{
0000000000000000000000000000000000000000;;			Type: pb.MsgHup,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Propose proposes data be appended to the raft log.
0000000000000000000000000000000000000000;;	func (rn *RawNode) Propose(data []byte) error {
0000000000000000000000000000000000000000;;		return rn.raft.Step(pb.Message{
0000000000000000000000000000000000000000;;			Type: pb.MsgProp,
0000000000000000000000000000000000000000;;			From: rn.raft.id,
0000000000000000000000000000000000000000;;			Entries: []pb.Entry{
0000000000000000000000000000000000000000;;				{Data: data},
0000000000000000000000000000000000000000;;			}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProposeConfChange proposes a config change.
0000000000000000000000000000000000000000;;	func (rn *RawNode) ProposeConfChange(cc pb.ConfChange) error {
0000000000000000000000000000000000000000;;		data, err := cc.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rn.raft.Step(pb.Message{
0000000000000000000000000000000000000000;;			Type: pb.MsgProp,
0000000000000000000000000000000000000000;;			Entries: []pb.Entry{
0000000000000000000000000000000000000000;;				{Type: pb.EntryConfChange, Data: data},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ApplyConfChange applies a config change to the local node.
0000000000000000000000000000000000000000;;	func (rn *RawNode) ApplyConfChange(cc pb.ConfChange) *pb.ConfState {
0000000000000000000000000000000000000000;;		if cc.NodeID == None {
0000000000000000000000000000000000000000;;			rn.raft.resetPendingConf()
0000000000000000000000000000000000000000;;			return &pb.ConfState{Nodes: rn.raft.nodes()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch cc.Type {
0000000000000000000000000000000000000000;;		case pb.ConfChangeAddNode:
0000000000000000000000000000000000000000;;			rn.raft.addNode(cc.NodeID)
0000000000000000000000000000000000000000;;		case pb.ConfChangeRemoveNode:
0000000000000000000000000000000000000000;;			rn.raft.removeNode(cc.NodeID)
0000000000000000000000000000000000000000;;		case pb.ConfChangeUpdateNode:
0000000000000000000000000000000000000000;;			rn.raft.resetPendingConf()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unexpected conf type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &pb.ConfState{Nodes: rn.raft.nodes()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Step advances the state machine using the given message.
0000000000000000000000000000000000000000;;	func (rn *RawNode) Step(m pb.Message) error {
0000000000000000000000000000000000000000;;		// ignore unexpected local messages receiving over network
0000000000000000000000000000000000000000;;		if IsLocalMsg(m.Type) {
0000000000000000000000000000000000000000;;			return ErrStepLocalMsg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := rn.raft.prs[m.From]; ok || !IsResponseMsg(m.Type) {
0000000000000000000000000000000000000000;;			return rn.raft.Step(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrStepPeerNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ready returns the current point-in-time state of this RawNode.
0000000000000000000000000000000000000000;;	func (rn *RawNode) Ready() Ready {
0000000000000000000000000000000000000000;;		rd := rn.newReady()
0000000000000000000000000000000000000000;;		rn.raft.msgs = nil
0000000000000000000000000000000000000000;;		return rd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasReady called when RawNode user need to check if any Ready pending.
0000000000000000000000000000000000000000;;	// Checking logic in this method should be consistent with Ready.containsUpdates().
0000000000000000000000000000000000000000;;	func (rn *RawNode) HasReady() bool {
0000000000000000000000000000000000000000;;		r := rn.raft
0000000000000000000000000000000000000000;;		if !r.softState().equal(rn.prevSoftSt) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hardSt := r.hardState(); !IsEmptyHardState(hardSt) && !isHardStateEqual(hardSt, rn.prevHardSt) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.raftLog.unstable.snapshot != nil && !IsEmptySnap(*r.raftLog.unstable.snapshot) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.msgs) > 0 || len(r.raftLog.unstableEntries()) > 0 || r.raftLog.hasNextEnts() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.readStates) != 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Advance notifies the RawNode that the application has applied and saved progress in the
0000000000000000000000000000000000000000;;	// last Ready results.
0000000000000000000000000000000000000000;;	func (rn *RawNode) Advance(rd Ready) {
0000000000000000000000000000000000000000;;		rn.commitReady(rd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns the current status of the given group.
0000000000000000000000000000000000000000;;	func (rn *RawNode) Status() *Status {
0000000000000000000000000000000000000000;;		status := getStatus(rn.raft)
0000000000000000000000000000000000000000;;		return &status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReportUnreachable reports the given node is not reachable for the last send.
0000000000000000000000000000000000000000;;	func (rn *RawNode) ReportUnreachable(id uint64) {
0000000000000000000000000000000000000000;;		_ = rn.raft.Step(pb.Message{Type: pb.MsgUnreachable, From: id})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReportSnapshot reports the status of the sent snapshot.
0000000000000000000000000000000000000000;;	func (rn *RawNode) ReportSnapshot(id uint64, status SnapshotStatus) {
0000000000000000000000000000000000000000;;		rej := status == SnapshotFailure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ = rn.raft.Step(pb.Message{Type: pb.MsgSnapStatus, From: id, Reject: rej})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransferLeader tries to transfer leadership to the given transferee.
0000000000000000000000000000000000000000;;	func (rn *RawNode) TransferLeader(transferee uint64) {
0000000000000000000000000000000000000000;;		_ = rn.raft.Step(pb.Message{Type: pb.MsgTransferLeader, From: transferee})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadIndex requests a read state. The read state will be set in ready.
0000000000000000000000000000000000000000;;	// Read State has a read index. Once the application advances further than the read
0000000000000000000000000000000000000000;;	// index, any linearizable read requests issued before the read request can be
0000000000000000000000000000000000000000;;	// processed safely. The read state will have the same rctx attached.
0000000000000000000000000000000000000000;;	func (rn *RawNode) ReadIndex(rctx []byte) {
0000000000000000000000000000000000000000;;		_ = rn.raft.Step(pb.Message{Type: pb.MsgReadIndex, Entries: []pb.Entry{{Data: rctx}}})
0000000000000000000000000000000000000000;;	}
