0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/raft/raft.go[Godeps/_workspace/src/github.com/coreos/etcd/raft/raft.go][vendor/github.com/coreos/etcd/raft/raft.go];	
0000000000000000000000000000000000000000;;	package raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// None is a placeholder node ID used when there is no leader.
0000000000000000000000000000000000000000;;	const None uint64 = 0
0000000000000000000000000000000000000000;;	const noLimit = math.MaxUint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Possible values for StateType.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		StateFollower StateType = iota
0000000000000000000000000000000000000000;;		StateCandidate
0000000000000000000000000000000000000000;;		StateLeader
0000000000000000000000000000000000000000;;		StatePreCandidate
0000000000000000000000000000000000000000;;		numStates
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReadOnlyOption int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ReadOnlySafe guarantees the linearizability of the read only request by
0000000000000000000000000000000000000000;;		// communicating with the quorum. It is the default and suggested option.
0000000000000000000000000000000000000000;;		ReadOnlySafe ReadOnlyOption = iota
0000000000000000000000000000000000000000;;		// ReadOnlyLeaseBased ensures linearizability of the read only request by
0000000000000000000000000000000000000000;;		// relying on the leader lease. It can be affected by clock drift.
0000000000000000000000000000000000000000;;		// If the clock drift is unbounded, leader might keep the lease longer than it
0000000000000000000000000000000000000000;;		// should (clock can move backward/pause without any bound). ReadIndex is not safe
0000000000000000000000000000000000000000;;		// in that case.
0000000000000000000000000000000000000000;;		ReadOnlyLeaseBased
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Possible values for CampaignType
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// campaignPreElection represents the first phase of a normal election when
0000000000000000000000000000000000000000;;		// Config.PreVote is true.
0000000000000000000000000000000000000000;;		campaignPreElection CampaignType = "CampaignPreElection"
0000000000000000000000000000000000000000;;		// campaignElection represents a normal (time-based) election (the second phase
0000000000000000000000000000000000000000;;		// of the election when Config.PreVote is true).
0000000000000000000000000000000000000000;;		campaignElection CampaignType = "CampaignElection"
0000000000000000000000000000000000000000;;		// campaignTransfer represents the type of leader transfer
0000000000000000000000000000000000000000;;		campaignTransfer CampaignType = "CampaignTransfer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lockedRand is a small wrapper around rand.Rand to provide
0000000000000000000000000000000000000000;;	// synchronization. Only the methods needed by the code are exposed
0000000000000000000000000000000000000000;;	// (e.g. Intn).
0000000000000000000000000000000000000000;;	type lockedRand struct {
0000000000000000000000000000000000000000;;		mu   sync.Mutex
0000000000000000000000000000000000000000;;		rand *rand.Rand
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *lockedRand) Intn(n int) int {
0000000000000000000000000000000000000000;;		r.mu.Lock()
0000000000000000000000000000000000000000;;		v := r.rand.Intn(n)
0000000000000000000000000000000000000000;;		r.mu.Unlock()
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var globalRand = &lockedRand{
0000000000000000000000000000000000000000;;		rand: rand.New(rand.NewSource(time.Now().UnixNano())),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CampaignType represents the type of campaigning
0000000000000000000000000000000000000000;;	// the reason we use the type of string instead of uint64
0000000000000000000000000000000000000000;;	// is because it's simpler to compare and fill in raft entries
0000000000000000000000000000000000000000;;	type CampaignType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StateType represents the role of a node in a cluster.
0000000000000000000000000000000000000000;;	type StateType uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var stmap = [...]string{
0000000000000000000000000000000000000000;;		"StateFollower",
0000000000000000000000000000000000000000;;		"StateCandidate",
0000000000000000000000000000000000000000;;		"StateLeader",
0000000000000000000000000000000000000000;;		"StatePreCandidate",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (st StateType) String() string {
0000000000000000000000000000000000000000;;		return stmap[uint64(st)]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config contains the parameters to start a raft.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// ID is the identity of the local raft. ID cannot be 0.
0000000000000000000000000000000000000000;;		ID uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// peers contains the IDs of all nodes (including self) in the raft cluster. It
0000000000000000000000000000000000000000;;		// should only be set when starting a new raft cluster. Restarting raft from
0000000000000000000000000000000000000000;;		// previous configuration will panic if peers is set. peer is private and only
0000000000000000000000000000000000000000;;		// used for testing right now.
0000000000000000000000000000000000000000;;		peers []uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ElectionTick is the number of Node.Tick invocations that must pass between
0000000000000000000000000000000000000000;;		// elections. That is, if a follower does not receive any message from the
0000000000000000000000000000000000000000;;		// leader of current term before ElectionTick has elapsed, it will become
0000000000000000000000000000000000000000;;		// candidate and start an election. ElectionTick must be greater than
0000000000000000000000000000000000000000;;		// HeartbeatTick. We suggest ElectionTick = 10 * HeartbeatTick to avoid
0000000000000000000000000000000000000000;;		// unnecessary leader switching.
0000000000000000000000000000000000000000;;		ElectionTick int
0000000000000000000000000000000000000000;;		// HeartbeatTick is the number of Node.Tick invocations that must pass between
0000000000000000000000000000000000000000;;		// heartbeats. That is, a leader sends heartbeat messages to maintain its
0000000000000000000000000000000000000000;;		// leadership every HeartbeatTick ticks.
0000000000000000000000000000000000000000;;		HeartbeatTick int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Storage is the storage for raft. raft generates entries and states to be
0000000000000000000000000000000000000000;;		// stored in storage. raft reads the persisted entries and states out of
0000000000000000000000000000000000000000;;		// Storage when it needs. raft reads out the previous state and configuration
0000000000000000000000000000000000000000;;		// out of storage when restarting.
0000000000000000000000000000000000000000;;		Storage Storage
0000000000000000000000000000000000000000;;		// Applied is the last applied index. It should only be set when restarting
0000000000000000000000000000000000000000;;		// raft. raft will not return entries to the application smaller or equal to
0000000000000000000000000000000000000000;;		// Applied. If Applied is unset when restarting, raft might return previous
0000000000000000000000000000000000000000;;		// applied entries. This is a very application dependent configuration.
0000000000000000000000000000000000000000;;		Applied uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxSizePerMsg limits the max size of each append message. Smaller value
0000000000000000000000000000000000000000;;		// lowers the raft recovery cost(initial probing and message lost during normal
0000000000000000000000000000000000000000;;		// operation). On the other side, it might affect the throughput during normal
0000000000000000000000000000000000000000;;		// replication. Note: math.MaxUint64 for unlimited, 0 for at most one entry per
0000000000000000000000000000000000000000;;		// message.
0000000000000000000000000000000000000000;;		MaxSizePerMsg uint64
0000000000000000000000000000000000000000;;		// MaxInflightMsgs limits the max number of in-flight append messages during
0000000000000000000000000000000000000000;;		// optimistic replication phase. The application transportation layer usually
0000000000000000000000000000000000000000;;		// has its own sending buffer over TCP/UDP. Setting MaxInflightMsgs to avoid
0000000000000000000000000000000000000000;;		// overflowing that sending buffer. TODO (xiangli): feedback to application to
0000000000000000000000000000000000000000;;		// limit the proposal rate?
0000000000000000000000000000000000000000;;		MaxInflightMsgs int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CheckQuorum specifies if the leader should check quorum activity. Leader
0000000000000000000000000000000000000000;;		// steps down when quorum is not active for an electionTimeout.
0000000000000000000000000000000000000000;;		CheckQuorum bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PreVote enables the Pre-Vote algorithm described in raft thesis section
0000000000000000000000000000000000000000;;		// 9.6. This prevents disruption when a node that has been partitioned away
0000000000000000000000000000000000000000;;		// rejoins the cluster.
0000000000000000000000000000000000000000;;		PreVote bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadOnlyOption specifies how the read only request is processed.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// ReadOnlySafe guarantees the linearizability of the read only request by
0000000000000000000000000000000000000000;;		// communicating with the quorum. It is the default and suggested option.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// ReadOnlyLeaseBased ensures linearizability of the read only request by
0000000000000000000000000000000000000000;;		// relying on the leader lease. It can be affected by clock drift.
0000000000000000000000000000000000000000;;		// If the clock drift is unbounded, leader might keep the lease longer than it
0000000000000000000000000000000000000000;;		// should (clock can move backward/pause without any bound). ReadIndex is not safe
0000000000000000000000000000000000000000;;		// in that case.
0000000000000000000000000000000000000000;;		ReadOnlyOption ReadOnlyOption
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Logger is the logger used for raft log. For multinode which can host
0000000000000000000000000000000000000000;;		// multiple raft group, each raft group can have its own logger
0000000000000000000000000000000000000000;;		Logger Logger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Config) validate() error {
0000000000000000000000000000000000000000;;		if c.ID == None {
0000000000000000000000000000000000000000;;			return errors.New("cannot use none as id")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HeartbeatTick <= 0 {
0000000000000000000000000000000000000000;;			return errors.New("heartbeat tick must be greater than 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.ElectionTick <= c.HeartbeatTick {
0000000000000000000000000000000000000000;;			return errors.New("election tick must be greater than heartbeat tick")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Storage == nil {
0000000000000000000000000000000000000000;;			return errors.New("storage cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.MaxInflightMsgs <= 0 {
0000000000000000000000000000000000000000;;			return errors.New("max inflight messages must be greater than 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Logger == nil {
0000000000000000000000000000000000000000;;			c.Logger = raftLogger
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type raft struct {
0000000000000000000000000000000000000000;;		id uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Term uint64
0000000000000000000000000000000000000000;;		Vote uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readStates []ReadState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the log
0000000000000000000000000000000000000000;;		raftLog *raftLog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxInflight int
0000000000000000000000000000000000000000;;		maxMsgSize  uint64
0000000000000000000000000000000000000000;;		prs         map[uint64]*Progress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state StateType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		votes map[uint64]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgs []pb.Message
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the leader id
0000000000000000000000000000000000000000;;		lead uint64
0000000000000000000000000000000000000000;;		// leadTransferee is id of the leader transfer target when its value is not zero.
0000000000000000000000000000000000000000;;		// Follow the procedure defined in raft thesis 3.10.
0000000000000000000000000000000000000000;;		leadTransferee uint64
0000000000000000000000000000000000000000;;		// New configuration is ignored if there exists unapplied configuration.
0000000000000000000000000000000000000000;;		pendingConf bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readOnly *readOnly
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// number of ticks since it reached last electionTimeout when it is leader
0000000000000000000000000000000000000000;;		// or candidate.
0000000000000000000000000000000000000000;;		// number of ticks since it reached last electionTimeout or received a
0000000000000000000000000000000000000000;;		// valid message from current leader when it is a follower.
0000000000000000000000000000000000000000;;		electionElapsed int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// number of ticks since it reached last heartbeatTimeout.
0000000000000000000000000000000000000000;;		// only leader keeps heartbeatElapsed.
0000000000000000000000000000000000000000;;		heartbeatElapsed int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkQuorum bool
0000000000000000000000000000000000000000;;		preVote     bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		heartbeatTimeout int
0000000000000000000000000000000000000000;;		electionTimeout  int
0000000000000000000000000000000000000000;;		// randomizedElectionTimeout is a random number between
0000000000000000000000000000000000000000;;		// [electiontimeout, 2 * electiontimeout - 1]. It gets reset
0000000000000000000000000000000000000000;;		// when raft changes its state to follower or candidate.
0000000000000000000000000000000000000000;;		randomizedElectionTimeout int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tick func()
0000000000000000000000000000000000000000;;		step stepFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger Logger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRaft(c *Config) *raft {
0000000000000000000000000000000000000000;;		if err := c.validate(); err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		raftlog := newLog(c.Storage, c.Logger)
0000000000000000000000000000000000000000;;		hs, cs, err := c.Storage.InitialState()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		peers := c.peers
0000000000000000000000000000000000000000;;		if len(cs.Nodes) > 0 {
0000000000000000000000000000000000000000;;			if len(peers) > 0 {
0000000000000000000000000000000000000000;;				// TODO(bdarnell): the peers argument is always nil except in
0000000000000000000000000000000000000000;;				// tests; the argument should be removed and these tests should be
0000000000000000000000000000000000000000;;				// updated to specify their nodes through a snapshot.
0000000000000000000000000000000000000000;;				panic("cannot specify both newRaft(peers) and ConfState.Nodes)")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			peers = cs.Nodes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := &raft{
0000000000000000000000000000000000000000;;			id:               c.ID,
0000000000000000000000000000000000000000;;			lead:             None,
0000000000000000000000000000000000000000;;			raftLog:          raftlog,
0000000000000000000000000000000000000000;;			maxMsgSize:       c.MaxSizePerMsg,
0000000000000000000000000000000000000000;;			maxInflight:      c.MaxInflightMsgs,
0000000000000000000000000000000000000000;;			prs:              make(map[uint64]*Progress),
0000000000000000000000000000000000000000;;			electionTimeout:  c.ElectionTick,
0000000000000000000000000000000000000000;;			heartbeatTimeout: c.HeartbeatTick,
0000000000000000000000000000000000000000;;			logger:           c.Logger,
0000000000000000000000000000000000000000;;			checkQuorum:      c.CheckQuorum,
0000000000000000000000000000000000000000;;			preVote:          c.PreVote,
0000000000000000000000000000000000000000;;			readOnly:         newReadOnly(c.ReadOnlyOption),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range peers {
0000000000000000000000000000000000000000;;			r.prs[p] = &Progress{Next: 1, ins: newInflights(r.maxInflight)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isHardStateEqual(hs, emptyState) {
0000000000000000000000000000000000000000;;			r.loadState(hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Applied > 0 {
0000000000000000000000000000000000000000;;			raftlog.appliedTo(c.Applied)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.becomeFollower(r.Term, None)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var nodesStrs []string
0000000000000000000000000000000000000000;;		for _, n := range r.nodes() {
0000000000000000000000000000000000000000;;			nodesStrs = append(nodesStrs, fmt.Sprintf("%x", n))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.logger.Infof("newRaft %x [peers: [%s], term: %d, commit: %d, applied: %d, lastindex: %d, lastterm: %d]",
0000000000000000000000000000000000000000;;			r.id, strings.Join(nodesStrs, ","), r.Term, r.raftLog.committed, r.raftLog.applied, r.raftLog.lastIndex(), r.raftLog.lastTerm())
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) hasLeader() bool { return r.lead != None }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) softState() *SoftState { return &SoftState{Lead: r.lead, RaftState: r.state} }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) hardState() pb.HardState {
0000000000000000000000000000000000000000;;		return pb.HardState{
0000000000000000000000000000000000000000;;			Term:   r.Term,
0000000000000000000000000000000000000000;;			Vote:   r.Vote,
0000000000000000000000000000000000000000;;			Commit: r.raftLog.committed,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) quorum() int { return len(r.prs)/2 + 1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) nodes() []uint64 {
0000000000000000000000000000000000000000;;		nodes := make([]uint64, 0, len(r.prs))
0000000000000000000000000000000000000000;;		for id := range r.prs {
0000000000000000000000000000000000000000;;			nodes = append(nodes, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(uint64Slice(nodes))
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// send persists state to stable storage and then sends to its mailbox.
0000000000000000000000000000000000000000;;	func (r *raft) send(m pb.Message) {
0000000000000000000000000000000000000000;;		m.From = r.id
0000000000000000000000000000000000000000;;		if m.Type == pb.MsgVote || m.Type == pb.MsgPreVote {
0000000000000000000000000000000000000000;;			if m.Term == 0 {
0000000000000000000000000000000000000000;;				// PreVote RPCs are sent at a term other than our actual term, so the code
0000000000000000000000000000000000000000;;				// that sends these messages is responsible for setting the term.
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("term should be set when sending %s", m.Type))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if m.Term != 0 {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("term should not be set when sending %s (was %d)", m.Type, m.Term))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// do not attach term to MsgProp, MsgReadIndex
0000000000000000000000000000000000000000;;			// proposals are a way to forward to the leader and
0000000000000000000000000000000000000000;;			// should be treated as local message.
0000000000000000000000000000000000000000;;			// MsgReadIndex is also forwarded to leader.
0000000000000000000000000000000000000000;;			if m.Type != pb.MsgProp && m.Type != pb.MsgReadIndex {
0000000000000000000000000000000000000000;;				m.Term = r.Term
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.msgs = append(r.msgs, m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendAppend sends RPC, with entries to the given peer.
0000000000000000000000000000000000000000;;	func (r *raft) sendAppend(to uint64) {
0000000000000000000000000000000000000000;;		pr := r.prs[to]
0000000000000000000000000000000000000000;;		if pr.IsPaused() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := pb.Message{}
0000000000000000000000000000000000000000;;		m.To = to
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		term, errt := r.raftLog.term(pr.Next - 1)
0000000000000000000000000000000000000000;;		ents, erre := r.raftLog.entries(pr.Next, r.maxMsgSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if errt != nil || erre != nil { // send snapshot if we failed to get term or entries
0000000000000000000000000000000000000000;;			if !pr.RecentActive {
0000000000000000000000000000000000000000;;				r.logger.Debugf("ignore sending snapshot to %x since it is not recently active", to)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			m.Type = pb.MsgSnap
0000000000000000000000000000000000000000;;			snapshot, err := r.raftLog.snapshot()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == ErrSnapshotTemporarilyUnavailable {
0000000000000000000000000000000000000000;;					r.logger.Debugf("%x failed to send snapshot to %x because snapshot is temporarily unavailable", r.id, to)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if IsEmptySnap(snapshot) {
0000000000000000000000000000000000000000;;				panic("need non-empty snapshot")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.Snapshot = snapshot
0000000000000000000000000000000000000000;;			sindex, sterm := snapshot.Metadata.Index, snapshot.Metadata.Term
0000000000000000000000000000000000000000;;			r.logger.Debugf("%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]",
0000000000000000000000000000000000000000;;				r.id, r.raftLog.firstIndex(), r.raftLog.committed, sindex, sterm, to, pr)
0000000000000000000000000000000000000000;;			pr.becomeSnapshot(sindex)
0000000000000000000000000000000000000000;;			r.logger.Debugf("%x paused sending replication messages to %x [%s]", r.id, to, pr)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m.Type = pb.MsgApp
0000000000000000000000000000000000000000;;			m.Index = pr.Next - 1
0000000000000000000000000000000000000000;;			m.LogTerm = term
0000000000000000000000000000000000000000;;			m.Entries = ents
0000000000000000000000000000000000000000;;			m.Commit = r.raftLog.committed
0000000000000000000000000000000000000000;;			if n := len(m.Entries); n != 0 {
0000000000000000000000000000000000000000;;				switch pr.State {
0000000000000000000000000000000000000000;;				// optimistically increase the next when in ProgressStateReplicate
0000000000000000000000000000000000000000;;				case ProgressStateReplicate:
0000000000000000000000000000000000000000;;					last := m.Entries[n-1].Index
0000000000000000000000000000000000000000;;					pr.optimisticUpdate(last)
0000000000000000000000000000000000000000;;					pr.ins.add(last)
0000000000000000000000000000000000000000;;				case ProgressStateProbe:
0000000000000000000000000000000000000000;;					pr.pause()
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					r.logger.Panicf("%x is sending append in unhandled state %s", r.id, pr.State)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.send(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendHeartbeat sends an empty MsgApp
0000000000000000000000000000000000000000;;	func (r *raft) sendHeartbeat(to uint64, ctx []byte) {
0000000000000000000000000000000000000000;;		// Attach the commit as min(to.matched, r.committed).
0000000000000000000000000000000000000000;;		// When the leader sends out heartbeat message,
0000000000000000000000000000000000000000;;		// the receiver(follower) might not be matched with the leader
0000000000000000000000000000000000000000;;		// or it might not have all the committed entries.
0000000000000000000000000000000000000000;;		// The leader MUST NOT forward the follower's commit to
0000000000000000000000000000000000000000;;		// an unmatched index.
0000000000000000000000000000000000000000;;		commit := min(r.prs[to].Match, r.raftLog.committed)
0000000000000000000000000000000000000000;;		m := pb.Message{
0000000000000000000000000000000000000000;;			To:      to,
0000000000000000000000000000000000000000;;			Type:    pb.MsgHeartbeat,
0000000000000000000000000000000000000000;;			Commit:  commit,
0000000000000000000000000000000000000000;;			Context: ctx,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.send(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bcastAppend sends RPC, with entries to all peers that are not up-to-date
0000000000000000000000000000000000000000;;	// according to the progress recorded in r.prs.
0000000000000000000000000000000000000000;;	func (r *raft) bcastAppend() {
0000000000000000000000000000000000000000;;		for id := range r.prs {
0000000000000000000000000000000000000000;;			if id == r.id {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.sendAppend(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bcastHeartbeat sends RPC, without entries to all the peers.
0000000000000000000000000000000000000000;;	func (r *raft) bcastHeartbeat() {
0000000000000000000000000000000000000000;;		lastCtx := r.readOnly.lastPendingRequestCtx()
0000000000000000000000000000000000000000;;		if len(lastCtx) == 0 {
0000000000000000000000000000000000000000;;			r.bcastHeartbeatWithCtx(nil)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.bcastHeartbeatWithCtx([]byte(lastCtx))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) bcastHeartbeatWithCtx(ctx []byte) {
0000000000000000000000000000000000000000;;		for id := range r.prs {
0000000000000000000000000000000000000000;;			if id == r.id {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.sendHeartbeat(id, ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeCommit attempts to advance the commit index. Returns true if
0000000000000000000000000000000000000000;;	// the commit index changed (in which case the caller should call
0000000000000000000000000000000000000000;;	// r.bcastAppend).
0000000000000000000000000000000000000000;;	func (r *raft) maybeCommit() bool {
0000000000000000000000000000000000000000;;		// TODO(bmizerany): optimize.. Currently naive
0000000000000000000000000000000000000000;;		mis := make(uint64Slice, 0, len(r.prs))
0000000000000000000000000000000000000000;;		for id := range r.prs {
0000000000000000000000000000000000000000;;			mis = append(mis, r.prs[id].Match)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(mis))
0000000000000000000000000000000000000000;;		mci := mis[r.quorum()-1]
0000000000000000000000000000000000000000;;		return r.raftLog.maybeCommit(mci, r.Term)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) reset(term uint64) {
0000000000000000000000000000000000000000;;		if r.Term != term {
0000000000000000000000000000000000000000;;			r.Term = term
0000000000000000000000000000000000000000;;			r.Vote = None
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.lead = None
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.electionElapsed = 0
0000000000000000000000000000000000000000;;		r.heartbeatElapsed = 0
0000000000000000000000000000000000000000;;		r.resetRandomizedElectionTimeout()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.abortLeaderTransfer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.votes = make(map[uint64]bool)
0000000000000000000000000000000000000000;;		for id := range r.prs {
0000000000000000000000000000000000000000;;			r.prs[id] = &Progress{Next: r.raftLog.lastIndex() + 1, ins: newInflights(r.maxInflight)}
0000000000000000000000000000000000000000;;			if id == r.id {
0000000000000000000000000000000000000000;;				r.prs[id].Match = r.raftLog.lastIndex()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.pendingConf = false
0000000000000000000000000000000000000000;;		r.readOnly = newReadOnly(r.readOnly.option)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) appendEntry(es ...pb.Entry) {
0000000000000000000000000000000000000000;;		li := r.raftLog.lastIndex()
0000000000000000000000000000000000000000;;		for i := range es {
0000000000000000000000000000000000000000;;			es[i].Term = r.Term
0000000000000000000000000000000000000000;;			es[i].Index = li + 1 + uint64(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.raftLog.append(es...)
0000000000000000000000000000000000000000;;		r.prs[r.id].maybeUpdate(r.raftLog.lastIndex())
0000000000000000000000000000000000000000;;		// Regardless of maybeCommit's return, our caller will call bcastAppend.
0000000000000000000000000000000000000000;;		r.maybeCommit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tickElection is run by followers and candidates after r.electionTimeout.
0000000000000000000000000000000000000000;;	func (r *raft) tickElection() {
0000000000000000000000000000000000000000;;		r.electionElapsed++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.promotable() && r.pastElectionTimeout() {
0000000000000000000000000000000000000000;;			r.electionElapsed = 0
0000000000000000000000000000000000000000;;			r.Step(pb.Message{From: r.id, Type: pb.MsgHup})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tickHeartbeat is run by leaders to send a MsgBeat after r.heartbeatTimeout.
0000000000000000000000000000000000000000;;	func (r *raft) tickHeartbeat() {
0000000000000000000000000000000000000000;;		r.heartbeatElapsed++
0000000000000000000000000000000000000000;;		r.electionElapsed++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.electionElapsed >= r.electionTimeout {
0000000000000000000000000000000000000000;;			r.electionElapsed = 0
0000000000000000000000000000000000000000;;			if r.checkQuorum {
0000000000000000000000000000000000000000;;				r.Step(pb.Message{From: r.id, Type: pb.MsgCheckQuorum})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If current leader cannot transfer leadership in electionTimeout, it becomes leader again.
0000000000000000000000000000000000000000;;			if r.state == StateLeader && r.leadTransferee != None {
0000000000000000000000000000000000000000;;				r.abortLeaderTransfer()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.state != StateLeader {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.heartbeatElapsed >= r.heartbeatTimeout {
0000000000000000000000000000000000000000;;			r.heartbeatElapsed = 0
0000000000000000000000000000000000000000;;			r.Step(pb.Message{From: r.id, Type: pb.MsgBeat})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) becomeFollower(term uint64, lead uint64) {
0000000000000000000000000000000000000000;;		r.step = stepFollower
0000000000000000000000000000000000000000;;		r.reset(term)
0000000000000000000000000000000000000000;;		r.tick = r.tickElection
0000000000000000000000000000000000000000;;		r.lead = lead
0000000000000000000000000000000000000000;;		r.state = StateFollower
0000000000000000000000000000000000000000;;		r.logger.Infof("%x became follower at term %d", r.id, r.Term)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) becomeCandidate() {
0000000000000000000000000000000000000000;;		// TODO(xiangli) remove the panic when the raft implementation is stable
0000000000000000000000000000000000000000;;		if r.state == StateLeader {
0000000000000000000000000000000000000000;;			panic("invalid transition [leader -> candidate]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.step = stepCandidate
0000000000000000000000000000000000000000;;		r.reset(r.Term + 1)
0000000000000000000000000000000000000000;;		r.tick = r.tickElection
0000000000000000000000000000000000000000;;		r.Vote = r.id
0000000000000000000000000000000000000000;;		r.state = StateCandidate
0000000000000000000000000000000000000000;;		r.logger.Infof("%x became candidate at term %d", r.id, r.Term)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) becomePreCandidate() {
0000000000000000000000000000000000000000;;		// TODO(xiangli) remove the panic when the raft implementation is stable
0000000000000000000000000000000000000000;;		if r.state == StateLeader {
0000000000000000000000000000000000000000;;			panic("invalid transition [leader -> pre-candidate]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Becoming a pre-candidate changes our step functions and state,
0000000000000000000000000000000000000000;;		// but doesn't change anything else. In particular it does not increase
0000000000000000000000000000000000000000;;		// r.Term or change r.Vote.
0000000000000000000000000000000000000000;;		r.step = stepCandidate
0000000000000000000000000000000000000000;;		r.tick = r.tickElection
0000000000000000000000000000000000000000;;		r.state = StatePreCandidate
0000000000000000000000000000000000000000;;		r.logger.Infof("%x became pre-candidate at term %d", r.id, r.Term)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) becomeLeader() {
0000000000000000000000000000000000000000;;		// TODO(xiangli) remove the panic when the raft implementation is stable
0000000000000000000000000000000000000000;;		if r.state == StateFollower {
0000000000000000000000000000000000000000;;			panic("invalid transition [follower -> leader]")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.step = stepLeader
0000000000000000000000000000000000000000;;		r.reset(r.Term)
0000000000000000000000000000000000000000;;		r.tick = r.tickHeartbeat
0000000000000000000000000000000000000000;;		r.lead = r.id
0000000000000000000000000000000000000000;;		r.state = StateLeader
0000000000000000000000000000000000000000;;		ents, err := r.raftLog.entries(r.raftLog.committed+1, noLimit)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.logger.Panicf("unexpected error getting uncommitted entries (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nconf := numOfPendingConf(ents)
0000000000000000000000000000000000000000;;		if nconf > 1 {
0000000000000000000000000000000000000000;;			panic("unexpected multiple uncommitted config entry")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nconf == 1 {
0000000000000000000000000000000000000000;;			r.pendingConf = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.appendEntry(pb.Entry{Data: nil})
0000000000000000000000000000000000000000;;		r.logger.Infof("%x became leader at term %d", r.id, r.Term)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) campaign(t CampaignType) {
0000000000000000000000000000000000000000;;		var term uint64
0000000000000000000000000000000000000000;;		var voteMsg pb.MessageType
0000000000000000000000000000000000000000;;		if t == campaignPreElection {
0000000000000000000000000000000000000000;;			r.becomePreCandidate()
0000000000000000000000000000000000000000;;			voteMsg = pb.MsgPreVote
0000000000000000000000000000000000000000;;			// PreVote RPCs are sent for the next term before we've incremented r.Term.
0000000000000000000000000000000000000000;;			term = r.Term + 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.becomeCandidate()
0000000000000000000000000000000000000000;;			voteMsg = pb.MsgVote
0000000000000000000000000000000000000000;;			term = r.Term
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.quorum() == r.poll(r.id, voteRespMsgType(voteMsg), true) {
0000000000000000000000000000000000000000;;			// We won the election after voting for ourselves (which must mean that
0000000000000000000000000000000000000000;;			// this is a single-node cluster). Advance to the next state.
0000000000000000000000000000000000000000;;			if t == campaignPreElection {
0000000000000000000000000000000000000000;;				r.campaign(campaignElection)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.becomeLeader()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for id := range r.prs {
0000000000000000000000000000000000000000;;			if id == r.id {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.logger.Infof("%x [logterm: %d, index: %d] sent %s request to %x at term %d",
0000000000000000000000000000000000000000;;				r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), voteMsg, id, r.Term)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var ctx []byte
0000000000000000000000000000000000000000;;			if t == campaignTransfer {
0000000000000000000000000000000000000000;;				ctx = []byte(t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.send(pb.Message{Term: term, To: id, Type: voteMsg, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) poll(id uint64, t pb.MessageType, v bool) (granted int) {
0000000000000000000000000000000000000000;;		if v {
0000000000000000000000000000000000000000;;			r.logger.Infof("%x received %s from %x at term %d", r.id, t, id, r.Term)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.logger.Infof("%x received %s rejection from %x at term %d", r.id, t, id, r.Term)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := r.votes[id]; !ok {
0000000000000000000000000000000000000000;;			r.votes[id] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, vv := range r.votes {
0000000000000000000000000000000000000000;;			if vv {
0000000000000000000000000000000000000000;;				granted++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return granted
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) Step(m pb.Message) error {
0000000000000000000000000000000000000000;;		// Handle the message term, which may result in our stepping down to a follower.
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case m.Term == 0:
0000000000000000000000000000000000000000;;			// local message
0000000000000000000000000000000000000000;;		case m.Term > r.Term:
0000000000000000000000000000000000000000;;			lead := m.From
0000000000000000000000000000000000000000;;			if m.Type == pb.MsgVote || m.Type == pb.MsgPreVote {
0000000000000000000000000000000000000000;;				force := bytes.Equal(m.Context, []byte(campaignTransfer))
0000000000000000000000000000000000000000;;				inLease := r.checkQuorum && r.lead != None && r.electionElapsed < r.electionTimeout
0000000000000000000000000000000000000000;;				if !force && inLease {
0000000000000000000000000000000000000000;;					// If a server receives a RequestVote request within the minimum election timeout
0000000000000000000000000000000000000000;;					// of hearing from a current leader, it does not update its term or grant its vote
0000000000000000000000000000000000000000;;					r.logger.Infof("%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)",
0000000000000000000000000000000000000000;;						r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term, r.electionTimeout-r.electionElapsed)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lead = None
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case m.Type == pb.MsgPreVote:
0000000000000000000000000000000000000000;;				// Never change our term in response to a PreVote
0000000000000000000000000000000000000000;;			case m.Type == pb.MsgPreVoteResp && !m.Reject:
0000000000000000000000000000000000000000;;				// We send pre-vote requests with a term in our future. If the
0000000000000000000000000000000000000000;;				// pre-vote is granted, we will increment our term when we get a
0000000000000000000000000000000000000000;;				// quorum. If it is not, the term comes from the node that
0000000000000000000000000000000000000000;;				// rejected our vote so we should become a follower at the new
0000000000000000000000000000000000000000;;				// term.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				r.logger.Infof("%x [term: %d] received a %s message with higher term from %x [term: %d]",
0000000000000000000000000000000000000000;;					r.id, r.Term, m.Type, m.From, m.Term)
0000000000000000000000000000000000000000;;				r.becomeFollower(m.Term, lead)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case m.Term < r.Term:
0000000000000000000000000000000000000000;;			if r.checkQuorum && (m.Type == pb.MsgHeartbeat || m.Type == pb.MsgApp) {
0000000000000000000000000000000000000000;;				// We have received messages from a leader at a lower term. It is possible
0000000000000000000000000000000000000000;;				// that these messages were simply delayed in the network, but this could
0000000000000000000000000000000000000000;;				// also mean that this node has advanced its term number during a network
0000000000000000000000000000000000000000;;				// partition, and it is now unable to either win an election or to rejoin
0000000000000000000000000000000000000000;;				// the majority on the old term. If checkQuorum is false, this will be
0000000000000000000000000000000000000000;;				// handled by incrementing term numbers in response to MsgVote with a
0000000000000000000000000000000000000000;;				// higher term, but if checkQuorum is true we may not advance the term on
0000000000000000000000000000000000000000;;				// MsgVote and must generate other messages to advance the term. The net
0000000000000000000000000000000000000000;;				// result of these two features is to minimize the disruption caused by
0000000000000000000000000000000000000000;;				// nodes that have been removed from the cluster's configuration: a
0000000000000000000000000000000000000000;;				// removed node will send MsgVotes (or MsgPreVotes) which will be ignored,
0000000000000000000000000000000000000000;;				// but it will not receive MsgApp or MsgHeartbeat, so it will not create
0000000000000000000000000000000000000000;;				// disruptive term increases
0000000000000000000000000000000000000000;;				r.send(pb.Message{To: m.From, Type: pb.MsgAppResp})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// ignore other cases
0000000000000000000000000000000000000000;;				r.logger.Infof("%x [term: %d] ignored a %s message with lower term from %x [term: %d]",
0000000000000000000000000000000000000000;;					r.id, r.Term, m.Type, m.From, m.Term)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch m.Type {
0000000000000000000000000000000000000000;;		case pb.MsgHup:
0000000000000000000000000000000000000000;;			if r.state != StateLeader {
0000000000000000000000000000000000000000;;				ents, err := r.raftLog.slice(r.raftLog.applied+1, r.raftLog.committed+1, noLimit)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					r.logger.Panicf("unexpected error getting unapplied entries (%v)", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n := numOfPendingConf(ents); n != 0 && r.raftLog.committed > r.raftLog.applied {
0000000000000000000000000000000000000000;;					r.logger.Warningf("%x cannot campaign at term %d since there are still %d pending configuration changes to apply", r.id, r.Term, n)
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r.logger.Infof("%x is starting a new election at term %d", r.id, r.Term)
0000000000000000000000000000000000000000;;				if r.preVote {
0000000000000000000000000000000000000000;;					r.campaign(campaignPreElection)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					r.campaign(campaignElection)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.logger.Debugf("%x ignoring MsgHup because already leader", r.id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case pb.MsgVote, pb.MsgPreVote:
0000000000000000000000000000000000000000;;			// The m.Term > r.Term clause is for MsgPreVote. For MsgVote m.Term should
0000000000000000000000000000000000000000;;			// always equal r.Term.
0000000000000000000000000000000000000000;;			if (r.Vote == None || m.Term > r.Term || r.Vote == m.From) && r.raftLog.isUpToDate(m.Index, m.LogTerm) {
0000000000000000000000000000000000000000;;				r.logger.Infof("%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d",
0000000000000000000000000000000000000000;;					r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)
0000000000000000000000000000000000000000;;				r.send(pb.Message{To: m.From, Type: voteRespMsgType(m.Type)})
0000000000000000000000000000000000000000;;				if m.Type == pb.MsgVote {
0000000000000000000000000000000000000000;;					// Only record real votes.
0000000000000000000000000000000000000000;;					r.electionElapsed = 0
0000000000000000000000000000000000000000;;					r.Vote = m.From
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.logger.Infof("%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d",
0000000000000000000000000000000000000000;;					r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)
0000000000000000000000000000000000000000;;				r.send(pb.Message{To: m.From, Type: voteRespMsgType(m.Type), Reject: true})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			r.step(r, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stepFunc func(r *raft, m pb.Message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stepLeader(r *raft, m pb.Message) {
0000000000000000000000000000000000000000;;		// These message types do not require any progress for m.From.
0000000000000000000000000000000000000000;;		switch m.Type {
0000000000000000000000000000000000000000;;		case pb.MsgBeat:
0000000000000000000000000000000000000000;;			r.bcastHeartbeat()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case pb.MsgCheckQuorum:
0000000000000000000000000000000000000000;;			if !r.checkQuorumActive() {
0000000000000000000000000000000000000000;;				r.logger.Warningf("%x stepped down to follower since quorum is not active", r.id)
0000000000000000000000000000000000000000;;				r.becomeFollower(r.Term, None)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case pb.MsgProp:
0000000000000000000000000000000000000000;;			if len(m.Entries) == 0 {
0000000000000000000000000000000000000000;;				r.logger.Panicf("%x stepped empty MsgProp", r.id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := r.prs[r.id]; !ok {
0000000000000000000000000000000000000000;;				// If we are not currently a member of the range (i.e. this node
0000000000000000000000000000000000000000;;				// was removed from the configuration while serving as leader),
0000000000000000000000000000000000000000;;				// drop any new proposals.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.leadTransferee != None {
0000000000000000000000000000000000000000;;				r.logger.Debugf("%x [term %d] transfer leadership to %x is in progress; dropping proposal", r.id, r.Term, r.leadTransferee)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, e := range m.Entries {
0000000000000000000000000000000000000000;;				if e.Type == pb.EntryConfChange {
0000000000000000000000000000000000000000;;					if r.pendingConf {
0000000000000000000000000000000000000000;;						r.logger.Infof("propose conf %s ignored since pending unapplied configuration", e.String())
0000000000000000000000000000000000000000;;						m.Entries[i] = pb.Entry{Type: pb.EntryNormal}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					r.pendingConf = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.appendEntry(m.Entries...)
0000000000000000000000000000000000000000;;			r.bcastAppend()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case pb.MsgReadIndex:
0000000000000000000000000000000000000000;;			if r.quorum() > 1 {
0000000000000000000000000000000000000000;;				if r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(r.raftLog.committed)) != r.Term {
0000000000000000000000000000000000000000;;					// Reject read only request when this leader has not committed any log entry at its term.
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// thinking: use an interally defined context instead of the user given context.
0000000000000000000000000000000000000000;;				// We can express this in terms of the term and index instead of a user-supplied value.
0000000000000000000000000000000000000000;;				// This would allow multiple reads to piggyback on the same message.
0000000000000000000000000000000000000000;;				switch r.readOnly.option {
0000000000000000000000000000000000000000;;				case ReadOnlySafe:
0000000000000000000000000000000000000000;;					r.readOnly.addRequest(r.raftLog.committed, m)
0000000000000000000000000000000000000000;;					r.bcastHeartbeatWithCtx(m.Entries[0].Data)
0000000000000000000000000000000000000000;;				case ReadOnlyLeaseBased:
0000000000000000000000000000000000000000;;					var ri uint64
0000000000000000000000000000000000000000;;					if r.checkQuorum {
0000000000000000000000000000000000000000;;						ri = r.raftLog.committed
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if m.From == None || m.From == r.id { // from local member
0000000000000000000000000000000000000000;;						r.readStates = append(r.readStates, ReadState{Index: r.raftLog.committed, RequestCtx: m.Entries[0].Data})
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						r.send(pb.Message{To: m.From, Type: pb.MsgReadIndexResp, Index: ri, Entries: m.Entries})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.readStates = append(r.readStates, ReadState{Index: r.raftLog.committed, RequestCtx: m.Entries[0].Data})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All other message types require a progress for m.From (pr).
0000000000000000000000000000000000000000;;		pr, prOk := r.prs[m.From]
0000000000000000000000000000000000000000;;		if !prOk {
0000000000000000000000000000000000000000;;			r.logger.Debugf("%x no progress available for %x", r.id, m.From)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch m.Type {
0000000000000000000000000000000000000000;;		case pb.MsgAppResp:
0000000000000000000000000000000000000000;;			pr.RecentActive = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m.Reject {
0000000000000000000000000000000000000000;;				r.logger.Debugf("%x received msgApp rejection(lastindex: %d) from %x for index %d",
0000000000000000000000000000000000000000;;					r.id, m.RejectHint, m.From, m.Index)
0000000000000000000000000000000000000000;;				if pr.maybeDecrTo(m.Index, m.RejectHint) {
0000000000000000000000000000000000000000;;					r.logger.Debugf("%x decreased progress of %x to [%s]", r.id, m.From, pr)
0000000000000000000000000000000000000000;;					if pr.State == ProgressStateReplicate {
0000000000000000000000000000000000000000;;						pr.becomeProbe()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					r.sendAppend(m.From)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				oldPaused := pr.IsPaused()
0000000000000000000000000000000000000000;;				if pr.maybeUpdate(m.Index) {
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case pr.State == ProgressStateProbe:
0000000000000000000000000000000000000000;;						pr.becomeReplicate()
0000000000000000000000000000000000000000;;					case pr.State == ProgressStateSnapshot && pr.needSnapshotAbort():
0000000000000000000000000000000000000000;;						r.logger.Debugf("%x snapshot aborted, resumed sending replication messages to %x [%s]", r.id, m.From, pr)
0000000000000000000000000000000000000000;;						pr.becomeProbe()
0000000000000000000000000000000000000000;;					case pr.State == ProgressStateReplicate:
0000000000000000000000000000000000000000;;						pr.ins.freeTo(m.Index)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if r.maybeCommit() {
0000000000000000000000000000000000000000;;						r.bcastAppend()
0000000000000000000000000000000000000000;;					} else if oldPaused {
0000000000000000000000000000000000000000;;						// update() reset the wait state on this node. If we had delayed sending
0000000000000000000000000000000000000000;;						// an update before, send it now.
0000000000000000000000000000000000000000;;						r.sendAppend(m.From)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Transfer leadership is in progress.
0000000000000000000000000000000000000000;;					if m.From == r.leadTransferee && pr.Match == r.raftLog.lastIndex() {
0000000000000000000000000000000000000000;;						r.logger.Infof("%x sent MsgTimeoutNow to %x after received MsgAppResp", r.id, m.From)
0000000000000000000000000000000000000000;;						r.sendTimeoutNow(m.From)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case pb.MsgHeartbeatResp:
0000000000000000000000000000000000000000;;			pr.RecentActive = true
0000000000000000000000000000000000000000;;			pr.resume()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// free one slot for the full inflights window to allow progress.
0000000000000000000000000000000000000000;;			if pr.State == ProgressStateReplicate && pr.ins.full() {
0000000000000000000000000000000000000000;;				pr.ins.freeFirstOne()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pr.Match < r.raftLog.lastIndex() {
0000000000000000000000000000000000000000;;				r.sendAppend(m.From)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.readOnly.option != ReadOnlySafe || len(m.Context) == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ackCount := r.readOnly.recvAck(m)
0000000000000000000000000000000000000000;;			if ackCount < r.quorum() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rss := r.readOnly.advance(m)
0000000000000000000000000000000000000000;;			for _, rs := range rss {
0000000000000000000000000000000000000000;;				req := rs.req
0000000000000000000000000000000000000000;;				if req.From == None || req.From == r.id { // from local member
0000000000000000000000000000000000000000;;					r.readStates = append(r.readStates, ReadState{Index: rs.index, RequestCtx: req.Entries[0].Data})
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					r.send(pb.Message{To: req.From, Type: pb.MsgReadIndexResp, Index: rs.index, Entries: req.Entries})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case pb.MsgSnapStatus:
0000000000000000000000000000000000000000;;			if pr.State != ProgressStateSnapshot {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !m.Reject {
0000000000000000000000000000000000000000;;				pr.becomeProbe()
0000000000000000000000000000000000000000;;				r.logger.Debugf("%x snapshot succeeded, resumed sending replication messages to %x [%s]", r.id, m.From, pr)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pr.snapshotFailure()
0000000000000000000000000000000000000000;;				pr.becomeProbe()
0000000000000000000000000000000000000000;;				r.logger.Debugf("%x snapshot failed, resumed sending replication messages to %x [%s]", r.id, m.From, pr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If snapshot finish, wait for the msgAppResp from the remote node before sending
0000000000000000000000000000000000000000;;			// out the next msgApp.
0000000000000000000000000000000000000000;;			// If snapshot failure, wait for a heartbeat interval before next try
0000000000000000000000000000000000000000;;			pr.pause()
0000000000000000000000000000000000000000;;		case pb.MsgUnreachable:
0000000000000000000000000000000000000000;;			// During optimistic replication, if the remote becomes unreachable,
0000000000000000000000000000000000000000;;			// there is huge probability that a MsgApp is lost.
0000000000000000000000000000000000000000;;			if pr.State == ProgressStateReplicate {
0000000000000000000000000000000000000000;;				pr.becomeProbe()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.logger.Debugf("%x failed to send message to %x because it is unreachable [%s]", r.id, m.From, pr)
0000000000000000000000000000000000000000;;		case pb.MsgTransferLeader:
0000000000000000000000000000000000000000;;			leadTransferee := m.From
0000000000000000000000000000000000000000;;			lastLeadTransferee := r.leadTransferee
0000000000000000000000000000000000000000;;			if lastLeadTransferee != None {
0000000000000000000000000000000000000000;;				if lastLeadTransferee == leadTransferee {
0000000000000000000000000000000000000000;;					r.logger.Infof("%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x",
0000000000000000000000000000000000000000;;						r.id, r.Term, leadTransferee, leadTransferee)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.abortLeaderTransfer()
0000000000000000000000000000000000000000;;				r.logger.Infof("%x [term %d] abort previous transferring leadership to %x", r.id, r.Term, lastLeadTransferee)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if leadTransferee == r.id {
0000000000000000000000000000000000000000;;				r.logger.Debugf("%x is already leader. Ignored transferring leadership to self", r.id)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Transfer leadership to third party.
0000000000000000000000000000000000000000;;			r.logger.Infof("%x [term %d] starts to transfer leadership to %x", r.id, r.Term, leadTransferee)
0000000000000000000000000000000000000000;;			// Transfer leadership should be finished in one electionTimeout, so reset r.electionElapsed.
0000000000000000000000000000000000000000;;			r.electionElapsed = 0
0000000000000000000000000000000000000000;;			r.leadTransferee = leadTransferee
0000000000000000000000000000000000000000;;			if pr.Match == r.raftLog.lastIndex() {
0000000000000000000000000000000000000000;;				r.sendTimeoutNow(leadTransferee)
0000000000000000000000000000000000000000;;				r.logger.Infof("%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log", r.id, leadTransferee, leadTransferee)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.sendAppend(leadTransferee)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stepCandidate is shared by StateCandidate and StatePreCandidate; the difference is
0000000000000000000000000000000000000000;;	// whether they respond to MsgVoteResp or MsgPreVoteResp.
0000000000000000000000000000000000000000;;	func stepCandidate(r *raft, m pb.Message) {
0000000000000000000000000000000000000000;;		// Only handle vote responses corresponding to our candidacy (while in
0000000000000000000000000000000000000000;;		// StateCandidate, we may get stale MsgPreVoteResp messages in this term from
0000000000000000000000000000000000000000;;		// our pre-candidate state).
0000000000000000000000000000000000000000;;		var myVoteRespType pb.MessageType
0000000000000000000000000000000000000000;;		if r.state == StatePreCandidate {
0000000000000000000000000000000000000000;;			myVoteRespType = pb.MsgPreVoteResp
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			myVoteRespType = pb.MsgVoteResp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch m.Type {
0000000000000000000000000000000000000000;;		case pb.MsgProp:
0000000000000000000000000000000000000000;;			r.logger.Infof("%x no leader at term %d; dropping proposal", r.id, r.Term)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case pb.MsgApp:
0000000000000000000000000000000000000000;;			r.becomeFollower(r.Term, m.From)
0000000000000000000000000000000000000000;;			r.handleAppendEntries(m)
0000000000000000000000000000000000000000;;		case pb.MsgHeartbeat:
0000000000000000000000000000000000000000;;			r.becomeFollower(r.Term, m.From)
0000000000000000000000000000000000000000;;			r.handleHeartbeat(m)
0000000000000000000000000000000000000000;;		case pb.MsgSnap:
0000000000000000000000000000000000000000;;			r.becomeFollower(m.Term, m.From)
0000000000000000000000000000000000000000;;			r.handleSnapshot(m)
0000000000000000000000000000000000000000;;		case myVoteRespType:
0000000000000000000000000000000000000000;;			gr := r.poll(m.From, m.Type, !m.Reject)
0000000000000000000000000000000000000000;;			r.logger.Infof("%x [quorum:%d] has received %d %s votes and %d vote rejections", r.id, r.quorum(), gr, m.Type, len(r.votes)-gr)
0000000000000000000000000000000000000000;;			switch r.quorum() {
0000000000000000000000000000000000000000;;			case gr:
0000000000000000000000000000000000000000;;				if r.state == StatePreCandidate {
0000000000000000000000000000000000000000;;					r.campaign(campaignElection)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					r.becomeLeader()
0000000000000000000000000000000000000000;;					r.bcastAppend()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case len(r.votes) - gr:
0000000000000000000000000000000000000000;;				r.becomeFollower(r.Term, None)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case pb.MsgTimeoutNow:
0000000000000000000000000000000000000000;;			r.logger.Debugf("%x [term %d state %v] ignored MsgTimeoutNow from %x", r.id, r.Term, r.state, m.From)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stepFollower(r *raft, m pb.Message) {
0000000000000000000000000000000000000000;;		switch m.Type {
0000000000000000000000000000000000000000;;		case pb.MsgProp:
0000000000000000000000000000000000000000;;			if r.lead == None {
0000000000000000000000000000000000000000;;				r.logger.Infof("%x no leader at term %d; dropping proposal", r.id, r.Term)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.To = r.lead
0000000000000000000000000000000000000000;;			r.send(m)
0000000000000000000000000000000000000000;;		case pb.MsgApp:
0000000000000000000000000000000000000000;;			r.electionElapsed = 0
0000000000000000000000000000000000000000;;			r.lead = m.From
0000000000000000000000000000000000000000;;			r.handleAppendEntries(m)
0000000000000000000000000000000000000000;;		case pb.MsgHeartbeat:
0000000000000000000000000000000000000000;;			r.electionElapsed = 0
0000000000000000000000000000000000000000;;			r.lead = m.From
0000000000000000000000000000000000000000;;			r.handleHeartbeat(m)
0000000000000000000000000000000000000000;;		case pb.MsgSnap:
0000000000000000000000000000000000000000;;			r.electionElapsed = 0
0000000000000000000000000000000000000000;;			r.lead = m.From
0000000000000000000000000000000000000000;;			r.handleSnapshot(m)
0000000000000000000000000000000000000000;;		case pb.MsgTransferLeader:
0000000000000000000000000000000000000000;;			if r.lead == None {
0000000000000000000000000000000000000000;;				r.logger.Infof("%x no leader at term %d; dropping leader transfer msg", r.id, r.Term)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.To = r.lead
0000000000000000000000000000000000000000;;			r.send(m)
0000000000000000000000000000000000000000;;		case pb.MsgTimeoutNow:
0000000000000000000000000000000000000000;;			if r.promotable() {
0000000000000000000000000000000000000000;;				r.logger.Infof("%x [term %d] received MsgTimeoutNow from %x and starts an election to get leadership.", r.id, r.Term, m.From)
0000000000000000000000000000000000000000;;				// Leadership transfers never use pre-vote even if r.preVote is true; we
0000000000000000000000000000000000000000;;				// know we are not recovering from a partition so there is no need for the
0000000000000000000000000000000000000000;;				// extra round trip.
0000000000000000000000000000000000000000;;				r.campaign(campaignTransfer)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.logger.Infof("%x received MsgTimeoutNow from %x but is not promotable", r.id, m.From)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case pb.MsgReadIndex:
0000000000000000000000000000000000000000;;			if r.lead == None {
0000000000000000000000000000000000000000;;				r.logger.Infof("%x no leader at term %d; dropping index reading msg", r.id, r.Term)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.To = r.lead
0000000000000000000000000000000000000000;;			r.send(m)
0000000000000000000000000000000000000000;;		case pb.MsgReadIndexResp:
0000000000000000000000000000000000000000;;			if len(m.Entries) != 1 {
0000000000000000000000000000000000000000;;				r.logger.Errorf("%x invalid format of MsgReadIndexResp from %x, entries count: %d", r.id, m.From, len(m.Entries))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.readStates = append(r.readStates, ReadState{Index: m.Index, RequestCtx: m.Entries[0].Data})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) handleAppendEntries(m pb.Message) {
0000000000000000000000000000000000000000;;		if m.Index < r.raftLog.committed {
0000000000000000000000000000000000000000;;			r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: r.raftLog.committed})
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mlastIndex, ok := r.raftLog.maybeAppend(m.Index, m.LogTerm, m.Commit, m.Entries...); ok {
0000000000000000000000000000000000000000;;			r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: mlastIndex})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.logger.Debugf("%x [logterm: %d, index: %d] rejected msgApp [logterm: %d, index: %d] from %x",
0000000000000000000000000000000000000000;;				r.id, r.raftLog.zeroTermOnErrCompacted(r.raftLog.term(m.Index)), m.Index, m.LogTerm, m.Index, m.From)
0000000000000000000000000000000000000000;;			r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: m.Index, Reject: true, RejectHint: r.raftLog.lastIndex()})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) handleHeartbeat(m pb.Message) {
0000000000000000000000000000000000000000;;		r.raftLog.commitTo(m.Commit)
0000000000000000000000000000000000000000;;		r.send(pb.Message{To: m.From, Type: pb.MsgHeartbeatResp, Context: m.Context})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) handleSnapshot(m pb.Message) {
0000000000000000000000000000000000000000;;		sindex, sterm := m.Snapshot.Metadata.Index, m.Snapshot.Metadata.Term
0000000000000000000000000000000000000000;;		if r.restore(m.Snapshot) {
0000000000000000000000000000000000000000;;			r.logger.Infof("%x [commit: %d] restored snapshot [index: %d, term: %d]",
0000000000000000000000000000000000000000;;				r.id, r.raftLog.committed, sindex, sterm)
0000000000000000000000000000000000000000;;			r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: r.raftLog.lastIndex()})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.logger.Infof("%x [commit: %d] ignored snapshot [index: %d, term: %d]",
0000000000000000000000000000000000000000;;				r.id, r.raftLog.committed, sindex, sterm)
0000000000000000000000000000000000000000;;			r.send(pb.Message{To: m.From, Type: pb.MsgAppResp, Index: r.raftLog.committed})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// restore recovers the state machine from a snapshot. It restores the log and the
0000000000000000000000000000000000000000;;	// configuration of state machine.
0000000000000000000000000000000000000000;;	func (r *raft) restore(s pb.Snapshot) bool {
0000000000000000000000000000000000000000;;		if s.Metadata.Index <= r.raftLog.committed {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.raftLog.matchTerm(s.Metadata.Index, s.Metadata.Term) {
0000000000000000000000000000000000000000;;			r.logger.Infof("%x [commit: %d, lastindex: %d, lastterm: %d] fast-forwarded commit to snapshot [index: %d, term: %d]",
0000000000000000000000000000000000000000;;				r.id, r.raftLog.committed, r.raftLog.lastIndex(), r.raftLog.lastTerm(), s.Metadata.Index, s.Metadata.Term)
0000000000000000000000000000000000000000;;			r.raftLog.commitTo(s.Metadata.Index)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.logger.Infof("%x [commit: %d, lastindex: %d, lastterm: %d] starts to restore snapshot [index: %d, term: %d]",
0000000000000000000000000000000000000000;;			r.id, r.raftLog.committed, r.raftLog.lastIndex(), r.raftLog.lastTerm(), s.Metadata.Index, s.Metadata.Term)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.raftLog.restore(s)
0000000000000000000000000000000000000000;;		r.prs = make(map[uint64]*Progress)
0000000000000000000000000000000000000000;;		for _, n := range s.Metadata.ConfState.Nodes {
0000000000000000000000000000000000000000;;			match, next := uint64(0), r.raftLog.lastIndex()+1
0000000000000000000000000000000000000000;;			if n == r.id {
0000000000000000000000000000000000000000;;				match = next - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.setProgress(n, match, next)
0000000000000000000000000000000000000000;;			r.logger.Infof("%x restored progress of %x [%s]", r.id, n, r.prs[n])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// promotable indicates whether state machine can be promoted to leader,
0000000000000000000000000000000000000000;;	// which is true when its own id is in progress list.
0000000000000000000000000000000000000000;;	func (r *raft) promotable() bool {
0000000000000000000000000000000000000000;;		_, ok := r.prs[r.id]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) addNode(id uint64) {
0000000000000000000000000000000000000000;;		r.pendingConf = false
0000000000000000000000000000000000000000;;		if _, ok := r.prs[id]; ok {
0000000000000000000000000000000000000000;;			// Ignore any redundant addNode calls (which can happen because the
0000000000000000000000000000000000000000;;			// initial bootstrapping entries are applied twice).
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.setProgress(id, 0, r.raftLog.lastIndex()+1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) removeNode(id uint64) {
0000000000000000000000000000000000000000;;		r.delProgress(id)
0000000000000000000000000000000000000000;;		r.pendingConf = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do not try to commit or abort transferring if there is no nodes in the cluster.
0000000000000000000000000000000000000000;;		if len(r.prs) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The quorum size is now smaller, so see if any pending entries can
0000000000000000000000000000000000000000;;		// be committed.
0000000000000000000000000000000000000000;;		if r.maybeCommit() {
0000000000000000000000000000000000000000;;			r.bcastAppend()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the removed node is the leadTransferee, then abort the leadership transferring.
0000000000000000000000000000000000000000;;		if r.state == StateLeader && r.leadTransferee == id {
0000000000000000000000000000000000000000;;			r.abortLeaderTransfer()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) resetPendingConf() { r.pendingConf = false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) setProgress(id, match, next uint64) {
0000000000000000000000000000000000000000;;		r.prs[id] = &Progress{Next: next, Match: match, ins: newInflights(r.maxInflight)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) delProgress(id uint64) {
0000000000000000000000000000000000000000;;		delete(r.prs, id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) loadState(state pb.HardState) {
0000000000000000000000000000000000000000;;		if state.Commit < r.raftLog.committed || state.Commit > r.raftLog.lastIndex() {
0000000000000000000000000000000000000000;;			r.logger.Panicf("%x state.commit %d is out of range [%d, %d]", r.id, state.Commit, r.raftLog.committed, r.raftLog.lastIndex())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.raftLog.committed = state.Commit
0000000000000000000000000000000000000000;;		r.Term = state.Term
0000000000000000000000000000000000000000;;		r.Vote = state.Vote
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pastElectionTimeout returns true iff r.electionElapsed is greater
0000000000000000000000000000000000000000;;	// than or equal to the randomized election timeout in
0000000000000000000000000000000000000000;;	// [electiontimeout, 2 * electiontimeout - 1].
0000000000000000000000000000000000000000;;	func (r *raft) pastElectionTimeout() bool {
0000000000000000000000000000000000000000;;		return r.electionElapsed >= r.randomizedElectionTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) resetRandomizedElectionTimeout() {
0000000000000000000000000000000000000000;;		r.randomizedElectionTimeout = r.electionTimeout + globalRand.Intn(r.electionTimeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkQuorumActive returns true if the quorum is active from
0000000000000000000000000000000000000000;;	// the view of the local raft state machine. Otherwise, it returns
0000000000000000000000000000000000000000;;	// false.
0000000000000000000000000000000000000000;;	// checkQuorumActive also resets all RecentActive to false.
0000000000000000000000000000000000000000;;	func (r *raft) checkQuorumActive() bool {
0000000000000000000000000000000000000000;;		var act int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for id := range r.prs {
0000000000000000000000000000000000000000;;			if id == r.id { // self is always active
0000000000000000000000000000000000000000;;				act++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.prs[id].RecentActive {
0000000000000000000000000000000000000000;;				act++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.prs[id].RecentActive = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return act >= r.quorum()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) sendTimeoutNow(to uint64) {
0000000000000000000000000000000000000000;;		r.send(pb.Message{To: to, Type: pb.MsgTimeoutNow})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *raft) abortLeaderTransfer() {
0000000000000000000000000000000000000000;;		r.leadTransferee = None
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func numOfPendingConf(ents []pb.Entry) int {
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		for i := range ents {
0000000000000000000000000000000000000000;;			if ents[i].Type == pb.EntryConfChange {
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
