0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/raft/node.go[Godeps/_workspace/src/github.com/coreos/etcd/raft/node.go][vendor/github.com/coreos/etcd/raft/node.go];	
0000000000000000000000000000000000000000;;	package raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SnapshotStatus int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SnapshotFinish  SnapshotStatus = 1
0000000000000000000000000000000000000000;;		SnapshotFailure SnapshotStatus = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		emptyState = pb.HardState{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrStopped is returned by methods on Nodes that have been stopped.
0000000000000000000000000000000000000000;;		ErrStopped = errors.New("raft: stopped")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SoftState provides state that is useful for logging and debugging.
0000000000000000000000000000000000000000;;	// The state is volatile and does not need to be persisted to the WAL.
0000000000000000000000000000000000000000;;	type SoftState struct {
0000000000000000000000000000000000000000;;		Lead      uint64 // must use atomic operations to access; keep 64-bit aligned.
0000000000000000000000000000000000000000;;		RaftState StateType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *SoftState) equal(b *SoftState) bool {
0000000000000000000000000000000000000000;;		return a.Lead == b.Lead && a.RaftState == b.RaftState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ready encapsulates the entries and messages that are ready to read,
0000000000000000000000000000000000000000;;	// be saved to stable storage, committed or sent to other peers.
0000000000000000000000000000000000000000;;	// All fields in Ready are read-only.
0000000000000000000000000000000000000000;;	type Ready struct {
0000000000000000000000000000000000000000;;		// The current volatile state of a Node.
0000000000000000000000000000000000000000;;		// SoftState will be nil if there is no update.
0000000000000000000000000000000000000000;;		// It is not required to consume or store SoftState.
0000000000000000000000000000000000000000;;		*SoftState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The current state of a Node to be saved to stable storage BEFORE
0000000000000000000000000000000000000000;;		// Messages are sent.
0000000000000000000000000000000000000000;;		// HardState will be equal to empty state if there is no update.
0000000000000000000000000000000000000000;;		pb.HardState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadStates can be used for node to serve linearizable read requests locally
0000000000000000000000000000000000000000;;		// when its applied index is greater than the index in ReadState.
0000000000000000000000000000000000000000;;		// Note that the readState will be returned when raft receives msgReadIndex.
0000000000000000000000000000000000000000;;		// The returned is only valid for the request that requested to read.
0000000000000000000000000000000000000000;;		ReadStates []ReadState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Entries specifies entries to be saved to stable storage BEFORE
0000000000000000000000000000000000000000;;		// Messages are sent.
0000000000000000000000000000000000000000;;		Entries []pb.Entry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Snapshot specifies the snapshot to be saved to stable storage.
0000000000000000000000000000000000000000;;		Snapshot pb.Snapshot
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CommittedEntries specifies entries to be committed to a
0000000000000000000000000000000000000000;;		// store/state-machine. These have previously been committed to stable
0000000000000000000000000000000000000000;;		// store.
0000000000000000000000000000000000000000;;		CommittedEntries []pb.Entry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Messages specifies outbound messages to be sent AFTER Entries are
0000000000000000000000000000000000000000;;		// committed to stable storage.
0000000000000000000000000000000000000000;;		// If it contains a MsgSnap message, the application MUST report back to raft
0000000000000000000000000000000000000000;;		// when the snapshot has been received or has failed by calling ReportSnapshot.
0000000000000000000000000000000000000000;;		Messages []pb.Message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHardStateEqual(a, b pb.HardState) bool {
0000000000000000000000000000000000000000;;		return a.Term == b.Term && a.Vote == b.Vote && a.Commit == b.Commit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmptyHardState returns true if the given HardState is empty.
0000000000000000000000000000000000000000;;	func IsEmptyHardState(st pb.HardState) bool {
0000000000000000000000000000000000000000;;		return isHardStateEqual(st, emptyState)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmptySnap returns true if the given Snapshot is empty.
0000000000000000000000000000000000000000;;	func IsEmptySnap(sp pb.Snapshot) bool {
0000000000000000000000000000000000000000;;		return sp.Metadata.Index == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rd Ready) containsUpdates() bool {
0000000000000000000000000000000000000000;;		return rd.SoftState != nil || !IsEmptyHardState(rd.HardState) ||
0000000000000000000000000000000000000000;;			!IsEmptySnap(rd.Snapshot) || len(rd.Entries) > 0 ||
0000000000000000000000000000000000000000;;			len(rd.CommittedEntries) > 0 || len(rd.Messages) > 0 || len(rd.ReadStates) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node represents a node in a raft cluster.
0000000000000000000000000000000000000000;;	type Node interface {
0000000000000000000000000000000000000000;;		// Tick increments the internal logical clock for the Node by a single tick. Election
0000000000000000000000000000000000000000;;		// timeouts and heartbeat timeouts are in units of ticks.
0000000000000000000000000000000000000000;;		Tick()
0000000000000000000000000000000000000000;;		// Campaign causes the Node to transition to candidate state and start campaigning to become leader.
0000000000000000000000000000000000000000;;		Campaign(ctx context.Context) error
0000000000000000000000000000000000000000;;		// Propose proposes that data be appended to the log.
0000000000000000000000000000000000000000;;		Propose(ctx context.Context, data []byte) error
0000000000000000000000000000000000000000;;		// ProposeConfChange proposes config change.
0000000000000000000000000000000000000000;;		// At most one ConfChange can be in the process of going through consensus.
0000000000000000000000000000000000000000;;		// Application needs to call ApplyConfChange when applying EntryConfChange type entry.
0000000000000000000000000000000000000000;;		ProposeConfChange(ctx context.Context, cc pb.ConfChange) error
0000000000000000000000000000000000000000;;		// Step advances the state machine using the given message. ctx.Err() will be returned, if any.
0000000000000000000000000000000000000000;;		Step(ctx context.Context, msg pb.Message) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ready returns a channel that returns the current point-in-time state.
0000000000000000000000000000000000000000;;		// Users of the Node must call Advance after retrieving the state returned by Ready.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// NOTE: No committed entries from the next Ready may be applied until all committed entries
0000000000000000000000000000000000000000;;		// and snapshots from the previous one have finished.
0000000000000000000000000000000000000000;;		Ready() <-chan Ready
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Advance notifies the Node that the application has saved progress up to the last Ready.
0000000000000000000000000000000000000000;;		// It prepares the node to return the next available Ready.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The application should generally call Advance after it applies the entries in last Ready.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// However, as an optimization, the application may call Advance while it is applying the
0000000000000000000000000000000000000000;;		// commands. For example. when the last Ready contains a snapshot, the application might take
0000000000000000000000000000000000000000;;		// a long time to apply the snapshot data. To continue receiving Ready without blocking raft
0000000000000000000000000000000000000000;;		// progress, it can call Advance before finishing applying the last ready.
0000000000000000000000000000000000000000;;		Advance()
0000000000000000000000000000000000000000;;		// ApplyConfChange applies config change to the local node.
0000000000000000000000000000000000000000;;		// Returns an opaque ConfState protobuf which must be recorded
0000000000000000000000000000000000000000;;		// in snapshots. Will never return nil; it returns a pointer only
0000000000000000000000000000000000000000;;		// to match MemoryStorage.Compact.
0000000000000000000000000000000000000000;;		ApplyConfChange(cc pb.ConfChange) *pb.ConfState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TransferLeadership attempts to transfer leadership to the given transferee.
0000000000000000000000000000000000000000;;		TransferLeadership(ctx context.Context, lead, transferee uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadIndex request a read state. The read state will be set in the ready.
0000000000000000000000000000000000000000;;		// Read state has a read index. Once the application advances further than the read
0000000000000000000000000000000000000000;;		// index, any linearizable read requests issued before the read request can be
0000000000000000000000000000000000000000;;		// processed safely. The read state will have the same rctx attached.
0000000000000000000000000000000000000000;;		ReadIndex(ctx context.Context, rctx []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status returns the current status of the raft state machine.
0000000000000000000000000000000000000000;;		Status() Status
0000000000000000000000000000000000000000;;		// ReportUnreachable reports the given node is not reachable for the last send.
0000000000000000000000000000000000000000;;		ReportUnreachable(id uint64)
0000000000000000000000000000000000000000;;		// ReportSnapshot reports the status of the sent snapshot.
0000000000000000000000000000000000000000;;		ReportSnapshot(id uint64, status SnapshotStatus)
0000000000000000000000000000000000000000;;		// Stop performs any necessary termination of the Node.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Peer struct {
0000000000000000000000000000000000000000;;		ID      uint64
0000000000000000000000000000000000000000;;		Context []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartNode returns a new Node given configuration and a list of raft peers.
0000000000000000000000000000000000000000;;	// It appends a ConfChangeAddNode entry for each given peer to the initial log.
0000000000000000000000000000000000000000;;	func StartNode(c *Config, peers []Peer) Node {
0000000000000000000000000000000000000000;;		r := newRaft(c)
0000000000000000000000000000000000000000;;		// become the follower at term 1 and apply initial configuration
0000000000000000000000000000000000000000;;		// entries of term 1
0000000000000000000000000000000000000000;;		r.becomeFollower(1, None)
0000000000000000000000000000000000000000;;		for _, peer := range peers {
0000000000000000000000000000000000000000;;			cc := pb.ConfChange{Type: pb.ConfChangeAddNode, NodeID: peer.ID, Context: peer.Context}
0000000000000000000000000000000000000000;;			d, err := cc.Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic("unexpected marshal error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e := pb.Entry{Type: pb.EntryConfChange, Term: 1, Index: r.raftLog.lastIndex() + 1, Data: d}
0000000000000000000000000000000000000000;;			r.raftLog.append(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Mark these initial entries as committed.
0000000000000000000000000000000000000000;;		// TODO(bdarnell): These entries are still unstable; do we need to preserve
0000000000000000000000000000000000000000;;		// the invariant that committed < unstable?
0000000000000000000000000000000000000000;;		r.raftLog.committed = r.raftLog.lastIndex()
0000000000000000000000000000000000000000;;		// Now apply them, mainly so that the application can call Campaign
0000000000000000000000000000000000000000;;		// immediately after StartNode in tests. Note that these nodes will
0000000000000000000000000000000000000000;;		// be added to raft twice: here and when the application's Ready
0000000000000000000000000000000000000000;;		// loop calls ApplyConfChange. The calls to addNode must come after
0000000000000000000000000000000000000000;;		// all calls to raftLog.append so progress.next is set after these
0000000000000000000000000000000000000000;;		// bootstrapping entries (it is an error if we try to append these
0000000000000000000000000000000000000000;;		// entries since they have already been committed).
0000000000000000000000000000000000000000;;		// We do not set raftLog.applied so the application will be able
0000000000000000000000000000000000000000;;		// to observe all conf changes via Ready.CommittedEntries.
0000000000000000000000000000000000000000;;		for _, peer := range peers {
0000000000000000000000000000000000000000;;			r.addNode(peer.ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := newNode()
0000000000000000000000000000000000000000;;		n.logger = c.Logger
0000000000000000000000000000000000000000;;		go n.run(r)
0000000000000000000000000000000000000000;;		return &n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestartNode is similar to StartNode but does not take a list of peers.
0000000000000000000000000000000000000000;;	// The current membership of the cluster will be restored from the Storage.
0000000000000000000000000000000000000000;;	// If the caller has an existing state machine, pass in the last log index that
0000000000000000000000000000000000000000;;	// has been applied to it; otherwise use zero.
0000000000000000000000000000000000000000;;	func RestartNode(c *Config) Node {
0000000000000000000000000000000000000000;;		r := newRaft(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := newNode()
0000000000000000000000000000000000000000;;		n.logger = c.Logger
0000000000000000000000000000000000000000;;		go n.run(r)
0000000000000000000000000000000000000000;;		return &n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// node is the canonical implementation of the Node interface
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		propc      chan pb.Message
0000000000000000000000000000000000000000;;		recvc      chan pb.Message
0000000000000000000000000000000000000000;;		confc      chan pb.ConfChange
0000000000000000000000000000000000000000;;		confstatec chan pb.ConfState
0000000000000000000000000000000000000000;;		readyc     chan Ready
0000000000000000000000000000000000000000;;		advancec   chan struct{}
0000000000000000000000000000000000000000;;		tickc      chan struct{}
0000000000000000000000000000000000000000;;		done       chan struct{}
0000000000000000000000000000000000000000;;		stop       chan struct{}
0000000000000000000000000000000000000000;;		status     chan chan Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger Logger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newNode() node {
0000000000000000000000000000000000000000;;		return node{
0000000000000000000000000000000000000000;;			propc:      make(chan pb.Message),
0000000000000000000000000000000000000000;;			recvc:      make(chan pb.Message),
0000000000000000000000000000000000000000;;			confc:      make(chan pb.ConfChange),
0000000000000000000000000000000000000000;;			confstatec: make(chan pb.ConfState),
0000000000000000000000000000000000000000;;			readyc:     make(chan Ready),
0000000000000000000000000000000000000000;;			advancec:   make(chan struct{}),
0000000000000000000000000000000000000000;;			// make tickc a buffered chan, so raft node can buffer some ticks when the node
0000000000000000000000000000000000000000;;			// is busy processing raft messages. Raft node will resume process buffered
0000000000000000000000000000000000000000;;			// ticks when it becomes idle.
0000000000000000000000000000000000000000;;			tickc:  make(chan struct{}, 128),
0000000000000000000000000000000000000000;;			done:   make(chan struct{}),
0000000000000000000000000000000000000000;;			stop:   make(chan struct{}),
0000000000000000000000000000000000000000;;			status: make(chan chan Status),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Stop() {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case n.stop <- struct{}{}:
0000000000000000000000000000000000000000;;			// Not already stopped, so trigger it
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;			// Node has already been stopped - no need to do anything
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Block until the stop has been acknowledged by run()
0000000000000000000000000000000000000000;;		<-n.done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) run(r *raft) {
0000000000000000000000000000000000000000;;		var propc chan pb.Message
0000000000000000000000000000000000000000;;		var readyc chan Ready
0000000000000000000000000000000000000000;;		var advancec chan struct{}
0000000000000000000000000000000000000000;;		var prevLastUnstablei, prevLastUnstablet uint64
0000000000000000000000000000000000000000;;		var havePrevLastUnstablei bool
0000000000000000000000000000000000000000;;		var prevSnapi uint64
0000000000000000000000000000000000000000;;		var rd Ready
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lead := None
0000000000000000000000000000000000000000;;		prevSoftSt := r.softState()
0000000000000000000000000000000000000000;;		prevHardSt := emptyState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if advancec != nil {
0000000000000000000000000000000000000000;;				readyc = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rd = newReady(r, prevSoftSt, prevHardSt)
0000000000000000000000000000000000000000;;				if rd.containsUpdates() {
0000000000000000000000000000000000000000;;					readyc = n.readyc
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					readyc = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if lead != r.lead {
0000000000000000000000000000000000000000;;				if r.hasLeader() {
0000000000000000000000000000000000000000;;					if lead == None {
0000000000000000000000000000000000000000;;						r.logger.Infof("raft.node: %x elected leader %x at term %d", r.id, r.lead, r.Term)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						r.logger.Infof("raft.node: %x changed leader from %x to %x at term %d", r.id, lead, r.lead, r.Term)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					propc = n.propc
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					r.logger.Infof("raft.node: %x lost leader %x at term %d", r.id, lead, r.Term)
0000000000000000000000000000000000000000;;					propc = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lead = r.lead
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			// TODO: maybe buffer the config propose if there exists one (the way
0000000000000000000000000000000000000000;;			// described in raft dissertation)
0000000000000000000000000000000000000000;;			// Currently it is dropped in Step silently.
0000000000000000000000000000000000000000;;			case m := <-propc:
0000000000000000000000000000000000000000;;				m.From = r.id
0000000000000000000000000000000000000000;;				r.Step(m)
0000000000000000000000000000000000000000;;			case m := <-n.recvc:
0000000000000000000000000000000000000000;;				// filter out response message from unknown From.
0000000000000000000000000000000000000000;;				if _, ok := r.prs[m.From]; ok || !IsResponseMsg(m.Type) {
0000000000000000000000000000000000000000;;					r.Step(m) // raft never returns an error
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case cc := <-n.confc:
0000000000000000000000000000000000000000;;				if cc.NodeID == None {
0000000000000000000000000000000000000000;;					r.resetPendingConf()
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case n.confstatec <- pb.ConfState{Nodes: r.nodes()}:
0000000000000000000000000000000000000000;;					case <-n.done:
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch cc.Type {
0000000000000000000000000000000000000000;;				case pb.ConfChangeAddNode:
0000000000000000000000000000000000000000;;					r.addNode(cc.NodeID)
0000000000000000000000000000000000000000;;				case pb.ConfChangeRemoveNode:
0000000000000000000000000000000000000000;;					// block incoming proposal when local node is
0000000000000000000000000000000000000000;;					// removed
0000000000000000000000000000000000000000;;					if cc.NodeID == r.id {
0000000000000000000000000000000000000000;;						propc = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					r.removeNode(cc.NodeID)
0000000000000000000000000000000000000000;;				case pb.ConfChangeUpdateNode:
0000000000000000000000000000000000000000;;					r.resetPendingConf()
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic("unexpected conf type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case n.confstatec <- pb.ConfState{Nodes: r.nodes()}:
0000000000000000000000000000000000000000;;				case <-n.done:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-n.tickc:
0000000000000000000000000000000000000000;;				r.tick()
0000000000000000000000000000000000000000;;			case readyc <- rd:
0000000000000000000000000000000000000000;;				if rd.SoftState != nil {
0000000000000000000000000000000000000000;;					prevSoftSt = rd.SoftState
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(rd.Entries) > 0 {
0000000000000000000000000000000000000000;;					prevLastUnstablei = rd.Entries[len(rd.Entries)-1].Index
0000000000000000000000000000000000000000;;					prevLastUnstablet = rd.Entries[len(rd.Entries)-1].Term
0000000000000000000000000000000000000000;;					havePrevLastUnstablei = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !IsEmptyHardState(rd.HardState) {
0000000000000000000000000000000000000000;;					prevHardSt = rd.HardState
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !IsEmptySnap(rd.Snapshot) {
0000000000000000000000000000000000000000;;					prevSnapi = rd.Snapshot.Metadata.Index
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r.msgs = nil
0000000000000000000000000000000000000000;;				r.readStates = nil
0000000000000000000000000000000000000000;;				advancec = n.advancec
0000000000000000000000000000000000000000;;			case <-advancec:
0000000000000000000000000000000000000000;;				if prevHardSt.Commit != 0 {
0000000000000000000000000000000000000000;;					r.raftLog.appliedTo(prevHardSt.Commit)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if havePrevLastUnstablei {
0000000000000000000000000000000000000000;;					r.raftLog.stableTo(prevLastUnstablei, prevLastUnstablet)
0000000000000000000000000000000000000000;;					havePrevLastUnstablei = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.raftLog.stableSnapTo(prevSnapi)
0000000000000000000000000000000000000000;;				advancec = nil
0000000000000000000000000000000000000000;;			case c := <-n.status:
0000000000000000000000000000000000000000;;				c <- getStatus(r)
0000000000000000000000000000000000000000;;			case <-n.stop:
0000000000000000000000000000000000000000;;				close(n.done)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tick increments the internal logical clock for this Node. Election timeouts
0000000000000000000000000000000000000000;;	// and heartbeat timeouts are in units of ticks.
0000000000000000000000000000000000000000;;	func (n *node) Tick() {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case n.tickc <- struct{}{}:
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			n.logger.Warningf("A tick missed to fire. Node blocks too long!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Campaign(ctx context.Context) error { return n.step(ctx, pb.Message{Type: pb.MsgHup}) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Propose(ctx context.Context, data []byte) error {
0000000000000000000000000000000000000000;;		return n.step(ctx, pb.Message{Type: pb.MsgProp, Entries: []pb.Entry{{Data: data}}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Step(ctx context.Context, m pb.Message) error {
0000000000000000000000000000000000000000;;		// ignore unexpected local messages receiving over network
0000000000000000000000000000000000000000;;		if IsLocalMsg(m.Type) {
0000000000000000000000000000000000000000;;			// TODO: return an error?
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.step(ctx, m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) ProposeConfChange(ctx context.Context, cc pb.ConfChange) error {
0000000000000000000000000000000000000000;;		data, err := cc.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.Step(ctx, pb.Message{Type: pb.MsgProp, Entries: []pb.Entry{{Type: pb.EntryConfChange, Data: data}}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Step advances the state machine using msgs. The ctx.Err() will be returned,
0000000000000000000000000000000000000000;;	// if any.
0000000000000000000000000000000000000000;;	func (n *node) step(ctx context.Context, m pb.Message) error {
0000000000000000000000000000000000000000;;		ch := n.recvc
0000000000000000000000000000000000000000;;		if m.Type == pb.MsgProp {
0000000000000000000000000000000000000000;;			ch = n.propc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case ch <- m:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return ctx.Err()
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;			return ErrStopped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Ready() <-chan Ready { return n.readyc }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Advance() {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case n.advancec <- struct{}{}:
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) ApplyConfChange(cc pb.ConfChange) *pb.ConfState {
0000000000000000000000000000000000000000;;		var cs pb.ConfState
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case n.confc <- cc:
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case cs = <-n.confstatec:
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &cs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Status() Status {
0000000000000000000000000000000000000000;;		c := make(chan Status)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case n.status <- c:
0000000000000000000000000000000000000000;;			return <-c
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;			return Status{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) ReportUnreachable(id uint64) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case n.recvc <- pb.Message{Type: pb.MsgUnreachable, From: id}:
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) ReportSnapshot(id uint64, status SnapshotStatus) {
0000000000000000000000000000000000000000;;		rej := status == SnapshotFailure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case n.recvc <- pb.Message{Type: pb.MsgSnapStatus, From: id, Reject: rej}:
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) TransferLeadership(ctx context.Context, lead, transferee uint64) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		// manually set 'from' and 'to', so that leader can voluntarily transfers its leadership
0000000000000000000000000000000000000000;;		case n.recvc <- pb.Message{Type: pb.MsgTransferLeader, From: transferee, To: lead}:
0000000000000000000000000000000000000000;;		case <-n.done:
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) ReadIndex(ctx context.Context, rctx []byte) error {
0000000000000000000000000000000000000000;;		return n.step(ctx, pb.Message{Type: pb.MsgReadIndex, Entries: []pb.Entry{{Data: rctx}}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReady(r *raft, prevSoftSt *SoftState, prevHardSt pb.HardState) Ready {
0000000000000000000000000000000000000000;;		rd := Ready{
0000000000000000000000000000000000000000;;			Entries:          r.raftLog.unstableEntries(),
0000000000000000000000000000000000000000;;			CommittedEntries: r.raftLog.nextEnts(),
0000000000000000000000000000000000000000;;			Messages:         r.msgs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if softSt := r.softState(); !softSt.equal(prevSoftSt) {
0000000000000000000000000000000000000000;;			rd.SoftState = softSt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hardSt := r.hardState(); !isHardStateEqual(hardSt, prevHardSt) {
0000000000000000000000000000000000000000;;			rd.HardState = hardSt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.raftLog.unstable.snapshot != nil {
0000000000000000000000000000000000000000;;			rd.Snapshot = *r.raftLog.unstable.snapshot
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.readStates) != 0 {
0000000000000000000000000000000000000000;;			rd.ReadStates = r.readStates
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rd
0000000000000000000000000000000000000000;;	}
