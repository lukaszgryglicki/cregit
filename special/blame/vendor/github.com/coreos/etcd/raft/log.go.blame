0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/raft/log.go[Godeps/_workspace/src/github.com/coreos/etcd/raft/log.go][vendor/github.com/coreos/etcd/raft/log.go];	
0000000000000000000000000000000000000000;;	package raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type raftLog struct {
0000000000000000000000000000000000000000;;		// storage contains all stable entries since the last snapshot.
0000000000000000000000000000000000000000;;		storage Storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unstable contains all unstable entries and snapshot.
0000000000000000000000000000000000000000;;		// they will be saved into storage.
0000000000000000000000000000000000000000;;		unstable unstable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// committed is the highest log position that is known to be in
0000000000000000000000000000000000000000;;		// stable storage on a quorum of nodes.
0000000000000000000000000000000000000000;;		committed uint64
0000000000000000000000000000000000000000;;		// applied is the highest log position that the application has
0000000000000000000000000000000000000000;;		// been instructed to apply to its state machine.
0000000000000000000000000000000000000000;;		// Invariant: applied <= committed
0000000000000000000000000000000000000000;;		applied uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger Logger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newLog returns log using the given storage. It recovers the log to the state
0000000000000000000000000000000000000000;;	// that it just commits and applies the latest snapshot.
0000000000000000000000000000000000000000;;	func newLog(storage Storage, logger Logger) *raftLog {
0000000000000000000000000000000000000000;;		if storage == nil {
0000000000000000000000000000000000000000;;			log.Panic("storage must not be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log := &raftLog{
0000000000000000000000000000000000000000;;			storage: storage,
0000000000000000000000000000000000000000;;			logger:  logger,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		firstIndex, err := storage.FirstIndex()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lastIndex, err := storage.LastIndex()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.unstable.offset = lastIndex + 1
0000000000000000000000000000000000000000;;		log.unstable.logger = logger
0000000000000000000000000000000000000000;;		// Initialize our committed and applied pointers to the time of the last compaction.
0000000000000000000000000000000000000000;;		log.committed = firstIndex - 1
0000000000000000000000000000000000000000;;		log.applied = firstIndex - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return log
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("committed=%d, applied=%d, unstable.offset=%d, len(unstable.Entries)=%d", l.committed, l.applied, l.unstable.offset, len(l.unstable.entries))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeAppend returns (0, false) if the entries cannot be appended. Otherwise,
0000000000000000000000000000000000000000;;	// it returns (last index of new entries, true).
0000000000000000000000000000000000000000;;	func (l *raftLog) maybeAppend(index, logTerm, committed uint64, ents ...pb.Entry) (lastnewi uint64, ok bool) {
0000000000000000000000000000000000000000;;		if l.matchTerm(index, logTerm) {
0000000000000000000000000000000000000000;;			lastnewi = index + uint64(len(ents))
0000000000000000000000000000000000000000;;			ci := l.findConflict(ents)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ci == 0:
0000000000000000000000000000000000000000;;			case ci <= l.committed:
0000000000000000000000000000000000000000;;				l.logger.Panicf("entry %d conflict with committed entry [committed(%d)]", ci, l.committed)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				offset := index + 1
0000000000000000000000000000000000000000;;				l.append(ents[ci-offset:]...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.commitTo(min(committed, lastnewi))
0000000000000000000000000000000000000000;;			return lastnewi, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) append(ents ...pb.Entry) uint64 {
0000000000000000000000000000000000000000;;		if len(ents) == 0 {
0000000000000000000000000000000000000000;;			return l.lastIndex()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if after := ents[0].Index - 1; after < l.committed {
0000000000000000000000000000000000000000;;			l.logger.Panicf("after(%d) is out of range [committed(%d)]", after, l.committed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.unstable.truncateAndAppend(ents)
0000000000000000000000000000000000000000;;		return l.lastIndex()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findConflict finds the index of the conflict.
0000000000000000000000000000000000000000;;	// It returns the first pair of conflicting entries between the existing
0000000000000000000000000000000000000000;;	// entries and the given entries, if there are any.
0000000000000000000000000000000000000000;;	// If there is no conflicting entries, and the existing entries contains
0000000000000000000000000000000000000000;;	// all the given entries, zero will be returned.
0000000000000000000000000000000000000000;;	// If there is no conflicting entries, but the given entries contains new
0000000000000000000000000000000000000000;;	// entries, the index of the first new entry will be returned.
0000000000000000000000000000000000000000;;	// An entry is considered to be conflicting if it has the same index but
0000000000000000000000000000000000000000;;	// a different term.
0000000000000000000000000000000000000000;;	// The first entry MUST have an index equal to the argument 'from'.
0000000000000000000000000000000000000000;;	// The index of the given entries MUST be continuously increasing.
0000000000000000000000000000000000000000;;	func (l *raftLog) findConflict(ents []pb.Entry) uint64 {
0000000000000000000000000000000000000000;;		for _, ne := range ents {
0000000000000000000000000000000000000000;;			if !l.matchTerm(ne.Index, ne.Term) {
0000000000000000000000000000000000000000;;				if ne.Index <= l.lastIndex() {
0000000000000000000000000000000000000000;;					l.logger.Infof("found conflict at index %d [existing term: %d, conflicting term: %d]",
0000000000000000000000000000000000000000;;						ne.Index, l.zeroTermOnErrCompacted(l.term(ne.Index)), ne.Term)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return ne.Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) unstableEntries() []pb.Entry {
0000000000000000000000000000000000000000;;		if len(l.unstable.entries) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.unstable.entries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextEnts returns all the available entries for execution.
0000000000000000000000000000000000000000;;	// If applied is smaller than the index of snapshot, it returns all committed
0000000000000000000000000000000000000000;;	// entries after the index of snapshot.
0000000000000000000000000000000000000000;;	func (l *raftLog) nextEnts() (ents []pb.Entry) {
0000000000000000000000000000000000000000;;		off := max(l.applied+1, l.firstIndex())
0000000000000000000000000000000000000000;;		if l.committed+1 > off {
0000000000000000000000000000000000000000;;			ents, err := l.slice(off, l.committed+1, noLimit)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				l.logger.Panicf("unexpected error when getting unapplied entries (%v)", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ents
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasNextEnts returns if there is any available entries for execution. This
0000000000000000000000000000000000000000;;	// is a fast check without heavy raftLog.slice() in raftLog.nextEnts().
0000000000000000000000000000000000000000;;	func (l *raftLog) hasNextEnts() bool {
0000000000000000000000000000000000000000;;		off := max(l.applied+1, l.firstIndex())
0000000000000000000000000000000000000000;;		return l.committed+1 > off
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) snapshot() (pb.Snapshot, error) {
0000000000000000000000000000000000000000;;		if l.unstable.snapshot != nil {
0000000000000000000000000000000000000000;;			return *l.unstable.snapshot, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.storage.Snapshot()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) firstIndex() uint64 {
0000000000000000000000000000000000000000;;		if i, ok := l.unstable.maybeFirstIndex(); ok {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index, err := l.storage.FirstIndex()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return index
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) lastIndex() uint64 {
0000000000000000000000000000000000000000;;		if i, ok := l.unstable.maybeLastIndex(); ok {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, err := l.storage.LastIndex()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) commitTo(tocommit uint64) {
0000000000000000000000000000000000000000;;		// never decrease commit
0000000000000000000000000000000000000000;;		if l.committed < tocommit {
0000000000000000000000000000000000000000;;			if l.lastIndex() < tocommit {
0000000000000000000000000000000000000000;;				l.logger.Panicf("tocommit(%d) is out of range [lastIndex(%d)]. Was the raft log corrupted, truncated, or lost?", tocommit, l.lastIndex())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.committed = tocommit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) appliedTo(i uint64) {
0000000000000000000000000000000000000000;;		if i == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.committed < i || i < l.applied {
0000000000000000000000000000000000000000;;			l.logger.Panicf("applied(%d) is out of range [prevApplied(%d), committed(%d)]", i, l.applied, l.committed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.applied = i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) stableTo(i, t uint64) { l.unstable.stableTo(i, t) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) stableSnapTo(i uint64) { l.unstable.stableSnapTo(i) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) lastTerm() uint64 {
0000000000000000000000000000000000000000;;		t, err := l.term(l.lastIndex())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			l.logger.Panicf("unexpected error when getting the last term (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) term(i uint64) (uint64, error) {
0000000000000000000000000000000000000000;;		// the valid term range is [index of dummy entry, last index]
0000000000000000000000000000000000000000;;		dummyIndex := l.firstIndex() - 1
0000000000000000000000000000000000000000;;		if i < dummyIndex || i > l.lastIndex() {
0000000000000000000000000000000000000000;;			// TODO: return an error instead?
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t, ok := l.unstable.maybeTerm(i); ok {
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, err := l.storage.Term(i)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == ErrCompacted || err == ErrUnavailable {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) entries(i, maxsize uint64) ([]pb.Entry, error) {
0000000000000000000000000000000000000000;;		if i > l.lastIndex() {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.slice(i, l.lastIndex()+1, maxsize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allEntries returns all entries in the log.
0000000000000000000000000000000000000000;;	func (l *raftLog) allEntries() []pb.Entry {
0000000000000000000000000000000000000000;;		ents, err := l.entries(l.firstIndex(), noLimit)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return ents
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == ErrCompacted { // try again if there was a racing compaction
0000000000000000000000000000000000000000;;			return l.allEntries()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO (xiangli): handle error?
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isUpToDate determines if the given (lastIndex,term) log is more up-to-date
0000000000000000000000000000000000000000;;	// by comparing the index and term of the last entries in the existing logs.
0000000000000000000000000000000000000000;;	// If the logs have last entries with different terms, then the log with the
0000000000000000000000000000000000000000;;	// later term is more up-to-date. If the logs end with the same term, then
0000000000000000000000000000000000000000;;	// whichever log has the larger lastIndex is more up-to-date. If the logs are
0000000000000000000000000000000000000000;;	// the same, the given log is up-to-date.
0000000000000000000000000000000000000000;;	func (l *raftLog) isUpToDate(lasti, term uint64) bool {
0000000000000000000000000000000000000000;;		return term > l.lastTerm() || (term == l.lastTerm() && lasti >= l.lastIndex())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) matchTerm(i, term uint64) bool {
0000000000000000000000000000000000000000;;		t, err := l.term(i)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t == term
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) maybeCommit(maxIndex, term uint64) bool {
0000000000000000000000000000000000000000;;		if maxIndex > l.committed && l.zeroTermOnErrCompacted(l.term(maxIndex)) == term {
0000000000000000000000000000000000000000;;			l.commitTo(maxIndex)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) restore(s pb.Snapshot) {
0000000000000000000000000000000000000000;;		l.logger.Infof("log [%s] starts to restore snapshot [index: %d, term: %d]", l, s.Metadata.Index, s.Metadata.Term)
0000000000000000000000000000000000000000;;		l.committed = s.Metadata.Index
0000000000000000000000000000000000000000;;		l.unstable.restore(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// slice returns a slice of log entries from lo through hi-1, inclusive.
0000000000000000000000000000000000000000;;	func (l *raftLog) slice(lo, hi, maxSize uint64) ([]pb.Entry, error) {
0000000000000000000000000000000000000000;;		err := l.mustCheckOutOfBounds(lo, hi)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lo == hi {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ents []pb.Entry
0000000000000000000000000000000000000000;;		if lo < l.unstable.offset {
0000000000000000000000000000000000000000;;			storedEnts, err := l.storage.Entries(lo, min(hi, l.unstable.offset), maxSize)
0000000000000000000000000000000000000000;;			if err == ErrCompacted {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			} else if err == ErrUnavailable {
0000000000000000000000000000000000000000;;				l.logger.Panicf("entries[%d:%d) is unavailable from storage", lo, min(hi, l.unstable.offset))
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				panic(err) // TODO(bdarnell)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check if ents has reached the size limitation
0000000000000000000000000000000000000000;;			if uint64(len(storedEnts)) < min(hi, l.unstable.offset)-lo {
0000000000000000000000000000000000000000;;				return storedEnts, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ents = storedEnts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hi > l.unstable.offset {
0000000000000000000000000000000000000000;;			unstable := l.unstable.slice(max(lo, l.unstable.offset), hi)
0000000000000000000000000000000000000000;;			if len(ents) > 0 {
0000000000000000000000000000000000000000;;				ents = append([]pb.Entry{}, ents...)
0000000000000000000000000000000000000000;;				ents = append(ents, unstable...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ents = unstable
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return limitSize(ents, maxSize), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// l.firstIndex <= lo <= hi <= l.firstIndex + len(l.entries)
0000000000000000000000000000000000000000;;	func (l *raftLog) mustCheckOutOfBounds(lo, hi uint64) error {
0000000000000000000000000000000000000000;;		if lo > hi {
0000000000000000000000000000000000000000;;			l.logger.Panicf("invalid slice %d > %d", lo, hi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fi := l.firstIndex()
0000000000000000000000000000000000000000;;		if lo < fi {
0000000000000000000000000000000000000000;;			return ErrCompacted
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		length := l.lastIndex() + 1 - fi
0000000000000000000000000000000000000000;;		if lo < fi || hi > fi+length {
0000000000000000000000000000000000000000;;			l.logger.Panicf("slice[%d,%d) out of bound [%d,%d]", lo, hi, fi, l.lastIndex())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *raftLog) zeroTermOnErrCompacted(t uint64, err error) uint64 {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == ErrCompacted {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.logger.Panicf("unexpected error (%v)", err)
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
