0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import pb "github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadState provides state for read only query.
0000000000000000000000000000000000000000;;	// It's caller's responsibility to call ReadIndex first before getting
0000000000000000000000000000000000000000;;	// this state from ready, It's also caller's duty to differentiate if this
0000000000000000000000000000000000000000;;	// state is what it requests through RequestCtx, eg. given a unique id as
0000000000000000000000000000000000000000;;	// RequestCtx
0000000000000000000000000000000000000000;;	type ReadState struct {
0000000000000000000000000000000000000000;;		Index      uint64
0000000000000000000000000000000000000000;;		RequestCtx []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type readIndexStatus struct {
0000000000000000000000000000000000000000;;		req   pb.Message
0000000000000000000000000000000000000000;;		index uint64
0000000000000000000000000000000000000000;;		acks  map[uint64]struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type readOnly struct {
0000000000000000000000000000000000000000;;		option           ReadOnlyOption
0000000000000000000000000000000000000000;;		pendingReadIndex map[string]*readIndexStatus
0000000000000000000000000000000000000000;;		readIndexQueue   []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newReadOnly(option ReadOnlyOption) *readOnly {
0000000000000000000000000000000000000000;;		return &readOnly{
0000000000000000000000000000000000000000;;			option:           option,
0000000000000000000000000000000000000000;;			pendingReadIndex: make(map[string]*readIndexStatus),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addRequest adds a read only reuqest into readonly struct.
0000000000000000000000000000000000000000;;	// `index` is the commit index of the raft state machine when it received
0000000000000000000000000000000000000000;;	// the read only request.
0000000000000000000000000000000000000000;;	// `m` is the original read only request message from the local or remote node.
0000000000000000000000000000000000000000;;	func (ro *readOnly) addRequest(index uint64, m pb.Message) {
0000000000000000000000000000000000000000;;		ctx := string(m.Entries[0].Data)
0000000000000000000000000000000000000000;;		if _, ok := ro.pendingReadIndex[ctx]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ro.pendingReadIndex[ctx] = &readIndexStatus{index: index, req: m, acks: make(map[uint64]struct{})}
0000000000000000000000000000000000000000;;		ro.readIndexQueue = append(ro.readIndexQueue, ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recvAck notifies the readonly struct that the raft state machine received
0000000000000000000000000000000000000000;;	// an acknowledgment of the heartbeat that attached with the read only request
0000000000000000000000000000000000000000;;	// context.
0000000000000000000000000000000000000000;;	func (ro *readOnly) recvAck(m pb.Message) int {
0000000000000000000000000000000000000000;;		rs, ok := ro.pendingReadIndex[string(m.Context)]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rs.acks[m.From] = struct{}{}
0000000000000000000000000000000000000000;;		// add one to include an ack from local node
0000000000000000000000000000000000000000;;		return len(rs.acks) + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// advance advances the read only request queue kept by the readonly struct.
0000000000000000000000000000000000000000;;	// It dequeues the requests until it finds the read only request that has
0000000000000000000000000000000000000000;;	// the same context as the given `m`.
0000000000000000000000000000000000000000;;	func (ro *readOnly) advance(m pb.Message) []*readIndexStatus {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			i     int
0000000000000000000000000000000000000000;;			found bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := string(m.Context)
0000000000000000000000000000000000000000;;		rss := []*readIndexStatus{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, okctx := range ro.readIndexQueue {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			rs, ok := ro.pendingReadIndex[okctx]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				panic("cannot find corresponding read state from pending map")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rss = append(rss, rs)
0000000000000000000000000000000000000000;;			if okctx == ctx {
0000000000000000000000000000000000000000;;				found = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			ro.readIndexQueue = ro.readIndexQueue[i:]
0000000000000000000000000000000000000000;;			for _, rs := range rss {
0000000000000000000000000000000000000000;;				delete(ro.pendingReadIndex, string(rs.req.Entries[0].Data))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rss
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lastPendingRequestCtx returns the context of the last pending read only
0000000000000000000000000000000000000000;;	// request in readonly struct.
0000000000000000000000000000000000000000;;	func (ro *readOnly) lastPendingRequestCtx() string {
0000000000000000000000000000000000000000;;		if len(ro.readIndexQueue) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ro.readIndexQueue[len(ro.readIndexQueue)-1]
0000000000000000000000000000000000000000;;	}
