0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/raft/log_unstable.go[Godeps/_workspace/src/github.com/coreos/etcd/raft/log_unstable.go][vendor/github.com/coreos/etcd/raft/log_unstable.go];	
0000000000000000000000000000000000000000;;	package raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import pb "github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unstable.entries[i] has raft log position i+unstable.offset.
0000000000000000000000000000000000000000;;	// Note that unstable.offset may be less than the highest log
0000000000000000000000000000000000000000;;	// position in storage; this means that the next write to storage
0000000000000000000000000000000000000000;;	// might need to truncate the log before persisting unstable.entries.
0000000000000000000000000000000000000000;;	type unstable struct {
0000000000000000000000000000000000000000;;		// the incoming unstable snapshot, if any.
0000000000000000000000000000000000000000;;		snapshot *pb.Snapshot
0000000000000000000000000000000000000000;;		// all entries that have not yet been written to storage.
0000000000000000000000000000000000000000;;		entries []pb.Entry
0000000000000000000000000000000000000000;;		offset  uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logger Logger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeFirstIndex returns the index of the first possible entry in entries
0000000000000000000000000000000000000000;;	// if it has a snapshot.
0000000000000000000000000000000000000000;;	func (u *unstable) maybeFirstIndex() (uint64, bool) {
0000000000000000000000000000000000000000;;		if u.snapshot != nil {
0000000000000000000000000000000000000000;;			return u.snapshot.Metadata.Index + 1, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeLastIndex returns the last index if it has at least one
0000000000000000000000000000000000000000;;	// unstable entry or snapshot.
0000000000000000000000000000000000000000;;	func (u *unstable) maybeLastIndex() (uint64, bool) {
0000000000000000000000000000000000000000;;		if l := len(u.entries); l != 0 {
0000000000000000000000000000000000000000;;			return u.offset + uint64(l) - 1, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.snapshot != nil {
0000000000000000000000000000000000000000;;			return u.snapshot.Metadata.Index, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeTerm returns the term of the entry at index i, if there
0000000000000000000000000000000000000000;;	// is any.
0000000000000000000000000000000000000000;;	func (u *unstable) maybeTerm(i uint64) (uint64, bool) {
0000000000000000000000000000000000000000;;		if i < u.offset {
0000000000000000000000000000000000000000;;			if u.snapshot == nil {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u.snapshot.Metadata.Index == i {
0000000000000000000000000000000000000000;;				return u.snapshot.Metadata.Term, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		last, ok := u.maybeLastIndex()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i > last {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.entries[i-u.offset].Term, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *unstable) stableTo(i, t uint64) {
0000000000000000000000000000000000000000;;		gt, ok := u.maybeTerm(i)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if i < offset, term is matched with the snapshot
0000000000000000000000000000000000000000;;		// only update the unstable entries if term is matched with
0000000000000000000000000000000000000000;;		// an unstable entry.
0000000000000000000000000000000000000000;;		if gt == t && i >= u.offset {
0000000000000000000000000000000000000000;;			u.entries = u.entries[i+1-u.offset:]
0000000000000000000000000000000000000000;;			u.offset = i + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *unstable) stableSnapTo(i uint64) {
0000000000000000000000000000000000000000;;		if u.snapshot != nil && u.snapshot.Metadata.Index == i {
0000000000000000000000000000000000000000;;			u.snapshot = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *unstable) restore(s pb.Snapshot) {
0000000000000000000000000000000000000000;;		u.offset = s.Metadata.Index + 1
0000000000000000000000000000000000000000;;		u.entries = nil
0000000000000000000000000000000000000000;;		u.snapshot = &s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *unstable) truncateAndAppend(ents []pb.Entry) {
0000000000000000000000000000000000000000;;		after := ents[0].Index
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case after == u.offset+uint64(len(u.entries)):
0000000000000000000000000000000000000000;;			// after is the next index in the u.entries
0000000000000000000000000000000000000000;;			// directly append
0000000000000000000000000000000000000000;;			u.entries = append(u.entries, ents...)
0000000000000000000000000000000000000000;;		case after <= u.offset:
0000000000000000000000000000000000000000;;			u.logger.Infof("replace the unstable entries from index %d", after)
0000000000000000000000000000000000000000;;			// The log is being truncated to before our current offset
0000000000000000000000000000000000000000;;			// portion, so set the offset and replace the entries
0000000000000000000000000000000000000000;;			u.offset = after
0000000000000000000000000000000000000000;;			u.entries = ents
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// truncate to after and copy to u.entries
0000000000000000000000000000000000000000;;			// then append
0000000000000000000000000000000000000000;;			u.logger.Infof("truncate the unstable entries before index %d", after)
0000000000000000000000000000000000000000;;			u.entries = append([]pb.Entry{}, u.slice(u.offset, after)...)
0000000000000000000000000000000000000000;;			u.entries = append(u.entries, ents...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *unstable) slice(lo uint64, hi uint64) []pb.Entry {
0000000000000000000000000000000000000000;;		u.mustCheckOutOfBounds(lo, hi)
0000000000000000000000000000000000000000;;		return u.entries[lo-u.offset : hi-u.offset]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// u.offset <= lo <= hi <= u.offset+len(u.offset)
0000000000000000000000000000000000000000;;	func (u *unstable) mustCheckOutOfBounds(lo, hi uint64) {
0000000000000000000000000000000000000000;;		if lo > hi {
0000000000000000000000000000000000000000;;			u.logger.Panicf("invalid unstable.slice %d > %d", lo, hi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		upper := u.offset + uint64(len(u.entries))
0000000000000000000000000000000000000000;;		if lo < u.offset || hi > upper {
0000000000000000000000000000000000000000;;			u.logger.Panicf("unstable.slice[%d,%d) out of bound [%d,%d]", lo, hi, u.offset, upper)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
