0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
9b11e90c65f84c704d29a1c6a5867d26fdba23c5;Godeps/_workspace/src/github.com/coreos/etcd/integration/cluster.go[Godeps/_workspace/src/github.com/coreos/etcd/integration/cluster.go][vendor/github.com/coreos/etcd/integration/cluster.go];	
0000000000000000000000000000000000000000;;	package integration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v2http"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v3rpc"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/testutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/transport"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/rafthttp"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tickDuration   = 10 * time.Millisecond
0000000000000000000000000000000000000000;;		clusterName    = "etcd"
0000000000000000000000000000000000000000;;		requestTimeout = 20 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		basePort     = 21000
0000000000000000000000000000000000000000;;		UrlScheme    = "unix"
0000000000000000000000000000000000000000;;		UrlSchemeTLS = "unixs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		electionTicks = 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// integration test uses unique ports, counting up, to listen for each
0000000000000000000000000000000000000000;;		// member, ensuring restarted members can listen on the same port again.
0000000000000000000000000000000000000000;;		localListenCount int64 = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testTLSInfo = transport.TLSInfo{
0000000000000000000000000000000000000000;;			KeyFile:        "./fixtures/server.key.insecure",
0000000000000000000000000000000000000000;;			CertFile:       "./fixtures/server.crt",
0000000000000000000000000000000000000000;;			TrustedCAFile:  "./fixtures/ca.crt",
0000000000000000000000000000000000000000;;			ClientCertAuth: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog = capnslog.NewPackageLogger("github.com/coreos/etcd", "integration")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterConfig struct {
0000000000000000000000000000000000000000;;		Size              int
0000000000000000000000000000000000000000;;		PeerTLS           *transport.TLSInfo
0000000000000000000000000000000000000000;;		ClientTLS         *transport.TLSInfo
0000000000000000000000000000000000000000;;		DiscoveryURL      string
0000000000000000000000000000000000000000;;		UseGRPC           bool
0000000000000000000000000000000000000000;;		QuotaBackendBytes int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cluster struct {
0000000000000000000000000000000000000000;;		cfg     *ClusterConfig
0000000000000000000000000000000000000000;;		Members []*member
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// manually enable v3 capability since we know the cluster members all support v3.
0000000000000000000000000000000000000000;;		api.EnableCapability(api.V3rpcCapability)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func schemeFromTLSInfo(tls *transport.TLSInfo) string {
0000000000000000000000000000000000000000;;		if tls == nil {
0000000000000000000000000000000000000000;;			return UrlScheme
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return UrlSchemeTLS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) fillClusterForMembers() error {
0000000000000000000000000000000000000000;;		if c.cfg.DiscoveryURL != "" {
0000000000000000000000000000000000000000;;			// cluster will be discovered
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addrs := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			scheme := schemeFromTLSInfo(m.PeerTLSInfo)
0000000000000000000000000000000000000000;;			for _, l := range m.PeerListeners {
0000000000000000000000000000000000000000;;				addrs = append(addrs, fmt.Sprintf("%s=%s://%s", m.Name, scheme, l.Addr().String()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterStr := strings.Join(addrs, ",")
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			m.InitialPeerURLsMap, err = types.NewURLsMap(clusterStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCluster(t *testing.T, cfg *ClusterConfig) *cluster {
0000000000000000000000000000000000000000;;		c := &cluster{cfg: cfg}
0000000000000000000000000000000000000000;;		ms := make([]*member, cfg.Size)
0000000000000000000000000000000000000000;;		for i := 0; i < cfg.Size; i++ {
0000000000000000000000000000000000000000;;			ms[i] = c.mustNewMember(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Members = ms
0000000000000000000000000000000000000000;;		if err := c.fillClusterForMembers(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCluster returns an unlaunched cluster of the given size which has been
0000000000000000000000000000000000000000;;	// set to use static bootstrap.
0000000000000000000000000000000000000000;;	func NewCluster(t *testing.T, size int) *cluster {
0000000000000000000000000000000000000000;;		return newCluster(t, &ClusterConfig{Size: size})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClusterByConfig returns an unlaunched cluster defined by a cluster configuration
0000000000000000000000000000000000000000;;	func NewClusterByConfig(t *testing.T, cfg *ClusterConfig) *cluster {
0000000000000000000000000000000000000000;;		return newCluster(t, cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) Launch(t *testing.T) {
0000000000000000000000000000000000000000;;		errc := make(chan error)
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			// Members are launched in separate goroutines because if they boot
0000000000000000000000000000000000000000;;			// using discovery url, they have to wait for others to register to continue.
0000000000000000000000000000000000000000;;			go func(m *member) {
0000000000000000000000000000000000000000;;				errc <- m.Launch()
0000000000000000000000000000000000000000;;			}(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for range c.Members {
0000000000000000000000000000000000000000;;			if err := <-errc; err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("error setting up member: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// wait cluster to be stable to receive future client requests
0000000000000000000000000000000000000000;;		c.waitMembersMatch(t, c.HTTPMembers())
0000000000000000000000000000000000000000;;		c.waitVersion()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) URL(i int) string {
0000000000000000000000000000000000000000;;		return c.Members[i].ClientURLs[0].String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLs returns a list of all active client URLs in the cluster
0000000000000000000000000000000000000000;;	func (c *cluster) URLs() []string {
0000000000000000000000000000000000000000;;		urls := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-m.s.StopNotify():
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, u := range m.ClientURLs {
0000000000000000000000000000000000000000;;				urls = append(urls, u.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return urls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPMembers returns a list of all active members as client.Members
0000000000000000000000000000000000000000;;	func (c *cluster) HTTPMembers() []client.Member {
0000000000000000000000000000000000000000;;		ms := []client.Member{}
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			pScheme := schemeFromTLSInfo(m.PeerTLSInfo)
0000000000000000000000000000000000000000;;			cScheme := schemeFromTLSInfo(m.ClientTLSInfo)
0000000000000000000000000000000000000000;;			cm := client.Member{Name: m.Name}
0000000000000000000000000000000000000000;;			for _, ln := range m.PeerListeners {
0000000000000000000000000000000000000000;;				cm.PeerURLs = append(cm.PeerURLs, pScheme+"://"+ln.Addr().String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ln := range m.ClientListeners {
0000000000000000000000000000000000000000;;				cm.ClientURLs = append(cm.ClientURLs, cScheme+"://"+ln.Addr().String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ms = append(ms, cm)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ms
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) mustNewMember(t *testing.T) *member {
0000000000000000000000000000000000000000;;		m := mustNewMember(t,
0000000000000000000000000000000000000000;;			memberConfig{
0000000000000000000000000000000000000000;;				name:              c.name(rand.Int()),
0000000000000000000000000000000000000000;;				peerTLS:           c.cfg.PeerTLS,
0000000000000000000000000000000000000000;;				clientTLS:         c.cfg.ClientTLS,
0000000000000000000000000000000000000000;;				quotaBackendBytes: c.cfg.QuotaBackendBytes,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		m.DiscoveryURL = c.cfg.DiscoveryURL
0000000000000000000000000000000000000000;;		if c.cfg.UseGRPC {
0000000000000000000000000000000000000000;;			if err := m.listenGRPC(); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) addMember(t *testing.T) {
0000000000000000000000000000000000000000;;		m := c.mustNewMember(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := schemeFromTLSInfo(c.cfg.PeerTLS)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// send add request to the cluster
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := 0; i < len(c.Members); i++ {
0000000000000000000000000000000000000000;;			clientURL := c.URL(i)
0000000000000000000000000000000000000000;;			peerURL := scheme + "://" + m.PeerListeners[0].Addr().String()
0000000000000000000000000000000000000000;;			if err = c.addMemberByURL(t, clientURL, peerURL); err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("add member failed on all members error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.InitialPeerURLsMap = types.URLsMap{}
0000000000000000000000000000000000000000;;		for _, mm := range c.Members {
0000000000000000000000000000000000000000;;			m.InitialPeerURLsMap[mm.Name] = mm.PeerURLs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.InitialPeerURLsMap[m.Name] = m.PeerURLs
0000000000000000000000000000000000000000;;		m.NewCluster = false
0000000000000000000000000000000000000000;;		if err := m.Launch(); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Members = append(c.Members, m)
0000000000000000000000000000000000000000;;		// wait cluster to be stable to receive future client requests
0000000000000000000000000000000000000000;;		c.waitMembersMatch(t, c.HTTPMembers())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) addMemberByURL(t *testing.T, clientURL, peerURL string) error {
0000000000000000000000000000000000000000;;		cc := MustNewHTTPClient(t, []string{clientURL}, c.cfg.ClientTLS)
0000000000000000000000000000000000000000;;		ma := client.NewMembersAPI(cc)
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), requestTimeout)
0000000000000000000000000000000000000000;;		if _, err := ma.Add(ctx, peerURL); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for the add node entry applied in the cluster
0000000000000000000000000000000000000000;;		members := append(c.HTTPMembers(), client.Member{PeerURLs: []string{peerURL}, ClientURLs: []string{}})
0000000000000000000000000000000000000000;;		c.waitMembersMatch(t, members)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) AddMember(t *testing.T) {
0000000000000000000000000000000000000000;;		c.addMember(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) RemoveMember(t *testing.T, id uint64) {
0000000000000000000000000000000000000000;;		if err := c.removeMember(t, id); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) removeMember(t *testing.T, id uint64) error {
0000000000000000000000000000000000000000;;		// send remove request to the cluster
0000000000000000000000000000000000000000;;		cc := MustNewHTTPClient(t, c.URLs(), c.cfg.ClientTLS)
0000000000000000000000000000000000000000;;		ma := client.NewMembersAPI(cc)
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithTimeout(context.Background(), requestTimeout)
0000000000000000000000000000000000000000;;		if err := ma.Remove(ctx, types.ID(id).String()); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cancel()
0000000000000000000000000000000000000000;;		newMembers := make([]*member, 0)
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			if uint64(m.s.ID()) != id {
0000000000000000000000000000000000000000;;				newMembers = append(newMembers, m)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-m.s.StopNotify():
0000000000000000000000000000000000000000;;					m.Terminate(t)
0000000000000000000000000000000000000000;;				// 1s stop delay + election timeout + 1s disk and network delay + connection write timeout
0000000000000000000000000000000000000000;;				// TODO: remove connection write timeout by selecting on http response closeNotifier
0000000000000000000000000000000000000000;;				// blocking on https://github.com/golang/go/issues/9524
0000000000000000000000000000000000000000;;				case <-time.After(time.Second + time.Duration(electionTicks)*tickDuration + time.Second + rafthttp.ConnWriteTimeout):
0000000000000000000000000000000000000000;;					t.Fatalf("failed to remove member %s in time", m.s.ID())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Members = newMembers
0000000000000000000000000000000000000000;;		c.waitMembersMatch(t, c.HTTPMembers())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) Terminate(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			m.Terminate(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) waitMembersMatch(t *testing.T, membs []client.Member) {
0000000000000000000000000000000000000000;;		for _, u := range c.URLs() {
0000000000000000000000000000000000000000;;			cc := MustNewHTTPClient(t, []string{u}, c.cfg.ClientTLS)
0000000000000000000000000000000000000000;;			ma := client.NewMembersAPI(cc)
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				ctx, cancel := context.WithTimeout(context.Background(), requestTimeout)
0000000000000000000000000000000000000000;;				ms, err := ma.List(ctx)
0000000000000000000000000000000000000000;;				cancel()
0000000000000000000000000000000000000000;;				if err == nil && isMembersEqual(ms, membs) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(tickDuration)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) WaitLeader(t *testing.T) int { return c.waitLeader(t, c.Members) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitLeader waits until given members agree on the same leader.
0000000000000000000000000000000000000000;;	func (c *cluster) waitLeader(t *testing.T, membs []*member) int {
0000000000000000000000000000000000000000;;		possibleLead := make(map[uint64]bool)
0000000000000000000000000000000000000000;;		var lead uint64
0000000000000000000000000000000000000000;;		for _, m := range membs {
0000000000000000000000000000000000000000;;			possibleLead[uint64(m.s.ID())] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for lead == 0 || !possibleLead[lead] {
0000000000000000000000000000000000000000;;			lead = 0
0000000000000000000000000000000000000000;;			for _, m := range membs {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-m.s.StopNotify():
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if lead != 0 && lead != m.s.Lead() {
0000000000000000000000000000000000000000;;					lead = 0
0000000000000000000000000000000000000000;;					time.Sleep(10 * tickDuration)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lead = m.s.Lead()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, m := range membs {
0000000000000000000000000000000000000000;;			if uint64(m.s.ID()) == lead {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) WaitNoLeader(t *testing.T) { c.waitNoLeader(t, c.Members) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitNoLeader waits until given members lose leader.
0000000000000000000000000000000000000000;;	func (c *cluster) waitNoLeader(t *testing.T, membs []*member) {
0000000000000000000000000000000000000000;;		noLeader := false
0000000000000000000000000000000000000000;;		for !noLeader {
0000000000000000000000000000000000000000;;			noLeader = true
0000000000000000000000000000000000000000;;			for _, m := range membs {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-m.s.StopNotify():
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if m.s.Lead() != 0 {
0000000000000000000000000000000000000000;;					noLeader = false
0000000000000000000000000000000000000000;;					time.Sleep(10 * tickDuration)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) waitVersion() {
0000000000000000000000000000000000000000;;		for _, m := range c.Members {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if m.s.ClusterVersion() != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(tickDuration)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cluster) name(i int) string {
0000000000000000000000000000000000000000;;		return fmt.Sprint(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isMembersEqual checks whether two members equal except ID field.
0000000000000000000000000000000000000000;;	// The given wmembs should always set ID field to empty string.
0000000000000000000000000000000000000000;;	func isMembersEqual(membs []client.Member, wmembs []client.Member) bool {
0000000000000000000000000000000000000000;;		sort.Sort(SortableMemberSliceByPeerURLs(membs))
0000000000000000000000000000000000000000;;		sort.Sort(SortableMemberSliceByPeerURLs(wmembs))
0000000000000000000000000000000000000000;;		for i := range membs {
0000000000000000000000000000000000000000;;			membs[i].ID = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(membs, wmembs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLocalListener(t *testing.T) net.Listener {
0000000000000000000000000000000000000000;;		c := atomic.AddInt64(&localListenCount, 1)
0000000000000000000000000000000000000000;;		// Go 1.8+ allows only numbers in port
0000000000000000000000000000000000000000;;		addr := fmt.Sprintf("127.0.0.1:%05d%05d", c+basePort, os.Getpid())
0000000000000000000000000000000000000000;;		return NewListenerWithAddr(t, addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewListenerWithAddr(t *testing.T, addr string) net.Listener {
0000000000000000000000000000000000000000;;		l, err := transport.NewUnixListener(addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type member struct {
0000000000000000000000000000000000000000;;		etcdserver.ServerConfig
0000000000000000000000000000000000000000;;		PeerListeners, ClientListeners []net.Listener
0000000000000000000000000000000000000000;;		grpcListener                   net.Listener
0000000000000000000000000000000000000000;;		// PeerTLSInfo enables peer TLS when set
0000000000000000000000000000000000000000;;		PeerTLSInfo *transport.TLSInfo
0000000000000000000000000000000000000000;;		// ClientTLSInfo enables client TLS when set
0000000000000000000000000000000000000000;;		ClientTLSInfo *transport.TLSInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raftHandler *testutil.PauseableHandler
0000000000000000000000000000000000000000;;		s           *etcdserver.EtcdServer
0000000000000000000000000000000000000000;;		hss         []*httptest.Server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		grpcServer *grpc.Server
0000000000000000000000000000000000000000;;		grpcAddr   string
0000000000000000000000000000000000000000;;		grpcBridge *bridge
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keepDataDirTerminate bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *member) GRPCAddr() string { return m.grpcAddr }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type memberConfig struct {
0000000000000000000000000000000000000000;;		name              string
0000000000000000000000000000000000000000;;		peerTLS           *transport.TLSInfo
0000000000000000000000000000000000000000;;		clientTLS         *transport.TLSInfo
0000000000000000000000000000000000000000;;		quotaBackendBytes int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mustNewMember return an inited member with the given name. If peerTLS is
0000000000000000000000000000000000000000;;	// set, it will use https scheme to communicate between peers.
0000000000000000000000000000000000000000;;	func mustNewMember(t *testing.T, mcfg memberConfig) *member {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		m := &member{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		peerScheme := schemeFromTLSInfo(mcfg.peerTLS)
0000000000000000000000000000000000000000;;		clientScheme := schemeFromTLSInfo(mcfg.clientTLS)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pln := newLocalListener(t)
0000000000000000000000000000000000000000;;		m.PeerListeners = []net.Listener{pln}
0000000000000000000000000000000000000000;;		m.PeerURLs, err = types.NewURLs([]string{peerScheme + "://" + pln.Addr().String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.PeerTLSInfo = mcfg.peerTLS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cln := newLocalListener(t)
0000000000000000000000000000000000000000;;		m.ClientListeners = []net.Listener{cln}
0000000000000000000000000000000000000000;;		m.ClientURLs, err = types.NewURLs([]string{clientScheme + "://" + cln.Addr().String()})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.ClientTLSInfo = mcfg.clientTLS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.Name = mcfg.name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.DataDir, err = ioutil.TempDir(os.TempDir(), "etcd")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterStr := fmt.Sprintf("%s=%s://%s", mcfg.name, peerScheme, pln.Addr().String())
0000000000000000000000000000000000000000;;		m.InitialPeerURLsMap, err = types.NewURLsMap(clusterStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.InitialClusterToken = clusterName
0000000000000000000000000000000000000000;;		m.NewCluster = true
0000000000000000000000000000000000000000;;		m.BootstrapTimeout = 10 * time.Millisecond
0000000000000000000000000000000000000000;;		if m.PeerTLSInfo != nil {
0000000000000000000000000000000000000000;;			m.ServerConfig.PeerTLSInfo = *m.PeerTLSInfo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.ElectionTicks = electionTicks
0000000000000000000000000000000000000000;;		m.TickMs = uint(tickDuration / time.Millisecond)
0000000000000000000000000000000000000000;;		m.QuotaBackendBytes = mcfg.quotaBackendBytes
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listenGRPC starts a grpc server over a unix domain socket on the member
0000000000000000000000000000000000000000;;	func (m *member) listenGRPC() error {
0000000000000000000000000000000000000000;;		// prefix with localhost so cert has right domain
0000000000000000000000000000000000000000;;		m.grpcAddr = "localhost:" + m.Name
0000000000000000000000000000000000000000;;		l, err := transport.NewUnixListener(m.grpcAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("listen failed on grpc socket %s (%v)", m.grpcAddr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.grpcBridge, err = newBridge(m.grpcAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			l.Close()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.grpcAddr = m.grpcBridge.URL()
0000000000000000000000000000000000000000;;		m.grpcListener = l
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *member) electionTimeout() time.Duration {
0000000000000000000000000000000000000000;;		return time.Duration(m.s.Cfg.ElectionTicks) * time.Millisecond
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *member) DropConnections() { m.grpcBridge.Reset() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientV3 creates a new grpc client connection to the member
0000000000000000000000000000000000000000;;	func NewClientV3(m *member) (*clientv3.Client, error) {
0000000000000000000000000000000000000000;;		if m.grpcAddr == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("member not configured for grpc")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := clientv3.Config{
0000000000000000000000000000000000000000;;			Endpoints:   []string{m.grpcAddr},
0000000000000000000000000000000000000000;;			DialTimeout: 5 * time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.ClientTLSInfo != nil {
0000000000000000000000000000000000000000;;			tls, err := m.ClientTLSInfo.ClientConfig()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cfg.TLS = tls
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newClientV3(cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clone returns a member with the same server configuration. The returned
0000000000000000000000000000000000000000;;	// member will not set PeerListeners and ClientListeners.
0000000000000000000000000000000000000000;;	func (m *member) Clone(t *testing.T) *member {
0000000000000000000000000000000000000000;;		mm := &member{}
0000000000000000000000000000000000000000;;		mm.ServerConfig = m.ServerConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		clientURLStrs := m.ClientURLs.StringSlice()
0000000000000000000000000000000000000000;;		mm.ClientURLs, err = types.NewURLs(clientURLStrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// this should never fail
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		peerURLStrs := m.PeerURLs.StringSlice()
0000000000000000000000000000000000000000;;		mm.PeerURLs, err = types.NewURLs(peerURLStrs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// this should never fail
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clusterStr := m.InitialPeerURLsMap.String()
0000000000000000000000000000000000000000;;		mm.InitialPeerURLsMap, err = types.NewURLsMap(clusterStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// this should never fail
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mm.InitialClusterToken = m.InitialClusterToken
0000000000000000000000000000000000000000;;		mm.ElectionTicks = m.ElectionTicks
0000000000000000000000000000000000000000;;		mm.PeerTLSInfo = m.PeerTLSInfo
0000000000000000000000000000000000000000;;		mm.ClientTLSInfo = m.ClientTLSInfo
0000000000000000000000000000000000000000;;		return mm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Launch starts a member based on ServerConfig, PeerListeners
0000000000000000000000000000000000000000;;	// and ClientListeners.
0000000000000000000000000000000000000000;;	func (m *member) Launch() error {
0000000000000000000000000000000000000000;;		plog.Printf("launching %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if m.s, err = etcdserver.NewServer(&m.ServerConfig); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to initialize the etcd server: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.s.SyncTicker = time.Tick(500 * time.Millisecond)
0000000000000000000000000000000000000000;;		m.s.Start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.raftHandler = &testutil.PauseableHandler{Next: v2http.NewPeerHandler(m.s)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ln := range m.PeerListeners {
0000000000000000000000000000000000000000;;			hs := &httptest.Server{
0000000000000000000000000000000000000000;;				Listener: ln,
0000000000000000000000000000000000000000;;				Config:   &http.Server{Handler: m.raftHandler},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if m.PeerTLSInfo == nil {
0000000000000000000000000000000000000000;;				hs.Start()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hs.TLS, err = m.PeerTLSInfo.ServerConfig()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				hs.StartTLS()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.hss = append(m.hss, hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ln := range m.ClientListeners {
0000000000000000000000000000000000000000;;			hs := &httptest.Server{
0000000000000000000000000000000000000000;;				Listener: ln,
0000000000000000000000000000000000000000;;				Config:   &http.Server{Handler: v2http.NewClientHandler(m.s, m.ServerConfig.ReqTimeout())},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if m.ClientTLSInfo == nil {
0000000000000000000000000000000000000000;;				hs.Start()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hs.TLS, err = m.ClientTLSInfo.ServerConfig()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				hs.StartTLS()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.hss = append(m.hss, hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.grpcListener != nil {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				tlscfg *tls.Config
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			if m.ClientTLSInfo != nil && !m.ClientTLSInfo.Empty() {
0000000000000000000000000000000000000000;;				tlscfg, err = m.ClientTLSInfo.ServerConfig()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.grpcServer = v3rpc.Server(m.s, tlscfg)
0000000000000000000000000000000000000000;;			go m.grpcServer.Serve(m.grpcListener)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Printf("launched %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *member) WaitOK(t *testing.T) {
0000000000000000000000000000000000000000;;		cc := MustNewHTTPClient(t, []string{m.URL()}, m.ClientTLSInfo)
0000000000000000000000000000000000000000;;		kapi := client.NewKeysAPI(cc)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ctx, cancel := context.WithTimeout(context.Background(), requestTimeout)
0000000000000000000000000000000000000000;;			_, err := kapi.Get(ctx, "/", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				time.Sleep(tickDuration)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for m.s.Leader() == 0 {
0000000000000000000000000000000000000000;;			time.Sleep(tickDuration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *member) URL() string { return m.ClientURLs[0].String() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *member) Pause() {
0000000000000000000000000000000000000000;;		m.raftHandler.Pause()
0000000000000000000000000000000000000000;;		m.s.PauseSending()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *member) Resume() {
0000000000000000000000000000000000000000;;		m.raftHandler.Resume()
0000000000000000000000000000000000000000;;		m.s.ResumeSending()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close stops the member's etcdserver and closes its connections
0000000000000000000000000000000000000000;;	func (m *member) Close() {
0000000000000000000000000000000000000000;;		if m.grpcBridge != nil {
0000000000000000000000000000000000000000;;			m.grpcBridge.Close()
0000000000000000000000000000000000000000;;			m.grpcBridge = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.grpcServer != nil {
0000000000000000000000000000000000000000;;			m.grpcServer.Stop()
0000000000000000000000000000000000000000;;			m.grpcServer = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.s.HardStop()
0000000000000000000000000000000000000000;;		for _, hs := range m.hss {
0000000000000000000000000000000000000000;;			hs.CloseClientConnections()
0000000000000000000000000000000000000000;;			hs.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the member, but the data dir of the member is preserved.
0000000000000000000000000000000000000000;;	func (m *member) Stop(t *testing.T) {
0000000000000000000000000000000000000000;;		plog.Printf("stopping %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;		m.Close()
0000000000000000000000000000000000000000;;		m.hss = nil
0000000000000000000000000000000000000000;;		plog.Printf("stopped %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkLeaderTransition waits for leader transition, returning the new leader ID.
0000000000000000000000000000000000000000;;	func checkLeaderTransition(t *testing.T, m *member, oldLead uint64) uint64 {
0000000000000000000000000000000000000000;;		interval := time.Duration(m.s.Cfg.TickMs) * time.Millisecond
0000000000000000000000000000000000000000;;		for m.s.Lead() == 0 || (m.s.Lead() == oldLead) {
0000000000000000000000000000000000000000;;			time.Sleep(interval)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.s.Lead()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StopNotify unblocks when a member stop completes
0000000000000000000000000000000000000000;;	func (m *member) StopNotify() <-chan struct{} {
0000000000000000000000000000000000000000;;		return m.s.StopNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Restart starts the member using the preserved data dir.
0000000000000000000000000000000000000000;;	func (m *member) Restart(t *testing.T) error {
0000000000000000000000000000000000000000;;		plog.Printf("restarting %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;		newPeerListeners := make([]net.Listener, 0)
0000000000000000000000000000000000000000;;		for _, ln := range m.PeerListeners {
0000000000000000000000000000000000000000;;			newPeerListeners = append(newPeerListeners, NewListenerWithAddr(t, ln.Addr().String()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.PeerListeners = newPeerListeners
0000000000000000000000000000000000000000;;		newClientListeners := make([]net.Listener, 0)
0000000000000000000000000000000000000000;;		for _, ln := range m.ClientListeners {
0000000000000000000000000000000000000000;;			newClientListeners = append(newClientListeners, NewListenerWithAddr(t, ln.Addr().String()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.ClientListeners = newClientListeners
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.grpcListener != nil {
0000000000000000000000000000000000000000;;			if err := m.listenGRPC(); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := m.Launch()
0000000000000000000000000000000000000000;;		plog.Printf("restarted %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Terminate stops the member and removes the data dir.
0000000000000000000000000000000000000000;;	func (m *member) Terminate(t *testing.T) {
0000000000000000000000000000000000000000;;		plog.Printf("terminating %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;		m.Close()
0000000000000000000000000000000000000000;;		if !m.keepDataDirTerminate {
0000000000000000000000000000000000000000;;			if err := os.RemoveAll(m.ServerConfig.DataDir); err != nil {
0000000000000000000000000000000000000000;;				t.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Printf("terminated %s (%s)", m.Name, m.grpcAddr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Metric gets the metric value for a member
0000000000000000000000000000000000000000;;	func (m *member) Metric(metricName string) (string, error) {
0000000000000000000000000000000000000000;;		cfgtls := transport.TLSInfo{}
0000000000000000000000000000000000000000;;		tr, err := transport.NewTimeoutTransport(cfgtls, time.Second, time.Second, time.Second)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cli := &http.Client{Transport: tr}
0000000000000000000000000000000000000000;;		resp, err := cli.Get(m.ClientURLs[0].String() + "/metrics")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		b, rerr := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if rerr != nil {
0000000000000000000000000000000000000000;;			return "", rerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lines := strings.Split(string(b), "\n")
0000000000000000000000000000000000000000;;		for _, l := range lines {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(l, metricName) {
0000000000000000000000000000000000000000;;				return strings.Split(l, " ")[1], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InjectPartition drops connections from m to others, vice versa.
0000000000000000000000000000000000000000;;	func (m *member) InjectPartition(t *testing.T, others []*member) {
0000000000000000000000000000000000000000;;		for _, other := range others {
0000000000000000000000000000000000000000;;			m.s.CutPeer(other.s.ID())
0000000000000000000000000000000000000000;;			other.s.CutPeer(m.s.ID())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecoverPartition recovers connections from m to others, vice versa.
0000000000000000000000000000000000000000;;	func (m *member) RecoverPartition(t *testing.T, others []*member) {
0000000000000000000000000000000000000000;;		for _, other := range others {
0000000000000000000000000000000000000000;;			m.s.MendPeer(other.s.ID())
0000000000000000000000000000000000000000;;			other.s.MendPeer(m.s.ID())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MustNewHTTPClient(t *testing.T, eps []string, tls *transport.TLSInfo) client.Client {
0000000000000000000000000000000000000000;;		cfgtls := transport.TLSInfo{}
0000000000000000000000000000000000000000;;		if tls != nil {
0000000000000000000000000000000000000000;;			cfgtls = *tls
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg := client.Config{Transport: mustNewTransport(t, cfgtls), Endpoints: eps}
0000000000000000000000000000000000000000;;		c, err := client.New(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustNewTransport(t *testing.T, tlsInfo transport.TLSInfo) *http.Transport {
0000000000000000000000000000000000000000;;		// tick in integration test is short, so 1s dial timeout could play well.
0000000000000000000000000000000000000000;;		tr, err := transport.NewTimeoutTransport(tlsInfo, time.Second, rafthttp.ConnReadTimeout, rafthttp.ConnWriteTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SortableMemberSliceByPeerURLs []client.Member
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p SortableMemberSliceByPeerURLs) Len() int { return len(p) }
0000000000000000000000000000000000000000;;	func (p SortableMemberSliceByPeerURLs) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return p[i].PeerURLs[0] < p[j].PeerURLs[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (p SortableMemberSliceByPeerURLs) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClusterV3 struct {
0000000000000000000000000000000000000000;;		*cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		clients []*clientv3.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClusterV3 returns a launched cluster with a grpc client connection
0000000000000000000000000000000000000000;;	// for each cluster member.
0000000000000000000000000000000000000000;;	func NewClusterV3(t *testing.T, cfg *ClusterConfig) *ClusterV3 {
0000000000000000000000000000000000000000;;		cfg.UseGRPC = true
0000000000000000000000000000000000000000;;		clus := &ClusterV3{
0000000000000000000000000000000000000000;;			cluster: NewClusterByConfig(t, cfg),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clus.Launch(t)
0000000000000000000000000000000000000000;;		for _, m := range clus.Members {
0000000000000000000000000000000000000000;;			client, err := NewClientV3(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("cannot create client: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clus.clients = append(clus.clients, client)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClusterV3) TakeClient(idx int) {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		c.clients[idx] = nil
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClusterV3) Terminate(t *testing.T) {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		for _, client := range c.clients {
0000000000000000000000000000000000000000;;			if client == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := client.Close(); err != nil {
0000000000000000000000000000000000000000;;				t.Error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;		c.cluster.Terminate(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClusterV3) RandClient() *clientv3.Client {
0000000000000000000000000000000000000000;;		return c.clients[rand.Intn(len(c.clients))]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClusterV3) Client(i int) *clientv3.Client {
0000000000000000000000000000000000000000;;		return c.clients[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type grpcAPI struct {
0000000000000000000000000000000000000000;;		// Cluster is the cluster API for the client's connection.
0000000000000000000000000000000000000000;;		Cluster pb.ClusterClient
0000000000000000000000000000000000000000;;		// KV is the keyvalue API for the client's connection.
0000000000000000000000000000000000000000;;		KV pb.KVClient
0000000000000000000000000000000000000000;;		// Lease is the lease API for the client's connection.
0000000000000000000000000000000000000000;;		Lease pb.LeaseClient
0000000000000000000000000000000000000000;;		// Watch is the watch API for the client's connection.
0000000000000000000000000000000000000000;;		Watch pb.WatchClient
0000000000000000000000000000000000000000;;		// Maintenance is the maintenance API for the client's connection.
0000000000000000000000000000000000000000;;		Maintenance pb.MaintenanceClient
0000000000000000000000000000000000000000;;		// Auth is the authentication API for the client's connection.
0000000000000000000000000000000000000000;;		Auth pb.AuthClient
0000000000000000000000000000000000000000;;	}
