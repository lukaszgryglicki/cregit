0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	package integration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/transport"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bridge creates a unix socket bridge to another unix socket, making it possible
0000000000000000000000000000000000000000;;	// to disconnect grpc network connections without closing the logical grpc connection.
0000000000000000000000000000000000000000;;	type bridge struct {
0000000000000000000000000000000000000000;;		inaddr  string
0000000000000000000000000000000000000000;;		outaddr string
0000000000000000000000000000000000000000;;		l       net.Listener
0000000000000000000000000000000000000000;;		conns   map[*bridgeConn]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopc chan struct{}
0000000000000000000000000000000000000000;;		wg    sync.WaitGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBridge(addr string) (*bridge, error) {
0000000000000000000000000000000000000000;;		b := &bridge{
0000000000000000000000000000000000000000;;			// bridge "port" is ("%05d%05d0", port, pid) since go1.8 expects the port to be a number
0000000000000000000000000000000000000000;;			inaddr:  addr + "0",
0000000000000000000000000000000000000000;;			outaddr: addr,
0000000000000000000000000000000000000000;;			conns:   make(map[*bridgeConn]struct{}),
0000000000000000000000000000000000000000;;			stopc:   make(chan struct{}, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l, err := transport.NewUnixListener(b.inaddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("listen failed on socket %s (%v)", addr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.l = l
0000000000000000000000000000000000000000;;		b.wg.Add(1)
0000000000000000000000000000000000000000;;		go b.serveListen()
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *bridge) URL() string { return "unix://" + b.inaddr }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *bridge) Close() {
0000000000000000000000000000000000000000;;		b.l.Close()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case b.stopc <- struct{}{}:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *bridge) Reset() {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		for bc := range b.conns {
0000000000000000000000000000000000000000;;			bc.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.conns = make(map[*bridgeConn]struct{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *bridge) serveListen() {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			b.l.Close()
0000000000000000000000000000000000000000;;			b.mu.Lock()
0000000000000000000000000000000000000000;;			for bc := range b.conns {
0000000000000000000000000000000000000000;;				bc.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.mu.Unlock()
0000000000000000000000000000000000000000;;			b.wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			inc, ierr := b.l.Accept()
0000000000000000000000000000000000000000;;			if ierr != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outc, oerr := net.Dial("unix", b.outaddr)
0000000000000000000000000000000000000000;;			if oerr != nil {
0000000000000000000000000000000000000000;;				inc.Close()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			bc := &bridgeConn{inc, outc}
0000000000000000000000000000000000000000;;			b.wg.Add(1)
0000000000000000000000000000000000000000;;			b.mu.Lock()
0000000000000000000000000000000000000000;;			b.conns[bc] = struct{}{}
0000000000000000000000000000000000000000;;			go b.serveConn(bc)
0000000000000000000000000000000000000000;;			b.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *bridge) serveConn(bc *bridgeConn) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			bc.Close()
0000000000000000000000000000000000000000;;			b.mu.Lock()
0000000000000000000000000000000000000000;;			delete(b.conns, bc)
0000000000000000000000000000000000000000;;			b.mu.Unlock()
0000000000000000000000000000000000000000;;			b.wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(2)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			io.Copy(bc.out, bc.in)
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			io.Copy(bc.in, bc.out)
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bridgeConn struct {
0000000000000000000000000000000000000000;;		in  net.Conn
0000000000000000000000000000000000000000;;		out net.Conn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (bc *bridgeConn) Close() {
0000000000000000000000000000000000000000;;		bc.in.Close()
0000000000000000000000000000000000000000;;		bc.out.Close()
0000000000000000000000000000000000000000;;	}
