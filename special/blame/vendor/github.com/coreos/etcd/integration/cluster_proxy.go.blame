0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	// +build cluster_proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package integration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/clientv3"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/proxy/grpcproxy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		pmu     sync.Mutex
0000000000000000000000000000000000000000;;		proxies map[*clientv3.Client]grpcClientProxy = make(map[*clientv3.Client]grpcClientProxy)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type grpcClientProxy struct {
0000000000000000000000000000000000000000;;		grpc    grpcAPI
0000000000000000000000000000000000000000;;		wdonec  <-chan struct{}
0000000000000000000000000000000000000000;;		kvdonec <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toGRPC(c *clientv3.Client) grpcAPI {
0000000000000000000000000000000000000000;;		pmu.Lock()
0000000000000000000000000000000000000000;;		defer pmu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v, ok := proxies[c]; ok {
0000000000000000000000000000000000000000;;			return v.grpc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wp, wpch := grpcproxy.NewWatchProxy(c)
0000000000000000000000000000000000000000;;		kvp, kvpch := grpcproxy.NewKvProxy(c)
0000000000000000000000000000000000000000;;		grpc := grpcAPI{
0000000000000000000000000000000000000000;;			pb.NewClusterClient(c.ActiveConnection()),
0000000000000000000000000000000000000000;;			grpcproxy.KvServerToKvClient(kvp),
0000000000000000000000000000000000000000;;			pb.NewLeaseClient(c.ActiveConnection()),
0000000000000000000000000000000000000000;;			grpcproxy.WatchServerToWatchClient(wp),
0000000000000000000000000000000000000000;;			pb.NewMaintenanceClient(c.ActiveConnection()),
0000000000000000000000000000000000000000;;			pb.NewAuthClient(c.ActiveConnection()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxies[c] = grpcClientProxy{grpc: grpc, wdonec: wpch, kvdonec: kvpch}
0000000000000000000000000000000000000000;;		return grpc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type proxyCloser struct {
0000000000000000000000000000000000000000;;		clientv3.Watcher
0000000000000000000000000000000000000000;;		wdonec  <-chan struct{}
0000000000000000000000000000000000000000;;		kvdonec <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pc *proxyCloser) Close() error {
0000000000000000000000000000000000000000;;		// client ctx is canceled before calling close, so kv will close out
0000000000000000000000000000000000000000;;		<-pc.kvdonec
0000000000000000000000000000000000000000;;		err := pc.Watcher.Close()
0000000000000000000000000000000000000000;;		<-pc.wdonec
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClientV3(cfg clientv3.Config) (*clientv3.Client, error) {
0000000000000000000000000000000000000000;;		c, err := clientv3.New(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rpc := toGRPC(c)
0000000000000000000000000000000000000000;;		c.KV = clientv3.NewKVFromKVClient(rpc.KV)
0000000000000000000000000000000000000000;;		pmu.Lock()
0000000000000000000000000000000000000000;;		c.Watcher = &proxyCloser{
0000000000000000000000000000000000000000;;			Watcher: clientv3.NewWatchFromWatchClient(rpc.Watch),
0000000000000000000000000000000000000000;;			wdonec:  proxies[c].wdonec,
0000000000000000000000000000000000000000;;			kvdonec: proxies[c].kvdonec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pmu.Unlock()
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
