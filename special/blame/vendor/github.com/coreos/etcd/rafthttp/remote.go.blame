0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/remote.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/remote.go][vendor/github.com/coreos/etcd/rafthttp/remote.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type remote struct {
0000000000000000000000000000000000000000;;		id       types.ID
0000000000000000000000000000000000000000;;		status   *peerStatus
0000000000000000000000000000000000000000;;		pipeline *pipeline
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startRemote(tr *Transport, urls types.URLs, id types.ID) *remote {
0000000000000000000000000000000000000000;;		picker := newURLPicker(urls)
0000000000000000000000000000000000000000;;		status := newPeerStatus(id)
0000000000000000000000000000000000000000;;		pipeline := &pipeline{
0000000000000000000000000000000000000000;;			peerID: id,
0000000000000000000000000000000000000000;;			tr:     tr,
0000000000000000000000000000000000000000;;			picker: picker,
0000000000000000000000000000000000000000;;			status: status,
0000000000000000000000000000000000000000;;			raft:   tr.Raft,
0000000000000000000000000000000000000000;;			errorc: tr.ErrorC,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pipeline.start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &remote{
0000000000000000000000000000000000000000;;			id:       id,
0000000000000000000000000000000000000000;;			status:   status,
0000000000000000000000000000000000000000;;			pipeline: pipeline,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *remote) send(m raftpb.Message) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case g.pipeline.msgc <- m:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if g.status.isActive() {
0000000000000000000000000000000000000000;;				plog.MergeWarningf("dropped internal raft message to %s since sending buffer is full (bad/overloaded network)", g.id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Debugf("dropped %s to %s since sending buffer is full", m.Type, g.id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *remote) stop() {
0000000000000000000000000000000000000000;;		g.pipeline.stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *remote) Pause() {
0000000000000000000000000000000000000000;;		g.stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *remote) Resume() {
0000000000000000000000000000000000000000;;		g.pipeline.start()
0000000000000000000000000000000000000000;;	}
