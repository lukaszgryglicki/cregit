0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/msgappv2.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/msgappv2.go][vendor/github.com/coreos/etcd/rafthttp/msgappv2_codec.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/stats"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		msgTypeLinkHeartbeat uint8 = 0
0000000000000000000000000000000000000000;;		msgTypeAppEntries    uint8 = 1
0000000000000000000000000000000000000000;;		msgTypeApp           uint8 = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgAppV2BufSize = 1024 * 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// msgappv2 stream sends three types of message: linkHeartbeatMessage,
0000000000000000000000000000000000000000;;	// AppEntries and MsgApp. AppEntries is the MsgApp that is sent in
0000000000000000000000000000000000000000;;	// replicate state in raft, whose index and term are fully predictable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Data format of linkHeartbeatMessage:
0000000000000000000000000000000000000000;;	// | offset | bytes | description |
0000000000000000000000000000000000000000;;	// +--------+-------+-------------+
0000000000000000000000000000000000000000;;	// | 0      | 1     | \x00        |
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Data format of AppEntries:
0000000000000000000000000000000000000000;;	// | offset | bytes | description |
0000000000000000000000000000000000000000;;	// +--------+-------+-------------+
0000000000000000000000000000000000000000;;	// | 0      | 1     | \x01        |
0000000000000000000000000000000000000000;;	// | 1      | 8     | length of entries |
0000000000000000000000000000000000000000;;	// | 9      | 8     | length of first entry |
0000000000000000000000000000000000000000;;	// | 17     | n1    | first entry |
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	// | x      | 8     | length of k-th entry data |
0000000000000000000000000000000000000000;;	// | x+8    | nk    | k-th entry data |
0000000000000000000000000000000000000000;;	// | x+8+nk | 8     | commit index |
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Data format of MsgApp:
0000000000000000000000000000000000000000;;	// | offset | bytes | description |
0000000000000000000000000000000000000000;;	// +--------+-------+-------------+
0000000000000000000000000000000000000000;;	// | 0      | 1     | \x02        |
0000000000000000000000000000000000000000;;	// | 1      | 8     | length of encoded message |
0000000000000000000000000000000000000000;;	// | 9      | n     | encoded message |
0000000000000000000000000000000000000000;;	type msgAppV2Encoder struct {
0000000000000000000000000000000000000000;;		w  io.Writer
0000000000000000000000000000000000000000;;		fs *stats.FollowerStats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		term      uint64
0000000000000000000000000000000000000000;;		index     uint64
0000000000000000000000000000000000000000;;		buf       []byte
0000000000000000000000000000000000000000;;		uint64buf []byte
0000000000000000000000000000000000000000;;		uint8buf  []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMsgAppV2Encoder(w io.Writer, fs *stats.FollowerStats) *msgAppV2Encoder {
0000000000000000000000000000000000000000;;		return &msgAppV2Encoder{
0000000000000000000000000000000000000000;;			w:         w,
0000000000000000000000000000000000000000;;			fs:        fs,
0000000000000000000000000000000000000000;;			buf:       make([]byte, msgAppV2BufSize),
0000000000000000000000000000000000000000;;			uint64buf: make([]byte, 8),
0000000000000000000000000000000000000000;;			uint8buf:  make([]byte, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (enc *msgAppV2Encoder) encode(m *raftpb.Message) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isLinkHeartbeatMessage(m):
0000000000000000000000000000000000000000;;			enc.uint8buf[0] = byte(msgTypeLinkHeartbeat)
0000000000000000000000000000000000000000;;			if _, err := enc.w.Write(enc.uint8buf); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case enc.index == m.Index && enc.term == m.LogTerm && m.LogTerm == m.Term:
0000000000000000000000000000000000000000;;			enc.uint8buf[0] = byte(msgTypeAppEntries)
0000000000000000000000000000000000000000;;			if _, err := enc.w.Write(enc.uint8buf); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// write length of entries
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint64(enc.uint64buf, uint64(len(m.Entries)))
0000000000000000000000000000000000000000;;			if _, err := enc.w.Write(enc.uint64buf); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < len(m.Entries); i++ {
0000000000000000000000000000000000000000;;				// write length of entry
0000000000000000000000000000000000000000;;				binary.BigEndian.PutUint64(enc.uint64buf, uint64(m.Entries[i].Size()))
0000000000000000000000000000000000000000;;				if _, err := enc.w.Write(enc.uint64buf); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n := m.Entries[i].Size(); n < msgAppV2BufSize {
0000000000000000000000000000000000000000;;					if _, err := m.Entries[i].MarshalTo(enc.buf); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if _, err := enc.w.Write(enc.buf[:n]); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if _, err := enc.w.Write(pbutil.MustMarshal(&m.Entries[i])); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				enc.index++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// write commit index
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint64(enc.uint64buf, m.Commit)
0000000000000000000000000000000000000000;;			if _, err := enc.w.Write(enc.uint64buf); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.fs.Succ(time.Since(start))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if err := binary.Write(enc.w, binary.BigEndian, msgTypeApp); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// write size of message
0000000000000000000000000000000000000000;;			if err := binary.Write(enc.w, binary.BigEndian, uint64(m.Size())); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// write message
0000000000000000000000000000000000000000;;			if _, err := enc.w.Write(pbutil.MustMarshal(m)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			enc.term = m.Term
0000000000000000000000000000000000000000;;			enc.index = m.Index
0000000000000000000000000000000000000000;;			if l := len(m.Entries); l > 0 {
0000000000000000000000000000000000000000;;				enc.index = m.Entries[l-1].Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enc.fs.Succ(time.Since(start))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type msgAppV2Decoder struct {
0000000000000000000000000000000000000000;;		r             io.Reader
0000000000000000000000000000000000000000;;		local, remote types.ID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		term      uint64
0000000000000000000000000000000000000000;;		index     uint64
0000000000000000000000000000000000000000;;		buf       []byte
0000000000000000000000000000000000000000;;		uint64buf []byte
0000000000000000000000000000000000000000;;		uint8buf  []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMsgAppV2Decoder(r io.Reader, local, remote types.ID) *msgAppV2Decoder {
0000000000000000000000000000000000000000;;		return &msgAppV2Decoder{
0000000000000000000000000000000000000000;;			r:         r,
0000000000000000000000000000000000000000;;			local:     local,
0000000000000000000000000000000000000000;;			remote:    remote,
0000000000000000000000000000000000000000;;			buf:       make([]byte, msgAppV2BufSize),
0000000000000000000000000000000000000000;;			uint64buf: make([]byte, 8),
0000000000000000000000000000000000000000;;			uint8buf:  make([]byte, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *msgAppV2Decoder) decode() (raftpb.Message, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			m   raftpb.Message
0000000000000000000000000000000000000000;;			typ uint8
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(dec.r, dec.uint8buf); err != nil {
0000000000000000000000000000000000000000;;			return m, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typ = uint8(dec.uint8buf[0])
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case msgTypeLinkHeartbeat:
0000000000000000000000000000000000000000;;			return linkHeartbeatMessage, nil
0000000000000000000000000000000000000000;;		case msgTypeAppEntries:
0000000000000000000000000000000000000000;;			m = raftpb.Message{
0000000000000000000000000000000000000000;;				Type:    raftpb.MsgApp,
0000000000000000000000000000000000000000;;				From:    uint64(dec.remote),
0000000000000000000000000000000000000000;;				To:      uint64(dec.local),
0000000000000000000000000000000000000000;;				Term:    dec.term,
0000000000000000000000000000000000000000;;				LogTerm: dec.term,
0000000000000000000000000000000000000000;;				Index:   dec.index,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// decode entries
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(dec.r, dec.uint64buf); err != nil {
0000000000000000000000000000000000000000;;				return m, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l := binary.BigEndian.Uint64(dec.uint64buf)
0000000000000000000000000000000000000000;;			m.Entries = make([]raftpb.Entry, int(l))
0000000000000000000000000000000000000000;;			for i := 0; i < int(l); i++ {
0000000000000000000000000000000000000000;;				if _, err := io.ReadFull(dec.r, dec.uint64buf); err != nil {
0000000000000000000000000000000000000000;;					return m, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				size := binary.BigEndian.Uint64(dec.uint64buf)
0000000000000000000000000000000000000000;;				var buf []byte
0000000000000000000000000000000000000000;;				if size < msgAppV2BufSize {
0000000000000000000000000000000000000000;;					buf = dec.buf[:size]
0000000000000000000000000000000000000000;;					if _, err := io.ReadFull(dec.r, buf); err != nil {
0000000000000000000000000000000000000000;;						return m, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					buf = make([]byte, int(size))
0000000000000000000000000000000000000000;;					if _, err := io.ReadFull(dec.r, buf); err != nil {
0000000000000000000000000000000000000000;;						return m, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.index++
0000000000000000000000000000000000000000;;				// 1 alloc
0000000000000000000000000000000000000000;;				pbutil.MustUnmarshal(&m.Entries[i], buf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// decode commit index
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(dec.r, dec.uint64buf); err != nil {
0000000000000000000000000000000000000000;;				return m, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.Commit = binary.BigEndian.Uint64(dec.uint64buf)
0000000000000000000000000000000000000000;;		case msgTypeApp:
0000000000000000000000000000000000000000;;			var size uint64
0000000000000000000000000000000000000000;;			if err := binary.Read(dec.r, binary.BigEndian, &size); err != nil {
0000000000000000000000000000000000000000;;				return m, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf := make([]byte, int(size))
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(dec.r, buf); err != nil {
0000000000000000000000000000000000000000;;				return m, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pbutil.MustUnmarshal(&m, buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dec.term = m.Term
0000000000000000000000000000000000000000;;			dec.index = m.Index
0000000000000000000000000000000000000000;;			if l := len(m.Entries); l > 0 {
0000000000000000000000000000000000000000;;				dec.index = m.Entries[l-1].Index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return m, fmt.Errorf("failed to parse type %d in msgappv2 stream", typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
